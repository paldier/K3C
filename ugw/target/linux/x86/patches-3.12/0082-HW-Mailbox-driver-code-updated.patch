From df623d8ec976b012cca43a3b7f1ed95d5730d098 Mon Sep 17 00:00:00 2001
From: Emmanuel Jillela <emmanuel.jillela@intel.com>
Date: Tue, 19 May 2015 16:24:01 -0700
Subject: [PATCH 082/441] HW Mailbox driver code updated.

---
 arch/x86/hw_mailbox/hw_mbox_defs.h       |  201 +-
 arch/x86/hw_mailbox/hw_mbox_drv.c        | 3556 ++++++++++++++++++++++++++----
 arch/x86/hw_mailbox/hw_mbox_mem_access.h |  157 +-
 3 files changed, 3442 insertions(+), 472 deletions(-)

--- a/arch/x86/hw_mailbox/hw_mbox_defs.h
+++ b/arch/x86/hw_mailbox/hw_mbox_defs.h
@@ -10,7 +10,7 @@
 
   GPL LICENSE SUMMARY
 
-  Copyright(c) 2014 Intel Corporation.
+  Copyright(c) 2014-2015 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify 
   it under the terms of version 2 of the GNU General Public License as
@@ -35,7 +35,7 @@
 
   BSD LICENSE 
 
-  Copyright(c) 2014 Intel Corporation. All rights reserved.
+  Copyright(c) 2014-2015 Intel Corporation. All rights reserved.
 
   Redistribution and use in source and binary forms, with or without 
   modification, are permitted provided that the following conditions 
@@ -119,14 +119,23 @@ typedef enum hw_mbox_type
 {
     hw_mbox_command = 0,  /* Command */
     hw_mbox_event,        /* Event   */
+    hw_mbox_opcode,       /* Opcode (generic HW MBOX command-response protocol) */
+
+    HW_MBOX_TYPE_COUNT    /* Should always be last... */
 } hw_mbox_type_e;
 
 /*! \def HW_MBOX_TYPE_STR(mboxType)
     \brief gets a string according to <mboxType>
     \attention <mboxType> should be a value from hw_mbox_type_e 
 */
-#define HW_MBOX_TYPE_STR(mboxType)    ((mboxType == hw_mbox_event)?("Event"):("Command"))
+#define HW_MBOX_TYPE_STR(mboxType)    ( (mboxType == hw_mbox_command)?("Command"): \
+                                        ((mboxType == hw_mbox_event)?("Event"):("Opcode")) )
 
+/*! \def HW_MBOX_DEFAULT_TIMEOUT_SEC
+    \brief Default timeout value in seconds.
+    \note can comment out define to set wait forever.
+    \attention wait forever setting should only be used for debug! 
+*/
 #define HW_MBOX_DEFAULT_TIMEOUT_SEC    10  /* 10 sec */
 
 /* Error Notification: */
@@ -148,6 +157,10 @@ typedef enum hw_mbox_type
 
 #define HW_MBOX_STRINGIFY(x)    #x
 
+#ifndef BIT
+#define BIT( _i )       (1UL << ( _i ))
+#endif
+
 /**********************************************
 |                                             |
 |        HW_MBOX Package Configuration        |
@@ -257,6 +270,7 @@ enum { HW_MBOX_HARDCODED_MID = HW_MBOX_M
 #include "_tistdtypes.h"
 #elif defined HW_MBOX_IS_APP_CPU
 typedef uint32_t Uint32;
+typedef int32_t  Int32;
 typedef uint8_t  Uint8;
 typedef bool     Bool;
 #define True true
@@ -359,12 +373,28 @@ typedef struct hw_mbox_masterConfig
 /* Master Table Expander Wrappers: */
 
 /*! \def HW_MBOX_MASTER_TABLE_STRS
-    \brief wrapper for HW_MBOX_MASTER_TABLE_AS_STRS.
+    \brief Creates an string array with HW MBOX Masters names.
     \note "<_desc0>", "<_desc1>", ... [so we need] '\0' for array syntax and proper array null termination.
-    \note intializes a char* array.
-    \attention only create inside c file.
+    \note creates and initializes a static char * array with name <_arrayName>.
+    \attention only use inside c file.
 */
-#define HW_MBOX_MASTER_TABLE_STRS    HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_STRS) '\0'
+#define HW_MBOX_MASTER_TABLE_STRS( _arrayName ) \
+    static const char *_arrayName[] =                      \
+    {                                                      \
+        HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_STRS) \
+        '\0'                                               \
+    }
+
+/*! \def HW_MBOX_MASTER_TABLE_DB( _arrayName )
+    \brief Creates a hw_mbox_masterConfig_t array with HW MBOX Masters Data.
+    \note creates and initializes a static hw_mbox_masterConfig_t array with name <_arrayName>.
+    \attention only use inside c file.
+*/
+#define HW_MBOX_MASTER_TABLE_DB( _arrayName ) \
+    static const hw_mbox_masterConfig_t _arrayName[] =     \
+    {                                                      \
+        HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_DB)   \
+    }
 
 /*! \def HW_MBOX_MASTER_TABLE_COUNT
     \brief wrapper for HW_MBOX_MASTER_TABLE_AS_COUNT.
@@ -411,7 +441,7 @@ typedef enum hw_mbox_Masters
 /** --------------------------------------- **/
 
 /*! \def HW_MBOX_RECENT_COMMAND_LOG    <Command_Count>
-    \brief How many recent commands should be save.
+    \brief How many recent commands should be saved.
     \attention use a value > 0.
     \note Feature is OPTIONAL, comment out define to disable.
     \note Monitor Thread is in-charge of updating the Log.
@@ -419,21 +449,138 @@ typedef enum hw_mbox_Masters
 //#define HW_MBOX_RECENT_COMMAND_LOG    16
 
 #ifdef HW_MBOX_RECENT_COMMAND_LOG
+
 /* Argument Sanity Check: */
 #if (HW_MBOX_RECENT_COMMAND_LOG <= 0)
 #   error "HW_MBOX RECENT COMMAND LOG: Command Count Must be > 0!" 
 #endif
 
-/*! \def HW_MBOX_RECENT_COMMAND_LOG_ARRAY_ENTRY_COUNT
-    \brief How many entries we should have in the array.
-    \note (+2) Total addition to guarantee we always have an amount of <HW_MBOX_RECENT_COMMAND_LOG> valid entries:
-    \note (+1) entry for NULL termination.
-    \note (+1) entry as one is invalidated in the update process.
-    \note This guarantee obviously applies only after at least <HW_MBOX_RECENT_COMMAND_LOG> commands were actually logged (one buffer fill up).
-*/
-#define HW_MBOX_RECENT_COMMAND_LOG_ARRAY_ENTRY_COUNT    ((HW_MBOX_RECENT_COMMAND_LOG) + 1 + 1)
-#endif // HW_MBOX_RECENT_COMMAND_LOG
-#endif // HW_MBOX_OS_LINUX
+/*! \def HW_MBOX_RECENT_COMMAND_LOG_INDEX_INVALID
+    \brief invalid index for the recent command log and snapshot log.
+*/
+#define HW_MBOX_RECENT_COMMAND_LOG_INDEX_INVALID    (-1)
+#endif /* HW_MBOX_RECENT_COMMAND_LOG */
+#endif /* HW_MBOX_OS_LINUX */
+
+/****************************************************
+|                                                   |
+|        HW_MBOX Opcode                             |
+|        (generic command-response protocol)        |
+|                                                   |
+****************************************************/
+
+/* HW MBOX OPCODE: a generic command-response protocol
+
+   OPCODE type channels exist to implement a generic command-response
+   sequence that can be used by package customers. The protocol predefines
+   the structure of the values that are to be written to command channel
+   register. While enabling less freedom to applications it enables the
+   construction of generic entities that can be used for message dispatching
+   without relying completely on application context. OPCODE type channels 
+   enable inherent support for several applications on the same channel.
+*/
+
+/* The Fields that OPCODE channel uses are:
+ 
+   TAG - indicates the application that is the destination of the code.
+         Note: TAG == 0xFF and 0xFE are reserved for HW MBOX usage.
+ 
+   CODE - code of the command (per TAG, defined by applicative context).
+ 
+   FLAG A/B - 2 reserved flags [for internal use].
+
+   LEN - How many words are to be read from SRAM (opcode Data).
+         [LEN is integral multiple of 4 Bytes so we can use word count].
+
+   exact Field division is defined in mem_access file.
+*/
+
+/*! \var typedef struct hwMbox_opcode hwMbox_opcode_t
+    \brief struct for opcode fields. 
+    \note the types used here sometimes have more capacity than actual max value. 
+*/
+typedef struct hwMbox_opcode
+{
+    Uint32  tag;
+    Uint32  code;
+    Bool    flagA;
+    Bool    flagB;
+    Uint32  lenInBytes;
+} hwMbox_opcode_t;
+
+/* Field Bit Length definitions:
+   [These are done here so max value can be calculated and used here...] 
+
+   Note: if value change please update also corresponding documentation 
+   in mem access.
+*/
+
+#define HW_MBOX_OPCODE_TAG_BITLEN    (8)
+
+#define HW_MBOX_OPCODE_CODE_BITLEN   (12)
+
+/*! \def HW_MBOX_OPCODE_TAG_MAX_VALUE 
+    \brief Max value available for tag field when using OPCODE. */
+#define HW_MBOX_OPCODE_TAG_MAX_VALUE    (BIT(HW_MBOX_OPCODE_TAG_BITLEN) - 1)
+
+/*! \def HW_MBOX_OPCODE_CODE_MAX_VALUE 
+    \brief Max value available for code field when using OPCODE. */
+#define HW_MBOX_OPCODE_CODE_MAX_VALUE   (BIT(HW_MBOX_OPCODE_CODE_BITLEN) - 1)
+
+#define HW_MBOX_OPCODE_TAG                0xFF /*! Reserved TAG value for Kernel HW MBOX */
+#define HW_MBOX_OPCODE_USER_SPACE_TAG     0xFE /*! Reserved TAG value for User-Space HW MBOX */
+
+/*! \var typedef enum hwMbox_code hwMbox_code_e
+    \brief This enum denotes codes of internal administrative HW MBOX 
+           commands to be sent on opcode channel.
+*/
+typedef enum hwMbox_code
+{
+    HW_MBOX_CODE_INIT_COMPLETE = 0,    /* init complete code [sent to other Masters by supervisor]. */
+    HW_MBOX_CODE_PING,                 /* ping SW support on other end */
+
+    HW_MBOX_CODE_COUNT    /* Should always be last... */
+} hwMbox_code_e;
+
+/*! \var typedef enum hwMbox_opcodeReturnCode hwMbox_opcodeReturnCode_e
+    \brief This enum denotes return codes of an opcode channel.
+*/
+typedef enum hwMbox_opcodeReturnCode
+{
+    HW_MBOX_OPCODE_RC_OK = 0,
+
+    HW_MBOX_OPCODE_RC_NOT_INITIALIZED_YET = 0x100,
+    HW_MBOX_OPCODE_RC_INVALID_TAG,
+    HW_MBOX_OPCODE_RC_INVALID_CODE,
+    HW_MBOX_OPCODE_RC_CALLBACK_FAILED,
+    HW_MBOX_OPCODE_RC_REPLY_TOO_LONG,
+
+    HW_MBOX_OPCODE_RC_NOK = HW_MBOX_OPCODE_CODE_MAX_VALUE /* this should be last... */
+} hwMbox_opcodeReturnCode_e;
+
+#define HW_MBOX_OPCODE_RECV_COUNT    10 /*! max amount of recv opcode channels per Master. */
+#define HW_MBOX_OPCODE_TAG_COUNT     10 /*! max amount of tags that can be registered per RecvOpcode channel. */
+
+/*! \typedef int (*hwMboxRecvOpcodeCallback)(hw_mbox_Masters_e commander,
+                                             Uint32 code,
+                                             Uint8 *dataBuf, Uint32 dataLen,
+                                             Uint32 *token)
+    \brief prototype for receive opcode channels callback function pointers, to be
+           invoked by Receive Opcode Listeners upon incoming opcode.
+    \param[in]     commander - Master from which the opcode has been received.
+    \param[in]     code - code of the opcode that has been received.
+    \param[in,out] dataBuf - data of the opcode that has been received.
+    \param[in]     dataLen - Length in bytes of <dataBuf>.
+    \param[in,out] token - 32 bit saved in DB upon registering the callback,
+                           modifiable by the callback.
+    \note return value (-1) is reserved to indicate generic error, use token
+          to output an error from <hwMbox_opcodeReturnCode_e>, it will be sent
+          to the commander and the sendOpcode service it invoked will fail.
+*/
+typedef int (*hwMboxRecvOpcodeCallback)(hw_mbox_Masters_e commander,
+                                        Uint32 code,
+                                        Uint8 *dataBuf, Uint32 dataLen,
+                                        Uint32 *token);
 
 /********************************************
 |                                           |
@@ -489,8 +636,11 @@ typedef struct hw_mbox_channelConfig
     ENTRY(    3  , HW_MBOX_MASTER_BBU_C                , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
     ENTRY(    4  , HW_MBOX_MASTER_DS_PHY_CPU           , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
     ENTRY(    5  , HW_MBOX_MASTER_MOCA_C               , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
-    ENTRY(    6  , HW_MBOX_MASTER_APP_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_command          , 0         )    \
-    ENTRY(    7  , HW_MBOX_MASTER_APP_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )
+    ENTRY(    6  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_opcode           , 8         )    \
+    ENTRY(    7  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_APP_CPU              , hw_mbox_opcode           , 8         )    \
+    ENTRY(    8  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_DS_PHY_CPU           , hw_mbox_opcode           , 8         )    \
+    ENTRY(    9  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_opcode           , 8         )    \
+    ENTRY(   10  , HW_MBOX_MASTER_APP_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_opcode           , 8         )
 
 /* static channel Table Expanders: */
 
@@ -508,6 +658,17 @@ typedef struct hw_mbox_channelConfig
 
 /* static channel Table Expander Wrappers: */
 
+/*! \def HW_MBOX_STATIC_CHANNEL_TABLE_DB( _arrayName )
+    \brief Creates a hw_mbox_channelConfig_t array with HW MBOX static channels Data.
+    \note creates and initializes a static hw_mbox_channelConfig_t array with name <_arrayName>.
+    \attention only use inside c file.
+*/
+#define HW_MBOX_STATIC_CHANNEL_TABLE_DB( _arrayName ) \
+    static const hw_mbox_channelConfig_t _arrayName[] =                    \
+    {                                                                      \
+        HW_MBOX_STATIC_CHANNEL_TABLE(HW_MBOX_STATIC_CHANNEL_TABLE_AS_DB)   \
+    }
+
 /*! \def HW_MBOX_STATIC_CHANNEL_COUNT
     \brief wrapper for HW_MBOX_STATIC_CHANNEL_TABLE_AS_COUNT.
     \note 1+ 1+ ... [so we need] 0 for syntax.
@@ -519,4 +680,4 @@ typedef struct hw_mbox_channelConfig
 #   error "HW_MBOX STATIC CHANNELS: entry count in the table exceeds the total Channel Count!"
 #endif
 
-#endif // !_HW_MBOX_DEFS_H_
+#endif /* ! _HW_MBOX_DEFS_H_ */
--- a/arch/x86/hw_mailbox/hw_mbox_drv.c
+++ b/arch/x86/hw_mailbox/hw_mbox_drv.c
@@ -7,7 +7,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- *  Copyright(c) 2014 Intel Corporation.
+ *  Copyright(c) 2014-2015 Intel Corporation.
  *
  *  This program is free software; you can redistribute it and/or modify 
  *  it under the terms of version 2 of the GNU General Public License as
@@ -47,11 +47,13 @@
 #include <linux/seq_file.h>
 #include <linux/device.h>
 #include <linux/cdev.h>     /* cdev utilities */
+#include <linux/slab.h>
 #include <linux/wait.h>
 #include <linux/sched.h>
 #include <linux/poll.h>
-#include <linux/slab.h>
-#include <linux/kern_levels.h>
+#include <linux/jiffies.h>      /* jiffies */
+#include <linux/kthread.h>      /* Kernel Threads */
+#include <linux/delay.h>        /* for usleep_range */
 
 #include <linux/netip_subsystem.h>
 #include "hw_mbox_defs.h"        /* HW_MBOX definitions and configuration */
@@ -60,10 +62,26 @@
 #ifdef HW_MBOX_IS_NP_CPU
 #include "puma7.h"       /* for irq number */
 #endif
+
 #ifdef HW_MBOX_IS_APP_CPU
 /* Include file with irq number */ 
 #endif
 
+#ifdef HW_MBOX_IS_APP_CPU
+/* APP-CPU gets HW MBOX Interrupts as MSI messages triggered upon rising edge of the HW MBOX
+   interrupt line [as sampled by the bridge]. Reading the Interrupt Status Register resets its
+   value [all unmasked bits] and de-asserts the interrupt line. If the line is re-asserted
+   immediately after, the bridge might not be able to sample again and there will not be
+   another MSI message. To handle this issue we read the Interrupt Status Registers in
+   the ISR until there are no more new channel interrupts...
+
+   Note: as we are reading the Interrupt Status Registers again in the same ISR if the bridge was
+         able to sample the re-assertion there will be an MSI message that will be interpreted
+         as a ghost interrupt [reading will get no set unmasked bits].
+*/
+#define APP_CPU_HW_MBOX_IRQ_SAMPLE_CLK_WA
+#endif /* HW_MBOX_IS_APP_CPU */
+
 /************************************************************************/
 /*     Defines and Macros                                               */
 /************************************************************************/
@@ -71,13 +89,13 @@
 //#define HW_MBOX_KDBG /*! Use this define to toggle HW_MBOX kernel debug prints */
 #ifdef HW_MBOX_KDBG
 /* note: prints Module header and '\n' is included inside */
-#  define DPRINTK(fmt, args...) printk("HW_MBOX_KDBG: " fmt "\n" , ## args)
+#  define DPRINTK(fmt, args...) printk("HW_MBOX_KDBG[%s:%d]: " fmt "\n" , __FUNCTION__, __LINE__, ## args)
 #else
-#  define DPRINTK(fmt, args...)
+#  define DPRINTK(fmt, args...) do{ } while(0)
 #endif
 
 #define PRINTK_INFO(fmt, args...) printk(KERN_INFO "HW_MBOX_KERNEL_INFO: " fmt "\n" , ## args)
-#define PRINTK_ERR(fmt, args...)  printk(KERN_ERR  "HW_MBOX_KERNEL_ERROR(%s:%d): " fmt "\n" , __FUNCTION__, __LINE__, ## args)
+#define PRINTK_ERR(fmt, args...)  printk(KERN_ERR  "HW_MBOX_KERNEL_ERROR[%s:%d]: " fmt "\n" , __FUNCTION__, __LINE__, ## args)
 
 /* General Macros: */
 
@@ -92,7 +110,15 @@
 #define CONCAT2(a, b)   a ## b
 #endif
 
-/* HW_MBOX driver Macros and Defines:  */
+#ifndef SEC_TO_MSEC
+#define SEC_TO_MSEC( _valueInSec )      (( _valueInSec ) * 1000)
+#endif
+
+#ifndef min
+#define min( _a, _b )      ((( _a ) < ( _b ))?( _a ):( _b ))
+#endif
+
+/*** HW_MBOX driver Macros and Defines:  ***/
 
 /*! \def HW_MBOX_INT_LINE
     \brief irq number of the HW_MBOX. */
@@ -131,7 +157,7 @@
     \brief List all HW_MBOX Master names listed by MID: "<_desc>"
     \attention use HW_MBOX_MASTER_GET_NAME() to access.
 */
-static const char *HW_MBOX_MASTER_STRS[] = { HW_MBOX_MASTER_TABLE_STRS };
+HW_MBOX_MASTER_TABLE_STRS(HW_MBOX_MASTER_STRS);
 
 /*! \def HW_MBOX_MASTER_GET_NAME(paramMID)
     \brief Get Name of HW_MBOX Master by MID. */
@@ -144,7 +170,7 @@ static const char *HW_MBOX_MASTER_STRS[]
     \note index in the array is the MID.
     \attention use HW_MBOX_MASTER_GET_CONFIG() to access.
 */
-static const hw_mbox_masterConfig_t HW_MBOX_MASTER_CONFIG[HW_MBOX_MASTER_COUNT] = { HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_DB) };
+HW_MBOX_MASTER_TABLE_DB(HW_MBOX_MASTER_CONFIG);
 
 /*! \def HW_MBOX_MASTER_GET_CONFIG(paramMID)
     \brief Gets a Master's configuration.
@@ -159,7 +185,7 @@ static const hw_mbox_masterConfig_t HW_M
     \note index in the array is NOT the CID.
     \attention use HW_MBOX_STATIC_CHANNEL_GET_CONFIG() to access.
 */
-static const hw_mbox_channelConfig_t HW_MBOX_STATIC_CHANNEL_CONFIG[HW_MBOX_STATIC_CHANNEL_COUNT] = { HW_MBOX_STATIC_CHANNEL_TABLE(HW_MBOX_STATIC_CHANNEL_TABLE_AS_DB) };
+HW_MBOX_STATIC_CHANNEL_TABLE_DB(HW_MBOX_STATIC_CHANNEL_CONFIG);
 
 /*! \def HW_MBOX_STATIC_CHANNEL_GET_CONFIG(staticChannelIndex)
     \brief Gets a static Channel's configuration.
@@ -167,173 +193,290 @@ static const hw_mbox_channelConfig_t HW_
 */
 #define HW_MBOX_STATIC_CHANNEL_GET_CONFIG(staticChannelIndex)    HW_MBOX_STATIC_CHANNEL_CONFIG[staticChannelIndex]
 
-/************************************************************************/
-/*     HW_MBOX Channel Interrupt Devices:                               */
-/************************************************************************/
+/**************************************************************************/
+/*      LOCAL GENERAL DRIVER VARIABLES:                                   */
+/**************************************************************************/
+
+/*! \var static bool isInitialized
+    \brief to be set when driver is fully initialized.
+    \note use bool to be consistent with module_param macro.
+*/
+static bool isInitialized = false;
+module_param(isInitialized, bool, S_IRUGO); /* read-only 'cat'-able kernel param */
 
-/*  Channel interrupt Devices Defines and Structures: */
+/*! \var static wait_queue_head_t waitForInitializedWq
+    \brief used for channel device blocking open operation.
+*/
+static DECLARE_WAIT_QUEUE_HEAD(waitForInitializedWq);
 
-/*! \var typedef struct chnint chnint_t
-    \brief Channel Interrupt Device structure. */
-typedef struct chnint 
-{
-    Uint32              chn_cid;           /* CID of the channel this device is reporting about */
-    Uint32              interruptPending;  /* if CHN_INT_PENDING then there's an interrupt on channel CID else CHN_INT_NONE */
-    wait_queue_head_t   chnint_rqueue;     /* unsatisfied read from device sleeps on it */
-    struct cdev         chnint_cdev;       /* channel's char device structure */
-} chnint_t;
+/*! \def SET_INITIALIZED()
+    \brief use once the driver is initialized and ready.
+    \note also wakes up any process that opened a device in a blocking
+          manner prior to driver initialization.
+*/
+#define SET_INITIALIZED() \
+do{ \
+    isInitialized =  true;                                \
+    /* since the sleeps are not exclusive also the non */ \
+    /* _all variant will wake up all... */                \
+    wake_up_interruptible_all(&waitForInitializedWq);     \
+} while (0)
 
-#define CHN_INT_NONE       0  /* use with interruptPending field of the chnint devices, this value means that there's no interrupt on the device */
-#define CHN_INT_PENDING    1  /* use with interruptPending field of the chnint devices, this value means that there is an interrupt on the device */
+#define IS_INITIALIZED()    ( isInitialized == true )
 
-/*! \var static dev_t chnint_dev
-    \brief The first channel interrupt device that will be created, Contains major and first minor number.
-    \note This is the reference point for allocation of all other devices and the chrdev region. */
-static dev_t chnint_dev;
+/*! \def CHECK_IS_DRV_INITIALIZED( __noNotInitialized )
+    \brief use to check if the driver is initialized, if it is not 
+           execute __noNotInitialized.
+    \param[in] __noNotInitialized - executed in case of driver not
+                                    initialized.
+*/
+#define CHECK_IS_DRV_INITIALIZED( __noNotInitialized ) \
+do{ \
+    if (!IS_INITIALIZED())                      \
+    {                                           \
+        DPRINTK("Driver not initialized yet!"); \
+        __noNotInitialized;                     \
+    }                                           \
+} while (0)
 
-/* Channel interrupt Devices Function Declarations: */
+/*! \var static Bool isInitComplete
+    \brief to be set when supervisor finishes initial configuration of
+           the HW MBOX.
+    \note non supervisor receives notification via opcode channel.
+*/
+static Bool isInitComplete = False;
 
-#if defined HW_MBOX_IS_NP_CPU
-/* File Operations: */
-static int chnint_open(struct inode *inode, struct file *filp);
-static ssize_t chnint_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
-static unsigned int chnint_poll(struct file *filp, struct poll_table_struct *wait);
-static int chnint_release(struct inode *inode, struct file *filp);
-#endif
+/*! \var static wait_queue_head_t waitForInitCompleteWq
+    \brief used to wait for init Complete by supervisor.
+    \note used by the first recvOpcode listener to wait for init Complete
+          notification from supervisor.
+*/
+static DECLARE_WAIT_QUEUE_HEAD(waitForInitCompleteWq);
 
-static void chnint_cleanup(int count);
+#define IS_INIT_COMPLETE()    (isInitComplete == True)
 
-/* Channel interrupt Devices Local Variables: */
+/*! \def SET_INIT_COMPLETE()
+    \brief use once the supervisor finished HW MBOX initial configuration.
+*/
+#define SET_INIT_COMPLETE() \
+do{ \
+    isInitComplete =  True;                               \
+    /* since the sleeps are not exclusive also the non */ \
+    /* _all variant will wake up all... */                \
+    wake_up_interruptible_all(&waitForInitCompleteWq);    \
+} while (0)
 
+#if defined(HW_MBOX_DEBUG) && defined(HW_MBOX_KDBG)
+/*! \var static bool enableDevicePrintk
+    \brief to be set when verbose device prints are required.
+    \note use bool to be consistent with module_param macro.
+*/
+static bool enableDevicePrintk = false;
+module_param(enableDevicePrintk, bool, S_IRUGO | S_IWUSR); /* read/write 'cat/echo'-able kernel param */
 
-#if defined HW_MBOX_IS_NP_CPU
-/*! \var static struct class *chnint_class
-    \brief Channel interrupt devices class. */
-static struct class *chnint_class;
-#endif
+#define IS_DEV_PRINTK_ENABLED()    ( enableDevicePrintk == true )
 
-/*! \var static chnint_t *chnint_devices
-    \brief Array of all the channel interrupt Device structures, one entry per channel.
-    \note Index in the array is the CID of the device. */
-static chnint_t *chnint_devices;    /* one char device per channel */    
+/*! \def DEV_PRINTK(fmt, args...)
+    \brief verbose debug prints for the char devices, enabled by module param.
+    \note prints are disabled by default, change <enableDevicePrintks> module params
+          to enable the prints.
+    \attention feature is only available when HW_MBOX_DEBUG precompilation flag is set.
+*/
+#   define DEV_PRINTK(fmt, args...) \
+do{ \
+    if ( IS_DEV_PRINTK_ENABLED() )              \
+    {                                           \
+        DPRINTK("DEV_PRINTK: " fmt , ## args);  \
+    }                                           \
+} while (0)
+#else
+#   define DEV_PRINTK(fmt, args...) do{ } while(0)
+#endif /* HW_MBOX_DEBUG && HW_MBOX_KDBG */
 
-#if defined HW_MBOX_IS_NP_CPU
-/*! \var static struct file_operations chnint_fops
-    \brief file operations structure for the channel interrupt devices. */
-static struct file_operations chnint_fops = {
-    .owner      = THIS_MODULE,
-    .read       = chnint_read,
-    .poll       = chnint_poll,
-    .open       = chnint_open,
-    .release    = chnint_release,
-};
+/************************************************************************/
+/*     HW_MBOX Kernel Defines & Types                                   */
+/************************************************************************/
 
-/* Channel interrupt Devices Functions Definations: */
+/*** Channel Interrupts: ***/
 
-/* File Operations: */
+#define CHN_INTR_NO_TIMEOUT  (-1)
 
-static int chnint_open(struct inode *inode, struct file *filp)
+#ifdef HW_MBOX_DEFAULT_TIMEOUT_SEC
+#define CHN_INTR_DEFAULT_TIMEOUT_MSEC   SEC_TO_MSEC(HW_MBOX_DEFAULT_TIMEOUT_SEC)
+#else
+#define CHN_INTR_DEFAULT_TIMEOUT_MSEC   CHN_INTR_NO_TIMEOUT /* no Timeout: Used for debug */
+#endif /* HW_MBOX_DEFAULT_TIMEOUT_SEC */
+
+/*! \var typedef enum chnIntrReturnCodes chnIntrReturnCodes_e
+    \brief return codes for channel interrupts */
+typedef enum chnIntrReturnCodes 
 {
-    chnint_t *dev;
-    dev = container_of(inode->i_cdev, chnint_t, chnint_cdev);
-    DPRINTK("chnint_open dev %p, chn_cid %d", dev, dev->chn_cid);
-    DPRINTK("filp=%p", filp);
-    filp->private_data = dev;   /* store for future use */
-    return 0;
-}
+    CHN_INTR_RC_OK = 0,
+    CHN_INTR_RC_NOK = -1,
 
-static ssize_t chnint_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+    CHN_INTR_RC_INTERRUPTED_BY_SIGNAL = 0x100,
+    CHN_INTR_RC_TIMEOUT_EXPIRED,
+    CHN_INTR_RC_NOT_INITIALIZED_YET
+} chnIntrReturnCodes_e;
+
+/*! \var typedef enum chnIntrState chnIntrState_e
+    \brief Channel Interrupt state. */
+typedef enum chnIntrState 
 {
-    chnint_t *dev = filp->private_data; /* dev was stored in filp during open */
+    CHN_INTR_STATE_NONE = 0,
+    CHN_INTR_STATE_PENDING
+} chnIntrState_e;
+
+/*! \var typedef struct chnIntr chnIntr_t
+    \brief Channel Interrupt abstraction. */
+typedef struct chnIntr
+{
+    wait_queue_head_t       waitQueue; /* wait queue for channel interrupts */
+    chnIntrState_e          state;     /* indicates channel interrupt state */
+} chnIntr_t;
 
-    DPRINTK("chnint_read dev %p, chn_cid %d, interruptPending=%d", dev, dev->chn_cid, dev->interruptPending);
-    DPRINTK("filp=%p, count=%u, *f_pos=%lld", filp, count, (long long)*f_pos);
+/*! \var typedef struct chnint chnint_t
+    \brief Channel Interrupt Device structure. */
+typedef struct chnint 
+{
+    Uint32              chn_cid;      /* CID of the channel this device is connected to */
+    struct cdev         chnint_cdev;  /* channel's char device structure */
+} chnint_t;
 
-    if (wait_event_interruptible(dev->chnint_rqueue, dev->interruptPending != CHN_INT_NONE))
-    {
-        return -EINTR;
-    }
+/*** Receive Opcode Infrastructure: ***/
 
-    if (copy_to_user(buf, &dev->interruptPending, sizeof(dev->interruptPending)))
-    {
-        return -EFAULT;
-    }
+#define RECV_OPCODE_LISTENER_PREFIX    "hwMboxKRecvOp" /*! thread name prefix */
 
-    dev->interruptPending = CHN_INT_NONE;
-    *f_pos += sizeof(dev->interruptPending);
-    return sizeof(dev->interruptPending);
-}
+/*! \def RECV_OPCODE_INIT_INDEX
+    \brief on non-supervisor the first opcode listener is used to continue the 
+           driver initialization process.
+*/
+#define RECV_OPCODE_INIT_INDEX      0
 
-static unsigned int chnint_poll(struct file *filp, struct poll_table_struct *wait)
+/*! \var typedef struct recvOpcodeListenerThreadData recvOpcodeListenerThreadData_t
+    \brief data relevant to the recieve opcode listener. */
+typedef struct recvOpcodeListenerThreadData
 {
-    chnint_t *dev = filp->private_data; /* dev was stored in filp during open */
-    unsigned int mask = 0;
-    DPRINTK("chnint_poll dev %p, chn_cid %d: poll Check interruptPending=%d", dev, dev->chn_cid, dev->interruptPending);
-    DPRINTK("filp=%p", filp);
-    poll_wait(filp, &dev->chnint_rqueue, wait);
-    if (dev->interruptPending != CHN_INT_NONE)
-    {
-        DPRINTK("chnint_poll dev %p, chn_cid %d waked up", dev, dev->chn_cid);
-        mask |= POLLIN | POLLRDNORM; /* readable */
-    }
-    DPRINTK("chnint_poll dev %p, chn_cid %d: mask=0x%08x", dev, dev->chn_cid, mask);
-    return mask;
-}
-
-static int chnint_release(struct inode *inode, struct file *filp)
+    Uint32 index;
+    Uint32 cid;
+} recvOpcodeListenerThreadData_t;
+
+/*! \var typedef struct recvOpcodeRegisteredTag recvOpcodeRegisteredTag_t
+    \brief A single entry registered by application. */
+typedef struct recvOpcodeRegisteredTag
 {
-#ifdef HW_MBOX_KDBG
-    chnint_t *dev;
-    dev = container_of(inode->i_cdev, chnint_t, chnint_cdev);
-#endif
-    DPRINTK("chnint_release: dev %p, chn_cid %d", dev, dev->chn_cid);
-    return 0;
-}
-#endif
+    Uint32                      tag;
+    hwMboxRecvOpcodeCallback    callbackFunc;
+    Uint32                      token;
+
+    /* statistics: */
+    Uint32                  opcodeCount; /* counts opcodes that arrived with this tag */
+} recvOpcodeRegisteredTag_t;
+
+/*! \var typedef struct recvOpcodeInfrastructure recvOpcodeInfrastructure_t
+    \brief required infrastructure for receive opcode channels. */
+typedef struct recvOpcodeInfrastructure
+{
+    struct task_struct              *listenerThread;
+    recvOpcodeRegisteredTag_t       registeredTags[HW_MBOX_OPCODE_TAG_COUNT];
 
-/*! \fn static void chnint_cleanup(int count) 
-    \brief use to clean up the Channel Interrupt devices.
-    \param[in] count - amount of devices to clean up. 
-    \note also clears the chrdev region. 
-*/
-static void chnint_cleanup(int count)
+    chnIntr_t appWq; /* Application's wait queue */
+
+    Uint32 registeredCount; /* amount of registered tags/applications */
+
+    /* statistics: */
+    Uint32 wakeupCount;     /* counts listener thread wake ups */
+    Uint32 invalidTagCount; /* counts opcodes that arrived with an invlaid tag */
+} recvOpcodeInfrastructure_t;
+
+/*! \var typedef struct statistics statistics_t
+    \brief HW MBOX statistics. */
+typedef struct hwMbox_statistics
 {
-    int i;
-    DPRINTK("cleanup function, count=%d", count);
-    if (chnint_devices)
-    {
-        for (i = 0; i < count; i++)
-        {
-            cdev_del(&chnint_devices[i].chnint_cdev);
-        }
-        kfree(chnint_devices);
-    }
-    unregister_chrdev_region(chnint_dev, HW_MBOX_CHANNEL_COUNT);
-}
+    /* Service Counters:
+       How many times each service was invoked.
+       Note: Sizing and dimensions are the same as CID LUT.
+    */
+    Uint32 serviceCounters[HW_MBOX_MASTER_COUNT][HW_MBOX_TYPE_COUNT << 1];
+} hwMbox_statistics_t; 
+
+/************************************************************************/
+/*     HW_MBOX Kernel Local Declarations                                */
+/************************************************************************/
+
+static int hwMbox_initAfterStarted(void);
+static int hwMbox_setChannelConfig(hw_mbox_channelConfig_t config);
+static int hwMbox_setChannelValid(Uint32 paramCID, Bool isValid);
+static int hwMbox_waitForChannelInterrupt(int cid, int timeoutInMsec);
 
+static int hwMbox_recvOpcodeListenerEntry(void *data);
 
 /************************************************************************/
 /*     HW_MBOX driver data                                              */
 /************************************************************************/
 
+/*! \var typedef struct ctrlDb ctrlDb_t
+    \brief holds general control information. */
+typedef struct ctrlDbEntry
+{
+    Uint32 coreVerMajor;
+    Uint32 coreVerMinor;
+
+    hw_mbox_Masters_e supervisor;
+    hw_mbox_Masters_e monitor;    /* if is HW_MBOX_MID_INVALID then no monitor is defined */
+
+    Bool isHwDebugMode; /* is in HW Debug Mode? */
+    Bool isStarted;     /* is Started? (initial configuration by supervisor done) */
+    Bool isLocked;      /* is Locked? (once set configuration is fixed, value cannot be changed once set) */
+} ctrlDbEntry_t;
+
+/*! \var typedef struct masterDbEntry masterDbEntry_t
+    \brief a single Master entry in driver DB. */
+typedef struct masterDbEntry
+{
+    Bool valid;         /* flag is set if Master is valid (Not fused out and has HW_MBOX SW support) */
+    Bool initialized;   /* flag is set once Master responds to the initial command the supervisor sends [to notify the Masters that HW MBOX is started...] */
+
+    hw_mbox_masterConfig_t config; /* Master's configuration */
+
+    Uint32 errorCount;  /* only relevant for supervisor [currently only incremented in User-Space] */
+} masterDbEntry_t; 
+
+/*! \var typedef struct chnDbEntry chnDbEntry_t
+    \brief a single channel entry in driver DB. */
+typedef struct chnDbEntry
+{
+    Bool assigned;         /* flag is set once configuration has been written */
+    Bool valid;            /* flag is set once channel is valid and can be used by Master */
+    Bool isInitChannel;    /* special flag that marks that this is a channel for initial configuration */
+
+    hw_mbox_channelConfig_t config;     /* Channel's configuration */
+
+    Uint32      intrCount;       /* count channel interrupts */
+    Uint32      recvOpcodeIndex; /* indicates relevant entry in recvOpData [only relevant for recvOpcode] */
+} chnDbEntry_t; 
+
+/*! \def CHN_DB_ENTRY_SIZE 
+    \brief Channel entry struct's size in driver DB. */
+#define CHN_DB_ENTRY_SIZE    sizeof(chnDbEntry_t)
+
 /*! \var typedef struct hw_mbox_drv_data hw_mbox_drv_data_t 
     \brief struct for HW_MBOX driver Local Data. */
 typedef struct hw_mbox_drv_data
 {
-    /* Core (Hardware) version: */
-    Uint32 coreVerMajor; 
-    Uint32 coreVerMinor;
+    /* General Control Information: */
+    ctrlDbEntry_t ctrlData;
+
+    /* Channel Database: */
+    chnDbEntry_t chnDb[HW_MBOX_CHANNEL_COUNT];
 
-    /* Control Data: */
-    Bool isSupervisor; /* If True then this Master is the supervisor of the HW_MBOX */
-    Bool isMonitor;    /* If True then this Master is the Monitor of the HW_MBOX */
-
-    Bool masterValid[HW_MBOX_MASTER_COUNT];    /* index is MID, if True then Master has SW support and is not fused out */
-    Uint32 chnIntr[HW_MBOX_CHANNEL_COUNT];     /* index is CID, incremented upon interrupt */
-    Uint32 errIntr;                            /* incremented only for supervisor */
-    Uint32 ghostIntr;                          /* incremented if there's an interrupt but no set bits in Interrupt Status Registers */
-    void __iomem *reg_base;                    /* Mapped io reg base address */
-    struct mutex chnLock[HW_MBOX_CHANNEL_COUNT];
+    /* Master Database: */
+    masterDbEntry_t masterDb[HW_MBOX_MASTER_COUNT];
+
+    /* Statistics: */
+    Uint32 errIntr;     /* incremented only for supervisor */
+    Uint32 ghostIntr;   /* incremented if there's an interrupt but no set bits in Interrupt Status Registers */
+    void __iomem *reg_base; /* Mapped io reg base address */ 
 } hw_mbox_drv_data_t;
 
 /*! \def HW_MBOX_DRIVER_DATA_SIZE 
@@ -344,38 +487,104 @@ typedef struct hw_mbox_drv_data
     \brief HW_MBOX driver Local Data. */
 static hw_mbox_drv_data_t hwMboxDriverData;
 
-/* Access Driver Data Macros: */
+/***** DATABASE ACCESS MACRO HELPERS: *****/
+
+#define RESET_DRIVER_DATA()    (memset(&hwMboxDriverData, 0, HW_MBOX_DRIVER_DATA_SIZE))
+
+/*** Ctrl DB: ***/
+
+#define CTRL_GET_CORE_VER_MAJ()             (hwMboxDriverData.ctrlData.coreVerMajor)
+#define CTRL_SET_CORE_VER_MAJ( _value )     (hwMboxDriverData.ctrlData.coreVerMajor = ( _value ))
+
+#define CTRL_GET_CORE_VER_MIN()             (hwMboxDriverData.ctrlData.coreVerMinor)
+#define CTRL_SET_CORE_VER_MIN( _value )     (hwMboxDriverData.ctrlData.coreVerMinor = ( _value ))
+
+#define CTRL_GET_IS_HW_DEBUG_MODE()         (hwMboxDriverData.ctrlData.isHwDebugMode)
+#define CTRL_SET_IS_HW_DEBUG_MODE( _value ) (hwMboxDriverData.ctrlData.isHwDebugMode = ( _value ))
+
+#define CTRL_GET_IS_STARTED()               (hwMboxDriverData.ctrlData.isStarted)
+#define CTRL_SET_IS_STARTED( _value )       (hwMboxDriverData.ctrlData.isStarted = ( _value ))
+
+#define CTRL_GET_IS_LOCKED()                (hwMboxDriverData.ctrlData.isLocked)
+#define CTRL_SET_IS_LOCKED( _value )        (hwMboxDriverData.ctrlData.isLocked = ( _value ))
+
+#define CTRL_GET_SUPERVISOR()               (hwMboxDriverData.ctrlData.supervisor)
+#define CTRL_SET_SUPERVISOR( _value )       (hwMboxDriverData.ctrlData.supervisor = ( _value ))
+#define IS_SUPERVISOR()                     (hwMboxDriverData.ctrlData.supervisor == HW_MBOX_MID)
+
+#define CTRL_GET_MONITOR()                  (hwMboxDriverData.ctrlData.monitor)
+#define CTRL_SET_MONITOR( _value )          (hwMboxDriverData.ctrlData.monitor = ( _value ))
+#define IS_MONITOR()                        (hwMboxDriverData.ctrlData.monitor == HW_MBOX_MID)
+
+/*** Master DB: ***/
+
+#define MASTER_GET_VALID( _mid )               (hwMboxDriverData.masterDb[ _mid ].valid)
+#define MASTER_SET_VALID( _mid, _value)        (hwMboxDriverData.masterDb[ _mid ].valid = ( _value ))
+#define IS_MASTER_VALID( _mid )                (hwMboxDriverData.masterDb[ _mid ].valid == True)
 
-#define RESET_DRIVER_DATA()                     memset(&hwMboxDriverData, 0, HW_MBOX_DRIVER_DATA_SIZE)
+#define MASTER_GET_INITIALIZED( _mid )         (hwMboxDriverData.masterDb[ _mid ].initialized)
+#define MASTER_SET_INITIALIZED( _mid, _value)  (hwMboxDriverData.masterDb[ _mid ].initialized = ( _value ))
+#define IS_MASTER_INIT( _mid )                 (hwMboxDriverData.masterDb[ _mid ].initialized == True)
 
-#define SET_CORE_VER_MAJ(value)                 (hwMboxDriverData.coreVerMajor = value)
-#define SET_CORE_VER_MIN(value)                 (hwMboxDriverData.coreVerMinor = value)
-#define GET_CORE_VER_MAJ()                      (hwMboxDriverData.coreVerMajor)
-#define GET_CORE_VER_MIN()                      (hwMboxDriverData.coreVerMinor)
+/* Configuration: */
 
-#define SET_IS_SUPERVISOR()                     (hwMboxDriverData.isSupervisor = True) /* Use to set an indication that current Master is the supervisor. */
-#define SET_IS_MONITOR()                        (hwMboxDriverData.isMonitor = True)    /* Use to set an indication that current Master is the monitor. */
+#define MASTER_CFG( _mid )                      (hwMboxDriverData.masterDb[ _mid ].config)
 
-#define IS_SUPERVISOR()                         (hwMboxDriverData.isSupervisor == True)
-#define IS_MONITOR()                            (hwMboxDriverData.isMonitor == True)
+#define MASTER_CFG_GET_SUPPORT( _mid )          (hwMboxDriverData.masterDb[ _mid ].config.support)
 
-#define SET_MASTER_VALID(paramMID, value)       (hwMboxDriverData.masterValid[paramMID] = value)
-#define IS_MASTER_VALID(paramMID)               (hwMboxDriverData.masterValid[paramMID] == True)
+#define MASTER_GET_ERROR_COUNT( _mid )          (hwMboxDriverData.masterDb[ _mid ].errorCount)
 
-#define GET_CHN_INTR(paramCID)                  (hwMboxDriverData.chnIntr[paramCID])
-#define INC_CHN_INTR(paramCID)                  ((hwMboxDriverData.chnIntr[paramCID])++)
+/*** Channels DB: ***/
+
+#define CHN_ENTRY( _cid )                       (hwMboxDriverData.chnDb[ _cid ])
+
+#define CHN_IS_ASSIGNED( _cid )                 (hwMboxDriverData.chnDb[ _cid ].assigned == True)
+#define CHN_SET_ASSIGNED( _cid, _value)         (hwMboxDriverData.chnDb[ _cid ].assigned = ( _value ))
+
+#define CHN_IS_VALID( _cid )                    (hwMboxDriverData.chnDb[ _cid ].valid == True)
+#define CHN_SET_VALID( _cid, _value)            (hwMboxDriverData.chnDb[ _cid ].valid = ( _value ))
+
+#define CHN_IS_INIT( _cid )                     (hwMboxDriverData.chnDb[ _cid ].isInitChannel == True)
+#define CHN_SET_INIT( _cid, _value)             (hwMboxDriverData.chnDb[ _cid ].isInitChannel = ( _value ))
+
+/* Configuration: */
+
+#define CHN_CFG( _cid )                         (hwMboxDriverData.chnDb[ _cid ].config)
+
+#define CHN_CFG_GET_TYPE( _cid )                (hwMboxDriverData.chnDb[ _cid ].config.mboxType)
+#define CHN_CFG_GET_COMMANDER( _cid )           (hwMboxDriverData.chnDb[ _cid ].config.commander)
+#define CHN_CFG_GET_SUBJECT( _cid )             (hwMboxDriverData.chnDb[ _cid ].config.subject)
+
+#define CHN_CFG_MEMBUFF_GET_SIZE( _cid )        (hwMboxDriverData.chnDb[ _cid ].config.memBuff.size)
+#define CHN_CFG_MEMBUFF_GET_START( _cid )       (hwMboxDriverData.chnDb[ _cid ].config.memBuff.start)
+
+/* Check if it's a receive Opcode channel: */
+#define CHN_IS_RECV_OP( _cid )  ( ((CHN_CFG_GET_TYPE( _cid ) == hw_mbox_opcode)  && \
+                                   (CHN_CFG_GET_SUBJECT( _cid ) == HW_MBOX_MID)) == True )
+
+/* infrastracture: */
+
+#define CHN_INTR_GET_COUNT( _cid )                  (hwMboxDriverData.chnDb[ _cid ].intrCount)
+#define CHN_INTR_INC_COUNT( _cid )                  (hwMboxDriverData.chnDb[ _cid ].intrCount++)
+
+#define CHN_RECV_OPCODE_GET_INDEX( _cid )           (hwMboxDriverData.chnDb[ _cid ].recvOpcodeIndex)
+#define CHN_RECV_OPCODE_SET_INDEX( _cid, _value )   (hwMboxDriverData.chnDb[ _cid ].recvOpcodeIndex = ( _value ))
+
+#define CHN_RECV_OPCODE_INDEX_INVALID  (-1) /*! use for non recvOpcode channel */
+
+/*** Statistics ***/
 
 #define GET_ERR_INTR()                          (hwMboxDriverData.errIntr)
-#define INC_ERR_INTR()                          ((hwMboxDriverData.errIntr)++)
+#define INC_ERR_INTR()                          (hwMboxDriverData.errIntr++)
 
 #define GET_GHOST_INTR()                        (hwMboxDriverData.ghostIntr)
-#define INC_GHOST_INTR()                        ((hwMboxDriverData.ghostIntr)++)
+#define INC_GHOST_INTR()                        (hwMboxDriverData.ghostIntr++)
 
-/* SRAM allocation: */
+/*** SRAM allocation: ***/
 
 #define GET_FREE_SRAM_LEFT()                    (HW_MBOX_SRAM_SIZE - __currentNonallocatedSramOffset)
 #define GET_NEXT_ALLOCATION_SRAM_OFFSET()       (__currentNonallocatedSramOffset)
-  
+
 #define ALLOCATE_SRAM(paramCID, requiredSizeInBytes)    \
 do{ \
      /* Update Memory Map registers: */                                         \
@@ -385,11 +594,47 @@ do{ \
     __currentNonallocatedSramOffset += requiredSizeInBytes;                     \
 } while (0)
 
-/*! \var static Uint32 __currentNonallocatedSramOffset
-    \brief keeps track of offset of currently allocated SRAM.
-    \warning Do not modify directly use the Macros!  
-*/
-static Uint32 __currentNonallocatedSramOffset = 0;
+/************************************************************************/
+/*     HW_MBOX Channel Devices:                                         */
+/************************************************************************/
+
+/* Channel Devices Function Declarations: */
+
+/* File Operations: */
+static int chnint_open(struct inode *inode, struct file *filp);
+static ssize_t chnint_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
+static unsigned int chnint_poll(struct file *filp, struct poll_table_struct *wait);
+static int chnint_release(struct inode *inode, struct file *filp);
+
+static void chnint_cleanup(int count);
+
+/* Channel interrupt Devices Local Variables: */
+
+/*! \var static dev_t chnint_dev
+    \brief The first channel interrupt device that will be created, Contains major and first minor number.
+    \note This is the reference point for allocation of all other devices and the chrdev region. */
+static dev_t chnint_dev;
+
+/*! \var static struct class *chnint_class
+    \brief Channel interrupt devices class. */
+static struct class *chnint_class;
+
+/*! \var static chnint_t *chnint_devices
+    \brief Array of all the channel interrupt Device structures, one entry per channel.
+    \note Index in the array is the CID of the device. */
+static chnint_t *chnint_devices;
+
+#define RESET_CHN_DEVS()    (memset(chnint_devices, 0, HW_MBOX_CHANNEL_COUNT * sizeof(chnint_t)))
+
+/*! \var static struct file_operations chnint_fops
+    \brief file operations structure for the channel interrupt devices. */
+static struct file_operations chnint_fops = {
+    .owner      = THIS_MODULE,
+    .read       = chnint_read,
+    .poll       = chnint_poll,
+    .open       = chnint_open,
+    .release    = chnint_release,
+};
 
 /************************************************************************/
 /*     SEQ PROC Interface Macros:                                       */
@@ -613,166 +858,2354 @@ if (NULL == (procDir = proc_mkdir(procDi
 }
 
 /************************************************************************/
-/*     HW_MBOX proc file system utilities:                              */
+/*     HW_MBOX Kernel Local Variables                                   */
 /************************************************************************/
 
-/*! \def HW_MBOX_PROC_DIR_STR
-    \brief proc dir: /proc/HW_MBOX */
-#define HW_MBOX_PROC_DIR_STR    "hw_mbox"
+#ifdef HW_MBOX_DEBUG
+/*! \var volatile Uint32 __debug_HW_MBOX_MID
+    \brief enables changing MID during runtime.
+    \note backing field to an extern variable in hw_mbox_mem_access.h
+    \note starts off with the hardcoded MID.
+    \attention don't access directly use the macros!
+*/
+volatile Uint32 __debug_HW_MBOX_MID = HW_MBOX_HARDCODED_MID;
+#endif /* HW_MBOX_DEBUG */
 
-/* Define all Simple Procs here: */
+/*! \var static Uint32 __currentNonallocatedSramOffset
+    \brief keeps track of offset of currently allocated SRAM.
+    \warning Do not modify directly use the Macros!  
+*/
+static Uint32 __currentNonallocatedSramOffset = 0;
 
-SEQ_PROC_DEFINE_SIMPLE(proc_dump_core_version);
-SEQ_PROC_DEFINE_SIMPLE(proc_dump_control_regs);
-SEQ_PROC_DEFINE_SIMPLE(proc_dump_status);
+/*! \var static chnIntr_t chnIntrData[]
+    \brief array containing channel interrupts information.
+    \note index in the array is CID.
+*/
+static chnIntr_t chnIntrData[HW_MBOX_CHANNEL_COUNT];
 
-/* Define all SEQ Procs here: */
+#define RESET_CHN_INTR_DATA()               (memset(chnIntrData, 0, sizeof(chnIntrData)))
+#define CHN_INTR_WQ( _cid )                 (chnIntrData[ _cid ].waitQueue)
+#define CHN_INTR_GET_STATE( _cid )          (chnIntrData[ _cid ].state)
+#define CHN_INTR_SET_STATE( _cid, _value )  (chnIntrData[ _cid ].state = ( _value ))
+
+/*! \var static struct semaphore chnLocks[]
+    \brief array containing channel locks (binary semaphores).
+    \note index in the array is CID.
+*/
+static struct semaphore chnLocks[HW_MBOX_CHANNEL_COUNT];
 
-SEQ_PROC_DEFINE(proc_dump_masters_regs);
-SEQ_PROC_DEFINE(proc_dump_channels_regs);
-SEQ_PROC_DEFINE(proc_dump_interrupts);
+#define RESET_CHN_LOCKS()                   (memset(chnLocks, 0, sizeof(chnLocks)))
+#define CHN_LOCK( _cid )                    (chnLocks[ _cid ])
 
-/* Implement all simple procs here: */
+/*** CID Look Up Table: ***/
 
-/*! \fn static int proc_dump_core_version(struct seq_file *m, void *v)
-    \brief dump HW_MBOX Core Version proc (reads ID registers). */
-static int proc_dump_core_version(struct seq_file *m, void *v)
-{
-    seq_printf(m, "HW_MBOX Core Version: %d.%d\n", HW_MBOX_ID_MAJOR_GET(), HW_MBOX_ID_MINOR_GET());
-    return 0;
-}
+static Uint32 cidLUT[HW_MBOX_MASTER_COUNT][HW_MBOX_TYPE_COUNT << 1];
 
-/*! \fn static int proc_dump_control_regs(struct seq_file *m, void *v)
-    \brief dump HW_MBOX Control Registers proc. */
-static int proc_dump_control_regs(struct seq_file *m, void *v)
-{
-    seq_printf(m, "ID:     0x%08x\n", HW_MBOX_ID_REG_GET());
-    seq_printf(m, "CTRL:   0x%08x\n", HW_MBOX_CTRL_REG_GET());
-    seq_printf(m, "ERROR:  0x%08x\n", HW_MBOX_ERROR_REG_GET());
-    return 0;
-}
+/* This LUT allows to find the correct CID for each peer according to type.
+   It is required because the channels are an internal entity and only have 
+   meaning inside the HW MBOX package code. Outside users invoke services
+   specifying a destination peer (Commander/Subject).
 
-/*! \fn static int proc_dump_status(struct seq_file *m, void *v)
+   Table should be accessed using FIND_CID_IN_LUT/SET_CID_IN_LUT Macros.
+
+   First dimension is the destination peer (indexed by MID).
+   Second dimension is the required channel type (implicitly specified 
+   according to service that was invoked).
+
+   Please note: second dimension size is HW_MBOX_TYPE_COUNT << 1 ( * 2 )
+                because one CID is required for send variants (peer is subject);
+                and another CID is required for recv variants (peer is commander).
+
+   Currently per each < Commander, Subject, type > combination exist no more than one CID.
+*/
+
+#define RESET_CID_LUT()                                         (memset(cidLUT, 0xFF, sizeof(cidLUT)))
+#define FIND_CID_IN_LUT( _peer, _type, _isPeerCommander)        (cidLUT[ _peer ][ ( ( _type ) << 1 ) + ( _isPeerCommander ) ])
+#define SET_CID_IN_LUT( _peer, _type, _isPeerCommander, _value) (cidLUT[ _peer ][ ( ( _type ) << 1 ) + ( _isPeerCommander ) ] = ( _value ))
+
+/*! \def CHECK_FIND_CID_IN_LUT( _peer, _type, _isPeerCommander, __onNotFound, _paramCID)
+    \brief looks for CID in LUT, checks if found, if not executes __onNotFound.
+    \param[in] _peer - peer of the channel, value from <hw_mbox_Masters_e>.
+    \param[in] _type - channel type, value from <hw_mbox_type_e>.
+    \param[in] _isPeerCommander - is <peer> the channel's commander.
+    \param[in] __onNotFound - execute if CID not found.
+    \param[out] _paramCID - upon returning will hold the CID [or HW_MBOX_CID_INVALID if not found].
+*/
+#define CHECK_FIND_CID_IN_LUT( _peer, _type, _isPeerCommander, __onNotFound, _paramCID) \
+do{ \
+    ( _paramCID ) = FIND_CID_IN_LUT(_peer, _type, _isPeerCommander);           \
+    if (( _paramCID ) == HW_MBOX_CID_INVALID)                                  \
+    {                                                                          \
+        PRINTK_ERR("There's no %s channel configured with %s(%d) as %s...",    \
+                   HW_MBOX_TYPE_STR( _type ),                                  \
+                   HW_MBOX_MASTER_GET_NAME( _peer ), ( _peer ),                \
+                   (( _isPeerCommander )?("commander"):("subject")));          \
+        __onNotFound;                                                          \
+    }                                                                          \
+    DPRINTK("found correct cid, using cid %d", _paramCID);                     \
+} while (0)
+
+/*! \var static recvOpcodeListenerThreadData_t recvOpThreadsData[]
+    \brief data of the receive opcode listeners.
+*/
+static recvOpcodeListenerThreadData_t recvOpThreadsData[HW_MBOX_OPCODE_RECV_COUNT];
+
+#define RESET_RECV_OP_THREAD_DATA()    (memset(recvOpThreadsData, 0, sizeof(recvOpThreadsData)))
+
+#define RECV_OP_THREAD_DATA( _recvOpIndex )                  (recvOpThreadsData[ _recvOpIndex ])
+
+#define RECV_OP_THREAD_SET_CID( _recvOpIndex, _paramCID )    (recvOpThreadsData[ _recvOpIndex ].cid = ( _paramCID ))
+#define RECV_OP_THREAD_SET_INDEX( _recvOpIndex )             (recvOpThreadsData[ _recvOpIndex ].index = ( _recvOpIndex ))
+
+/*! \var static recvOpcodeInfrastructure_t recvOpData[]
+    \brief required infrastructure for receive opcode channels.
+*/
+static recvOpcodeInfrastructure_t recvOpData[HW_MBOX_OPCODE_RECV_COUNT];
+
+#define RESET_RECV_OP_DATA()                    (memset(recvOpData, 0, sizeof(recvOpData)))
+
+/* Access By Receive Op Index Macros: */
+
+/* Listener Thread: */
+#define RECV_OP_THREAD_BY_INDEX( _recvOpIndex )                         (recvOpData[ _recvOpIndex ].listenerThread)
+
+/* Regsitered Count: */
+#define RECV_OP_GET_TAG_COUNT_BY_INDEX( _recvOpIndex )                  (recvOpData[ _recvOpIndex ].registeredCount)
+#define RECV_OP_INC_TAG_COUNT_BY_INDEX( _recvOpIndex )                  (recvOpData[ _recvOpIndex ].registeredCount++)
+
+/* Application Queue: */
+#define RECV_OP_APP_WQ_BY_INDEX( _recvOpIndex )                         (recvOpData[ _recvOpIndex ].appWq.waitQueue)
+#define RECV_OP_APP_GET_STATE_BY_INDEX( _recvOpIndex )                  (recvOpData[ _recvOpIndex ].appWq.state)
+#define RECV_OP_APP_SET_STATE_BY_INDEX( _recvOpIndex, _stateVal )       (recvOpData[ _recvOpIndex ].appWq.state = ( _stateVal ))
+
+/* Tag: */
+#define RECV_OP_GET_TAG_BY_INDEX( _recvOpIndex, _tagIndex )             (recvOpData[ _recvOpIndex ].registeredTags[ _tagIndex ].tag)
+#define RECV_OP_SET_TAG_BY_INDEX( _recvOpIndex, _tagIndex, _tagVal )    (recvOpData[ _recvOpIndex ].registeredTags[ _tagIndex ].tag = ( _tagVal ))
+
+/* Callback: */
+#define RECV_OP_GET_CB_BY_INDEX( _recvOpIndex, _tagIndex )              (recvOpData[ _recvOpIndex ].registeredTags[ _tagIndex ].callbackFunc)
+#define RECV_OP_SET_CB_BY_INDEX( _recvOpIndex, _tagIndex, _cbPtr)       (recvOpData[ _recvOpIndex ].registeredTags[ _tagIndex ].callbackFunc = ( _cbPtr ))
+
+/* Token: */
+#define RECV_OP_GET_TOKEN_BY_INDEX( _recvOpIndex, _tagIndex)            (recvOpData[ _recvOpIndex ].registeredTags[ _tagIndex ].token)
+#define RECV_OP_SET_TOKEN_BY_INDEX( _recvOpIndex, _tagIndex, _tokenVal) (recvOpData[ _recvOpIndex ].registeredTags[ _tagIndex ].token = ( _tokenVal ))
+
+/* Statistics: */
+#define RECV_OP_GET_WAKEUP_COUNT_BY_INDEX( _recvOpIndex )               (recvOpData[ _recvOpIndex ].wakeupCount)
+#define RECV_OP_INC_WAKEUP_COUNT_BY_INDEX( _recvOpIndex )               (recvOpData[ _recvOpIndex ].wakeupCount++)
+
+#define RECV_OP_GET_INVALID_TAG_COUNT_BY_INDEX( _recvOpIndex )          (recvOpData[ _recvOpIndex ].invalidTagCount)
+#define RECV_OP_INC_INVALID_TAG_COUNT_BY_INDEX( _recvOpIndex )          (recvOpData[ _recvOpIndex ].invalidTagCount++)
+
+#define RECV_OP_GET_OPCODE_CNT_BY_INDEX( _recvOpIndex, _tagIndex)       (recvOpData[ _recvOpIndex ].registeredTags[ _tagIndex ].opcodeCount)
+#define RECV_OP_INC_OPCODE_CNT_BY_INDEX( _recvOpIndex, _tagIndex)       (recvOpData[ _recvOpIndex ].registeredTags[ _tagIndex ].opcodeCount++)
+
+/* Access By CID Macros: */
+/* IMPORTANT: Only use the following functions for valid recv Opcode channels! */
+
+/* Regsitered Count: */
+#define RECV_OP_GET_TAG_COUNT( _cid )                   (RECV_OP_GET_TAG_COUNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
+#define RECV_OP_INC_TAG_COUNT( _cid )                   (RECV_OP_INC_TAG_COUNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
+
+/* Application Queue: */
+#define RECV_OP_APP_WQ( _cid )                          (RECV_OP_APP_WQ_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
+#define RECV_OP_APP_GET_STATE( _cid )                   (RECV_OP_APP_GET_STATE_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
+#define RECV_OP_APP_SET_STATE( _cid, _stateVal )        (RECV_OP_APP_SET_STATE_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _stateVal ) ))
+
+/* Tag: */
+#define RECV_OP_GET_TAG( _cid, _tagIndex )              (RECV_OP_GET_TAG_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _tagIndex ) ))
+#define RECV_OP_SET_TAG( _cid, _tagIndex, _tagVal)      (RECV_OP_SET_TAG_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _tagIndex ), ( _tagVal ) ))
+
+/* Callback: */
+#define RECV_OP_GET_CB( _cid, _tagIndex )               (RECV_OP_GET_CB_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _tagIndex ) ))
+#define RECV_OP_SET_CB( _cid, _tagIndex, _cbPtr)        (RECV_OP_SET_CB_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _tagIndex ), ( _cbPtr ) ))
+
+/* Token: */
+#define RECV_OP_GET_TOKEN( _cid, _tagIndex )            (RECV_OP_GET_TOKEN_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _tagIndex ) ))
+#define RECV_OP_SET_TOKEN( _cid, _tagIndex, _tokenVal)  (RECV_OP_SET_TOKEN_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _tagIndex ), ( _tokenVal ) ))
+
+/* Statistics: */
+#define RECV_OP_GET_WAKEUP_COUNT( _cid )                (RECV_OP_GET_WAKEUP_COUNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
+#define RECV_OP_INC_WAKEUP_COUNT( _cid )                (RECV_OP_INC_WAKEUP_COUNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
+
+#define RECV_OP_GET_INVALID_TAG_COUNT( _cid )           (RECV_OP_GET_INVALID_TAG_COUNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
+#define RECV_OP_INC_INVALID_TAG_COUNT( _cid )           (RECV_OP_INC_INVALID_TAG_COUNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
+
+#define RECV_OP_GET_OPCODE_CNT( _cid, _tagIndex )       (RECV_OP_GET_OPCODE_CNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _tagIndex ) ))
+#define RECV_OP_INC_OPCODE_CNT( _cid, _tagIndex )       (RECV_OP_INC_OPCODE_CNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _tagIndex ) ))
+
+/*** Kernel Statistics: ***/
+
+static hwMbox_statistics_t stats;
+
+#define RESET_STATS()                                         (memset(&stats, 0, sizeof(stats)))
+#define STATS_GET_COUNTER( _peer, _type, _isPeerCommander)    (stats.serviceCounters[ _peer ][ ( ( _type ) << 1 ) + ( _isPeerCommander ) ])
+#define STATS_INC_COUNTER( _peer, _type, _isPeerCommander)    (stats.serviceCounters[ _peer ][ ( ( _type ) << 1 ) + ( _isPeerCommander ) ]++)
+
+/*** High Level Function Helpers ***/
+
+/*! \def WAIT_FOR_CHN_INTR( _cid, _timeOutInMsec) 
+    \brief invokes waitForChannelInterrupt function.
+    \attention releases channel lock on error.
+    \note assumes int calling function.
+    \param[in] _cid - CID to wait for.
+    \param[in] _timeOutInMsec - Timeout value (use CHN_INTR_NO_TIMEOUT for no timeout).
+*/
+#define WAIT_FOR_CHN_INTR( _cid, _timeOutInMsec ) \
+do{ \
+    chnIntrReturnCodes_e chnIntrRc;                                                                    \
+    if ((chnIntrRc = hwMbox_waitForChannelInterrupt( ( _cid ), ( _timeOutInMsec ))) != CHN_INTR_RC_OK) \
+    {                                                                                                  \
+        /* release Lock... */                                                       \
+        up(&CHN_LOCK( ( _cid )));                                                   \
+        if (chnIntrRc == CHN_INTR_RC_INTERRUPTED_BY_SIGNAL)                         \
+        {                                                                           \
+            DPRINTK("cid %d: wait interrupted by signal!", ( _cid ));               \
+            return -ERESTARTSYS;                                                    \
+        }                                                                           \
+        else if (chnIntrRc == CHN_INTR_RC_TIMEOUT_EXPIRED)                          \
+        {                                                                           \
+            /* TBD: what to do in this case... */                                   \
+            PRINTK_ERR("cid %d: timeout expired!", ( _cid ));                       \
+            return (-1);                                                            \
+        }                                                                           \
+        else                                                                        \
+        {                                                                           \
+            PRINTK_ERR("cid %d: unknown chnIntrRc (%d)!", ( _cid ), chnIntrRc);     \
+            return (-1);                                                            \
+        }                                                                           \
+    }                                                                               \
+} while (0)
+
+/************************************************************************/
+/*     HW_MBOX Kernel INTERFACE FUNCTIONS Implementation:               */
+/************************************************************************/
+/**************************************************************************/
+/*! \fn int hwMbox_isReady(void)
+ **************************************************************************
+ *  \brief Returns whether HW MBOX driver is initailized or not.
+ *  \return [ 0 on success / error -1 ].
+ **************************************************************************/
+int hwMbox_isReady(void)
+{
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+    return 0;
+}
+EXPORT_SYMBOL(hwMbox_isReady);
+/**************************************************************************/
+/*! \fn int hwMbox_sendCommand(hw_mbox_Masters_e subject,
+                       Uint32 *cmd,
+                       Uint8 *dataBuf, Uint32 dataLen)
+ **************************************************************************
+ *  \brief Send a command to <subject> in a blocking manner using the HW_MBOX.
+ *  \attention will only return upon reply/ACK from <subject> (or error).
+ *  \param[in]     subject - To which Master should the opcode be sent.
+ *  \param[in,out] cmd - Command to send, upon returning will hold the reply.
+ *  \param[in,out] dataBuf - pointer to a Buffer containing more data to be 
+ *                           sent, upon returning will hold the reply data
+ *                           Buffer (copies as much as the buffer can hold). 
+ *  \param[in]     dataLen - Length in Bytes of buffer specified in <dataBuf>.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_sendCommand(hw_mbox_Masters_e subject,
+                       Uint32 *cmd,
+                       Uint8 *dataBuf, Uint32 dataLen)
+{
+    Uint32 paramCID;
+
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+
+    if (cmd == NULL)
+    {
+        PRINTK_ERR("cmd == NULL!");
+        return (-1);
+    }
+
+    DPRINTK("send Command to %s(%d) [command value 0x%08x with %uB of data]",
+            HW_MBOX_MASTER_GET_NAME(subject), subject,
+            *cmd, dataLen);
+
+    CHECK_FIND_CID_IN_LUT(subject, hw_mbox_command, False, return (-1), paramCID);
+
+    /* seize channel lock */
+    if (down_interruptible(&CHN_LOCK(paramCID)))
+    {
+        DPRINTK("down interrupted by signal...");
+        return -ERESTARTSYS;
+    }
+
+    if ((dataBuf != NULL) && (dataLen > 0))
+    {
+        /* command has data! save to SRAM: */
+
+        /* verify SRAM size: */
+        if (dataLen > CHN_CFG_MEMBUFF_GET_SIZE(paramCID))
+        {
+            PRINTK_ERR("send Command to %s(%d) - Command data Buffer size (%uB) > SRAM size allocated to channel (%uB)!",
+                       HW_MBOX_MASTER_GET_NAME(subject), subject, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID));
+
+            /* release Lock... */
+            up(&CHN_LOCK(paramCID));
+            return (-1);
+        }
+
+        DPRINTK("send Command to %s(%d) - copying %uB of command data to SRAM",
+                HW_MBOX_MASTER_GET_NAME(subject), subject, dataLen);
+
+        DPRINTK("cid %d: copying %uB [out of total %uB channel has] to SRAM at offset=0x%08x",
+                paramCID, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+        HW_MBOX_COPY_TO_SRAM(dataBuf, dataLen, CHN_CFG_MEMBUFF_GET_START(paramCID));
+    }
+
+    /* Send Command to subject: */
+    DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+    DPRINTK("cid %d: writing 0x%08x to the command register of the channel...", paramCID, *cmd);
+    HW_MBOX_CHN_COMMAND_REG_SET(paramCID, *cmd);
+    DPRINTK("cid %d: after write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+
+    WAIT_FOR_CHN_INTR(paramCID, CHN_INTR_DEFAULT_TIMEOUT_MSEC);
+
+    DPRINTK("cid %d: Reply/ACK from subject!", paramCID);
+
+    /* get the Reply: */
+    *cmd = HW_MBOX_CHN_COMMAND_REG_GET(paramCID);
+    DPRINTK("cid %d: subject reply=0x%08x", paramCID, *cmd);
+
+    if ((dataBuf != NULL) && (dataLen > 0))
+    {
+        /* get reply data from SRAM: */
+        DPRINTK("send Command to %s(%d) - copying %uB of reply command data from SRAM",
+                HW_MBOX_MASTER_GET_NAME(subject), subject, dataLen);
+
+        DPRINTK("cid %d: copying %uB [out of total %uB channel has] from SRAM at offset=0x%08x",
+                paramCID, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+        HW_MBOX_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID), dataLen, dataBuf);
+    }
+
+    STATS_INC_COUNTER(subject, hw_mbox_command, False);
+
+    /* release Lock... */
+    up(&CHN_LOCK(paramCID));
+
+    return 0;
+}
+EXPORT_SYMBOL(hwMbox_sendCommand);
+
+/**************************************************************************/
+/*! \fn int hwMbox_recvCommand(hw_mbox_Masters_e commander,
+                               Uint32 *cmd,
+                               Uint8 *dataBuf, Uint32 dataLen)
+ **************************************************************************
+ *  \brief Receive a command from <commander> using the HW_MBOX.
+ *  \attention will only return upon arrival of a command from <commander> 
+ *             (or error).
+ *  \note To reply call HW_MBOX_sendReply [if a meaningful response is expected].
+ *  \note To ACK call HW_MBOX_sendAck [to simply ACK the command].
+ *  \warning The subsequent call to HW_MBOX_sendReply/HW_MBOX_sendAck is extermely
+ *           important as until it is called the channel is not released!!!
+ *  \param[in]  commander - From which Master should a command be received.
+ *  \param[out] cmd - Command that was received.
+ *  \param[out] dataBuf - pointer to a Buffer containing more data that was sent.
+ *  \param[in]  dataLen - Length in Bytes of buffer specified in <dataBuf>.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_recvCommand(hw_mbox_Masters_e commander,
+                       Uint32 *cmd,
+                       Uint8 *dataBuf, Uint32 dataLen)
+{
+    Uint32 paramCID;
+
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+
+    if (cmd == NULL)
+    {
+        PRINTK_ERR("cmd == NULL!");
+        return (-1);
+    }
+
+    DPRINTK("receive Command from %s(%d) [incoming data buffer size %uB]",
+            HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen);
+
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_command, True, return (-1), paramCID);
+
+    if (dataBuf != NULL)
+    {
+        if (dataLen > CHN_CFG_MEMBUFF_GET_SIZE(paramCID))
+        {
+            /* verify SRAM size: */
+            PRINTK_ERR("receive Command from %s(%d) - incoming data buffer size (%uB) > SRAM allocated to channel (%uB)!",
+                       HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID));
+
+            return (-1);
+        }
+    }
+
+    /* seize channel lock 
+       [handle possible simultaneous access from both User-Space and Kernel] */
+    if (down_interruptible(&CHN_LOCK(paramCID)))
+    {
+        DPRINTK("down interrupted by signal...");
+        return -ERESTARTSYS;
+    }
+
+    DPRINTK("receive Command from %s(%d) - start waiting for commands...",
+            HW_MBOX_MASTER_GET_NAME(commander), commander);
+
+    DPRINTK("cid %d: before wait - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+
+    WAIT_FOR_CHN_INTR(paramCID, CHN_INTR_NO_TIMEOUT);
+
+    DPRINTK("cid %d: after wait - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+
+    /* get the Command: */
+    *cmd = HW_MBOX_CHN_COMMAND_REG_GET(paramCID);
+
+    DPRINTK("receive Command from %s(%d) - New command received from commander!",
+            HW_MBOX_MASTER_GET_NAME(commander), commander);
+
+    if ((dataBuf != NULL) && (dataLen > 0))
+    {
+        if (CHN_CFG_MEMBUFF_GET_SIZE(paramCID) > 0)
+        {
+            /* get command data from SRAM: */
+            DPRINTK("receive Command from %s(%d) - copying %uB of command data from SRAM",
+                     HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen);
+
+            DPRINTK("cid %d: copying %uB [out of total %uB channel has] from SRAM at offset=0x%08x",
+                    paramCID, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+            HW_MBOX_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID), dataLen, dataBuf);
+        }
+    }
+
+    DPRINTK("receive Command from %s(%d) - command value 0x%08x (%u) with %uB of data",
+            HW_MBOX_MASTER_GET_NAME(commander), commander, *cmd, *cmd, dataLen);
+
+    STATS_INC_COUNTER(commander, hw_mbox_command, True);
+
+    /* release Lock... */
+    up(&CHN_LOCK(paramCID));
+
+    return 0;
+}
+EXPORT_SYMBOL(hwMbox_recvCommand);
+
+/**************************************************************************/
+/*! \fn int hwMbox_sendReplyCommand(hw_mbox_Masters_e commander,
+                                    Uint32 reply,
+                                    Uint8 *dataBuf, Uint32 dataLen)
+ **************************************************************************
+ *  \brief Send back a reply to <commander>, from which a command has been
+ *         received using the HW_MBOX.
+ *  \note should be called when a meaningful response is expected.
+ *  \attention should only be used after a command has been received from
+ *             <commander> using hwMbox_recvCommand.
+ *  \param[in] commander - To which Master should the reply be sent.
+ *  \param[in] reply - reply to send.
+ *  \param[in] dataBuf - pointer to a Buffer containing more data to be sent.
+ *  \param[in] dataLen - Length in Bytes of buffer specified in <dataBuf>.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_sendReplyCommand(hw_mbox_Masters_e commander,
+                            Uint32 reply,
+                            Uint8 *dataBuf, Uint32 dataLen)
+{
+    Uint32 paramCID;
+
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+
+    DPRINTK("send Reply Command to %s(%d) [reply value 0x%08x with %uB of data]",
+            HW_MBOX_MASTER_GET_NAME(commander), commander,
+            reply, dataLen);
+
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_command, True, return (-1), paramCID);
+
+    /* seize channel lock 
+       [handle possible simultaneous access from both User-Space and Kernel] */
+    if (down_interruptible(&CHN_LOCK(paramCID)))
+    {
+        DPRINTK("down interrupted by signal...");
+        return -ERESTARTSYS;
+    }
+
+    if ((dataBuf != NULL) && (dataLen > 0))
+    {
+        /* reply has data! save to SRAM: */
+
+        /* verify SRAM size: */
+        if (dataLen > CHN_CFG_MEMBUFF_GET_SIZE(paramCID))
+        {
+            PRINTK_ERR("send Reply Command to %s(%d) - Reply Command Data size (%uB) > SRAM size allocated to channel (%uB)!",
+                       HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID));
+
+            /* release Lock... */
+            up(&CHN_LOCK(paramCID));
+            return (-1);
+        }
+
+        DPRINTK("send Reply Command to %s(%d) - copying %uB of reply command data to SRAM",
+                HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen);
+
+        DPRINTK("cid %d: copying %uB [out of total %uB channel has] to SRAM at offset=0x%08x",
+                paramCID, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+        HW_MBOX_COPY_TO_SRAM(dataBuf, dataLen, CHN_CFG_MEMBUFF_GET_START(paramCID));
+    }
+
+    /* Send Reply to commander: */
+    DPRINTK("send Reply Command to %s(%d) - sending reply to commander!", 
+            HW_MBOX_MASTER_GET_NAME(commander), commander);
+
+    DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+    DPRINTK("cid %d: writing 0x%08x to the command register of the channel...", paramCID, reply);
+    HW_MBOX_CHN_COMMAND_REG_SET(paramCID, reply);
+    DPRINTK("cid %d: after write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+
+    /* release Lock... */
+    up(&CHN_LOCK(paramCID));
+
+    return 0;
+}
+EXPORT_SYMBOL(hwMbox_sendReplyCommand);
+
+/**************************************************************************/
+/*! \fn int hwMbox_sendAckCommand(hw_mbox_Masters_e commander)
+ **************************************************************************
+ *  \brief Send back an ACK to <commander>, from which a command has been
+ *         received using the HW_MBOX.
+ *  \note should be called when no meaningful response is expected in order
+ *        to simply ACK the command.
+ *  \note Using this function leaves the command registers value unchanged
+ *        (writes the same value that was received).
+ *  \attention should only be used after a command has been received from
+ *             <commander> using hwMbox_recvCommand.
+ *  \param[in] commander - To which Master should the reply be sent.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_sendAckCommand(hw_mbox_Masters_e commander)
+{
+    Uint32 paramCID, currCmdRegVal;
+
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+
+    DPRINTK("send ACK Command to %s(%d)", HW_MBOX_MASTER_GET_NAME(commander), commander);
+
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_command, True, return (-1), paramCID);
+
+    /* seize channel lock 
+       [handle possible simultaneous access from both User-Space and Kernel] */
+    if (down_interruptible(&CHN_LOCK(paramCID)))
+    {
+        DPRINTK("down interrupted by signal...");
+        return -ERESTARTSYS;
+    }
+
+    /* write the current command (command that was sent), 
+       to better assist the HW_MBOX Monitor... */
+
+    currCmdRegVal = HW_MBOX_CHN_COMMAND_REG_GET(paramCID);
+
+    /* Send ACK to commander: */
+    DPRINTK("send ACK Command to %s(%d) - sending ACK to commander!",
+            HW_MBOX_MASTER_GET_NAME(commander), commander);
+
+    DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+    DPRINTK("cid %d: writing 0x%08x to the command register of the channel...", paramCID, currCmdRegVal);
+    HW_MBOX_CHN_COMMAND_REG_SET(paramCID, currCmdRegVal);
+    DPRINTK("cid %d: after write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+
+    /* release Lock... */
+    up(&CHN_LOCK(paramCID));
+
+    return 0;
+}
+EXPORT_SYMBOL(hwMbox_sendAckCommand);
+
+/**************************************************************************/
+/*! \fn int hwMbox_sendOpcode(hw_mbox_Masters_e subject,
+                              Uint32 tag,
+                              Uint32 *code,
+                              Uint8 *dataBuf, Uint32 *dataLen,
+                              Uint32 opcodeDataLen,
+                              Uint32 *replyDataLen)
+ **************************************************************************
+ *  \brief Send an opcode to <subject> in a blocking manner using the HW_MBOX.
+ *  \attention will only return upon reply from <subject> (or error).
+ *  \param[in]     subject - To which Master should the opcode be sent.
+ *  \param[in]     tag - indicates opcode destination.
+ *  \param[in,out] code - code to send, upon returning will hold the return
+ *                        code.
+ *                  NOTE: if generic error upon returning will hold the error
+ *                        code <hwMbox_opcodeReturnCode_e>.
+ *  \param[in,out] dataBuf - pointer to a Buffer containing more data to be sent,
+ *                           upon returning will hold the reply data Buffer.
+ *  \param[in]     dataLen - Length in Bytes of buffer specified in <dataBuf>.
+ *  \param[in]     opcodeDataLen - Length in Bytes of opcode data to send.
+ *  \param[out]    replyDataLen - upon returning will hold the length in Bytes
+ *                                of returned reply data.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_sendOpcode(hw_mbox_Masters_e subject,
+                      Uint32 tag,
+                      Uint32 *code,
+                      Uint8 *dataBuf, Uint32 dataLen,
+                      Uint32 opcodeDataLen,
+                      Uint32 *replyDataLen)
+{
+    Uint32 paramCID, cmdRegVal, tagMaxVal, codeMaxVal;
+    hwMbox_opcode_t opFlds = { 0 };
+
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+
+    if (code == NULL)
+    {
+        PRINTK_ERR("code == NULL!");
+        return (-1);
+    }
+
+    if (replyDataLen == NULL)
+    {
+        PRINTK_ERR("replyDataLen == NULL!");
+        return (-1);
+    }
+
+    DPRINTK("send Opcode to %s(%d) [tag %u code 0x%x (%u) with %uB of data]",
+            HW_MBOX_MASTER_GET_NAME(subject), subject,
+            tag, *code, *code, opcodeDataLen);
+
+    CHECK_FIND_CID_IN_LUT(subject, hw_mbox_opcode, False, return (-1), paramCID);
+
+    DPRINTK("cid %d: size of buffer %uB", paramCID, dataLen);
+
+    tagMaxVal = HW_MBOX_OPCODE_TAG_MAX_VALUE;
+    if (tag > tagMaxVal)
+    {
+        PRINTK_ERR("send Opcode to %s(%d) - tag value (%u) > max possible value (%u)!",
+                   HW_MBOX_MASTER_GET_NAME(subject), subject,
+                   tag, tagMaxVal);
+
+        return (-1);
+    }
+
+    codeMaxVal = HW_MBOX_OPCODE_CODE_MAX_VALUE;
+    if (*code > codeMaxVal)
+    {
+        PRINTK_ERR("send Opcode to %s(%d) - code value 0x%x (%u) > max possible value 0x%x (%u)!",
+                   HW_MBOX_MASTER_GET_NAME(subject), subject,
+                   *code, *code, codeMaxVal, codeMaxVal);
+
+        return (-1);
+    }
+
+    if ((tag == HW_MBOX_OPCODE_TAG) || (tag == HW_MBOX_OPCODE_USER_SPACE_TAG))
+    {
+        DPRINTK("cid %d: NOTICE - using reserved HW_MBOX opcode tag %u", paramCID, tag);
+    }
+
+    if (dataBuf != NULL)
+    {
+        /* Buffer specified! */
+
+        if (opcodeDataLen > dataLen)
+        {
+            /* Opcode data longer than specified buffer... */
+            PRINTK_ERR("send Opcode to %s(%d) - opcode data length (%uB) > specified buffer size (%uB)!",
+                       HW_MBOX_MASTER_GET_NAME(subject), subject,
+                       opcodeDataLen, dataLen);
+
+            return (-1);
+        }
+
+        if ((opcodeDataLen % 4) != 0)
+        {
+            /* Opcode data is always a multiple of 4 Bytes! */
+            PRINTK_ERR("send Opcode to %s(%d) - opcode data length (%uB) must be a multiple of 4!",
+                       HW_MBOX_MASTER_GET_NAME(subject), subject, opcodeDataLen);
+
+            return (-1);
+        }
+    }
+
+    opFlds.tag = tag;
+    opFlds.code = *code;
+
+    /* Flags are currently reserved! */
+    opFlds.flagA = 0;
+    opFlds.flagB = 0;
+
+    opFlds.lenInBytes = opcodeDataLen;
+
+    DPRINTK("cid %d: opcode fields: tag=%u, code=%u=0x%x, A=%d, B=%d, lenInBytes=%u",
+            paramCID, opFlds.tag, opFlds.code, opFlds.code,
+            opFlds.flagA, opFlds.flagB, opFlds.lenInBytes);
+
+    /* seize channel lock */
+    if (down_interruptible(&CHN_LOCK(paramCID)))
+    {
+        DPRINTK("down interrupted by signal...");
+        return -ERESTARTSYS;
+    }
+
+    if ((dataBuf != NULL) && (opcodeDataLen > 0))
+    {
+        /* opcode has data! save to SRAM: */
+
+        /* verify SRAM size: */
+        if (opcodeDataLen > CHN_CFG_MEMBUFF_GET_SIZE(paramCID))
+        {
+            PRINTK_ERR("send Opcode to %s(%d) - opcode data length (%uB) > SRAM allocated to channel (%uB)!",
+                       HW_MBOX_MASTER_GET_NAME(subject), subject, opcodeDataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID));
+
+            /* release Lock... */
+            up(&CHN_LOCK(paramCID));
+            return (-1);
+        }
+
+        DPRINTK("send Opcode to %s(%d) - copying %uB of opcode data to SRAM",
+                HW_MBOX_MASTER_GET_NAME(subject), subject, opcodeDataLen);
+
+        DPRINTK("cid %d: copying %uB [out of total %uB channel has] to SRAM at offset=0x%08x",
+                paramCID, opcodeDataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+        HW_MBOX_COPY_TO_SRAM(dataBuf, opcodeDataLen, CHN_CFG_MEMBUFF_GET_START(paramCID));
+    }
+
+    /* Send Opcode to subject: */
+    cmdRegVal = 0;
+    HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT(cmdRegVal, &opFlds);
+
+    DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+    DPRINTK("cid %d: writing 0x%08x to the command register of the channel...", paramCID, cmdRegVal);
+    HW_MBOX_CHN_COMMAND_REG_SET(paramCID, cmdRegVal);
+    DPRINTK("cid %d: after write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+
+    WAIT_FOR_CHN_INTR(paramCID, CHN_INTR_DEFAULT_TIMEOUT_MSEC);
+
+    DPRINTK("cid %d: Reply from subject!", paramCID);
+
+    /* get the Reply: */
+    cmdRegVal = HW_MBOX_CHN_COMMAND_REG_GET(paramCID);
+
+    DPRINTK("cid %d: subject's opcode reply=0x%08x!", paramCID, cmdRegVal);
+
+    /* parse to opcode fields: */
+    HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT(cmdRegVal, &opFlds);
+
+    DPRINTK("cid %d: opcode fields: tag=%u, code=%u=0x%x, A=%d, B=%d, lenInBytes=%u",
+            paramCID, opFlds.tag, opFlds.code, opFlds.code,
+            opFlds.flagA, opFlds.flagB, opFlds.lenInBytes);
+
+    if (opFlds.lenInBytes > 0)
+    {
+        /* Reply has data! */
+
+        if (dataBuf == NULL)
+        {
+            /* No specified Buffer... */
+            PRINTK_ERR("send Opcode to %s(%d) - opcode reply has data (%uB) but NO specified buffer!",
+                       HW_MBOX_MASTER_GET_NAME(subject), subject, opFlds.lenInBytes);
+
+            *code = HW_MBOX_OPCODE_RC_REPLY_TOO_LONG;
+
+            /* release Lock... */
+            up(&CHN_LOCK(paramCID));
+            return (-1);
+        }
+
+        if (opFlds.lenInBytes > dataLen)
+        {
+            /* Opcode reply data longer than specified buffer... */
+            PRINTK_ERR("send Opcode to %s(%d) - opcode reply data length (%uB) > specified buffer size (%uB)!",
+                       HW_MBOX_MASTER_GET_NAME(subject), subject, opFlds.lenInBytes, dataLen);
+
+            *code = HW_MBOX_OPCODE_RC_REPLY_TOO_LONG;
+
+            /* release Lock... */
+            up(&CHN_LOCK(paramCID));
+            return (-1);
+        }
+
+        /* Get Reply Opcode Data from SRAM: */
+        DPRINTK("send Opcode to %s(%d) - copying %uB of reply opcode data from SRAM",
+                HW_MBOX_MASTER_GET_NAME(subject), subject, opFlds.lenInBytes);
+
+        DPRINTK("cid %d: copying %uB [out of total %uB channel has] from offset 0x%08x",
+                paramCID, opFlds.lenInBytes, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+        HW_MBOX_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID), opFlds.lenInBytes, dataBuf);
+    }
+
+    /* output the Reply size: */
+    *replyDataLen = opFlds.lenInBytes;
+
+    /* check for internal replies: */
+    if (opFlds.tag == HW_MBOX_OPCODE_TAG)
+    {
+        /* 2 possible options here:
+             1. this was a HW MBOX sendOp.
+             2. this was not a HW MBOX sendOp but it failed and the code is the generic RC.
+        */
+
+        if (opFlds.code != HW_MBOX_OPCODE_RC_OK)
+        {
+            DPRINTK("cid %d: subject replied with internal error! rc = 0x%08x (%u)",
+                    paramCID, opFlds.code, opFlds.code);
+
+            /* Put error <hwMbox_opcodeReturnCode_e> in code field: */
+            *code = opFlds.code;
+
+            /* release Lock... */
+            up(&CHN_LOCK(paramCID));
+            return (-1);
+        }
+    }
+
+    /* output received code value: */
+    *code = opFlds.code;
+
+    DPRINTK("send Opcode to %s(%d) - opcode reply code value 0x%x (%u) with %uB of data",
+            HW_MBOX_MASTER_GET_NAME(subject), subject, *code, *code, *replyDataLen);
+
+    STATS_INC_COUNTER(subject, hw_mbox_opcode, False);
+
+    /* release Lock... */
+    up(&CHN_LOCK(paramCID));
+
+    return 0;
+}
+EXPORT_SYMBOL(hwMbox_sendOpcode);
+
+/**************************************************************************/
+/*! \fn int hwMbox_sendReplyOpcode(hw_mbox_Masters_e commander,
+                                   Uint32 code,
+                                   Uint8 *dataBuf, Uint32 *dataLen)
+ **************************************************************************
+ *  \brief Send a reply to an opcode received from <commander> using the HW_MBOX.
+ *  \attention should only be used after an opcode has been received from <commander>.
+ *  \param[in] commander - To which Master should the reply be sent.
+ *  \param[in] code - reply code.
+ *  \param[in] dataBuf - pointer to a Buffer containing more data to be sent.
+ *  \param[in] dataLen - Length in Bytes of data to be sent from buffer
+ *                       specified in <dataBuf>.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_sendReplyOpcode(hw_mbox_Masters_e commander,
+                           Uint32 code,
+                           Uint8 *dataBuf, Uint32 dataLen)
+{
+    Uint32 paramCID, cmdRegVal, codeMaxVal;
+    hwMbox_opcode_t opFlds = { 0 };
+
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+
+    DPRINTK("send Reply Opcode to %s(%d) [code 0x%x (%u) with %uB of data]",
+             HW_MBOX_MASTER_GET_NAME(commander), commander,
+             code, code, dataLen);
+
+    codeMaxVal = HW_MBOX_OPCODE_CODE_MAX_VALUE;
+    if (code > codeMaxVal)
+    {
+        PRINTK_ERR("send Reply Opcode to %s(%d) - code value 0x%x (%u) > max possible value 0x%x (%u)!",
+                   HW_MBOX_MASTER_GET_NAME(commander), commander,
+                   code, code, codeMaxVal, codeMaxVal);
+
+        return (-1);
+    }
+
+    if ((dataBuf != NULL) && ((dataLen % 4) != 0))
+    {
+        /* Opcode Reply data is always a multiple of 4 Bytes! */
+        PRINTK_ERR("send Reply Opcode to %s(%d) - opcode reply data length (%uB) must be a multiple of 4!",
+                   HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen);
+
+        return (-1);
+    }
+
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_opcode, True, return (-1), paramCID);
+
+    if ((dataBuf != NULL) && (dataLen > 0))
+    {
+        /* opcode Reply has data! save to SRAM: */
+
+        /* verify SRAM size: */
+        if (dataLen > CHN_CFG_MEMBUFF_GET_SIZE(paramCID))
+        {
+            PRINTK_ERR("send Reply Opcode to %s(%d) - opcode reply data length (%uB) > SRAM allocated to channel (%uB)!",
+                       HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID));
+
+            return (-1);
+        }
+
+
+        DPRINTK("send Reply Opcode to %s(%d) - copying %uB of opcode reply data to SRAM",
+                HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen);
+
+        DPRINTK("cid %d: copying %uB [out of total %uB channel has] to SRAM at offset=0x%08x",
+                paramCID, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+        HW_MBOX_COPY_TO_SRAM(dataBuf, dataLen, CHN_CFG_MEMBUFF_GET_START(paramCID));
+    }
+
+    /* get the current command register value to modify: */
+    cmdRegVal = HW_MBOX_CHN_COMMAND_REG_GET(paramCID);
+    HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT(cmdRegVal, &opFlds);
+
+    /* update with the required code: */
+    opFlds.code = code;
+
+    /* Flags are currently reserved! */
+    opFlds.flagA = 0;
+    opFlds.flagB = 0;
+
+    /* update with the required size: */
+    opFlds.lenInBytes = dataLen;
+
+    DPRINTK("cid %d: opcode fields - tag=%u, code=%u=0x%x, A=%d, B=%d, lenInBytes=%u",
+            paramCID, opFlds.tag, opFlds.code, opFlds.code,
+            opFlds.flagA, opFlds.flagB, opFlds.lenInBytes);
+
+    /* create opcode reply: */
+    HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT(cmdRegVal, &opFlds);
+
+    /* Send Opcode Reply to commander */
+    DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+    DPRINTK("cid %d: writing 0x%08x to the command register of the channel...", paramCID, cmdRegVal);
+    HW_MBOX_CHN_COMMAND_REG_SET(paramCID, cmdRegVal);
+    DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+
+    return 0;
+}
+EXPORT_SYMBOL(hwMbox_sendReplyOpcode);
+
+/**************************************************************************/
+/*! \fn int hwMbox_registerRecvOpcode(hw_mbox_Masters_e commander,
+                                      hwMboxRecvOpcodeCallback pOpcodeCallbackFunc,
+                                      Uint32 tag,
+                                      Uint32 token)
+ **************************************************************************
+ *  \brief Register for Receive Opcode from <commander> using the HW_MBOX.
+ *  \attention This function should be called once per tag.
+ *  \param[in] commander - From which Master should the opcode be received.
+ *  \param[in] pOpcodeCallbackFunc - pointer to the callback function to be 
+ *                                   invoked upon receiving an opcode from
+ *                                   <commander>.
+ *  \param[in] tag - indicates the destination.
+ *  \param[in] token - 32 bit value saved in DB that can be used by application.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_registerRecvOpcode(hw_mbox_Masters_e commander,
+                              hwMboxRecvOpcodeCallback pOpcodeCallbackFunc,
+                              Uint32 tag,
+                              Uint32 token)
+{
+    int i;
+    Uint32 paramCID, nextTagIndex;
+
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+
+    if (pOpcodeCallbackFunc == NULL)
+    {
+        PRINTK_ERR("pOpcodeCallbackFunc == NULL!");
+        return (-1);
+    }
+
+    DPRINTK("register Receive Opcode from %s(%d) [tag %u token 0x%x (%u)]",
+            HW_MBOX_MASTER_GET_NAME(commander), commander, tag, token, token);
+
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_opcode, True, return (-1), paramCID);
+
+    if (CHN_RECV_OPCODE_GET_INDEX(paramCID) == CHN_RECV_OPCODE_INDEX_INVALID)
+    {
+        /* should generally not happen since it is changed by
+           set channel config, but it doesn't hurt to make sure... */
+
+        PRINTK_ERR("recvOpIndex == CHN_RECV_OPCODE_INDEX_INVALID");
+        return (-1);
+    }
+
+    if ((tag == HW_MBOX_OPCODE_TAG) || (tag == HW_MBOX_OPCODE_USER_SPACE_TAG))
+    {
+        PRINTK_ERR("register Receive Opcode from %s(%d) - can't register tag %u, it is reserved for HW MBOX!",
+                   HW_MBOX_MASTER_GET_NAME(commander), commander, tag);
+        return (-1);
+    }
+
+    /* seize channel lock */
+    if (down_interruptible(&CHN_LOCK(paramCID)))
+    {
+        return -ERESTARTSYS;
+    }
+
+    nextTagIndex = RECV_OP_GET_TAG_COUNT(paramCID);
+    if (nextTagIndex == HW_MBOX_OPCODE_TAG_COUNT)
+    {
+        DPRINTK("register Receive Opcode from %s(%d) - max registered tag count (%d) reached!",
+                HW_MBOX_MASTER_GET_NAME(commander), commander, HW_MBOX_OPCODE_TAG_COUNT);
+
+        /* release lock */
+        up(&CHN_LOCK(paramCID));
+        return (-1);
+    }
+
+    /* verify that tag is not already registered... */
+    for (i = 0; i < nextTagIndex; i++)
+    {
+        if(RECV_OP_GET_TAG(paramCID, i) == tag)
+        {
+            PRINTK_ERR("register Receive Opcode from %s(%d) - tag %u is already registered!",
+                        HW_MBOX_MASTER_GET_NAME(commander), commander, tag);
+
+            /* release lock */
+            up(&CHN_LOCK(paramCID));
+            return 0;
+        }
+    }
+
+    RECV_OP_SET_TAG(paramCID, nextTagIndex, tag);
+    RECV_OP_SET_CB(paramCID, nextTagIndex, pOpcodeCallbackFunc);
+    RECV_OP_SET_TOKEN(paramCID, nextTagIndex, token);
+
+    RECV_OP_INC_TAG_COUNT(paramCID);
+
+    DPRINTK("register Receive Opcode from %s(%d) - tag %u successfully registered!",
+            HW_MBOX_MASTER_GET_NAME(commander), commander, tag);
+
+    /* release lock */
+    up(&CHN_LOCK(paramCID));
+    return 0;
+}
+EXPORT_SYMBOL(hwMbox_registerRecvOpcode);
+
+/************************************************************************/
+/*     HW_MBOX proc file system utilities:                              */
+/************************************************************************/
+
+/*! \def HW_MBOX_PROC_DIR_STR
+    \brief proc dir: /proc/HW_MBOX */
+#define HW_MBOX_PROC_DIR_STR    "hw_mbox"
+
+/* Define all Simple Procs here: */
+
+SEQ_PROC_DEFINE_SIMPLE(proc_dump_core_version);
+SEQ_PROC_DEFINE_SIMPLE(proc_dump_control_regs);
+SEQ_PROC_DEFINE_SIMPLE(proc_dump_status);
+SEQ_PROC_DEFINE_SIMPLE(proc_dump_ctrlDb);
+
+/* Define all SEQ Procs here: */
+
+SEQ_PROC_DEFINE(proc_dump_masters_regs);
+SEQ_PROC_DEFINE(proc_dump_channels_regs);
+SEQ_PROC_DEFINE(proc_dump_assignedChannels_regs);
+SEQ_PROC_DEFINE(proc_dump_interrupts);
+SEQ_PROC_DEFINE(proc_dump_LUT);
+SEQ_PROC_DEFINE(proc_dump_serviceCounter);
+SEQ_PROC_DEFINE(proc_dump_masterDb);
+SEQ_PROC_DEFINE(proc_dump_chnDb);
+SEQ_PROC_DEFINE(proc_dump_recvOpDb);
+SEQ_PROC_DEFINE(proc_dump_recvOpTagsDb);
+
+/* Implement all simple procs here: */
+
+/*! \fn static int proc_dump_core_version(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Core Version proc (reads ID registers). */
+static int proc_dump_core_version(struct seq_file *m, void *v)
+{
+    seq_printf(m, "HW_MBOX Core Version: %d.%d\n", HW_MBOX_ID_MAJOR_GET(), HW_MBOX_ID_MINOR_GET());
+    return 0;
+}
+
+/*! \fn static int proc_dump_control_regs(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Control Registers proc. */
+static int proc_dump_control_regs(struct seq_file *m, void *v)
+{
+    seq_printf(m, "ID:     0x%08x\n", HW_MBOX_ID_REG_GET());
+    seq_printf(m, "CTRL:   0x%08x\n", HW_MBOX_CTRL_REG_GET());
+    seq_printf(m, "ERROR:  0x%08x\n", HW_MBOX_ERROR_REG_GET());
+    return 0;
+}
+
+/*! \fn static int proc_dump_status(struct seq_file *m, void *v)
     \brief dump HW_MBOX Status proc (parses data from Control Registers). */
 static int proc_dump_status(struct seq_file *m, void *v)
 {
-    seq_printf(m, "HW_MBOX status:\n");
-    seq_printf(m, "LOCKED:          %s\n", YESNO_STR(HW_MBOX_CTRL_LOCK_GET()));
-    seq_printf(m, "STARTED:         %s\n", YESNO_STR(HW_MBOX_CTRL_START_GET()));
-    seq_printf(m, "HW DEBUG MODE:   %s\n", YESNO_STR(HW_MBOX_CTRL_DEBUG_GET()));
-    seq_printf(m, "Supervisor:      %s(%d)\n", HW_MBOX_MASTER_GET_NAME(HW_MBOX_CTRL_SUPERVISOR_GET()),
-                                               HW_MBOX_CTRL_SUPERVISOR_GET());
-    if (HW_MBOX_CTRL_MON_EXIST_GET())
+    seq_printf(m, "HW_MBOX status:\n");
+    seq_printf(m, "LOCKED:          %s\n", YESNO_STR(HW_MBOX_CTRL_LOCK_GET()));
+    seq_printf(m, "STARTED:         %s\n", YESNO_STR(HW_MBOX_CTRL_START_GET()));
+    seq_printf(m, "HW DEBUG MODE:   %s\n", YESNO_STR(HW_MBOX_CTRL_DEBUG_GET()));
+    seq_printf(m, "Supervisor:      %s(%d)\n", HW_MBOX_MASTER_GET_NAME(HW_MBOX_CTRL_SUPERVISOR_GET()),
+                                               HW_MBOX_CTRL_SUPERVISOR_GET());
+    if (HW_MBOX_CTRL_MON_EXIST_GET())
+    {
+        seq_printf(m, "Monitor:         %s(%d)\n", HW_MBOX_MASTER_GET_NAME(HW_MBOX_CTRL_MONITOR_GET()),
+                                                   HW_MBOX_CTRL_MONITOR_GET());
+    }
+    else
+    {
+        seq_printf(m, "Monitor:         There is no Monitor defined.\n");
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_ctrlDb(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Control DB proc. */
+static int proc_dump_ctrlDb(struct seq_file *m, void *v)
+{
+    seq_printf(m, "HW_MBOX Ctrl DB:\n");
+    seq_printf(m, "LOCKED:          %s\n", YESNO_STR(CTRL_GET_IS_LOCKED()));
+    seq_printf(m, "STARTED:         %s\n", YESNO_STR(CTRL_GET_IS_STARTED()));
+    seq_printf(m, "HW DEBUG MODE:   %s\n", YESNO_STR(CTRL_GET_IS_HW_DEBUG_MODE()));
+    seq_printf(m, "Supervisor:      %s(%d)\n", HW_MBOX_MASTER_GET_NAME(CTRL_GET_SUPERVISOR()),
+                                               CTRL_GET_SUPERVISOR());
+    if (CTRL_GET_MONITOR() != HW_MBOX_MID_INVALID)
+    {
+        seq_printf(m, "Monitor:         %s(%d)\n", HW_MBOX_MASTER_GET_NAME(CTRL_GET_MONITOR()),
+                                                   CTRL_GET_MONITOR());
+    }
+    else
+    {
+        seq_printf(m, "Monitor:         There is no Monitor defined.\n");
+    }
+
+    return 0;
+}
+
+/* Implement all SEQ show functions here: */
+
+/*! \fn static int proc_dump_masters_regs_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Masters Registers. */
+static int proc_dump_masters_regs_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+    if (i < HW_MBOX_MASTER_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+            seq_printf(m, "+------+-----------------------+-----------------------+-------------------------+-----------------------+\n");
+            seq_printf(m, "| MID# |   SHADOW_H SHADOW_L   |     MASK_H MASK_L     | COMMANDER_H COMMANDER_L |  SUBJECT_H SUBJECT_L  |\n");
+            /* Value fmt: "|  ##  | 0x00000000 0x00000000 | 0x00000000 0x00000000 |  0x00000000 0x00000000  | 0x00000000 0x00000000 |" */
+        }
+
+        seq_printf(m, "|  %2d  | 0x%08x 0x%08x | 0x%08x 0x%08x |  0x%08x 0x%08x  | 0x%08x 0x%08x |\n", i,
+                   HW_MBOX_MASTER_PARAM_INTR_CLEAR_H_REG_GET(i), HW_MBOX_MASTER_PARAM_INTR_CLEAR_L_REG_GET(i),
+                   HW_MBOX_MASTER_PARAM_INTR_MASK_H_REG_GET(i), HW_MBOX_MASTER_PARAM_INTR_MASK_L_REG_GET(i),
+                   HW_MBOX_MASTER_PARAM_COMMANDER_H_REG_GET(i), HW_MBOX_MASTER_PARAM_COMMANDER_L_REG_GET(i),
+                   HW_MBOX_MASTER_PARAM_SUBJECT_H_REG_GET(i), HW_MBOX_MASTER_PARAM_SUBJECT_L_REG_GET(i));
+
+        if ((HW_MBOX_MASTER_COUNT - 1) == i)
+        {
+            /* End of table print trailing line */
+            seq_printf(m, "+------+-----------------------+-----------------------+-------------------------+-----------------------+\n");
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_channels_regs_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Channels Registers. */
+static int proc_dump_channels_regs_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+    if (i < HW_MBOX_CHANNEL_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+            seq_printf(m, "+------+-------------+-------------+-------------+-------------+\n");
+            seq_printf(m, "| CHN# |   CHN_CFG   |  CHN_STATE  | CHN_COMMAND |   MEM_MAP   |\n");
+            /* Value fmt: "|  ##  |  0x00000000 |  0x00000000 |  0x00000000 |  0x00000000 |" */
+        }
+
+        seq_printf(m, "|  %2d  |  0x%08x |  0x%08x |  0x%08x |  0x%08x |\n", i, 
+                   HW_MBOX_CHN_CFG_REG_GET(i), HW_MBOX_CHN_STATE_REG_GET(i),
+                   HW_MBOX_CHN_COMMAND_REG_GET(i), HW_MBOX_MEMORY_MAP_REG_GET(i));
+
+        if ((HW_MBOX_CHANNEL_COUNT - 1) == i)
+        {
+            /* End of table print trailing line */
+            seq_printf(m, "+------+-------------+-------------+-------------+-------------+\n");
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_assignedChannels_regs_show(struct seq_file *m, void *v)
+    \brief dumps assigned HW_MBOX Channels Registers (according to DB). */
+static int proc_dump_assignedChannels_regs_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+    if (i < HW_MBOX_CHANNEL_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+            seq_printf(m, "+------+-------------+-------------+-------------+-------------+\n");
+            seq_printf(m, "| CHN# |   CHN_CFG   |  CHN_STATE  | CHN_COMMAND |   MEM_MAP   |\n");
+            /* Value fmt: "|  ##  |  0x00000000 |  0x00000000 |  0x00000000 |  0x00000000 |" */
+        }
+
+        if (CHN_IS_ASSIGNED(i))
+        {
+            seq_printf(m, "|  %2d  |  0x%08x |  0x%08x |  0x%08x |  0x%08x |\n", i,
+                       HW_MBOX_CHN_CFG_REG_GET(i), HW_MBOX_CHN_STATE_REG_GET(i),
+                       HW_MBOX_CHN_COMMAND_REG_GET(i), HW_MBOX_MEMORY_MAP_REG_GET(i));
+        }
+
+        if ((HW_MBOX_CHANNEL_COUNT - 1) == i)
+        {
+            /* End of table print trailing line */
+            seq_printf(m, "+------+-------------+-------------+-------------+-------------+\n");
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_interrupts_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Interrupts Data. */
+static int proc_dump_interrupts_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+    if (i < HW_MBOX_CHANNEL_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+            seq_printf(m, " CID         INTR\n");
+        }
+        seq_printf(m, " %2d:   %10u\n", i, CHN_INTR_GET_COUNT(i));
+
+        if (i == HW_MBOX_CHANNEL_COUNT - 1) /* Last Line */
+        {
+            seq_printf(m, "err:   %10u\n", GET_ERR_INTR());
+            seq_printf(m, "ghost: %10u\n", GET_GHOST_INTR());
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_LUT_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX channel LUT [invalid CID is 0xffffffff]. */
+static int proc_dump_LUT_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+
+    hw_mbox_type_e type;
+
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+    if (i < HW_MBOX_MASTER_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+
+            /* "+------+------------+------------+------------+ ... "
+               "|      |            |  SEND      |  RECV      | ... "
+               "| MID# |   MASTER   |  CHN_TYPE  |  CHN_TYPE  | ... "
+          fmt: "|  ##  | ********** | 0x00000000 | 0x00000000 | for every type..." */
+
+            seq_printf(m, "+------+------------+");
+            for (type = 0; type < HW_MBOX_TYPE_COUNT; type++)
+            {
+                seq_printf(m, "------------+------------+");
+            }
+            seq_printf(m, "\n");
+
+            seq_printf(m, "|      |            |");
+
+            for (type = 0; type < HW_MBOX_TYPE_COUNT; type++)
+            {
+                seq_printf(m, "  SEND      |  RECV      |");
+            }
+            seq_printf(m, "\n");
+
+            seq_printf(m, "| MID# |   MASTER   |");
+
+            for (type = 0; type < HW_MBOX_TYPE_COUNT; type++)
+            {
+                seq_printf(m, "  %-8s  |  %-8s  |", HW_MBOX_TYPE_STR(type), HW_MBOX_TYPE_STR(type));
+            }
+            seq_printf(m, "\n");
+        }
+
+        seq_printf(m, "|  %2d  | %-10s |", i, HW_MBOX_MASTER_GET_NAME(i));
+
+        for (type = 0; type < HW_MBOX_TYPE_COUNT; type++)
+        {
+            seq_printf(m, " 0x%08x | 0x%08x |", FIND_CID_IN_LUT(i, type, False), FIND_CID_IN_LUT(i, type, True));
+            /* fmt:          SEND  |  RECV  | */
+        }
+        seq_printf(m, "\n");
+
+        if (i == HW_MBOX_MASTER_COUNT - 1) /* Last Line */
+        {
+            seq_printf(m, "+------+------------+");
+            for (type = 0; type < HW_MBOX_TYPE_COUNT; type++)
+            {
+                seq_printf(m, "------------+------------+");
+            }
+            seq_printf(m, "\n");
+
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_serviceCounter_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX service counter statistics data. */
+static int proc_dump_serviceCounter_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+
+    hw_mbox_type_e type;
+
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+    if (i < HW_MBOX_MASTER_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+
+            /* "+------+------------+------------+------------+ ... "
+               "|      |            |  SEND      |  RECV      | ... "
+               "| MID# |   MASTER   |  CHN_TYPE  |  CHN_TYPE  | ... "
+          fmt: "|  ##  | ********** | 0000000000 | 0000000000 | for every type..." */
+
+            seq_printf(m, "+------+------------+");
+            for (type = 0; type < HW_MBOX_TYPE_COUNT; type++)
+            {
+                seq_printf(m, "------------+------------+");
+            }
+            seq_printf(m, "\n");
+
+            seq_printf(m, "|      |            |");
+
+            for (type = 0; type < HW_MBOX_TYPE_COUNT; type++)
+            {
+                seq_printf(m, "  SEND      |  RECV      |");
+            }
+            seq_printf(m, "\n");
+
+            seq_printf(m, "| MID# |   MASTER   |");
+
+            for (type = 0; type < HW_MBOX_TYPE_COUNT; type++)
+            {
+                seq_printf(m, "  %-8s  |  %-8s  |", HW_MBOX_TYPE_STR(type), HW_MBOX_TYPE_STR(type));
+            }
+            seq_printf(m, "\n");
+        }
+
+        seq_printf(m, "|  %2d  | %-10s |", i, HW_MBOX_MASTER_GET_NAME(i));
+
+        for (type = 0; type < HW_MBOX_TYPE_COUNT; type++)
+        {
+            seq_printf(m, " %10u | %10u |", STATS_GET_COUNTER(i, type, False), STATS_GET_COUNTER(i, type, True));
+            /* fmt:         SEND | RECV | */
+        }
+        seq_printf(m, "\n");
+
+        if (i == HW_MBOX_MASTER_COUNT - 1) /* Last Line */
+        {
+            seq_printf(m, "+------+------------+");
+            for (type = 0; type < HW_MBOX_TYPE_COUNT; type++)
+            {
+                seq_printf(m, "------------+------------+");
+            }
+            seq_printf(m, "\n");
+
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_masterDb_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX master DB Data. */
+static int proc_dump_masterDb_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+    if (i < HW_MBOX_MASTER_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+            seq_printf(m, "+------+------------+-------+------+------------+------------+\n");
+            seq_printf(m, "| MID# |   MASTER   | VALID | INIT | SW SUPPORT |   ERRORS   |\n");
+            /*       fmt: "|  ##  | ********** |  ***  | ***  | *******    | ########## |" */
+        }
+
+        seq_printf(m, "|  %2d  | %-10s |  %-3s  | %-3s  | %-7s    | %10u |\n", 
+                   i,
+                   HW_MBOX_MASTER_GET_NAME(i),
+                   YESNO_STR(IS_MASTER_VALID(i)),
+                   YESNO_STR(IS_MASTER_INIT(i)),
+                   HW_MBOX_SUPPORT_STR(MASTER_CFG_GET_SUPPORT(i)),
+                   MASTER_GET_ERROR_COUNT(i));
+
+        if (i == HW_MBOX_MASTER_COUNT - 1) /* Last Line */
+        {
+            seq_printf(m, "+------+------------+-------+------+------------+------------+\n");
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_chnDb_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX channel DB Data. */
+static int proc_dump_chnDb_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+    if (i < HW_MBOX_CHANNEL_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+            seq_printf(m, "+------+-------+---------------+---------------+---------------+-------------+-----------+---------------+--------------+\n");
+            seq_printf(m, "| CHN# | VALID |   MBOX TYPE   |   COMMANDER   |    SUBJECT    | SRAM OFFSET | SRAM SIZE |  CHN_INTR_ST  | RECVOP INDEX |\n");
+                  /* fmt: "|  ##  |  ***  | ************  | ## ********** | ## ********** |  0x00000000 |  00000000 |            00 |           00 |" */
+        }
+
+        if (CHN_IS_ASSIGNED(i))
+        {
+            /* only prints assigned channels */
+            seq_printf(m, "|  %2d  |  %-3s  |  %-12s | %02d %-10s | %02d %-10s |  0x%08x |  %8u |            %2d |           %2d |\n", 
+                       i,
+                       YESNO_STR(CHN_IS_VALID(i)),
+                       HW_MBOX_TYPE_STR(CHN_CFG_GET_TYPE(i)),
+                       CHN_CFG_GET_COMMANDER(i) , HW_MBOX_MASTER_GET_NAME(CHN_CFG_GET_COMMANDER(i)),
+                       CHN_CFG_GET_SUBJECT(i) , HW_MBOX_MASTER_GET_NAME(CHN_CFG_GET_SUBJECT(i)),
+                       CHN_CFG_MEMBUFF_GET_START(i), CHN_CFG_MEMBUFF_GET_SIZE(i),
+                       CHN_INTR_GET_STATE(i),
+                       CHN_RECV_OPCODE_GET_INDEX(i));
+
+        }
+
+        if (i == HW_MBOX_CHANNEL_COUNT - 1) /* Last Line */
+        {
+            seq_printf(m, "+------+-------+---------------+---------------+---------------+-------------+-----------+---------------+--------------+\n");
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_recvOpDb_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX receive Opcode DB Data. */
+static int proc_dump_recvOpDb_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+
+    if (i < HW_MBOX_OPCODE_RECV_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+            seq_printf(m, "+--------+-------------+-------------+---------------+------------------+\n");
+            seq_printf(m, "| RECVOP | REG TAG CNT | WAKE UP CNT |  APP_INTR_ST  | INVALID TAG MSGS |\n");
+                  /* fmt: "|     ## |  0000000000 |  0000000000 |            00 |       0000000000 |" */
+        }
+
+        if (RECV_OP_THREAD_BY_INDEX(i) != NULL)
+        {
+            /* only prints assigned recvOp indices */
+            seq_printf(m, "|     %2d |  %10u |  %10u |            %2d |       %10u |\n",
+                       i,
+                       RECV_OP_GET_TAG_COUNT_BY_INDEX(i),
+                       RECV_OP_GET_WAKEUP_COUNT_BY_INDEX(i),
+                       RECV_OP_APP_GET_STATE_BY_INDEX(i),
+                       RECV_OP_GET_INVALID_TAG_COUNT_BY_INDEX(i));
+        }
+        else
+        {
+            /* no more data, we can already end here... */
+            seq_printf(m, "+--------+-------------+-------------+---------------+------------------+\n");
+            controlData->endOfData = True;
+        }
+
+        if (i == HW_MBOX_OPCODE_RECV_COUNT - 1) /* Last Line */
+        {
+            seq_printf(m, "+--------+-------------+-------------+---------------+------------------+\n");
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_recvOpTagsDb_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX receive Opcode Tags DB Data. */
+static int proc_dump_recvOpTagsDb_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    Uint32 recvOpIndex, tagIndex;
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+
+    if (i < (HW_MBOX_OPCODE_RECV_COUNT * HW_MBOX_OPCODE_TAG_COUNT))
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+            seq_printf(m, "+--------+-----+----------+-------------+\n");
+            seq_printf(m, "| RECVOP | TAG |  CB_PTR  |    TOKEN    |\n");
+                  /* fmt: "|     ## | ### | 00000000 |  0x00000000 |" */
+        }
+
+        /* find the correct internal indices */
+        tagIndex = i % HW_MBOX_OPCODE_TAG_COUNT;
+
+        recvOpIndex = 0;
+        while ((recvOpIndex * HW_MBOX_OPCODE_TAG_COUNT) < i) /* to avoid division... */
+        {
+            recvOpIndex++;
+        }
+
+        if (recvOpData[recvOpIndex].listenerThread != NULL)
+        {
+            if (tagIndex < recvOpData[recvOpIndex].registeredCount)
+            {
+                /* only prints assigned recvOp indices */
+                seq_printf(m, "|     %2d | %3d | %-8p |  0x%08x |\n",
+                           recvOpIndex,
+                           RECV_OP_GET_TAG_BY_INDEX(recvOpIndex, tagIndex),
+                           RECV_OP_GET_CB_BY_INDEX(recvOpIndex, tagIndex),
+                           RECV_OP_GET_TOKEN_BY_INDEX(recvOpIndex, tagIndex));
+            }
+        }
+        else
+        {
+            /* no more data, we can already end here... */
+            seq_printf(m, "+--------+-----+----------+-------------+\n");
+            controlData->endOfData = True;
+        }
+
+        if (i == (HW_MBOX_OPCODE_RECV_COUNT * HW_MBOX_OPCODE_TAG_COUNT) - 1) /* Last Line */
+        {
+            seq_printf(m, "+--------+-----+----------+-------------+\n");
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/************************************************************************/
+/*     HW_MBOX Kernel Local Functions                                   */
+/************************************************************************/
+
+/**************************************************************************/
+/*! \fn int hwMbox_initAfterStarted(void)
+ **************************************************************************
+ *  \brief Dynamically initialize the HW MBOX according to the set HW 
+ *         configuration, previously set by supervisor.
+ *  \note used by non-supervisor to learn initial configurtion.
+ *  \note used by supervisor after warm boot. 
+ *  \return [ 0 on success /(-1) on error ].
+ **************************************************************************/
+int hwMbox_initAfterStarted(void)
+{
+    int paramCID;
+    hw_mbox_channelConfig_t chnConfig;
+
+    if (!HW_MBOX_IS_STARTED())
+    {
+        /* HW_MBOX is not started yet... */
+        PRINTK_ERR("HW_MBOX is not started! can't learn configuration yet...");
+        return (-1);
+    }
+
+    /* HW MBOX is started!!! */
+    CTRL_SET_IS_STARTED(True); /* set in DB... */
+
+    /* dynamically learn set configuration from HW: */
+    DPRINTK("dynamically learn set configuration from HW...");
+
+    /* general configuration values: */
+    if (HW_MBOX_CTRL_MON_EXIST_GET() == True)
+    {
+        CTRL_SET_MONITOR(HW_MBOX_CTRL_MONITOR_GET());
+        DPRINTK("Monitor = %s(%d)", HW_MBOX_MASTER_GET_NAME(CTRL_GET_MONITOR()),
+                                    CTRL_GET_MONITOR());
+    }
+    else
+    {
+        CTRL_SET_MONITOR(HW_MBOX_MID_INVALID);
+        DPRINTK("There's no Monitor configured...");
+    }
+
+    /* HW Debug Mode: */
+    if (HW_MBOX_CTRL_DEBUG_GET() == True)
+    {
+        DPRINTK("HW Debug Mode is set!");
+        CTRL_SET_IS_HW_DEBUG_MODE(True);
+    }
+    else
+    {
+        DPRINTK("HW Debug Mode is not set!");
+        CTRL_SET_IS_HW_DEBUG_MODE(False);
+    }
+
+    /* HW Lock: */
+    if (HW_MBOX_CTRL_LOCK_GET() == True)
+    {
+        DPRINTK("HW Lock is set!");
+        CTRL_SET_IS_LOCKED(True);
+    }
+    else
+    {
+        DPRINTK("HW Lock is not set yet...");
+        CTRL_SET_IS_LOCKED(False);
+    }
+
+    /* Channel Configurations: */
+    for (paramCID = 0; paramCID < HW_MBOX_CHANNEL_COUNT; paramCID++)
+    {
+        DPRINTK("checking channel %d...", paramCID);
+        if (HW_MBOX_CHN_CFG_VALID_GET(paramCID) == True) 
+        {
+            DPRINTK("channel %d is assigned!", paramCID);
+            HW_MBOX_CHANNEL_CONFIG_GET_TO_STRUCT(paramCID, &chnConfig);
+            DPRINTK("found new static channel (cid=%d): %s MBOX, %s(%d) -> %s(%d) [%uB of SRAM]",
+                    paramCID, HW_MBOX_TYPE_STR(chnConfig.mboxType),
+                    HW_MBOX_MASTER_GET_NAME(chnConfig.commander), chnConfig.commander,
+                    HW_MBOX_MASTER_GET_NAME(chnConfig.subject), chnConfig.subject,
+                    chnConfig.memBuff.size);
+
+            if ((IS_SUPERVISOR() /* supervisor gets all channels */) ||
+                (IS_MONITOR()    /* monitor gets all channels */)    ||
+                (chnConfig.commander == HW_MBOX_MID) ||
+                (chnConfig.subject == HW_MBOX_MID))
+            {
+                if (!CHN_IS_ASSIGNED(paramCID))
+                {
+                    /* some channels might already be assigned [like initial RecvOp]... */
+                    hwMbox_setChannelConfig(chnConfig);
+
+                    /* if this master is the commander it should reset SRAM
+                       [Note: at this point it must be possible since START must be already set] */
+
+                    if (chnConfig.commander == HW_MBOX_MID)
+                    {
+                        DPRINTK("cid=%d has this master as commander, do initial SRAM reset...", paramCID);
+                        DPRINTK("cid=%d resetting %uB of SRAM at start offset 0x%08x...",
+                                paramCID, chnConfig.memBuff.size, chnConfig.memBuff.start);
+
+                        HW_MBOX_RESET_SRAM(chnConfig.memBuff.start, chnConfig.memBuff.size);
+                    }
+                }
+                else
+                {
+                    DPRINTK("cid=%d is already updated in DB...", paramCID);
+                }
+
+                if (!CHN_IS_RECV_OP(paramCID))
+                {
+                    hwMbox_setChannelValid(paramCID, True); /* also updates LUTs */
+                    /* for recv Op channel valid is set by listener... */
+                }
+            }
+        }
+    }
+
+    /* Let all driver services that the device is initialized! */
+    SET_INITIALIZED();
+
+    return 0;
+}
+
+/**************************************************************************/
+/*! \fn int hwMbox_setChannelConfig(hw_mbox_channelConfig_t config)
+ **************************************************************************
+ *  \brief Set a channel's configuration in DB.
+ *  \param[in] config - struct containing channel's configuration.
+ *  \return [ 0 on success /(-1) on error ].
+ **************************************************************************/
+int hwMbox_setChannelConfig(hw_mbox_channelConfig_t config)
+{
+    static int recvOpcodeChannelsCount = 0;
+    Uint32 paramCID;
+    Int32 retVal = 0;
+
+    paramCID = config.cid;
+
+    DPRINTK("cid %d: update configuration in DB", paramCID);
+
+    /* recv Opcode channel... */
+    if ((config.mboxType == hw_mbox_opcode) &&
+        (config.subject == HW_MBOX_MID))
     {
-        seq_printf(m, "Monitor:         %s(%d)\n", HW_MBOX_MASTER_GET_NAME(HW_MBOX_CTRL_MONITOR_GET()),
-                                                   HW_MBOX_CTRL_MONITOR_GET());
+        if (recvOpcodeChannelsCount == HW_MBOX_OPCODE_RECV_COUNT)
+        {
+            PRINTK_ERR("cid %d cannot be configured! no more room for recv Opcode Channels [current recv Opcode Channel Count = %d]...",
+                       paramCID, recvOpcodeChannelsCount);
+
+            return (-1);
+        }
+    }
+
+    /* Copy configuration to the DB: */
+    memcpy(&CHN_CFG(paramCID), &config, HW_MBOX_CHANNEL_CONFIG_SIZE);
+
+    CHN_SET_ASSIGNED(paramCID, True);
+
+    if ((config.mboxType == hw_mbox_opcode) &&
+        (config.subject == HW_MBOX_MID))
+    {
+        /* recv Opcode channel: create the required infrastructure... */
+
+        if (NULL == RECV_OP_THREAD_BY_INDEX(recvOpcodeChannelsCount))
+        {
+            /* initialize the listener: 
+               This is not required for the first Receive Opcode Listener... */
+            RECV_OP_THREAD_SET_CID(recvOpcodeChannelsCount, paramCID);
+            RECV_OP_THREAD_SET_INDEX(recvOpcodeChannelsCount);
+
+            RECV_OP_THREAD_BY_INDEX(recvOpcodeChannelsCount) = kthread_run(hwMbox_recvOpcodeListenerEntry,
+                                                                           &RECV_OP_THREAD_DATA(recvOpcodeChannelsCount),
+                                                                           RECV_OPCODE_LISTENER_PREFIX"%02d",
+                                                                           recvOpcodeChannelsCount);
+            if (IS_ERR(RECV_OP_THREAD_BY_INDEX(recvOpcodeChannelsCount)))
+            {
+                retVal = PTR_ERR(RECV_OP_THREAD_BY_INDEX(recvOpcodeChannelsCount));
+                PRINTK_ERR("Creating %s%02d for CID %d Failed!!! [error %d]",
+                           RECV_OPCODE_LISTENER_PREFIX, recvOpcodeChannelsCount, paramCID, retVal);
+
+                RECV_OP_THREAD_BY_INDEX(recvOpcodeChannelsCount) = NULL;
+                CHN_RECV_OPCODE_SET_INDEX(paramCID, CHN_RECV_OPCODE_INDEX_INVALID);
+
+                return (-1);
+            }
+        }
+
+        CHN_RECV_OPCODE_SET_INDEX(paramCID, recvOpcodeChannelsCount);
+        recvOpcodeChannelsCount++;
     }
     else
     {
-        seq_printf(m, "Monitor:         There is no Monitor defined.\n");
+        /* not a receive Opcode channel... */
+        CHN_RECV_OPCODE_SET_INDEX(paramCID, CHN_RECV_OPCODE_INDEX_INVALID);
     }
 
     return 0;
 }
 
-/* Implement all SEQ show functions here: */
+/**************************************************************************/
+/*! \fn int hwMbox_setChannelValid(Uint32 paramCID, Bool isValid)
+ **************************************************************************
+ *  \brief Sets channel <paramCID> as valid/invalid according to <isValid>
+ *         in DB.
+ *  \note Also updates the LUTs.
+ *  \param[in] paramCID - which channel.
+ *  \param[in] isValid - valid/invalid.
+ *  \return [ 0 on success /(-1) on error ].
+ **************************************************************************/
+int hwMbox_setChannelValid(Uint32 paramCID, Bool isValid)
+{
+    DPRINTK("cid %d: set%s valid in DB", paramCID, ((isValid)?(""):(" NOT")));
 
-/*! \fn static int proc_dump_masters_regs_show(struct seq_file *m, void *v)
-    \brief dump HW_MBOX Masters Registers. */
-static int proc_dump_masters_regs_show(struct seq_file *m, void *v)
+    if (!HW_MBOX_CID_VALIDITY_CHECK(paramCID))
+    {
+        return (-1);
+    }
+
+    if (!CHN_IS_ASSIGNED(paramCID))
+    {
+        PRINTK_ERR("Trying to modify Valid for channel %d that has not been assigned!", paramCID);
+        return (-1);
+    }
+
+    CHN_SET_VALID(paramCID, isValid);
+
+    if ((CHN_CFG_GET_COMMANDER(paramCID) != HW_MBOX_MID) && 
+        (CHN_CFG_GET_SUBJECT(paramCID) != HW_MBOX_MID))
+    {
+        /* Master is not part of this channel... Don't add to LUTs!!!
+           (possible because supervisor sets valid for all channels) */
+        return 0;
+    }
+
+    if (CHN_CFG_GET_TYPE(paramCID) == hw_mbox_event)
+    {
+        /* Kernel doesn't currently support event channels */
+        DPRINTK("channel %d will not be set in LUT, as Kernel doesn't support event Channels yet!", paramCID);
+        return 0;
+    }
+
+    /* Update CID LUT: */
+    if (CHN_CFG_GET_COMMANDER(paramCID) == HW_MBOX_MID)
+    {
+        /* Master is commander on this channel [peer is subject]: */
+        SET_CID_IN_LUT( CHN_CFG_GET_SUBJECT(paramCID),
+                        CHN_CFG_GET_TYPE(paramCID),
+                        False,
+                        ((isValid)?(paramCID):(HW_MBOX_CID_INVALID)) );
+    }
+    else
+    {
+        /* Master is subject on this channel [peer is commander]: */
+        SET_CID_IN_LUT( CHN_CFG_GET_COMMANDER(paramCID),
+                        CHN_CFG_GET_TYPE(paramCID),
+                        True,
+                        ((isValid)?(paramCID):(HW_MBOX_CID_INVALID)) );
+    }
+
+    return 0;
+}
+
+/**************************************************************************/
+/*! \fn int hwMbox_waitForChannelInterrupt(int cid, int timeoutInMsec)
+ **************************************************************************
+ *  \brief wait for channel interrupt on <cid>
+ *  \note receive opcode channel waits on a different queue [Application Queue,
+ *        owned by the listener].
+ *  \param[in] cid - cid to wait on.
+ *  \param[in] timeoutInMsec - timeout [use CHN_INTR_NO_TIMEOUT for no timeout].
+ *  \note this function is blocking, returning only upon channel interrupt [or error].
+ *  \note this function also clears the channel interrupt.
+ *  \attnetion this is just the wait, if you need a lock then acquire it before...
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_waitForChannelInterrupt(int cid, int timeoutInMsec)
 {
-    seq_proc_if_control_data_t *controlData = m->private;
-    loff_t *spos = v;
-    Uint32 i = (Uint32)(*spos);
-    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
-    if (i < HW_MBOX_MASTER_COUNT)
+    long rc = 0;
+    wait_queue_head_t *pWq; /* pointer to the wait queue we should wait on */
+    chnIntrState_e *pState; /* pointer to the channel interrupt state we should query */
+
+    DPRINTK("cid %d: wait for channel interrupts...", cid);
+
+    if (CHN_IS_RECV_OP(cid))
+    {
+        /* Receive Opcode channel should wait on application queue */
+        pWq = &RECV_OP_APP_WQ(cid);
+        pState = &RECV_OP_APP_GET_STATE(cid);
+        DPRINTK("cid %d: using application queue...", cid);
+    }
+    else
     {
-        if (0 == i)
+        /* all other cases, wait on channel interrupt */
+        pWq = &CHN_INTR_WQ(cid);
+        pState = &CHN_INTR_GET_STATE(cid);
+        DPRINTK("cid %d: using channel queue...", cid);
+    }
+
+    DPRINTK("cid %d: pWQ=%p, pSTATE=%p", cid, pWq, pState);
+
+    /* wait for channel interrupts, on wait queue */
+    if (timeoutInMsec == CHN_INTR_NO_TIMEOUT)
+    {
+        DPRINTK("cid %d: no timeout...", cid);
+        if ( wait_event_interruptible(*pWq,
+                                      *pState != CHN_INTR_STATE_NONE) )
         {
-            /* We are in the first run, print line and headers */
-            seq_printf(m, "+------+-----------------------+-----------------------+-------------------------+-----------------------+\n");
-            seq_printf(m, "| MID# |   SHADOW_H SHADOW_L   |     MASK_H MASK_L     | COMMANDER_H COMMANDER_L |  SUBJECT_H SUBJECT_L  |\n");
-            /* Value fmt: "|  ##  | 0x00000000 0x00000000 | 0x00000000 0x00000000 |  0x00000000 0x00000000  | 0x00000000 0x00000000 |" */
+            DPRINTK("cid %d, wait interrupted by signal!", cid);
+            return CHN_INTR_RC_INTERRUPTED_BY_SIGNAL;
+        }
+    }
+    else
+    {
+        DPRINTK("cid %d: using timeout %d MSEC", cid, timeoutInMsec);
+        rc = wait_event_interruptible_timeout(*pWq,
+                                              *pState != CHN_INTR_STATE_NONE,
+                                              msecs_to_jiffies(timeoutInMsec));
+
+        DPRINTK("cid %d: rc=%ld", cid, rc);
+
+        /* if evaluated to true before timeout expires
+           returns the remaining amount of jiffies, else errors: */
+        if (rc <= 0)
+        {
+            if (0 == rc)
+            {
+                DPRINTK("cid %d: timeout expired!", cid);
+                return CHN_INTR_RC_TIMEOUT_EXPIRED;
+            }
+            else
+            {
+                DPRINTK("cid %d: wait interrupted by signal!", cid);
+                return CHN_INTR_RC_INTERRUPTED_BY_SIGNAL;
+            }
         }
+    }
 
-        seq_printf(m, "|  %2d  | 0x%08x 0x%08x | 0x%08x 0x%08x |  0x%08x 0x%08x  | 0x%08x 0x%08x |\n", i,
-                   HW_MBOX_MASTER_PARAM_INTR_CLEAR_H_REG_GET(i), HW_MBOX_MASTER_PARAM_INTR_CLEAR_L_REG_GET(i),
-                   HW_MBOX_MASTER_PARAM_INTR_MASK_H_REG_GET(i), HW_MBOX_MASTER_PARAM_INTR_MASK_L_REG_GET(i),
-                   HW_MBOX_MASTER_PARAM_COMMANDER_H_REG_GET(i), HW_MBOX_MASTER_PARAM_COMMANDER_L_REG_GET(i),
-                   HW_MBOX_MASTER_PARAM_SUBJECT_H_REG_GET(i), HW_MBOX_MASTER_PARAM_SUBJECT_L_REG_GET(i));
+    if (*pState != CHN_INTR_STATE_PENDING)
+    {
+        /* required if we will support more channel interrupt states... */
+        DPRINTK("cid %d: channel interrupt state is not pending! state=%d", cid, *pState);
+    }
 
-        if ((HW_MBOX_MASTER_COUNT - 1) == i)
+    *pState = CHN_INTR_STATE_NONE; /* we got the state, set to none... */
+    return CHN_INTR_RC_OK;
+}
+
+/**************************************************************************/
+/*! \fn int hwMbox_recvOpcodeListenerEntry(void *data)
+ **************************************************************************
+ *  \brief entry function for a receive opcode listener.
+ **************************************************************************/
+static int hwMbox_recvOpcodeListenerEntry(void *data)
+{
+#define LOG_RECVOP_LISTENER(fmt, args...)    DPRINTK("[RECV_OP_LISTENER#%d ON CID#%d]: " fmt, threadData->index, threadData->cid, ## args)
+
+    recvOpcodeListenerThreadData_t *threadData; /* This listener's data */
+
+    int i, cbRc;
+    Uint32 cmdRegVal; /* also re-used for listener replies */
+    Uint32 paramToken;
+
+    hwMbox_opcode_t opFlds = { 0 };
+    hw_mbox_channelConfig_t chnCfg = { 0 }; /* used only if first listener... */
+
+    hwMboxRecvOpcodeCallback recvOpCb;
+
+    threadData = data;
+
+    if ( IS_INIT_COMPLETE() || IS_SUPERVISOR() )
+    {
+        PRINTK_INFO("RECV OPCODE LISTENER#%d kernel thread on CID#%d started running...",
+                    threadData->index, threadData->cid);
+    }
+    else
+    {
+        /* Driver is waiting for INIT_COMPLETE from supervisor,
+           this is the first Listener used for initialization!
+
+           It should wait for INIT_COMPLETE notification,
+           It should then set its own configuration in DB...
+
+           Thread sets its own configuration so that ISR can do the bare possible minimum...
+        */
+
+        PRINTK_INFO("RECV OPCODE LISTENER#%d kernel thread used for initialization started running...",
+                    threadData->index);
+
+        DPRINTK("start waiting for INIT_COMPLETE from supervisor");
+
+        if( wait_event_interruptible(waitForInitCompleteWq, IS_INIT_COMPLETE()) )
         {
-            /* End of table print trailing line */
-            seq_printf(m, "+------+-----------------------+-----------------------+-------------------------+-----------------------+\n");
-            controlData->endOfData = True;
+            DPRINTK("First Listener thread interrupted by signal while waiting for INIT_COMPLETE...");
+            PRINTK_ERR("*** CRITICAL ERROR in HW MBOX initialization, no HW MBOX services will be avaiable ***");
+            return -ERESTARTSYS;
+        }
+
+        /* INIT_COMPLETE signaled by ISR! 
+           correct CID was set in thread Data by ISR, listener should do the rest... */
+
+        LOG_RECVOP_LISTENER("driver NOT initialized yet, This is the first Listener!");
+        LOG_RECVOP_LISTENER("set channel configuration in DB...");
+
+        HW_MBOX_CHANNEL_CONFIG_GET_TO_STRUCT(threadData->cid, &chnCfg);
+        hwMbox_setChannelConfig(chnCfg);
+    }
+
+    while (!CHN_IS_ASSIGNED(threadData->cid))
+    {
+        /* Make sure channel configuration has been written to DB... */
+        usleep_range(20, 100);
+    }
+
+    /* setup any required infrastructure: */
+    init_waitqueue_head(&RECV_OP_APP_WQ(threadData->cid));
+    RECV_OP_APP_SET_STATE(threadData->cid, CHN_INTR_STATE_NONE);
+
+    /* once all required infrastructure is ready we can set valid... */
+    hwMbox_setChannelValid(threadData->cid, True); /* also updates LUTs */
+
+    while (1)
+    {
+        /* cannot use hwMbox_waitForChannelInterrupt as it will redirect us to application
+           queue and we should wait on Channel Queue [without Timeout]... */
+
+        LOG_RECVOP_LISTENER("start waiting for channel interrupts...");
+
+        if ( wait_event_interruptible(CHN_INTR_WQ(threadData->cid),
+                                      CHN_INTR_GET_STATE(threadData->cid) != CHN_INTR_STATE_NONE) )
+        {
+            LOG_RECVOP_LISTENER("wait interrupted by signal!");
+            continue;
+        }
+
+        if (CHN_INTR_GET_STATE(threadData->cid) != CHN_INTR_STATE_PENDING)
+        {
+            /* required if we will support more channel interrupt states... */
+            LOG_RECVOP_LISTENER("channel interrupt state is not pending! state=%d", CHN_INTR_GET_STATE(threadData->cid));
+        }
+
+        CHN_INTR_SET_STATE(threadData->cid, CHN_INTR_STATE_NONE); /* we got the state, set to none... */
+
+        RECV_OP_INC_WAKEUP_COUNT(threadData->cid);
+
+        LOG_RECVOP_LISTENER("received channel interrupt!");
+        cmdRegVal = HW_MBOX_CHN_COMMAND_REG_GET(threadData->cid);
+        LOG_RECVOP_LISTENER("command register=0x%08x", cmdRegVal);
+
+        /* Parse the opcode fields to struct: */
+        HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT(cmdRegVal, &opFlds);
+
+        LOG_RECVOP_LISTENER("opcode fields: tag=%u, code=%u=0x%x, A=%d, B=%d, lenInBytes=%u",
+                            opFlds.tag, opFlds.code, opFlds.code,
+                            opFlds.flagA, opFlds.flagB, opFlds.lenInBytes);
+
+        /* cmdRegVal is reused for listener replies */
+        cmdRegVal = HW_MBOX_OPCODE_SET_LEN(cmdRegVal, 0);                     /* default value: no data */
+        cmdRegVal = HW_MBOX_OPCODE_SET_TAG(cmdRegVal, HW_MBOX_OPCODE_TAG);    /* listener response is internal */
+
+        /* Flags are currently reserved! */
+        cmdRegVal = HW_MBOX_OPCODE_SET_FLAG_A(cmdRegVal, 0);
+        cmdRegVal = HW_MBOX_OPCODE_SET_FLAG_B(cmdRegVal, 0);
+
+        /* first handle Kernel HW MBOX tag: */
+        if (opFlds.tag == HW_MBOX_OPCODE_TAG)
+        {
+            LOG_RECVOP_LISTENER("Handling Kernel HW MBOX TAG(%u)", HW_MBOX_OPCODE_TAG);
+
+            if (!IS_INITIALIZED())
+            {
+                /* Driver is not initialized yet... */
+                LOG_RECVOP_LISTENER("driver NOT initialized yet...");
+
+                /* at this point command must be init complete... */
+
+                if (opFlds.code == HW_MBOX_CODE_INIT_COMPLETE)
+                {
+                    LOG_RECVOP_LISTENER("Handling INIT_COMPLETE code %u", HW_MBOX_CODE_INIT_COMPLETE);
+                    hwMbox_initAfterStarted();
+
+                    /* Currently hwMbox_initAfterStarted will always succeed here, since it is called in response
+                       to an interrupt so HW MBOX must be started and the function can only fail if it is called 
+                       and start is not set yet...  
+                    */
+
+                    /* Success! */
+                    LOG_RECVOP_LISTENER("INIT_COMPLETE! report back to supervisor...");
+                    cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_OK);
+                }
+                else
+                {
+                    /* shouldn't happen, kept here as a safety precaution... */
+                    LOG_RECVOP_LISTENER("First opcode should be INIT_COMPLETE %u...", HW_MBOX_CODE_INIT_COMPLETE);
+
+                    cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_NOK);
+                    goto SEND_OP_REPLY;
+                }
+            }
+            else
+            {
+                /* initialized! */
+                LOG_RECVOP_LISTENER("driver is initialized!!!");
+
+                switch (opFlds.code)
+                {
+                    case HW_MBOX_CODE_INIT_COMPLETE:
+                        LOG_RECVOP_LISTENER("Handling INIT_COMPLETE code %u", HW_MBOX_CODE_INIT_COMPLETE);
+                        LOG_RECVOP_LISTENER("Driver already initialized! report back...");
+                        cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_OK);
+                        break;
+
+                    case HW_MBOX_CODE_PING:
+                        LOG_RECVOP_LISTENER("Handling PING code %u", HW_MBOX_CODE_PING);
+                        cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_OK);    /* ACK ping */
+                        break;
+
+                    default:
+                        LOG_RECVOP_LISTENER("invalid code %u for tag %u", opFlds.code, opFlds.tag);
+                        cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_INVALID_CODE);
+                }
+            }
+
+            goto SEND_OP_REPLY;
+        }
+
+        if (!IS_INITIALIZED())
+        {
+            /* if we are here driver is not initialized yet and it's a non Kernel HW MBOX tag... */
+            LOG_RECVOP_LISTENER("driver NOT initialized! can't handle tag %u yet...", opFlds.tag);
+            cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_NOT_INITIALIZED_YET);
+            goto SEND_OP_REPLY;
+        }
+
+        if (opFlds.tag == HW_MBOX_OPCODE_USER_SPACE_TAG)
+        {
+            /* it's an opcode for HW MBOX in User-Space! signal APP Queue */
+            LOG_RECVOP_LISTENER("HW MBOX User-Space opcode! signaling APP queue...");
+
+            RECV_OP_APP_SET_STATE(threadData->cid, CHN_INTR_STATE_PENDING);
+            wake_up_interruptible(&RECV_OP_APP_WQ(threadData->cid));
+
+            continue;
+        }
+
+        /* start checking the registered callbacks... */
+        LOG_RECVOP_LISTENER("start checking the registered callbacks...");
+        recvOpCb = NULL;
+
+        /* seize channel lock */
+        if (down_interruptible(&CHN_LOCK(threadData->cid)))
+        {
+            LOG_RECVOP_LISTENER("down interrupted by signal...");
+            continue;
+        }
+
+        for (i = 0; i < RECV_OP_GET_TAG_COUNT(threadData->cid); i++)
+        {
+            if (RECV_OP_GET_TAG(threadData->cid, i) == opFlds.tag)
+            {
+                /* found the correct tag! */
+                recvOpCb = RECV_OP_GET_CB(threadData->cid, i);
+                LOG_RECVOP_LISTENER("found tag %u in DB [index %d], invoking callback %p, token %u=0x%08x",
+                                    opFlds.tag, i, recvOpCb,
+                                    RECV_OP_GET_TOKEN(threadData->cid, i),
+                                    RECV_OP_GET_TOKEN(threadData->cid, i));
+
+                RECV_OP_INC_OPCODE_CNT(threadData->cid, i);
+                break;
+            }
+        }
+
+        if (recvOpCb == NULL)
+        {
+            /* no registered kernel tag found...
+               This means that if it's a valid tag it's for User-Space! */
+            LOG_RECVOP_LISTENER("tag %u is not for kernel! send to User-Space...", opFlds.tag);
+
+            RECV_OP_APP_SET_STATE(threadData->cid, CHN_INTR_STATE_PENDING);
+            wake_up_interruptible(&RECV_OP_APP_WQ(threadData->cid));
+
+            /* release Lock... */
+            up(&CHN_LOCK(threadData->cid));
+            continue;
+        }
+
+        paramToken = RECV_OP_GET_TOKEN(threadData->cid, i);
+
+        cbRc = recvOpCb(CHN_CFG_GET_COMMANDER(threadData->cid),
+                        opFlds.code,
+                        HW_MBOX_POINTER_TO_SRAM(CHN_CFG_MEMBUFF_GET_START(threadData->cid)),
+                        opFlds.lenInBytes,
+                        &paramToken);
+
+        LOG_RECVOP_LISTENER("callback retuned with %d, paramToken after callback %u=0x%08x, channel state is %d.",
+                            cbRc, paramToken, paramToken, HW_MBOX_CHN_STATE_REG_GET(threadData->cid));
+
+        if (cbRc == -1)
+        {
+            /* reserved return value indicating the the Callback failed!
+               Token should hold a generic HW MBOX return code <hwMbox_opcodeReturnCode_e> 
+               that will indicate of the error cause [i.e. INVALID_CODE]. */
+
+            LOG_RECVOP_LISTENER("callback failed, sending back error 0x%08x (%u)",
+                                paramToken, paramToken);
+
+            cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, paramToken);
+
+            /* release Lock... */
+            up(&CHN_LOCK(threadData->cid));
+            goto SEND_OP_REPLY;
+        }
+        else
+        {
+            RECV_OP_SET_TOKEN(threadData->cid, i, paramToken); /* update in DB the possibly modified Token */
+        }
+
+        /* Opcode successfully received, INC count! */
+        STATS_INC_COUNTER(CHN_CFG_GET_COMMANDER(threadData->cid), hw_mbox_opcode, True);
+
+        /* release Lock... */
+        up(&CHN_LOCK(threadData->cid));
+        continue;
+
+SEND_OP_REPLY:
+        /* Opcode successfully received, INC count! */
+        STATS_INC_COUNTER(CHN_CFG_GET_COMMANDER(threadData->cid), hw_mbox_opcode, True);
+
+        LOG_RECVOP_LISTENER("send reply to subject!");
+
+        /* uses cmdRegVal current value: */
+        LOG_RECVOP_LISTENER("before write to command register - state=%d", HW_MBOX_CHN_STATE_REG_GET(threadData->cid));
+        LOG_RECVOP_LISTENER("writing 0x%08x to the command register of the channel...", cmdRegVal);
+        HW_MBOX_CHN_COMMAND_REG_SET(threadData->cid, cmdRegVal); /* send Command... */
+        LOG_RECVOP_LISTENER("before write to command register - state=%d", HW_MBOX_CHN_STATE_REG_GET(threadData->cid));
+    }
+
+    return 0;
+#undef LOG_RECVOP_LISTENER
+}
+
+/*** Channel interrupt Devices Functions Definitions: ***/
+
+/* File Operations: */
+
+static int chnint_open(struct inode *inode, struct file *filp)
+{
+    chnint_t *dev;
+    dev = container_of(inode->i_cdev, chnint_t, chnint_cdev);
+    DEV_PRINTK("chnint_open dev %p, chn_cid %d", dev, dev->chn_cid);
+    DEV_PRINTK("filp=%p", filp);
+
+    if ((filp->f_flags & O_NONBLOCK) && (!IS_INITIALIZED()))
+    {
+        /* support non blocking open operation... */
+        return -EAGAIN;
+    }
+    else
+    {
+        /* otherwise block and wait for driver initialization! */
+        if( wait_event_interruptible(waitForInitializedWq, IS_INITIALIZED()) )
+        {
+            /* following return code used internally by VFS (virtual filesystem) layer.
+               it will either restart the system call or return -EINTR to User-Space. 
+               (to indicate that it was interrupted by signal...) */
+
+            return -ERESTARTSYS;
         }
     }
 
+    filp->private_data = dev;   /* store for future use */
     return 0;
 }
 
-/*! \fn static int proc_dump_channels_regs_show(struct seq_file *m, void *v)
-    \brief dump HW_MBOX Channels Registers. */
-static int proc_dump_channels_regs_show(struct seq_file *m, void *v)
+static ssize_t chnint_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
 {
-    seq_proc_if_control_data_t *controlData = m->private;
-    loff_t *spos = v;
-    Uint32 i = (Uint32)(*spos);
-    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
-    if (i < HW_MBOX_CHANNEL_COUNT)
+    chnIntrReturnCodes_e chnIntrRc;
+    Bool replyToUserBuffer; /* initial preparation for full channel devices */
+
+    chnint_t *dev = filp->private_data; /* dev was stored in filp during open */
+
+    DEV_PRINTK("chnint_read dev %p, chn_cid %d, interruptPending=%d", dev, dev->chn_cid, CHN_INTR_GET_STATE(dev->chn_cid));
+    DEV_PRINTK("filp=%p, count=%u, *f_pos=%lld", filp, count, (long long)*f_pos);
+
+    if ((chnIntrRc = hwMbox_waitForChannelInterrupt(dev->chn_cid, CHN_INTR_NO_TIMEOUT)) != CHN_INTR_RC_OK)
     {
-        if (0 == i)
+        /* error, currently can only be interrupted by signal... */
+        if (chnIntrRc == CHN_INTR_RC_INTERRUPTED_BY_SIGNAL)
         {
-            /* We are in the first run, print line and headers */
-            seq_printf(m, "+------+-------------+-------------+-------------+-------------+\n");
-            seq_printf(m, "| CHN# |   CHN_CFG   |  CHN_STATE  | CHN_COMMAND |   MEM_MAP   |\n");
-            /* Value fmt: "|  ##  |  0x00000000 |  0x00000000 |  0x00000000 |  0x00000000 |" */
+            /* following return code used internally by VFS (virtual filesystem) layer.
+               it will either restart the system call or return -EINTR to User-Space. 
+               (to indicate that it was interrupted by signal...) */
+
+            return -ERESTARTSYS;
         }
+    }
 
-        seq_printf(m, "|  %2d  |  0x%08x |  0x%08x |  0x%08x |  0x%08x |\n", i, 
-                   HW_MBOX_CHN_CFG_REG_GET(i), HW_MBOX_CHN_STATE_REG_GET(i),
-                   HW_MBOX_CHN_COMMAND_REG_GET(i), HW_MBOX_MEMORY_MAP_REG_GET(i));
+    replyToUserBuffer = True;
 
-        if ((HW_MBOX_CHANNEL_COUNT - 1) == i)
-        {
-            /* End of table print trailing line */
-            seq_printf(m, "+------+-------------+-------------+-------------+-------------+\n");
-            controlData->endOfData = True;
-        }
+    if (copy_to_user(buf, &replyToUserBuffer, sizeof(replyToUserBuffer)))
+    {
+        return -EFAULT;
     }
 
-    return 0;
+    *f_pos += sizeof(replyToUserBuffer);
+    return sizeof(replyToUserBuffer);
 }
 
-/*! \fn static int proc_dump_interrupts_show(struct seq_file *m, void *v)
-    \brief dump HW_MBOX Interrupts Data. */
-static int proc_dump_interrupts_show(struct seq_file *m, void *v)
+static unsigned int chnint_poll(struct file *filp, struct poll_table_struct *wait)
 {
-    seq_proc_if_control_data_t *controlData = m->private;
-    loff_t *spos = v;
-    Uint32 i = (Uint32)(*spos);
-    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
-    if (i < HW_MBOX_CHANNEL_COUNT)
+    chnint_t *dev = filp->private_data; /* dev was stored in filp during open */
+    unsigned int mask = 0;
+
+    wait_queue_head_t *pWq; /* pointer to the wait queue we should wait on */
+    chnIntrState_e *pState; /* pointer to the channel interrupt state we should query */
+
+    if (CHN_IS_RECV_OP(dev->chn_cid))
     {
-        if (0 == i)
-        {
-            /* We are in the first run, print line and headers */
-            seq_printf(m, " CID         INTR\n");
-        }
-        seq_printf(m, " %2d:   %10u\n", i, GET_CHN_INTR(i));
+        /* Receive Opcode channel should wait on application queue */
+        pWq = &RECV_OP_APP_WQ(dev->chn_cid);
+        pState = &RECV_OP_APP_GET_STATE(dev->chn_cid);
+        DEV_PRINTK("cid %d: using application queue...", dev->chn_cid);
+    }
+    else
+    {
+        /* all other cases, wait on channel interrupt */
+        pWq = &CHN_INTR_WQ(dev->chn_cid);
+        pState = &CHN_INTR_GET_STATE(dev->chn_cid);
+        DEV_PRINTK("cid %d: using channel queue...", dev->chn_cid);
+    }
 
-        if (i == HW_MBOX_CHANNEL_COUNT - 1) /* Last Line */
-        {
-            seq_printf(m, "err:   %10u\n", GET_ERR_INTR());
-            seq_printf(m, "ghost: %10u\n", GET_GHOST_INTR());
-            controlData->endOfData = True;
-        }
+    DEV_PRINTK("chnint_poll dev %p, chn_cid %d: poll check intrState=%d", dev, dev->chn_cid, *pState);
+    DEV_PRINTK("filp=%p", filp);
+
+    poll_wait(filp, pWq, wait);
+    if (*pState != CHN_INTR_STATE_NONE)
+    {
+        DEV_PRINTK("chnint_poll dev %p, chn_cid %d waked up", dev, dev->chn_cid);
+        mask |= POLLIN | POLLRDNORM; /* readable */
     }
+    DEV_PRINTK("chnint_poll dev %p, chn_cid %d: mask=0x%08x", dev, dev->chn_cid, mask);
+    return mask;
+}
+
+static int chnint_release(struct inode *inode, struct file *filp)
+{
+#ifdef HW_MBOX_KDBG
+    chnint_t *dev;
+    dev = container_of(inode->i_cdev, chnint_t, chnint_cdev);
 
+    DEV_PRINTK("chnint_release: dev %p, chn_cid %d", dev, dev->chn_cid);
+#endif /* HW_MBOX_KDBG */
     return 0;
 }
 
+/*! \fn static void chnint_cleanup(int count) 
+    \brief use to clean up the Channel Interrupt devices.
+    \param[in] count - amount of devices to clean up. 
+    \note also clears the chrdev region. 
+*/
+static void chnint_cleanup(int count)
+{
+    int i;
+    DPRINTK("cleanup function, count=%d", count);
+    if (chnint_devices)
+    {
+        for (i = 0; i < count; i++)
+        {
+            cdev_del(&chnint_devices[i].chnint_cdev);
+        }
+        kfree(chnint_devices);
+    }
+    unregister_chrdev_region(chnint_dev, HW_MBOX_CHANNEL_COUNT);
+}
+
 /************************************************************************/
 /*     HW_MBOX driver functions                                         */
 /************************************************************************/
@@ -782,13 +3215,22 @@ static irqreturn_t hw_mbox_drv_isr(int i
     Uint32 highIntrStatusReg; /* Interrupts from Channels 63-32 [for supervisor 63 is error notify] */
     Uint32 lowIntrStatusReg;  /* Interrupts from Channels 31-0 */
 
+#ifdef APP_CPU_HW_MBOX_IRQ_SAMPLE_CLK_WA
+    Uint32 highIntrStatusRegBuffer; /* Buffer for Interrupts from Channels 63-32 [for supervisor 63 is error notify] */
+    Uint32 lowIntrStatusRegBuffer;  /* Buffer for Interrupts from Channels 31-0 */
+#endif /* APP_CPU_HW_MBOX_IRQ_SAMPLE_CLK_WA */
+
     Uint32 highIntrMaskReg; /* Interrupt Enable Mask for Channels 63-32 [for supervisor 63 is error notify, mask will be ignored] */
     Uint32 lowIntrMaskReg;  /* Interrupt Enable Mask for Channels 31-0 */
 
-    chnint_t *dev;
-    Uint32 highCidRange, regVal, chnint_cid;
+    Uint32 highCidRange, regVal, cfgRegVal, chnint_cid;
     Bool errorBitWasOn = False;
 
+#ifdef APP_CPU_HW_MBOX_IRQ_SAMPLE_CLK_WA
+    highIntrStatusRegBuffer = 0;
+    lowIntrStatusRegBuffer = 0;
+#endif /* APP_CPU_HW_MBOX_IRQ_SAMPLE_CLK_WA */
+
     DPRINTK("isr!");
     /* We got an interrupt! */
 
@@ -796,12 +3238,15 @@ static irqreturn_t hw_mbox_drv_isr(int i
        HW_MBOX_MASTER_INTR_STATUS_L. All interrupts must be handled as the bits are
        reset upon read! [except masked ones...] */
 
+#ifdef APP_CPU_HW_MBOX_IRQ_SAMPLE_CLK_WA
+READ_INTERRUPT_STATUS_REGS:
+#endif
     highIntrStatusReg = HW_MBOX_MASTER_INTR_STATUS_H_REG_GET();
     lowIntrStatusReg = HW_MBOX_MASTER_INTR_STATUS_L_REG_GET();
 
-    DPRINTK("intrStatus(H L): 0x%08x 0x%08x", highIntrStatusReg, lowIntrStatusReg);
+    DPRINTK("intrStatusRegs(H L): 0x%08x 0x%08x", highIntrStatusReg, lowIntrStatusReg);
 
-    DPRINTK("interrupt bits should now be cleard [all unmasked ones]...");
+    DPRINTK("channel interrupt bits should now be cleared [all unmasked ones]...");
     DPRINTK("verifying using shadowRegs(H L): 0x%08x 0x%08x", HW_MBOX_MASTER_INTR_CLEAR_H_REG_GET(),
                                                               HW_MBOX_MASTER_INTR_CLEAR_L_REG_GET());
 
@@ -811,10 +3256,10 @@ static irqreturn_t hw_mbox_drv_isr(int i
         DPRINTK("Hardware signals of Access Violation Error!");
         INC_ERR_INTR();
 
-        DPRINTK("interrupt on channel %d, waking up dev...", HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
-        dev = &chnint_devices[HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR];
-        dev->interruptPending = CHN_INT_PENDING;
-        wake_up_interruptible(&dev->chnint_rqueue);
+        DPRINTK("interrupt on channel %d, signaling queue...", HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
+
+        CHN_INTR_SET_STATE(HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR, CHN_INTR_STATE_PENDING);
+        wake_up_interruptible(&CHN_INTR_WQ(HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR));
 
         highIntrStatusReg &= (~HW_MBOX_ERROR_BIT_FOR_SUPERVISOR); /* Clear the error interrupt from the register value buffer */
         errorBitWasOn = True; /* need to remember that error bit was on as we turn it off here */
@@ -824,11 +3269,28 @@ static irqreturn_t hw_mbox_drv_isr(int i
 
     highIntrMaskReg = HW_MBOX_MASTER_INTR_MASK_H_REG_GET();
     lowIntrMaskReg  = HW_MBOX_MASTER_INTR_MASK_L_REG_GET();
-    DPRINTK("intrMask(H L): 0x%08x 0x%08x", highIntrMaskReg, lowIntrMaskReg);
+    DPRINTK("intrMaskRegs(H L): 0x%08x 0x%08x", highIntrMaskReg, lowIntrMaskReg);
 
     highIntrStatusReg &= (~highIntrMaskReg);
     lowIntrStatusReg  &= (~lowIntrMaskReg);
-    DPRINTK("intrStatus(H L) [after removed masked CIDs]: 0x%08x 0x%08x", highIntrStatusReg, lowIntrStatusReg);
+    DPRINTK("intrStatusRegs(H L) [after removed masked CIDs]: 0x%08x 0x%08x", highIntrStatusReg, lowIntrStatusReg);
+
+#ifdef APP_CPU_HW_MBOX_IRQ_SAMPLE_CLK_WA
+    /* save the current values to the buffers, read again, see if we get new bits... */
+    if ((0 != highIntrStatusReg) || (0 != lowIntrStatusReg))
+    {
+        highIntrStatusRegBuffer |= highIntrStatusReg;
+        lowIntrStatusRegBuffer |= lowIntrStatusReg;
+        DPRINTK("APP-CPU: read again interrupt status regs values...");
+        goto READ_INTERRUPT_STATUS_REGS;
+    }
+
+    /* no more new bits, save back to values from the buffers the regular variables */
+    DPRINTK("APP-CPU: no more new bits, continuing...");
+    highIntrStatusReg = highIntrStatusRegBuffer;
+    lowIntrStatusReg = lowIntrStatusRegBuffer;
+    DPRINTK("APP-CPU: intrStatusRegs(H L) [final values]: 0x%08x 0x%08x", highIntrStatusReg, lowIntrStatusReg);
+#endif /* APP_CPU_HW_MBOX_IRQ_SAMPLE_CLK_WA */
 
     if ((0 == highIntrStatusReg) && (0 == lowIntrStatusReg))
     {
@@ -862,12 +3324,60 @@ static irqreturn_t hw_mbox_drv_isr(int i
                 DPRINTK("position of LSB that is set on regVal=0x%08x is %d", regVal, chnint_cid);
                 regVal &= (~BIT(chnint_cid));       /* turn off bit, we got it... */
                 chnint_cid += (32 * highCidRange);  /* adjusting to range */
-                INC_CHN_INTR(chnint_cid);
-                DPRINTK("interrupt on channel %d, waking up dev...", chnint_cid);
-                dev = &chnint_devices[chnint_cid];
-                dev->interruptPending = CHN_INT_PENDING;
-                wake_up_interruptible(&dev->chnint_rqueue);
-                DPRINTK("new regVal=0x%08x (after handling one interrupt)", regVal);
+                CHN_INTR_INC_COUNT(chnint_cid);
+
+                if ( !IS_INITIALIZED() && !IS_SUPERVISOR() )
+                {
+                    /* non-supervisor getting a HW MBOX interrupt at Initialization stage.
+                       It should look if this channel is a Receive Opcode channel from the
+                       supervisor. */
+
+                    DPRINTK("non-supervisor and HW MBOX not initialized yet...");
+
+                    cfgRegVal = HW_MBOX_CHN_CFG_REG_GET(chnint_cid);
+
+                    if ( (HW_MBOX_CHN_CFG_COMMANDER_GET_FROM_REGVAL(cfgRegVal) == CTRL_GET_SUPERVISOR()) &&
+                         (HW_MBOX_CHN_CFG_TYPE_GET_FROM_REGVAL(cfgRegVal) == hw_mbox_opcode) )
+                    {
+                        DPRINTK("cid %d is the receive opcode channel used for initial configuration! signal INIT_COMPLETE WQ...",
+                                chnint_cid);
+
+                        /* Signal the first listener!
+                           just signal the listener, it'll do the rest...*/
+
+                        RECV_OP_THREAD_SET_CID(RECV_OPCODE_INIT_INDEX, chnint_cid);
+                        RECV_OP_THREAD_SET_INDEX(RECV_OPCODE_INIT_INDEX);
+
+                        SET_INIT_COMPLETE();
+                    }
+
+                    /* continue normal flow, either way we should signal the channel queue...
+                       To release the first listener to continue init, or to save the channel interrupt for later use...
+                    */
+                }
+
+                if (CHN_IS_INIT(chnint_cid))
+                {
+                    /* Special flag on channel that indicates that it's part of
+                       HW MBOX intialization process. This is always an Opcode channel
+                       with supervisor as commander and another master as subject.
+                     
+                       First message on this channel acts as ACK from subject that it is
+                       initialized.
+                    */
+                    DPRINTK("interrupt on INIT channel %d from Master %d",
+                            chnint_cid, CHN_CFG_GET_SUBJECT(chnint_cid));
+
+                    MASTER_SET_INITIALIZED(CHN_CFG_GET_SUBJECT(chnint_cid), True);
+                    CHN_SET_INIT(chnint_cid, False); /* This channel is no longer used for INIT... */
+                }
+                else
+                {
+                    DPRINTK("interrupt on channel %d, signaling queue...", chnint_cid);
+                    CHN_INTR_SET_STATE(chnint_cid, CHN_INTR_STATE_PENDING);
+                    wake_up_interruptible(&CHN_INTR_WQ(chnint_cid));
+                }
+                DPRINTK("new regVal=0x%08x (after handling one channel interrupt)", regVal);
             }
         }
     }
@@ -884,7 +3394,9 @@ static irqreturn_t hw_mbox_drv_isr(int i
        interrupts by using ack_irq but we will save the unnecessary ISR just to clear the bit
        in the interrupt controller.
     */
-    //ack_irq(irq);
+#ifdef HW_MBOX_IS_NP_CPU
+    ack_irq(irq);
+#endif
     return IRQ_HANDLED;
 }
 
@@ -912,11 +3424,11 @@ int hw_mailbox_register_with_netss(void)
 	
    /* Initialize critical structures */
    for (i = 0; i< HW_MBOX_CHANNEL_COUNT; i++) {
-      mutex_init(&hwMboxDriverData.chnLock[i]);
+      //mutex_init(&hwMboxDriverData.chnLock[i]);
    }
 
    hwMboxDriverData.reg_base = (void __iomem *)ioremap_nocache(hwmailbox_mmio.base,hwmailbox_mmio.size);
-   if (hwMboxDriverData.reg_base) {
+   if (!hwMboxDriverData.reg_base) {
       printk(KERN_ERR "error, failed to ioremap hw mailbox registers\n");
       ret = -ENOMEM;
       return ret;
@@ -928,13 +3440,11 @@ int hw_mailbox_register_with_netss(void)
 
 static int __init hw_mbox_drv_init_module (void)
 {
-    //int r, devno;
-    int i, paramMID, paramCID;
+    int i, r, devno, paramMID, paramCID;
     hw_mbox_masterConfig_t masterConfig;
     hw_mbox_channelConfig_t chnConfig;
-
-    /* Initialize the Driver Local Data: */
-    RESET_DRIVER_DATA();
+    Int32 retVal;
+    Uint32 cmdRegVal, regVal;
 
     DPRINTK("init!");
     PRINTK_INFO("%s version %s built on %s @ %s", DRV_NAME, DRV_VERSION, __DATE__, __TIME__);
@@ -945,13 +3455,14 @@ static int __init hw_mbox_drv_init_modul
     PRINTK_INFO("Master Disguise Feature: Setting initial MID to the Hardcoded one");  
     __HW_MBOX_DEBUG_SET_MID(HW_MBOX_HARDCODED_MID);
 #endif
-    if( 0 >= hw_mailbox_register_with_netss()) 
+    /* Initialize the Driver Local Data: */
+    RESET_DRIVER_DATA();
+    if( 0 > hw_mailbox_register_with_netss()) 
     {
        PRINTK_INFO("%s version %s built on %s @ %s CANNOT BE INITALIZED", DRV_NAME, DRV_VERSION, __DATE__, __TIME__);
        return -ENODEV;
     }
 
-#if defined HW_MBOX_IS_NP_CPU 
     /* Create Channel interrupt Devices: */
     if ((r = alloc_chrdev_region(&chnint_dev, 0, HW_MBOX_CHANNEL_COUNT, HW_MBOX_CHNINT_DEV_NAME)) != 0)
     {
@@ -970,15 +3481,22 @@ static int __init hw_mbox_drv_init_modul
     }
 
     DPRINTK("Successfully allocated %d devices!", HW_MBOX_CHANNEL_COUNT);
-    memset(chnint_devices, 0, HW_MBOX_CHANNEL_COUNT * sizeof(chnint_t));
+
+    RESET_CHN_DEVS();
+    RESET_CHN_INTR_DATA();
+    RESET_CHN_LOCKS();
 
     for (i = 0; i < HW_MBOX_CHANNEL_COUNT; i++)
     {
-        chnint_devices[i].chn_cid = i;
+        /* Initialize the channel's infrastructure [channel interrupt and lock]: */
+        /* note: this should be done prior to ISR request to ensure that there's a channel interrupt to catch the signal. */
+        init_waitqueue_head(&CHN_INTR_WQ(i));
+        CHN_INTR_SET_STATE(i, CHN_INTR_STATE_NONE);
+        sema_init(&CHN_LOCK(i), 1);
+        DPRINTK("initialized infrastructure for cid %d [WQ %p, LOCK %p]", i, &CHN_INTR_WQ(i), &CHN_LOCK(i));
 
-        /* Create a wait queue that applications will sleep on until interrupt */
-        init_waitqueue_head(&chnint_devices[i].chnint_rqueue);
-        chnint_devices[i].interruptPending = CHN_INT_NONE;
+        /* Initialize the channel device: */
+        chnint_devices[i].chn_cid = i;
 
         /* Connect the file operations with the cdev */
         cdev_init(&chnint_devices[i].chnint_cdev, &chnint_fops);
@@ -1012,20 +3530,34 @@ static int __init hw_mbox_drv_init_modul
         SEQ_PROC_CREATE("core_version", proc_dump_core_version, procDir);
         SEQ_PROC_CREATE("control_regs", proc_dump_control_regs, procDir);
         SEQ_PROC_CREATE("status", proc_dump_status, procDir);
-        
+        SEQ_PROC_CREATE("ctrlDb", proc_dump_ctrlDb, procDir);
+
         /* SEQ Procs: */
         SEQ_PROC_CREATE("masters_regs", proc_dump_masters_regs, procDir);
         SEQ_PROC_CREATE("channels_regs", proc_dump_channels_regs, procDir);
+        SEQ_PROC_CREATE("assignedChannels_regs", proc_dump_assignedChannels_regs, procDir);
         SEQ_PROC_CREATE("interrupts", proc_dump_interrupts, procDir);
+        SEQ_PROC_CREATE("LUT", proc_dump_LUT, procDir);
+        SEQ_PROC_CREATE("counters", proc_dump_serviceCounter, procDir);
+        SEQ_PROC_CREATE("masterDb", proc_dump_masterDb, procDir);
+        SEQ_PROC_CREATE("chnDb", proc_dump_chnDb, procDir);
+        SEQ_PROC_CREATE("recvOpDb", proc_dump_recvOpDb, procDir);
+        SEQ_PROC_CREATE("tagsDb", proc_dump_recvOpTagsDb, procDir);
     }
     PRINTK_INFO("Created proc directory: /proc/%s", HW_MBOX_PROC_DIR_STR);
-#endif
+
+
+    /* and other local variables: */
+    RESET_CID_LUT();
+    RESET_RECV_OP_THREAD_DATA();
+    RESET_RECV_OP_DATA();
+    RESET_STATS();
 
     /* Get core version from HW_MBOX_ID register: */
-    SET_CORE_VER_MAJ(HW_MBOX_ID_MAJOR_GET());
-    SET_CORE_VER_MIN(HW_MBOX_ID_MINOR_GET());
+    CTRL_SET_CORE_VER_MAJ(HW_MBOX_ID_MAJOR_GET());
+    CTRL_SET_CORE_VER_MIN(HW_MBOX_ID_MINOR_GET());
 
-    DPRINTK("HW_MBOX core version: %d.%d", GET_CORE_VER_MAJ(), GET_CORE_VER_MIN());
+    DPRINTK("HW_MBOX core version: %d.%d", CTRL_GET_CORE_VER_MAJ(), CTRL_GET_CORE_VER_MIN());
 
 #ifdef __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO
     /* Check if we need to change default supervisor: */
@@ -1038,194 +3570,247 @@ static int __init hw_mbox_drv_init_modul
 
         HW_MBOX_CTRL_AS_DEFAULT_SUPERVISOR_SUPERVISOR_SET(__HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO);
     }
-#endif
+#endif /* __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO */
 
-    /* Check if this Master is the supervisor: */
-    if (HW_MBOX_IS_SUPERVISOR())
-    {
-        DPRINTK("Current Master is the supervisor: %s(%d)", HW_MBOX_MASTER_GET_NAME(HW_MBOX_MID), HW_MBOX_MID);
-        SET_IS_SUPERVISOR();
-    }
-    else
+    /* Set Supervisor Value in DB: */
+    CTRL_SET_SUPERVISOR(HW_MBOX_CTRL_SUPERVISOR_GET());
+    DPRINTK("supervisor is: %s(%d)", HW_MBOX_MASTER_GET_NAME(CTRL_GET_SUPERVISOR()),
+                                     CTRL_GET_SUPERVISOR());
+
+    /* Check which Masters are Valid: */
+    for (paramMID = 0; paramMID < HW_MBOX_MASTER_COUNT; paramMID++)
     {
-        DPRINTK("supervisor is: %s(%d)", HW_MBOX_MASTER_GET_NAME(HW_MBOX_CTRL_SUPERVISOR_GET()),
-                                         HW_MBOX_CTRL_SUPERVISOR_GET());
+        memcpy(&MASTER_CFG(paramMID), &HW_MBOX_MASTER_GET_CONFIG(paramMID), HW_MBOX_MASTER_CONFIG_SIZE);
+
+        /* TBD: add check for fused out Masters */
+
+        if (MASTER_CFG_GET_SUPPORT(paramMID) != hw_mbox_support_none)
+        {
+            MASTER_SET_VALID(paramMID, True);
+        }
     }
 
-#ifdef HW_MBOX_MONITOR
-    if (HW_MBOX_MONITOR == HW_MBOX_MID)
+    if (HW_MBOX_IS_STARTED())
     {
-        /* This Master is the Monitor, Update Driver Data... */
-        SET_IS_MONITOR();
+        /* HW_MBOX is already configured and started
+           (supervisor warm reset or non-supervisor starting after supervisor finished configuring)... */
+        PRINTK_INFO("HW_MBOX is already configured and started -> dynamically learn set configuration from HW...");
+        CTRL_SET_IS_STARTED(True);
+        hwMbox_initAfterStarted();
     }
-#endif
-
-    if (IS_SUPERVISOR())
+    else
     {
-        if (HW_MBOX_IS_STARTED())
+        if (IS_SUPERVISOR())
         {
-            /* HW_MBOX is already configured and started (probably warm reset)... */
-            PRINTK_INFO("HW_MBOX is already configured and started -> skip configuration...");
-            goto SKIP_CONFIGURATION;
-        }
+            DPRINTK("Current Master is the supervisor!");
+            DPRINTK("Setting up general control configuration values...");
 
-        DPRINTK("Setting up general control configuration values...");
 #ifdef HW_MBOX_MONITOR
-        DPRINTK("Setting Monitor = %s(%d)", HW_MBOX_MASTER_GET_NAME(HW_MBOX_MONITOR), HW_MBOX_MONITOR);
+            DPRINTK("Setting Monitor = %s(%d)", HW_MBOX_MASTER_GET_NAME(HW_MBOX_MONITOR), HW_MBOX_MONITOR);
 
-        /* Setup HW_MBOX Configuration registers: */
-        HW_MBOX_CTRL_MON_EXIST_SET(True);
-        HW_MBOX_CTRL_MONITOR_SET(HW_MBOX_MONITOR);
-#else
-        /* Setup HW_MBOX Configuration registers: */
-        HW_MBOX_CTRL_MON_EXIST_SET(False); /* Default should be False, but it doesn't hurt to make sure */
-#endif // HW_MBOX_MONITOR
-#ifdef HW_MBOX_START_IN_HW_DEBUG_MODE
-        DPRINTK("Setting HW Debug Mode...");
+            /* Setup HW_MBOX Configuration registers: */
+            HW_MBOX_CTRL_MON_EXIST_SET(True);
+            HW_MBOX_CTRL_MONITOR_SET(HW_MBOX_MONITOR);
 
-        /* Setup HW_MBOX Configuration registers: */
-        HW_MBOX_CTRL_DEBUG_SET(True);
+            /* Set Monitor Value in DB: */
+            CTRL_SET_MONITOR(HW_MBOX_MONITOR);
 #else
-        HW_MBOX_CTRL_DEBUG_SET(False); /* Default should be False, but it doesn't hurt to make sure */
-#endif // HW_MBOX_START_IN_HW_DEBUG_MODE
+            /* Setup HW_MBOX Configuration registers: */
+            HW_MBOX_CTRL_MON_EXIST_SET(False); /* Default should be False, but it doesn't hurt to make sure */
 
-        /* Check which Masters are Valid: */
-        for (paramMID = 0; paramMID < HW_MBOX_MASTER_COUNT; paramMID++)
-        {
-            memcpy(&masterConfig, &HW_MBOX_MASTER_GET_CONFIG(paramMID), HW_MBOX_MASTER_CONFIG_SIZE);
+            /* Set Monitor Value in DB: */
+            CTRL_SET_MONITOR(HW_MBOX_MID_INVALID);
+#endif /* HW_MBOX_MONITOR */
+
+#ifdef HW_MBOX_START_IN_HW_DEBUG_MODE
+            DPRINTK("Setting HW Debug Mode...");
 
-            /* TBD: add check for fused out Masters */
+            /* Setup HW_MBOX Configuration registers: */
+            HW_MBOX_CTRL_DEBUG_SET(True);
+            CTRL_SET_IS_HW_DEBUG_MODE(True);
+#else
+            HW_MBOX_CTRL_DEBUG_SET(False); /* Default should be False, but it doesn't hurt to make sure */
+            CTRL_SET_IS_HW_DEBUG_MODE(False);
+#endif /* HW_MBOX_START_IN_HW_DEBUG_MODE */
 
-            if (masterConfig.support != hw_mbox_support_none)
+            /* Check which Masters are Valid: */
+            for (paramMID = 0; paramMID < HW_MBOX_MASTER_COUNT; paramMID++)
             {
-                SET_MASTER_VALID(paramMID, True);
+                memcpy(&masterConfig, &HW_MBOX_MASTER_GET_CONFIG(paramMID), HW_MBOX_MASTER_CONFIG_SIZE);
+
+                /* TBD: add check for fused out Masters */
+                if (masterConfig.support != hw_mbox_support_none)
+                {
+                    MASTER_SET_VALID(paramMID, True);
+                }
             }
-        }
-        
-        /* INIT static channels: */
-        DPRINTK("Initializing %d static channels", HW_MBOX_STATIC_CHANNEL_COUNT);
-        for (i = 0; i < HW_MBOX_STATIC_CHANNEL_COUNT; i++)
-        {
-            memcpy(&chnConfig, &HW_MBOX_STATIC_CHANNEL_GET_CONFIG(i), HW_MBOX_CHANNEL_CONFIG_SIZE);
-            paramCID = chnConfig.cid;
+            
+            /* INIT static channels: */
+            DPRINTK("Initializing %d static channels", HW_MBOX_STATIC_CHANNEL_COUNT);
+            for (i = 0; i < HW_MBOX_STATIC_CHANNEL_COUNT; i++)
+            {
+                memcpy(&chnConfig, &HW_MBOX_STATIC_CHANNEL_GET_CONFIG(i), HW_MBOX_CHANNEL_CONFIG_SIZE);
+                paramCID = chnConfig.cid;
 
-            DPRINTK("static channel entry %d (cid=%d): mboxType=%d, commander=%d, subject=%d, memSize=%uB",
-                    i, paramCID, chnConfig.mboxType, chnConfig.commander, chnConfig.subject, chnConfig.memBuff.size);
+                DPRINTK("static channel entry %d (cid=%d): mboxType=%d, commander=%d, subject=%d, memSize=%uB",
+                        i, paramCID, chnConfig.mboxType, chnConfig.commander, chnConfig.subject, chnConfig.memBuff.size);
 
-            /* First we should check if the configuration is valid: */
-            DPRINTK("static channel entry %d (cid=%d): verifying configuration...", i, paramCID);
+                /* First we should check if the configuration is valid: */
+                DPRINTK("static channel entry %d (cid=%d): verifying configuration...", i, paramCID);
 
-            /* check that both Masters are Valid */
-            if ((!IS_MASTER_VALID(chnConfig.commander)) ||
-                (!IS_MASTER_VALID(chnConfig.subject)))
-            {
-                PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! One of the Masters is invalid!",
-                            i, paramCID);
-                continue; /* invalid configuration skip this channel */
-            }
+                /* check that both Masters are Valid */
+                if ((!IS_MASTER_VALID(chnConfig.commander)) ||
+                    (!IS_MASTER_VALID(chnConfig.subject)))
+                {
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! One of the Masters is invalid!",
+                                i, paramCID);
 
-            /* check that CID is not yet allocated: */
-            if (HW_MBOX_CHN_CFG_VALID_GET(paramCID))
-            {
-                /* CHN_CFG is valid... This CID has already been assigned! */
-                PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! CID already assigned!",
-                            i, paramCID);
-                continue; /* invalid configuration skip this channel */
-            }
+                    continue; /* invalid configuration skip this channel */
+                }
 
-            if (paramCID == HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR)
-            {
-                /* We can't allocate CID that's used for error notification with supervisor as Commmander/Subject  */
-                if ((chnConfig.commander == HW_MBOX_MID) || (chnConfig.subject == HW_MBOX_MID))
+                /* check that CID is not yet allocated: */
+                if (HW_MBOX_CHN_CFG_VALID_GET(paramCID))
                 {
-                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! Notify Error CID %d can't be allocated with supervisor as Commander/Subject!",
-                                i, paramCID, HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
+                    /* CHN_CFG is valid... This CID has already been assigned! */
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! CID already assigned!",
+                                i, paramCID);
+
                     continue; /* invalid configuration skip this channel */
                 }
+
+                if (paramCID == HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR)
+                {
+                    /* We can't allocate CID that's used for error notification with supervisor as Commmander/Subject  */
+                    if ((chnConfig.commander == HW_MBOX_MID) || (chnConfig.subject == HW_MBOX_MID))
+                    {
+                        PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! Notify Error CID %d can't be allocated with supervisor as Commander/Subject!",
+                                    i, paramCID, HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
+
+                        continue; /* invalid configuration skip this channel */
+                    }
+
 #ifdef HW_MBOX_MONITOR
-                /* If Supervisor is also Monitor we can't allocate CID that's used for error notification at all! */
-                if (IS_MONITOR())
+                    /* If Supervisor is also Monitor we can't allocate CID that's used for error notification at all! */
+                    if (IS_MONITOR())
+                    {
+                        PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! Notify Error CID %d can't be allocated at all if supervisor is also Monitor!",
+                                    i, paramCID, HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
+
+                        continue; /* invalid configuration skip this channel */
+                    }
+#endif /* HW_MBOX_MONITOR */
+                }
+
+                if ((chnConfig.memBuff.size % HW_MBOX_SRAM_CHUNK) != 0)
                 {
-                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! Notify Error CID %d can't be allocated at all if supervisor is also Monitor!",
-                                i, paramCID, HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! sram size must be an integral Multiple of %d (requested Size=%uB)",
+                                i, paramCID, chnConfig.memBuff.size, HW_MBOX_SRAM_CHUNK);
+
                     continue; /* invalid configuration skip this channel */
                 }
-#endif
-            }
 
-            if (chnConfig.memBuff.size % HW_MBOX_SRAM_CHUNK != 0)
-            {
-                PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! sram size must be an integral Multiple of %d (requested Size=%uB)",
-                            i, paramCID, chnConfig.memBuff.size, HW_MBOX_SRAM_CHUNK);
-                continue; /* invalid configuration skip this channel */
-            }
-
-            if (chnConfig.mboxType == hw_mbox_event)
-            {
-                if (chnConfig.memBuff.size == 0)
+                if (chnConfig.mboxType == hw_mbox_event)
                 {
-                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! for event channels sram size must be > 0 [for event Buffer] (requested Size=%uB)",
-                                i, paramCID, chnConfig.memBuff.size);
-                    continue; /* invalid configuration skip this channel */
+                    if (chnConfig.memBuff.size == 0)
+                    {
+                        PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! for event channels sram size must be > 0 [for event Buffer] (requested Size=%uB)",
+                                    i, paramCID, chnConfig.memBuff.size);
+
+                        continue; /* invalid configuration skip this channel */
+                    }
+                    if ((chnConfig.memBuff.size / HW_MBOX_SRAM_CHUNK) % 2 != 0)
+                    {
+                        PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! for event channels sram size must be an evenly divisible amount of %dB chunks (requested Size=%uB)",
+                                    i, paramCID, HW_MBOX_SRAM_CHUNK, chnConfig.memBuff.size);
+
+                        continue; /* invalid configuration skip this channel */
+                    }
                 }
-                if ((chnConfig.memBuff.size / HW_MBOX_SRAM_CHUNK) % 2 != 0)
+
+                if (chnConfig.memBuff.size > GET_FREE_SRAM_LEFT())
                 {
-                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! for event channels sram size must be an evenly divisible amount of %dB chunks (requested Size=%uB)",
-                                i, paramCID, HW_MBOX_SRAM_CHUNK, chnConfig.memBuff.size);
-                    continue; /* invalid configuration skip this channel */
+                    PRINTK_ERR("static channel entry %d (cid=%d): Cannot be configured! Not enough SRAM memory Left (requested Size=%uB, free SRAM left=%uB)!", 
+                               i, paramCID, chnConfig.memBuff.size, GET_FREE_SRAM_LEFT());
+
+                    continue; /* error, not more memory left! skip this channel */
                 }
-            }
 
-            if (chnConfig.memBuff.size > GET_FREE_SRAM_LEFT())
-            {
-                PRINTK_ERR("static channel entry %d (cid=%d): Cannot be configured! Not enough SRAM memory Left (requested Size=%uB, free SRAM left=%uB)!", 
-                           i, paramCID, chnConfig.memBuff.size, GET_FREE_SRAM_LEFT());
-                continue; /* error, not more memory left! skip this channel */
-            }
+                /* If we are here the channel configuration is OK we can proceed in setting up the HW_MBOX channel
+                   registers with its configuration. */
+                HW_MBOX_CHANNEL_CONFIG_SET(paramCID, chnConfig.mboxType, 0 /* reqId is not used yet */, chnConfig.commander, chnConfig.subject);
 
-            /* If we are here the channel configuration is OK we can proceed in setting up the HW_MBOX channel
-               registers with its configuration. */
-            HW_MBOX_CHANNEL_CONFIG_SET(paramCID, chnConfig.mboxType, 0, chnConfig.commander, chnConfig.subject);
+                if (chnConfig.memBuff.size > 0)
+                {
+                    DPRINTK("static channel entry %d (cid=%d): current Nonallocated SRAM Offset=0x%08x, need %uB of SRAM", 
+                            i, paramCID, GET_NEXT_ALLOCATION_SRAM_OFFSET(), chnConfig.memBuff.size);
 
-            if (chnConfig.memBuff.size > 0)
-            {
-                DPRINTK("static channel entry %d (cid=%d): current Nonallocated SRAM Offset=0x%08x, need %uB of SRAM", 
-                        i, paramCID, GET_NEXT_ALLOCATION_SRAM_OFFSET(), chnConfig.memBuff.size);
+                    chnConfig.memBuff.start = GET_NEXT_ALLOCATION_SRAM_OFFSET();
+
+                    ALLOCATE_SRAM(paramCID, chnConfig.memBuff.size);
+
+                    DPRINTK("static channel entry %d (cid=%d): %uB of SRAM allocated, new current Nonallocated SRAM Offset=0x%08x",
+                            i, paramCID, chnConfig.memBuff.size, GET_NEXT_ALLOCATION_SRAM_OFFSET());
 
-                chnConfig.memBuff.start = GET_NEXT_ALLOCATION_SRAM_OFFSET();
+                    /* We would have liked to reset channel's SRAM if we are Commander,
+                       but it is impossible to do so at this point since START is not set...
+                       it will be done later in this function... */
+                }
+
+                HW_MBOX_CHN_CFG_VALID_SET(paramCID, True);
 
-                ALLOCATE_SRAM(paramCID, chnConfig.memBuff.size);
+                hwMbox_setChannelConfig(chnConfig);
+
+                if (!CHN_IS_RECV_OP(paramCID))
+                {
+                    hwMbox_setChannelValid(paramCID, True); /* also updates LUTs */
 
-                DPRINTK("static channel entry %d (cid=%d): %uB of SRAM allocated, new current Nonallocated SRAM Offset=0x%08x",
-                        i, paramCID, chnConfig.memBuff.size, GET_NEXT_ALLOCATION_SRAM_OFFSET());
+                    /* for recv Op channel valid is set by listener... */
+                }
 
-                /* We would have liked to reset channel's SRAM if we are Commander,
-                   to cover the case of Kernel Customers but it is impossible to do
-                   so at this point since START is not set...
-                 
-                   If there are Kernel contexts using a channel, Commander should
-                   first reset channel's SRAM. */
+                DPRINTK("configured new static channel (cid=%d): %s MBOX, %s(%d) -> %s(%d) [%uB of SRAM]",
+                        paramCID, HW_MBOX_TYPE_STR(chnConfig.mboxType),
+                        HW_MBOX_MASTER_GET_NAME(chnConfig.commander), chnConfig.commander,
+                        HW_MBOX_MASTER_GET_NAME(chnConfig.subject), chnConfig.subject,
+                        chnConfig.memBuff.size);
             }
 
-            HW_MBOX_CHN_CFG_VALID_SET(paramCID, True);
+            /* Now that all configuration values and static channels are set we can set start! */
+            PRINTK_INFO("initial configuration completed, setting START!");
+            HW_MBOX_CTRL_START_SET(True);
 
-            DPRINTK("configured new static channel (cid=%d): %s MBOX, %s(%d) -> %s(%d) [%uB of SRAM]",
-                    paramCID, HW_MBOX_TYPE_STR(chnConfig.mboxType),
-                    HW_MBOX_MASTER_GET_NAME(chnConfig.commander), chnConfig.commander,
-                    HW_MBOX_MASTER_GET_NAME(chnConfig.subject), chnConfig.subject,
-                    chnConfig.memBuff.size);
+            CTRL_SET_IS_STARTED(True);
         }
+        else
+        {
+            /* non-supervisor and HW MBOX is not yet started... */
+            DPRINTK("continue configuration upon first interrupt from supervisor...");
+
+            /* Create the first receive opcode listener, it'll wait for the
+               first interrupt from supervisor (INIT_COMPLETE) */
+
+            RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX) = kthread_run(hwMbox_recvOpcodeListenerEntry,
+                                                                          &RECV_OP_THREAD_DATA(RECV_OPCODE_INIT_INDEX),
+                                                                          RECV_OPCODE_LISTENER_PREFIX"%02d",
+                                                                          RECV_OPCODE_INIT_INDEX);
+
+            if (IS_ERR(RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX)))
+            {
+                retVal = PTR_ERR(RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX));
+                PRINTK_ERR("Creating %s%02d used for initialization Failed!!! [error %d]",
+                           RECV_OPCODE_LISTENER_PREFIX, RECV_OPCODE_INIT_INDEX, retVal);
+
+                PRINTK_ERR("*** CRITICAL ERROR in HW MBOX initialization, no HW MBOX services will be avaiable ***");
 
-        /* Now that all configuration values and static channels are set we can set start! */
-        PRINTK_INFO("initial configuration completed, setting START!");
-        HW_MBOX_CTRL_START_SET(True);
+                RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX) = NULL;
 
-        /* TBD: send interrupt to BBU?! */
+                /* HW MBOX initialization cannot continue... */
+                return (-1);
+            }
+        }
     }
 
-SKIP_CONFIGURATION:
 #if defined HW_MBOX_IS_NP_CPU
-    /* Setup ISR (only after static configuration has been fully completed): */
+    /* Setup ISR: */
     if (request_irq(HW_MBOX_INT_LINE, hw_mbox_drv_isr, IRQF_TRIGGER_HIGH, HW_MBOX_INT_NAME, NULL /* no need for dev as line is not shared */))
     {
         PRINTK_ERR("Unable to allocate IRQ!");
@@ -1236,9 +3821,106 @@ SKIP_CONFIGURATION:
        netss_subdev_irq_info_t irq_info;
        irq_info.func = &hw_mbox_drv_isr;
        irq_info.args = &hwMboxDriverData;
-       netss_subdev_register_irq(NETSS_HW_MAILBOX, &irq_info); 
+       netss_subdev_register_irq(NETSS_HW_MAILBOX, &irq_info);
     }
 #endif
+
+    if (IS_SUPERVISOR())
+    {
+        /* Now that everything is ready send interrupt to all valid Masters: */
+
+        DPRINTK("send IS_INIT_COMPLETE command to valid masters...");
+
+        cmdRegVal = 0;
+        cmdRegVal = HW_MBOX_OPCODE_SET_TAG(cmdRegVal, HW_MBOX_OPCODE_TAG);
+        cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_CODE_INIT_COMPLETE);
+
+        /* Flags are currently reserved! */
+        cmdRegVal = HW_MBOX_OPCODE_SET_FLAG_A(cmdRegVal, 0);
+        cmdRegVal = HW_MBOX_OPCODE_SET_FLAG_B(cmdRegVal, 0);
+
+        for (paramMID = 0; paramMID < HW_MBOX_MASTER_COUNT; paramMID++)
+        {
+            if (IS_MASTER_VALID(paramMID))
+            {
+                if (paramMID == HW_MBOX_MID)
+                {
+                    MASTER_SET_INITIALIZED(HW_MBOX_MID, True);
+
+                    /* no need to send to ourself */
+                    continue;
+                }
+
+                paramCID = FIND_CID_IN_LUT(paramMID, hw_mbox_opcode, False);
+                if (paramCID != HW_MBOX_CID_INVALID)
+                {
+                    /* Set a special flag so that ISR can identify it's an INIT channel */
+                    DPRINTK("using cid %d as INIT CID master %d, sending command 0x%08x", paramCID, paramMID, cmdRegVal);
+                    CHN_SET_INIT(paramCID, True);
+                    HW_MBOX_CHN_COMMAND_REG_SET(paramCID, cmdRegVal);
+                }
+                else
+                {
+                    PRINTK_ERR("can't find an INIT CID for valid master %d", paramMID);
+                }
+            }
+        }
+
+        /* currently INIT_COMPLETE notification is not used in supervisor's driver... */
+        SET_INIT_COMPLETE();
+
+        /* reset SRAM of channel where this Master [supervisor] is Commander: */
+        DPRINTK("Reset SRAM of channels where supervisor is commander");
+
+        regVal = HW_MBOX_MASTER_COMMANDER_L_REG_GET();
+        DPRINTK("commander initial SRAM reset: master commander low reg 0x%08x", regVal);
+
+        for (i = 0; i < HW_MBOX_CHANNEL_COUNT; i++)
+        {
+            if (0 == regVal)
+            {
+                if (i < 32)
+                {
+                    DPRINTK("no more channels in commander low reg val...");
+
+                    /* go to high register */
+                    regVal = HW_MBOX_MASTER_COMMANDER_H_REG_GET();
+                    DPRINTK("commander initial SRAM reset: master commander high reg 0x%08x", regVal);
+
+                    i = 31;     /* jump to high CID range... */
+                    continue;
+                }
+                else
+                {
+                    DPRINTK("no more channels in commander high reg val...");
+                    break; /* done! */
+                }
+            }
+
+            DPRINTK("commander initial SRAM reset: checking cid %d", i);
+
+            if ((regVal & BIT(i % 32)) != 0)
+            {
+                /* commander on this channel! */
+                DPRINTK("commander initial SRAM reset: master is commander on cid %d!", i);
+
+                if (CHN_CFG_MEMBUFF_GET_SIZE(i) > 0)
+                {
+                    /* Reset Channel SRAM: */
+                    DPRINTK("commander initial SRAM reset: resetting %uB of SRAM at offset=0x%08x",
+                            CHN_CFG_MEMBUFF_GET_SIZE(i), CHN_CFG_MEMBUFF_GET_START(i));
+
+                    HW_MBOX_RESET_SRAM(CHN_CFG_MEMBUFF_GET_START(i), CHN_CFG_MEMBUFF_GET_SIZE(i));
+                }
+
+                regVal &= (~BIT(i % 32));    /* turn off bit, we got it... */
+            }
+        }
+
+        /* Let all driver services that the device is initialized! */
+        SET_INITIALIZED();
+    }
+
     return 0;
 }
 
--- a/arch/x86/hw_mailbox/hw_mbox_mem_access.h
+++ b/arch/x86/hw_mailbox/hw_mbox_mem_access.h
@@ -11,7 +11,7 @@
 
   GPL LICENSE SUMMARY
 
-  Copyright(c) 2014 Intel Corporation.
+  Copyright(c) 2014-2015 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify 
   it under the terms of version 2 of the GNU General Public License as
@@ -36,7 +36,7 @@
 
   BSD LICENSE 
 
-  Copyright(c) 2014 Intel Corporation. All rights reserved.
+  Copyright(c) 2014-2015 Intel Corporation. All rights reserved.
 
   Redistribution and use in source and binary forms, with or without 
   modification, are permitted provided that the following conditions 
@@ -92,8 +92,8 @@
 #else
 /* User Space: */
 #include "endian.h"     /* Endianness: htobe32, be32toh */
-#endif // __KERNEL__
-#endif // HW_MBOX_OS_LINUX
+#endif /* __KERNEL__ */
+#endif /* HW_MBOX_OS_LINUX */
 
 #ifdef HW_MBOX_OS_FLAT
 /* FLAT OS: */
@@ -101,7 +101,7 @@
 #if defined HW_MBOX_IS_DS_PHY_CPU
 #include "phy_cpu_defs.h"    /* for base address of the HW_MBOX and Endianness Configuration */
 #endif
-#endif // HW_MBOX_OS_FLAT
+#endif /* HW_MBOX_OS_FLAT */
 
 /***********************************************************
 |                                                          |
@@ -201,19 +201,18 @@
 #undef HW_MBOX_MID                            /* Undefine the Hardcoded original value */
 #define HW_MBOX_MID ( __debug_HW_MBOX_MID )   /* redefine as a global variable [so will be able to change during runtime] */
 
-/*! \var volatile Uint32 __debug_HW_MBOX_MID
+/*! \var extern volatile Uint32 __debug_HW_MBOX_MID
     \brief changeable MID field for Debug.
     \attention set by using __HW_MBOX_DEBUG_SET_MID()
-    \note value starts off as 0.
 */
-volatile Uint32 __debug_HW_MBOX_MID;
+extern volatile Uint32 __debug_HW_MBOX_MID;
 
 /*! \def __HW_MBOX_DEBUG_SET_MID(newMID)
     \brief set Debug MID to <newMID>.
     \warning Must Use a Valid MID! 
 */
 #define __HW_MBOX_DEBUG_SET_MID(newMID)  ( __debug_HW_MBOX_MID = (newMID) )
-#endif // HW_MBOX_DEBUG
+#endif /* HW_MBOX_DEBUG */
 
 /* --- ACCESS MODIFIER (determines address space for this MID, relative to HW_MBOX BASE) --- */
 #define HW_MBOX_MEMDEFS_ACCESS_MODIFIER(paramMID)   ((paramMID) << 13)    /*!   ((paramMID) * 0x2000)   */
@@ -591,8 +590,8 @@ volatile Uint32 __debug_HW_MBOX_MID;
     TYPE - The Type of MBOX protocol that is employed on the channel.
            Possible Values: COMMAND=0, EVENT=1.
 
-           * NOTE: we only need 1 bit (for 0/1 possible values). The other bits
-                   are reserved for future type expansion and byte alignment
+           * NOTE: we only need 2 bit (for 00/01/10 possible values). The other
+                   bits are reserved for future type expansion and byte alignment
                    considerations of the fields.
 
     REQ_ID - Request ID, a unique identifier (0-255 possible values) for the
@@ -1030,7 +1029,7 @@ static inline Uint32 hw_mbox_field32_set
 /*! Clears bitPattern from the Interrupt Enable Mask */
 #define HW_MBOX_MASTER_INTR_MASK_H_REG_CLEAR(bitPattern) \
           HW_MBOX_MASTER_INTR_MASK_H_REG_SET(HW_MBOX_MASTER_INTR_MASK_H_REG_GET() & (~(bitPattern)))
-
+    
 /*! Masks interrupts from a specific CID (<paramCID> = [0-63]) */
 #define HW_MBOX_MASTER_INTR_MASK_CID(paramCID) \
 do{ \
@@ -1068,6 +1067,10 @@ do{ \
     Use it to clear consumed Masked interrupts. */
 #define HW_MBOX_MASTER_INTR_CLEAR_H_REG_SET(value)    HW_MBOX_REG_SET(HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_H_OFFSET, value)
 
+/*! Gets the correct INTR_CLEAR_REG (L/H) according to CID range (<paramCID> = [0-63]) */
+#define HW_MBOX_MASTER_INTR_CLEAR_REG_GET(paramCID) \
+    ((paramCID > 31)?(HW_MBOX_MASTER_INTR_CLEAR_H_REG_GET()):(HW_MBOX_MASTER_INTR_CLEAR_L_REG_GET()))
+
 /* --------------------------------------------------------------------------- */
 /* COMMANDER REGISTERS: */
 
@@ -1131,7 +1134,16 @@ do{ \
     HW_MBOX_CHN_CFG_COMMANDER_SET(paramCID, _commander);    \
     HW_MBOX_CHN_CFG_SUBJECT_SET(paramCID, _subject);        \
 } while (0)
-    
+
+/* Macros that enable getting configuration field values
+   from the configuration register value [after reg value has already been read]: */
+
+#define HW_MBOX_CHN_CFG_VALID_GET_FROM_REGVAL( _cfgRegVal )         hw_mbox_field32_get( _cfgRegVal , HW_MBOX_FLDDEFS_CHN_VALID_OFFSET, HW_MBOX_FLDDEFS_CHN_VALID_LENGTH)
+#define HW_MBOX_CHN_CFG_TYPE_GET_FROM_REGVAL( _cfgRegVal )          hw_mbox_field32_get( _cfgRegVal , HW_MBOX_FLDDEFS_CHN_TYPE_OFFSET, HW_MBOX_FLDDEFS_CHN_TYPE_LENGTH)
+#define HW_MBOX_CHN_CFG_REQ_ID_GET_FROM_REGVAL( _cfgRegVal )        hw_mbox_field32_get( _cfgRegVal , HW_MBOX_FLDDEFS_CHN_REQ_ID_OFFSET, HW_MBOX_FLDDEFS_CHN_REQ_ID_LENGTH)
+#define HW_MBOX_CHN_CFG_COMMANDER_GET_FROM_REGVAL( _cfgRegVal )     hw_mbox_field32_get( _cfgRegVal , HW_MBOX_FLDDEFS_CHN_COMMANDER_OFFSET, HW_MBOX_FLDDEFS_CHN_COMMANDER_LENGTH)
+#define HW_MBOX_CHN_CFG_SUBJECT_GET_FROM_REGVAL( _cfgRegVal )       hw_mbox_field32_get( _cfgRegVal , HW_MBOX_FLDDEFS_CHN_SUBJECT_OFFSET, HW_MBOX_FLDDEFS_CHN_SUBJECT_LENGTH)
+
 /* --------------------------------------------------------------------------- */
 /*  HW_MBOX_CHN_COMMAND[CID](REG), RW: */
 
@@ -1243,6 +1255,121 @@ do{ \
 */
 #define HW_MBOX_CTRL_AS_DEFAULT_SUPERVISOR_SUPERVISOR_SET(newSupervisorMID) \
           HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CTRL_AS_DEFAULT_SUPERVISOR_OFFSET, HW_MBOX_FLDDEFS_SUPERVISOR_OFFSET, HW_MBOX_FLDDEFS_SUPERVISOR_LENGTH, newSupervisorMID)
-#endif // __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO
 
-#endif // !_HW_MBOX_MEM_ACCESS_H_
+#endif /* __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO */
+
+/****************************************************
+|                                                   |
+|        HW_MBOX Opcode Fields                      |
+|                                                   |
+****************************************************/
+
+/*  --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_OPCODE
+    +---------------------------------------------------------------------------+
+    | TAG             | A  | B  |    CODE                 |    LEN              |
+    | 31:24           | 23 | 22 |    21:10                |    9:0              |
+    | RW              | RW | RW |    RW                   |    RW               |
+    +---------------------------------------------------------------------------/
+
+    NOTE: These are SW defined fields on to be used on the channel's command register.
+
+    TAG - value indicating the destination of the opcode.
+
+    CODE - code of the command (per TAG, defined by applicative context).
+
+    FLAG A/B - 2 reserved flags [for internal use].
+
+    LEN - How many words are to be read from SRAM (opcode Data).
+          [LEN is integral multiple of 4 Bytes so we can use word count].
+*/
+
+#define HW_MBOX_OPCODE_FLDDEFS_TAG_OFFSET (24)
+#define HW_MBOX_OPCODE_FLDDEFS_TAG_LENGTH (HW_MBOX_OPCODE_TAG_BITLEN) /*! already defined in defs */
+
+#define HW_MBOX_OPCODE_FLDDEFS_FLAG_A_OFFSET (23)
+#define HW_MBOX_OPCODE_FLDDEFS_FLAG_A_LENGTH (1)
+
+#define HW_MBOX_OPCODE_FLDDEFS_FLAG_B_OFFSET (22)
+#define HW_MBOX_OPCODE_FLDDEFS_FLAG_B_LENGTH (1)
+
+#define HW_MBOX_OPCODE_FLDDEFS_CODE_OFFSET (10)
+#define HW_MBOX_OPCODE_FLDDEFS_CODE_LENGTH (HW_MBOX_OPCODE_CODE_BITLEN) /*! already defined in defs */
+
+#define HW_MBOX_OPCODE_FLDDEFS_LEN_OFFSET (0)
+#define HW_MBOX_OPCODE_FLDDEFS_LEN_LENGTH (10)
+
+/* Modifier Macro helpers: */
+
+/*! TAG: customer indication. */
+#define HW_MBOX_OPCODE_GET_TAG( _cmdRegVal)                   hw_mbox_field32_get( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_TAG_OFFSET, HW_MBOX_OPCODE_FLDDEFS_TAG_LENGTH)
+#define HW_MBOX_OPCODE_SET_TAG( _cmdRegVal, _tagVal)          hw_mbox_field32_set( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_TAG_OFFSET, HW_MBOX_OPCODE_FLDDEFS_TAG_LENGTH, _tagVal)
+
+/*! Flags: */
+
+/* A: */
+#define HW_MBOX_OPCODE_GET_FLAG_A( _cmdRegVal )               hw_mbox_field32_get( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_FLAG_A_OFFSET, HW_MBOX_OPCODE_FLDDEFS_FLAG_A_LENGTH)
+#define HW_MBOX_OPCODE_SET_FLAG_A( _cmdRegVal, _flagAVal)     hw_mbox_field32_set( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_FLAG_A_OFFSET, HW_MBOX_OPCODE_FLDDEFS_FLAG_A_LENGTH, _flagAVal)
+
+/* B: */
+#define HW_MBOX_OPCODE_GET_FLAG_B( _cmdRegVal )               hw_mbox_field32_get( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_FLAG_B_OFFSET, HW_MBOX_OPCODE_FLDDEFS_FLAG_B_LENGTH)
+#define HW_MBOX_OPCODE_SET_FLAG_B( _cmdRegVal, _flagBVal)     hw_mbox_field32_set( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_FLAG_B_OFFSET, HW_MBOX_OPCODE_FLDDEFS_FLAG_B_LENGTH, _flagBVal)
+
+/*! CODE: command code. */
+#define HW_MBOX_OPCODE_GET_CODE( _cmdRegVal)                  hw_mbox_field32_get( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_CODE_OFFSET, HW_MBOX_OPCODE_FLDDEFS_CODE_LENGTH)
+#define HW_MBOX_OPCODE_SET_CODE( _cmdRegVal, _codeVal)        hw_mbox_field32_set( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_CODE_OFFSET, HW_MBOX_OPCODE_FLDDEFS_CODE_LENGTH, _codeVal)
+
+/*! LEN: command data len in Bytes [note: in command Register the value is in words]. */
+#define HW_MBOX_OPCODE_GET_LEN( _cmdRegVal)                   (hw_mbox_field32_get( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_LEN_OFFSET, HW_MBOX_OPCODE_FLDDEFS_LEN_LENGTH) << 2)
+#define HW_MBOX_OPCODE_SET_LEN( _cmdRegVal, _lenValInBytes)   hw_mbox_field32_set( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_LEN_OFFSET, HW_MBOX_OPCODE_FLDDEFS_LEN_LENGTH, (( _lenValInBytes ) >> 2))
+
+/*********************************
+        High Level Helpers        
+*********************************/
+
+/*! \def HW_MBOX_CHANNEL_FULL_CONFIG_GET_TO_STRUCT(paramCID, _pChnConfig)
+    \brief Macro to get channel's full configuration (including SRAM) via struct.
+    \param[out] _pChnConfig - pointer to a hw_mbox_channelConfig_t struct.
+*/
+#define HW_MBOX_CHANNEL_CONFIG_GET_TO_STRUCT(paramCID, _pChnConfig) \
+do{ \
+    (_pChnConfig)->cid = paramCID;                                                 \
+    (_pChnConfig)->mboxType = HW_MBOX_CHN_CFG_TYPE_GET(paramCID);                  \
+    (_pChnConfig)->commander = HW_MBOX_CHN_CFG_COMMANDER_GET(paramCID);            \
+    (_pChnConfig)->subject = HW_MBOX_CHN_CFG_SUBJECT_GET(paramCID);                \
+    if (((_pChnConfig)->memBuff.size = HW_MBOX_MEMORY_MAP_SIZE_GET(paramCID)) > 0) \
+    {                                                                              \
+        /* Channel has SRAM */                                                     \
+        (_pChnConfig)->memBuff.start = HW_MBOX_MEMORY_MAP_START_GET(paramCID);     \
+    }                                                                              \
+} while (0)
+
+/*! \def HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT( _cmdRegVal, _pOpcodeFlds)
+    \brief Macro to get all opcode fields from a specific command register value via struct.
+    \param[in] _cmdRegVal - command register's value. 
+    \param[out] _pOpCodeFlds - pointer to a hwMbox_opcode_t struct.
+*/
+#define HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT( _cmdRegVal, _pOpcodeFlds) \
+do{ \
+    (_pOpcodeFlds)->tag = HW_MBOX_OPCODE_GET_TAG( _cmdRegVal);          \
+    (_pOpcodeFlds)->flagA = HW_MBOX_OPCODE_GET_FLAG_A( _cmdRegVal);     \
+    (_pOpcodeFlds)->flagB = HW_MBOX_OPCODE_GET_FLAG_B( _cmdRegVal);     \
+    (_pOpcodeFlds)->code = HW_MBOX_OPCODE_GET_CODE( _cmdRegVal);        \
+    (_pOpcodeFlds)->lenInBytes = HW_MBOX_OPCODE_GET_LEN( _cmdRegVal);   \
+} while (0)
+
+/*! \def HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT( _cmdRegVal, _pOpcodeFlds)
+    \brief Macro to set all opcode fields using struct.
+    \param[out] _cmdRegVal - buffer for command register's value. 
+    \param[in] _pOpCodeFlds - pointer to a hwMbox_opcode_t struct.
+*/
+#define HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT( _cmdRegVal, _pOpcodeFlds) \
+do{ \
+    (_cmdRegVal) = HW_MBOX_OPCODE_SET_TAG( _cmdRegVal, (_pOpcodeFlds)->tag);          \
+    (_cmdRegVal) = HW_MBOX_OPCODE_SET_FLAG_A( _cmdRegVal, (_pOpcodeFlds)->flagA);     \
+    (_cmdRegVal) = HW_MBOX_OPCODE_SET_FLAG_B( _cmdRegVal, (_pOpcodeFlds)->flagB);     \
+    (_cmdRegVal) = HW_MBOX_OPCODE_SET_CODE( _cmdRegVal, (_pOpcodeFlds)->code);        \
+    (_cmdRegVal) = HW_MBOX_OPCODE_SET_LEN( _cmdRegVal, (_pOpcodeFlds)->lenInBytes);   \
+} while (0)
+
+#endif /* ! _HW_MBOX_MEM_ACCESS_H_ */
