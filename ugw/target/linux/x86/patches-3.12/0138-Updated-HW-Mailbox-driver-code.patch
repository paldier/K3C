From 7f2a84eed9e8c2687a77735800a33801b5fb366d Mon Sep 17 00:00:00 2001
From: Emmanuel Jillela <emmanuel.jillela@intel.com>
Date: Tue, 23 Jun 2015 17:06:01 -0700
Subject: [PATCH 138/441] Updated HW Mailbox driver code.

---
 arch/x86/NetIP_SubSystem/netip_subsystem_defs.h |    2 +-
 arch/x86/NetIP_SubSystem/netip_subsystem_pm.c   |   73 +-
 arch/x86/hw_mailbox/hw_mbox_defs.h              |  683 -----------
 arch/x86/hw_mailbox/hw_mbox_drv.c               | 1421 ++++++++++++++---------
 arch/x86/hw_mailbox/hw_mbox_mem_access.h        |  316 ++---
 include/linux/hwMbox_types.h                    |   79 ++
 include/linux/hw_mailbox.h                      |   16 +-
 include/linux/hw_mbox_defs.h                    |  404 ++++---
 8 files changed, 1422 insertions(+), 1572 deletions(-)
 delete mode 100644 arch/x86/hw_mailbox/hw_mbox_defs.h
 create mode 100644 include/linux/hwMbox_types.h

--- a/arch/x86/NetIP_SubSystem/netip_subsystem_defs.h
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_defs.h
@@ -75,8 +75,8 @@ typedef struct netss_configure_msg {
    //uint32_t num_ds_chan;     /**Number of QAM DS channels */
    uint8_t  docsis_chan[32]; /** each byte if 1, indicates that it is a docsis channel */
    uint32_t cm_mode;         /**Cable modem operational mode  */
-   uint32_t RCF_filter;      /** */
    uint32_t RCE_floor;       /** */
+   uint32_t RCF_filter;      /** */
 } netss_configure_msg_t;
 
 typedef struct netss_service_request_msg {
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_pm.c
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_pm.c
@@ -81,7 +81,7 @@ static bool g_netss_boot_handshake_done
 static DECLARE_WAIT_QUEUE_HEAD(waitForNetIPMsgWQ);
 
 static int  netss_receive_netip_properties_msg(hw_mbox_Masters_e commander,
-                              Uint32 code,
+                              //Uint32 code,
                               Uint8 *dataBuf, Uint32 dataLen,
                               Uint32 *token)
 {
@@ -97,7 +97,7 @@ static int  netss_receive_netip_properti
 }
 
 int  netss_receive_netip_status_msg(hw_mbox_Masters_e commander,
-                              Uint32 code,
+                              //Uint32 code,
                               Uint8 *dataBuf, Uint32 dataLen,
                               Uint32 *token)
 {
@@ -110,13 +110,21 @@ int  netss_receive_netip_status_msg(hw_m
 }
 int data;
 
+static void netss_send_reply_ack(void)
+{
+   int ret = 0;
+   ret = hwMbox_sendAckOpcode(HW_MBOX_MASTER_NP_CPU);
+   if(ret) {
+      printk(KERN_ERR "Failed to send Ack to msg ret %d\n", ret);
+   }
+   return;
+}
 static void netss_send_reply_msg(void)
 {
    uint8_t reply_msg[64];
-   uint32_t reply_code = 0;
    memcpy(reply_msg, pnetss_drv_data->netip_msg.payload, pnetss_drv_data->netip_msg.len);
    /* Sending what recieved */
-   hwMbox_sendReplyOpcode(HW_MBOX_MASTER_NP_CPU, reply_code, reply_msg, pnetss_drv_data->netip_msg.len);
+   hwMbox_sendReplyOpcode(HW_MBOX_MASTER_NP_CPU, reply_msg, pnetss_drv_data->netip_msg.len);
 
    return;
 }
@@ -160,13 +168,34 @@ static void ness_process_netip_props_msg
    netss_sysfs_clean_up(g_netip_services_available);
    return;
 }
+/** NetIP configure message format
+ * ------------------------------------
+ * |header including Opcode -4bytes   |
+ * |----------------------------------|
+ * | chan id | chan id|chan id|chan id|   32 bytes are reserved for 32 channels [1...32]
+ * | 1byte   | 1byte  |1byte  |1byte  |   to be specified as docsis channels.
+ * |----------------------------------|   terminate list with 0 
+ * |And so on....
+ * |----------------------------------|
+ * | chan id | chan id|chan id|chan id|
+ * | 1bytes  | 1byte  |1byte  |1byte  |
+ * |----------------------------------|
+ * | cable modem mode 0-docsis, 1-GW  |  
+ * |           4bytes                 |
+ * |----------------------------------|
+ * |          RCE Floor               |  
+ * |           4bytes                 |
+ * |----------------------------------|
+ * |          RCE Filter              |  
+ * |           4bytes                 |
+ * |----------------------------------|
+ */
 
 static void netss_send_configure_msg (void)
 {
    int i, j=0, ret;
    uint32_t docsis_channels = 0xF0F00000; /*Mask indicating the channels numbers configured as docsis channels */
    netss_configure_msg_t cfg_msg;
-   uint32_t reply_code;
    uint32_t reply_len;
     
    /*clear the message */
@@ -186,12 +215,12 @@ static void netss_send_configure_msg (vo
    cfg_msg.docsis_chan[j] = 0;
   
    cfg_msg.cm_mode = 0; 
-   cfg_msg.RCF_filter = 0;
    cfg_msg.RCE_floor = 1;
-   ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, 0xFE, &reply_code, (uint8_t*)&cfg_msg, sizeof(netss_configure_msg_t), 4, &reply_len);
+   cfg_msg.RCF_filter = 0;
+   ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, HW_MBOX_RESREVED_OPCODE_TAG_5, (uint8_t*)&cfg_msg, sizeof(netss_configure_msg_t), sizeof(netss_configure_msg_t), &reply_len);
    if(ret)
    {
-       printk(KERN_ERR "Send configure message failed ret %d reply_code %d\n", ret, reply_code);
+       printk(KERN_ERR "Send configure message failed ret %d \n", ret);
    }
    /**Add some debug message on success */  
    return; 
@@ -223,9 +252,9 @@ static void netss_send_configure_msg (vo
 static void ness_process_service_status_msg(void) 
 {
    int i=0;
-   netss_service_request_msg_t *service_msg = &pnetss_drv_data->netip_msg.payload[0];
+   netss_service_request_msg_t *service_msg =(netss_service_request_msg_t*) &pnetss_drv_data->netip_msg.payload[0];
    netss_sysfs_attributes_info_t *syfs_info = &g_netss_sysfs_attributes_info;
-   netss_service_status_t *service_status = &pnetss_drv_data->netip_msg.payload[SERVICE_OFFSET];
+   netss_service_status_t *service_status = (netss_service_status_t *)&pnetss_drv_data->netip_msg.payload[SERVICE_OFFSET];
    
    //mutex_lock(&syfs_info->lock);
    NETSS_DBG_PRINT("processing service status message opcode %d\n", service_msg->opcode);
@@ -304,7 +333,6 @@ static int ness_send_service_request_msg
 {
    int i=0, j=0;
    int ret = -1;
-   uint32_t reply_code;
    uint32_t reply_len;
    netss_service_request_msg_t *service_msg = NULL;
    uint32_t service_msg_len;
@@ -388,15 +416,15 @@ static int ness_send_service_request_msg
       service_msg->service[j].id = 0;
       service_msg->service[j].state = 0;
     
-      ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, 0xFE, &reply_code, (uint8_t *)service_msg, service_msg_len, 4, &reply_len);
+      ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, HW_MBOX_RESREVED_OPCODE_TAG_5, (uint8_t *)service_msg, service_msg_len, service_msg_len, &reply_len);
       if(ret) {
-         printk(KERN_ERR "Send Sevice Request message failed ret %d reply_code %d\n", ret, reply_code);
+         printk(KERN_ERR "Send Sevice Request message failed ret %d \n", ret);
       } else {
          netss_update_sysfs_attributes(syfs_info, service_msg);
       }
      // mutex_unlock(&syfs_info->lock);
      /*Can free the message memory now */
-     kfree(service_msg_len);
+     kfree(service_msg);
    }
    
    /**Add some debug message on success */   
@@ -406,7 +434,6 @@ static int ness_send_service_request_msg
 static int ness_send_single_service_request_msg(uint32_t service_id, uint32_t state)
 {
    int ret = -1;
-   uint32_t reply_code;
    uint32_t reply_len;
    netss_service_request_msg_t *service_msg = NULL;
    uint32_t service_msg_len;
@@ -438,15 +465,15 @@ static int ness_send_single_service_requ
       service_msg->service[1].id = 0;
       service_msg->service[1].state = 0;
 
-      ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, 0xFE, &reply_code, (uint8_t *)service_msg, service_msg_len, 4, &reply_len);
+      ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, HW_MBOX_RESREVED_OPCODE_TAG_5, (uint8_t *)service_msg, service_msg_len, service_msg_len, &reply_len);
       if(ret) {
-         printk(KERN_ERR "Send Single Sevice Request message failed ret %d reply_code %d\n", ret, reply_code);
+         printk(KERN_ERR "Send Single Sevice Request message failed ret %d \n", ret);
       } else {
          netss_update_sysfs_attributes(syfs_info, service_msg);
       }
 
       /*Can free the message memory now */
-      kfree(service_msg_len);
+      kfree(service_msg);
    }   
 }
 static int netss_configure_and_setup_netip_services(void *data)
@@ -469,7 +496,7 @@ static int netss_configure_and_setup_net
       mutex_lock(&g_netss_sysfs_attributes_info.lock);
       if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_NETIP_PROPERTIES) {
          /*send reply*/ 
-         netss_send_reply_msg();
+         netss_send_reply_ack();
          /*process netip properties message */
          ness_process_netip_props_msg();
          /* send configure message */
@@ -477,7 +504,7 @@ static int netss_configure_and_setup_net
          
       } else if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_SERVICE_STATUS) {
          /*send reply*/
-         netss_send_reply_msg();
+         netss_send_reply_ack();
          /*process service status message */
          ness_process_service_status_msg();
          /* send service request message */
@@ -501,7 +528,7 @@ static int netss_configure_and_setup_net
          NETSS_DBG_PRINT("service status of all available services received \n");
          /*This thread can exit here */
       } else {
-         NETSS_DBG_PRINT("services available 0x status received %x\n", g_netip_services_available, g_netip_services_status_received);
+         NETSS_DBG_PRINT("services available %x status received %x\n", g_netip_services_available, g_netip_services_status_received);
       }
       /*Done processing the message */ 
       g_netip_msg = NETIP_MSG_NONE;
@@ -520,11 +547,11 @@ void netss_manage_netip_services(void)
    /*Register netip properties message, update tage and token later */
    hwMbox_registerRecvOpcode(HW_MBOX_MASTER_NP_CPU,
                              netss_receive_netip_properties_msg,
-                             0xFE, 0x1); 
+                             HW_MBOX_RESREVED_OPCODE_TAG_5, 0x1); 
    /*Register netip status message, update tage and token later */
    hwMbox_registerRecvOpcode(HW_MBOX_MASTER_NP_CPU,
                              netss_receive_netip_status_msg,
-                             0xFE, 0x2); 
+                             HW_MBOX_RESREVED_OPCODE_TAG_5, 0x2); 
    pnetss_drv_data->handshake_thread = kthread_run(netss_configure_and_setup_netip_services, (void *)data, "netip_service_manager");
    
    if(!pnetss_drv_data->handshake_thread) {
--- a/arch/x86/hw_mailbox/hw_mbox_defs.h
+++ /dev/null
@@ -1,683 +0,0 @@
-/*
- *
- * hw_mbox_defs.h
- * Description:
- * contains basic definitions puma7 HW_MBOX controller SW.
- *
- 
-  This file is provided under a dual BSD/GPLv2 license.  When using or 
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014-2015 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify 
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but 
-  WITHOUT ANY WARRANTY; without even the implied warranty of 
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
-  General Public License for more details.
-
-  You should have received a copy of the GNU General Public License 
-  along with this program; if not, write to the Free Software 
-  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-  The full GNU General Public License is included in this distribution 
-  in the file called LICENSE.GPL.
-
-
-  Contact Information:
-  Intel Corporation
-  2200 Mission College Blvd.
-  Santa Clara, CA  97052
-
-  BSD LICENSE 
-
-  Copyright(c) 2014-2015 Intel Corporation. All rights reserved.
-
-  Redistribution and use in source and binary forms, with or without 
-  modification, are permitted provided that the following conditions 
-  are met:
-
-    * Redistributions of source code must retain the above copyright 
-      notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright 
-      notice, this list of conditions and the following disclaimer in 
-      the documentation and/or other materials provided with the 
-      distribution.
-
-    * Neither the name of Intel Corporation nor the names of its 
-      contributors may be used to endorse or promote products derived 
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-#ifndef _HW_MBOX_DEFS_H_
-#define _HW_MBOX_DEFS_H_
-
-/******************************************
-|                                         |
-|        HW_MBOX Basic Definitions        |
-|                                         |
-******************************************/
-
-/*! \def HW_MBOX_MASTER_COUNT 
-    \brief Count of HW_MBOX Masters. */
-#define HW_MBOX_MASTER_COUNT     16
-
-/*! \def HW_MBOX_CHANNEL_COUNT 
-    \brief Count of HW_MBOX Channel. */
-#define HW_MBOX_CHANNEL_COUNT    64
-
-#define HW_MBOX_CID_INVALID    0xFFFFFFFF
-
-/*! \def HW_MBOX_MID_VALIDITY_CHECK(paramMID) 
-    \brief evaluates as True if paramMID is a valid MID. */
-#define HW_MBOX_MID_VALIDITY_CHECK(paramMID)    (((paramMID) >= 0) && ((paramMID) < HW_MBOX_MASTER_COUNT))
-
-/*! \def HW_MBOX_CID_VALIDITY_CHECK(paramCID) 
-    \brief evaluates as True if paramCID is a valid CID. */
-#define HW_MBOX_CID_VALIDITY_CHECK(paramCID)    (((paramCID) >= 0) && ((paramCID) < HW_MBOX_CHANNEL_COUNT))
-
-/* HW_MBOX_MASTER_MID defines: */
-/* Note: should be kept in sync with HW_MBOX_IS_MASTER defines and with HW_MBOX_MASTER_TABLE */
-#define HW_MBOX_NP_CPU_MID          0  /*! MID of NP_CPU        */
-#define HW_MBOX_BBU_C_MID           1  /*! MID of BBU_C         */
-#define HW_MBOX_APP_CPU_MID         2  /*! MID of APP_CPU       */
-#define HW_MBOX_RCE_MID             3  /*! MID of RCE           */
-#define HW_MBOX_US_MAC_CPU_MID      4  /*! MID of US_MAC_CPU    */
-#define HW_MBOX_DS_PHY_CPU_MID      5  /*! MID of DS_PHY_CPU    */
-#define HW_MBOX_MOCA_C_MID          6  /*! MID of MOCA_C        */
-#define HW_MBOX_DS_MAC_C_MID        7  /*! MID of DS_MAC_C      */
-#define HW_MBOX_PP_NETSEC_MID       8  /*! MID of PP_NETSEC     */
-#define HW_MBOX_PP_RESEQ_MID        9  /*! MID of PP_RESEQ      */
-#define HW_MBOX_PP_STAGE1_MID      10  /*! MID of PP_STAGE1     */
-#define HW_MBOX_PP_QOS_MID         11  /*! MID of PP_QOS        */
-#define HW_MBOX_C55_MID            12  /*! MID of C55           */
-#define HW_MBOX_FREE0_MID          13  /*! MID of FREE0         */
-#define HW_MBOX_SEC_MID            14  /*! MID of SEC           */
-#define HW_MBOX_CSE_MID            15  /*! MID of CSE           */
-
-/*! \var typedef enum hw_mbox_type hw_mbox_type_e
-    \brief This enum denotes types of mboxs (protocols) that are supported. */
-typedef enum hw_mbox_type
-{
-    hw_mbox_command = 0,  /* Command */
-    hw_mbox_event,        /* Event   */
-    hw_mbox_opcode,       /* Opcode (generic HW MBOX command-response protocol) */
-
-    HW_MBOX_TYPE_COUNT    /* Should always be last... */
-} hw_mbox_type_e;
-
-/*! \def HW_MBOX_TYPE_STR(mboxType)
-    \brief gets a string according to <mboxType>
-    \attention <mboxType> should be a value from hw_mbox_type_e 
-*/
-#define HW_MBOX_TYPE_STR(mboxType)    ( (mboxType == hw_mbox_command)?("Command"): \
-                                        ((mboxType == hw_mbox_event)?("Event"):("Opcode")) )
-
-/*! \def HW_MBOX_DEFAULT_TIMEOUT_SEC
-    \brief Default timeout value in seconds.
-    \note can comment out define to set wait forever.
-    \attention wait forever setting should only be used for debug! 
-*/
-#define HW_MBOX_DEFAULT_TIMEOUT_SEC    10  /* 10 sec */
-
-/* Error Notification: */
-
-/* supervisor gets notified of access violation errors through a HW_MBOX interrupt.
-   To signal that there's an access violation error a Certain predetermined CID is
-   selected. This CID should not be allocaed to supervisor as a channel. */
-
-/*! \def HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR
-    \brief This CID gets signaled upon HW access violation errors.
-    \attention should only be used by supervisor.
-*/
-#define HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR    63
-
-/* Some General Macros we will use throughout the Code: */
-
-#define HW_MBOX_CONCAT2(a, b)          a ## b
-#define HW_MBOX_CONCAT3(a, b, c)       a ## b ## c
-
-#define HW_MBOX_STRINGIFY(x)    #x
-
-#ifndef BIT
-#define BIT( _i )       (1UL << ( _i ))
-#endif
-
-/**********************************************
-|                                             |
-|        HW_MBOX Package Configuration        |
-|                                             |
-**********************************************/
-
-/*! \def HW_MBOX_MONITOR    <MID_of_Monitor>
-    \brief MID of the Master to act as Monitor.
-    \attention use a value from HW_MBOX_MASTER_MID defines.
-    \note Feature is OPTIONAL, comment out define to disable.
-    \note Monitor gets an interrupt upon every HW_MBOX interrupt of any channel and should log the commands.
-    \note There's no lock on the command register value, this Monitoring feature is best effort only!
-*/
-//#define HW_MBOX_MONITOR    HW_MBOX_NP_CPU_MID
-
-/** --------------------------------------- **/
-
-/*! \def HW_MBOX_START_IN_HW_DEBUG_MODE
-    \brief Start HW_MBOX in HW Debug Mode.
-    \attention In HW Debug Mode access protection rules are not enforced and every Master access is permitted.
-    \note Feature is OPTIONAL, comment out define to disable.
-*/
-//#define HW_MBOX_START_IN_HW_DEBUG_MODE
-
-/** --------------------------------------- **/
-
-/*! \def __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO    <MID_of_new_Supervisor>
-    \brief MID of the Master to act as supervisor (instead of default one). 
-    \warning ONLY USE IF YOU ABSOULTLY KNOW WHAT YOU ARE DOING!!!
-    \attention use a value from HW_MBOX_MASTER_MID defines.
-    \note Feature is OPTIONAL, comment out define to disable.
-    \note This will change the default supervisor's MID (MID == 0) to the new value indicated here.
-    \note There has to be a special way to change it since only the supervisor can access the ctrl Register.
-*/
-//#define __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO    HW_MBOX_NP_CPU_MID
-
-/** --------------------------------------- **/
-
-/*! \def HW_MBOX_DEBUG
-    \brief Enable this flag for various debug operations of the HW_MBOX package. 
-    \note Feature is OPTIONAL, comment out define to disable.
-    \note Debug Features:
-    \note 1. Free access to the HW_MBOX registers and Memory via CLI.
-    \note 2. MID Disguise: enable the current Master to access the HW_MBOX "disguised" as a different Master.
-*/
-//#define HW_MBOX_DEBUG
-
-/******************************************************
-|                                                     |
-|        HW_MBOX Specific Master Configuration        |
-|                                                     |
-******************************************************/
-
-/*! \def HW_MBOX_MID    <MID_of_this_Master>
-    \brief MID of this Master, current Master, the one running this code. 
-    \attention use a value from HW_MBOX_MASTER_MID defines.
-    \note It is derived from which physical HW_MBOX interrupt line is connected to this Master.
-    \note Values for all Master are enumerated by hw_mbox_Masters_e, just pick the correct one.
-*/
-#define HW_MBOX_MID    HW_MBOX_APP_CPU_MID
-
-/*! \def HW_MBOX_OS_LINUX\HW_MBOX_OS_FLAT\HW_MBOX_OS_NONE
-    \brief Set one appropriate define according to Variant (OS). 
-    \attention Enable Exactly one of these!
-    \note HW_MBOX_OS_LINUX: U-services.
-    \note HW_MBOX_OS_FLAT:  F-services. 
-    \note HW_MBOX_OS_NONE:  N-services. 
-*/
-#define HW_MBOX_OS_LINUX     /* U-services */
-//#define HW_MBOX_OS_FLAT    /* F-services */
-//#define HW_MBOX_OS_NONE    /* N-services */
-
-/* Variant Selection Check: */
-#if ((defined(HW_MBOX_OS_LINUX) + defined(HW_MBOX_OS_FLAT) + defined(HW_MBOX_OS_NONE)) != 1)
-#   error "HW_MBOX defs: Enable ONE OS Variant exactly!"
-#endif
-
-/*! \var HW_MBOX_HARDCODED_MID
-    \brief Remember the HARDCODED MID of this Master.
-    \attention This is needed as under debug "MID Disguise Feature" undefs HW_MBOX_MID and redefines it as a dynamic field.
-    \note using enum to qualify as CONST.
-*/
-enum { HW_MBOX_HARDCODED_MID = HW_MBOX_MID };
-
-/* HW_MBOX_IS_MASTER defines (useful for #ifdef-ing include for instance): */
-/* Note: These should be kept in sync with HW_MBOX_MASTER_MID defines and with HW_MBOX_MASTER_TABLE  */
-#if (HW_MBOX_MID == HW_MBOX_NP_CPU_MID)
-#define HW_MBOX_IS_NP_CPU               /*! defined if current HW_MBOX Master is NP_CPU     */
-#elif (HW_MBOX_MID == HW_MBOX_BBU_C_MID)
-#define HW_MBOX_IS_BBU_C                /*! defined if current HW_MBOX Master is BBU_C      */
-#elif (HW_MBOX_MID == HW_MBOX_APP_CPU_MID)
-#define HW_MBOX_IS_APP_CPU              /*! defined if current HW_MBOX Master is APP_CPU    */
-#elif (HW_MBOX_MID == HW_MBOX_RCE_MID)
-#define HW_MBOX_IS_RCE                  /*! defined if current HW_MBOX Master is RCE        */
-#elif (HW_MBOX_MID == HW_MBOX_US_MAC_CPU_MID)
-#define HW_MBOX_IS_US_MAC_CPU           /*! defined if current HW_MBOX Master is US_MAC_CPU */
-#elif (HW_MBOX_MID == HW_MBOX_DS_PHY_CPU_MID)
-#define HW_MBOX_IS_DS_PHY_CPU           /*! defined if current HW_MBOX Master is DS_PHY_CPU */
-#elif (HW_MBOX_MID == HW_MBOX_MOCA_C_MID)
-#define HW_MBOX_IS_MOCA_C               /*! defined if current HW_MBOX Master is MOCA_C     */
-#endif
-
-/* Generic Primitive typedefs: */
-
-/* need typedefs of Uint32, Uint8 and Bool(True/False). */
-#if   defined HW_MBOX_IS_NP_CPU
-#include "_tistdtypes.h"
-#elif defined HW_MBOX_IS_APP_CPU
-typedef uint32_t Uint32;
-typedef int32_t  Int32;
-typedef uint8_t  Uint8;
-typedef bool     Bool;
-#define True true
-#define False false
-#include <linux/types.h> /* include file with generic typedefs for APP-CPU */
-#elif defined HW_MBOX_IS_DS_PHY_CPU
-#include "types.h"
-#endif
-
-/********************************************
-|                                           |
-|        HW_MBOX Master Declarations        |
-|                                           |
-********************************************/
-
-/*! \var typedef enum hw_mbox_support hw_mbox_support_e
-    \brief This enum denotes which SW support exists on each Master. */
-typedef enum hw_mbox_support
-{
-    hw_mbox_support_none = 0, /* No SW support on this Master */
-    hw_mbox_support_static,   /* only supports static channel allocation */
-    hw_mbox_support_dynamic   /* supports static and dynamic channel allocation */
-} hw_mbox_support_e;
-
-/*! \def HW_MBOX_SUPPORT_STR(mboxSupport)
-    \brief gets a string according to <mboxSupport>
-    \attention <mboxSupport> should be a value from hw_mbox_support_e 
-*/
-#define HW_MBOX_SUPPORT_STR(mboxSupport)    ( (mboxSupport == hw_mbox_support_dynamic)?("Dynamic"): \
-                                              ((mboxSupport == hw_mbox_support_static)?("Static"):("None")) )
-
-/*! \var typedefstruct hw_mbox_masterConfig hw_mbox_masterConfig_t
-    \brief Master configuration struct. */
-typedef struct hw_mbox_masterConfig
-{
-    hw_mbox_support_e   support;
-} hw_mbox_masterConfig_t;
-
-/*! \def HW_MBOX_MASTER_CONFIG_SIZE 
-    \brief Master configuration struct's size. */
-#define HW_MBOX_MASTER_CONFIG_SIZE    (sizeof(hw_mbox_masterConfig_t))
-
-/*! \def HW_MBOX_MASTER_TABLE(ENTRY)
-    \brief X-MACRO hardcoded table for HW_MBOX Master declarations.
-    \brief Position in the Table determines MID (Master ID) of the Master, a unique identifier
-           dictated by Hardware (HW_MBOX Interrupt Line Number which connects to the Master).
-    \attention Should be kept in sync with HW_MBOX_MASTER_MID defines and with HW_MBOX_IS_MASTER defines.
-    \note NP_CPU is generic name for ARM11.
-    \note APP_CPU is generic name for ATOM.
-    \note US_MAC_CPU is generic name for Upstream MAC CPU ARM9.
-    \note Interrupt line 13 is not physically connected, reserved for possible SW internal usage.
-*/
-#define HW_MBOX_MASTER_TABLE(ENTRY) \
-/* +------------------------------------------------------------+ */ \
-/* | MID |         | Name /        | HW_MBOX SW support         | */ \
-/* |     |         | Description   | [hw_mbox_support_e]        | */ \
-/* +------------------------------------------------------------+ */ \
-/* |  0  | */ ENTRY( NP_CPU        , hw_mbox_support_static     )    \
-/* |  1  | */ ENTRY( BBU_C         , hw_mbox_support_static     )    \
-/* |  2  | */ ENTRY( APP_CPU       , hw_mbox_support_static     )    \
-/* |  3  | */ ENTRY( RCE           , hw_mbox_support_none       )    \
-/* |  4  | */ ENTRY( US_MAC_CPU    , hw_mbox_support_none       )    \
-/* |  5  | */ ENTRY( DS_PHY_CPU    , hw_mbox_support_static     )    \
-/* |  6  | */ ENTRY( MOCA_C        , hw_mbox_support_static     )    \
-/* |  7  | */ ENTRY( DS_MAC_C      , hw_mbox_support_none       )    \
-/* |  8  | */ ENTRY( PP_NETSEC     , hw_mbox_support_none       )    \
-/* |  9  | */ ENTRY( PP_RESEQ      , hw_mbox_support_none       )    \
-/* | 10  | */ ENTRY( PP_STAGE1     , hw_mbox_support_none       )    \
-/* | 11  | */ ENTRY( PP_QOS        , hw_mbox_support_none       )    \
-/* | 12  | */ ENTRY( C55           , hw_mbox_support_none       )    \
-/* | 13  | */ ENTRY( FREE0         , hw_mbox_support_none       )    \
-/* | 14  | */ ENTRY( SEC           , hw_mbox_support_none       )    \
-/* | 15  | */ ENTRY( CSE           , hw_mbox_support_none       )
-
-/* Master Table Expanders: */
-
-/*! \def HW_MBOX_MASTER_TABLE_AS_ENUM( _desc, _support )
-    \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as enum.
-    \note Masters will be enumerated according to this template: HW_MBOX_MASTER_<_desc> 
-*/
-#define HW_MBOX_MASTER_TABLE_AS_ENUM( _desc, _support )      HW_MBOX_CONCAT2(HW_MBOX_MASTER_, _desc),
-
-/*! \def HW_MBOX_MASTER_TABLE_AS_STRS( _desc, _support )
-    \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as strings.
-    \note Strings are created according to this template: "<_desc>" 
-*/
-#define HW_MBOX_MASTER_TABLE_AS_STRS( _desc, _support )      HW_MBOX_STRINGIFY(_desc),
-
-/*! \def HW_MBOX_MASTER_TABLE_AS_COUNT( _desc, _support )
-    \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as entry count. */
-#define HW_MBOX_MASTER_TABLE_AS_COUNT( _desc, _support )     1+ 
-
-/*! \def HW_MBOX_MASTER_TABLE_AS_DB( _desc, _support )
-    \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as DB.
-    \note intializes an array of hw_mbox_masterConfig_t.
-    \attention only create inside c file.
-*/
-#define HW_MBOX_MASTER_TABLE_AS_DB( _desc, _support )    { .support = _support },
-
-/* Master Table Expander Wrappers: */
-
-/*! \def HW_MBOX_MASTER_TABLE_STRS
-    \brief Creates an string array with HW MBOX Masters names.
-    \note "<_desc0>", "<_desc1>", ... [so we need] '\0' for array syntax and proper array null termination.
-    \note creates and initializes a static char * array with name <_arrayName>.
-    \attention only use inside c file.
-*/
-#define HW_MBOX_MASTER_TABLE_STRS( _arrayName ) \
-    static const char *_arrayName[] =                      \
-    {                                                      \
-        HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_STRS) \
-        '\0'                                               \
-    }
-
-/*! \def HW_MBOX_MASTER_TABLE_DB( _arrayName )
-    \brief Creates a hw_mbox_masterConfig_t array with HW MBOX Masters Data.
-    \note creates and initializes a static hw_mbox_masterConfig_t array with name <_arrayName>.
-    \attention only use inside c file.
-*/
-#define HW_MBOX_MASTER_TABLE_DB( _arrayName ) \
-    static const hw_mbox_masterConfig_t _arrayName[] =     \
-    {                                                      \
-        HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_DB)   \
-    }
-
-/*! \def HW_MBOX_MASTER_TABLE_COUNT
-    \brief wrapper for HW_MBOX_MASTER_TABLE_AS_COUNT.
-    \note 1+ 1+ ... [so we need] 0 for syntax.
-*/
-#define HW_MBOX_MASTER_TABLE_COUNT    (HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_COUNT) 0)
-
-/* Basic Sanity Check for Master Table: */
-#if (HW_MBOX_MASTER_COUNT != (HW_MBOX_MASTER_TABLE_COUNT))
-#   error "HW_MBOX MASTER TABLE: entry count in the table must equal the total Master Count!"
-#endif
-
-/*! \var typedef enum hw_mbox_Masters hw_mbox_Masters_e 
-    \brief Enumerate all HW_MBOX Master with MID value.
-    \note name of the Masters is according to HW_MBOX_MASTER_TABLE_AS_ENUM Macro.
-*/
-typedef enum hw_mbox_Masters
-{
-    HW_MBOX_MID_INVALID = -1,
-    HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_ENUM)
-    HW_MBOX_MASTER_LAST_ENTRY
-} hw_mbox_Masters_e;
-
-/**********************************************
-|                                             |
-|        Variant Specific Declarations        |
-|                                             |
-**********************************************/
-
-#ifdef HW_MBOX_OS_LINUX
-/* Defines related to Kernel Driver: */
-
-/*! \def HW_MBOX_DRV_DEV_DIR_NAME
-    \brief directory under /dev containing the chnint char devices. */
-#define HW_MBOX_DRV_DEV_DIR_NAME    "hw_mbox_drv"
-
-/*! \def HW_MBOX_CHNINT_DEV_NAME
-    \brief Prefix name of the chnint char devices, these devices are used to extend interrupt signals from Kernel to User Space.
-    \note for channel XX the device is chnintXX [e.g. channel 8 -> chnint08].
-    \note devices located in directory /dev/<HW_MBOX_DRV_DEV_DIR_NAME> 
-*/
-#define HW_MBOX_CHNINT_DEV_NAME    "chnint"
-
-/** --------------------------------------- **/
-
-/*! \def HW_MBOX_RECENT_COMMAND_LOG    <Command_Count>
-    \brief How many recent commands should be saved.
-    \attention use a value > 0.
-    \note Feature is OPTIONAL, comment out define to disable.
-    \note Monitor Thread is in-charge of updating the Log.
-*/
-//#define HW_MBOX_RECENT_COMMAND_LOG    16
-
-#ifdef HW_MBOX_RECENT_COMMAND_LOG
-
-/* Argument Sanity Check: */
-#if (HW_MBOX_RECENT_COMMAND_LOG <= 0)
-#   error "HW_MBOX RECENT COMMAND LOG: Command Count Must be > 0!" 
-#endif
-
-/*! \def HW_MBOX_RECENT_COMMAND_LOG_INDEX_INVALID
-    \brief invalid index for the recent command log and snapshot log.
-*/
-#define HW_MBOX_RECENT_COMMAND_LOG_INDEX_INVALID    (-1)
-#endif /* HW_MBOX_RECENT_COMMAND_LOG */
-#endif /* HW_MBOX_OS_LINUX */
-
-/****************************************************
-|                                                   |
-|        HW_MBOX Opcode                             |
-|        (generic command-response protocol)        |
-|                                                   |
-****************************************************/
-
-/* HW MBOX OPCODE: a generic command-response protocol
-
-   OPCODE type channels exist to implement a generic command-response
-   sequence that can be used by package customers. The protocol predefines
-   the structure of the values that are to be written to command channel
-   register. While enabling less freedom to applications it enables the
-   construction of generic entities that can be used for message dispatching
-   without relying completely on application context. OPCODE type channels 
-   enable inherent support for several applications on the same channel.
-*/
-
-/* The Fields that OPCODE channel uses are:
- 
-   TAG - indicates the application that is the destination of the code.
-         Note: TAG == 0xFF and 0xFE are reserved for HW MBOX usage.
- 
-   CODE - code of the command (per TAG, defined by applicative context).
- 
-   FLAG A/B - 2 reserved flags [for internal use].
-
-   LEN - How many words are to be read from SRAM (opcode Data).
-         [LEN is integral multiple of 4 Bytes so we can use word count].
-
-   exact Field division is defined in mem_access file.
-*/
-
-/*! \var typedef struct hwMbox_opcode hwMbox_opcode_t
-    \brief struct for opcode fields. 
-    \note the types used here sometimes have more capacity than actual max value. 
-*/
-typedef struct hwMbox_opcode
-{
-    Uint32  tag;
-    Uint32  code;
-    Bool    flagA;
-    Bool    flagB;
-    Uint32  lenInBytes;
-} hwMbox_opcode_t;
-
-/* Field Bit Length definitions:
-   [These are done here so max value can be calculated and used here...] 
-
-   Note: if value change please update also corresponding documentation 
-   in mem access.
-*/
-
-#define HW_MBOX_OPCODE_TAG_BITLEN    (8)
-
-#define HW_MBOX_OPCODE_CODE_BITLEN   (12)
-
-/*! \def HW_MBOX_OPCODE_TAG_MAX_VALUE 
-    \brief Max value available for tag field when using OPCODE. */
-#define HW_MBOX_OPCODE_TAG_MAX_VALUE    (BIT(HW_MBOX_OPCODE_TAG_BITLEN) - 1)
-
-/*! \def HW_MBOX_OPCODE_CODE_MAX_VALUE 
-    \brief Max value available for code field when using OPCODE. */
-#define HW_MBOX_OPCODE_CODE_MAX_VALUE   (BIT(HW_MBOX_OPCODE_CODE_BITLEN) - 1)
-
-#define HW_MBOX_OPCODE_TAG                0xFF /*! Reserved TAG value for Kernel HW MBOX */
-#define HW_MBOX_OPCODE_USER_SPACE_TAG     0xFE /*! Reserved TAG value for User-Space HW MBOX */
-
-/*! \var typedef enum hwMbox_code hwMbox_code_e
-    \brief This enum denotes codes of internal administrative HW MBOX 
-           commands to be sent on opcode channel.
-*/
-typedef enum hwMbox_code
-{
-    HW_MBOX_CODE_INIT_COMPLETE = 0,    /* init complete code [sent to other Masters by supervisor]. */
-    HW_MBOX_CODE_PING,                 /* ping SW support on other end */
-
-    HW_MBOX_CODE_COUNT    /* Should always be last... */
-} hwMbox_code_e;
-
-/*! \var typedef enum hwMbox_opcodeReturnCode hwMbox_opcodeReturnCode_e
-    \brief This enum denotes return codes of an opcode channel.
-*/
-typedef enum hwMbox_opcodeReturnCode
-{
-    HW_MBOX_OPCODE_RC_OK = 0,
-
-    HW_MBOX_OPCODE_RC_NOT_INITIALIZED_YET = 0x100,
-    HW_MBOX_OPCODE_RC_INVALID_TAG,
-    HW_MBOX_OPCODE_RC_INVALID_CODE,
-    HW_MBOX_OPCODE_RC_CALLBACK_FAILED,
-    HW_MBOX_OPCODE_RC_REPLY_TOO_LONG,
-
-    HW_MBOX_OPCODE_RC_NOK = HW_MBOX_OPCODE_CODE_MAX_VALUE /* this should be last... */
-} hwMbox_opcodeReturnCode_e;
-
-#define HW_MBOX_OPCODE_RECV_COUNT    10 /*! max amount of recv opcode channels per Master. */
-#define HW_MBOX_OPCODE_TAG_COUNT     10 /*! max amount of tags that can be registered per RecvOpcode channel. */
-
-/*! \typedef int (*hwMboxRecvOpcodeCallback)(hw_mbox_Masters_e commander,
-                                             Uint32 code,
-                                             Uint8 *dataBuf, Uint32 dataLen,
-                                             Uint32 *token)
-    \brief prototype for receive opcode channels callback function pointers, to be
-           invoked by Receive Opcode Listeners upon incoming opcode.
-    \param[in]     commander - Master from which the opcode has been received.
-    \param[in]     code - code of the opcode that has been received.
-    \param[in,out] dataBuf - data of the opcode that has been received.
-    \param[in]     dataLen - Length in bytes of <dataBuf>.
-    \param[in,out] token - 32 bit saved in DB upon registering the callback,
-                           modifiable by the callback.
-    \note return value (-1) is reserved to indicate generic error, use token
-          to output an error from <hwMbox_opcodeReturnCode_e>, it will be sent
-          to the commander and the sendOpcode service it invoked will fail.
-*/
-typedef int (*hwMboxRecvOpcodeCallback)(hw_mbox_Masters_e commander,
-                                        Uint32 code,
-                                        Uint8 *dataBuf, Uint32 dataLen,
-                                        Uint32 *token);
-
-/********************************************
-|                                           |
-|        HW_MBOX Channel Definitions        |
-|                                           |
-********************************************/
-
-/*! \var typedef struct hw_mbox_sram hw_mbox_sram_t
-    \brief struct for Channel's SRAM configuration. */
-typedef struct hw_mbox_sram
-{
-    Uint32 start; /* start Offset aligned and relvant to the 4KB of HW_MBOX SRAM */
-    Uint32 size;  /* size is in bytes */
-} hw_mbox_sram_t;
-
-#define HW_MBOX_SRAM_CHUNK    4  /*! Allocated SRAM size must be an integral Multiple of 4B */
-
-/*! \var typedef struct hw_mbox_channelConfig hw_mbox_channelConfig_t
-    \brief struct for Channel's configuration. */
-typedef struct hw_mbox_channelConfig
-{
-    Uint32              cid;
-    hw_mbox_type_e      mboxType;
-    hw_mbox_Masters_e   commander;
-    hw_mbox_Masters_e   subject;
-    hw_mbox_sram_t      memBuff;
-} hw_mbox_channelConfig_t;
-
-/*! \def HW_MBOX_CHANNEL_CONFIG_SIZE 
-    \brief channel configuration struct's size. */
-#define HW_MBOX_CHANNEL_CONFIG_SIZE    sizeof(hw_mbox_channelConfig_t)
-
-/********************************************
-|                                           |
-|        STATIC channel Declarations        |
-|                                           |
-********************************************/
-
-/*! \def HW_MBOX_STATIC_CHANNEL_TABLE
-    \brief X-MACRO hardcoded table for STATIC Channel declarations.
-    \attention SRAM size must be an integral Multiple of HW_MBOX_SRAM_CHUNK = 4B.
-    \attention An event channel must have SRAM allocated to accomdate the event buffer.
-    \attention An event channel SRAM size must be divisible to 2 equal sized valid individual SRAM buffers [for the double buffer] --> meaning it should be an integral multiple of 2 * HW_MBOX_SRAM_CHUNK = 8B.
-*/
-#define HW_MBOX_STATIC_CHANNEL_TABLE(ENTRY) \
-/*       +--------------------------------------------------------------------------------------------------------------------------+ */ \
-/*       |  CID  | Commander                           | Subject                             | HW_MBOX Channel Type     | SRAM size | */ \
-/*       |       | [hw_mbox_Masters_e]                 | [hw_mbox_Masters_e]                 | [hw_mbox_channel_type_e] | [Bytes]   | */ \
-/*       +--------------------------------------------------------------------------------------------------------------------------+ */ \
-    ENTRY(    0  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_command          , 0         )    \
-    ENTRY(    1  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_DS_PHY_CPU           , hw_mbox_command          , 0         )    \
-    ENTRY(    2  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_command          , 0         )    \
-    ENTRY(    3  , HW_MBOX_MASTER_BBU_C                , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
-    ENTRY(    4  , HW_MBOX_MASTER_DS_PHY_CPU           , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
-    ENTRY(    5  , HW_MBOX_MASTER_MOCA_C               , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
-    ENTRY(    6  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_opcode           , 8         )    \
-    ENTRY(    7  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_APP_CPU              , hw_mbox_opcode           , 8         )    \
-    ENTRY(    8  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_DS_PHY_CPU           , hw_mbox_opcode           , 8         )    \
-    ENTRY(    9  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_opcode           , 8         )    \
-    ENTRY(   10  , HW_MBOX_MASTER_APP_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_opcode           , 8         )
-
-/* static channel Table Expanders: */
-
-/*! \def HW_MBOX_STATIC_CHANNEL_TABLE_AS_COUNT( _cid, _commander, _subject, _mboxType, _sramSize )
-    \brief use this as argument to HW_MBOX_STATIC_CHANNEL_TABLE to expand table as entry count. */
-#define HW_MBOX_STATIC_CHANNEL_TABLE_AS_COUNT( _cid, _commander, _subject, _mboxType, _sramSize )    1+
-
-/*! \def HW_MBOX_STATIC_CHANNEL_TABLE_AS_DB(_cid, _commander, _subject, _mboxType, _sramSize)
-    \brief use this as argument to HW_MBOX_STATIC_CHANNEL_TABLE to expand table as DB.
-    \note intializes an array of hw_mbox_channelConfig_t.
-    \attention only create inside c file.
-*/
-#define HW_MBOX_STATIC_CHANNEL_TABLE_AS_DB(_cid, _commander, _subject, _mboxType, _sramSize) \
-{ .cid = _cid, .mboxType = _mboxType, .commander = _commander, .subject = _subject, .memBuff.start = 0 /* To be updated when SRAM is allocated */, .memBuff.size = _sramSize },
-
-/* static channel Table Expander Wrappers: */
-
-/*! \def HW_MBOX_STATIC_CHANNEL_TABLE_DB( _arrayName )
-    \brief Creates a hw_mbox_channelConfig_t array with HW MBOX static channels Data.
-    \note creates and initializes a static hw_mbox_channelConfig_t array with name <_arrayName>.
-    \attention only use inside c file.
-*/
-#define HW_MBOX_STATIC_CHANNEL_TABLE_DB( _arrayName ) \
-    static const hw_mbox_channelConfig_t _arrayName[] =                    \
-    {                                                                      \
-        HW_MBOX_STATIC_CHANNEL_TABLE(HW_MBOX_STATIC_CHANNEL_TABLE_AS_DB)   \
-    }
-
-/*! \def HW_MBOX_STATIC_CHANNEL_COUNT
-    \brief wrapper for HW_MBOX_STATIC_CHANNEL_TABLE_AS_COUNT.
-    \note 1+ 1+ ... [so we need] 0 for syntax.
-*/
-#define HW_MBOX_STATIC_CHANNEL_COUNT    (HW_MBOX_STATIC_CHANNEL_TABLE(HW_MBOX_STATIC_CHANNEL_TABLE_AS_COUNT) 0) /* 1+ ... 1+ [need] 0 for syntax */
-
-/* Basic Sanity Check for static channel Table */
-#if ((HW_MBOX_STATIC_CHANNEL_COUNT) > HW_MBOX_CHANNEL_COUNT)
-#   error "HW_MBOX STATIC CHANNELS: entry count in the table exceeds the total Channel Count!"
-#endif
-
-#endif /* ! _HW_MBOX_DEFS_H_ */
--- a/arch/x86/hw_mailbox/hw_mbox_drv.c
+++ b/arch/x86/hw_mailbox/hw_mbox_drv.c
@@ -55,8 +55,7 @@
 #include <linux/kthread.h>      /* Kernel Threads */
 #include <linux/delay.h>        /* for usleep_range */
 
-#include <linux/netip_subsystem.h>
-#include "hw_mbox_defs.h"        /* HW_MBOX definitions and configuration */
+#include <linux/hw_mbox_defs.h>        /* HW_MBOX definitions and configuration */
 #include "hw_mbox_mem_access.h"  /* HW_MBOX Register and Memory Access    */
 
 #ifdef HW_MBOX_IS_NP_CPU
@@ -64,7 +63,7 @@
 #endif
 
 #ifdef HW_MBOX_IS_APP_CPU
-/* Include file with irq number */ 
+#include <linux/netip_subsystem.h>
 #endif
 
 #ifdef HW_MBOX_IS_APP_CPU
@@ -120,6 +119,7 @@
 
 /*** HW_MBOX driver Macros and Defines:  ***/
 
+#ifdef HW_MBOX_IS_NP_CPU
 /*! \def HW_MBOX_INT_LINE
     \brief irq number of the HW_MBOX. */
 #define HW_MBOX_INT_LINE    AVALANCHE_HW_MBOX_INT
@@ -127,6 +127,12 @@
 /*! \def HW_MBOX_INT_NAME
     \brief irq name of the HW_MBOX. */
 #define HW_MBOX_INT_NAME    "hw_mbox_irq"
+#endif /* HW_MBOX_IS_NP_CPU */
+
+#ifdef HW_MBOX_IS_APP_CPU
+/* define HW_MBOX_BASE as the memory mapped reg base address: */
+#define HW_MBOX_BASE hwMboxDriverData.reg_base
+#endif /* HW_MBOX_IS_APP_CPU */
 
 /*! \def HW_MBOX_ERROR_BIT_POS_SUPERVISOR
     \brief bit position in Interrupt Status H that signals of HW_MBOX access violation Error!
@@ -143,7 +149,7 @@
 /*! \def HW_MBOX_IS_ERROR_BIT_SET_FOR_SUPERVISOR(interruptStatus_H)
     \brief use this as supervisor to find out whether error bit is set on interrupt status high register value.
     \param[in] interruptStatus_H - HW_MBOX_MASTER_INTR_STATUS_H register value that was read.
-    \attention Only use as supervisor! 
+    \attention Only use as supervisor!
 */
 #define HW_MBOX_IS_ERROR_BIT_SET_FOR_SUPERVISOR(interruptStatus_H)      (((interruptStatus_H) & HW_MBOX_ERROR_BIT_FOR_SUPERVISOR) != 0)
 
@@ -153,7 +159,7 @@
 
 /* List HW_MBOX Master names (using the Master Table X-MACRO): */
 
-/*! \var static const char *HW_MBOX_MASTER_STRS[] 
+/*! \var static const char *HW_MBOX_MASTER_STRS[]
     \brief List all HW_MBOX Master names listed by MID: "<_desc>"
     \attention use HW_MBOX_MASTER_GET_NAME() to access.
 */
@@ -225,7 +231,7 @@ do{ \
 #define IS_INITIALIZED()    ( isInitialized == true )
 
 /*! \def CHECK_IS_DRV_INITIALIZED( __noNotInitialized )
-    \brief use to check if the driver is initialized, if it is not 
+    \brief use to check if the driver is initialized, if it is not
            execute __noNotInitialized.
     \param[in] __noNotInitialized - executed in case of driver not
                                     initialized.
@@ -307,27 +313,15 @@ do{ \
 #define CHN_INTR_DEFAULT_TIMEOUT_MSEC   CHN_INTR_NO_TIMEOUT /* no Timeout: Used for debug */
 #endif /* HW_MBOX_DEFAULT_TIMEOUT_SEC */
 
-/*! \var typedef enum chnIntrReturnCodes chnIntrReturnCodes_e
-    \brief return codes for channel interrupts */
-typedef enum chnIntrReturnCodes 
-{
-    CHN_INTR_RC_OK = 0,
-    CHN_INTR_RC_NOK = -1,
-
-    CHN_INTR_RC_INTERRUPTED_BY_SIGNAL = 0x100,
-    CHN_INTR_RC_TIMEOUT_EXPIRED,
-    CHN_INTR_RC_NOT_INITIALIZED_YET
-} chnIntrReturnCodes_e;
-
-/*! \var typedef enum chnIntrState chnIntrState_e
+/*! \enum chnIntrState_e
     \brief Channel Interrupt state. */
-typedef enum chnIntrState 
+typedef enum chnIntrState
 {
     CHN_INTR_STATE_NONE = 0,
     CHN_INTR_STATE_PENDING
 } chnIntrState_e;
 
-/*! \var typedef struct chnIntr chnIntr_t
+/*! \struct chnIntr_t
     \brief Channel Interrupt abstraction. */
 typedef struct chnIntr
 {
@@ -335,9 +329,9 @@ typedef struct chnIntr
     chnIntrState_e          state;     /* indicates channel interrupt state */
 } chnIntr_t;
 
-/*! \var typedef struct chnint chnint_t
+/*! \struct chnint_t
     \brief Channel Interrupt Device structure. */
-typedef struct chnint 
+typedef struct chnint
 {
     Uint32              chn_cid;      /* CID of the channel this device is connected to */
     struct cdev         chnint_cdev;  /* channel's char device structure */
@@ -348,12 +342,12 @@ typedef struct chnint
 #define RECV_OPCODE_LISTENER_PREFIX    "hwMboxKRecvOp" /*! thread name prefix */
 
 /*! \def RECV_OPCODE_INIT_INDEX
-    \brief on non-supervisor the first opcode listener is used to continue the 
+    \brief on non-supervisor the first opcode listener is used to continue the
            driver initialization process.
 */
 #define RECV_OPCODE_INIT_INDEX      0
 
-/*! \var typedef struct recvOpcodeListenerThreadData recvOpcodeListenerThreadData_t
+/*! \struct recvOpcodeListenerThreadData_t
     \brief data relevant to the recieve opcode listener. */
 typedef struct recvOpcodeListenerThreadData
 {
@@ -361,7 +355,7 @@ typedef struct recvOpcodeListenerThreadD
     Uint32 cid;
 } recvOpcodeListenerThreadData_t;
 
-/*! \var typedef struct recvOpcodeRegisteredTag recvOpcodeRegisteredTag_t
+/*! \struct recvOpcodeRegisteredTag_t
     \brief A single entry registered by application. */
 typedef struct recvOpcodeRegisteredTag
 {
@@ -373,7 +367,7 @@ typedef struct recvOpcodeRegisteredTag
     Uint32                  opcodeCount; /* counts opcodes that arrived with this tag */
 } recvOpcodeRegisteredTag_t;
 
-/*! \var typedef struct recvOpcodeInfrastructure recvOpcodeInfrastructure_t
+/*! \struct recvOpcodeInfrastructure_t
     \brief required infrastructure for receive opcode channels. */
 typedef struct recvOpcodeInfrastructure
 {
@@ -389,7 +383,7 @@ typedef struct recvOpcodeInfrastructure
     Uint32 invalidTagCount; /* counts opcodes that arrived with an invlaid tag */
 } recvOpcodeInfrastructure_t;
 
-/*! \var typedef struct statistics statistics_t
+/*! \struct statistics_t
     \brief HW MBOX statistics. */
 typedef struct hwMbox_statistics
 {
@@ -398,7 +392,7 @@ typedef struct hwMbox_statistics
        Note: Sizing and dimensions are the same as CID LUT.
     */
     Uint32 serviceCounters[HW_MBOX_MASTER_COUNT][HW_MBOX_TYPE_COUNT << 1];
-} hwMbox_statistics_t; 
+} hwMbox_statistics_t;
 
 /************************************************************************/
 /*     HW_MBOX Kernel Local Declarations                                */
@@ -407,7 +401,7 @@ typedef struct hwMbox_statistics
 static int hwMbox_initAfterStarted(void);
 static int hwMbox_setChannelConfig(hw_mbox_channelConfig_t config);
 static int hwMbox_setChannelValid(Uint32 paramCID, Bool isValid);
-static int hwMbox_waitForChannelInterrupt(int cid, int timeoutInMsec);
+static int hwMbox_waitForChannelInterrupt(int cid, int timeoutInMsec, HW_MBOX_STATUS_e *pHwMboxStatus);
 
 static int hwMbox_recvOpcodeListenerEntry(void *data);
 
@@ -415,7 +409,7 @@ static int hwMbox_recvOpcodeListenerEntr
 /*     HW_MBOX driver data                                              */
 /************************************************************************/
 
-/*! \var typedef struct ctrlDb ctrlDb_t
+/*! \struct ctrlDb_t
     \brief holds general control information. */
 typedef struct ctrlDbEntry
 {
@@ -430,7 +424,7 @@ typedef struct ctrlDbEntry
     Bool isLocked;      /* is Locked? (once set configuration is fixed, value cannot be changed once set) */
 } ctrlDbEntry_t;
 
-/*! \var typedef struct masterDbEntry masterDbEntry_t
+/*! \struct masterDbEntry_t
     \brief a single Master entry in driver DB. */
 typedef struct masterDbEntry
 {
@@ -440,9 +434,9 @@ typedef struct masterDbEntry
     hw_mbox_masterConfig_t config; /* Master's configuration */
 
     Uint32 errorCount;  /* only relevant for supervisor [currently only incremented in User-Space] */
-} masterDbEntry_t; 
+} masterDbEntry_t;
 
-/*! \var typedef struct chnDbEntry chnDbEntry_t
+/*! \struct chnDbEntry_t
     \brief a single channel entry in driver DB. */
 typedef struct chnDbEntry
 {
@@ -454,13 +448,13 @@ typedef struct chnDbEntry
 
     Uint32      intrCount;       /* count channel interrupts */
     Uint32      recvOpcodeIndex; /* indicates relevant entry in recvOpData [only relevant for recvOpcode] */
-} chnDbEntry_t; 
+} chnDbEntry_t;
 
-/*! \def CHN_DB_ENTRY_SIZE 
+/*! \def CHN_DB_ENTRY_SIZE
     \brief Channel entry struct's size in driver DB. */
 #define CHN_DB_ENTRY_SIZE    sizeof(chnDbEntry_t)
 
-/*! \var typedef struct hw_mbox_drv_data hw_mbox_drv_data_t 
+/*! \struct hw_mbox_drv_data_t
     \brief struct for HW_MBOX driver Local Data. */
 typedef struct hw_mbox_drv_data
 {
@@ -476,10 +470,13 @@ typedef struct hw_mbox_drv_data
     /* Statistics: */
     Uint32 errIntr;     /* incremented only for supervisor */
     Uint32 ghostIntr;   /* incremented if there's an interrupt but no set bits in Interrupt Status Registers */
-    void __iomem *reg_base; /* Mapped io reg base address */ 
+
+#ifdef HW_MBOX_IS_APP_CPU
+    void __iomem *reg_base; /* Mapped io reg base address */
+#endif
 } hw_mbox_drv_data_t;
 
-/*! \def HW_MBOX_DRIVER_DATA_SIZE 
+/*! \def HW_MBOX_DRIVER_DATA_SIZE
     \brief HW_MBOX driver Data struct's size. */
 #define HW_MBOX_DRIVER_DATA_SIZE    sizeof(hw_mbox_drv_data_t)
 
@@ -650,7 +647,7 @@ static struct file_operations chnint_fop
 
 /* Defines and Structs: */
 
-typedef struct seq_proc_if_control_data 
+typedef struct seq_proc_if_control_data
 {
     Bool endOfData;    /* if True then there's no more data left and proc should end */
 } seq_proc_if_control_data_t;
@@ -815,7 +812,7 @@ SEQ_PROC_DEFINE_STOP(procName);
     \brief macro that will define a simple generic seq proc template, where no more than one page is needed.
     \param[in] procName - name designation of the seq proc, to be used as prefix to all the needed functions and also the name of the actual proc function.
     \attention user should define the proc function with prototype/name: static int <procName>(struct seq_file *m, void *v)
-    \attention This should be used over SEQ_PROC_DEFINE for short procs that surely will not exceed a page. 
+    \attention This should be used over SEQ_PROC_DEFINE for short procs that surely will not exceed a page.
     \note <procName> can be different then the actual file name that will be used for the proc [see SEQ_PROC_CREATE].
 */
 #define SEQ_PROC_DEFINE_SIMPLE(procName) \
@@ -873,7 +870,7 @@ volatile Uint32 __debug_HW_MBOX_MID = HW
 
 /*! \var static Uint32 __currentNonallocatedSramOffset
     \brief keeps track of offset of currently allocated SRAM.
-    \warning Do not modify directly use the Macros!  
+    \warning Do not modify directly use the Macros!
 */
 static Uint32 __currentNonallocatedSramOffset = 0;
 
@@ -902,14 +899,14 @@ static struct semaphore chnLocks[HW_MBOX
 static Uint32 cidLUT[HW_MBOX_MASTER_COUNT][HW_MBOX_TYPE_COUNT << 1];
 
 /* This LUT allows to find the correct CID for each peer according to type.
-   It is required because the channels are an internal entity and only have 
+   It is required because the channels are an internal entity and only have
    meaning inside the HW MBOX package code. Outside users invoke services
    specifying a destination peer (Commander/Subject).
 
    Table should be accessed using FIND_CID_IN_LUT/SET_CID_IN_LUT Macros.
 
    First dimension is the destination peer (indexed by MID).
-   Second dimension is the required channel type (implicitly specified 
+   Second dimension is the required channel type (implicitly specified
    according to service that was invoked).
 
    Please note: second dimension size is HW_MBOX_TYPE_COUNT << 1 ( * 2 )
@@ -936,15 +933,18 @@ do{ \
     ( _paramCID ) = FIND_CID_IN_LUT(_peer, _type, _isPeerCommander);           \
     if (( _paramCID ) == HW_MBOX_CID_INVALID)                                  \
     {                                                                          \
-        PRINTK_ERR("There's no %s channel configured with %s(%d) as %s...",    \
-                   HW_MBOX_TYPE_STR( _type ),                                  \
-                   HW_MBOX_MASTER_GET_NAME( _peer ), ( _peer ),                \
-                   (( _isPeerCommander )?("commander"):("subject")));          \
+        DPRINTK("There's no %s channel configured with %s(%d) as %s...",       \
+                HW_MBOX_TYPE_STR( _type ),                                     \
+                HW_MBOX_MASTER_GET_NAME( _peer ), ( _peer ),                   \
+                (( _isPeerCommander )?("commander"):("subject")));             \
         __onNotFound;                                                          \
     }                                                                          \
     DPRINTK("found correct cid, using cid %d", _paramCID);                     \
 } while (0)
 
+#define CID_LUT_PEER_IS_COMMANDER   ( True )
+#define CID_LUT_PEER_IS_SUBJECT     ( False )
+
 /*! \var static recvOpcodeListenerThreadData_t recvOpThreadsData[]
     \brief data of the receive opcode listeners.
 */
@@ -1044,7 +1044,7 @@ static hwMbox_statistics_t stats;
 
 /*** High Level Function Helpers ***/
 
-/*! \def WAIT_FOR_CHN_INTR( _cid, _timeOutInMsec) 
+/*! \def WAIT_FOR_CHN_INTR( _cid, _timeOutInMsec)
     \brief invokes waitForChannelInterrupt function.
     \attention releases channel lock on error.
     \note assumes int calling function.
@@ -1053,38 +1053,34 @@ static hwMbox_statistics_t stats;
 */
 #define WAIT_FOR_CHN_INTR( _cid, _timeOutInMsec ) \
 do{ \
-    chnIntrReturnCodes_e chnIntrRc;                                                                    \
-    if ((chnIntrRc = hwMbox_waitForChannelInterrupt( ( _cid ), ( _timeOutInMsec ))) != CHN_INTR_RC_OK) \
-    {                                                                                                  \
+    HW_MBOX_STATUS_e hwMboxStatus;                                                      \
+    if (hwMbox_waitForChannelInterrupt( ( _cid ), ( _timeOutInMsec ), &hwMboxStatus))   \
+    {                                                                                   \
         /* release Lock... */                                                       \
         up(&CHN_LOCK( ( _cid )));                                                   \
-        if (chnIntrRc == CHN_INTR_RC_INTERRUPTED_BY_SIGNAL)                         \
+        if (hwMboxStatus == HW_MBOX_STATUS_INTERRUPTED_BY_SIGNAL)                   \
         {                                                                           \
             DPRINTK("cid %d: wait interrupted by signal!", ( _cid ));               \
             return -ERESTARTSYS;                                                    \
         }                                                                           \
-        else if (chnIntrRc == CHN_INTR_RC_TIMEOUT_EXPIRED)                          \
+        else if (hwMboxStatus == HW_MBOX_STATUS_ERROR_TIMEOUT_EXPIRED)              \
         {                                                                           \
             /* TBD: what to do in this case... */                                   \
             PRINTK_ERR("cid %d: timeout expired!", ( _cid ));                       \
             return (-1);                                                            \
         }                                                                           \
-        else                                                                        \
-        {                                                                           \
-            PRINTK_ERR("cid %d: unknown chnIntrRc (%d)!", ( _cid ), chnIntrRc);     \
-            return (-1);                                                            \
-        }                                                                           \
     }                                                                               \
 } while (0)
 
 /************************************************************************/
 /*     HW_MBOX Kernel INTERFACE FUNCTIONS Implementation:               */
 /************************************************************************/
+
 /**************************************************************************/
 /*! \fn int hwMbox_isReady(void)
  **************************************************************************
  *  \brief Returns whether HW MBOX driver is initailized or not.
- *  \return [ 0 on success / error -1 ].
+ *  \return [ 0 on initialized / -1 on NOT initialized ].
  **************************************************************************/
 int hwMbox_isReady(void)
 {
@@ -1092,18 +1088,19 @@ int hwMbox_isReady(void)
     return 0;
 }
 EXPORT_SYMBOL(hwMbox_isReady);
+
 /**************************************************************************/
 /*! \fn int hwMbox_sendCommand(hw_mbox_Masters_e subject,
-                       Uint32 *cmd,
-                       Uint8 *dataBuf, Uint32 dataLen)
+                               Uint32 *cmd,
+                               Uint8 *dataBuf, Uint32 dataLen)
  **************************************************************************
  *  \brief Send a command to <subject> in a blocking manner using the HW_MBOX.
  *  \attention will only return upon reply/ACK from <subject> (or error).
  *  \param[in]     subject - To which Master should the opcode be sent.
  *  \param[in,out] cmd - Command to send, upon returning will hold the reply.
- *  \param[in,out] dataBuf - pointer to a Buffer containing more data to be 
+ *  \param[in,out] dataBuf - pointer to a Buffer containing more data to be
  *                           sent, upon returning will hold the reply data
- *                           Buffer (copies as much as the buffer can hold). 
+ *                           Buffer (copies as much as the buffer can hold).
  *  \param[in]     dataLen - Length in Bytes of buffer specified in <dataBuf>.
  *  \return [ 0 on success / error otherwise ].
  **************************************************************************/
@@ -1125,7 +1122,14 @@ int hwMbox_sendCommand(hw_mbox_Masters_e
             HW_MBOX_MASTER_GET_NAME(subject), subject,
             *cmd, dataLen);
 
-    CHECK_FIND_CID_IN_LUT(subject, hw_mbox_command, False, return (-1), paramCID);
+    CHECK_FIND_CID_IN_LUT(subject, hw_mbox_command, CID_LUT_PEER_IS_SUBJECT, return (-1), paramCID);
+
+    if (!IS_MASTER_INIT(subject))
+    {
+        DPRINTK("send Command to %s(%d) - subject not initialized!",
+                HW_MBOX_MASTER_GET_NAME(subject), subject);
+        return (-1);
+    }
 
     /* seize channel lock */
     if (down_interruptible(&CHN_LOCK(paramCID)))
@@ -1199,7 +1203,7 @@ EXPORT_SYMBOL(hwMbox_sendCommand);
                                Uint8 *dataBuf, Uint32 dataLen)
  **************************************************************************
  *  \brief Receive a command from <commander> using the HW_MBOX.
- *  \attention will only return upon arrival of a command from <commander> 
+ *  \attention will only return upon arrival of a command from <commander>
  *             (or error).
  *  \note To reply call HW_MBOX_sendReply [if a meaningful response is expected].
  *  \note To ACK call HW_MBOX_sendAck [to simply ACK the command].
@@ -1228,7 +1232,7 @@ int hwMbox_recvCommand(hw_mbox_Masters_e
     DPRINTK("receive Command from %s(%d) [incoming data buffer size %uB]",
             HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen);
 
-    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_command, True, return (-1), paramCID);
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_command, CID_LUT_PEER_IS_COMMANDER, return (-1), paramCID);
 
     if (dataBuf != NULL)
     {
@@ -1242,7 +1246,7 @@ int hwMbox_recvCommand(hw_mbox_Masters_e
         }
     }
 
-    /* seize channel lock 
+    /* seize channel lock
        [handle possible simultaneous access from both User-Space and Kernel] */
     if (down_interruptible(&CHN_LOCK(paramCID)))
     {
@@ -1320,9 +1324,9 @@ int hwMbox_sendReplyCommand(hw_mbox_Mast
             HW_MBOX_MASTER_GET_NAME(commander), commander,
             reply, dataLen);
 
-    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_command, True, return (-1), paramCID);
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_command, CID_LUT_PEER_IS_COMMANDER, return (-1), paramCID);
 
-    /* seize channel lock 
+    /* seize channel lock
        [handle possible simultaneous access from both User-Space and Kernel] */
     if (down_interruptible(&CHN_LOCK(paramCID)))
     {
@@ -1355,7 +1359,7 @@ int hwMbox_sendReplyCommand(hw_mbox_Mast
     }
 
     /* Send Reply to commander: */
-    DPRINTK("send Reply Command to %s(%d) - sending reply to commander!", 
+    DPRINTK("send Reply Command to %s(%d) - sending reply to commander!",
             HW_MBOX_MASTER_GET_NAME(commander), commander);
 
     DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
@@ -1392,9 +1396,9 @@ int hwMbox_sendAckCommand(hw_mbox_Master
 
     DPRINTK("send ACK Command to %s(%d)", HW_MBOX_MASTER_GET_NAME(commander), commander);
 
-    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_command, True, return (-1), paramCID);
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_command, CID_LUT_PEER_IS_COMMANDER, return (-1), paramCID);
 
-    /* seize channel lock 
+    /* seize channel lock
        [handle possible simultaneous access from both User-Space and Kernel] */
     if (down_interruptible(&CHN_LOCK(paramCID)))
     {
@@ -1402,7 +1406,7 @@ int hwMbox_sendAckCommand(hw_mbox_Master
         return -ERESTARTSYS;
     }
 
-    /* write the current command (command that was sent), 
+    /* write the current command (command that was sent),
        to better assist the HW_MBOX Monitor... */
 
     currCmdRegVal = HW_MBOX_CHN_COMMAND_REG_GET(paramCID);
@@ -1426,44 +1430,43 @@ EXPORT_SYMBOL(hwMbox_sendAckCommand);
 /**************************************************************************/
 /*! \fn int hwMbox_sendOpcode(hw_mbox_Masters_e subject,
                               Uint32 tag,
-                              Uint32 *code,
                               Uint8 *dataBuf, Uint32 *dataLen,
                               Uint32 opcodeDataLen,
                               Uint32 *replyDataLen)
  **************************************************************************
  *  \brief Send an opcode to <subject> in a blocking manner using the HW_MBOX.
  *  \attention will only return upon reply from <subject> (or error).
+ *  \attention specified buffer should be able to hold generic messages that
+ *             sent on opcode channels, meaning size should be at least
+ *             HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES.
  *  \param[in]     subject - To which Master should the opcode be sent.
  *  \param[in]     tag - indicates opcode destination.
- *  \param[in,out] code - code to send, upon returning will hold the return
- *                        code.
- *                  NOTE: if generic error upon returning will hold the error
- *                        code <hwMbox_opcodeReturnCode_e>.
- *  \param[in,out] dataBuf - pointer to a Buffer containing more data to be sent,
+ *  \param[in,out] dataBuf - pointer to a Buffer containing opcode data to be sent,
  *                           upon returning will hold the reply data Buffer.
  *  \param[in]     dataLen - Length in Bytes of buffer specified in <dataBuf>.
  *  \param[in]     opcodeDataLen - Length in Bytes of opcode data to send.
  *  \param[out]    replyDataLen - upon returning will hold the length in Bytes
  *                                of returned reply data.
+ *  \note if function returns -1, and replyDataLen outputs > 0 value then
+ *        the user supplied buffer is populated with a <hwMbox_opcodeMessage_t>
+ *        of type HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS containing extended error
+ *        information.
  *  \return [ 0 on success / error otherwise ].
  **************************************************************************/
 int hwMbox_sendOpcode(hw_mbox_Masters_e subject,
                       Uint32 tag,
-                      Uint32 *code,
                       Uint8 *dataBuf, Uint32 dataLen,
                       Uint32 opcodeDataLen,
                       Uint32 *replyDataLen)
 {
-    Uint32 paramCID, cmdRegVal, tagMaxVal, codeMaxVal;
+    Uint32 paramCID, cmdRegVal, tagMaxVal;
     hwMbox_opcode_t opFlds = { 0 };
+    hwMbox_opcodeMessage_t *pOpcodeMsg;
 
-    CHECK_IS_DRV_INITIALIZED(return (-1));
+    /* Initialize with default output value: */
+    *replyDataLen = 0;
 
-    if (code == NULL)
-    {
-        PRINTK_ERR("code == NULL!");
-        return (-1);
-    }
+    CHECK_IS_DRV_INITIALIZED(return (-1));
 
     if (replyDataLen == NULL)
     {
@@ -1471,11 +1474,18 @@ int hwMbox_sendOpcode(hw_mbox_Masters_e
         return (-1);
     }
 
-    DPRINTK("send Opcode to %s(%d) [tag %u code 0x%x (%u) with %uB of data]",
+    DPRINTK("send Opcode to %s(%d) [tag %u with %uB of data]",
             HW_MBOX_MASTER_GET_NAME(subject), subject,
-            tag, *code, *code, opcodeDataLen);
+            tag, opcodeDataLen);
+
+    CHECK_FIND_CID_IN_LUT(subject, hw_mbox_opcode, CID_LUT_PEER_IS_SUBJECT, return (-1), paramCID);
 
-    CHECK_FIND_CID_IN_LUT(subject, hw_mbox_opcode, False, return (-1), paramCID);
+    if (!IS_MASTER_INIT(subject))
+    {
+        DPRINTK("send Opcode to %s(%d) - subject not initialized!",
+                HW_MBOX_MASTER_GET_NAME(subject), subject);
+        return (-1);
+    }
 
     DPRINTK("cid %d: size of buffer %uB", paramCID, dataLen);
 
@@ -1485,61 +1495,57 @@ int hwMbox_sendOpcode(hw_mbox_Masters_e
         PRINTK_ERR("send Opcode to %s(%d) - tag value (%u) > max possible value (%u)!",
                    HW_MBOX_MASTER_GET_NAME(subject), subject,
                    tag, tagMaxVal);
-
         return (-1);
     }
 
-    codeMaxVal = HW_MBOX_OPCODE_CODE_MAX_VALUE;
-    if (*code > codeMaxVal)
+#ifdef HW_MBOX_KDBG
+    if (tag >= HW_MBOX_OPCODE_RESERVED_TAGS_START)
     {
-        PRINTK_ERR("send Opcode to %s(%d) - code value 0x%x (%u) > max possible value 0x%x (%u)!",
-                   HW_MBOX_MASTER_GET_NAME(subject), subject,
-                   *code, *code, codeMaxVal, codeMaxVal);
+        DPRINTK("cid %d: NOTICE - using reserved HW_MBOX opcode tag %u", paramCID, tag);
+    }
+#endif  /* HW_MBOX_KDBG */
 
+    if ((dataBuf == NULL) || (dataLen == 0))
+    {
+        /* No Buffer specified! */
+        PRINTK_ERR("send Opcode to %s(%d) - No Buffer specified! [dataBuf %p, dataLen %uB]",
+                   HW_MBOX_MASTER_GET_NAME(subject), subject, dataBuf, dataLen);
         return (-1);
     }
 
-    if ((tag == HW_MBOX_OPCODE_TAG) || (tag == HW_MBOX_OPCODE_USER_SPACE_TAG))
+    if (dataLen < HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES)
     {
-        DPRINTK("cid %d: NOTICE - using reserved HW_MBOX opcode tag %u", paramCID, tag);
+        /* Insufficient Size Buffer specified! */
+        PRINTK_ERR("send Opcode to %s(%d) - Insufficient Size Buffer specified! [dataLen %uB, minimal size is %dB]",
+                   HW_MBOX_MASTER_GET_NAME(subject), subject,
+                   dataLen, HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES);
+        return (-1);
     }
 
-    if (dataBuf != NULL)
+    if (opcodeDataLen == 0)
     {
-        /* Buffer specified! */
-
-        if (opcodeDataLen > dataLen)
-        {
-            /* Opcode data longer than specified buffer... */
-            PRINTK_ERR("send Opcode to %s(%d) - opcode data length (%uB) > specified buffer size (%uB)!",
-                       HW_MBOX_MASTER_GET_NAME(subject), subject,
-                       opcodeDataLen, dataLen);
-
-            return (-1);
-        }
-
-        if ((opcodeDataLen % 4) != 0)
-        {
-            /* Opcode data is always a multiple of 4 Bytes! */
-            PRINTK_ERR("send Opcode to %s(%d) - opcode data length (%uB) must be a multiple of 4!",
-                       HW_MBOX_MASTER_GET_NAME(subject), subject, opcodeDataLen);
-
-            return (-1);
-        }
+        /* No Data specified! */
+        PRINTK_ERR("send Opcode to %s(%d) - No Data specified! [opcodeDataLen %uB]",
+                   HW_MBOX_MASTER_GET_NAME(subject), subject, opcodeDataLen);
+        return (-1);
     }
 
-    opFlds.tag = tag;
-    opFlds.code = *code;
-
-    /* Flags are currently reserved! */
-    opFlds.flagA = 0;
-    opFlds.flagB = 0;
-
-    opFlds.lenInBytes = opcodeDataLen;
+    if (opcodeDataLen > dataLen)
+    {
+        /* Opcode data longer than specified buffer... */
+        PRINTK_ERR("send Opcode to %s(%d) - opcode data length (%uB) > specified buffer size (%uB)!",
+                   HW_MBOX_MASTER_GET_NAME(subject), subject,
+                   opcodeDataLen, dataLen);
+        return (-1);
+    }
 
-    DPRINTK("cid %d: opcode fields: tag=%u, code=%u=0x%x, A=%d, B=%d, lenInBytes=%u",
-            paramCID, opFlds.tag, opFlds.code, opFlds.code,
-            opFlds.flagA, opFlds.flagB, opFlds.lenInBytes);
+    if ((opcodeDataLen % 4) != 0)
+    {
+        /* Opcode data is always a multiple of 4 Bytes! */
+        PRINTK_ERR("send Opcode to %s(%d) - opcode data length (%uB) must be a multiple of 4B!",
+                   HW_MBOX_MASTER_GET_NAME(subject), subject, opcodeDataLen);
+        return (-1);
+    }
 
     /* seize channel lock */
     if (down_interruptible(&CHN_LOCK(paramCID)))
@@ -1548,34 +1554,39 @@ int hwMbox_sendOpcode(hw_mbox_Masters_e
         return -ERESTARTSYS;
     }
 
-    if ((dataBuf != NULL) && (opcodeDataLen > 0))
+    /* Save Opcode data to SRAM: */
+
+    /* verify SRAM size: */
+    if (opcodeDataLen > CHN_CFG_MEMBUFF_GET_SIZE(paramCID))
     {
-        /* opcode has data! save to SRAM: */
+        PRINTK_ERR("send Opcode to %s(%d) - opcode data length (%uB) > SRAM allocated to channel (%uB)!",
+                   HW_MBOX_MASTER_GET_NAME(subject), subject, opcodeDataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID));
 
-        /* verify SRAM size: */
-        if (opcodeDataLen > CHN_CFG_MEMBUFF_GET_SIZE(paramCID))
-        {
-            PRINTK_ERR("send Opcode to %s(%d) - opcode data length (%uB) > SRAM allocated to channel (%uB)!",
-                       HW_MBOX_MASTER_GET_NAME(subject), subject, opcodeDataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID));
+        /* release Lock... */
+        up(&CHN_LOCK(paramCID));
+        return (-1);
+    }
 
-            /* release Lock... */
-            up(&CHN_LOCK(paramCID));
-            return (-1);
-        }
+    DPRINTK("send Opcode to %s(%d) - copying %uB of opcode data to SRAM",
+            HW_MBOX_MASTER_GET_NAME(subject), subject, opcodeDataLen);
 
-        DPRINTK("send Opcode to %s(%d) - copying %uB of opcode data to SRAM",
-                HW_MBOX_MASTER_GET_NAME(subject), subject, opcodeDataLen);
+    DPRINTK("cid %d: copying %uB [out of total %uB channel has] to SRAM at offset=0x%08x",
+            paramCID, opcodeDataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
 
-        DPRINTK("cid %d: copying %uB [out of total %uB channel has] to SRAM at offset=0x%08x",
-                paramCID, opcodeDataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+    HW_MBOX_COPY_TO_SRAM(dataBuf, opcodeDataLen, CHN_CFG_MEMBUFF_GET_START(paramCID));
 
-        HW_MBOX_COPY_TO_SRAM(dataBuf, opcodeDataLen, CHN_CFG_MEMBUFF_GET_START(paramCID));
-    }
+    /* Build the opcode: */
+    opFlds.tag = tag;
+    opFlds.lenInBytes = opcodeDataLen;
 
-    /* Send Opcode to subject: */
-    cmdRegVal = 0;
+    /* Create the opcode value: */
     HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT(cmdRegVal, &opFlds);
 
+    DPRINTK("cid %d: opcode fields: tag=%u, lenInBytes=%u -> cmdRegVal=0x%08x",
+            paramCID, opFlds.tag, opFlds.lenInBytes, cmdRegVal);
+
+    /* Send Opcode to subject: */
+
     DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
     DPRINTK("cid %d: writing 0x%08x to the command register of the channel...", paramCID, cmdRegVal);
     HW_MBOX_CHN_COMMAND_REG_SET(paramCID, cmdRegVal);
@@ -1585,42 +1596,33 @@ int hwMbox_sendOpcode(hw_mbox_Masters_e
 
     DPRINTK("cid %d: Reply from subject!", paramCID);
 
-    /* get the Reply: */
+    /* Get the opcode reply value: */
     cmdRegVal = HW_MBOX_CHN_COMMAND_REG_GET(paramCID);
 
-    DPRINTK("cid %d: subject's opcode reply=0x%08x!", paramCID, cmdRegVal);
-
     /* parse to opcode fields: */
     HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT(cmdRegVal, &opFlds);
 
-    DPRINTK("cid %d: opcode fields: tag=%u, code=%u=0x%x, A=%d, B=%d, lenInBytes=%u",
-            paramCID, opFlds.tag, opFlds.code, opFlds.code,
-            opFlds.flagA, opFlds.flagB, opFlds.lenInBytes);
+    DPRINTK("cid %d: cmdRegVal=0x%08x -> opcode fields: tag=%u, lenInBytes=%u",
+            paramCID, cmdRegVal, opFlds.tag, opFlds.lenInBytes);
 
     if (opFlds.lenInBytes > 0)
     {
         /* Reply has data! */
 
-        if (dataBuf == NULL)
-        {
-            /* No specified Buffer... */
-            PRINTK_ERR("send Opcode to %s(%d) - opcode reply has data (%uB) but NO specified buffer!",
-                       HW_MBOX_MASTER_GET_NAME(subject), subject, opFlds.lenInBytes);
-
-            *code = HW_MBOX_OPCODE_RC_REPLY_TOO_LONG;
-
-            /* release Lock... */
-            up(&CHN_LOCK(paramCID));
-            return (-1);
-        }
-
         if (opFlds.lenInBytes > dataLen)
         {
             /* Opcode reply data longer than specified buffer... */
             PRINTK_ERR("send Opcode to %s(%d) - opcode reply data length (%uB) > specified buffer size (%uB)!",
                        HW_MBOX_MASTER_GET_NAME(subject), subject, opFlds.lenInBytes, dataLen);
 
-            *code = HW_MBOX_OPCODE_RC_REPLY_TOO_LONG;
+            /* Output status messge in User Buffer: */
+            pOpcodeMsg = (hwMbox_opcodeMessage_t *)dataBuf;
+
+            pOpcodeMsg->msgType = HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS;
+            pOpcodeMsg->msgData.msgStatus.status = HW_MBOX_STATUS_OPCODE_ERROR_MESSAGE_TOO_LONG;
+
+            /* Set the correct size: */
+            *replyDataLen = HW_MBOX_OPCODE_MESSAGE_SIZE;
 
             /* release Lock... */
             up(&CHN_LOCK(paramCID));
@@ -1631,7 +1633,7 @@ int hwMbox_sendOpcode(hw_mbox_Masters_e
         DPRINTK("send Opcode to %s(%d) - copying %uB of reply opcode data from SRAM",
                 HW_MBOX_MASTER_GET_NAME(subject), subject, opFlds.lenInBytes);
 
-        DPRINTK("cid %d: copying %uB [out of total %uB channel has] from offset 0x%08x",
+        DPRINTK("cid %d: copying %uB [out of total %uB channel has] from SRAM at offset 0x%08x",
                 paramCID, opFlds.lenInBytes, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
 
         HW_MBOX_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID), opFlds.lenInBytes, dataBuf);
@@ -1643,30 +1645,91 @@ int hwMbox_sendOpcode(hw_mbox_Masters_e
     /* check for internal replies: */
     if (opFlds.tag == HW_MBOX_OPCODE_TAG)
     {
-        /* 2 possible options here:
+        /* 3 possible options here:
              1. this was a HW MBOX sendOp.
-             2. this was not a HW MBOX sendOp but it failed and the code is the generic RC.
+             2. this was not a HW MBOX sendOpcode but it failed and the
+                data returned is a Status Message with the error code.
+             3. this was not a HW MBOX sendOpcode and subject used
+                sendAckOpcode to simply ACK the sent opcode.
         */
 
-        if (opFlds.code != HW_MBOX_OPCODE_RC_OK)
+        /* Either way we should check for a status message: */
+        if (*replyDataLen != HW_MBOX_OPCODE_MESSAGE_SIZE)
         {
-            DPRINTK("cid %d: subject replied with internal error! rc = 0x%08x (%u)",
-                    paramCID, opFlds.code, opFlds.code);
+            PRINTK_ERR("send Opcode to %s(%d) - invalid message for tag %u [got size %uB, excpected size %uB]!",
+                       HW_MBOX_MASTER_GET_NAME(subject), subject,
+                       HW_MBOX_OPCODE_TAG, *replyDataLen, HW_MBOX_OPCODE_MESSAGE_SIZE);
+
+            /* Output status messge in User Buffer: */
+            pOpcodeMsg = (hwMbox_opcodeMessage_t *)dataBuf;
+
+            /* Change to correct Opcode message to output to User: */
+            pOpcodeMsg->msgType = HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS;
+            pOpcodeMsg->msgData.msgStatus.status = HW_MBOX_STATUS_OPCODE_ERROR_INVALID_MESSAGE;
 
-            /* Put error <hwMbox_opcodeReturnCode_e> in code field: */
-            *code = opFlds.code;
+            /* Set the correct size: */
+            *replyDataLen = HW_MBOX_OPCODE_MESSAGE_SIZE;
 
             /* release Lock... */
             up(&CHN_LOCK(paramCID));
             return (-1);
         }
-    }
 
-    /* output received code value: */
-    *code = opFlds.code;
+        /* Opcode message was sent: */
+        pOpcodeMsg = (hwMbox_opcodeMessage_t *)dataBuf;
+
+        DPRINTK("cid %d: received HW_MBOX_OPCODE_MESSAGE - msgType %d",
+                paramCID, pOpcodeMsg->msgType);
+
+        if (pOpcodeMsg->msgType != HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS)
+        {
+            PRINTK_ERR("send Opcode to %s(%d) - unexpected message type for tag %u at this point [got type %d, excpected type %d]!",
+                       HW_MBOX_MASTER_GET_NAME(subject), subject,
+                       HW_MBOX_OPCODE_TAG, pOpcodeMsg->msgType, HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS);
+
+            /* Change to correct Opcode message to output to User: */
+            pOpcodeMsg->msgType = HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS;
+            pOpcodeMsg->msgData.msgStatus.status = HW_MBOX_STATUS_OPCODE_ERROR_ILLEGAL_MESSAGE;
+
+            /* release Lock... */
+            up(&CHN_LOCK(paramCID));
+            return (-1);
+        }
+        else
+        {
+            /* Opcode Reply Message of type STATUS: */
+
+            DPRINTK("cid %d: received HW_MBOX_OPCODE_MESSAGE of type STATUS(%d) - STATUS = 0x%x (%u)",
+                    paramCID, pOpcodeMsg->msgType,
+                    pOpcodeMsg->msgData.msgStatus.status, pOpcodeMsg->msgData.msgStatus.status);
+
+            /* Check the returned STATUS value: */
+            if (pOpcodeMsg->msgData.msgStatus.status != HW_MBOX_STATUS_OK)
+            {
+                /* Internal Error! */
+                PRINTK_ERR("send Opcode to %s(%d) - subject replied with internal error! STATUS = 0x%x (%u)",
+                           HW_MBOX_MASTER_GET_NAME(subject), subject,
+                           pOpcodeMsg->msgData.msgStatus.status, pOpcodeMsg->msgData.msgStatus.status);
+
+                /* release Lock... */
+                up(&CHN_LOCK(paramCID));
+                return (-1);
+            }
+            else
+            {
+                DPRINTK("send Opcode to %s(%d) - subject replied with ACK!",
+                        HW_MBOX_MASTER_GET_NAME(subject), subject);
 
-    DPRINTK("send Opcode to %s(%d) - opcode reply code value 0x%x (%u) with %uB of data",
-            HW_MBOX_MASTER_GET_NAME(subject), subject, *code, *code, *replyDataLen);
+                /* ACK should succeed and return with no Data: */
+                *replyDataLen = 0;
+            }
+        }
+    }
+    else
+    {
+        DPRINTK("send Opcode to %s(%d) - opcode reply with %uB of data",
+                HW_MBOX_MASTER_GET_NAME(subject), subject, *replyDataLen);
+    }
 
     STATS_INC_COUNTER(subject, hw_mbox_opcode, False);
 
@@ -1679,57 +1742,43 @@ EXPORT_SYMBOL(hwMbox_sendOpcode);
 
 /**************************************************************************/
 /*! \fn int hwMbox_sendReplyOpcode(hw_mbox_Masters_e commander,
-                                   Uint32 code,
                                    Uint8 *dataBuf, Uint32 *dataLen)
  **************************************************************************
  *  \brief Send a reply to an opcode received from <commander> using the HW_MBOX.
  *  \attention should only be used after an opcode has been received from <commander>.
  *  \param[in] commander - To which Master should the reply be sent.
- *  \param[in] code - reply code.
- *  \param[in] dataBuf - pointer to a Buffer containing more data to be sent.
+ *  \param[in] dataBuf - pointer to a Buffer containing data to be sent.
  *  \param[in] dataLen - Length in Bytes of data to be sent from buffer
  *                       specified in <dataBuf>.
  *  \return [ 0 on success / error otherwise ].
  **************************************************************************/
 int hwMbox_sendReplyOpcode(hw_mbox_Masters_e commander,
-                           Uint32 code,
                            Uint8 *dataBuf, Uint32 dataLen)
 {
-    Uint32 paramCID, cmdRegVal, codeMaxVal;
+    Uint32 paramCID, cmdRegVal;
     hwMbox_opcode_t opFlds = { 0 };
 
     CHECK_IS_DRV_INITIALIZED(return (-1));
 
-    DPRINTK("send Reply Opcode to %s(%d) [code 0x%x (%u) with %uB of data]",
-             HW_MBOX_MASTER_GET_NAME(commander), commander,
-             code, code, dataLen);
-
-    codeMaxVal = HW_MBOX_OPCODE_CODE_MAX_VALUE;
-    if (code > codeMaxVal)
-    {
-        PRINTK_ERR("send Reply Opcode to %s(%d) - code value 0x%x (%u) > max possible value 0x%x (%u)!",
-                   HW_MBOX_MASTER_GET_NAME(commander), commander,
-                   code, code, codeMaxVal, codeMaxVal);
-
-        return (-1);
-    }
+    DPRINTK("send Reply Opcode to %s(%d) [with %uB of data]",
+             HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen);
 
     if ((dataBuf != NULL) && ((dataLen % 4) != 0))
     {
         /* Opcode Reply data is always a multiple of 4 Bytes! */
-        PRINTK_ERR("send Reply Opcode to %s(%d) - opcode reply data length (%uB) must be a multiple of 4!",
+        PRINTK_ERR("send Reply Opcode to %s(%d) - opcode reply data length (%uB) must be a multiple of 4B!",
                    HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen);
 
         return (-1);
     }
 
-    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_opcode, True, return (-1), paramCID);
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_opcode, CID_LUT_PEER_IS_COMMANDER, return (-1), paramCID);
 
     if ((dataBuf != NULL) && (dataLen > 0))
     {
-        /* opcode Reply has data! save to SRAM: */
+        /* Opcode Reply has data! save to SRAM: */
 
-        /* verify SRAM size: */
+        /* Verify SRAM size: */
         if (dataLen > CHN_CFG_MEMBUFF_GET_SIZE(paramCID))
         {
             PRINTK_ERR("send Reply Opcode to %s(%d) - opcode reply data length (%uB) > SRAM allocated to channel (%uB)!",
@@ -1738,7 +1787,6 @@ int hwMbox_sendReplyOpcode(hw_mbox_Maste
             return (-1);
         }
 
-
         DPRINTK("send Reply Opcode to %s(%d) - copying %uB of opcode reply data to SRAM",
                 HW_MBOX_MASTER_GET_NAME(commander), commander, dataLen);
 
@@ -1748,38 +1796,99 @@ int hwMbox_sendReplyOpcode(hw_mbox_Maste
         HW_MBOX_COPY_TO_SRAM(dataBuf, dataLen, CHN_CFG_MEMBUFF_GET_START(paramCID));
     }
 
-    /* get the current command register value to modify: */
+    /* Get the current opcode to modify: */
     cmdRegVal = HW_MBOX_CHN_COMMAND_REG_GET(paramCID);
-    HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT(cmdRegVal, &opFlds);
 
-    /* update with the required code: */
-    opFlds.code = code;
+    /* parse to opcode fields: */
+    HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT(cmdRegVal, &opFlds);
 
-    /* Flags are currently reserved! */
-    opFlds.flagA = 0;
-    opFlds.flagB = 0;
+    DPRINTK("cid %d: cmdRegVal=0x%08x -> opcode fields - tag=%u, lenInBytes=%u",
+            paramCID, cmdRegVal, opFlds.tag, opFlds.lenInBytes);
 
-    /* update with the required size: */
+    /* Update with the required size: */
     opFlds.lenInBytes = dataLen;
 
-    DPRINTK("cid %d: opcode fields - tag=%u, code=%u=0x%x, A=%d, B=%d, lenInBytes=%u",
-            paramCID, opFlds.tag, opFlds.code, opFlds.code,
-            opFlds.flagA, opFlds.flagB, opFlds.lenInBytes);
-
-    /* create opcode reply: */
+    /* Create opcode reply value: */
     HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT(cmdRegVal, &opFlds);
 
+    DPRINTK("cid %d: opcode fields - tag=%u, lenInBytes=%u -> cmdRegVal=0x%08x",
+            paramCID, opFlds.tag, opFlds.lenInBytes, cmdRegVal);
+
     /* Send Opcode Reply to commander */
     DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
     DPRINTK("cid %d: writing 0x%08x to the command register of the channel...", paramCID, cmdRegVal);
     HW_MBOX_CHN_COMMAND_REG_SET(paramCID, cmdRegVal);
-    DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+    DPRINTK("cid %d: after write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
 
     return 0;
 }
 EXPORT_SYMBOL(hwMbox_sendReplyOpcode);
 
 /**************************************************************************/
+/*! \fn int hwMbox_sendAckOpcode(hw_mbox_Masters_e commander)
+ **************************************************************************
+ *  \brief Send back an ACK to <commander>, from which an opcode has been
+ *         received using the HW_MBOX.
+ *  \attention should only be used after an opcode has been received from
+ *             <commander> using HW_MBOX_recvCommand.
+ *  \param[in] commander - To which Master should the ACK be sent.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_sendAckOpcode(hw_mbox_Masters_e commander)
+{
+    Uint32 paramCID, cmdRegVal;
+
+    hwMbox_opcode_t opFlds = { 0 };
+    hwMbox_opcodeMessage_t opcodeMsg;
+
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+
+    DPRINTK("send ACK Opcode to %s(%d)",
+             HW_MBOX_MASTER_GET_NAME(commander), commander);
+
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_opcode, CID_LUT_PEER_IS_COMMANDER, return (-1), paramCID);
+
+    /* To send an ACK to the Commander we send back
+       a HW MBOX opcode message of type STATUS with STATUS_OK. */
+
+    opcodeMsg.msgType = HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS;
+    opcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_OK;
+
+    DPRINTK("send ACK Opcode to %s(%d) - copying %uB of opcode ACK data to SRAM",
+             HW_MBOX_MASTER_GET_NAME(commander), commander, HW_MBOX_OPCODE_MESSAGE_SIZE);
+
+    DPRINTK("cid %d: copying %uB [out of total %uB channel has] to SRAM at offset=0x%08x",
+            paramCID, HW_MBOX_OPCODE_MESSAGE_SIZE, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+    /* Copy the opcode message to the SRAM: */
+    HW_MBOX_COPY_TO_SRAM(&opcodeMsg,
+                         HW_MBOX_OPCODE_MESSAGE_SIZE,
+                         CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+    /* Build the opcode: */
+    opFlds.tag = HW_MBOX_OPCODE_TAG;
+    opFlds.lenInBytes = HW_MBOX_OPCODE_MESSAGE_SIZE;
+
+    /* Create opcode reply value: */
+    HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT(cmdRegVal, &opFlds);
+
+    DPRINTK("cid %d: opcode fields - tag=%u, lenInBytes=%u -> cmdRegVal=0x%08x",
+            paramCID, opFlds.tag, opFlds.lenInBytes, cmdRegVal);
+
+    /* Send Opcode ACK to commander: */
+    DPRINTK("send ACK Opcode to %s(%d) - sending opcode ACK to commander!",
+             HW_MBOX_MASTER_GET_NAME(commander), commander);
+
+    DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+    DPRINTK("cid %d: writing 0x%08x to the command register of the channel...", paramCID, cmdRegVal);
+    HW_MBOX_CHN_COMMAND_REG_SET(paramCID, cmdRegVal);
+    DPRINTK("cid %d: after write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+
+    return 0;
+}
+EXPORT_SYMBOL(hwMbox_sendAckOpcode);
+
+/**************************************************************************/
 /*! \fn int hwMbox_registerRecvOpcode(hw_mbox_Masters_e commander,
                                       hwMboxRecvOpcodeCallback pOpcodeCallbackFunc,
                                       Uint32 tag,
@@ -1788,7 +1897,7 @@ EXPORT_SYMBOL(hwMbox_sendReplyOpcode);
  *  \brief Register for Receive Opcode from <commander> using the HW_MBOX.
  *  \attention This function should be called once per tag.
  *  \param[in] commander - From which Master should the opcode be received.
- *  \param[in] pOpcodeCallbackFunc - pointer to the callback function to be 
+ *  \param[in] pOpcodeCallbackFunc - pointer to the callback function to be
  *                                   invoked upon receiving an opcode from
  *                                   <commander>.
  *  \param[in] tag - indicates the destination.
@@ -1814,7 +1923,7 @@ int hwMbox_registerRecvOpcode(hw_mbox_Ma
     DPRINTK("register Receive Opcode from %s(%d) [tag %u token 0x%x (%u)]",
             HW_MBOX_MASTER_GET_NAME(commander), commander, tag, token, token);
 
-    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_opcode, True, return (-1), paramCID);
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_opcode, CID_LUT_PEER_IS_COMMANDER, return (-1), paramCID);
 
     if (CHN_RECV_OPCODE_GET_INDEX(paramCID) == CHN_RECV_OPCODE_INDEX_INVALID)
     {
@@ -1825,7 +1934,7 @@ int hwMbox_registerRecvOpcode(hw_mbox_Ma
         return (-1);
     }
 
-    if ((tag == HW_MBOX_OPCODE_TAG) || (tag == HW_MBOX_OPCODE_USER_SPACE_TAG))
+    if (tag >= HW_MBOX_OPCODE_RESERVED_TAGS_START)
     {
         PRINTK_ERR("register Receive Opcode from %s(%d) - can't register tag %u, it is reserved for HW MBOX!",
                    HW_MBOX_MASTER_GET_NAME(commander), commander, tag);
@@ -1854,8 +1963,8 @@ int hwMbox_registerRecvOpcode(hw_mbox_Ma
     {
         if(RECV_OP_GET_TAG(paramCID, i) == tag)
         {
-            PRINTK_ERR("register Receive Opcode from %s(%d) - tag %u is already registered!",
-                        HW_MBOX_MASTER_GET_NAME(commander), commander, tag);
+            DPRINTK("register Receive Opcode from %s(%d) - tag %u is already registered!",
+                    HW_MBOX_MASTER_GET_NAME(commander), commander, tag);
 
             /* release lock */
             up(&CHN_LOCK(paramCID));
@@ -2027,7 +2136,7 @@ static int proc_dump_channels_regs_show(
             /* Value fmt: "|  ##  |  0x00000000 |  0x00000000 |  0x00000000 |  0x00000000 |" */
         }
 
-        seq_printf(m, "|  %2d  |  0x%08x |  0x%08x |  0x%08x |  0x%08x |\n", i, 
+        seq_printf(m, "|  %2d  |  0x%08x |  0x%08x |  0x%08x |  0x%08x |\n", i,
                    HW_MBOX_CHN_CFG_REG_GET(i), HW_MBOX_CHN_STATE_REG_GET(i),
                    HW_MBOX_CHN_COMMAND_REG_GET(i), HW_MBOX_MEMORY_MAP_REG_GET(i));
 
@@ -2156,7 +2265,8 @@ static int proc_dump_LUT_show(struct seq
 
         for (type = 0; type < HW_MBOX_TYPE_COUNT; type++)
         {
-            seq_printf(m, " 0x%08x | 0x%08x |", FIND_CID_IN_LUT(i, type, False), FIND_CID_IN_LUT(i, type, True));
+            seq_printf(m, " 0x%08x | 0x%08x |", FIND_CID_IN_LUT(i, type, CID_LUT_PEER_IS_SUBJECT),
+                                                FIND_CID_IN_LUT(i, type, CID_LUT_PEER_IS_COMMANDER));
             /* fmt:          SEND  |  RECV  | */
         }
         seq_printf(m, "\n");
@@ -2266,7 +2376,7 @@ static int proc_dump_masterDb_show(struc
             /*       fmt: "|  ##  | ********** |  ***  | ***  | *******    | ########## |" */
         }
 
-        seq_printf(m, "|  %2d  | %-10s |  %-3s  | %-3s  | %-7s    | %10u |\n", 
+        seq_printf(m, "|  %2d  | %-10s |  %-3s  | %-3s  | %-7s    | %10u |\n",
                    i,
                    HW_MBOX_MASTER_GET_NAME(i),
                    YESNO_STR(IS_MASTER_VALID(i)),
@@ -2305,7 +2415,7 @@ static int proc_dump_chnDb_show(struct s
         if (CHN_IS_ASSIGNED(i))
         {
             /* only prints assigned channels */
-            seq_printf(m, "|  %2d  |  %-3s  |  %-12s | %02d %-10s | %02d %-10s |  0x%08x |  %8u |            %2d |           %2d |\n", 
+            seq_printf(m, "|  %2d  |  %-3s  |  %-12s | %02d %-10s | %02d %-10s |  0x%08x |  %8u |            %2d |           %2d |\n",
                        i,
                        YESNO_STR(CHN_IS_VALID(i)),
                        HW_MBOX_TYPE_STR(CHN_CFG_GET_TYPE(i)),
@@ -2397,14 +2507,15 @@ static int proc_dump_recvOpTagsDb_show(s
         tagIndex = i % HW_MBOX_OPCODE_TAG_COUNT;
 
         recvOpIndex = 0;
-        while ((recvOpIndex * HW_MBOX_OPCODE_TAG_COUNT) < i) /* to avoid division... */
+        while ((recvOpIndex * HW_MBOX_OPCODE_TAG_COUNT) <= i) /* to avoid division... */
         {
             recvOpIndex++;
         }
+        recvOpIndex--;
 
-        if (recvOpData[recvOpIndex].listenerThread != NULL)
+        if (RECV_OP_THREAD_BY_INDEX(recvOpIndex) != NULL)
         {
-            if (tagIndex < recvOpData[recvOpIndex].registeredCount)
+            if (tagIndex < RECV_OP_GET_TAG_COUNT_BY_INDEX(recvOpIndex))
             {
                 /* only prints assigned recvOp indices */
                 seq_printf(m, "|     %2d | %3d | %-8p |  0x%08x |\n",
@@ -2438,15 +2549,14 @@ static int proc_dump_recvOpTagsDb_show(s
 /**************************************************************************/
 /*! \fn int hwMbox_initAfterStarted(void)
  **************************************************************************
- *  \brief Dynamically initialize the HW MBOX according to the set HW 
+ *  \brief Dynamically initialize the HW MBOX according to the set HW
  *         configuration, previously set by supervisor.
- *  \note used by non-supervisor to learn initial configurtion.
- *  \note used by supervisor after warm boot. 
  *  \return [ 0 on success /(-1) on error ].
  **************************************************************************/
 int hwMbox_initAfterStarted(void)
 {
-    int paramCID;
+    Uint32 paramCID;
+
     hw_mbox_channelConfig_t chnConfig;
 
     if (!HW_MBOX_IS_STARTED())
@@ -2462,7 +2572,9 @@ int hwMbox_initAfterStarted(void)
     /* dynamically learn set configuration from HW: */
     DPRINTK("dynamically learn set configuration from HW...");
 
-    /* general configuration values: */
+    /* General configuration values: */
+
+    /* Monitor: */
     if (HW_MBOX_CTRL_MON_EXIST_GET() == True)
     {
         CTRL_SET_MONITOR(HW_MBOX_CTRL_MONITOR_GET());
@@ -2503,7 +2615,7 @@ int hwMbox_initAfterStarted(void)
     for (paramCID = 0; paramCID < HW_MBOX_CHANNEL_COUNT; paramCID++)
     {
         DPRINTK("checking channel %d...", paramCID);
-        if (HW_MBOX_CHN_CFG_VALID_GET(paramCID) == True) 
+        if (HW_MBOX_CHN_CFG_VALID_GET(paramCID) == True)
         {
             DPRINTK("channel %d is assigned!", paramCID);
             HW_MBOX_CHANNEL_CONFIG_GET_TO_STRUCT(paramCID, &chnConfig);
@@ -2549,9 +2661,6 @@ int hwMbox_initAfterStarted(void)
         }
     }
 
-    /* Let all driver services that the device is initialized! */
-    SET_INITIALIZED();
-
     return 0;
 }
 
@@ -2597,7 +2706,7 @@ int hwMbox_setChannelConfig(hw_mbox_chan
 
         if (NULL == RECV_OP_THREAD_BY_INDEX(recvOpcodeChannelsCount))
         {
-            /* initialize the listener: 
+            /* initialize the listener:
                This is not required for the first Receive Opcode Listener... */
             RECV_OP_THREAD_SET_CID(recvOpcodeChannelsCount, paramCID);
             RECV_OP_THREAD_SET_INDEX(recvOpcodeChannelsCount);
@@ -2658,7 +2767,7 @@ int hwMbox_setChannelValid(Uint32 paramC
 
     CHN_SET_VALID(paramCID, isValid);
 
-    if ((CHN_CFG_GET_COMMANDER(paramCID) != HW_MBOX_MID) && 
+    if ((CHN_CFG_GET_COMMANDER(paramCID) != HW_MBOX_MID) &&
         (CHN_CFG_GET_SUBJECT(paramCID) != HW_MBOX_MID))
     {
         /* Master is not part of this channel... Don't add to LUTs!!!
@@ -2702,12 +2811,13 @@ int hwMbox_setChannelValid(Uint32 paramC
  *        owned by the listener].
  *  \param[in] cid - cid to wait on.
  *  \param[in] timeoutInMsec - timeout [use CHN_INTR_NO_TIMEOUT for no timeout].
+ *  \param[out] pHwMboxStatus - extended status information.
  *  \note this function is blocking, returning only upon channel interrupt [or error].
  *  \note this function also clears the channel interrupt.
  *  \attnetion this is just the wait, if you need a lock then acquire it before...
  *  \return [ 0 on success / error otherwise ].
  **************************************************************************/
-int hwMbox_waitForChannelInterrupt(int cid, int timeoutInMsec)
+int hwMbox_waitForChannelInterrupt(int cid, int timeoutInMsec, HW_MBOX_STATUS_e *pHwMboxStatus)
 {
     long rc = 0;
     wait_queue_head_t *pWq; /* pointer to the wait queue we should wait on */
@@ -2715,6 +2825,8 @@ int hwMbox_waitForChannelInterrupt(int c
 
     DPRINTK("cid %d: wait for channel interrupts...", cid);
 
+    *pHwMboxStatus = HW_MBOX_STATUS_OK;
+
     if (CHN_IS_RECV_OP(cid))
     {
         /* Receive Opcode channel should wait on application queue */
@@ -2740,7 +2852,8 @@ int hwMbox_waitForChannelInterrupt(int c
                                       *pState != CHN_INTR_STATE_NONE) )
         {
             DPRINTK("cid %d, wait interrupted by signal!", cid);
-            return CHN_INTR_RC_INTERRUPTED_BY_SIGNAL;
+            *pHwMboxStatus = HW_MBOX_STATUS_INTERRUPTED_BY_SIGNAL;
+            return (-1);
         }
     }
     else
@@ -2752,19 +2865,21 @@ int hwMbox_waitForChannelInterrupt(int c
 
         DPRINTK("cid %d: rc=%ld", cid, rc);
 
-        /* if evaluated to true before timeout expires
+        /* if evaluated to True before timeout expires
            returns the remaining amount of jiffies, else errors: */
         if (rc <= 0)
         {
             if (0 == rc)
             {
                 DPRINTK("cid %d: timeout expired!", cid);
-                return CHN_INTR_RC_TIMEOUT_EXPIRED;
+                *pHwMboxStatus = HW_MBOX_STATUS_ERROR_TIMEOUT_EXPIRED;
+                return (-1);
             }
             else
             {
                 DPRINTK("cid %d: wait interrupted by signal!", cid);
-                return CHN_INTR_RC_INTERRUPTED_BY_SIGNAL;
+                *pHwMboxStatus = HW_MBOX_STATUS_INTERRUPTED_BY_SIGNAL;
+                return(-1);
             }
         }
     }
@@ -2776,7 +2891,7 @@ int hwMbox_waitForChannelInterrupt(int c
     }
 
     *pState = CHN_INTR_STATE_NONE; /* we got the state, set to none... */
-    return CHN_INTR_RC_OK;
+    return 0;
 }
 
 /**************************************************************************/
@@ -2786,15 +2901,20 @@ int hwMbox_waitForChannelInterrupt(int c
  **************************************************************************/
 static int hwMbox_recvOpcodeListenerEntry(void *data)
 {
-#define LOG_RECVOP_LISTENER(fmt, args...)    DPRINTK("[RECV_OP_LISTENER#%d ON CID#%d]: " fmt, threadData->index, threadData->cid, ## args)
+#define LOG_RECVOP_LISTENER(fmt, args...) \
+    DPRINTK("[RECV_OP_LISTENER#%d ON CID#%d]: " fmt, threadData->index, threadData->cid, ## args)
 
     recvOpcodeListenerThreadData_t *threadData; /* This listener's data */
 
-    int i, cbRc;
+    int i, cbRc, paramMID;
     Uint32 cmdRegVal; /* also re-used for listener replies */
     Uint32 paramToken;
 
     hwMbox_opcode_t opFlds = { 0 };
+    hwMbox_opcodeMessage_t opcodeMsg;
+    hwMbox_opcode_t replyOpFlds = { 0 };
+    hwMbox_opcodeMessage_t replyOpcodeMsg;
+
     hw_mbox_channelConfig_t chnCfg = { 0 }; /* used only if first listener... */
 
     hwMboxRecvOpcodeCallback recvOpCb;
@@ -2829,7 +2949,7 @@ static int hwMbox_recvOpcodeListenerEntr
             return -ERESTARTSYS;
         }
 
-        /* INIT_COMPLETE signaled by ISR! 
+        /* INIT_COMPLETE signaled by ISR!
            correct CID was set in thread Data by ISR, listener should do the rest... */
 
         LOG_RECVOP_LISTENER("driver NOT initialized yet, This is the first Listener!");
@@ -2877,80 +2997,154 @@ static int hwMbox_recvOpcodeListenerEntr
         RECV_OP_INC_WAKEUP_COUNT(threadData->cid);
 
         LOG_RECVOP_LISTENER("received channel interrupt!");
+
+        /* Get the opcode value: */
         cmdRegVal = HW_MBOX_CHN_COMMAND_REG_GET(threadData->cid);
-        LOG_RECVOP_LISTENER("command register=0x%08x", cmdRegVal);
 
         /* Parse the opcode fields to struct: */
         HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT(cmdRegVal, &opFlds);
 
-        LOG_RECVOP_LISTENER("opcode fields: tag=%u, code=%u=0x%x, A=%d, B=%d, lenInBytes=%u",
-                            opFlds.tag, opFlds.code, opFlds.code,
-                            opFlds.flagA, opFlds.flagB, opFlds.lenInBytes);
-
-        /* cmdRegVal is reused for listener replies */
-        cmdRegVal = HW_MBOX_OPCODE_SET_LEN(cmdRegVal, 0);                     /* default value: no data */
-        cmdRegVal = HW_MBOX_OPCODE_SET_TAG(cmdRegVal, HW_MBOX_OPCODE_TAG);    /* listener response is internal */
-
-        /* Flags are currently reserved! */
-        cmdRegVal = HW_MBOX_OPCODE_SET_FLAG_A(cmdRegVal, 0);
-        cmdRegVal = HW_MBOX_OPCODE_SET_FLAG_B(cmdRegVal, 0);
+        LOG_RECVOP_LISTENER("cmdRegVal=0x%08x -> opcode fields: tag=%u, lenInBytes=%u",
+                            cmdRegVal, opFlds.tag, opFlds.lenInBytes);
 
-        /* first handle Kernel HW MBOX tag: */
+        /* Setup the structs for listener replies [HW MBOX opcode message of type STATUS]: */
+        replyOpFlds.tag = HW_MBOX_OPCODE_TAG;
+        replyOpFlds.lenInBytes = HW_MBOX_OPCODE_MESSAGE_SIZE;
+        replyOpcodeMsg.msgType = HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS;
+
+        /* First handle Kernel HW MBOX tag: */
         if (opFlds.tag == HW_MBOX_OPCODE_TAG)
         {
-            LOG_RECVOP_LISTENER("Handling Kernel HW MBOX TAG(%u)", HW_MBOX_OPCODE_TAG);
+            LOG_RECVOP_LISTENER("Handling Kernel HW MBOX OPCODE TAG(%u)", HW_MBOX_OPCODE_TAG);
+
+            /* Verify message validity: */
+            if (opFlds.lenInBytes != HW_MBOX_OPCODE_MESSAGE_SIZE)
+            {
+                LOG_RECVOP_LISTENER("invalid message for tag %u [got size %uB, excpected size %uB]!",
+                                    HW_MBOX_OPCODE_TAG, opFlds.lenInBytes, HW_MBOX_OPCODE_MESSAGE_SIZE);
+
+                /* Invalid message, prepare the response: */
+                replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_OPCODE_ERROR_INVALID_MESSAGE;
+
+                goto SEND_OP_REPLY;
+            }
+
+            LOG_RECVOP_LISTENER("copying %uB [out of total %uB channel has] from SRAM at offset=0x%08x",
+                                HW_MBOX_OPCODE_MESSAGE_SIZE,
+                                CHN_CFG_MEMBUFF_GET_SIZE(threadData->cid),
+                                CHN_CFG_MEMBUFF_GET_START(threadData->cid));
+
+            /* Get the opcode message from the SRAM: */
+            HW_MBOX_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(threadData->cid),
+                                   HW_MBOX_OPCODE_MESSAGE_SIZE,
+                                   &opcodeMsg);
+
+            LOG_RECVOP_LISTENER("incoming message is of type %d", opcodeMsg.msgType);
 
             if (!IS_INITIALIZED())
             {
                 /* Driver is not initialized yet... */
                 LOG_RECVOP_LISTENER("driver NOT initialized yet...");
 
-                /* at this point command must be init complete... */
+                /* At this point message must be of type CODE
+                   and Code should be INIT_COMPLETE... */
 
-                if (opFlds.code == HW_MBOX_CODE_INIT_COMPLETE)
+                if (opcodeMsg.msgType != HW_MBOX_OPCODE_MESSAGE_TYPE_CODE)
                 {
-                    LOG_RECVOP_LISTENER("Handling INIT_COMPLETE code %u", HW_MBOX_CODE_INIT_COMPLETE);
-                    hwMbox_initAfterStarted();
+                    /* shouldn't happen, kept here as a safety precaution... */
+                    LOG_RECVOP_LISTENER("First opcode message should be of type code (%u) [got message of type %u]...",
+                                        HW_MBOX_OPCODE_MESSAGE_TYPE_CODE, opcodeMsg.msgType);
 
-                    /* Currently hwMbox_initAfterStarted will always succeed here, since it is called in response
-                       to an interrupt so HW MBOX must be started and the function can only fail if it is called 
-                       and start is not set yet...  
-                    */
+                    /* Driver not initialized! prepare the response: */
+                    replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_DRIVER_NOT_INITIALIZED;
 
-                    /* Success! */
-                    LOG_RECVOP_LISTENER("INIT_COMPLETE! report back to supervisor...");
-                    cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_OK);
+                    goto SEND_OP_REPLY;
                 }
-                else
+
+                /* Opcode message is of type CODE: */
+                LOG_RECVOP_LISTENER("incoming code message has code %u",
+                                    opcodeMsg.msgData.msgCode.code);
+
+                if (opcodeMsg.msgData.msgCode.code != HW_MBOX_CODE_INIT_COMPLETE)
                 {
                     /* shouldn't happen, kept here as a safety precaution... */
-                    LOG_RECVOP_LISTENER("First opcode should be INIT_COMPLETE %u...", HW_MBOX_CODE_INIT_COMPLETE);
+                    LOG_RECVOP_LISTENER("First opcode code message should have INIT_COMPLETE code (%u) [got code message with code %u]...",
+                                        HW_MBOX_CODE_INIT_COMPLETE, opcodeMsg.msgData.msgCode.code);
+
+                    /* Driver not initialized! prepare the response: */
+                    replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_DRIVER_NOT_INITIALIZED;
 
-                    cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_NOK);
                     goto SEND_OP_REPLY;
                 }
+
+                LOG_RECVOP_LISTENER("Handling INIT_COMPLETE code (%u)", HW_MBOX_CODE_INIT_COMPLETE);
+                hwMbox_initAfterStarted();
+
+                /* Currently hwMbox_initAfterStarted will always succeed here, since it is called in response
+                   to an interrupt so HW MBOX must be started and the function can only fail if it is called
+                   and start is not set yet...
+                */
+
+                for (paramMID = 0; paramMID < HW_MBOX_MASTER_COUNT; paramMID++)
+                {
+                    if (IS_MASTER_VALID(paramMID))
+                    {
+                        /* Currently for non-supervisor,
+                           all valid masters are considered initialized. */
+                        MASTER_SET_INITIALIZED(paramMID, True);
+                    }
+                }
+
+                /* Let all driver services that the device is initialized! */
+                SET_INITIALIZED();
+
+                /* Success! */
+                LOG_RECVOP_LISTENER("INIT_COMPLETE! report back to supervisor...");
+
+                /* Prepare the response: */
+                replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_OK;
             }
             else
             {
-                /* initialized! */
+                /* Initialized! */
                 LOG_RECVOP_LISTENER("driver is initialized!!!");
 
-                switch (opFlds.code)
+                switch (opcodeMsg.msgType)
                 {
-                    case HW_MBOX_CODE_INIT_COMPLETE:
-                        LOG_RECVOP_LISTENER("Handling INIT_COMPLETE code %u", HW_MBOX_CODE_INIT_COMPLETE);
-                        LOG_RECVOP_LISTENER("Driver already initialized! report back...");
-                        cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_OK);
+                    case HW_MBOX_OPCODE_MESSAGE_TYPE_CODE:
+                        LOG_RECVOP_LISTENER("Handling messages of type CODE (%d)!", opcodeMsg.msgType);
+
+                        switch (opcodeMsg.msgData.msgCode.code)
+                        {
+                            case HW_MBOX_CODE_INIT_COMPLETE:
+                                LOG_RECVOP_LISTENER("Handling INIT_COMPLETE code %u", HW_MBOX_CODE_INIT_COMPLETE);
+                                LOG_RECVOP_LISTENER("Driver already initialized! report back...");
+                                replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_OK;
+                                break;
+
+                            case HW_MBOX_CODE_PING:
+                                LOG_RECVOP_LISTENER("Handling PING code %u", HW_MBOX_CODE_PING);
+                                replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_OK;    /* ACK ping */
+                                break;
+
+                            default:
+                                LOG_RECVOP_LISTENER("invalid opcode CODE message code value %u!",
+                                                    opcodeMsg.msgData.msgCode.code);
+                                replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_OPCODE_ERROR;
+                        }
                         break;
 
-                    case HW_MBOX_CODE_PING:
-                        LOG_RECVOP_LISTENER("Handling PING code %u", HW_MBOX_CODE_PING);
-                        cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_OK);    /* ACK ping */
+                    case HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS:
+                        LOG_RECVOP_LISTENER("incoming message of type STATUS %d should not be received at this point!",
+                                            opcodeMsg.msgType);
+                        replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_OPCODE_ERROR_ILLEGAL_MESSAGE;
                         break;
 
                     default:
-                        LOG_RECVOP_LISTENER("invalid code %u for tag %u", opFlds.code, opFlds.tag);
-                        cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_INVALID_CODE);
+                        LOG_RECVOP_LISTENER("incoming message has invalid type %d!",
+                                            opcodeMsg.msgType);
+
+                        replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_OPCODE_ERROR_INVALID_MESSAGE;
                 }
             }
 
@@ -2959,9 +3153,9 @@ static int hwMbox_recvOpcodeListenerEntr
 
         if (!IS_INITIALIZED())
         {
-            /* if we are here driver is not initialized yet and it's a non Kernel HW MBOX tag... */
+            /* if we are here, driver is not initialized yet and it's a non Kernel HW MBOX tag... */
             LOG_RECVOP_LISTENER("driver NOT initialized! can't handle tag %u yet...", opFlds.tag);
-            cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_OPCODE_RC_NOT_INITIALIZED_YET);
+            replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_DRIVER_NOT_INITIALIZED;
             goto SEND_OP_REPLY;
         }
 
@@ -3020,7 +3214,6 @@ static int hwMbox_recvOpcodeListenerEntr
         paramToken = RECV_OP_GET_TOKEN(threadData->cid, i);
 
         cbRc = recvOpCb(CHN_CFG_GET_COMMANDER(threadData->cid),
-                        opFlds.code,
                         HW_MBOX_POINTER_TO_SRAM(CHN_CFG_MEMBUFF_GET_START(threadData->cid)),
                         opFlds.lenInBytes,
                         &paramToken);
@@ -3031,13 +3224,13 @@ static int hwMbox_recvOpcodeListenerEntr
         if (cbRc == -1)
         {
             /* reserved return value indicating the the Callback failed!
-               Token should hold a generic HW MBOX return code <hwMbox_opcodeReturnCode_e> 
-               that will indicate of the error cause [i.e. INVALID_CODE]. */
+               Token should hold a generic HW MBOX return code <HW_MBOX_STATUS_e>
+               that will indicate of the error cause [i.e. ILLEGAL_MESSAGE]. */
 
             LOG_RECVOP_LISTENER("callback failed, sending back error 0x%08x (%u)",
                                 paramToken, paramToken);
 
-            cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, paramToken);
+            replyOpcodeMsg.msgData.msgStatus.status = paramToken;
 
             /* release Lock... */
             up(&CHN_LOCK(threadData->cid));
@@ -3045,7 +3238,7 @@ static int hwMbox_recvOpcodeListenerEntr
         }
         else
         {
-            RECV_OP_SET_TOKEN(threadData->cid, i, paramToken); /* update in DB the possibly modified Token */
+            RECV_OP_SET_TOKEN(threadData->cid, i, paramToken);    /* update in DB the possibly modified Token */
         }
 
         /* Opcode successfully received, INC count! */
@@ -3059,13 +3252,31 @@ SEND_OP_REPLY:
         /* Opcode successfully received, INC count! */
         STATS_INC_COUNTER(CHN_CFG_GET_COMMANDER(threadData->cid), hw_mbox_opcode, True);
 
-        LOG_RECVOP_LISTENER("send reply to subject!");
+        LOG_RECVOP_LISTENER("send opcode reply to subject!");
+
+        /* Use the current values in the Reply OPCODE message and the Reply OPCODE fields structs: */
+        LOG_RECVOP_LISTENER("sending back opcode message of type STATUS (%d), with status value 0x%x (%d)",
+                            replyOpcodeMsg.msgType,
+                            replyOpcodeMsg.msgData.msgStatus.status, replyOpcodeMsg.msgData.msgStatus.status);
+
+        LOG_RECVOP_LISTENER("copying %uB [out of total %uB channel has] to SRAM at offset=0x%08x",
+                            replyOpFlds.lenInBytes, CHN_CFG_MEMBUFF_GET_SIZE(threadData->cid), CHN_CFG_MEMBUFF_GET_START(threadData->cid));
+
+        /* Copy the opcode message to the SRAM: */
+        HW_MBOX_COPY_TO_SRAM(&replyOpcodeMsg,
+                             replyOpFlds.lenInBytes,
+                             CHN_CFG_MEMBUFF_GET_START(threadData->cid));
+
+        /* Create opcode reply value: */
+        HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT(cmdRegVal, &replyOpFlds);
+
+        LOG_RECVOP_LISTENER("opcode fields - tag=%u, lenInBytes=%u -> cmdRegVal=0x%08x",
+                            replyOpFlds.tag, replyOpFlds.lenInBytes, cmdRegVal);
 
-        /* uses cmdRegVal current value: */
         LOG_RECVOP_LISTENER("before write to command register - state=%d", HW_MBOX_CHN_STATE_REG_GET(threadData->cid));
         LOG_RECVOP_LISTENER("writing 0x%08x to the command register of the channel...", cmdRegVal);
         HW_MBOX_CHN_COMMAND_REG_SET(threadData->cid, cmdRegVal); /* send Command... */
-        LOG_RECVOP_LISTENER("before write to command register - state=%d", HW_MBOX_CHN_STATE_REG_GET(threadData->cid));
+        LOG_RECVOP_LISTENER("after write to command register - state=%d", HW_MBOX_CHN_STATE_REG_GET(threadData->cid));
     }
 
     return 0;
@@ -3094,7 +3305,7 @@ static int chnint_open(struct inode *ino
         if( wait_event_interruptible(waitForInitializedWq, IS_INITIALIZED()) )
         {
             /* following return code used internally by VFS (virtual filesystem) layer.
-               it will either restart the system call or return -EINTR to User-Space. 
+               it will either restart the system call or return -EINTR to User-Space.
                (to indicate that it was interrupted by signal...) */
 
             return -ERESTARTSYS;
@@ -3107,7 +3318,7 @@ static int chnint_open(struct inode *ino
 
 static ssize_t chnint_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
 {
-    chnIntrReturnCodes_e chnIntrRc;
+    HW_MBOX_STATUS_e hwMboxStatus;
     Bool replyToUserBuffer; /* initial preparation for full channel devices */
 
     chnint_t *dev = filp->private_data; /* dev was stored in filp during open */
@@ -3115,13 +3326,13 @@ static ssize_t chnint_read(struct file *
     DEV_PRINTK("chnint_read dev %p, chn_cid %d, interruptPending=%d", dev, dev->chn_cid, CHN_INTR_GET_STATE(dev->chn_cid));
     DEV_PRINTK("filp=%p, count=%u, *f_pos=%lld", filp, count, (long long)*f_pos);
 
-    if ((chnIntrRc = hwMbox_waitForChannelInterrupt(dev->chn_cid, CHN_INTR_NO_TIMEOUT)) != CHN_INTR_RC_OK)
+    if (hwMbox_waitForChannelInterrupt(dev->chn_cid, CHN_INTR_NO_TIMEOUT, &hwMboxStatus))
     {
-        /* error, currently can only be interrupted by signal... */
-        if (chnIntrRc == CHN_INTR_RC_INTERRUPTED_BY_SIGNAL)
+        /* error, no timeout so it can only be interrupted by signal... */
+        if (hwMboxStatus == HW_MBOX_STATUS_INTERRUPTED_BY_SIGNAL)
         {
             /* following return code used internally by VFS (virtual filesystem) layer.
-               it will either restart the system call or return -EINTR to User-Space. 
+               it will either restart the system call or return -EINTR to User-Space.
                (to indicate that it was interrupted by signal...) */
 
             return -ERESTARTSYS;
@@ -3186,10 +3397,10 @@ static int chnint_release(struct inode *
     return 0;
 }
 
-/*! \fn static void chnint_cleanup(int count) 
+/*! \fn static void chnint_cleanup(int count)
     \brief use to clean up the Channel Interrupt devices.
-    \param[in] count - amount of devices to clean up. 
-    \note also clears the chrdev region. 
+    \param[in] count - amount of devices to clean up.
+    \note also clears the chrdev region.
 */
 static void chnint_cleanup(int count)
 {
@@ -3210,7 +3421,13 @@ static void chnint_cleanup(int count)
 /*     HW_MBOX driver functions                                         */
 /************************************************************************/
 
-static irqreturn_t hw_mbox_drv_isr(int irq, void *dev_id)
+/**************************************************************************/
+/*! \fn irqreturn_t hwMbox_drv_isr(int irq, void *dev_id)
+ **************************************************************************
+ *  \brief HW_MBOX driver ISR.
+ *  \return [ IRQ_HANDLED ].
+ **************************************************************************/
+static irqreturn_t hwMbox_drv_isr(int irq, void *dev_id)
 {
     Uint32 highIntrStatusReg; /* Interrupts from Channels 63-32 [for supervisor 63 is error notify] */
     Uint32 lowIntrStatusReg;  /* Interrupts from Channels 31-0 */
@@ -3220,19 +3437,17 @@ static irqreturn_t hw_mbox_drv_isr(int i
     Uint32 lowIntrStatusRegBuffer;  /* Buffer for Interrupts from Channels 31-0 */
 #endif /* APP_CPU_HW_MBOX_IRQ_SAMPLE_CLK_WA */
 
-    Uint32 highIntrMaskReg; /* Interrupt Enable Mask for Channels 63-32 [for supervisor 63 is error notify, mask will be ignored] */
-    Uint32 lowIntrMaskReg;  /* Interrupt Enable Mask for Channels 31-0 */
+    Uint32 highIntrMaskReg; /* Interrupt Mask for Channels 63-32 */
+    Uint32 lowIntrMaskReg;  /* Interrupt Mask for Channels 31-0  */
 
     Uint32 highCidRange, regVal, cfgRegVal, chnint_cid;
-    Bool errorBitWasOn = False;
 
 #ifdef APP_CPU_HW_MBOX_IRQ_SAMPLE_CLK_WA
     highIntrStatusRegBuffer = 0;
     lowIntrStatusRegBuffer = 0;
 #endif /* APP_CPU_HW_MBOX_IRQ_SAMPLE_CLK_WA */
 
-    DPRINTK("isr!");
-    /* We got an interrupt! */
+    /* We got a HW MBOX interrupt! */
 
     /* Now we must read all the set bits from both HW_MBOX_MASTER_INTR_STATUS_H and
        HW_MBOX_MASTER_INTR_STATUS_L. All interrupts must be handled as the bits are
@@ -3250,22 +3465,7 @@ READ_INTERRUPT_STATUS_REGS:
     DPRINTK("verifying using shadowRegs(H L): 0x%08x 0x%08x", HW_MBOX_MASTER_INTR_CLEAR_H_REG_GET(),
                                                               HW_MBOX_MASTER_INTR_CLEAR_L_REG_GET());
 
-    /* First we will check if error is set, so we can notify hw_mbox_app as quickly as possible */
-    if ((IS_SUPERVISOR()) && (HW_MBOX_IS_ERROR_BIT_SET_FOR_SUPERVISOR(highIntrStatusReg)))
-    {
-        DPRINTK("Hardware signals of Access Violation Error!");
-        INC_ERR_INTR();
-
-        DPRINTK("interrupt on channel %d, signaling queue...", HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
-
-        CHN_INTR_SET_STATE(HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR, CHN_INTR_STATE_PENDING);
-        wake_up_interruptible(&CHN_INTR_WQ(HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR));
-
-        highIntrStatusReg &= (~HW_MBOX_ERROR_BIT_FOR_SUPERVISOR); /* Clear the error interrupt from the register value buffer */
-        errorBitWasOn = True; /* need to remember that error bit was on as we turn it off here */
-    }
-
-    /* Now we should remove the masked bits [interrupt is disabled for them] */
+    /* Now we should remove the masked bits [interrupt is disabled for them]: */
 
     highIntrMaskReg = HW_MBOX_MASTER_INTR_MASK_H_REG_GET();
     lowIntrMaskReg  = HW_MBOX_MASTER_INTR_MASK_L_REG_GET();
@@ -3294,21 +3494,28 @@ READ_INTERRUPT_STATUS_REGS:
 
     if ((0 == highIntrStatusReg) && (0 == lowIntrStatusReg))
     {
-        if (errorBitWasOn == False)
-        {
-            /* we got an interrupt, but no set bits in interrupt status! */
-            DPRINTK("We got a ghost Interrupt!");
-            INC_GHOST_INTR();
-        }
-        else
-        {
-            /* only error bit was on... */
-            DPRINTK("Only Error bit was on, no need to continue checking...");
-        }
+        /* we got an interrupt, but no set bits in interrupt status! */
+        DPRINTK("We got a ghost Interrupt!");
+        INC_GHOST_INTR();
     }
     else
     {
-        for (highCidRange = 0; highCidRange < 2; highCidRange++) 
+        /* First we will check if error is set, so we can notify as quickly as possible */
+        if ((IS_SUPERVISOR()) && (HW_MBOX_IS_ERROR_BIT_SET_FOR_SUPERVISOR(highIntrStatusReg)))
+        {
+            DPRINTK("Hardware signals of Access Violation Error!");
+            INC_ERR_INTR();
+
+            DPRINTK("interrupt on channel %d, signaling queue...", HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
+
+            CHN_INTR_SET_STATE(HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR, CHN_INTR_STATE_PENDING);
+            wake_up_interruptible(&CHN_INTR_WQ(HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR));
+
+            /* Clear the error interrupt from the register value buffer: */
+            highIntrStatusReg &= (~HW_MBOX_ERROR_BIT_FOR_SUPERVISOR);
+        }
+
+        for (highCidRange = 0; highCidRange < 2; highCidRange++)
         {
             /* highCidRange determines what CID range we are querying:
                highCidRange = 0 -> CID range [31-0]
@@ -3361,7 +3568,7 @@ READ_INTERRUPT_STATUS_REGS:
                     /* Special flag on channel that indicates that it's part of
                        HW MBOX intialization process. This is always an Opcode channel
                        with supervisor as commander and another master as subject.
-                     
+
                        First message on this channel acts as ACK from subject that it is
                        initialized.
                     */
@@ -3382,6 +3589,7 @@ READ_INTERRUPT_STATUS_REGS:
         }
     }
 
+#ifdef HW_MBOX_IS_NP_CPU
     /* Use ack_irq:
        Signal that we handled the Interrupt to clear the bit in the interrupt controller.
        Otherwise ISR would get called again as the bit is not cleared and it is Level.
@@ -3394,74 +3602,101 @@ READ_INTERRUPT_STATUS_REGS:
        interrupts by using ack_irq but we will save the unnecessary ISR just to clear the bit
        in the interrupt controller.
     */
-#ifdef HW_MBOX_IS_NP_CPU
     ack_irq(irq);
-#endif
+#endif /* HW_MBOX_IS_NP_CPU */
     return IRQ_HANDLED;
 }
 
-int hw_mailbox_register_with_netss(void) 
+#ifdef HW_MBOX_IS_APP_CPU
+/**************************************************************************/
+/*! \fn int hwMbox_drv_registerWithNetss(void)
+ **************************************************************************
+ *  \brief Register the HW_MBOX driver with Net Subsystem.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_drv_registerWithNetss(void)
 {
-   int i, ret = -ENODEV;
-   netss_subdevice_mmio_t hwmailbox_mmio;
+    int ret = -ENODEV;
+    netss_subdevice_mmio_t hwMbox_mmio;
 
-   if(!netss_driver_ready())
-   {
-      printk(KERN_INFO "Net SubSystem Driver is not ready, cannot initialize HW MUTEX driver\n");
-      return ret;
-   }
-
-   if(netss_get_subdevice_mmio_info(NETSS_HW_MAILBOX, &hwmailbox_mmio))
-   {
-      printk(KERN_INFO "HW MAILBOX driver could not get mmio info \n");
-      return -1;
-   }
-   else
-   {
-      printk(KERN_INFO "HW Mailbox mem_iobase = 0x%x, mem_iosize = 0x%x\n",(unsigned int)hwmailbox_mmio.base,(unsigned int)hwmailbox_mmio.size);
-   }
-    
-	
-   /* Initialize critical structures */
-   for (i = 0; i< HW_MBOX_CHANNEL_COUNT; i++) {
-      //mutex_init(&hwMboxDriverData.chnLock[i]);
-   }
-
-   hwMboxDriverData.reg_base = (void __iomem *)ioremap_nocache(hwmailbox_mmio.base,hwmailbox_mmio.size);
-   if (!hwMboxDriverData.reg_base) {
-      printk(KERN_ERR "error, failed to ioremap hw mailbox registers\n");
-      ret = -ENOMEM;
-      return ret;
-   }
-	
-   printk(KERN_INFO "Intel(R) HW MAILBOX driver built on %s @ %s\n", __DATE__, __TIME__);
-   return 0;
+    DPRINTK("About to register driver with Net Subsystem...");
+
+    DPRINTK("Checking netss driver ready...");
+    if(!netss_driver_ready())
+    {
+        PRINTK_ERR("Net Subsystem Driver is not ready!");
+        return ret;
+    }
+
+    DPRINTK("Getting MMIO info...");
+    if(netss_get_subdevice_mmio_info(NETSS_HW_MAILBOX, &hwMbox_mmio))
+    {
+        PRINTK_ERR("Failed to get mmio info!");
+        return -1;
+    }
+    else
+    {
+        PRINTK_INFO("mem_iobase = 0x%x, mem_iosize = 0x%x",
+                    (unsigned int)hwMbox_mmio.base, (unsigned int)hwMbox_mmio.size);
+    }
+
+    DPRINTK("ioremap registers...");
+    hwMboxDriverData.reg_base = (void __iomem *)ioremap_nocache(hwMbox_mmio.base, hwMbox_mmio.size);
+    if (!hwMboxDriverData.reg_base)
+    {
+        PRINTK_ERR("Failed to ioremap registers!");
+        ret = -ENOMEM;
+        return ret;
+    }
+
+    DPRINTK("Registered driver with Net Subsystem successfully!");
+    return 0;
 }
+#endif /* HW_MBOX_IS_APP_CPU */
 
-static int __init hw_mbox_drv_init_module (void)
+/**************************************************************************/
+/*! \fn int __init hwMbox_drv_init(void)
+ **************************************************************************
+ *  \brief HW_MBOX driver Initialization function.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+static int __init hwMbox_drv_init(void)
 {
-    int i, r, devno, paramMID, paramCID;
-    hw_mbox_masterConfig_t masterConfig;
+    int i, r, devno, paramMID;
+    Uint32 paramCID;
+
     hw_mbox_channelConfig_t chnConfig;
+
     Int32 retVal;
     Uint32 cmdRegVal, regVal;
 
-    DPRINTK("init!");
+    hwMbox_opcode_t opFlds = { 0 };
+    hwMbox_opcodeMessage_t opcodeMsg;
+
     PRINTK_INFO("%s version %s built on %s @ %s", DRV_NAME, DRV_VERSION, __DATE__, __TIME__);
 
 #ifdef HW_MBOX_DEBUG
-    /* If we are in debug mode (MID disguise feature) MID starts as 0
-       it makes more sense to start with the HARDCODED one... */
-    PRINTK_INFO("Master Disguise Feature: Setting initial MID to the Hardcoded one");  
-    __HW_MBOX_DEBUG_SET_MID(HW_MBOX_HARDCODED_MID);
-#endif
+    /* Verify initial disguise: */
+    PRINTK_INFO("Master Disguise Feature: initial MID (%d) is hardcoded MID (%d)",
+                HW_MBOX_MID, HW_MBOX_HARDCODED_MID);
+#endif /* HW_MBOX_DEBUG */
+
     /* Initialize the Driver Local Data: */
     RESET_DRIVER_DATA();
-    if( 0 > hw_mailbox_register_with_netss()) 
+
+    /* and other local variables: */
+    RESET_CID_LUT();
+    RESET_RECV_OP_THREAD_DATA();
+    RESET_RECV_OP_DATA();
+    RESET_STATS();
+
+#ifdef HW_MBOX_IS_APP_CPU
+    if(0 > hwMbox_drv_registerWithNetss())
     {
-       PRINTK_INFO("%s version %s built on %s @ %s CANNOT BE INITALIZED", DRV_NAME, DRV_VERSION, __DATE__, __TIME__);
-       return -ENODEV;
+        PRINTK_ERR("Failed to register driver with Net Subsystem!!!");
+        return -ENODEV;
     }
+#endif /* HW_MBOX_IS_APP_CPU */
 
     /* Create Channel interrupt Devices: */
     if ((r = alloc_chrdev_region(&chnint_dev, 0, HW_MBOX_CHANNEL_COUNT, HW_MBOX_CHNINT_DEV_NAME)) != 0)
@@ -3546,13 +3781,6 @@ static int __init hw_mbox_drv_init_modul
     }
     PRINTK_INFO("Created proc directory: /proc/%s", HW_MBOX_PROC_DIR_STR);
 
-
-    /* and other local variables: */
-    RESET_CID_LUT();
-    RESET_RECV_OP_THREAD_DATA();
-    RESET_RECV_OP_DATA();
-    RESET_STATS();
-
     /* Get core version from HW_MBOX_ID register: */
     CTRL_SET_CORE_VER_MAJ(HW_MBOX_ID_MAJOR_GET());
     CTRL_SET_CORE_VER_MIN(HW_MBOX_ID_MINOR_GET());
@@ -3588,230 +3816,217 @@ static int __init hw_mbox_drv_init_modul
         {
             MASTER_SET_VALID(paramMID, True);
         }
-    }
+        else
+        {
+            MASTER_SET_VALID(paramMID, False);
+        }
 
-    if (HW_MBOX_IS_STARTED())
-    {
-        /* HW_MBOX is already configured and started
-           (supervisor warm reset or non-supervisor starting after supervisor finished configuring)... */
-        PRINTK_INFO("HW_MBOX is already configured and started -> dynamically learn set configuration from HW...");
-        CTRL_SET_IS_STARTED(True);
-        hwMbox_initAfterStarted();
+        MASTER_SET_INITIALIZED(paramMID, False);
     }
-    else
+
+    if (IS_SUPERVISOR())
     {
-        if (IS_SUPERVISOR())
-        {
-            DPRINTK("Current Master is the supervisor!");
-            DPRINTK("Setting up general control configuration values...");
+        DPRINTK("Current Master is the supervisor!");
+        DPRINTK("Setting up general control configuration values...");
 
 #ifdef HW_MBOX_MONITOR
-            DPRINTK("Setting Monitor = %s(%d)", HW_MBOX_MASTER_GET_NAME(HW_MBOX_MONITOR), HW_MBOX_MONITOR);
+        DPRINTK("Setting Monitor = %s(%d)", HW_MBOX_MASTER_GET_NAME(HW_MBOX_MONITOR), HW_MBOX_MONITOR);
 
-            /* Setup HW_MBOX Configuration registers: */
-            HW_MBOX_CTRL_MON_EXIST_SET(True);
-            HW_MBOX_CTRL_MONITOR_SET(HW_MBOX_MONITOR);
+        /* Setup HW_MBOX Configuration registers: */
+        HW_MBOX_CTRL_MON_EXIST_SET(True);
+        HW_MBOX_CTRL_MONITOR_SET(HW_MBOX_MONITOR);
 
-            /* Set Monitor Value in DB: */
-            CTRL_SET_MONITOR(HW_MBOX_MONITOR);
+        /* Set Monitor Value in DB: */
+        CTRL_SET_MONITOR(HW_MBOX_MONITOR);
 #else
-            /* Setup HW_MBOX Configuration registers: */
-            HW_MBOX_CTRL_MON_EXIST_SET(False); /* Default should be False, but it doesn't hurt to make sure */
+        /* Setup HW_MBOX Configuration registers: */
+        HW_MBOX_CTRL_MON_EXIST_SET(False); /* Default should be False, but it doesn't hurt to make sure */
 
-            /* Set Monitor Value in DB: */
-            CTRL_SET_MONITOR(HW_MBOX_MID_INVALID);
+        /* Set Monitor Value in DB: */
+        CTRL_SET_MONITOR(HW_MBOX_MID_INVALID);
 #endif /* HW_MBOX_MONITOR */
 
 #ifdef HW_MBOX_START_IN_HW_DEBUG_MODE
-            DPRINTK("Setting HW Debug Mode...");
+        DPRINTK("Setting HW Debug Mode...");
 
-            /* Setup HW_MBOX Configuration registers: */
-            HW_MBOX_CTRL_DEBUG_SET(True);
-            CTRL_SET_IS_HW_DEBUG_MODE(True);
+        /* Setup HW_MBOX Configuration registers: */
+        HW_MBOX_CTRL_DEBUG_SET(True);
+        CTRL_SET_IS_HW_DEBUG_MODE(True);
 #else
-            HW_MBOX_CTRL_DEBUG_SET(False); /* Default should be False, but it doesn't hurt to make sure */
-            CTRL_SET_IS_HW_DEBUG_MODE(False);
+        HW_MBOX_CTRL_DEBUG_SET(False); /* Default should be False, but it doesn't hurt to make sure */
+        CTRL_SET_IS_HW_DEBUG_MODE(False);
 #endif /* HW_MBOX_START_IN_HW_DEBUG_MODE */
 
-            /* Check which Masters are Valid: */
-            for (paramMID = 0; paramMID < HW_MBOX_MASTER_COUNT; paramMID++)
+        /* INIT static channels: */
+        DPRINTK("Initializing %d static channels", HW_MBOX_STATIC_CHANNEL_COUNT);
+        for (i = 0; i < HW_MBOX_STATIC_CHANNEL_COUNT; i++)
+        {
+            memcpy(&chnConfig, &HW_MBOX_STATIC_CHANNEL_GET_CONFIG(i), HW_MBOX_CHANNEL_CONFIG_SIZE);
+            paramCID = chnConfig.cid;
+
+            DPRINTK("static channel entry %d (cid=%d): mboxType=%d, commander=%d, subject=%d, memSize=%uB",
+                    i, paramCID, chnConfig.mboxType, chnConfig.commander, chnConfig.subject, chnConfig.memBuff.size);
+
+            /* First we should check if the configuration is valid: */
+            DPRINTK("static channel entry %d (cid=%d): verifying configuration...", i, paramCID);
+
+            /* check that both Masters are Valid */
+            if ((!IS_MASTER_VALID(chnConfig.commander)) ||
+                (!IS_MASTER_VALID(chnConfig.subject)))
             {
-                memcpy(&masterConfig, &HW_MBOX_MASTER_GET_CONFIG(paramMID), HW_MBOX_MASTER_CONFIG_SIZE);
+                PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! One of the Masters is invalid!",
+                            i, paramCID);
 
-                /* TBD: add check for fused out Masters */
-                if (masterConfig.support != hw_mbox_support_none)
-                {
-                    MASTER_SET_VALID(paramMID, True);
-                }
+                continue; /* invalid configuration skip this channel */
             }
-            
-            /* INIT static channels: */
-            DPRINTK("Initializing %d static channels", HW_MBOX_STATIC_CHANNEL_COUNT);
-            for (i = 0; i < HW_MBOX_STATIC_CHANNEL_COUNT; i++)
-            {
-                memcpy(&chnConfig, &HW_MBOX_STATIC_CHANNEL_GET_CONFIG(i), HW_MBOX_CHANNEL_CONFIG_SIZE);
-                paramCID = chnConfig.cid;
 
-                DPRINTK("static channel entry %d (cid=%d): mboxType=%d, commander=%d, subject=%d, memSize=%uB",
-                        i, paramCID, chnConfig.mboxType, chnConfig.commander, chnConfig.subject, chnConfig.memBuff.size);
+            /* check that CID is not yet allocated: */
+            if (HW_MBOX_CHN_CFG_VALID_GET(paramCID))
+            {
+                /* CHN_CFG is valid... This CID has already been assigned! */
+                PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! CID already assigned!",
+                            i, paramCID);
 
-                /* First we should check if the configuration is valid: */
-                DPRINTK("static channel entry %d (cid=%d): verifying configuration...", i, paramCID);
+                continue; /* invalid configuration skip this channel */
+            }
 
-                /* check that both Masters are Valid */
-                if ((!IS_MASTER_VALID(chnConfig.commander)) ||
-                    (!IS_MASTER_VALID(chnConfig.subject)))
+            if (paramCID == HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR)
+            {
+                /* We can't allocate CID that's used for error notification with supervisor as Commmander/Subject  */
+                if ((chnConfig.commander == HW_MBOX_MID) || (chnConfig.subject == HW_MBOX_MID))
                 {
-                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! One of the Masters is invalid!",
-                                i, paramCID);
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! Notify Error CID %d can't be allocated with supervisor as Commander/Subject!",
+                                i, paramCID, HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
 
                     continue; /* invalid configuration skip this channel */
                 }
 
-                /* check that CID is not yet allocated: */
-                if (HW_MBOX_CHN_CFG_VALID_GET(paramCID))
+#ifdef HW_MBOX_MONITOR
+                /* If Supervisor is also Monitor we can't allocate CID that's used for error notification at all! */
+                if (IS_MONITOR())
                 {
-                    /* CHN_CFG is valid... This CID has already been assigned! */
-                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! CID already assigned!",
-                                i, paramCID);
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! Notify Error CID %d can't be allocated at ALL if supervisor is also Monitor!",
+                                i, paramCID, HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
 
                     continue; /* invalid configuration skip this channel */
                 }
+#endif /* HW_MBOX_MONITOR */
+            }
 
-                if (paramCID == HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR)
-                {
-                    /* We can't allocate CID that's used for error notification with supervisor as Commmander/Subject  */
-                    if ((chnConfig.commander == HW_MBOX_MID) || (chnConfig.subject == HW_MBOX_MID))
-                    {
-                        PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! Notify Error CID %d can't be allocated with supervisor as Commander/Subject!",
-                                    i, paramCID, HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
-
-                        continue; /* invalid configuration skip this channel */
-                    }
-
-#ifdef HW_MBOX_MONITOR
-                    /* If Supervisor is also Monitor we can't allocate CID that's used for error notification at all! */
-                    if (IS_MONITOR())
-                    {
-                        PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! Notify Error CID %d can't be allocated at all if supervisor is also Monitor!",
-                                    i, paramCID, HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
+            if ((chnConfig.memBuff.size % HW_MBOX_SRAM_CHUNK) != 0)
+            {
+                PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! SRAM size must be an integral Multiple of %dB (requested Size = %uB)",
+                            i, paramCID, HW_MBOX_SRAM_CHUNK, chnConfig.memBuff.size);
 
-                        continue; /* invalid configuration skip this channel */
-                    }
-#endif /* HW_MBOX_MONITOR */
-                }
+                continue; /* invalid configuration skip this channel */
+            }
 
-                if ((chnConfig.memBuff.size % HW_MBOX_SRAM_CHUNK) != 0)
+            if (chnConfig.mboxType == hw_mbox_event)
+            {
+                if (chnConfig.memBuff.size == 0)
                 {
-                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! sram size must be an integral Multiple of %d (requested Size=%uB)",
-                                i, paramCID, chnConfig.memBuff.size, HW_MBOX_SRAM_CHUNK);
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! for event channels SRAM size must be > 0 [for event Buffer] (requested Size = %uB)",
+                                i, paramCID, chnConfig.memBuff.size);
 
                     continue; /* invalid configuration skip this channel */
                 }
-
-                if (chnConfig.mboxType == hw_mbox_event)
+                if ((chnConfig.memBuff.size / HW_MBOX_SRAM_CHUNK) % 2 != 0)
                 {
-                    if (chnConfig.memBuff.size == 0)
-                    {
-                        PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! for event channels sram size must be > 0 [for event Buffer] (requested Size=%uB)",
-                                    i, paramCID, chnConfig.memBuff.size);
-
-                        continue; /* invalid configuration skip this channel */
-                    }
-                    if ((chnConfig.memBuff.size / HW_MBOX_SRAM_CHUNK) % 2 != 0)
-                    {
-                        PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! for event channels sram size must be an evenly divisible amount of %dB chunks (requested Size=%uB)",
-                                    i, paramCID, HW_MBOX_SRAM_CHUNK, chnConfig.memBuff.size);
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! for event channels SRAM size must be an evenly divisible amount of %dB chunks (requested Size = %uB)",
+                                i, paramCID, HW_MBOX_SRAM_CHUNK, chnConfig.memBuff.size);
 
-                        continue; /* invalid configuration skip this channel */
-                    }
+                    continue; /* invalid configuration skip this channel */
                 }
-
-                if (chnConfig.memBuff.size > GET_FREE_SRAM_LEFT())
+            }
+            else if (chnConfig.mboxType == hw_mbox_opcode)
+            {
+                if (chnConfig.memBuff.size < HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES)
                 {
-                    PRINTK_ERR("static channel entry %d (cid=%d): Cannot be configured! Not enough SRAM memory Left (requested Size=%uB, free SRAM left=%uB)!", 
-                               i, paramCID, chnConfig.memBuff.size, GET_FREE_SRAM_LEFT());
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! for opcode channels SRAM size must be >= %dB (requested Size = %uB)",
+                                i, paramCID, HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES, chnConfig.memBuff.size);
 
-                    continue; /* error, not more memory left! skip this channel */
+                    continue; /* invalid configuration skip this channel */
                 }
+            }
 
-                /* If we are here the channel configuration is OK we can proceed in setting up the HW_MBOX channel
-                   registers with its configuration. */
-                HW_MBOX_CHANNEL_CONFIG_SET(paramCID, chnConfig.mboxType, 0 /* reqId is not used yet */, chnConfig.commander, chnConfig.subject);
+            if (chnConfig.memBuff.size > GET_FREE_SRAM_LEFT())
+            {
+                PRINTK_ERR("static channel entry %d (cid=%d): Cannot be configured! Not enough SRAM memory Left (requested Size = %uB, free SRAM left = %uB)!",
+                           i, paramCID, chnConfig.memBuff.size, GET_FREE_SRAM_LEFT());
 
-                if (chnConfig.memBuff.size > 0)
-                {
-                    DPRINTK("static channel entry %d (cid=%d): current Nonallocated SRAM Offset=0x%08x, need %uB of SRAM", 
-                            i, paramCID, GET_NEXT_ALLOCATION_SRAM_OFFSET(), chnConfig.memBuff.size);
+                continue; /* error, not more memory left! skip this channel */
+            }
 
-                    chnConfig.memBuff.start = GET_NEXT_ALLOCATION_SRAM_OFFSET();
+            /* If we are here the channel configuration is OK we can proceed in setting up the HW_MBOX channel
+               registers with its configuration. */
+            HW_MBOX_CHANNEL_CONFIG_SET(paramCID, chnConfig.mboxType, 0 /* reqId is not used yet */, chnConfig.commander, chnConfig.subject);
 
-                    ALLOCATE_SRAM(paramCID, chnConfig.memBuff.size);
+            if (chnConfig.memBuff.size > 0)
+            {
+                DPRINTK("static channel entry %d (cid=%d): current Nonallocated SRAM Offset=0x%08x, need %uB of SRAM",
+                        i, paramCID, GET_NEXT_ALLOCATION_SRAM_OFFSET(), chnConfig.memBuff.size);
 
-                    DPRINTK("static channel entry %d (cid=%d): %uB of SRAM allocated, new current Nonallocated SRAM Offset=0x%08x",
-                            i, paramCID, chnConfig.memBuff.size, GET_NEXT_ALLOCATION_SRAM_OFFSET());
+                chnConfig.memBuff.start = GET_NEXT_ALLOCATION_SRAM_OFFSET();
 
-                    /* We would have liked to reset channel's SRAM if we are Commander,
-                       but it is impossible to do so at this point since START is not set...
-                       it will be done later in this function... */
-                }
+                ALLOCATE_SRAM(paramCID, chnConfig.memBuff.size);
 
-                HW_MBOX_CHN_CFG_VALID_SET(paramCID, True);
+                DPRINTK("static channel entry %d (cid=%d): %uB of SRAM allocated, new current Nonallocated SRAM Offset=0x%08x",
+                        i, paramCID, chnConfig.memBuff.size, GET_NEXT_ALLOCATION_SRAM_OFFSET());
 
-                hwMbox_setChannelConfig(chnConfig);
+                /* We would have liked to reset channel's SRAM if we are Commander,
+                   but it is impossible to do so at this point since START is not set...
+                   it will be done later in this function... */
+            }
 
-                if (!CHN_IS_RECV_OP(paramCID))
-                {
-                    hwMbox_setChannelValid(paramCID, True); /* also updates LUTs */
+            HW_MBOX_CHN_CFG_VALID_SET(paramCID, True);
 
-                    /* for recv Op channel valid is set by listener... */
-                }
+            hwMbox_setChannelConfig(chnConfig);
 
-                DPRINTK("configured new static channel (cid=%d): %s MBOX, %s(%d) -> %s(%d) [%uB of SRAM]",
-                        paramCID, HW_MBOX_TYPE_STR(chnConfig.mboxType),
-                        HW_MBOX_MASTER_GET_NAME(chnConfig.commander), chnConfig.commander,
-                        HW_MBOX_MASTER_GET_NAME(chnConfig.subject), chnConfig.subject,
-                        chnConfig.memBuff.size);
-            }
+            if (!CHN_IS_RECV_OP(paramCID))
+            {
+                hwMbox_setChannelValid(paramCID, True); /* also updates LUTs */
 
-            /* Now that all configuration values and static channels are set we can set start! */
-            PRINTK_INFO("initial configuration completed, setting START!");
-            HW_MBOX_CTRL_START_SET(True);
+                /* for recv Op channel valid is set by listener... */
+            }
 
-            CTRL_SET_IS_STARTED(True);
+            DPRINTK("configured new static channel (cid=%d): %s MBOX, %s(%d) -> %s(%d) [%uB of SRAM]",
+                    paramCID, HW_MBOX_TYPE_STR(chnConfig.mboxType),
+                    HW_MBOX_MASTER_GET_NAME(chnConfig.commander), chnConfig.commander,
+                    HW_MBOX_MASTER_GET_NAME(chnConfig.subject), chnConfig.subject,
+                    chnConfig.memBuff.size);
         }
-        else
-        {
-            /* non-supervisor and HW MBOX is not yet started... */
-            DPRINTK("continue configuration upon first interrupt from supervisor...");
-
-            /* Create the first receive opcode listener, it'll wait for the
-               first interrupt from supervisor (INIT_COMPLETE) */
+    }
+    else
+    {
+        /* non-supervisor and HW MBOX is not yet started... */
+        DPRINTK("continue configuration upon first interrupt from supervisor...");
 
-            RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX) = kthread_run(hwMbox_recvOpcodeListenerEntry,
-                                                                          &RECV_OP_THREAD_DATA(RECV_OPCODE_INIT_INDEX),
-                                                                          RECV_OPCODE_LISTENER_PREFIX"%02d",
-                                                                          RECV_OPCODE_INIT_INDEX);
+        /* Create the first receive opcode listener, it'll wait for the
+           first interrupt from supervisor (INIT_COMPLETE) */
 
-            if (IS_ERR(RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX)))
-            {
-                retVal = PTR_ERR(RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX));
-                PRINTK_ERR("Creating %s%02d used for initialization Failed!!! [error %d]",
-                           RECV_OPCODE_LISTENER_PREFIX, RECV_OPCODE_INIT_INDEX, retVal);
+        RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX) = kthread_run(hwMbox_recvOpcodeListenerEntry,
+                                                                      &RECV_OP_THREAD_DATA(RECV_OPCODE_INIT_INDEX),
+                                                                      RECV_OPCODE_LISTENER_PREFIX"%02d",
+                                                                      RECV_OPCODE_INIT_INDEX);
+
+        if (IS_ERR(RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX)))
+        {
+            retVal = PTR_ERR(RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX));
+            PRINTK_ERR("Creating %s%02d used for initialization Failed!!! [error %d]",
+                       RECV_OPCODE_LISTENER_PREFIX, RECV_OPCODE_INIT_INDEX, retVal);
 
-                PRINTK_ERR("*** CRITICAL ERROR in HW MBOX initialization, no HW MBOX services will be avaiable ***");
+            PRINTK_ERR("*** CRITICAL ERROR in HW MBOX initialization, no HW MBOX services will be avaiable ***");
 
-                RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX) = NULL;
+            RECV_OP_THREAD_BY_INDEX(RECV_OPCODE_INIT_INDEX) = NULL;
 
-                /* HW MBOX initialization cannot continue... */
-                return (-1);
-            }
+            /* HW MBOX initialization cannot continue... */
+            return (-1);
         }
     }
 
-#if defined HW_MBOX_IS_NP_CPU
     /* Setup ISR: */
-    if (request_irq(HW_MBOX_INT_LINE, hw_mbox_drv_isr, IRQF_TRIGGER_HIGH, HW_MBOX_INT_NAME, NULL /* no need for dev as line is not shared */))
+#if defined HW_MBOX_IS_NP_CPU
+    if (request_irq(HW_MBOX_INT_LINE, hwMbox_drv_isr, IRQF_TRIGGER_HIGH, HW_MBOX_INT_NAME, NULL /* no need for dev as line is not shared */))
     {
         PRINTK_ERR("Unable to allocate IRQ!");
         return -ENODEV;
@@ -3819,7 +4034,7 @@ static int __init hw_mbox_drv_init_modul
 #elif defined HW_MBOX_IS_APP_CPU
     {
        netss_subdev_irq_info_t irq_info;
-       irq_info.func = &hw_mbox_drv_isr;
+       irq_info.func = &hwMbox_drv_isr;
        irq_info.args = &hwMboxDriverData;
        netss_subdev_register_irq(NETSS_HW_MAILBOX, &irq_info);
     }
@@ -3827,17 +4042,29 @@ static int __init hw_mbox_drv_init_modul
 
     if (IS_SUPERVISOR())
     {
+        /* Now that all configuration values and static channels are set,
+           and Supervisor Driver is ready after ISR setup we can set START! */
+        PRINTK_INFO("initial configuration completed, setting START!");
+        HW_MBOX_CTRL_START_SET(True);
+
+        CTRL_SET_IS_STARTED(True);
+
         /* Now that everything is ready send interrupt to all valid Masters: */
+        DPRINTK("send INIT_COMPLETE command to valid masters...");
+
+        /* Prepare the INIT_COMPLETE message: */
+        opcodeMsg.msgType = HW_MBOX_OPCODE_MESSAGE_TYPE_CODE;
+        opcodeMsg.msgData.msgCode.code = HW_MBOX_CODE_INIT_COMPLETE;
 
-        DPRINTK("send IS_INIT_COMPLETE command to valid masters...");
+        /* Build the opcode: */
+        opFlds.tag = HW_MBOX_OPCODE_TAG;
+        opFlds.lenInBytes = HW_MBOX_OPCODE_MESSAGE_SIZE;
 
-        cmdRegVal = 0;
-        cmdRegVal = HW_MBOX_OPCODE_SET_TAG(cmdRegVal, HW_MBOX_OPCODE_TAG);
-        cmdRegVal = HW_MBOX_OPCODE_SET_CODE(cmdRegVal, HW_MBOX_CODE_INIT_COMPLETE);
-
-        /* Flags are currently reserved! */
-        cmdRegVal = HW_MBOX_OPCODE_SET_FLAG_A(cmdRegVal, 0);
-        cmdRegVal = HW_MBOX_OPCODE_SET_FLAG_B(cmdRegVal, 0);
+        /* Create the opcode value: */
+        HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT(cmdRegVal, &opFlds);
+
+        DPRINTK("opcode fields - tag=%u, lenInBytes=%u -> cmdRegVal=0x%08x",
+                opFlds.tag, opFlds.lenInBytes, cmdRegVal);
 
         for (paramMID = 0; paramMID < HW_MBOX_MASTER_COUNT; paramMID++)
         {
@@ -3851,12 +4078,23 @@ static int __init hw_mbox_drv_init_modul
                     continue;
                 }
 
-                paramCID = FIND_CID_IN_LUT(paramMID, hw_mbox_opcode, False);
+                paramCID = FIND_CID_IN_LUT(paramMID, hw_mbox_opcode, CID_LUT_PEER_IS_SUBJECT);
                 if (paramCID != HW_MBOX_CID_INVALID)
                 {
-                    /* Set a special flag so that ISR can identify it's an INIT channel */
-                    DPRINTK("using cid %d as INIT CID master %d, sending command 0x%08x", paramCID, paramMID, cmdRegVal);
+                    /* Set a special flag so that ISR can identify it's an INIT channel: */
+                    DPRINTK("using cid %d as INIT CID master %d, sending opcode message", paramCID, paramMID);
                     CHN_SET_INIT(paramCID, True);
+
+                    DPRINTK("cid %d: copying %uB [out of total %uB channel has] to SRAM at offset=0x%08x",
+                            paramCID, opFlds.lenInBytes, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+                    /* Send the opcode message: */
+                    HW_MBOX_COPY_TO_SRAM(&opcodeMsg,
+                                         opFlds.lenInBytes,
+                                         CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+                    DPRINTK("using cid %d as INIT CID master %d, sending cmdRegVal=0x%08x", paramCID, paramMID, cmdRegVal);
+
                     HW_MBOX_CHN_COMMAND_REG_SET(paramCID, cmdRegVal);
                 }
                 else
@@ -3921,26 +4159,55 @@ static int __init hw_mbox_drv_init_modul
         SET_INITIALIZED();
     }
 
+#ifdef HW_MBOX_IS_APP_CPU
+    if (!IS_SUPERVISOR())
+    {
+        /* APP-CPU and Non-Supervisor:
+           If APP-CPU is not the supervisor there can be set bits in the
+           Interrupt Status Registers prior to setting up the ISR. In this
+           case the sent MSI message will not be intercepted. To make the
+           bridge sample the Interrupt Status Registers again a mask/Un-mask
+           of the interrupts will be performed. Should there be any set bits
+           then a new MSI message will be sent [and now ISR is properly setup].
+        */
+
+        DPRINTK("APP-CPU: Disabling all interrupts!");
+        HW_MBOX_DISABLE_ALL_INTERRUPTS();
+
+        DPRINTK("APP-CPU: intrMaskRegs(H L): 0x%08x 0x%08x",
+                HW_MBOX_MASTER_INTR_MASK_H_REG_GET()
+                HW_MBOX_MASTER_INTR_MASK_L_REG_GET());
+
+        DPRINTK("APP-CPU: Enabling all interrupts!");
+        HW_MBOX_ENABLE_ALL_INTERRUPTS();
+    }
+#endif /* HW_MBOX_IS_APP_CPU */
+
     return 0;
 }
 
-static void __exit hw_mbox_drv_exit(void)
+/**************************************************************************/
+/*! \fn void __exit hwMbox_drv_exit(void)
+ **************************************************************************
+ *  \brief HW_MBOX driver exit function.
+ *  \return VOID.
+ **************************************************************************/
+static void __exit hwMbox_drv_exit(void)
 {
 #if defined HW_MBOX_IS_NP_CPU
-   free_irq(HW_MBOX_INT_LINE, NULL);
+    free_irq(HW_MBOX_INT_LINE, NULL);
 #elif defined HW_MBOX_IS_APP_CPU
-   netss_subdev_irq_info_t irq_info;
-   irq_info.func = NULL;
-   irq_info.args = NULL;
-   netss_subdev_register_irq(NETSS_HW_MUTEX, &irq_info);
-   iounmap(hwMboxDriverData.reg_base);
-
+    netss_subdev_irq_info_t irq_info;
+    irq_info.func = NULL;
+    irq_info.args = NULL;
+    netss_subdev_register_irq(NETSS_HW_MAILBOX, &irq_info);
+    iounmap(hwMboxDriverData.reg_base);
 #endif
    chnint_cleanup(HW_MBOX_CHANNEL_COUNT);
 }
 
-subsys_initcall(hw_mbox_drv_init_module);
-module_exit(hw_mbox_drv_exit);
+subsys_initcall(hwMbox_drv_init);
+module_exit(hwMbox_drv_exit);
 
 /* Driver identification: */
 MODULE_DESCRIPTION(DRV_NAME);
--- a/arch/x86/hw_mailbox/hw_mbox_mem_access.h
+++ b/arch/x86/hw_mailbox/hw_mbox_mem_access.h
@@ -72,23 +72,22 @@
 #define _HW_MBOX_MEM_ACCESS_H_
 
 /************************************
-              INCLUDES:              
+|             INCLUDES:             |
 ************************************/
 
 /* Include Always: */
-#include "hw_mbox_defs.h"   /* for HW_MBOX_MID, HW_MBOX_CONCAT and Generic types */
+#include <linux/hw_mbox_defs.h>   /* for HW_MBOX_MID, HW_MBOX_CONCAT and Generic types */
 
 /* The following Included files are Determined Accordingly to OS and Master: */
+
 #ifdef HW_MBOX_OS_LINUX
 #ifdef __KERNEL__
 /* Kernel: */
 #include <linux/byteorder/generic.h>    /* Endianness: cpu_to_be32, be32_to_cpu */
 #include <linux/string.h>               /* for memcpy\memset used in SRAM access */
-#if   defined HW_MBOX_IS_NP_CPU
+#ifdef HW_MBOX_IS_NP_CPU
 #include "puma7.h"    /* for NP_CPU Kernel HW_MBOX Base Address */
-#elif defined HW_MBOX_IS_APP_CPU
-/* include file with Kernel HW_MBOX Base Address for APP CPU */
-#endif
+#endif /* HW_MBOX_IS_NP_CPU */
 #else
 /* User Space: */
 #include "endian.h"     /* Endianness: htobe32, be32toh */
@@ -98,8 +97,8 @@
 #ifdef HW_MBOX_OS_FLAT
 /* FLAT OS: */
 #include "string.h"    /* for memcpy\memset used in SRAM access */
-#if defined HW_MBOX_IS_DS_PHY_CPU
-#include "phy_cpu_defs.h"    /* for base address of the HW_MBOX and Endianness Configuration */
+#if defined HW_MBOX_IS_PHY_CPU
+#include "global_defines.h"    /* for base address of the HW_MBOX */
 #endif
 #endif /* HW_MBOX_OS_FLAT */
 
@@ -118,7 +117,7 @@
    2. MAP HW_MBOX REGISTERS FIELDS:
       Map the Fields in the HW_MBOX registers (bit Offset and bit Length).
 
-   3. DEFINE BASIC OPERATIONS: 
+   3. DEFINE BASIC OPERATIONS:
       Define basic Macros to read and write 32 register values, handle Endianness
       and access specific bit fields.
 
@@ -127,7 +126,7 @@
       get/set field32 and set bit32 with a specific template.
 
       If direct access can be used and the base address is known in advance (i.e. Linux
-      Kernel) then these will be defined here. 
+      Kernel) then these will be defined here.
 
       Otherwise (Indirect access) matching name Macros must be defined in the file that
       can handle the access (i.e. hw_mbox_hal for Linux User Space application access).
@@ -138,7 +137,7 @@
 
    5. SPECIFIC REGISTERS & FIELDS ACCESS MACROS:
       Define Get/Set Macros for all registers and Fields utilizing the generic Macros
-      (set up at 4) and the basic operations (set up at 3). Using the generic Macros 
+      (set up at 4) and the basic operations (set up at 3). Using the generic Macros
       and basic operation enables to define these once.
 */
 
@@ -149,20 +148,20 @@
 |                                            |
 *********************************************/
 
-/* 
+/*
     Each Master has a different Address space to access to HW_MBOX memory (Registers and SRAM).
     The HW_MBOX determines which Master is Accessing it according to the address used. Using
     this information the HW_MBOX can enforce Access Protection.
- 
+
     This section includes the calculation of the proper offsets to be used by every Master.
- 
+
     Under normal conditions the MID is predetermined, therefore most of the calculations will
     be optimized under "constant folding". This excludes Macros that we want to receive a
     parameter such as the channel register offsets (one define that will work for all channels).
- 
+
     Another exception will be the Debug feature "MID Disguise": Under this feature we add the
     option to change the MID on the fly, during runtime.
- 
+
     There are 4 groups (types) of registers:
     1. Control Registers - contains general information regarding the HW_MBOX setup (shared among Masters).
     2. Master Registers - contains information relevant for each Master (one set per Master).
@@ -170,11 +169,11 @@
     4. Memory Map Registers - contains SRAM allocated to each Master (one register per Channel).
 
     The Address to be used can be Mapped using the Following table (relative to HW_MBOX Base Address):
- 
+
                            +------------------------------------------------------------------------------------+
-      USAGE          bits  | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |    
+      USAGE          bits  | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
     +----------------------+------------------------------------------------------------------------------------+
-    | Control Registers    |  ACCESS MODIFIER  |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  INTERNAL OFFSET  |  
+    | Control Registers    |  ACCESS MODIFIER  |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  INTERNAL OFFSET  |
     +-----------------------------------------------------------------------------------------------------------+
     | Master Registers     |  ACCESS MODIFIER  |  0 |  0 |  1 |  MID SUBGROUP     |            INTERNAL OFFSET  |
     +-----------------------------------------------------------------------------------------------------------+
@@ -184,12 +183,12 @@
     +-----------------------------------------------------------------------------------------------------------+
     | SRAM                 |  ACCESS MODIFIER  |  1 |            SRAM OFFSET                                    |
     +-----------------------------------------------------------------------------------------------------------+
- 
+
     ACCESS MODIFIER is the MID of the Master performing the Access to the HW_MBOX.
     SUBGROUP values are determined according to which Channel or Master we are observing (CID/MID).
     GROUP_OFFSET (denoted later on) are the value of bits [12:10].
-    SRAM_INTERNAL_OFFSET (denoted later on) is (bit(12) = 1) for SRAM.  
-*/ 
+    SRAM_INTERNAL_OFFSET (denoted later on) is (bit(12) = 1) for SRAM.
+*/
 
 #ifdef HW_MBOX_DEBUG
 /* MID Disguise feature:
@@ -209,7 +208,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
 
 /*! \def __HW_MBOX_DEBUG_SET_MID(newMID)
     \brief set Debug MID to <newMID>.
-    \warning Must Use a Valid MID! 
+    \warning Must Use a Valid MID!
 */
 #define __HW_MBOX_DEBUG_SET_MID(newMID)  ( __debug_HW_MBOX_MID = (newMID) )
 #endif /* HW_MBOX_DEBUG */
@@ -255,11 +254,11 @@ extern volatile Uint32 __debug_HW_MBOX_M
 #define HW_MBOX_REGDEFS_MEMORY_MAP_INTERNAL_OFFSET    (0x0)
 
 /******************************************
-        Register Offset Calculation        
+|       Register Offset Calculation       |
 ******************************************/
 
 /* Now to do the actual calculation of the Offsets:
- 
+
    OFFSET = ACCESS_MODIFIER + GROUP_OFFSET + [Optional] SUBGROUP_OFFSET + INTERNAL_OFFSET
 
    ACCESS_MODIFIER: According to current MID, translates the request to specific Master's Address Space
@@ -304,15 +303,15 @@ extern volatile Uint32 __debug_HW_MBOX_M
 /* --- Memory Map Registers --- */
 #define HW_MBOX_REGDEFS_MEMORY_MAP_OFFSET(paramCID) ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MEMORY_MAP_GROUP_OFFSET + HW_MBOX_REGDEFS_MMAP_SUBGROUP_OFFSET(paramCID) + HW_MBOX_REGDEFS_MEMORY_MAP_INTERNAL_OFFSET )
 
-/***************************************************
-        Parametric Master Registers Mapping        
-***************************************************/
+/**************************************************
+|       Parametric Master Registers Mapping       |
+**************************************************/
 
 /* These are defined for the purpose of accessing other Master's Master Registers.
    Generally speaking each Master should only involve itself with its own Master Registers.
    Still we should map these as we might need to read their values for research purposes.
    Unless In Package Debug We avoid mapping the interrupt status registers as access to them might prove to be disastrous.
- 
+
    NOTE: The access is done from the MID associated with the current Master!
 */
 
@@ -326,7 +325,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
 #define HW_MBOX_REGDEFS_MASTER_PARAM_SUBJECT_H_OFFSET(paramMID)     ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(paramMID) + HW_MBOX_REGDEFS_MASTER_SUBJECT_H_INTERNAL_OFFSET )
 
 /*******************************************
-        HW_MBOX SRAM Address Mapping        
+|       HW_MBOX SRAM Address Mapping       |
 *******************************************/
 
 #define HW_MBOX_MEMDEFS_SRAM_INTERNAL_OFFSET    (0x1000)  /*!  bit(12) = 1  */
@@ -340,7 +339,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
 #define HW_MBOX_SRAM_SIZE    (0x1000)  /*! 4KB SRAM (total actual size) */
 
 /**********************************************
-        HW_MBOX Special Address Mapping        
+|       HW_MBOX Special Address Mapping       |
 **********************************************/
 
 /*! \def HW_MBOX_REGDEFS_CTRL_AS_DEFAULT_SUPERVISOR_OFFSET
@@ -359,7 +358,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
 
 /* This Section will list all the HW_MBOX registers structure, followed
    by a declaration (via #define) of the bit offset and bit length of each
-   field. 
+   field.
 
    Please note that we will use a constant naming template for all #defines:
    field bit offset: #define HW_MBOX_<fieldName>_OFFSET
@@ -369,7 +368,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
 */
 
 /********************************
-        CONTROL REGISTERS        
+|       CONTROL REGISTERS       |
 ********************************/
 
 /* These registers contain general control data and settings of the HW_MBOX. */
@@ -400,7 +399,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
     |   RO            | RW        | RW      | RWO  | RW    | RW    | RW         |
     +---------------------------------------------------------------------------/
 
-    NOTE: only the supervisor should write to this register (preferably) until 
+    NOTE: only the supervisor should write to this register (preferably) until
           setting START=TRUE. Once setting LOCK=TRUE the register is RO.
 
     MON_EXIST - 0 indicates that there is no Monitor.
@@ -414,8 +413,8 @@ extern volatile Uint32 __debug_HW_MBOX_M
     DEBUG - 1 indicates that the MBOX is in debug mode, enabling any Master
             to access MBOX registers without limitations.
 
-    START - 1 indicates that the MBOX is configured and functional. 
-            0 indicates that the MBOX is not configured yet, and the Channels cannot 
+    START - 1 indicates that the MBOX is configured and functional.
+            0 indicates that the MBOX is not configured yet, and the Channels cannot
               be used by the Masters.
 
     SUPERVISOR - MID of the Supervisor.
@@ -439,7 +438,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
    some prefix to make it more understandable. */
 
 #define HW_MBOX_FLDDEFS_START_OFFSET (4)
-#define HW_MBOX_FLDDEFS_START_LENGTH (1) 
+#define HW_MBOX_FLDDEFS_START_LENGTH (1)
 
 #define HW_MBOX_FLDDEFS_SUPERVISOR_OFFSET (0)
 #define HW_MBOX_FLDDEFS_SUPERVISOR_LENGTH (4)
@@ -462,7 +461,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
           the protection rules. By default ERR=0.
 */
 
-/* Adding the word ERROR even though the Field 
+/* Adding the word ERROR even though the Field
    is called COUNT to make it more understandable. */
 #define HW_MBOX_FLDDEFS_ERROR_COUNT_OFFSET  (8)
 #define HW_MBOX_FLDDEFS_ERROR_COUNT_LENGTH  (8)
@@ -473,7 +472,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
 #define HW_MBOX_FLDDEFS_ERRMID_LENGTH  (4)
 
 /*******************************
-        MASTER REGISTERS        
+|       MASTER REGISTERS       |
 *******************************/
 
 /* These Registers contain data related to the Masters. There's a set of these registers
@@ -482,7 +481,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
    These Registers do not contain fields per say, but rather each pair (*_L and *_H) of
    them is divided into 64 one bit fields. Each field signifies the Channel with a CID
    corresponding to the position of the set bit [CID = (is *_H reg)*32 + (bit position)].
-   Thus, there's no need to define specific fields here. 
+   Thus, there's no need to define specific fields here.
 
 */
 
@@ -512,7 +511,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
     |   RW                                                                      |
     +---------------------------------------------------------------------------/
 
-    These Registers enable to Mask channels from triggering an interrupt for this 
+    These Registers enable to Mask channels from triggering an interrupt for this
     MASTER (according to which bits are set).
 
     NOTE: a common use of these will be masking a channel in order to use polling.
@@ -526,7 +525,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
     |   RW                                                                      |
     +---------------------------------------------------------------------------/
 
-    These are Shadow registers of the interrupt status ones. Can be used for probing 
+    These are Shadow registers of the interrupt status ones. Can be used for probing
     the Interrupt status registers without triggering the write after read. These
     are also used when polling is desired.
 
@@ -564,10 +563,10 @@ extern volatile Uint32 __debug_HW_MBOX_M
 */
 
 /********************************
-        CHANNEL REGISTERS        
+|       CHANNEL REGISTERS       |
 ********************************/
 
-/* These registers contain data related to the channels. There's a set of these for 
+/* These registers contain data related to the channels. There's a set of these for
    each channel. */
 
 /* --------------------------------------------------------------------------- */
@@ -580,7 +579,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
 
     This Register Holds the configuration of the Channel.
 
-    NOTE: only the supervisor has write access to this register and only when 
+    NOTE: only the supervisor has write access to this register and only when
           CTRL.START=FALSE or when CTRL.START=TRUE and VALID=FALSE.
 
     VALID - 1 indicates valid configuration.
@@ -611,7 +610,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
     SUBJECT - MID of the Subject Master.
 */
 
-/* Adding the word CHN even though the Fields 
+/* Adding the word CHN even though the Fields
    don't have it to make it more understandable. */
 
 #define HW_MBOX_FLDDEFS_CHN_VALID_OFFSET (31)
@@ -653,29 +652,29 @@ extern volatile Uint32 __debug_HW_MBOX_M
     |   RW                                                            |  RW     |
     +---------------------------------------------------------------------------/
 
-    NOTE: only the supervisor has write access to this register and can do so 
+    NOTE: only the supervisor has write access to this register and can do so
           at any time (even when CTRL.LOCK=TRUE). Any write to this register will
-          reset the channel (Channel goes back to state ready and any possibly 
+          reset the channel (Channel goes back to state ready and any possibly
           pending interrupt is cleared).
 
     STATE - Possible values are:
             Ready=0, Pending=1, Consume=2, Done=3.
 */
 
-/* Adding the word CHN even though the Fields 
+/* Adding the word CHN even though the Fields
    don't have it to make it more understandable. */
 
 #define HW_MBOX_FLDDEFS_CHN_STATE_OFFSET (0)
 #define HW_MBOX_FLDDEFS_CHN_STATE_LENGTH (2)
 
 /***********************************
-        MEMORY MAP REGISTERS        
+|       MEMORY MAP REGISTERS       |
 ***********************************/
 
-/* There's one Memory Map Register per channel. It contains the section in the 
+/* There's one Memory Map Register per channel. It contains the section in the
    HW_MBOX SRAM that is allocated to this channel. According to this and the
-   values listed in the CHN_CFG register access protection is enforced (only 
-   the COMMANDER and SUBJECT of the channel may access the allocated SRAM 
+   values listed in the CHN_CFG register access protection is enforced (only
+   the COMMANDER and SUBJECT of the channel may access the allocated SRAM
    section). */
 
 /* --------------------------------------------------------------------------- */
@@ -686,7 +685,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
     | RW       |    RW                    |  RO      |    RW                    |
     +---------------------------------------------------------------------------/
 
-    NOTE: only the supervisor has write access to this register and only when 
+    NOTE: only the supervisor has write access to this register and only when
           CTRL.LOCK=FALSE.
 
     SIZE - The size in bytes of the region in SRAM allocated to Channel CID.
@@ -696,7 +695,7 @@ extern volatile Uint32 __debug_HW_MBOX_M
             the region allocated to Channel CID.
 */
 
-/* Adding the word MMAP to make it more understandable. 
+/* Adding the word MMAP to make it more understandable.
    (and prevent possible conflict with another field named START in the CTRL reg). */
 
 #define HW_MBOX_FLDDEFS_MMAP_SIZE_OFFSET (16)
@@ -716,22 +715,23 @@ extern volatile Uint32 __debug_HW_MBOX_M
    to define the more complex access function to the HW_MBOX memory. */
 
 /*******************************
-        Basic Mem Access        
+|       Basic Mem Access       |
 *******************************/
-#ifdef HW_MBOX_IS_APP_CPU
-#define HW_MBOX_REG32_READ(address)                  ( HW_MBOX_CONVERT_FROM_BIG_ENDIAN32(__raw_readl(address)) )
-#define HW_MBOX_REG32_WRITE(address, value)          (__raw_writel( HW_MBOX_CONVERT_TO_BIG_ENDIAN32(value), address) )
-#else
+
+#ifndef HW_MBOX_IS_APP_CPU
 #define HW_MBOX_REG32(address)                  ( *(volatile Uint32 *)(address) )
 #define HW_MBOX_REG32_READ(address)             ( HW_MBOX_CONVERT_FROM_BIG_ENDIAN32(HW_MBOX_REG32(address)) )
 #define HW_MBOX_REG32_WRITE(address, value)     ( (HW_MBOX_REG32(address)) = (HW_MBOX_CONVERT_TO_BIG_ENDIAN32(value)) )
-#endif
+#else
+#define HW_MBOX_REG32_READ(address)             ( HW_MBOX_CONVERT_FROM_BIG_ENDIAN32( __raw_readl(address)) )
+#define HW_MBOX_REG32_WRITE(address, value)     ( __raw_writel( HW_MBOX_CONVERT_TO_BIG_ENDIAN32(value), address) )
+#endif /* ! HW_MBOX_IS_APP_CPU */
 
 /********************************
-        HANDLE Endianness        
+|       HANDLE Endianness       |
 ********************************/
 
-/* HW_MBOX memory should be kept BE, all arithmetic operations 
+/* HW_MBOX memory should be kept BE, all arithmetic operations
    should be done using CPU's native endianness. */
 
 #ifdef HW_MBOX_OS_LINUX
@@ -741,29 +741,24 @@ extern volatile Uint32 __debug_HW_MBOX_M
 #else
 #define HW_MBOX_CONVERT_TO_BIG_ENDIAN32(val)    htobe32(val)
 #define HW_MBOX_CONVERT_FROM_BIG_ENDIAN32(val)  be32toh(val)
-#endif // __KERNEL__
-#endif // HW_MBOX_OS_LINUX
+#endif /* __KERNEL__ */
+#endif /* HW_MBOX_OS_LINUX */
+
 #ifdef HW_MBOX_OS_FLAT
-#if defined HW_MBOX_IS_DS_PHY_CPU
-#if     defined PHY_CPU_LITTLE_ENDIAN
-#define HW_MBOX_CONVERT_TO_BIG_ENDIAN32(val)    phy_cpu_swab32(val)
-#define HW_MBOX_CONVERT_FROM_BIG_ENDIAN32(val)  phy_cpu_swab32(val)
-#elif   defined PHY_CPU_BIG_ENDIAN
+#if defined HW_MBOX_IS_PHY_CPU
+/* PHY-CPU is BE! */
 #define HW_MBOX_CONVERT_TO_BIG_ENDIAN32(val)    (val)
 #define HW_MBOX_CONVERT_FROM_BIG_ENDIAN32(val)  (val)
-#else
-#   error "HW_MBOX mem access (PHY_CPU): endianness undefined!!!"
 #endif
-#endif // HW_MBOX_IS_DS_PHY_CPU
-#endif // HW_MBOX_OS_FLAT
+#endif /* HW_MBOX_OS_FLAT */
 
 /***********************************************
-        Bit-Field Manipulation Functions        
+|       Bit-Field Manipulation Functions       |
 ***********************************************/
 
 /*! \fn Uint32 hw_mbox_field32_get(Uint32 regData, Uint32 fieldOffset, Uint32 fieldLength)
  *  \brief gets the value of a specific bit-field from a given 32-bit value (in CPU native endianness)
- *  \param[in] regData - the value from which to extract the bit-field (in CPU native endianness) 
+ *  \param[in] regData - the value from which to extract the bit-field (in CPU native endianness)
  *  \param[in] fieldOffset - the offset (in bits) of the required bit-field
  *  \param[in] fieldLength - the number of bits in the required bit-field
  *  \return bit-field value (in CPU native endianness).
@@ -781,13 +776,13 @@ static inline Uint32 hw_mbox_field32_get
  *  \param[in] fieldOffset - the offset (in bits) of the required bit-field
  *  \param[in] fieldLength - the number of bits in the required bit-field
  *  \param[in] fieldData - the value of the bit-field to be written
- *  \return the new 32-bit value with the new field value set inside (in CPU native endianness). 
+ *  \return the new 32-bit value with the new field value set inside (in CPU native endianness).
  */
 static inline Uint32 hw_mbox_field32_set(Uint32 regData, Uint32 fieldOffset, Uint32 fieldLength, Uint32 fieldData)
 {
     Uint32 mask;
     mask = ((0xFFFFFFFF >> (32 - fieldLength)) << fieldOffset);
-    regData &= (~mask); 
+    regData &= (~mask);
     regData |= (mask & (fieldData << fieldOffset));
     return regData;
 }
@@ -801,8 +796,8 @@ static inline Uint32 hw_mbox_field32_set
 /*
     As Mentioned before regarding register Access there are 2 cases:
 
-    1. Direct Access - In this case Base Address of the HW_MBOX is always the same, Hardcoded 
-                       determined by system architecture and Low Level memory access is enabled 
+    1. Direct Access - In this case Base Address of the HW_MBOX is always the same, Hardcoded
+                       determined by system architecture and Low Level memory access is enabled
                        (i.e. Linux KERNEL of FLAT OS CPU). We can define the generic access Macros
                        here.
 
@@ -817,14 +812,14 @@ static inline Uint32 hw_mbox_field32_set
     IMPORTANT NOTE: If including this file and taking the Indirect Access route you are obliged
                     to define these Generic Access Macros with same structure (parameters and
                     functionality), the Macros that should be defined are:
-                    
+
                     HW_MBOX_REG_GET(regOffset)          returning Uint32
                     HW_MBOX_REG_SET(regOffset, value)   returning void
-                    
+
                     HW_MBOX_FIELD_GET(regOffset, fieldOffset, fieldLength)          returning Uint32
                     HW_MBOX_FIELD_SET(regOffset, fieldOffset, fieldLength, value)   returning void
 
-                    HW_MBOX_BIT_SET_VALUE(regOffset, bitPosition, bitVal)   returning void 
+                    HW_MBOX_BIT_SET_VALUE(regOffset, bitPosition, bitVal)   returning void
 
     SRAM Access:
 
@@ -838,15 +833,16 @@ static inline Uint32 hw_mbox_field32_set
 #if   defined HW_MBOX_IS_NP_CPU
 #define HW_MBOX_BASE    AVALANCHE_MAILBOX
 #elif defined HW_MBOX_IS_APP_CPU
-#define HW_MBOX_BASE hwMboxDriverData.reg_base
-#elif defined HW_MBOX_IS_DS_PHY_CPU
+/* App-CPU Kernel determines the Base address at runtime, driver should
+   define HW_MBOX_BASE as a variable that holds this mapped base address. */
+#elif defined HW_MBOX_IS_PHY_CPU
 #define HW_MBOX_BASE    PHY_CPU_HW_MBOX_BASE
 #else
-#define HW_MBOX_BASE    (0) /* TBD: MoCA/BBU/anyNoOS CPU can put it here */
+#define HW_MBOX_BASE    (0)
 #endif
 
 /******************************************************************************
-        Generic Low Level Mem Access Macro Templates For Direct Access:        
+|       Generic Low Level Mem Access Macro Templates For Direct Access:       |
 ******************************************************************************/
 
 #define HW_MBOX_REG_GET(regOffset)           HW_MBOX_REG32_READ(regOffset + HW_MBOX_BASE)
@@ -872,7 +868,7 @@ static inline Uint32 hw_mbox_field32_set
 #define HW_MBOX_COPY_TO_SRAM(pSrcBuffer, srcBufferLen, destSramOffset)   memcpy(HW_MBOX_POINTER_TO_SRAM(destSramOffset), pSrcBuffer, srcBufferLen)
 #define HW_MBOX_RESET_SRAM(sramOffset, sramLen)                          memset(HW_MBOX_POINTER_TO_SRAM(sramOffset), 0, sramLen)
 
-#endif // ((defined(HW_MBOX_OS_LINUX) && defined(__KERNEL__)) || defined(HW_MBOX_OS_FLAT) || defined(HW_MBOX_OS_NONE))
+#endif /* ((defined(HW_MBOX_OS_LINUX) && defined(__KERNEL__)) || defined(HW_MBOX_OS_FLAT) || defined(HW_MBOX_OS_NONE)) */
 
 
 /*************************************************************
@@ -884,14 +880,14 @@ static inline Uint32 hw_mbox_field32_set
 /* These are shared by both direct and Indirect due to the use of the Generic Intermediate Layer! [defined at step 4] */
 
 /*************************************
-        SINGLE BIT OPERATIONS:        
+|       SINGLE BIT OPERATIONS:       |
 *************************************/
 
 #define HW_MBOX_BIT_SET(regOffset, bitPosition)      HW_MBOX_BIT_SET_VALUE(regOffset, bitPosition, 1)
 #define HW_MBOX_BIT_UNSET(regOffset, bitPosition)    HW_MBOX_BIT_SET_VALUE(regOffset, bitPosition, 0)
 
 /********************************
-        CONTROL REGISTERS        
+|       CONTROL REGISTERS       |
 ********************************/
 
 /* --------------------------------------------------------------------------- */
@@ -978,7 +974,7 @@ static inline Uint32 hw_mbox_field32_set
 #define HW_MBOX_ERROR_ERRMID_GET()     HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_ERROR_OFFSET, HW_MBOX_FLDDEFS_ERRMID_OFFSET, HW_MBOX_FLDDEFS_ERRMID_LENGTH)
 
 /*******************************
-        MASTER REGISTERS        
+|       MASTER REGISTERS       |
 *******************************/
 
 /* These are mapped so that each Master only sees its own registers.
@@ -1029,7 +1025,7 @@ static inline Uint32 hw_mbox_field32_set
 /*! Clears bitPattern from the Interrupt Enable Mask */
 #define HW_MBOX_MASTER_INTR_MASK_H_REG_CLEAR(bitPattern) \
           HW_MBOX_MASTER_INTR_MASK_H_REG_SET(HW_MBOX_MASTER_INTR_MASK_H_REG_GET() & (~(bitPattern)))
-    
+
 /*! Masks interrupts from a specific CID (<paramCID> = [0-63]) */
 #define HW_MBOX_MASTER_INTR_MASK_CID(paramCID) \
 do{ \
@@ -1094,7 +1090,7 @@ do{ \
 #define HW_MBOX_MASTER_SUBJECT_H_REG_GET()          HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_SUBJECT_H_OFFSET)
 
 /********************************
-        CHANNEL REGISTERS        
+|       CHANNEL REGISTERS       |
 ********************************/
 
 /* --------------------------------------------------------------------------- */
@@ -1158,7 +1154,7 @@ do{ \
 #define HW_MBOX_CHN_STATE_REG_GET(paramCID)        HW_MBOX_REG_GET(HW_MBOX_REGDEFS_CHN_STATE_OFFSET(paramCID))
 
 /* Writing any value to the register resets the Channel, meaning:
-   the Channel returns to state Ready and if interrupt was issued by the Channel then the interrupt is cleared. 
+   the Channel returns to state Ready and if interrupt was issued by the Channel then the interrupt is cleared.
    Only the Supervisor is allowed to write to this register, and it can do it at any time,
    even after LOCK in MBOX_CTRL was set. */
 #define HW_MBOX_CHN_STATE_REG_SET(paramCID, value)    HW_MBOX_REG_SET(HW_MBOX_REGDEFS_CHN_STATE_OFFSET(paramCID), value)
@@ -1174,7 +1170,7 @@ do{ \
 #define HW_MBOX_CHN_STATE_DONE      3
 
 /***********************************
-        MEMORY MAP REGISTERS        
+|       MEMORY MAP REGISTERS       |
 ***********************************/
 
 /* --------------------------------------------------------------------------- */
@@ -1193,9 +1189,9 @@ do{ \
 #define HW_MBOX_MEMORY_MAP_START_GET(paramCID)           HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_MEMORY_MAP_OFFSET(paramCID), HW_MBOX_FLDDEFS_MMAP_START_OFFSET, HW_MBOX_FLDDEFS_MMAP_START_LENGTH)
 #define HW_MBOX_MEMORY_MAP_START_SET(paramCID, value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_MEMORY_MAP_OFFSET(paramCID), HW_MBOX_FLDDEFS_MMAP_START_OFFSET, HW_MBOX_FLDDEFS_MMAP_START_LENGTH, value)
 
-/*******************************************
-        Parametric Master Registers        
-*******************************************/
+/******************************************
+|       Parametric Master Registers       |
+******************************************/
 
 /* For the purpose of reading other Masters' Master registers */
 
@@ -1237,7 +1233,7 @@ do{ \
 
 #ifdef __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO
 /********************************
-        Change Supervisor        
+|       Change Supervisor       |
 ********************************/
 
 /* Since only the supervisor has write access to the HW_MBOX_CTRL register, in the case
@@ -1249,9 +1245,9 @@ do{ \
    supervisor (effectively disguising ourselves). */
 
 /*! \def HW_MBOX_CTRL_AS_DEFAULT_SUPERVISOR_SUPERVISOR_SET(newSupervisorMID)
-    \brief Change the default supervisor. 
+    \brief Change the default supervisor.
     \attention This will only work once, for the initial substitution (and assuming default supervisor is set).
-    \warning Must Use a Valid MID! 
+    \warning Must Use a Valid MID!
 */
 #define HW_MBOX_CTRL_AS_DEFAULT_SUPERVISOR_SUPERVISOR_SET(newSupervisorMID) \
           HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CTRL_AS_DEFAULT_SUPERVISOR_OFFSET, HW_MBOX_FLDDEFS_SUPERVISOR_OFFSET, HW_MBOX_FLDDEFS_SUPERVISOR_LENGTH, newSupervisorMID)
@@ -1267,37 +1263,26 @@ do{ \
 /*  --------------------------------------------------------------------------- */
 /*  HW_MBOX_REG_OPCODE
     +---------------------------------------------------------------------------+
-    | TAG             | A  | B  |    CODE                 |    LEN              |
-    | 31:24           | 23 | 22 |    21:10                |    9:0              |
-    | RW              | RW | RW |    RW                   |    RW               |
+    | SW RESERVED |  TAG                 |  SW RESERVED    |  LEN_IN_WORDS      |
+    | 31:28       |  27:16               |  15:10          |  9:0               |
+    | RW          |  RW                  |  RW             |  RW                |
     +---------------------------------------------------------------------------/
 
     NOTE: These are SW defined fields on to be used on the channel's command register.
 
     TAG - value indicating the destination of the opcode.
 
-    CODE - code of the command (per TAG, defined by applicative context).
-
-    FLAG A/B - 2 reserved flags [for internal use].
+    SW RESERVED - reserved for future SW use.
 
-    LEN - How many words are to be read from SRAM (opcode Data).
-          [LEN is integral multiple of 4 Bytes so we can use word count].
+    LEN_IN_WORDS - How many words are to be read from SRAM (opcode Data).
+                   [LEN is integral multiple of 4 Bytes so we can use word count].
 */
 
-#define HW_MBOX_OPCODE_FLDDEFS_TAG_OFFSET (24)
-#define HW_MBOX_OPCODE_FLDDEFS_TAG_LENGTH (HW_MBOX_OPCODE_TAG_BITLEN) /*! already defined in defs */
-
-#define HW_MBOX_OPCODE_FLDDEFS_FLAG_A_OFFSET (23)
-#define HW_MBOX_OPCODE_FLDDEFS_FLAG_A_LENGTH (1)
-
-#define HW_MBOX_OPCODE_FLDDEFS_FLAG_B_OFFSET (22)
-#define HW_MBOX_OPCODE_FLDDEFS_FLAG_B_LENGTH (1)
-
-#define HW_MBOX_OPCODE_FLDDEFS_CODE_OFFSET (10)
-#define HW_MBOX_OPCODE_FLDDEFS_CODE_LENGTH (HW_MBOX_OPCODE_CODE_BITLEN) /*! already defined in defs */
+#define HW_MBOX_OPCODE_FLDDEFS_TAG_OFFSET (16)
+#define HW_MBOX_OPCODE_FLDDEFS_TAG_LENGTH (HW_MBOX_OPCODE_TAG_BITLEN)    /*! already defined in defs */
 
-#define HW_MBOX_OPCODE_FLDDEFS_LEN_OFFSET (0)
-#define HW_MBOX_OPCODE_FLDDEFS_LEN_LENGTH (10)
+#define HW_MBOX_OPCODE_FLDDEFS_LEN_IN_WORDS_OFFSET (0)
+#define HW_MBOX_OPCODE_FLDDEFS_LEN_IN_WORDS_LENGTH (10)
 
 /* Modifier Macro helpers: */
 
@@ -1305,29 +1290,71 @@ do{ \
 #define HW_MBOX_OPCODE_GET_TAG( _cmdRegVal)                   hw_mbox_field32_get( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_TAG_OFFSET, HW_MBOX_OPCODE_FLDDEFS_TAG_LENGTH)
 #define HW_MBOX_OPCODE_SET_TAG( _cmdRegVal, _tagVal)          hw_mbox_field32_set( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_TAG_OFFSET, HW_MBOX_OPCODE_FLDDEFS_TAG_LENGTH, _tagVal)
 
-/*! Flags: */
-
-/* A: */
-#define HW_MBOX_OPCODE_GET_FLAG_A( _cmdRegVal )               hw_mbox_field32_get( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_FLAG_A_OFFSET, HW_MBOX_OPCODE_FLDDEFS_FLAG_A_LENGTH)
-#define HW_MBOX_OPCODE_SET_FLAG_A( _cmdRegVal, _flagAVal)     hw_mbox_field32_set( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_FLAG_A_OFFSET, HW_MBOX_OPCODE_FLDDEFS_FLAG_A_LENGTH, _flagAVal)
-
-/* B: */
-#define HW_MBOX_OPCODE_GET_FLAG_B( _cmdRegVal )               hw_mbox_field32_get( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_FLAG_B_OFFSET, HW_MBOX_OPCODE_FLDDEFS_FLAG_B_LENGTH)
-#define HW_MBOX_OPCODE_SET_FLAG_B( _cmdRegVal, _flagBVal)     hw_mbox_field32_set( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_FLAG_B_OFFSET, HW_MBOX_OPCODE_FLDDEFS_FLAG_B_LENGTH, _flagBVal)
-
-/*! CODE: command code. */
-#define HW_MBOX_OPCODE_GET_CODE( _cmdRegVal)                  hw_mbox_field32_get( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_CODE_OFFSET, HW_MBOX_OPCODE_FLDDEFS_CODE_LENGTH)
-#define HW_MBOX_OPCODE_SET_CODE( _cmdRegVal, _codeVal)        hw_mbox_field32_set( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_CODE_OFFSET, HW_MBOX_OPCODE_FLDDEFS_CODE_LENGTH, _codeVal)
-
 /*! LEN: command data len in Bytes [note: in command Register the value is in words]. */
-#define HW_MBOX_OPCODE_GET_LEN( _cmdRegVal)                   (hw_mbox_field32_get( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_LEN_OFFSET, HW_MBOX_OPCODE_FLDDEFS_LEN_LENGTH) << 2)
-#define HW_MBOX_OPCODE_SET_LEN( _cmdRegVal, _lenValInBytes)   hw_mbox_field32_set( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_LEN_OFFSET, HW_MBOX_OPCODE_FLDDEFS_LEN_LENGTH, (( _lenValInBytes ) >> 2))
+#define HW_MBOX_OPCODE_GET_LEN( _cmdRegVal)                   (hw_mbox_field32_get( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_LEN_IN_WORDS_OFFSET, HW_MBOX_OPCODE_FLDDEFS_LEN_IN_WORDS_LENGTH) << 2)
+#define HW_MBOX_OPCODE_SET_LEN( _cmdRegVal, _lenValInBytes)   hw_mbox_field32_set( _cmdRegVal, HW_MBOX_OPCODE_FLDDEFS_LEN_IN_WORDS_OFFSET, HW_MBOX_OPCODE_FLDDEFS_LEN_IN_WORDS_LENGTH, (( _lenValInBytes ) >> 2))
 
 /*********************************
-        High Level Helpers        
+|       High Level Helpers       |
 *********************************/
 
-/*! \def HW_MBOX_CHANNEL_FULL_CONFIG_GET_TO_STRUCT(paramCID, _pChnConfig)
+/*! \struct hwMbox_interruptState_t
+    \brief struct specifying HW MBOX state of interrupts.
+    \note Low CID range is [0-31], High CID range is [32-63].
+    \note These are Mask values of CID interrupts, 1 = Disabled, 0 = Enabled.
+*/
+typedef struct hwMbox_interruptState
+{
+    Uint32 lowCidRangeMaskVal;
+    Uint32 highCidRangeMaskVal;
+} hwMbox_interruptState_t;
+
+/*! \def HW_MBOX_INTERRUPT_STATE_GET_TO_STRUCT( _pIntrState )
+    \brief Gets the current HW MBOX interrupts on the HW level.
+    \param[out] _pIntrState - pointer to <hwMbox_interruptState_t>
+                              to save the current state to.
+*/
+#define HW_MBOX_INTERRUPT_STATE_GET_TO_STRUCT( _pIntrState ) \
+do{ \
+    ( _pIntrState )->lowCidRangeMaskVal = HW_MBOX_MASTER_INTR_MASK_L_REG_GET();    \
+    ( _pIntrState )->highCidRangeMaskVal = HW_MBOX_MASTER_INTR_MASK_H_REG_GET();   \
+} while (0)
+
+/*! \def HW_MBOX_RESTORE_INTERRUPTS( _pIntrState )
+    \brief Restore HW MBOX interrupt state on the HW level.
+    \param[in] _pIntrState - pointer to <hwMbox_interruptState_t>
+                             specifying the state to restore.
+    \note Done by Un-masking channel interrupts.
+*/
+#define HW_MBOX_RESTORE_INTERRUPTS( _pIntrState ) \
+do{ \
+    HW_MBOX_MASTER_INTR_MASK_L_REG_SET(( _pIntrState )->lowCidRangeMaskVal);    \
+    HW_MBOX_MASTER_INTR_MASK_H_REG_SET(( _pIntrState )->highCidRangeMaskVal);   \
+} while (0)
+
+/*! \def HW_MBOX_ENABLE_ALL_INTERRUPTS()
+    \brief Enable ALL HW MBOX interrupts on the HW level.
+    \note Done by Un-masking channel interrupts.
+*/
+#define HW_MBOX_ENABLE_ALL_INTERRUPTS() \
+do{ \
+    HW_MBOX_MASTER_INTR_MASK_L_REG_SET( 0 );    \
+    HW_MBOX_MASTER_INTR_MASK_H_REG_SET( 0 );    \
+} while (0)
+
+/*! \def HW_MBOX_DISABLE_ALL_INTERRUPTS()
+    \brief Disable HW MBOX interrupts on the HW level.
+    \attention save the current state using HW_MBOX_INTERRUPT_STATE_GET_TO_STRUCT
+               if planning to later restore [and use HW_MBOX_RESTORE_INTERRUPTS].
+    \note Done by masking channel interrupts.
+*/
+#define HW_MBOX_DISABLE_ALL_INTERRUPTS() \
+do{ \
+    HW_MBOX_MASTER_INTR_MASK_L_REG_SET( 0xFFFFFFFF );   \
+    HW_MBOX_MASTER_INTR_MASK_H_REG_SET( 0xFFFFFFFF );   \
+} while (0)
+
+/*! \def HW_MBOX_CHANNEL_CONFIG_GET_TO_STRUCT(paramCID, _pChnConfig)
     \brief Macro to get channel's full configuration (including SRAM) via struct.
     \param[out] _pChnConfig - pointer to a hw_mbox_channelConfig_t struct.
 */
@@ -1346,29 +1373,24 @@ do{ \
 
 /*! \def HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT( _cmdRegVal, _pOpcodeFlds)
     \brief Macro to get all opcode fields from a specific command register value via struct.
-    \param[in] _cmdRegVal - command register's value. 
+    \param[in] _cmdRegVal - command register's value.
     \param[out] _pOpCodeFlds - pointer to a hwMbox_opcode_t struct.
 */
 #define HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT( _cmdRegVal, _pOpcodeFlds) \
 do{ \
     (_pOpcodeFlds)->tag = HW_MBOX_OPCODE_GET_TAG( _cmdRegVal);          \
-    (_pOpcodeFlds)->flagA = HW_MBOX_OPCODE_GET_FLAG_A( _cmdRegVal);     \
-    (_pOpcodeFlds)->flagB = HW_MBOX_OPCODE_GET_FLAG_B( _cmdRegVal);     \
-    (_pOpcodeFlds)->code = HW_MBOX_OPCODE_GET_CODE( _cmdRegVal);        \
     (_pOpcodeFlds)->lenInBytes = HW_MBOX_OPCODE_GET_LEN( _cmdRegVal);   \
 } while (0)
 
 /*! \def HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT( _cmdRegVal, _pOpcodeFlds)
     \brief Macro to set all opcode fields using struct.
-    \param[out] _cmdRegVal - buffer for command register's value. 
+    \param[out] _cmdRegVal - buffer for command register's value.
     \param[in] _pOpCodeFlds - pointer to a hwMbox_opcode_t struct.
 */
 #define HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT( _cmdRegVal, _pOpcodeFlds) \
 do{ \
+    (_cmdRegVal) = 0;                                                                 \
     (_cmdRegVal) = HW_MBOX_OPCODE_SET_TAG( _cmdRegVal, (_pOpcodeFlds)->tag);          \
-    (_cmdRegVal) = HW_MBOX_OPCODE_SET_FLAG_A( _cmdRegVal, (_pOpcodeFlds)->flagA);     \
-    (_cmdRegVal) = HW_MBOX_OPCODE_SET_FLAG_B( _cmdRegVal, (_pOpcodeFlds)->flagB);     \
-    (_cmdRegVal) = HW_MBOX_OPCODE_SET_CODE( _cmdRegVal, (_pOpcodeFlds)->code);        \
     (_cmdRegVal) = HW_MBOX_OPCODE_SET_LEN( _cmdRegVal, (_pOpcodeFlds)->lenInBytes);   \
 } while (0)
 
--- /dev/null
+++ b/include/linux/hwMbox_types.h
@@ -0,0 +1,79 @@
+/*
+ *
+ * hwMbox_types.h
+ * Description:
+ * contains basic typedefs for puma7 HW_MBOX controller SW.
+ *
+ 
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2015 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE 
+
+  Copyright(c) 2015 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+
+
+typedef uint32_t Uint32;
+typedef int32_t  Int32;
+typedef uint8_t  Uint8;
+typedef bool     Bool;
+#define True true
+#define False false
+#include <linux/types.h> /* include file with generic typedefs for APP-CPU */
+
--- a/include/linux/hw_mailbox.h
+++ b/include/linux/hw_mailbox.h
@@ -140,7 +140,7 @@ int hwMbox_sendAckCommand(hw_mbox_Master
  **************************************************************************/
 int hwMbox_sendOpcode(hw_mbox_Masters_e subject,
                       Uint32 tag,
-                      Uint32 *code,
+                      //Uint32 *code,
                       Uint8 *dataBuf, Uint32 dataLen,
                       Uint32 opcodeDataLen,
                       Uint32 *replyDataLen);
@@ -160,10 +160,22 @@ int hwMbox_sendOpcode(hw_mbox_Masters_e
  *  \return [ 0 on success / error otherwise ].
  **************************************************************************/
 int hwMbox_sendReplyOpcode(hw_mbox_Masters_e commander,
-                           Uint32 code,
+                           //Uint32 code,
                            Uint8 *dataBuf, Uint32 dataLen);
 
 /**************************************************************************/
+/*! \fn int hwMbox_sendAckOpcode(hw_mbox_Masters_e commander)
+ **************************************************************************
+ *  \brief Send back an ACK to <commander>, from which an opcode has been
+ *         received using the HW_MBOX.
+ *  \attention should only be used after an opcode has been received from
+ *             <commander> using HW_MBOX_recvCommand.
+ *  \param[in] commander - To which Master should the ACK be sent.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_sendAckOpcode(hw_mbox_Masters_e commander);
+
+/**************************************************************************/
 /*! \fn int hwMbox_registerRecvOpcode(hw_mbox_Masters_e commander,
                                       hwMboxRecvOpcodeCallback pOpcodeCallbackFunc,
                                       Uint32 tag,
--- a/include/linux/hw_mbox_defs.h
+++ b/include/linux/hw_mbox_defs.h
@@ -76,21 +76,21 @@
 |                                         |
 ******************************************/
 
-/*! \def HW_MBOX_MASTER_COUNT 
+/*! \def HW_MBOX_MASTER_COUNT
     \brief Count of HW_MBOX Masters. */
 #define HW_MBOX_MASTER_COUNT     16
 
-/*! \def HW_MBOX_CHANNEL_COUNT 
+/*! \def HW_MBOX_CHANNEL_COUNT
     \brief Count of HW_MBOX Channel. */
 #define HW_MBOX_CHANNEL_COUNT    64
 
 #define HW_MBOX_CID_INVALID    0xFFFFFFFF
 
-/*! \def HW_MBOX_MID_VALIDITY_CHECK(paramMID) 
+/*! \def HW_MBOX_MID_VALIDITY_CHECK(paramMID)
     \brief evaluates as True if paramMID is a valid MID. */
 #define HW_MBOX_MID_VALIDITY_CHECK(paramMID)    (((paramMID) >= 0) && ((paramMID) < HW_MBOX_MASTER_COUNT))
 
-/*! \def HW_MBOX_CID_VALIDITY_CHECK(paramCID) 
+/*! \def HW_MBOX_CID_VALIDITY_CHECK(paramCID)
     \brief evaluates as True if paramCID is a valid CID. */
 #define HW_MBOX_CID_VALIDITY_CHECK(paramCID)    (((paramCID) >= 0) && ((paramCID) < HW_MBOX_CHANNEL_COUNT))
 
@@ -101,7 +101,7 @@
 #define HW_MBOX_APP_CPU_MID         2  /*! MID of APP_CPU       */
 #define HW_MBOX_RCE_MID             3  /*! MID of RCE           */
 #define HW_MBOX_US_MAC_CPU_MID      4  /*! MID of US_MAC_CPU    */
-#define HW_MBOX_DS_PHY_CPU_MID      5  /*! MID of DS_PHY_CPU    */
+#define HW_MBOX_PHY_CPU_MID         5  /*! MID of PHY_CPU       */
 #define HW_MBOX_MOCA_C_MID          6  /*! MID of MOCA_C        */
 #define HW_MBOX_DS_MAC_C_MID        7  /*! MID of DS_MAC_C      */
 #define HW_MBOX_PP_NETSEC_MID       8  /*! MID of PP_NETSEC     */
@@ -113,28 +113,10 @@
 #define HW_MBOX_SEC_MID            14  /*! MID of SEC           */
 #define HW_MBOX_CSE_MID            15  /*! MID of CSE           */
 
-/*! \var typedef enum hw_mbox_type hw_mbox_type_e
-    \brief This enum denotes types of mboxs (protocols) that are supported. */
-typedef enum hw_mbox_type
-{
-    hw_mbox_command = 0,  /* Command */
-    hw_mbox_event,        /* Event   */
-    hw_mbox_opcode,       /* Opcode (generic HW MBOX command-response protocol) */
-
-    HW_MBOX_TYPE_COUNT    /* Should always be last... */
-} hw_mbox_type_e;
-
-/*! \def HW_MBOX_TYPE_STR(mboxType)
-    \brief gets a string according to <mboxType>
-    \attention <mboxType> should be a value from hw_mbox_type_e 
-*/
-#define HW_MBOX_TYPE_STR(mboxType)    ( (mboxType == hw_mbox_command)?("Command"): \
-                                        ((mboxType == hw_mbox_event)?("Event"):("Opcode")) )
-
 /*! \def HW_MBOX_DEFAULT_TIMEOUT_SEC
     \brief Default timeout value in seconds.
     \note can comment out define to set wait forever.
-    \attention wait forever setting should only be used for debug! 
+    \attention wait forever setting should only be used for debug!
 */
 #define HW_MBOX_DEFAULT_TIMEOUT_SEC    10  /* 10 sec */
 
@@ -188,7 +170,7 @@ typedef enum hw_mbox_type
 /** --------------------------------------- **/
 
 /*! \def __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO    <MID_of_new_Supervisor>
-    \brief MID of the Master to act as supervisor (instead of default one). 
+    \brief MID of the Master to act as supervisor (instead of default one).
     \warning ONLY USE IF YOU ABSOULTLY KNOW WHAT YOU ARE DOING!!!
     \attention use a value from HW_MBOX_MASTER_MID defines.
     \note Feature is OPTIONAL, comment out define to disable.
@@ -200,7 +182,7 @@ typedef enum hw_mbox_type
 /** --------------------------------------- **/
 
 /*! \def HW_MBOX_DEBUG
-    \brief Enable this flag for various debug operations of the HW_MBOX package. 
+    \brief Enable this flag for various debug operations of the HW_MBOX package.
     \note Feature is OPTIONAL, comment out define to disable.
     \note Debug Features:
     \note 1. Free access to the HW_MBOX registers and Memory via CLI.
@@ -215,7 +197,7 @@ typedef enum hw_mbox_type
 ******************************************************/
 
 /*! \def HW_MBOX_MID    <MID_of_this_Master>
-    \brief MID of this Master, current Master, the one running this code. 
+    \brief MID of this Master, current Master, the one running this code.
     \attention use a value from HW_MBOX_MASTER_MID defines.
     \note It is derived from which physical HW_MBOX interrupt line is connected to this Master.
     \note Values for all Master are enumerated by hw_mbox_Masters_e, just pick the correct one.
@@ -223,11 +205,11 @@ typedef enum hw_mbox_type
 #define HW_MBOX_MID    HW_MBOX_APP_CPU_MID
 
 /*! \def HW_MBOX_OS_LINUX\HW_MBOX_OS_FLAT\HW_MBOX_OS_NONE
-    \brief Set one appropriate define according to Variant (OS). 
+    \brief Set one appropriate define according to Variant (OS).
     \attention Enable Exactly one of these!
     \note HW_MBOX_OS_LINUX: U-services.
-    \note HW_MBOX_OS_FLAT:  F-services. 
-    \note HW_MBOX_OS_NONE:  N-services. 
+    \note HW_MBOX_OS_FLAT:  F-services.
+    \note HW_MBOX_OS_NONE:  N-services.
 */
 #define HW_MBOX_OS_LINUX     /* U-services */
 //#define HW_MBOX_OS_FLAT    /* F-services */
@@ -257,36 +239,75 @@ enum { HW_MBOX_HARDCODED_MID = HW_MBOX_M
 #define HW_MBOX_IS_RCE                  /*! defined if current HW_MBOX Master is RCE        */
 #elif (HW_MBOX_MID == HW_MBOX_US_MAC_CPU_MID)
 #define HW_MBOX_IS_US_MAC_CPU           /*! defined if current HW_MBOX Master is US_MAC_CPU */
-#elif (HW_MBOX_MID == HW_MBOX_DS_PHY_CPU_MID)
-#define HW_MBOX_IS_DS_PHY_CPU           /*! defined if current HW_MBOX Master is DS_PHY_CPU */
+#elif (HW_MBOX_MID == HW_MBOX_PHY_CPU_MID)
+#define HW_MBOX_IS_PHY_CPU              /*! defined if current HW_MBOX Master is PHY_CPU    */
 #elif (HW_MBOX_MID == HW_MBOX_MOCA_C_MID)
 #define HW_MBOX_IS_MOCA_C               /*! defined if current HW_MBOX Master is MOCA_C     */
 #endif
 
+/**********************************************
+|                                             |
+|        HW_MBOX Types and Definitions        |
+|                                             |
+**********************************************/
+
 /* Generic Primitive typedefs: */
 
 /* need typedefs of Uint32, Uint8 and Bool(True/False). */
 #if   defined HW_MBOX_IS_NP_CPU
+#ifdef __KERNEL__
 #include "_tistdtypes.h"
+#else
+#include "sys_types.h"
+#endif /* __KERNEL__ */
 #elif defined HW_MBOX_IS_APP_CPU
-typedef uint32_t Uint32;
-typedef int32_t  Int32;
-typedef uint8_t  Uint8;
-typedef bool     Bool;
-#define True true
-#define False false
-#include <linux/types.h> /* include file with generic typedefs for APP-CPU */
-#elif defined HW_MBOX_IS_DS_PHY_CPU
+#include "hwMbox_types.h"
+#elif defined HW_MBOX_IS_PHY_CPU
 #include "types.h"
 #endif
 
+/* STATUS (Return Codes): */
+
+/*! \enum HW_MBOX_STATUS_e
+    \brief HW MBOX return codes.
+*/
+typedef enum HW_MBOX_STATUS
+{
+    HW_MBOX_STATUS_NOK = -1,
+    HW_MBOX_STATUS_OK = 0,
+
+    HW_MBOX_STATUS_INTERNAL_ERROR = 0x100,
+    HW_MBOX_STATUS_DRIVER_NOT_INITIALIZED,
+    HW_MBOX_STATUS_PEER_NOT_INITIALIZED,
+    HW_MBOX_STATUS_PEER_NOT_VALID,
+    HW_MBOX_STATUS_NO_CHANNEL_FOUND,
+    HW_MBOX_STATUS_INTERRUPTED_BY_SIGNAL,
+
+    HW_MBOX_STATUS_ERROR = 0x200,
+    HW_MBOX_STATUS_ERROR_TIMEOUT_EXPIRED,
+
+    HW_MBOX_STATUS_OPCODE_ERROR = 0x300,
+    HW_MBOX_STATUS_OPCODE_ERROR_INVALID_TAG,
+    HW_MBOX_STATUS_OPCODE_ERROR_MESSAGE_TOO_LONG,
+    HW_MBOX_STATUS_OPCODE_ERROR_INVALID_MESSAGE,
+    HW_MBOX_STATUS_OPCODE_ERROR_ILLEGAL_MESSAGE,
+    HW_MBOX_STATUS_OPCODE_ERROR_CALLBACK_FAILED,
+
+    /* Don't add any values after this line!!! */
+
+    HW_MBOX_STATUS_ONE_AFTER_LAST,
+    HW_MBOX_STATUS_LAST = (HW_MBOX_STATUS_ONE_AFTER_LAST - 1)
+} HW_MBOX_STATUS_e;
+
 /********************************************
 |                                           |
 |        HW_MBOX Master Declarations        |
 |                                           |
 ********************************************/
 
-/*! \var typedef enum hw_mbox_support hw_mbox_support_e
+/* Master Related Types and Defines: */
+
+/*! \enum hw_mbox_support_e
     \brief This enum denotes which SW support exists on each Master. */
 typedef enum hw_mbox_support
 {
@@ -297,19 +318,21 @@ typedef enum hw_mbox_support
 
 /*! \def HW_MBOX_SUPPORT_STR(mboxSupport)
     \brief gets a string according to <mboxSupport>
-    \attention <mboxSupport> should be a value from hw_mbox_support_e 
+    \attention <mboxSupport> should be a value from hw_mbox_support_e
 */
-#define HW_MBOX_SUPPORT_STR(mboxSupport)    ( (mboxSupport == hw_mbox_support_dynamic)?("Dynamic"): \
-                                              ((mboxSupport == hw_mbox_support_static)?("Static"):("None")) )
+#define HW_MBOX_SUPPORT_STR(mboxSupport)    ( (mboxSupport) == hw_mbox_support_none    ) ? ("None"   ) : \
+                                            ( (mboxSupport) == hw_mbox_support_static  ) ? ("Static" ) : \
+                                            ( (mboxSupport) == hw_mbox_support_dynamic ) ? ("Dynamic") : \
+                                              ("ERROR_UNKNOWN_HW_MBOX_SUPPORT!")
 
-/*! \var typedefstruct hw_mbox_masterConfig hw_mbox_masterConfig_t
+/*! \struct hw_mbox_masterConfig_t
     \brief Master configuration struct. */
 typedef struct hw_mbox_masterConfig
 {
     hw_mbox_support_e   support;
 } hw_mbox_masterConfig_t;
 
-/*! \def HW_MBOX_MASTER_CONFIG_SIZE 
+/*! \def HW_MBOX_MASTER_CONFIG_SIZE
     \brief Master configuration struct's size. */
 #define HW_MBOX_MASTER_CONFIG_SIZE    (sizeof(hw_mbox_masterConfig_t))
 
@@ -333,7 +356,7 @@ typedef struct hw_mbox_masterConfig
 /* |  2  | */ ENTRY( APP_CPU       , hw_mbox_support_static     )    \
 /* |  3  | */ ENTRY( RCE           , hw_mbox_support_none       )    \
 /* |  4  | */ ENTRY( US_MAC_CPU    , hw_mbox_support_none       )    \
-/* |  5  | */ ENTRY( DS_PHY_CPU    , hw_mbox_support_static     )    \
+/* |  5  | */ ENTRY( PHY_CPU       , hw_mbox_support_static     )    \
 /* |  6  | */ ENTRY( MOCA_C        , hw_mbox_support_static     )    \
 /* |  7  | */ ENTRY( DS_MAC_C      , hw_mbox_support_none       )    \
 /* |  8  | */ ENTRY( PP_NETSEC     , hw_mbox_support_none       )    \
@@ -349,19 +372,19 @@ typedef struct hw_mbox_masterConfig
 
 /*! \def HW_MBOX_MASTER_TABLE_AS_ENUM( _desc, _support )
     \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as enum.
-    \note Masters will be enumerated according to this template: HW_MBOX_MASTER_<_desc> 
+    \note Masters will be enumerated according to this template: HW_MBOX_MASTER_<_desc>
 */
 #define HW_MBOX_MASTER_TABLE_AS_ENUM( _desc, _support )      HW_MBOX_CONCAT2(HW_MBOX_MASTER_, _desc),
 
 /*! \def HW_MBOX_MASTER_TABLE_AS_STRS( _desc, _support )
     \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as strings.
-    \note Strings are created according to this template: "<_desc>" 
+    \note Strings are created according to this template: "<_desc>"
 */
 #define HW_MBOX_MASTER_TABLE_AS_STRS( _desc, _support )      HW_MBOX_STRINGIFY(_desc),
 
 /*! \def HW_MBOX_MASTER_TABLE_AS_COUNT( _desc, _support )
     \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as entry count. */
-#define HW_MBOX_MASTER_TABLE_AS_COUNT( _desc, _support )     1+ 
+#define HW_MBOX_MASTER_TABLE_AS_COUNT( _desc, _support )     1+
 
 /*! \def HW_MBOX_MASTER_TABLE_AS_DB( _desc, _support )
     \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as DB.
@@ -407,7 +430,7 @@ typedef struct hw_mbox_masterConfig
 #   error "HW_MBOX MASTER TABLE: entry count in the table must equal the total Master Count!"
 #endif
 
-/*! \var typedef enum hw_mbox_Masters hw_mbox_Masters_e 
+/*! \enum hw_mbox_Masters_e
     \brief Enumerate all HW_MBOX Master with MID value.
     \note name of the Masters is according to HW_MBOX_MASTER_TABLE_AS_ENUM Macro.
 */
@@ -434,7 +457,7 @@ typedef enum hw_mbox_Masters
 /*! \def HW_MBOX_CHNINT_DEV_NAME
     \brief Prefix name of the chnint char devices, these devices are used to extend interrupt signals from Kernel to User Space.
     \note for channel XX the device is chnintXX [e.g. channel 8 -> chnint08].
-    \note devices located in directory /dev/<HW_MBOX_DRV_DEV_DIR_NAME> 
+    \note devices located in directory /dev/<HW_MBOX_DRV_DEV_DIR_NAME>
 */
 #define HW_MBOX_CHNINT_DEV_NAME    "chnint"
 
@@ -452,7 +475,7 @@ typedef enum hw_mbox_Masters
 
 /* Argument Sanity Check: */
 #if (HW_MBOX_RECENT_COMMAND_LOG <= 0)
-#   error "HW_MBOX RECENT COMMAND LOG: Command Count Must be > 0!" 
+#   error "HW_MBOX RECENT COMMAND LOG: Command Count Must be > 0!"
 #endif
 
 /*! \def HW_MBOX_RECENT_COMMAND_LOG_INDEX_INVALID
@@ -462,6 +485,57 @@ typedef enum hw_mbox_Masters
 #endif /* HW_MBOX_RECENT_COMMAND_LOG */
 #endif /* HW_MBOX_OS_LINUX */
 
+/**********************************************
+|                                             |
+|        Channel Types and Definitions        |
+|                                             |
+**********************************************/
+
+/*! \enum hw_mbox_type_e
+    \brief This enum denotes types of mboxs (protocols) that are supported. */
+typedef enum hw_mbox_type
+{
+    hw_mbox_command = 0,  /* Command */
+    hw_mbox_event,        /* Event   */
+    hw_mbox_opcode,       /* Opcode (generic HW MBOX command-response protocol) */
+
+    HW_MBOX_TYPE_COUNT    /* Should always be last... */
+} hw_mbox_type_e;
+
+/*! \def HW_MBOX_TYPE_STR(mboxType)
+    \brief gets a string according to <mboxType>
+    \attention <mboxType> should be a value from hw_mbox_type_e
+*/
+#define HW_MBOX_TYPE_STR(mboxType)    ( (mboxType) == hw_mbox_command ) ? ("Command"): \
+                                      ( (mboxType) == hw_mbox_event   ) ? ("Event"  ): \
+                                      ( (mboxType) == hw_mbox_opcode  ) ? ("Opcode" ): \
+                                        ("ERROR_UNKNOWN_HW_MBOX_TYPE!")
+
+/*! \struct hw_mbox_sram_t
+    \brief struct for Channel's SRAM configuration. */
+typedef struct hw_mbox_sram
+{
+    Uint32 start; /* start Offset aligned and relvant to the 4KB of HW_MBOX SRAM */
+    Uint32 size;  /* size is in bytes */
+} hw_mbox_sram_t;
+
+#define HW_MBOX_SRAM_CHUNK    4  /*! Allocated SRAM size must be an integral Multiple of 4B */
+
+/*! \struct hw_mbox_channelConfig_t
+    \brief struct for Channel's configuration. */
+typedef struct hw_mbox_channelConfig
+{
+    Uint32              cid;
+    hw_mbox_type_e      mboxType;
+    hw_mbox_Masters_e   commander;
+    hw_mbox_Masters_e   subject;
+    hw_mbox_sram_t      memBuff;
+} hw_mbox_channelConfig_t;
+
+/*! \def HW_MBOX_CHANNEL_CONFIG_SIZE
+    \brief channel configuration struct's size. */
+#define HW_MBOX_CHANNEL_CONFIG_SIZE    sizeof(hw_mbox_channelConfig_t)
+
 /****************************************************
 |                                                   |
 |        HW_MBOX Opcode                             |
@@ -476,142 +550,192 @@ typedef enum hw_mbox_Masters
    the structure of the values that are to be written to command channel
    register. While enabling less freedom to applications it enables the
    construction of generic entities that can be used for message dispatching
-   without relying completely on application context. OPCODE type channels 
+   without relying completely on application context. OPCODE type channels
    enable inherent support for several applications on the same channel.
 */
 
 /* The Fields that OPCODE channel uses are:
- 
-   TAG - indicates the application that is the destination of the code.
-         Note: TAG == 0xFF and 0xFE are reserved for HW MBOX usage.
- 
-   CODE - code of the command (per TAG, defined by applicative context).
- 
-   FLAG A/B - 2 reserved flags [for internal use].
 
-   LEN - How many words are to be read from SRAM (opcode Data).
-         [LEN is integral multiple of 4 Bytes so we can use word count].
+   TAG - Indicates the application that is the destination of the code.
+         Note: Several TAGs are reserved for HW MBOX internal usage
+               [see hwMbox_opcodeReservedTags_e].
+
+   LEN - How many Bytes are to be read from SRAM (opcode Data).
+         [ LEN is always an integral multiple of 4 Bytes so we can
+           use word count when writing to the command register ].
 
    exact Field division is defined in mem_access file.
 */
 
-/*! \var typedef struct hwMbox_opcode hwMbox_opcode_t
-    \brief struct for opcode fields. 
-    \note the types used here sometimes have more capacity than actual max value. 
+/*! \struct hwMbox_opcode_t
+    \brief struct for opcode fields.
+    \note the types used here can have more capacity than actual max value.
 */
 typedef struct hwMbox_opcode
 {
     Uint32  tag;
-    Uint32  code;
-    Bool    flagA;
-    Bool    flagB;
     Uint32  lenInBytes;
 } hwMbox_opcode_t;
 
+/*! \def HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES
+    \brief a minimal amount of SRAM that should be allocated to Opcode channels.
+    \note an Opcode channel configuration with less than this amount is considered invalid.
+*/
+#define HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES    (2 * HW_MBOX_SRAM_CHUNK)
+
 /* Field Bit Length definitions:
-   [These are done here so max value can be calculated and used here...] 
+   [These are done here so max value possible can be calculated and used here...]
 
-   Note: if value change please update also corresponding documentation 
-   in mem access.
+   Note: if value change please update also corresponding documentation
+         in mem access.
 */
 
-#define HW_MBOX_OPCODE_TAG_BITLEN    (8)
+#define HW_MBOX_OPCODE_TAG_BITLEN    (12) /*! allocated amount of bits for the TAG field */
 
-#define HW_MBOX_OPCODE_CODE_BITLEN   (12)
-
-/*! \def HW_MBOX_OPCODE_TAG_MAX_VALUE 
+/*! \def HW_MBOX_OPCODE_TAG_MAX_VALUE
     \brief Max value available for tag field when using OPCODE. */
 #define HW_MBOX_OPCODE_TAG_MAX_VALUE    (BIT(HW_MBOX_OPCODE_TAG_BITLEN) - 1)
 
-/*! \def HW_MBOX_OPCODE_CODE_MAX_VALUE 
-    \brief Max value available for code field when using OPCODE. */
-#define HW_MBOX_OPCODE_CODE_MAX_VALUE   (BIT(HW_MBOX_OPCODE_CODE_BITLEN) - 1)
+/* Reserved HW MBOX TAGs: */
 
-#define HW_MBOX_OPCODE_TAG                0xFF /*! Reserved TAG value for Kernel HW MBOX */
-#define HW_MBOX_OPCODE_USER_SPACE_TAG     0xFE /*! Reserved TAG value for User-Space HW MBOX */
+#define HW_MBOX_OPCODE_RESERVED_TAGS_START    0xFF0 /*! First Reserved TAG value for HW MBOX */
 
-/*! \var typedef enum hwMbox_code hwMbox_code_e
-    \brief This enum denotes codes of internal administrative HW MBOX 
-           commands to be sent on opcode channel.
+/*! \enum hwMbox_opcodeReservedTags_e
+    \brief This enum denotes HW MBOX reserved opcode tags.
 */
-typedef enum hwMbox_code
+typedef enum hwMbox_opcodeReservedTags
 {
-    HW_MBOX_CODE_INIT_COMPLETE = 0,    /* init complete code [sent to other Masters by supervisor]. */
-    HW_MBOX_CODE_PING,                 /* ping SW support on other end */
+    HW_MBOX_LAST_NON_RESREVED_OPCODE_TAG_VALUE = (HW_MBOX_OPCODE_RESERVED_TAGS_START - 1),
 
-    HW_MBOX_CODE_COUNT    /* Should always be last... */
-} hwMbox_code_e;
+    /* Don't add any values before this line!!! */
 
-/*! \var typedef enum hwMbox_opcodeReturnCode hwMbox_opcodeReturnCode_e
-    \brief This enum denotes return codes of an opcode channel.
+    HW_MBOX_RESREVED_OPCODE_TAG_0,
+    HW_MBOX_RESREVED_OPCODE_TAG_1,
+    HW_MBOX_RESREVED_OPCODE_TAG_2,
+    HW_MBOX_RESREVED_OPCODE_TAG_3,
+    HW_MBOX_RESREVED_OPCODE_TAG_4,
+    HW_MBOX_RESREVED_OPCODE_TAG_5,
+    HW_MBOX_RESREVED_OPCODE_TAG_6,
+    HW_MBOX_RESREVED_OPCODE_TAG_7,
+    HW_MBOX_RESREVED_OPCODE_TAG_8,
+    HW_MBOX_RESREVED_OPCODE_TAG_9,
+    HW_MBOX_RESREVED_OPCODE_TAG_10,
+    HW_MBOX_RESREVED_OPCODE_TAG_11,
+    HW_MBOX_RESREVED_OPCODE_TAG_12,
+    HW_MBOX_RESREVED_OPCODE_TAG_13,
+    HW_MBOX_OPCODE_USER_SPACE_TAG,      /*! [0xFFE] Reserved TAG value for User-Space HW MBOX */
+    HW_MBOX_OPCODE_TAG,                 /*! [0xFFF] Reserved TAG value for Kernel HW MBOX */
+
+    /* Don't add any values after this line!!! */
+
+    HW_MBOX_RESERVED_OPCODE_ONE_AFTER_LAST,
+    HW_MBOX_RESERVED_OPCODE_LAST = (HW_MBOX_RESERVED_OPCODE_ONE_AFTER_LAST - 1)    /*! Last reserved TAG value */
+} hwMbox_opcodeReservedTags_e;
+
+/*! \typedef __hwMbox_reservedOpcodesEnumExceededAllowedSize
+    \brief Sanity check for reserved opcodes enum.
+    \note if compilation fails here then hwMbox_opcodeReservedTags_e exceeded the allowed size.
 */
-typedef enum hwMbox_opcodeReturnCode
-{
-    HW_MBOX_OPCODE_RC_OK = 0,
+typedef Uint8 __hwMbox_reservedOpcodesEnumExceededAllowedSize[HW_MBOX_OPCODE_TAG_MAX_VALUE - HW_MBOX_RESERVED_OPCODE_LAST];
 
-    HW_MBOX_OPCODE_RC_NOT_INITIALIZED_YET = 0x100,
-    HW_MBOX_OPCODE_RC_INVALID_TAG,
-    HW_MBOX_OPCODE_RC_INVALID_CODE,
-    HW_MBOX_OPCODE_RC_CALLBACK_FAILED,
-    HW_MBOX_OPCODE_RC_REPLY_TOO_LONG,
+/* Recv Opcode Infrastructure: */
 
-    HW_MBOX_OPCODE_RC_NOK = HW_MBOX_OPCODE_CODE_MAX_VALUE /* this should be last... */
-} hwMbox_opcodeReturnCode_e;
-
-#define HW_MBOX_OPCODE_RECV_COUNT    10 /*! max amount of recv opcode channels per Master. */
-#define HW_MBOX_OPCODE_TAG_COUNT     10 /*! max amount of tags that can be registered per RecvOpcode channel. */
+#define HW_MBOX_OPCODE_RECV_COUNT    10    /*! max amount of recv opcode channels per Master. */
+#define HW_MBOX_OPCODE_TAG_COUNT     10    /*! max amount of tags that can be registered per RecvOpcode channel. */
 
 /*! \typedef int (*hwMboxRecvOpcodeCallback)(hw_mbox_Masters_e commander,
-                                             Uint32 code,
                                              Uint8 *dataBuf, Uint32 dataLen,
                                              Uint32 *token)
     \brief prototype for receive opcode channels callback function pointers, to be
            invoked by Receive Opcode Listeners upon incoming opcode.
     \param[in]     commander - Master from which the opcode has been received.
-    \param[in]     code - code of the opcode that has been received.
-    \param[in,out] dataBuf - data of the opcode that has been received.
+    \param[in,out] dataBuf - opcode data that has been received.
     \param[in]     dataLen - Length in bytes of <dataBuf>.
     \param[in,out] token - 32 bit saved in DB upon registering the callback,
                            modifiable by the callback.
     \note return value (-1) is reserved to indicate generic error, use token
-          to output an error from <hwMbox_opcodeReturnCode_e>, it will be sent
+          to output an error from <HW_MBOX_STATUS_e>, it will be sent
           to the commander and the sendOpcode service it invoked will fail.
 */
 typedef int (*hwMboxRecvOpcodeCallback)(hw_mbox_Masters_e commander,
-                                        Uint32 code,
                                         Uint8 *dataBuf, Uint32 dataLen,
                                         Uint32 *token);
 
-/********************************************
-|                                           |
-|        HW_MBOX Channel Definitions        |
-|                                           |
-********************************************/
+/* Types and Defines for tag HW_MBOX_OPCODE_TAG: */
 
-/*! \var typedef struct hw_mbox_sram hw_mbox_sram_t
-    \brief struct for Channel's SRAM configuration. */
-typedef struct hw_mbox_sram
+typedef enum hwMbox_opcodeMessageTypes
 {
-    Uint32 start; /* start Offset aligned and relvant to the 4KB of HW_MBOX SRAM */
-    Uint32 size;  /* size is in bytes */
-} hw_mbox_sram_t;
+    HW_MBOX_OPCODE_MESSAGE_TYPE_CODE = 0,
+    HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS,
 
-#define HW_MBOX_SRAM_CHUNK    4  /*! Allocated SRAM size must be an integral Multiple of 4B */
+    HW_MBOX_OPCODE_MESSAGE_TYPE_COUNT /*! this should be last... */
+} hwMbox_opcodeMessageTypes_e;
 
-/*! \var typedef struct hw_mbox_channelConfig hw_mbox_channelConfig_t
-    \brief struct for Channel's configuration. */
-typedef struct hw_mbox_channelConfig
+/* Code Message: */
+
+/*! \enum hwMbox_code_e
+    \brief This enum denotes codes of internal administrative HW MBOX
+           commands to be sent on opcode channel.
+*/
+typedef enum hwMbox_code
 {
-    Uint32              cid;
-    hw_mbox_type_e      mboxType;
-    hw_mbox_Masters_e   commander;
-    hw_mbox_Masters_e   subject;
-    hw_mbox_sram_t      memBuff;
-} hw_mbox_channelConfig_t;
+    HW_MBOX_CODE_INIT_COMPLETE = 0,    /*! Init complete code [sent to other Masters by supervisor]. */
+    HW_MBOX_CODE_PING,                 /*! Ping SW support on other Master */
 
-/*! \def HW_MBOX_CHANNEL_CONFIG_SIZE 
-    \brief channel configuration struct's size. */
-#define HW_MBOX_CHANNEL_CONFIG_SIZE    sizeof(hw_mbox_channelConfig_t)
+    HW_MBOX_CODE_COUNT /*! Should always be last... */
+} hwMbox_code_e;
+
+/*! \struct hwMbox_opcodeMessageCode_t
+    \brief Opcode message to send a HW MBOX code to the other Master.
+*/
+typedef struct hwMbox_opcodeMessageCode
+{
+    hwMbox_code_e code;
+} hwMbox_opcodeMessageCode_t;
+
+#define HW_MBOX_OPCODE_MESSAGE_CODE_SIZE    sizeof(hwMbox_opcodeMessageCode_t)
+
+/* Status Message: */
+
+/*! \struct hwMbox_opcodeMessageStatus_t
+    \brief Opcode message to send a HW MBOX Status to the other Master.
+*/
+typedef struct hwMbox_opcodeMessageStatus
+{
+    HW_MBOX_STATUS_e status;
+} hwMbox_opcodeMessageStatus_t;
+
+#define HW_MBOX_OPCODE_MESSAGE_STATUS_SIZE     sizeof(hwMbox_opcodeMessageStatus_t)
+
+/* Opcode Message: */
+
+/*! \union hwMbox_opcodeMessageData_u
+    \brief Union for all types of opcode message data.
+*/
+typedef union hwMbox_opcodeMessageData
+{
+    hwMbox_opcodeMessageCode_t      msgCode;
+    hwMbox_opcodeMessageStatus_t    msgStatus;
+} hwMbox_opcodeMessageData_u;
+
+/*! \struct hwMbox_opcodeMessage_t
+    \brief Opcode message for tag HW_MBOX_OPCODE_TAG.
+*/
+typedef struct hwMbox_opcodeMessage
+{
+    hwMbox_opcodeMessageTypes_e msgType;
+    hwMbox_opcodeMessageData_u  msgData;
+} hwMbox_opcodeMessage_t;
+
+#define HW_MBOX_OPCODE_MESSAGE_SIZE     sizeof(hwMbox_opcodeMessage_t)
+
+/*! \typedef __hwMbox_opcodeMessageSizeExceededAllowedSize
+    \brief Sanity check for opcode message size.
+    \note if compilation fails here then hwMbox_opcodeMessage_t exceeded the allowed size.
+    \note The maximal allowed size is as such that this message can always be sent on opcode channels.
+    \note Meaning, it shouldn't exceed the minimal amount of SRAM allocate to opcode channels.
+*/
+typedef Uint8 __hwMbox_opcodeMessageSizeExceededAllowedSize[HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES - HW_MBOX_OPCODE_MESSAGE_SIZE];
 
 /********************************************
 |                                           |
@@ -623,7 +747,9 @@ typedef struct hw_mbox_channelConfig
     \brief X-MACRO hardcoded table for STATIC Channel declarations.
     \attention SRAM size must be an integral Multiple of HW_MBOX_SRAM_CHUNK = 4B.
     \attention An event channel must have SRAM allocated to accomdate the event buffer.
-    \attention An event channel SRAM size must be divisible to 2 equal sized valid individual SRAM buffers [for the double buffer] --> meaning it should be an integral multiple of 2 * HW_MBOX_SRAM_CHUNK = 8B.
+    \attention An event channel SRAM size must be divisible to 2 equal sized valid individual SRAM buffers
+              [for the double buffer] --> meaning it should be an integral multiple of 2 * HW_MBOX_SRAM_CHUNK = 8B.
+    \attention An opcode channel SRAM size must be >= HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES.
 */
 #define HW_MBOX_STATIC_CHANNEL_TABLE(ENTRY) \
 /*       +--------------------------------------------------------------------------------------------------------------------------+ */ \
@@ -631,16 +757,16 @@ typedef struct hw_mbox_channelConfig
 /*       |       | [hw_mbox_Masters_e]                 | [hw_mbox_Masters_e]                 | [hw_mbox_channel_type_e] | [Bytes]   | */ \
 /*       +--------------------------------------------------------------------------------------------------------------------------+ */ \
     ENTRY(    0  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_command          , 0         )    \
-    ENTRY(    1  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_DS_PHY_CPU           , hw_mbox_command          , 0         )    \
+    ENTRY(    1  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_PHY_CPU              , hw_mbox_command          , 8         )    \
     ENTRY(    2  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_command          , 0         )    \
     ENTRY(    3  , HW_MBOX_MASTER_BBU_C                , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
-    ENTRY(    4  , HW_MBOX_MASTER_DS_PHY_CPU           , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
+    ENTRY(    4  , HW_MBOX_MASTER_PHY_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
     ENTRY(    5  , HW_MBOX_MASTER_MOCA_C               , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
     ENTRY(    6  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_opcode           , 8         )    \
     ENTRY(    7  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_APP_CPU              , hw_mbox_opcode           , 8         )    \
-    ENTRY(    8  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_DS_PHY_CPU           , hw_mbox_opcode           , 8         )    \
-    ENTRY(    9  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_opcode           , 8         )    \
-    ENTRY(   10  , HW_MBOX_MASTER_APP_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_opcode           , 8         )
+    ENTRY(    8  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_PHY_CPU              , hw_mbox_opcode           , 8         )    \
+    ENTRY(    9  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_opcode           , 64        )    \
+    ENTRY(   10  , HW_MBOX_MASTER_APP_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_opcode           , 64        )
 
 /* static channel Table Expanders: */
 
