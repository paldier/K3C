From 4fc18d513e5fb51343b5138ad524fe6104f9e11b Mon Sep 17 00:00:00 2001
From: Pawan Gupta <pawan.kumarx.gupta@intel.com>
Date: Fri, 3 Jun 2016 17:14:14 -0700
Subject: [PATCH 414/441] spi: Merge Puma6 and Puma7

Merged puma6 spi with puma7. There are some puma6 files which
cannot be trivially merged with puma7 so created a copy of these
files ending with *_puma6.c. Such files are conditionally
compiled for puma6 only.

Signed-off-by: Pawan Gupta <pawan.kumarx.gupta@intel.com>

spi: Merge Puma6 and Puma7

Added missing ce5xx_spi_*.h header files for puma6.
Fix other spi build issues.

Signed-off-by: Pawan Gupta <pawan.kumarx.gupta@intel.com>
---
 drivers/spi/Makefile               |   11 +-
 drivers/spi/ce5xx_spi_flash.c      |  934 ++++++++++++++++++++
 drivers/spi/ce5xx_spi_flash.h      |  154 ++++
 drivers/spi/ce5xx_spi_slv.c        |  656 ++++++++++++++
 drivers/spi/ce5xx_spi_slv.h        |  112 +++
 drivers/spi/spi-pxa2xx-dma.c       |   29 +-
 drivers/spi/spi-pxa2xx-pci_puma6.c |  243 ++++++
 drivers/spi/spi-pxa2xx.h           |    6 +-
 drivers/spi/spi-pxa2xx_puma6.c     | 1698 ++++++++++++++++++++++++++++++++++++
 drivers/spi/spi.c                  |   52 +-
 drivers/spi/spidev.c               |   52 +-
 include/linux/pxa2xx_ssp.h         |   25 +
 include/linux/spi/pxa2xx_spi.h     |    9 +-
 13 files changed, 3972 insertions(+), 9 deletions(-)
 create mode 100644 drivers/spi/ce5xx_spi_flash.c
 create mode 100644 drivers/spi/ce5xx_spi_flash.h
 create mode 100644 drivers/spi/ce5xx_spi_slv.c
 create mode 100644 drivers/spi/ce5xx_spi_slv.h
 create mode 100644 drivers/spi/spi-pxa2xx-pci_puma6.c
 create mode 100644 drivers/spi/spi-pxa2xx_puma6.c

--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_SPI_SPIDEV)		+= spidev.o
 # SPI master controller drivers (bus)
 obj-$(CONFIG_SPI_ALTERA)		+= spi-altera.o
 obj-$(CONFIG_SPI_ATMEL)			+= spi-atmel.o
+obj-$(CONFIG_SPI_CE5XX_SPI_FLASH)       += ce5xx_spi_flash.o
 obj-$(CONFIG_SPI_ATH79)			+= spi-ath79.o
 obj-$(CONFIG_SPI_AU1550)		+= spi-au1550.o
 obj-$(CONFIG_SPI_BCM2835)		+= spi-bcm2835.o
@@ -54,11 +55,19 @@ obj-$(CONFIG_SPI_TI_QSPI)		+= spi-ti-qsp
 obj-$(CONFIG_SPI_ORION)			+= spi-orion.o
 obj-$(CONFIG_SPI_PL022)			+= spi-pl022.o
 obj-$(CONFIG_SPI_PPC4xx)		+= spi-ppc4xx.o
+
+ifeq ($(CONFIG_GEN3_SPI),y)
+spi-pxa2xx-platform-objs		:= spi-pxa2xx_puma6.o
+obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci_puma6.o
+else
 spi-pxa2xx-platform-objs		:= spi-pxa2xx.o
+obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
+endif
+
 spi-pxa2xx-platform-$(CONFIG_SPI_PXA2XX_PXADMA)	+= spi-pxa2xx-pxadma.o
 spi-pxa2xx-platform-$(CONFIG_SPI_PXA2XX_DMA)	+= spi-pxa2xx-dma.o
 obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-platform.o
-obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
+obj-$(CONFIG_SPI_CE5XX_SPI_SLAVE) += ce5xx_spi_slv.o
 obj-$(CONFIG_SPI_RSPI)			+= spi-rspi.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi-s3c24xx-hw.o
 spi-s3c24xx-hw-y			:= spi-s3c24xx.o
--- /dev/null
+++ b/drivers/spi/ce5xx_spi_flash.c
@@ -0,0 +1,934 @@
+/*
+ * SPI flash controller driver for Intel media processor CE5300/CE2600 series
+ *
+ * GPL LICENSE SUMMARY
+ * Copyright (c) 2011-2013, Intel Corporation and its suppliers.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/reboot.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/delay.h>
+
+#include <linux/io.h>
+
+#include "ce5xx_spi_flash.h"
+
+/*
+ * CS_HOLD is incorrect for legacy mode, causes possible spurrious CS assertion.
+ * If CS_TAR field is set, CS will go low and will not be released until we do
+ * another write to one of the legacy registers with data bit 26 = 0
+*/
+//#define CS_HOLD_DEFECT_EXIST_IN_CE2600 	1
+
+#define MB 			(1024*1024)
+#define SIZE_4_MB	(4*MB)
+#define SIZE_8_MB	(8*MB)
+#define SIZE_16_MB	(16*MB)
+#define SIZE_32_MB	(32*MB)
+#define SIZE_64_MB	(64*MB)
+
+#define BITS_OF_BYTES(bytenum)	(BITS_PER_BYTE*(bytenum))
+/*
+ * Device read contains two methods: CSR or Memory Window
+ * CSR: Configuration Space Registers
+ * CS0 is always the boot device
+ */
+
+static DEFINE_PCI_DEVICE_TABLE(ce5xx_sflash_pci_tbl)  = {
+  { PCI_DEVICE( INTEL_VENDOR_ID, CE5XX_SPI_FLASH_CONTROLLER_ID), .driver_data = 1 },
+  {0},
+};
+
+struct spi_board_info CE5xx_sflash_devices[] = {
+  {
+    .modalias = "nmyx25",
+    .chip_select = 0,
+    .bus_num = 1,
+  },
+};
+
+
+//#define SPI_CE_DEBUG 1
+#ifdef  SPI_CE_DEBUG
+#define spi_dbg(fmt, args...) do \
+                             { \
+                               printk(KERN_INFO fmt, ##args); \
+                              } while(0)
+
+#define spi_dbg_func	spi_dbg("func %s, line %d\n",__FUNCTION__,__LINE__)
+#else
+#define spi_dbg(fmt,args...) do {} while(0)
+#define spi_dbg_func	do {} while(0)
+#endif
+
+MODULE_DEVICE_TABLE(pci, ce5xx_sflash_pci_tbl);
+
+/*
+ *  Serial Flash controller using memory window for read, not by CSR read
+ * When using memory window read, the Address Split Register should be
+ * correctly configured.
+ * The match algorithm is :
+ * Mask is M; value is CS, address is A
+ * match= !((A xor CS) and (not M))
+ *
+ * Different device size in two chip selects require different Address Spilit
+ * Value.
+ */
+static struct ce5xx_address_split addr_split_tbl[] = {
+
+		/* single 4MB */
+		{SIZE_4_MB,	0,		0x8,	0x0,	0x0,	0x0},
+		{0,		SIZE_4_MB,	0x0,	0x0,	0x8,	0x0},
+
+		/* single 8MB*/
+		{SIZE_8_MB,	0,		0x8,	0x0,	0x0,	0x0},
+		{0,		SIZE_8_MB,	0x0,	0x0,	0x8,	0x0},
+
+		/* single 16MB*/
+		{SIZE_16_MB,	0,		0x8,	0x0,	0x0,	0x0},
+		{0, 	SIZE_16_MB,	0x0,	0x0,	0x8,	0x0},
+
+		/* single 32MB*/
+		{SIZE_32_MB,	0,	0x8,	0x1,	0xA,	0x1},
+		{0,	SIZE_32_MB,	0x8,	0x1,	0xA,	0x1},
+
+		/* single 64MB*/
+		{SIZE_64_MB,	0,		0x8,	0x0,	0x0,	0x0},
+		{0, 	SIZE_64_MB,	0x0,	0x0,	0x8,	0x0},
+
+		/* Double 8MB */
+		{SIZE_8_MB,	SIZE_8_MB,	0x8,	0x0,	0x9,	0x0},
+
+		/* Double 16MB */
+		{SIZE_16_MB,	SIZE_16_MB,	0x8,	0x0,	0x9,	0x0},
+
+		/* Double 32MB */
+		{SIZE_32_MB,	SIZE_32_MB,	0x8,	0x1,	0xA,	0x1},
+
+		/* Double 64MB */
+		/* [WARNING] Two 64MB devices can not be totally mapped, using CSR windows */
+		/* {SIZE_64_MB,	SIZE_64_MB,	0x8,	0x3,	0x8,	0x3},			*/
+		{},
+};
+
+static inline uint32_t flash_read32(void volatile *addr)
+{
+	return readl(addr);
+}
+
+static inline void flash_write32(uint32_t data, void volatile *addr)
+{
+	return writel(data, addr);
+}
+static struct ce5xx_address_split * match_address_split(struct flash_cs_info *cntl_data)
+{
+	int tmp = 0;
+	uint32_t cs0_size = cntl_data->cs0_size;
+	uint32_t cs1_size = cntl_data->cs1_size;
+	struct ce5xx_address_split *split = NULL;
+
+	spi_dbg(" [%s] cs0 0x%x, cs1 0x%x\n", __FUNCTION__,cs0_size,cs1_size);
+
+	for (tmp = 0; tmp < ARRAY_SIZE(addr_split_tbl) - 1; tmp++) {
+		split = &addr_split_tbl[tmp];
+		if ((split->cs0_size== cs0_size) && (split->cs1_size == cs1_size)){
+			spi_dbg("found address split method \n");
+			return &addr_split_tbl[tmp];
+		}
+	}
+	return 0;
+}
+/* Config address split register at init */
+static int address_split_cfg(struct ce5xx_sflash *dev)
+{
+	struct ce5xx_address_split *split = dev->addr_split_methd;
+	volatile void __iomem *reg = dev->regs_base;
+
+	uint32_t write_data = 0;
+
+	if (split)
+		return 0;
+
+	split = match_address_split(dev->cntl_data);
+	if (!split)
+		return -ENODEV;
+
+	write_data = ((uint32_t)split->cs0_cmp<<CS0_CMP)|((uint32_t)split->cs0_mask<<CS0_MASK)|((uint32_t)split->cs1_cmp<<CS1_CMP)|((uint32_t)split->cs1_mask<<CS1_MASK);
+	__raw_writel(write_data, reg + ADDR_SPLIT_REG);
+
+
+	return 0;
+}
+
+/*
+ * Chip select signal goes high
+ */
+static void ce5xx_sflash_turn_off_chip_sel(struct ce5xx_sflash *dev)
+{
+
+	volatile void __iomem *reg = dev->regs_base;
+	if (dev->mode & SPI_MODE_QUAD_IO){
+		__raw_writel(0, reg + HIGH_EFFICY_TRS_PAR_REG);
+	}
+	else{ /* Default Legacy mode */
+		__raw_writel(0, reg + DATA_COMMAND_REG);
+	}
+
+}
+static void ce5xx_sflash_cs_enable(struct ce5xx_sflash *dev, int cs0_on, int cs1_on)
+{
+	volatile void __iomem *reg = dev->regs_base;
+	uint32_t writeData = 0;
+	uint32_t readData = 0;
+	readData = __raw_readl(reg + MODE_CONTL_REG);
+	writeData = readData;
+
+	if (cs0_on)
+		writeData |= MODE_CONTL_CS0_MODE_ENABLE;
+	else
+		writeData &= (~MODE_CONTL_CS0_MODE_ENABLE);
+
+	if (cs1_on)
+		writeData |= MODE_CONTL_CS1_MODE_ENABLE;
+	else
+		writeData &= (~MODE_CONTL_CS1_MODE_ENABLE);
+
+	if (writeData != readData)
+		__raw_writel(writeData, reg + MODE_CONTL_REG);
+}
+
+/*
+ * __sflash_write_data_unit: program data to SPI flash, data size should be no more than 4 bytes
+ * In quad mode, write size should no more than 4 bytes
+ * In legacy mode, write size should no more than 3 bytes
+ * @buf, location of the data
+ * @len, write size, size could be 1, 2, 3, 4 bytes
+ * return 0 if success, else the remaining bytes
+ *
+ * Data in the source buffer is in little endian format, it should be transformed to big endian format.
+ */
+static uint32_t ce5xx_sflash_unit_write(struct ce5xx_sflash* dev, const char * buf, size_t len)
+{
+	uint32_t writeData = 0;
+	volatile void __iomem *reg = dev->regs_base;
+	uint32_t tmpData = 0;
+	volatile uint8_t *src = (uint8_t *)&tmpData;
+	uint32_t finished = 0;
+
+	//spi_dbg(" [%s] transmiting 0x%x bytes data to buf 0x%x\n", __FUNCTION__, len, buf);
+	memcpy((void *)src,buf,len);
+	if (dev->mode & SPI_MODE_QUAD_IO){
+		/* Sanity checks */
+		if ((!len) || (len > HETPR_NBYTES_WR_MAX))
+			return 0;
+
+		/* quad mode write parameter */
+		/* [FIX ME: do we need to add dummy cycle here? ] */
+		writeData = (uint32_t)((0x1<<HETPR_CS_HOLD)|(len<<HETPR_NBYTES_WR));
+		__raw_writel(writeData, reg + HIGH_EFFICY_TRS_PAR_REG);
+		printk("len %x, high efficiency write Data %x\n", len, writeData);
+
+
+		/* quad mode write data */
+		writeData = __cpu_to_be32p((uint32_t *)src);
+		__raw_writel(writeData, reg + HIGH_EFFICY_CMD_DATA_REG);
+		printk("original data %x, len %x, write Data %x\n",*(uint32_t *)src, len, writeData);
+		finished = len;
+	}
+	else{ /* Legacy SPI mode */
+		/* Sanity checks */
+		if ((!len) || ( len > DCR_NBYTES_MAX ))
+			return 0;
+		/* transformed to big endian format */
+
+		writeData = __cpu_to_be32p((uint32_t *)src)>>BITS_PER_BYTE;
+
+		 writeData = (uint32_t)((0x1<<DCR_CS_HOLD) | (len<<DCR_NBYTES) | (writeData & 0x00FFFFFF));
+
+		__raw_writel(writeData, reg + DATA_COMMAND_REG);
+		finished = len;
+		/* Dummy read */
+		//dummyData = __raw_readl(reg + DATA_COMMAND_REG);
+	}
+
+
+	return finished;
+	}
+/*
+ * sflash_unit_read_csr: read data from SPI flash by CSR window
+ * In quad mode, read length should no more than 0xFFFF bytes
+ * In legacy mode, read length should no more than 3 bytes
+ * @buf, location of the data
+ * @len, read length
+ *
+ * Data read from command/data register is big endian format. It will be
+ * transformed to little endian format.
+ *
+ */
+static uint32_t sflash_unit_read_csr(struct ce5xx_sflash *dev, const u_char *buf, size_t len)
+{
+	uint32_t readData = 0;
+    uint32_t writeData = 0;
+
+	volatile void __iomem *reg = dev->regs_base;
+
+	int num1 = 0, num2 = 0, i;
+	volatile u_char *dst = (u_char *)&readData;
+	uint32_t finished = 0;
+	uint32_t tmp = 0;
+
+	if (dev->mode & SPI_MODE_QUAD_IO){
+		spi_dbg_func;
+
+		/* Sanity checks */
+		if ((!len) || ( len > HETPR_NBYTES_RD_MAX))
+			return 0;
+
+		num1 = len/(sizeof(uint32_t));
+		num2 = len%(sizeof(uint32_t));
+
+		writeData = (uint32_t)((0x1<<HETPR_CS_HOLD)|(len<<HETPR_NBYTES_RD));
+		__raw_writel(writeData, reg + HIGH_EFFICY_TRS_PAR_REG);
+
+		if (num1){
+			for (i = 0; i < num1; i++){
+				readData =__raw_readl(reg + HIGH_EFFICY_CMD_DATA_REG)<<BITS_OF_BYTES(4-len);
+				tmp = (*(uint32_t *)dst>>BITS_OF_BYTES(len))<<BITS_OF_BYTES(len);
+				*(uint32_t *)dst = __be32_to_cpu(readData)|tmp;
+
+				finished += sizeof(uint32_t);
+			}
+		}
+		if (num2){
+			readData = __raw_readl(reg + HIGH_EFFICY_CMD_DATA_REG)<<BITS_OF_BYTES(4-len);
+			tmp = (*(uint32_t *)dst>>BITS_OF_BYTES(len))<<BITS_OF_BYTES(len);
+			*(uint32_t *)dst = __be32_to_cpu(readData)|tmp;
+
+			finished+=num2;
+		}
+	}
+	else {
+
+		/* Sanity checks */
+		if ((!len)||( len > DCR_NBYTES_MAX))
+			return 0;
+		__raw_writel((0x1<<DCR_CS_HOLD)|(len<<DCR_NBYTES),reg + DATA_COMMAND_REG);
+
+		/* Alligned to a integar in big endian format */
+	    readData = __raw_readl(reg + DATA_COMMAND_REG)<<BITS_OF_BYTES(4-len);
+		readData = __be32_to_cpu(readData);
+		finished+=len;
+	}
+	memcpy((void *)buf,(void *)dst,len);
+	//spi_dbg(" [%s], buf 0x%x, len 0x%x\n", __FUNCTION__, buf, len);
+
+	return finished;
+}
+
+
+/*
+ * ce5xx_sflash_transmiter: program data to SPI flash
+ * @buf, location of the data
+ * @len, write size
+ */
+static uint32_t ce5xx_sflash_transmiter(struct ce5xx_sflash	 *dev, void *buf, size_t len)
+{
+	uint32_t remain = len;
+	uint32_t finished = 0;
+	u_char * src = (u_char *)buf;
+	int limit = 0;
+	int count =0;
+
+	/* Sanity checks */
+	if ((!len) || (!src))
+		return 0;
+
+	if (dev->mode & SPI_MODE_QUAD_IO)
+		limit = HETPR_NBYTES_WR_MAX;
+	else
+		limit = DCR_NBYTES_MAX;
+
+	while (remain)
+	{
+		count = (remain>limit?limit:remain);
+		count = ce5xx_sflash_unit_write(dev,src + finished,count);
+		finished += count;
+		remain -=count;
+	}
+//	printk(" [%s] transmiting 0x%x bytes data to buf 0x%x\n", __FUNCTION__, len, buf);
+	return finished;
+}
+/*
+ * ce5xx_sflash_read: read data from flash device
+ */
+static uint32_t ce5xx_sflash_csr_receiver(struct ce5xx_sflash *dev, void *buf, size_t len)
+{
+	uint32_t remain = len;
+	uint32_t finished = 0;
+	u_char * src = (u_char *)buf;
+
+	int limit = 0;
+	int count =0;
+
+	/* Sanity checks */
+	if (!len)
+		return 0;
+
+	if (dev->mode & SPI_MODE_QUAD_IO)
+		limit = HETPR_NBYTES_RD_MAX;
+	else
+		limit = DCR_NBYTES_MAX;
+
+	//spi_dbg(" [%s] reading 0x%x bytes data to buf 0x%x\n", __FUNCTION__, len, buf);
+
+
+	while (remain)
+	{
+		count = (remain>limit?limit:remain);
+		count = sflash_unit_read_csr(dev,src + finished,count);
+		finished += count;
+		remain -=count;
+	}
+	return finished;
+}
+/*
+ * ce5xx_sflash_read: read data from memory window
+ */
+static uint32_t ce5xx_sflash_dma_receiver(struct ce5xx_sflash *dev, void *to, uint32_t offset, size_t len)
+{
+	void __iomem *from;
+
+	/* Sanity checks */
+	if ((!len) || (!to))
+		return 0;
+
+	from = dev->mem_base + offset;
+	spi_dbg(" [%s], flash addr: 0x%x, to 0x%x, len 0x%x\n",__FUNCTION__,(uint32_t)(dev->mem_base + offset), len, to);
+	memcpy(to,from, len);
+
+	return len;
+}
+
+
+/* Switch to a target CS_num and disable the other CS
+ * This is only used for CSR access
+ */
+static void ce5xx_sflash_cs_switch(struct ce5xx_sflash *dev, int cs_num)
+{
+	ce5xx_sflash_cs_enable(dev,(cs_num == 0),(cs_num == 1));
+}
+/* This is responsible for entire one operation */
+static void ce5xx_sflash_work_one(struct ce5xx_sflash *dev, struct spi_message *m)
+{
+	struct spi_device *spi = m->spi;
+	struct spi_transfer *t;
+
+	ce5xx_sflash_turn_off_chip_sel(dev);
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+
+		void *txbuf = (void *)t->tx_buf;
+		void *rxbuf = (void *)t->rx_buf;
+		uint32_t len = t->len;
+		uint32_t	actual_len = 0;
+
+		//spi_dbg(" [%s] m 0x%x, t 0x%x ,buf 0x%x, dma 0x%x, len 0x%x\n",__FUNCTION__,m,t,(u32)t->rx_buf, (u32)t->rx_dma, t->len);
+
+		/*
+		 * A transfer could be one of three types, csr_read, data_read, write
+		 * chip select number is decided by spi->chip_select
+		 */
+		/* Memory mapped method access
+		 * rx_dma is used to indicate memory window read access
+		 */
+
+		if (t->rx_buf && m->is_dma_mapped) {
+			/* CSR access method */
+			ce5xx_sflash_cs_enable(dev,dev->cntl_data->cs0_size,dev->cntl_data->cs1_size);
+
+			actual_len = dev->dma_receiver(dev,rxbuf,t->rx_dma,len);
+		}
+		else {
+
+		/* CSR access method */
+			ce5xx_sflash_cs_switch(dev, spi->chip_select);
+
+			if (t->tx_buf)
+				actual_len = dev->transmiter(dev,txbuf,len);
+			if (t->rx_buf)
+				actual_len = dev->csr_receiver(dev,rxbuf,len);
+
+		}
+		m->actual_length += actual_len;
+	}
+		spi_dbg_func;
+	ce5xx_sflash_turn_off_chip_sel(dev);
+
+	m->status = 0;
+	m->complete(m->context);
+	return;
+}
+
+static void ce5xx_sflash_work(struct work_struct *work)
+{
+	struct ce5xx_sflash *c = container_of(work, struct ce5xx_sflash, work);
+	unsigned long flags;
+
+	spin_lock_irqsave(&c->lock, flags);
+	while (!list_empty(&c->queue)) {
+		struct spi_message *m;
+		m = container_of(c->queue.next, struct spi_message, queue);
+		list_del_init(&m->queue);
+		spin_unlock_irqrestore(&c->lock, flags);
+		ce5xx_sflash_work_one(c, m);
+			spi_dbg_func;
+		spin_lock_irqsave(&c->lock, flags);
+	}
+	spin_unlock_irqrestore(&c->lock, flags);
+	spi_dbg_func;
+
+}
+
+static int ce5xx_sflash_transfer(struct spi_device *spi, struct spi_message *m)
+{
+	struct spi_master *master = spi->master;
+	struct ce5xx_sflash *c = spi_master_get_devdata(master);
+	struct spi_transfer *t;
+	unsigned long flags;
+
+	m->actual_length = 0;
+
+	/* check each transfer's parameters */
+	list_for_each_entry (t, &m->transfers, transfer_list) {
+		if (!t->len)
+			return -EINVAL;
+		else if (!t->tx_buf && !t->rx_buf)
+			return -EINVAL;
+	}
+
+	spin_lock_irqsave(&c->lock, flags);
+	if (c->status & (SPI_FLASH_SUSPEND | SPI_FLASH_REMOVE)) {
+		spin_unlock_irqrestore(&c->lock, flags);
+		return -ESHUTDOWN;
+	}
+	list_add_tail(&m->queue, &c->queue);
+	queue_work(c->workqueue, &c->work);
+	spin_unlock_irqrestore(&c->lock, flags);
+
+	return 0;
+}
+/*
+ * Initia configuration of controller
+ * Set to legacy mode
+ * Default value is 0x44450031, SLE clock divider = 1, 33.3MHZ
+ */
+static int ce5xx_sflash_set_up_default_mode(struct ce5xx_sflash *dev)
+{
+	uint32_t	mode_cntl = 0;
+	unsigned int soc_id = 0, soc_rev = 0;
+	void __iomem *reg = dev->regs_base;
+	mode_cntl = __raw_readl(reg + MODE_CONTL_REG);
+
+	/* CLK RATIO */
+	/* #H238847, CEFDK needs to set the SPI clock to
+	16MHz for A steppings
+	32MHz for B0 and above steppings. */
+	intelce_get_soc_info(&soc_id, &soc_rev);
+	if(soc_id == CE2600_SOC_DEVICE_ID) {
+		if( soc_rev < 0x4) {
+			mode_cntl = (mode_cntl>>3<<3)|(0x2<<MODE_CONTL_CLK_RATIOR_SHIFT);
+		} else {
+			mode_cntl = (mode_cntl>>3<<3)|(0x1<<MODE_CONTL_CLK_RATIOR_SHIFT);
+		}
+	} else {
+		mode_cntl = (mode_cntl>>3<<3)|(0x1<<MODE_CONTL_CLK_RATIOR_SHIFT);
+	}
+
+	/* Boot Mode */
+#if	CE5XX_BOOT_MODE_ENABLE
+	mode_cntl |= MODE_CONTL_BOOT_MODE_ENABLE;
+#else
+	mode_cntl &= MODE_CONTL_BOOT_MODE_DISABLE;
+#endif
+	/* SS1_UNIT_EN */
+	/*
+	 * In Golden Spring, SPI IO unit will be disabled by BIOS. Thus SPI
+	 * controller initialization need be bypassed
+	*/
+	if (!(MODE_CONTL_SPI_UNIT_EN & mode_cntl))
+		return -ENODEV;
+
+	/* SS1_EN Enable CS1*/
+	mode_cntl |= MODE_CONTL_SS1_EN;
+
+	/* CMD WIDTH */
+	mode_cntl |= MODE_CONTL_CMD_WIDTH_EQUAL_TO_DATA;
+
+	/* Set SPI_WIDTH */
+	mode_cntl |= MODE_CONTL_SPI_WIDTH_1_BIT;
+
+	/* NR_ADDR_BYTES  */
+	mode_cntl |= MODE_CONTL_N_ADDR_3_BYTES;
+
+	/* Chip select */
+	mode_cntl |= MODE_CONTL_CS0_WP|MODE_CONTL_CS0_MODE_ENABLE|MODE_CONTL_CS1_MODE_ENABLE|MODE_CONTL_CS1_WP;
+
+#ifdef CS_HOLD_DEFECT_EXIST_IN_CE2600
+	/* CS will assert since CS_TAR is set. We need wait for at least 20ns */
+	if (dev->pdev->revision == CE2600_SPI_FLASH_REVISION_ID) {
+		udelay(5);
+	}
+#endif
+	/* CS_TAR */
+	mode_cntl |= 0x4<<MODE_CONTL_CS_TAR_SHIFT;
+
+	__raw_writel(mode_cntl, reg + MODE_CONTL_REG);
+
+
+	spi_dbg("initial mode cntl 0x%x\n",mode_cntl);
+#ifdef CS_HOLD_DEFECT_EXIST_IN_CE2600
+	/* Cause CS to de-assert by this method */
+	if (dev->pdev->revision == CE2600_SPI_FLASH_REVISION_ID) {
+		tmp = 0;
+		__raw_writel(tmp, reg + DATA_COMMAND_REG);
+	}
+#endif
+	return 0;
+}
+
+
+/*
+ * Set controller to be the mode defined by serial flash devices
+ */
+static int ce5xx_sflash_setup(struct spi_device *spi)
+{
+	uint32_t	mode_cntl = 0;
+	struct ce5xx_sflash *dev = spi_master_get_devdata(spi->master) ;
+	void __iomem *reg		 = dev->regs_base;
+	unsigned long flags;
+
+	dev->cntl_data			= spi->controller_data;
+	dev->mode				= spi->mode;
+
+	spi_dbg_func;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (dev->status & (SPI_FLASH_SUSPEND | SPI_FLASH_REMOVE)) {
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return -ESHUTDOWN;
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	/*If no controller data from device layer, then set the controller works in default mode */
+	if (!dev->cntl_data)
+		return ce5xx_sflash_set_up_default_mode(dev);
+	/* Setup up Address Split Register */
+	if (address_split_cfg(dev))
+		return -ENODEV;
+
+	mode_cntl	=	__raw_readl(reg + MODE_CONTL_REG);
+
+	/* Setup up Mode Contrl Register */
+	mode_cntl &= MODE_CONTL_N_ADDR_BYTES_MASK;
+	switch (spi->bits_per_word>>3)
+	{
+
+		case 3:
+			mode_cntl |= MODE_CONTL_N_ADDR_3_BYTES;
+			break;
+		case 4:
+			mode_cntl |= MODE_CONTL_N_ADDR_4_BYTES;
+			break;
+		default:
+			dev_err(&spi->dev, "Error: not supported yet addr_width %d\n",spi->bits_per_word>>3);
+			return -ENODEV;
+	}
+	/* Using 4 BIT WIDTH in QUAD IO mode */
+	mode_cntl &= MODE_CONTL_SPI_WIDTH_BIT_MASK;
+	if (dev->mode & SPI_MODE_QUAD_IO)
+		mode_cntl |= MODE_CONTL_SPI_WIDTH_4_BIT;
+	else
+		mode_cntl |= MODE_CONTL_SPI_WIDTH_1_BIT;
+
+
+	/* Enable CS1 if there's device connected*/
+	mode_cntl &= (MODE_CONTL_CS0_MODE_DISABLE_MASK & MODE_CONTL_CS1_MODE_DISABLE_MASK);
+	if (dev->cntl_data->cs0_size)
+		mode_cntl |= MODE_CONTL_CS0_MODE_ENABLE;
+	if (dev->cntl_data->cs1_size)
+		mode_cntl |= MODE_CONTL_CS1_MODE_ENABLE;
+
+	__raw_writel(mode_cntl, reg + MODE_CONTL_REG);
+	return 0;
+}
+static int ce5xx_sflash_reboot(struct notifier_block *self, unsigned long event, void *data)
+{
+#if 0
+	struct ce5xx_sflash *c = container_of(self, struct ce5xx_sflash, reboot_notifier);
+	if (c->pdev->revision != CE2600_SPI_FLASH_REVISION_ID)
+		return NOTIFY_DONE;
+	/* Make sure ARM is not using the controller when reboot */
+	hw_mutex_lock(HW_MUTEX_NOR_SPI);
+	hw_mutex_unlock(HW_MUTEX_NOR_SPI);
+#endif
+	return NOTIFY_DONE;
+}
+static struct notifier_block ce5xx_sflash_reboot_notifier = {
+           .notifier_call   = ce5xx_sflash_reboot
+};
+
+/*Probe and Init controller */
+static int ce5xx_sflash_probe (struct pci_dev *pdev,
+                                const struct pci_device_id *id)
+{
+	struct spi_master *master;
+	struct ce5xx_sflash *c;
+	int ret = -ENODEV;
+
+	if ((pdev->device != CE5XX_SPI_FLASH_CONTROLLER_ID) || (pdev->revision < CE5300_SPI_FLASH_REVISION_ID)){
+		   return -ENODEV;
+	}
+	else
+		spi_dbg("found device 0x%08x, rev id 0x%08x\n", pdev->device, pdev->revision);
+
+	/* Determine BAR values */
+	ret = pci_enable_device(pdev);
+	if (ret)
+		 return ret;
+
+	/* SPI master register */
+	master = spi_alloc_master(&pdev->dev, sizeof(*c));
+	if (!master) {
+		ret = -ENOMEM;
+		return ret;
+	}
+	c = spi_master_get_devdata(master);
+	c->master = master;
+	c->pdev	= pdev;
+
+	pci_request_region(pdev, 0, "spi_flash_csr");
+	pci_request_region(pdev, 1, "spi_flash_mem");
+
+	c->regs_base = (void __iomem * )pci_ioremap_bar(pdev, 0);
+	if (!c->regs_base){
+		dev_err(&pdev->dev, "error, failed to ioremap sflash registers, regs_base %x\n",(uint32_t)c->regs_base);
+		ret = -ENOMEM;
+		goto out_release_master;
+	}
+	c->mem_base = (void __iomem * )pci_ioremap_bar(pdev, 1);
+	if (!c->regs_base){
+		dev_err(&pdev->dev, "error, failed to ioremap sflash mem space, mem_base %x\n",(uint32_t)c->mem_base);
+		ret = -ENOMEM;
+		goto out_release_bar0;
+	}
+
+	dev_info(&pdev->dev, "csr iobase 0x%x, iosize 0x%x , mapped to 0x%x\n",(uint32_t)pci_resource_start(pdev,0),(uint32_t)pci_resource_len(pdev,0),(uint32_t)c->regs_base);
+	dev_info(&pdev->dev, "mem iobase 0x%x, iosize 0x%x , mapped to 0x%x\n",(uint32_t)pci_resource_start(pdev,1),(uint32_t)pci_resource_len(pdev,1),(uint32_t)c->mem_base);
+
+
+	/* Lock/queue initliazation */
+	INIT_WORK(&c->work, ce5xx_sflash_work);
+	spin_lock_init(&c->lock);
+	INIT_LIST_HEAD(&c->queue);
+
+	c->workqueue = create_singlethread_workqueue(
+					dev_name(master->dev.parent));
+	if (!c->workqueue)
+		goto out_free_region;
+
+	master->bus_num 	= id->driver_data;
+	master->setup 		= ce5xx_sflash_setup;
+	master->transfer 	= ce5xx_sflash_transfer;
+	master->num_chipselect = 2; /* Two chip selects */
+	master->mode_bits	= SPI_MODE_0|SPI_MODE_QUAD_IO;
+
+
+	pci_set_drvdata(pdev, c);
+
+	/* Set controller working in legacy SPI mode */
+	c->transmiter	= ce5xx_sflash_transmiter;
+	c->csr_receiver	= ce5xx_sflash_csr_receiver;
+	c->dma_receiver	= ce5xx_sflash_dma_receiver;
+
+	spi_register_board_info(CE5xx_sflash_devices,ARRAY_SIZE(CE5xx_sflash_devices));
+
+	ret = spi_register_master(master);
+	if (ret)
+		goto out_unregister_board;
+
+	c->reboot_notifier	= &ce5xx_sflash_reboot_notifier;
+	register_reboot_notifier(c->reboot_notifier);
+	return 0;
+
+out_unregister_board:
+	spi_unregister_board_info(CE5xx_sflash_devices,1);
+	pci_set_drvdata(pdev, NULL);
+
+	if (c->workqueue)
+		destroy_workqueue(c->workqueue);
+out_free_region:
+	pci_release_region(pdev, 0);
+	pci_release_region(pdev, 1);
+	iounmap(c->mem_base);
+out_release_bar0:
+	iounmap(c->regs_base);
+
+out_release_master:
+	spi_master_put(master);
+	pci_disable_device(pdev);
+	return ret;
+}
+
+static void ce5xx_sflash_remove(struct pci_dev *pdev)
+{
+	struct ce5xx_sflash *c = pci_get_drvdata(pdev);
+	unsigned long flags;
+	spi_dbg_func;
+
+
+	spin_lock_irqsave(&c->lock, flags);
+	c->status |= SPI_FLASH_REMOVE;
+	spin_unlock_irqrestore(&c->lock, flags);
+
+	flush_workqueue(c->workqueue);
+
+	unregister_reboot_notifier(c->reboot_notifier);
+	spi_unregister_board_info(CE5xx_sflash_devices,1);
+	pci_set_drvdata(pdev,NULL);
+	if (c->workqueue)
+		destroy_workqueue(c->workqueue);
+	if (c->regs_base)
+		iounmap(c->regs_base);
+	if (c->mem_base)
+		iounmap(c->mem_base);
+	pci_release_region(pdev, 0);
+	pci_release_region(pdev, 1);
+	spi_unregister_master(c->master);
+	pci_disable_device(pdev);
+
+}
+
+#ifdef CONFIG_PM
+ static int ce5xx_sflash_device_suspend(struct device *dev)
+ {
+	struct ce5xx_sflash *c = dev_get_drvdata(dev);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	unsigned long flags;
+	unsigned int id;
+	int ret = 0;
+
+	/*set SUSPEND flag*/
+	spin_lock_irqsave(&c->lock, flags);
+	c->status |= SPI_FLASH_SUSPEND;
+	spin_unlock_irqrestore(&c->lock, flags);
+
+	flush_workqueue(c->workqueue);
+
+	intelce_get_soc_info(&id, NULL);
+	switch (id) {
+		case CE2600_SOC_DEVICE_ID:
+			break;
+		default:
+			c->mode_contrl = flash_read32(c->regs_base + MODE_CONTL_REG);
+			c->addr_split  = flash_read32(c->regs_base + ADDR_SPLIT_REG);
+			c->inf_conf = flash_read32(c->regs_base + INTERFACE_CONFIG_REG);
+			c->hetp = flash_read32(c->regs_base + HIGH_EFFICY_TRS_PAR_REG);
+			c->heop = flash_read32(c->regs_base + HIGH_EFFICY_OPCODE_REG);
+
+			pci_disable_device(pdev);
+			pci_save_state(pdev);
+			pci_set_power_state(pdev, PCI_D3hot);
+			break;
+	}
+	return ret;
+ }
+
+ static int ce5xx_sflash_device_resume(struct device *dev)
+ {
+	struct ce5xx_sflash *c = dev_get_drvdata(dev);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	unsigned int id;
+	unsigned long flags;
+	int ret = 0;
+
+	intelce_get_soc_info(&id, NULL);
+
+	switch (id) {
+	case CE2600_SOC_DEVICE_ID:
+		break;
+	default:
+		pci_set_power_state(pdev, PCI_D0);
+		pci_restore_state(pdev);
+		pci_enable_device(pdev);
+
+		flash_write32(c->mode_contrl, c->regs_base + MODE_CONTL_REG);
+		flash_write32(c->addr_split, c->regs_base + ADDR_SPLIT_REG);
+		flash_write32(c->inf_conf, c->regs_base + INTERFACE_CONFIG_REG);
+		flash_write32(c->hetp & (0xF0000000), c->regs_base + HIGH_EFFICY_TRS_PAR_REG);
+		flash_write32(c->heop, c->regs_base + HIGH_EFFICY_OPCODE_REG);
+	}
+	/*clear SUSPEND flag*/
+	spin_lock_irqsave(&c->lock, flags);
+	c->status &= ~SPI_FLASH_SUSPEND;
+	spin_unlock_irqrestore(&c->lock, flags);
+	return ret;
+ }
+
+static const struct dev_pm_ops nmyx25_pm_ops = {
+	.suspend    = ce5xx_sflash_device_suspend,
+	.resume     = ce5xx_sflash_device_resume,
+};
+#endif
+
+static struct pci_driver ce5xx_sflash_driver = {
+	.name			= "ce5xx-spi-flash",
+	.id_table		= ce5xx_sflash_pci_tbl,
+	.probe			= ce5xx_sflash_probe,
+	.remove			= ce5xx_sflash_remove,
+#ifdef CONFIG_PM
+	.driver.pm		= &nmyx25_pm_ops,
+#endif
+};
+
+static int ce5xx_sflash_init(void)
+{
+	printk(KERN_INFO "Intel(R) SPI FLASH CONTROLLER Driver built on %s @ %s\n", __DATE__, __TIME__);
+
+	return pci_register_driver(&ce5xx_sflash_driver);
+
+}
+static void ce5xx_sflash_exit(void)
+{
+	pci_unregister_driver(&ce5xx_sflash_driver);
+}
+
+module_init(ce5xx_sflash_init);
+module_exit(ce5xx_sflash_exit);
+
+MODULE_DESCRIPTION("Intel(R) SPI FLASH CONTROLLER Driver");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL");
+
--- /dev/null
+++ b/drivers/spi/ce5xx_spi_flash.h
@@ -0,0 +1,154 @@
+/*
+ * GPL LICENSE SUMMARY
+ * Copyright (c) 2011, Intel Corporation and its suppliers.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef CE5XX_SPI_FLASH_H
+#define CE5XX_SPI_FLASH_H
+
+/* Set controller working in boot mode, using direct memory window for device read */
+#define CE5XX_BOOT_MODE_ENABLE					1
+
+#define INTEL_VENDOR_ID 						0x8086
+#define CERSV1_DEVID 							0x0DC0
+#define CERSV2_DEVID 							0x0932
+
+#define CE5XX_SPI_FLASH_CONTROLLER_ID 			0x08A0
+#define CE5300_SPI_FLASH_REVISION_ID			0x00
+#define CE2600_SPI_FLASH_REVISION_ID			0x02
+
+
+/* Controller Register Set */
+#define MODE_CONTL_REG       					0
+
+#define MODE_CONTL_CLK_RATIOR_SHIFT				0
+#define MODE_CONTL_BOOT_MODE_ENABLE				(1<<4)
+#define MODE_CONTL_BOOT_MODE_DISABLE			(~(1<<4))
+#define MODE_CONTL_SPI_UNIT_EN					(1<<5)
+#define MODE_CONTL_SS1_EN						(1<<6)
+
+#define MODE_CONTL_CMD_WIDTH_EQUAL_TO_DATA		(0<<9)
+#define MODE_CONTL_CMD_WIDTH_1_DATA_LINE		(1<<9)
+
+#define MODE_CONTL_SPI_WIDTH_1_BIT				(1<<10)
+#define MODE_CONTL_SPI_WIDTH_2_BIT				(2<<10)
+#define MODE_CONTL_SPI_WIDTH_4_BIT				(3<<10)
+#define MODE_CONTL_SPI_WIDTH_BIT_MASK			(~(3<<10))
+
+#define MODE_CONTL_N_ADDR_2_BYTES				(2<<12)
+#define MODE_CONTL_N_ADDR_3_BYTES				(3<<12)
+#define MODE_CONTL_N_ADDR_4_BYTES				(4<<12)
+#define MODE_CONTL_N_ADDR_BYTES_MASK			(~(0xf<<12))
+
+
+#define MODE_CONTL_CS0_MODE_ENABLE				(1<<16)
+#define MODE_CONTL_CS0_WP						(1<<18)	
+#define MODE_CONTL_CS0_MODE_DISABLE_MASK		(~(3<<16))
+
+#define MODE_CONTL_CS1_MODE_ENABLE				(1<<20)
+#define MODE_CONTL_CS1_WP						(1<<22)	
+#define MODE_CONTL_CS1_MODE_DISABLE_MASK		(~(3<<20))
+
+#define MODE_CONTL_CS_TAR_SHIFT					24
+
+
+#define ADDR_SPLIT_REG                  		0x04
+#define CS0_CMP                                 0
+#define CS0_MASK                                4
+#define CS1_CMP                                 8
+#define CS1_MASK                                12
+
+#define CURRENT_ADDR_REG               	 		0x08
+#define DATA_COMMAND_REG                		0x0C
+#define DCR_CS_HOLD                             26
+#define DCR_NBYTES                              24
+#define DCR_NBYTES_MAX                          3
+#define DCR_DATA_FIRST_BYTE                     16
+#define DCR_DATA_SECOND_BYTE            		8
+#define DCR_DATA_THIRD_BYTE                     0
+#define DCR_DATA                                0
+#define INTERFACE_CONFIG_REG            		0x10
+
+#define HIGH_EFFICY_CMD_DATA_REG        		0x20
+#define HECDR_FIRST_BYTE                        24
+#define HECDR_SECOND_BYTE                       16
+#define HECDR_THIRD_BYTE                        8
+#define HECDR_FORTH_BYTE                        0
+
+
+#define HIGH_EFFICY_TRS_PAR_REG         		0x24
+#define HETPR_DUMMY_CYCLE               		28
+#define HETPR_CS_HOLD                   		27
+#define HETPR_NBYTES_WR                 		24
+#define HETPR_NBYTES_WR_MAX     				4
+#define HETPR_NBYTES_RD                 		0
+#define HETPR_NBYTES_RD_MAX             		0xFFFF
+#define HIGH_EFFICY_OPCODE_REG          		0x28
+
+enum {
+	SPI_FLASH_REMOVE_BIT = 1,
+	SPI_FLASH_SUSPEND_BIT,
+};
+
+#define SPI_FLASH_REMOVE	(1 << SPI_FLASH_REMOVE_BIT)
+#define SPI_FLASH_SUSPEND	(1 << SPI_FLASH_SUSPEND_BIT)
+
+struct ce5xx_sflash {
+	struct work_struct 			work;
+	struct workqueue_struct		*workqueue;
+	spinlock_t 					lock;				/* protect 'queue' */
+	struct list_head 			queue;
+	
+	void __iomem 				*mem_base;
+	void __iomem 				*regs_base;
+	
+	struct pci_dev 				*pdev;
+	struct spi_master 			*master;
+
+	uint16_t					mode;
+	struct flash_cs_info 		*cntl_data;			/* Device size info in each chip select */
+	struct ce5xx_address_split * addr_split_methd;	/* Address Split register value for the current flash layout */
+	struct notifier_block 		*reboot_notifier;	/* Reboot notification */
+	int  status;
+
+	uint32_t (*transmiter)	(struct ce5xx_sflash *dev, void *buf, size_t len);
+	uint32_t (*dma_receiver)(struct ce5xx_sflash *dev, void *to, uint32_t offset, size_t len);
+	uint32_t (*csr_receiver)(struct ce5xx_sflash *dev, void *buf, size_t len);
+	
+	/* S2Ram stored register */
+	uint32_t mode_contrl; /* mode control */
+	uint32_t addr_split; /* address split */
+	uint32_t cur_addr; /* current address */
+	uint32_t command; /* command/data */
+	uint32_t inf_conf; /* interface configuration */
+	uint32_t hecd;  /* high efficiency command/data */
+	uint32_t hetp;	/* high efficiency transaction parameters */
+	uint32_t heop; /* high efficiency opcode */
+	
+};
+struct ce5xx_address_split {
+	uint32_t 	cs0_size;
+	uint32_t	cs1_size;
+
+	uint16_t	cs0_cmp:4;
+	uint16_t	cs0_mask:4;	
+	uint16_t	cs1_cmp:4;
+	uint16_t	cs1_mask:4;
+}__attribute__((aligned(4)));
+
+
+#endif
--- /dev/null
+++ b/drivers/spi/ce5xx_spi_slv.c
@@ -0,0 +1,656 @@
+/*
+#
+#  This file is provided under a dual BSD/GPLv2 license.  When using or
+#  redistributing this file, you may do so under either license.
+#
+#  GPL LICENSE SUMMARY
+#
+#  Copyright(c) 2011-2012 Intel Corporation. All rights reserved.
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of version 2 of the GNU General Public License as
+#  published by the Free Software Foundation.
+#
+#  This program is distributed in the hope that it will be useful, but
+#  WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#  General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program; if not, write to the Free Software
+#  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#  The full GNU General Public License is included in this distribution
+#  in the file called LICENSE.GPL.
+#
+#  Contact Information:
+#  intel.com
+#  Intel Corporation
+#  2200 Mission College Blvd.
+#  Santa Clara, CA  95052
+#  USA
+#  (408) 765-8080
+#
+#*/
+/*------------------------------------------------------------------------------
+ * File Name: ce5xx_spi_slv.c
+ * Driver for  SPI Slave controller
+ *------------------------------------------------------------------------------
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/pci.h>
+#include <linux/circ_buf.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+
+#include "ce5xx_spi_slv.h"
+
+#ifdef DEBUG
+#define spi_slv_dbg(fmt, args...) do \
+    { \
+	            printk(KERN_INFO fmt, ##args); \
+	    } while (0)
+#else
+#define spi_slv_dbg(fmt, arg...) do { } while (0)
+#endif
+
+struct spi_slv{
+     /* lock to protect the critical area */
+ 	 spinlock_t lock;
+	 /* Driver model hookup */
+ 	 struct pci_dev *pdev;
+	 struct spi_master *master;
+
+	 /* SSP register addresses */
+	 void __iomem *ioaddr;
+	 u32 phy_base;
+	 u32 phy_len;
+	 s32 irq;
+
+
+#define SPI_SLV_CIRC_SIZE    (4*1024)
+ /* tx/rv circ buf */
+ 	struct circ_buf tx;
+ 	struct circ_buf rx;
+
+	u32 shift_per_word;
+
+    int waiting_len;
+	 /* Driver message queue and workqueue */
+	 struct workqueue_struct *workqueue;
+	 struct work_struct work;
+	 struct list_head queue;
+
+	 struct completion done;
+
+
+	 int (*transmitter)(struct spi_slv *slv);
+	 int (*receiver)(struct spi_slv *slv);
+
+ };
+
+static int buffer_size = SPI_SLV_CIRC_SIZE;
+module_param(buffer_size, int, S_IRUGO);
+
+static inline void  slv_circs_clear(struct spi_slv *slv)
+{
+		 slv->tx.head = slv->tx.tail = 0;
+		 slv->rx.head = slv->rx.tail = 0;
+}
+ static inline  int slv_circ_cnt(struct circ_buf *circ)
+ {
+
+		return CIRC_CNT(circ->head, circ->tail, buffer_size);
+ }
+
+ static inline int slv_circ_space(struct circ_buf *circ)
+ {
+
+		return CIRC_SPACE(circ->head, circ->tail, buffer_size);
+ }
+
+ static inline bool slv_circ_full(struct circ_buf *circ)
+ {
+
+		return !CIRC_SPACE(circ->head, circ->tail, buffer_size);
+ }
+
+ static inline bool slv_circ_empty(struct circ_buf *circ)
+ {
+		return (circ->head == circ->tail);
+ }
+
+ static inline void __slv_write32(struct spi_slv *slv, u32 reg_offset, u32 value)
+ {
+	 void __iomem *addr = (void __iomem *)slv->ioaddr;
+	 __raw_writel(value, addr + reg_offset);
+
+ }
+ static inline u32  __slv_read32(struct spi_slv *slv, u32 reg_offset)
+ {
+	 void __iomem *addr = (void __iomem *)slv->ioaddr;
+	 return __raw_readl(addr + reg_offset);
+ }
+
+ static int slv_u8_transmitter(struct spi_slv *slv)
+ {
+ 	struct circ_buf *circ = &slv->tx;
+	int count = 0;
+
+	while ((__slv_read32(slv,SPI_SLV_SSSR) & SPI_SLV_TNF)
+			&& (slv_circ_cnt(circ) > 0)) {
+			__slv_write32(slv, SPI_SLV_SSDR, *(u8 *)(circ->buf + circ->tail));
+			circ->tail = ((circ->tail + 1) & (buffer_size - 1));
+		   count++;
+	}
+	return count;
+ }
+
+ static int slv_u8_receiver(struct spi_slv *slv)
+ {
+ 	struct circ_buf *circ = &slv->rx;
+	u8 ch;
+	int count = 0;
+	 while (__slv_read32(slv,SPI_SLV_SSSR) & SPI_SLV_RNE) {
+	 	 ch = __slv_read32(slv,SPI_SLV_SSDR);
+		 if (slv_circ_space(circ) > 0) {
+		 	*(u8 *)(circ->buf + circ->head) = ch;
+		 	circ->head = ((circ->head + 1) & (buffer_size - 1));
+			count++;
+		 }
+	 }
+	return count;
+  }
+
+ static int slv_u16_transmitter(struct spi_slv *slv)
+ {
+	 struct circ_buf *circ = &slv->tx;
+	 int count = 0;
+
+	 while ((__slv_read32(slv,SPI_SLV_SSSR) & SPI_SLV_TNF)
+			 && (slv_circ_cnt(circ) >= 2 )) {
+			 __slv_write32(slv, SPI_SLV_SSDR, *(u16 *)(circ->buf + circ->tail));
+			 circ->tail = ((circ->tail + 2) & (buffer_size - 1));
+			count += 2;
+	 }
+
+	return count;
+
+ }
+
+ static int slv_u16_receiver(struct spi_slv *slv)
+ {
+	 struct circ_buf *circ = &slv->rx;
+	 u16 ch;
+	 int count = 0;
+	 while (__slv_read32(slv,SPI_SLV_SSSR) & SPI_SLV_RNE) {
+		  ch = __slv_read32(slv,SPI_SLV_SSDR);
+		  if (slv_circ_space(circ) >= 2) {
+			 *(u16 *)(circ->buf + circ->head) = ch;
+			 circ->head = ((circ->head + 2) & (buffer_size - 1));
+			 count += 2;
+		  }
+	 }
+	 return count;
+ }
+
+ static int slv_u32_transmitter(struct spi_slv *slv)
+ {
+	struct circ_buf *circ = &slv->tx;
+	int count = 0;
+
+	while ((__slv_read32(slv,SPI_SLV_SSSR) & SPI_SLV_TNF)
+		 && (slv_circ_cnt(circ) >= 4 )) {
+		 __slv_write32(slv, SPI_SLV_SSDR, *(u32 *)(circ->buf + circ->tail));
+		 circ->tail = ((circ->tail + 4) & (buffer_size - 1));
+		count++;
+	 }
+
+	return count;
+
+ }
+
+ static int slv_u32_receiver(struct spi_slv *slv)
+ {
+	 struct circ_buf *circ = &slv->rx;
+	 u32 ch;
+	 int count = 0;
+	 while (__slv_read32(slv,SPI_SLV_SSSR) & SPI_SLV_RNE) {
+		  ch = __slv_read32(slv,SPI_SLV_SSDR);
+		  if (slv_circ_space(circ) >= 4) {
+			 *(u32 *)(circ->buf + circ->head) = ch;
+			 circ->head = ((circ->head + 4) & (buffer_size - 1));
+			 count += 4;
+		  }
+	 }
+	 return count;
+
+}
+
+/*slv is configureed and enabled*/
+static int spi_slv_setup(struct spi_device *spi)
+{
+	struct spi_slv *slv = spi_master_get_devdata(spi->master);
+	int ret = 0;
+	u32 dds = 0, value = 0;
+
+	if (list_empty(&slv->queue)) {
+		switch (spi->bits_per_word) {
+			case 8:
+				slv->shift_per_word = 0;
+				slv->transmitter = slv_u8_transmitter;
+				slv->receiver = slv_u8_receiver;
+				dds = SPI_SLV_DSS_8;
+				break;
+
+			case 16:
+				slv->shift_per_word = 1;
+				slv->transmitter = slv_u16_transmitter;
+				slv->receiver = slv_u16_receiver;
+				dds = SPI_SLV_DSS_16;
+				break;
+
+			case 32:
+				slv->shift_per_word = 2;
+				slv->transmitter = slv_u32_transmitter;
+				slv->receiver = slv_u32_receiver;
+				dds = SPI_SLV_DSS_32;
+				break;
+
+			default:  /* default use 8 bits */
+			  spi->bits_per_word = 8;
+			  	break;
+		}
+	} else {
+		ret = -EBUSY;
+	}
+	if (!ret) {
+		value = __slv_read32(slv, SPI_SLV_SSCR0);
+		__slv_write32(slv, SPI_SLV_SSCR0, value & ~SPI_SLV_SSE);
+		mdelay(10);
+
+		__slv_write32(slv, SPI_SLV_SSCR0, SPI_SLV_SSE | dds | (0x1 << 5));
+		mdelay(10);
+		__slv_write32(slv, SPI_SLV_SSCR1, SPI_SLV_RIE ); /*fix me  define the macro for it */
+		slv_circs_clear(slv);
+
+	}
+
+	return ret;
+
+}
+
+static void spi_slv_cleanup(struct spi_device *spi)
+{
+	struct spi_slv *slv = spi_master_get_devdata(spi->master);
+	u32 value;
+
+	value = __slv_read32(slv, SPI_SLV_SSCR0);
+	__slv_write32(slv, SPI_SLV_SSCR0, value & ~SPI_SLV_SSE);
+	slv_circs_clear(slv);
+
+}
+
+static int spi_slv_transfer(struct spi_device *spi, struct spi_message *m)
+{
+	struct spi_slv *slv = spi_master_get_devdata(spi->master);
+	int ret = 0;
+
+	m->actual_length = 0;
+	m->status = -EINPROGRESS;
+	spin_lock(&slv->lock);
+	list_add_tail(&m->queue, &slv->queue);
+	queue_work(slv->workqueue, &slv->work);
+	spin_unlock(&slv->lock);
+	return ret;
+}
+static void spi_slv_pump_messages(struct work_struct *work)
+{
+	struct spi_slv *slv;
+
+	unsigned int bytes_per_word = 0;
+	unsigned int mask = 0;
+
+	slv = container_of(work, struct spi_slv, work);
+	bytes_per_word = 1 << slv->shift_per_word;
+	mask = ~(bytes_per_word - 1);
+
+	spin_lock(&slv->lock);
+	while(!list_empty(&slv->queue)) {
+		struct spi_message *m;
+		struct spi_transfer *t;
+
+		m = container_of(slv->queue.next, struct spi_message, queue);
+		list_del_init(&m->queue);
+		spin_unlock(&slv->lock);
+
+		list_for_each_entry(t, &m->transfers, transfer_list) {
+			int count = 0, c = 0;
+
+			slv->waiting_len = 0;
+			t->len = t->len & mask;
+			if (t->tx_buf) {
+				struct circ_buf *circ= &slv->tx;
+				count = t->len;
+
+					while(1) {
+						if (0 == count) break;
+						c = CIRC_SPACE_TO_END(circ->head, circ->tail, buffer_size);
+						c &= mask;
+						if (count < c)
+							c = count;
+						if (c <= 0) break;
+						memcpy(circ->buf + circ->head, t->tx_buf, c);
+						circ->head = (circ->head + c) & (buffer_size - 1);
+						t->tx_buf += c;
+						count -= c;
+					}
+					t->len -= count;
+					disable_irq(slv->irq);
+					slv->transmitter(slv);
+					enable_irq(slv->irq);
+			}
+			if (t->rx_buf) {
+				struct circ_buf *circ= &slv->rx;
+
+				count = t->len;
+
+					while(1) {
+						if (0 == count) break;
+						c = CIRC_CNT_TO_END(circ->head, circ->tail, buffer_size);
+						if (count < c)
+							c = count;
+						if (c <= 0) {
+							slv->waiting_len = count;
+							wait_for_completion(&slv->done);
+							continue;
+						}
+						memcpy(t->rx_buf, circ->buf + circ->tail, c);
+						circ->tail = (circ->tail + c) & (buffer_size - 1);
+						t->rx_buf += c;
+						count -= c;
+
+					}
+
+			}
+			m->actual_length += t->len;
+
+		}
+		m->status = 0;
+		m->complete(m->context); /* the mesage has been handled */
+
+		spin_lock(&slv->lock);
+	}
+	spin_unlock(&slv->lock);
+
+}
+
+ static irqreturn_t spi_slv_int(int irq, void *dev_id)
+ {
+	 struct spi_slv *slv = dev_id;
+	 u32 mask = (SPI_SLV_ROR | SPI_SLV_TFS | SPI_SLV_RFS);
+	 u32 status;
+
+	 status = __slv_read32(slv, SPI_SLV_SSSR);
+
+	 if (!(status & mask)) /* no interrupt comes*/
+		 return IRQ_NONE;
+
+ 	 if (status & SPI_SLV_ROR) {
+		__slv_write32(slv, SPI_SLV_SSSR, status);
+		printk(KERN_ERR "Error:SPI SLAVE overrun!!\n");
+
+	 }
+
+	slv->receiver(slv);
+
+	slv->transmitter(slv);
+
+	 if (slv->waiting_len > 0) {
+		int left;
+
+	 	left = slv_circ_cnt(&slv->rx) - slv->waiting_len;
+
+	 	if (left >= 0){
+		    slv->waiting_len = 0;
+			complete(&slv->done);
+	 	}
+	 }
+	 return IRQ_HANDLED;
+
+ }
+
+
+static struct spi_board_info info[1];
+
+static int spi_slv_probe(struct pci_dev *pdev,
+		 const struct pci_device_id *id)
+ {
+	int ret = 0;
+	struct pci_bus *pbus;
+	struct pci_dev *root;
+	struct spi_master *master;
+	struct spi_slv *slv;
+
+    pbus = pci_find_bus(0, 0); /*get the bus 0 in domain 0*/
+	root = pci_get_slot(pbus, 0); /*get pci root above bus 0 D0F0*/
+
+	switch (root->device) {
+
+		case  0x0c40:
+		   spi_slv_dbg("CE5300 board,SLV is found!\n");/*only CE5300 have spl slave controller*/
+		   break;
+	  	default:
+		   return ret = -ENODEV;
+	}
+    pci_dev_put(root);
+
+	ret = pci_enable_device(pdev);
+	if (ret)
+		 return ret;
+
+	 /* Allocate master with space for slv	*/
+	master = spi_alloc_master(&pdev->dev, 0);
+	if (!master) {
+		 dev_err(&pdev->dev, "can't alloc spi_master\n");
+		 return -ENOMEM;
+	 }
+	 /* the spi->mode bits understood by this driver: */
+	 master->bus_num = id->driver_data;
+	 master->num_chipselect = 1;
+	 master->using_slave = 1;
+	 master->setup = spi_slv_setup;
+	 master->transfer = spi_slv_transfer;
+ 	 master->cleanup = spi_slv_cleanup;
+
+	 strcpy(info[0].modalias, "spidev");
+	 info[0].irq =  pdev->irq;
+	 info[0].bus_num =   master->bus_num;
+	 info[0].chip_select = 0;
+	 info[0].mode  = 0;
+	 info[0].max_speed_hz =  0;
+	 spi_register_board_info(info, 1);
+
+	 slv = kmalloc(sizeof(struct spi_slv), GFP_KERNEL);
+     if (!slv){
+            dev_err(&pdev->dev, "can't alloc memory for spi_slv\n");
+            goto out_unregister_board_info;
+     }
+     spi_master_set_devdata(master, slv); /*set master privdate data*/
+	 slv->master = master;
+	 slv->pdev = pdev;
+
+	 spin_lock_init(&slv->lock);
+	 init_completion(&slv->done);
+	 INIT_WORK(&slv->work, spi_slv_pump_messages);
+	 INIT_LIST_HEAD(&slv->queue);
+
+	 slv->tx.buf = kmalloc(buffer_size*2, GFP_KERNEL);
+	 if (!slv->tx.buf) {
+	 	printk(KERN_ERR "circ buffer alloclation fails!\n");
+	 	goto out_free_slv;
+	 }
+	 slv->rx.buf = slv->tx.buf + buffer_size;
+	 slv->tx.head = slv->tx.tail = 0;
+	 slv->rx.head = slv->rx.tail = 0;
+
+	 slv->phy_base = pci_resource_start(pdev, 0);
+	 slv->phy_len  = pci_resource_len(pdev, 0);
+	 slv->irq = pdev->irq;
+
+	 spi_slv_dbg("slv phy is %x, len is %x\n", slv->phy_base, slv->phy_len);
+	 pci_request_region(pdev, 0, "slv");
+
+	 slv->ioaddr = ioremap_nocache(slv->phy_base, slv->phy_len);
+	 if (!slv->ioaddr) {
+		 dev_err(&pdev->dev, "failed to ioremap() registers\n");
+		 ret = -EIO;
+		 goto out_release_regions;
+	 }
+
+	 ret = request_irq(slv->irq, spi_slv_int, IRQF_SHARED, "spi slave int", slv);
+	 if (ret < 0) {
+			 dev_err(&pdev->dev, "register irq %d handler failed!\n", slv->irq);
+			 goto out_iounmap;
+	 }
+
+
+		 /* alloc work queue */
+	 slv->workqueue = create_singlethread_workqueue("spi_slave");
+
+	 if (!slv->workqueue) {
+		 dev_err(&pdev->dev, "Create work queue failed!\n");
+		 ret = -EBUSY;
+		 goto out_free_irq;
+	 }
+
+	 /* Register with the SPI framework */
+
+	 ret = spi_register_master(master);
+	 if (ret != 0) {
+		 dev_err(&pdev->dev, "problem registering spi master\n");
+		 goto out_destroy_queue;
+	 }
+
+	 pci_set_drvdata(pdev, slv);
+	 return ret;
+
+out_destroy_queue:
+	 destroy_workqueue(slv->workqueue);
+
+
+out_free_irq:
+	 free_irq(slv->irq, slv);
+
+out_iounmap:
+	 iounmap(slv->ioaddr);
+
+out_release_regions:
+	 pci_release_region(pdev, 0);
+	 kfree(slv->tx.buf);
+
+out_free_slv:
+     kfree(slv);
+
+out_unregister_board_info:
+	 spi_unregister_board_info(info, 1);
+     spi_master_put(master);
+	 pci_disable_device(pdev);
+
+	 return ret;
+ }
+
+static void spi_slv_remove(struct pci_dev *pdev)
+ {
+	 struct spi_slv *slv;
+ 	 struct spi_message *m;
+	 struct list_head *l;
+	 u32 value;
+
+	 slv = pci_get_drvdata(pdev);
+
+	 value = __slv_read32(slv, SPI_SLV_SSCR0); /*disable hardware*/
+	 __slv_write32(slv, SPI_SLV_SSCR0, value & ~SPI_SLV_SSE);
+
+	 list_for_each(l, &slv->queue) {
+		m = list_entry(l, struct spi_message, queue);
+	 	m->status = -ESHUTDOWN;
+	 	m->complete(m->context); /* the mesage has been handled */
+	 }
+	 spi_unregister_master(slv->master);
+	 destroy_workqueue(slv->workqueue);
+
+	 /* Disconnect from the SPI framework */
+	 free_irq(slv->irq, slv);
+	 iounmap(slv->ioaddr);
+	 pci_release_region(pdev, 0);
+     kfree(slv->tx.buf);
+     kfree(slv);
+	 spi_unregister_board_info(info, 1);
+	 pci_set_drvdata(pdev, NULL);
+	 pci_disable_device(pdev);
+
+ }
+
+#ifdef CONFIG_PM
+ static int spi_slv_suspend(struct pci_dev *pdev, pm_message_t state)
+ {
+		 pci_save_state(pdev);
+		 pci_set_power_state(pdev, pci_choose_state(pdev, state));
+		 return 0;
+ }
+
+ static int spi_slv_resume(struct pci_dev *pdev)
+ {
+		 pci_set_power_state(pdev, PCI_D0);
+		 pci_restore_state(pdev);
+		 return 0;
+ }
+#else
+#define   spi_slv_suspend NULL
+#define   spi_slv_resume  NULL
+#endif
+
+ static DEFINE_PCI_DEVICE_TABLE(spi_slv_id_tables) = {
+	 { PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x707), .driver_data = 32 },
+	 {0 },
+ };
+ MODULE_DEVICE_TABLE(pci, spi_slv_id_tables);
+
+ static struct pci_driver spi_slv_driver = {
+	 .name			 = "ce5xxx-spi_slv",
+	 .id_table		 = spi_slv_id_tables,
+	 .probe 		 = spi_slv_probe,
+	 .remove		 = spi_slv_remove,
+	 .suspend		 = spi_slv_suspend,
+	 .resume		 = spi_slv_resume,
+
+ };
+
+ static int __init spi_slv_init(void)
+ {
+	 return pci_register_driver(&spi_slv_driver);
+ }
+
+
+ static void __exit spi_slv_exit(void)
+ {
+	 pci_unregister_driver(&spi_slv_driver);
+ }
+
+ module_init(spi_slv_init);
+ module_exit(spi_slv_exit);
+
+ MODULE_DESCRIPTION("CE5xxx SPI Slave code");
+ MODULE_LICENSE("GPL v2");
+ MODULE_AUTHOR("cxu19 <chaoxu@intel.com>");
--- /dev/null
+++ b/drivers/spi/ce5xx_spi_slv.h
@@ -0,0 +1,112 @@
+/*
+#
+#  This file is provided under a dual BSD/GPLv2 license.  When using or
+#  redistributing this file, you may do so under either license.
+#
+#  GPL LICENSE SUMMARY
+#
+#  Copyright(c) 2011-2012 Intel Corporation. All rights reserved.
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of version 2 of the GNU General Public License as
+#  published by the Free Software Foundation.
+#
+#  This program is distributed in the hope that it will be useful, but
+#  WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#  General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program; if not, write to the Free Software
+#  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#  The full GNU General Public License is included in this distribution
+#  in the file called LICENSE.GPL.
+#
+#  Contact Information:
+#  intel.com
+#  Intel Corporation
+#  2200 Mission College Blvd.
+#  Santa Clara, CA  95052
+#  USA
+#  (408) 765-8080
+#
+#*/
+/*------------------------------------------------------------------------------
+ * File Name: ce5xx_spi_slv.h
+ * Driver for  SPI Slave controller
+ *------------------------------------------------------------------------------
+ */
+
+#ifndef __LINUX_CE5XX_SPI_SLV_H
+#define __LINUX_CE5XX_SPI_SLV_H
+
+#define SPI_SLV_SSCR0  0x0  /* SSP control Register 0 */
+#define SPI_SLV_SSCR1  0x4  /* SSP control Register 1 */
+#define SPI_SLV_SSSR   0x8  /* SSP status Register*/
+#define SPI_SLV_SSDR   0x10  /* SSP Dta Read/Write Register*/
+
+#define  SPI_SLV_FIFO_DEEP   32  /* SPI SLAVE FIFO deep 32*/
+#define  SPI_SLV_FIFO_WIDTH  32 /* SPI SLAVE FIFO width  32bits */
+
+#define  SPI_SLV_SSE_OFFSET  7  /* SSP enable bit's offset in SSCR0 */
+#define  SPI_SLV_SSE   (1 << SPI_SLV_SSE_OFFSET)   /* SSP enable bit in SSCR0 */
+
+#define  SPI_SLV_FRF_OFFSET  5  /* Frame Format control bits' offset in SSCR0 */
+#define  SPI_SLV_FRF_MSK     (0x3 << SPI_SLV_FRF_OFFSET) /*Frame Format control bits mask */
+
+#define  SPI_SLV_DSS_OFFSET     0   /*FIFO width select bits' offset in SSCR0*/
+#define  SPI_SLV_DSS_WIDTH      5   /*FIFO width select bits' length */
+#define  SPI_SLV_DSS_MSK     ( (( 1 << (SPI_SLV_DSS_WIDTH)) -1) << SPI_SLV_DSS_OFFSET)
+
+#define  SPI_SLV_DSS_8         0x7  /* FIFO width 8 bit */
+#define  SPI_SLV_DSS_16        0xF  /* FIFO width 16 bit */
+#define  SPI_SLV_DSS_32        0x1F  /* FIFO width 32 bit */
+
+#define  SPI_SLV_STRF_OFFSET    17   /*Select FIFO for EFWR's bit offset in SSCR1 */
+#define  SPI_SLV_STRF        (1 << SPI_SLV_STRF_OFFSET)  /*Select FIFO for EFWR*/
+
+#define  SPI_SLV_EFWR_OFFSET    16   /* Enable EFWR bit offset in SSCR1 */
+#define  SPI_SLV_EFWR        (1 << SPI_SLV_EFWR_OFFSET)  /*Enable EFWR*/
+
+#define  SPI_SLV_RFT_OFFSET   11 /* Receiver FIFO threshold in SSCR1 */
+#define  SPI_SLV_RFT_DEEP     SPI_SLV_FIFO_DEEP /* threshold deep*/
+#define  SPI_SLV_RFT_MSK      ((SPI_SLV_FIFO_DEEP -1) << SPI_SLV_RFT_OFFSET) /*RFT mask*/
+
+
+#define  SPI_SLV_TFT_OFFSET   6 /* Transmitter FIFO threshold in SSCR1 */
+#define  SPI_SLV_TFT_DEEP     SPI_SLV_FIFO_DEEP /* threshold deep*/
+#define  SPI_SLV_TFT_MSK      ((SPI_SLV_FIFO_DEEP -1) << SPI_SLV_TFT_OFFSET) /*RFT mask*/
+
+
+#define  SPI_SLV_TIE_OFFSET   1 /* Transmitter FIFO interrupt bit 's offset  in SSCR1 */
+#define  SPI_SLV_TIE         (1 << SPI_SLV_TIE_OFFSET)
+
+
+#define  SPI_SLV_RIE_OFFSET   0 /* Receiver FIFO interrupt in SSCR1 */
+#define  SPI_SLV_RIE          (1 << SPI_SLV_RIE_OFFSET)
+
+#define  SPI_SLV_RFL_OFFSET   13  /* Entries in Receiver FIFO bits's offset in SSSR*/
+#define  SPI_SLV_RFL_MSK         ((SPI_SLV_FIFO_DEEP - 1) << SPI_SLV_RFL_OFFSET) /*Enties in Reciever FIFO MSK*/
+
+#define  SPI_SLV_TFL_OFFSET   8  /* Entries in Transmitter FIFO bits's offset in SSSR*/
+#define  SPI_SLV_TFL_MSK         ((SPI_SLV_FIFO_DEEP - 1) << SPI_SLV_TFL_OFFSET) /*Enties in Transmitter FIFO MSK*/
+
+#define  SPI_SLV_ROR_OFFSET   7  /* SPI SLV overrun bit 's offset in SSSR */
+#define  SPI_SLV_ROR         (1 << SPI_SLV_ROR_OFFSET)
+
+#define  SPI_SLV_RFS_OFFSET  6 /* SPI SLV Reciever FIFO Interrupt bit offset in SSSR */
+#define  SPI_SLV_RFS         (1 << SPI_SLV_RFS_OFFSET)
+
+#define  SPI_SLV_TFS_OFFSET  5 /*SPI SLV Transmiter FIFO interrupt bit offset in SSSR */
+#define  SPI_SLV_TFS         (1 << SPI_SLV_TFS_OFFSET)
+
+#define  SPI_SLV_BSY_OFFSET 4 /* SPI SLV BUSY bit offset in SSSR */
+#define  SPI_SLV_BSY    (1 << SPI_SLV_BSY_OFFSET)
+
+#define  SPI_SLV_RNE_OFFSET 3 /* SPI SLV Receiver FIFO  is not empty bit offset in SSSR */
+#define  SPI_SLV_RNE        (1 << SPI_SLV_RNE_OFFSET)
+
+#define  SPI_SLV_TNF_OFFSET        2 /* SPI SLV Transmiter FIFO is not full bit offset in SSSR */
+#define  SPI_SLV_TNF           (1 << SPI_SLV_TNF_OFFSET)
+
+#endif //__LINUX_CE5XX_SPI_SLV_H
--- a/drivers/spi/spi-pxa2xx-dma.c
+++ b/drivers/spi/spi-pxa2xx-dma.c
@@ -174,6 +174,9 @@ static struct dma_async_tx_descriptor *
 pxa2xx_spi_dma_prepare_one(struct driver_data *drv_data,
 			   enum dma_transfer_direction dir)
 {
+#ifdef CONFIG_X86_PUMA6
+	struct pxa2xx_spi_master *pdata = drv_data->master_info;
+#endif
 	struct chip_data *chip = drv_data->cur_chip;
 	enum dma_slave_buswidth width;
 	struct dma_slave_config cfg;
@@ -200,7 +203,9 @@ pxa2xx_spi_dma_prepare_one(struct driver
 		cfg.dst_addr = drv_data->ssdr_physical;
 		cfg.dst_addr_width = width;
 		cfg.dst_maxburst = chip->dma_burst_size;
-
+#ifdef CONFIG_X86_PUMA6
+		cfg.slave_id = pdata->tx_slave_id;
+#endif
 		sgt = &drv_data->tx_sgt;
 		nents = drv_data->tx_nents;
 		chan = drv_data->tx_chan;
@@ -208,7 +213,9 @@ pxa2xx_spi_dma_prepare_one(struct driver
 		cfg.src_addr = drv_data->ssdr_physical;
 		cfg.src_addr_width = width;
 		cfg.src_maxburst = chip->dma_burst_size;
-
+#ifdef CONFIG_X86_PUMA6
+		cfg.slave_id = pdata->rx_slave_id;
+#endif
 		sgt = &drv_data->rx_sgt;
 		nents = drv_data->rx_nents;
 		chan = drv_data->rx_chan;
@@ -224,6 +231,16 @@ pxa2xx_spi_dma_prepare_one(struct driver
 				       DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
 }
 
+#ifdef CONFIG_X86_PUMA6
+static bool pxa2xx_spi_dma_filter(struct dma_chan *chan, void *param)
+{
+	const struct pxa2xx_spi_master *pdata = param;
+
+	return chan->chan_id == pdata->tx_chan_id ||
+	       chan->chan_id == pdata->rx_chan_id;
+}
+#endif
+
 bool pxa2xx_spi_dma_is_possible(size_t len)
 {
 	return len <= MAX_DMA_LEN;
@@ -327,12 +344,20 @@ int pxa2xx_spi_dma_setup(struct driver_d
 		return -ENOMEM;
 
 	drv_data->tx_chan = dma_request_slave_channel_compat(mask,
+#ifdef CONFIG_X86_PUMA6
+				pxa2xx_spi_dma_filter, pdata, dev, "tx");
+#else
 				pdata->dma_filter, pdata->tx_param, dev, "tx");
+#endif
 	if (!drv_data->tx_chan)
 		return -ENODEV;
 
 	drv_data->rx_chan = dma_request_slave_channel_compat(mask,
+#ifdef CONFIG_X86_PUMA6
+				pxa2xx_spi_dma_filter, pdata, dev, "rx");
+#else
 				pdata->dma_filter, pdata->rx_param, dev, "rx");
+#endif
 	if (!drv_data->rx_chan) {
 		dma_release_channel(drv_data->tx_chan);
 		drv_data->tx_chan = NULL;
--- /dev/null
+++ b/drivers/spi/spi-pxa2xx-pci_puma6.c
@@ -0,0 +1,243 @@
+/*
+ * CE4100's SPI device is more or less the same one as found on PXA
+ *
+ */
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/spi/spi.h>
+#include <linux/module.h>
+#include <linux/spi/pxa2xx_spi.h>
+
+#define CE4200_NUM_SPI_MASTER 1
+#define CE4200_NUM_CHIPSELECT 4
+#define CE4X00_SPI_MAX_SPEED  1843200
+#define CE5X00_SPI_MAX_SPEED  5000000
+
+
+#define GEN3_BOARD_INFO_CONFIG
+
+#ifdef  SPI_CE_DEBUG
+#define spi_dbg(fmt, args...) do \
+                             { \
+                               printk(KERN_INFO fmt, ##args); \
+                              } while(0)
+#else
+#define spi_dbg(fmt,args...) do {} while(0)
+#endif
+#ifdef CONFIG_GEN3_SPI
+#ifdef GEN3_BOARD_INFO_CONFIG
+struct spi_board_info CE4X00_spi_devices[]={
+  {
+    .modalias = "spidev",
+    .chip_select = 0,
+    .max_speed_hz = CE4X00_SPI_MAX_SPEED,
+    .bus_num = 0,
+  },
+  {
+    .modalias = "spidev",
+    .chip_select = 1,
+    .max_speed_hz = CE4X00_SPI_MAX_SPEED,
+    .bus_num = 0,
+  },
+  {
+    .modalias = "spidev",
+    .chip_select = 2,
+    .max_speed_hz = CE4X00_SPI_MAX_SPEED,
+    .bus_num = 0,
+  },
+  {
+    .modalias = "spidev",
+    .chip_select = 3,
+    .max_speed_hz = CE4X00_SPI_MAX_SPEED,
+    .bus_num = 0,
+  }
+};
+
+struct spi_board_info CE5X00_spi_devices[]={
+  {
+    .modalias = "spidev",
+    .chip_select = 0,
+    .max_speed_hz = CE5X00_SPI_MAX_SPEED,
+    .bus_num = 0,
+  },
+  {
+    .modalias = "spidev",
+    .chip_select = 1,
+    .max_speed_hz = CE5X00_SPI_MAX_SPEED,
+    .bus_num = 0,
+  },
+  {
+    .modalias = "spidev",
+    .chip_select = 2,
+    .max_speed_hz = CE5X00_SPI_MAX_SPEED,
+    .bus_num = 0,
+  },
+  {
+    .modalias = "spidev",
+    .chip_select = 3,
+    .max_speed_hz = CE5X00_SPI_MAX_SPEED,
+    .bus_num = 0,
+  }
+};
+
+static void add_spi_dev_devices(void)
+{
+  unsigned int id;
+
+        spi_dbg("add CE SPI board info\n");
+        intelce_get_soc_info(&id, NULL);
+        switch (id)
+        {
+                case CE5300_SOC_DEVICE_ID:
+                        spi_register_board_info(CE5X00_spi_devices,ARRAY_SIZE(CE5X00_spi_devices));
+                break;
+                case CE4200_SOC_DEVICE_ID:
+                default:
+                        spi_register_board_info(CE4X00_spi_devices,ARRAY_SIZE(CE4X00_spi_devices));
+                        break;
+        }
+}
+static void remove_spi_dev_devices(void)
+{
+  unsigned int id;
+
+        spi_dbg("remove CE SPI board info\n");
+        intelce_get_soc_info(&id, NULL);
+        switch (id)
+        {
+                case CE5300_SOC_DEVICE_ID:
+                        spi_unregister_board_info(CE5X00_spi_devices, ARRAY_SIZE(CE5X00_spi_devices));
+                        break;
+                case CE4200_SOC_DEVICE_ID:
+                default:
+                        spi_unregister_board_info(CE4X00_spi_devices, ARRAY_SIZE(CE4X00_spi_devices));
+                        break;
+        }
+}
+
+#endif
+#endif
+
+static int ce4100_spi_probe(struct pci_dev *dev,
+		const struct pci_device_id *ent)
+{
+	struct platform_device_info pi;
+	int ret;
+	struct platform_device *pdev;
+	struct pxa2xx_spi_master spi_pdata;
+	struct ssp_device *ssp;
+        unsigned int id;
+
+	ret = pcim_enable_device(dev);
+	if (ret)
+		return ret;
+
+	ret = pcim_iomap_regions(dev, 1 << 0, "PXA2xx SPI");
+	if (ret)
+		return ret;
+
+	memset(&spi_pdata, 0, sizeof(spi_pdata));
+	spi_pdata.num_chipselect = dev->devfn;
+	spi_pdata.num_chipselect = CE4200_NUM_CHIPSELECT;
+	ssp = &spi_pdata.ssp;
+	ssp->phys_base = pci_resource_start(dev, 0);
+	ssp->mmio_base = pcim_iomap_table(dev)[0];
+	if (!ssp->mmio_base) {
+		dev_err(&dev->dev, "failed to ioremap() registers\n");
+		return -EIO;
+	}
+	ssp->irq = dev->irq;
+	ssp->port_id = dev->devfn;
+	ssp->port_id = CE4200_NUM_SPI_MASTER-1;
+        intelce_get_soc_info(&id, NULL);
+        switch (id)
+        {
+                case CE5300_SOC_DEVICE_ID:
+                        ssp->type = CE5X00_SSP;
+                        printk("ssp type is CE5X00 SSP\n");
+                        break;
+                case CE4200_SOC_DEVICE_ID:
+                default:
+                        ssp->type = CE4100_SSP;
+                        printk("ssp type is CE4100 SSP\n");
+                        break;
+        }
+
+	memset(&pi, 0, sizeof(pi));
+	pi.parent = &dev->dev;
+	pi.name = "pxa2xx-spi";
+	pi.id = ssp->port_id;
+	pi.data = &spi_pdata;
+	pi.size_data = sizeof(spi_pdata);
+
+	pdev = platform_device_register_full(&pi);
+	if (IS_ERR(pdev))
+		return PTR_ERR(pdev);
+#ifdef CONFIG_OF
+        pdev->dev.of_node = dev->dev.of_node;
+#endif
+#ifdef CONFIG_GEN3_SPI
+#ifdef GEN3_BOARD_INFO_CONFIG
+        add_spi_dev_devices();
+#endif
+#endif
+
+	pci_set_drvdata(dev, pdev);
+
+	return 0;
+}
+
+static void ce4100_spi_remove(struct pci_dev *dev)
+{
+	struct platform_device *pdev = pci_get_drvdata(dev);
+#ifdef CONFIG_GEN3_SPI
+#ifdef GEN3_BOARD_INFO_CONFIG
+        remove_spi_dev_devices();
+#endif
+#endif
+
+	platform_device_unregister(pdev);
+}
+#ifdef CONFIG_PM
+static int ce4XXX_spi_suspend(struct pci_dev *dev, pm_message_t state)
+{
+        spi_dbg("Start to do spi pci suspend\n");
+        pci_save_state(dev);
+        pci_set_power_state(dev, pci_choose_state(dev, state));
+        return 0;
+}
+
+static int ce4XXX_spi_resume(struct pci_dev *dev)
+{
+        spi_dbg("Start to do spi pci resume\n");
+        pci_set_power_state(dev, PCI_D0);
+        pci_restore_state(dev);
+
+        return 0;
+}
+#endif
+
+static DEFINE_PCI_DEVICE_TABLE(ce4100_spi_devices) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x2e6a) },
+	{ },
+};
+MODULE_DEVICE_TABLE(pci, ce4100_spi_devices);
+
+static struct pci_driver ce4100_spi_driver = {
+	.name           = "ce4100_spi",
+	.id_table       = ce4100_spi_devices,
+	.probe          = ce4100_spi_probe,
+	.remove         = ce4100_spi_remove,
+#ifdef CONFIG_PM
+        .suspend        = ce4XXX_spi_suspend,
+        .resume         = ce4XXX_spi_resume,
+#endif
+
+};
+
+module_pci_driver(ce4100_spi_driver);
+
+MODULE_DESCRIPTION("CE4100 PCI-SPI glue code for PXA's driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Sebastian Andrzej Siewior <bigeasy@linutronix.de>");
--- a/drivers/spi/spi-pxa2xx.h
+++ b/drivers/spi/spi-pxa2xx.h
@@ -150,6 +150,10 @@ static inline int pxa25x_ssp_comp(struct
 		return 1;
 	if (drv_data->ssp_type == CE4100_SSP)
 		return 1;
+#ifdef CONFIG_GEN3_SPI
+         if (drv_data->ssp_type == CE5X00_SSP)
+		return 2;
+#endif
 	return 0;
 }
 
@@ -157,7 +161,7 @@ static inline void write_SSSR_CS(struct
 {
 	void __iomem *reg = drv_data->ioaddr;
 
-	if (drv_data->ssp_type == CE4100_SSP)
+	if (drv_data->ssp_type == CE4100_SSP  || drv_data->ssp_type == CE5X00_SSP ) 
 		val |= read_SSSR(reg) & SSSR_ALT_FRM_MASK;
 
 	write_SSSR(val, reg);
--- /dev/null
+++ b/drivers/spi/spi-pxa2xx_puma6.c
@@ -0,0 +1,1698 @@
+/*
+ * Copyright (C) 2005 Stephen Street / StreetFire Sound Labs
+ * Copyright (C) 2013, Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/pm_runtime.h>
+#include <linux/acpi.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/delay.h>
+
+#include "spi-pxa2xx.h"
+
+MODULE_AUTHOR("Stephen Street");
+MODULE_DESCRIPTION("PXA2xx SSP SPI Controller");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pxa2xx-spi");
+
+#define MAX_BUSES 3
+
+#define TIMOUT_DFLT		1000
+#define CE5X00_FIFO_DEPTH    32
+#define CE4X00_FIFO_DEPTH    4 
+
+//#define  SPI_CE_DEBUG
+#ifdef  SPI_CE_DEBUG
+#define spi_dbg(fmt, args...) do \
+                              { \
+                                printk(KERN_INFO fmt, ##args); \
+                              } while(0)
+#else
+#define spi_dbg(fmt,args...) do {} while(0)
+#endif
+
+/*
+ * for testing SSCR1 changes that require SSP restart, basically
+ * everything except the service and interrupt enables, the pxa270 developer
+ * manual says only SSCR1_SCFR, SSCR1_SPH, SSCR1_SPO need to be in this
+ * list, but the PXA255 dev man says all bits without really meaning the
+ * service and interrupt enables
+ */
+#define SSCR1_CHANGE_MASK (SSCR1_TTELP | SSCR1_TTE | SSCR1_SCFR \
+				| SSCR1_ECRA | SSCR1_ECRB | SSCR1_SCLKDIR \
+				| SSCR1_SFRMDIR | SSCR1_RWOT | SSCR1_TRAIL \
+				| SSCR1_IFS | SSCR1_STRF | SSCR1_EFWR \
+				| SSCR1_RFT | SSCR1_TFT | SSCR1_MWDS \
+				| SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)
+
+#define CE5X00_SSCR1_CHANGE_MASK (SSCR1_TTELP | SSCR1_TTE | SSCR1_SCFR \
+                                | SSCR1_ECRA | SSCR1_ECRB | SSCR1_SCLKDIR \
+                                | SSCR1_SFRMDIR | SSCR1_RWOT | SSCR1_TRAIL \
+                                | SSCR1_IFS | CE5X00_SSCR1_STRF | CE5X00_SSCR1_EFWR \
+                                | CE5X00_SSCR1_RFT | CE5X00_SSCR1_TFT | SSCR1_MWDS \
+                                | SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)
+
+#define LPSS_RX_THRESH_DFLT	64
+#define LPSS_TX_LOTHRESH_DFLT	160
+#define LPSS_TX_HITHRESH_DFLT	224
+
+/* Offset from drv_data->lpss_base */
+#define GENERAL_REG		0x08
+#define GENERAL_REG_RXTO_HOLDOFF_DISABLE BIT(24)
+#define SSP_REG			0x0c
+#define SPI_CS_CONTROL		0x18
+#define SPI_CS_CONTROL_SW_MODE	BIT(0)
+#define SPI_CS_CONTROL_CS_HIGH	BIT(1)
+
+#ifdef CONFIG_GEN3_SPI
+static unsigned long spi_clk_get_rate(int ssp_type)
+ {
+        switch (ssp_type)
+        {
+           case CE5X00_SSP:
+                /* CE5X00 clk is 10MHZ */
+                return 10000000;
+           case CE4100_SSP:
+                /* CE4X00 clk is 3.684MHZ */
+           default:
+                return 3686400;
+        }
+
+    return 3686400;
+ }
+static void wait_till_not_busy(struct driver_data *drv_data)
+{
+  /*
+   * Most cases, the BSY bit will be cleared in very short time.
+   * But if the controller is set to the slowest speed, the BSY
+   * bit waitting time will increase a lot.
+   * Here, we set the wait time to 100ms is to deal with such corner case,
+   * but in real world, there is almost no one will use the slowest
+   * speed to transfer data, which means there is no need to add more complex
+   * code to to deal with the slowest speed case.
+   */
+  unsigned long end = jiffies + 1 + usecs_to_jiffies(100000);
+  void __iomem *reg = drv_data->ioaddr;
+  while(time_before(jiffies,end)) {
+  if (!(read_SSSR(reg) & SSSR_BSY))
+    return;
+  }
+  printk(KERN_ERR "SPI MASTER keeps busy for 100ms after a read/write!\n");
+}
+
+#endif
+
+static bool is_lpss_ssp(const struct driver_data *drv_data)
+{
+	return drv_data->ssp_type == LPSS_SSP;
+}
+
+/*
+ * Read and write LPSS SSP private registers. Caller must first check that
+ * is_lpss_ssp() returns true before these can be called.
+ */
+static u32 __lpss_ssp_read_priv(struct driver_data *drv_data, unsigned offset)
+{
+	WARN_ON(!drv_data->lpss_base);
+	return readl(drv_data->lpss_base + offset);
+}
+
+static void __lpss_ssp_write_priv(struct driver_data *drv_data,
+				  unsigned offset, u32 value)
+{
+	WARN_ON(!drv_data->lpss_base);
+	writel(value, drv_data->lpss_base + offset);
+}
+
+/*
+ * lpss_ssp_setup - perform LPSS SSP specific setup
+ * @drv_data: pointer to the driver private data
+ *
+ * Perform LPSS SSP specific setup. This function must be called first if
+ * one is going to use LPSS SSP private registers.
+ */
+static void lpss_ssp_setup(struct driver_data *drv_data)
+{
+	unsigned offset = 0x400;
+	u32 value, orig;
+
+	if (!is_lpss_ssp(drv_data))
+		return;
+
+	/*
+	 * Perform auto-detection of the LPSS SSP private registers. They
+	 * can be either at 1k or 2k offset from the base address.
+	 */
+	orig = readl(drv_data->ioaddr + offset + SPI_CS_CONTROL);
+
+	value = orig | SPI_CS_CONTROL_SW_MODE;
+	writel(value, drv_data->ioaddr + offset + SPI_CS_CONTROL);
+	value = readl(drv_data->ioaddr + offset + SPI_CS_CONTROL);
+	if (value != (orig | SPI_CS_CONTROL_SW_MODE)) {
+		offset = 0x800;
+		goto detection_done;
+	}
+
+	value &= ~SPI_CS_CONTROL_SW_MODE;
+	writel(value, drv_data->ioaddr + offset + SPI_CS_CONTROL);
+	value = readl(drv_data->ioaddr + offset + SPI_CS_CONTROL);
+	if (value != orig) {
+		offset = 0x800;
+		goto detection_done;
+	}
+
+detection_done:
+	/* Now set the LPSS base */
+	drv_data->lpss_base = drv_data->ioaddr + offset;
+
+	/* Enable software chip select control */
+	value = SPI_CS_CONTROL_SW_MODE | SPI_CS_CONTROL_CS_HIGH;
+	__lpss_ssp_write_priv(drv_data, SPI_CS_CONTROL, value);
+
+	/* Enable multiblock DMA transfers */
+	if (drv_data->master_info->enable_dma) {
+		__lpss_ssp_write_priv(drv_data, SSP_REG, 1);
+
+		value = __lpss_ssp_read_priv(drv_data, GENERAL_REG);
+		value |= GENERAL_REG_RXTO_HOLDOFF_DISABLE;
+		__lpss_ssp_write_priv(drv_data, GENERAL_REG, value);
+	}
+}
+
+static void lpss_ssp_cs_control(struct driver_data *drv_data, bool enable)
+{
+	u32 value;
+
+	if (!is_lpss_ssp(drv_data))
+		return;
+
+	value = __lpss_ssp_read_priv(drv_data, SPI_CS_CONTROL);
+	if (enable)
+		value &= ~SPI_CS_CONTROL_CS_HIGH;
+	else
+		value |= SPI_CS_CONTROL_CS_HIGH;
+	__lpss_ssp_write_priv(drv_data, SPI_CS_CONTROL, value);
+}
+
+static void cs_assert(struct driver_data *drv_data)
+{
+	struct chip_data *chip = drv_data->cur_chip;
+
+	if (drv_data->ssp_type == CE4100_SSP  || drv_data->ssp_type == CE5X00_SSP ) {
+		write_SSSR(drv_data->cur_chip->frm, drv_data->ioaddr);
+		return;
+	}
+
+	if (chip->cs_control) {
+		chip->cs_control(PXA2XX_CS_ASSERT);
+		return;
+	}
+
+	if (gpio_is_valid(chip->gpio_cs)) {
+		gpio_set_value(chip->gpio_cs, chip->gpio_cs_inverted);
+		return;
+	}
+
+	lpss_ssp_cs_control(drv_data, true);
+}
+
+static void cs_deassert(struct driver_data *drv_data, struct chip_data * chip)
+{
+	if (drv_data->ssp_type == CE4100_SSP  || drv_data->ssp_type == CE5X00_SSP )
+		return;
+
+	if (chip->cs_control) {
+		chip->cs_control(PXA2XX_CS_DEASSERT);
+		return;
+	}
+
+	if (gpio_is_valid(chip->gpio_cs)) {
+		gpio_set_value(chip->gpio_cs, !chip->gpio_cs_inverted);
+		return;
+	}
+
+	lpss_ssp_cs_control(drv_data, false);
+}
+
+int pxa2xx_spi_flush(struct driver_data *drv_data)
+{
+	unsigned long limit = loops_per_jiffy << 1;
+
+	void __iomem *reg = drv_data->ioaddr;
+
+	do {
+		while (read_SSSR(reg) & SSSR_RNE) {
+			read_SSDR(reg);
+		}
+	} while ((read_SSSR(reg) & SSSR_BSY) && --limit);
+	write_SSSR_CS(drv_data, SSSR_ROR);
+
+	return limit;
+}
+
+static int null_writer(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+	u8 n_bytes = drv_data->n_bytes;
+
+	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
+		|| (drv_data->tx == drv_data->tx_end))
+		return 0;
+
+	write_SSDR(0, reg);
+	drv_data->tx += n_bytes;
+
+	return 1;
+}
+
+static int null_reader(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+	u8 n_bytes = drv_data->n_bytes;
+
+	while ((read_SSSR(reg) & SSSR_RNE)
+		&& (drv_data->rx < drv_data->rx_end)) {
+		read_SSDR(reg);
+		drv_data->rx += n_bytes;
+	}
+
+	return drv_data->rx == drv_data->rx_end;
+}
+
+static int u8_writer(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
+		|| (drv_data->tx == drv_data->tx_end))
+		return 0;
+
+	write_SSDR(*(u8 *)(drv_data->tx), reg);
+	++drv_data->tx;
+
+	return 1;
+}
+
+static int u8_reader(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	while ((read_SSSR(reg) & SSSR_RNE)
+		&& (drv_data->rx < drv_data->rx_end)) {
+		*(u8 *)(drv_data->rx) = read_SSDR(reg);
+		++drv_data->rx;
+	}
+
+	return drv_data->rx == drv_data->rx_end;
+}
+
+static int u16_writer(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
+		|| (drv_data->tx == drv_data->tx_end))
+		return 0;
+
+	write_SSDR(*(u16 *)(drv_data->tx), reg);
+	drv_data->tx += 2;
+
+	return 1;
+}
+
+static int u16_reader(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	while ((read_SSSR(reg) & SSSR_RNE)
+		&& (drv_data->rx < drv_data->rx_end)) {
+		*(u16 *)(drv_data->rx) = read_SSDR(reg);
+		drv_data->rx += 2;
+	}
+
+	return drv_data->rx == drv_data->rx_end;
+}
+
+static int u32_writer(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
+		|| (drv_data->tx == drv_data->tx_end))
+		return 0;
+
+	write_SSDR(*(u32 *)(drv_data->tx), reg);
+	drv_data->tx += 4;
+
+	return 1;
+}
+
+static int u32_reader(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	while ((read_SSSR(reg) & SSSR_RNE)
+		&& (drv_data->rx < drv_data->rx_end)) {
+		*(u32 *)(drv_data->rx) = read_SSDR(reg);
+		drv_data->rx += 4;
+	}
+
+	return drv_data->rx == drv_data->rx_end;
+}
+
+void *pxa2xx_spi_next_transfer(struct driver_data *drv_data)
+{
+	struct spi_message *msg = drv_data->cur_msg;
+	struct spi_transfer *trans = drv_data->cur_transfer;
+
+	/* Move to next transfer */
+	if (trans->transfer_list.next != &msg->transfers) {
+		drv_data->cur_transfer =
+			list_entry(trans->transfer_list.next,
+					struct spi_transfer,
+					transfer_list);
+		return RUNNING_STATE;
+	} else
+		return DONE_STATE;
+}
+
+/* caller already set message->status; dma and pio irqs are blocked */
+static void giveback(struct driver_data *drv_data)
+{
+	struct spi_transfer* last_transfer;
+	struct chip_data *chip = drv_data->cur_chip;
+	struct spi_message *msg;
+
+	msg = drv_data->cur_msg;
+	drv_data->cur_msg = NULL;
+	drv_data->cur_transfer = NULL;
+	drv_data->cur_chip = NULL;
+
+	last_transfer = list_entry(msg->transfers.prev,
+					struct spi_transfer,
+					transfer_list);
+
+	/* Delay if requested before any change in chip select */
+	if (last_transfer->delay_usecs)
+		udelay(last_transfer->delay_usecs);
+
+	/* Drop chip select UNLESS cs_change is true or we are returning
+	 * a message with an error, or next message is for another chip
+	 */
+	if (!last_transfer->cs_change)
+		cs_deassert(drv_data, chip);
+	else {
+		struct spi_message *next_msg;
+
+		/* Holding of cs was hinted, but we need to make sure
+		 * the next message is for the same chip.  Don't waste
+		 * time with the following tests unless this was hinted.
+		 *
+		 * We cannot postpone this until pump_messages, because
+		 * after calling msg->complete (below) the driver that
+		 * sent the current message could be unloaded, which
+		 * could invalidate the cs_control() callback...
+		 */
+
+		/* get a pointer to the next message, if any */
+		next_msg = spi_get_next_queued_message(drv_data->master);
+
+		/* see if the next and current messages point
+		 * to the same chip
+		 */
+		if (next_msg && next_msg->spi != msg->spi)
+			next_msg = NULL;
+		if (!next_msg || msg->state == ERROR_STATE)
+			cs_deassert(drv_data, chip);
+	}
+
+	drv_data->cur_chip = NULL;
+	spi_finalize_current_message(drv_data->master);
+}
+
+static void reset_sccr1(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+	struct chip_data *chip = drv_data->cur_chip;
+	u32 sccr1_reg;
+
+	sccr1_reg = read_SSCR1(reg) & ~drv_data->int_cr1;
+        if (drv_data->ssp_type == CE5X00_SSP)
+          sccr1_reg &= ~CE5X00_SSCR1_RFT;
+        else
+          sccr1_reg &= ~SSCR1_RFT;
+	sccr1_reg |= chip->threshold;
+	write_SSCR1(sccr1_reg, reg);
+}
+
+static void int_error_stop(struct driver_data *drv_data, const char* msg)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	/* Stop and reset SSP */
+	write_SSSR_CS(drv_data, drv_data->clear_sr);
+	reset_sccr1(drv_data);
+	if (!pxa25x_ssp_comp(drv_data))
+		write_SSTO(0, reg);
+	pxa2xx_spi_flush(drv_data);
+	write_SSCR0(read_SSCR0(reg) & ~SSCR0_SSE, reg);
+
+	dev_err(&drv_data->pdev->dev, "%s\n", msg);
+
+	drv_data->cur_msg->state = ERROR_STATE;
+	tasklet_schedule(&drv_data->pump_transfers);
+}
+
+static void int_transfer_complete(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	/* Stop SSP */
+	write_SSSR_CS(drv_data, drv_data->clear_sr);
+	reset_sccr1(drv_data);
+	if (!pxa25x_ssp_comp(drv_data))
+		write_SSTO(0, reg);
+
+	/* Update total byte transferred return count actual bytes read */
+	drv_data->cur_msg->actual_length += drv_data->len -
+				(drv_data->rx_end - drv_data->rx);
+
+	/* Transfer delays and chip select release are
+	 * handled in pump_transfers or giveback
+	 */
+
+	/* Move to next transfer */
+	drv_data->cur_msg->state = pxa2xx_spi_next_transfer(drv_data);
+
+	/* Schedule transfer tasklet */
+	tasklet_schedule(&drv_data->pump_transfers);
+}
+
+#ifndef CONFIG_GEN3_SPI
+static irqreturn_t interrupt_transfer(struct driver_data *drv_data)
+{
+	void __iomem *reg = drv_data->ioaddr;
+
+	u32 irq_mask = (read_SSCR1(reg) & SSCR1_TIE) ?
+			drv_data->mask_sr : drv_data->mask_sr & ~SSSR_TFS;
+
+	u32 irq_status = read_SSSR(reg) & irq_mask;
+
+	if (irq_status & SSSR_ROR) {
+		int_error_stop(drv_data, "interrupt_transfer: fifo overrun");
+		return IRQ_HANDLED;
+	}
+
+	if (irq_status & SSSR_TINT) {
+		write_SSSR(SSSR_TINT, reg);
+		if (drv_data->read(drv_data)) {
+			int_transfer_complete(drv_data);
+			return IRQ_HANDLED;
+		}
+	}
+
+	/* Drain rx fifo, Fill tx fifo and prevent overruns */
+	do {
+		if (drv_data->read(drv_data)) {
+			int_transfer_complete(drv_data);
+			return IRQ_HANDLED;
+		}
+	} while (drv_data->write(drv_data));
+
+	if (drv_data->read(drv_data)) {
+		int_transfer_complete(drv_data);
+		return IRQ_HANDLED;
+	}
+
+	if (drv_data->tx == drv_data->tx_end) {
+
+		u32 bytes_left=0;
+		u32 sccr1_reg;
+
+		sccr1_reg = read_SSCR1(reg);
+		sccr1_reg &= ~SSCR1_TIE;
+
+		/*
+		 * PXA25x_SSP has no timeout, set up rx threshould for the
+		 * remaining RX bytes.
+		 */
+		if (pxa25x_ssp_comp(drv_data)) {
+#ifndef CONFIG_GEN3_SPI
+			sccr1_reg &= ~SSCR1_RFT;
+
+			bytes_left = drv_data->rx_end - drv_data->rx;
+			switch (drv_data->n_bytes) {
+			case 4:
+				bytes_left >>= 1;
+			case 2:
+				bytes_left >>= 1;
+			}
+
+			if (bytes_left > RX_THRESH_DFLT)
+				bytes_left = RX_THRESH_DFLT;
+
+			sccr1_reg |= SSCR1_RxTresh(bytes_left);
+#endif
+		}
+		write_SSCR1(sccr1_reg, reg);
+#ifdef CONFIG_GEN3_SPI
+		if (!wait_ssp_rx_stall(reg))
+		{
+			int_error_stop(drv_data, "interrupt_transfer: "
+				"rx stall failed");
+			return IRQ_HANDLED;
+		}
+
+		spi_dbg("continue read\n");
+		if (!drv_data->read(drv_data))
+		{
+			int_error_stop(drv_data,
+				"interrupt_transfer: "
+				"trailing byte read failed");
+			return IRQ_HANDLED;
+		}
+
+		int_transfer_complete(drv_data);
+#endif
+	}
+
+	/* We did something */
+	return IRQ_HANDLED;
+}
+
+#else
+
+static void pxa2xx_update_tx_threshold(struct driver_data *drv_data, u32 threshold)
+{
+        void __iomem *reg = drv_data->ioaddr;
+        u32 sscr1_reg = 0;
+        sscr1_reg = read_SSCR1(reg);
+        sscr1_reg |= SSCR1_TIE;
+        if (drv_data->ssp_type == CE5X00_SSP) {
+                sscr1_reg &= ~CE5X00_SSCR1_TFT;
+                sscr1_reg |= CE5X00_SSCR1_TxTresh(threshold);
+        } else {
+                sscr1_reg &= ~SSCR1_TFT;
+                sscr1_reg |= SSCR1_TxTresh(threshold);
+        }
+
+        write_SSCR1(sscr1_reg, reg);
+}
+
+static void pxa2xx_mask_intr(void __iomem *reg, u32 intr)
+{
+        u32 mask;
+        mask = read_SSCR1(reg) & ~intr;
+        write_SSCR1(mask, reg);
+}
+
+static void pxa2xx_unmask_intr(void __iomem *reg, u32 intr)
+{
+        u32 mask;
+        mask = read_SSCR1(reg) | intr;
+        write_SSCR1(mask, reg);
+}
+static irqreturn_t interrupt_transfer(struct driver_data *drv_data)
+{
+        void __iomem *reg = drv_data->ioaddr;
+
+        u32 tx_count;
+        u32 irq_mask = (read_SSCR1(reg) & SSCR1_TIE) ?
+                        drv_data->mask_sr : drv_data->mask_sr & ~SSSR_TFS;
+
+
+        int left;
+
+        u32 tmp_sssr = read_SSSR(reg);
+        u32 irq_status = tmp_sssr & irq_mask;
+        /*
+         * Transmit FIFO Level Depth/MASK/Default value
+         */
+        u32 fifo_depth, sssr_tfl_mask, sscr1_tft_mask,tfl_default;
+
+        /*
+         * Check whether the irq is valid spi interrupt
+         */
+        if (!(tmp_sssr & (SSSR_TFS | SSSR_RFS | SSSR_ROR)))
+                return IRQ_NONE;
+
+        switch (drv_data->ssp_type) {
+                case CE4100_SSP:
+                        fifo_depth = CE4X00_FIFO_DEPTH;
+                        sssr_tfl_mask = SSSR_TFL_MASK;
+                        sscr1_tft_mask = SSCR1_TFT;
+                        tfl_default = TX_THRESH_DFLT;
+                        break;
+                case CE5X00_SSP:
+                        fifo_depth  = CE5X00_FIFO_DEPTH;
+                        sssr_tfl_mask = CE5X00_SSSR_TFL_MASK;
+                        sscr1_tft_mask = CE5X00_SSCR1_TFT;
+                        tfl_default = TX_THRESH_CE5X00_DFLT;
+                        break;
+                default:
+                        int_error_stop(drv_data, "Unsupported spi contoller type");
+                        return IRQ_HANDLED;
+        }
+
+
+        spi_dbg("in the interrupt_transfer\n");
+
+        if (irq_status & SSSR_ROR) {
+                int_error_stop(drv_data, "interrupt_transfer: fifo overrun");
+                return IRQ_HANDLED;
+        }
+
+
+
+        if (irq_status & SSSR_TINT) {
+                write_SSSR_CS(drv_data,SSSR_TINT);
+                if (drv_data->read(drv_data)) {
+                        int_transfer_complete(drv_data);
+                        return IRQ_HANDLED;
+                }
+        }
+
+
+        if (irq_status & SSSR_TFS) {
+
+               /*
+                * Mask the Transmit interrupt
+                */
+                pxa2xx_mask_intr(reg, SSCR1_TIE);
+
+                left = (drv_data->tx_end - drv_data->tx) / drv_data->n_bytes;
+                spi_dbg("len=%d,left=%d\n",drv_data->len, left * drv_data->n_bytes);
+
+                tmp_sssr = read_SSSR(reg);
+                tmp_sssr = (tmp_sssr & sssr_tfl_mask)>>8;
+                /*
+                 * Choose the correct tx_count to fill the Tx fifo and 
+                 * avoid the Rx Fifo overrun
+                 */
+                tx_count =  (fifo_depth - 1) - tmp_sssr;
+
+
+                if (left <= tx_count) {
+                        if (left > 0) {
+                                drv_data->read(drv_data);
+                                pxa2xx_update_tx_threshold(drv_data,1);
+                                while((left) > 0 ) {
+                                        left--;
+                                        drv_data->write(drv_data);
+                                }
+                                pxa2xx_unmask_intr(reg, SSCR1_TIE);
+                                return IRQ_HANDLED;
+                        } else {
+                                /*
+                                 * Tx transfer is done now,
+                                 * Read data when controller is not busy.
+                                 */
+                                wait_till_not_busy(drv_data);
+                                drv_data->read(drv_data);
+                                pxa2xx_unmask_intr(reg, SSCR1_TIE);
+                                int_transfer_complete(drv_data);
+                                return IRQ_HANDLED;
+                        }
+                } else {
+                        left = (left > tx_count)? tx_count:left;
+                        drv_data->read(drv_data);
+                        while((left) > 0 ) {
+                                left--;
+                                drv_data->write(drv_data);
+                        }
+                        pxa2xx_unmask_intr(reg, SSCR1_TIE);
+                        return IRQ_HANDLED;
+
+                }
+        }
+        /* We did something */
+        return IRQ_HANDLED;
+}
+#endif
+
+static irqreturn_t ssp_int(int irq, void *dev_id)
+{
+	struct driver_data *drv_data = dev_id;
+	void __iomem *reg = drv_data->ioaddr;
+	u32 sccr1_reg;
+	u32 mask = drv_data->mask_sr;
+	u32 status;
+
+	/*
+	 * The IRQ might be shared with other peripherals so we must first
+	 * check that are we RPM suspended or not. If we are we assume that
+	 * the IRQ was not for us (we shouldn't be RPM suspended when the
+	 * interrupt is enabled).
+	 */
+	if (pm_runtime_suspended(&drv_data->pdev->dev))
+		return IRQ_NONE;
+
+	/*
+	 * If the device is not yet in RPM suspended state and we get an
+	 * interrupt that is meant for another device, check if status bits
+	 * are all set to one. That means that the device is already
+	 * powered off.
+	 */
+	status = read_SSSR(reg);
+	if (status == ~0)
+		return IRQ_NONE;
+
+	sccr1_reg = read_SSCR1(reg);
+
+	/* Ignore possible writes if we don't need to write */
+	if (!(sccr1_reg & SSCR1_TIE))
+		mask &= ~SSSR_TFS;
+
+	/* Ignore RX timeout interrupt if it is disabled */
+	if (!(sccr1_reg & SSCR1_TINTE))
+		mask &= ~SSSR_TINT;
+
+	if (!(status & mask))
+		return IRQ_NONE;
+
+	if (!drv_data->cur_msg) {
+
+		write_SSCR0(read_SSCR0(reg) & ~SSCR0_SSE, reg);
+		write_SSCR1(read_SSCR1(reg) & ~drv_data->int_cr1, reg);
+		if (!pxa25x_ssp_comp(drv_data))
+			write_SSTO(0, reg);
+		write_SSSR_CS(drv_data, drv_data->clear_sr);
+
+		dev_err(&drv_data->pdev->dev, "bad message state "
+			"in interrupt handler\n");
+
+		/* Never fail */
+		return IRQ_HANDLED;
+	}
+
+	return drv_data->transfer_handler(drv_data);
+}
+
+static unsigned int ssp_get_clk_div(struct driver_data *drv_data, int rate)
+{
+	unsigned long ssp_clk = drv_data->max_clk_rate;
+	const struct ssp_device *ssp = drv_data->ssp;
+
+	rate = min_t(int, ssp_clk, rate);
+
+	if (ssp->type == PXA25x_SSP || ssp->type == CE4100_SSP ||ssp->type == CE5X00_SSP )
+		return ((ssp_clk / (2 * rate) - 1) & 0xff) << 8;
+	else
+		return ((ssp_clk / rate - 1) & 0xfff) << 8;
+}
+
+static void pump_transfers(unsigned long data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	struct spi_message *message = NULL;
+	struct spi_transfer *transfer = NULL;
+	struct spi_transfer *previous = NULL;
+	struct chip_data *chip = NULL;
+	void __iomem *reg = drv_data->ioaddr;
+	u32 clk_div = 0;
+	u8 bits = 0;
+	u32 speed = 0;
+	u32 cr0;
+	u32 cr1;
+	u32 dma_thresh = drv_data->cur_chip->dma_threshold;
+	u32 dma_burst = drv_data->cur_chip->dma_burst_size;
+
+	/* Get current state information */
+	message = drv_data->cur_msg;
+	transfer = drv_data->cur_transfer;
+	chip = drv_data->cur_chip;
+
+	/* Handle for abort */
+	if (message->state == ERROR_STATE) {
+		message->status = -EIO;
+		giveback(drv_data);
+		return;
+	}
+
+	/* Handle end of message */
+	if (message->state == DONE_STATE) {
+		message->status = 0;
+		giveback(drv_data);
+		return;
+	}
+
+	/* Delay if requested at end of transfer before CS change */
+	if (message->state == RUNNING_STATE) {
+		previous = list_entry(transfer->transfer_list.prev,
+					struct spi_transfer,
+					transfer_list);
+		if (previous->delay_usecs)
+			udelay(previous->delay_usecs);
+
+		/* Drop chip select only if cs_change is requested */
+		if (previous->cs_change)
+			cs_deassert(drv_data, chip);
+	}
+
+	/* Check if we can DMA this transfer */
+	if (!pxa2xx_spi_dma_is_possible(transfer->len) && chip->enable_dma) {
+
+		/* reject already-mapped transfers; PIO won't always work */
+		if (message->is_dma_mapped
+				|| transfer->rx_dma || transfer->tx_dma) {
+			dev_err(&drv_data->pdev->dev,
+				"pump_transfers: mapped transfer length "
+				"of %u is greater than %d\n",
+				transfer->len, MAX_DMA_LEN);
+			message->status = -EINVAL;
+			giveback(drv_data);
+			return;
+		}
+
+		/* warn ... we force this to PIO mode */
+		if (printk_ratelimit())
+			dev_warn(&message->spi->dev, "pump_transfers: "
+				"DMA disabled for transfer length %ld "
+				"greater than %d\n",
+				(long)drv_data->len, MAX_DMA_LEN);
+	}
+
+	/* Setup the transfer state based on the type of transfer */
+	if (pxa2xx_spi_flush(drv_data) == 0) {
+		dev_err(&drv_data->pdev->dev, "pump_transfers: flush failed\n");
+		message->status = -EIO;
+		giveback(drv_data);
+		return;
+	}
+	drv_data->n_bytes = chip->n_bytes;
+	drv_data->tx = (void *)transfer->tx_buf;
+	drv_data->tx_end = drv_data->tx + transfer->len;
+	drv_data->rx = transfer->rx_buf;
+	drv_data->rx_end = drv_data->rx + transfer->len;
+	drv_data->rx_dma = transfer->rx_dma;
+	drv_data->tx_dma = transfer->tx_dma;
+	drv_data->len = transfer->len;
+	drv_data->write = drv_data->tx ? chip->write : null_writer;
+	drv_data->read = drv_data->rx ? chip->read : null_reader;
+
+	/* Change speed and bit per word on a per transfer */
+	cr0 = chip->cr0;
+	spi_dbg("before update :cr0=%x\n",cr0);
+	if (transfer->speed_hz || transfer->bits_per_word) {
+		spi_dbg("transfer->speed_hz=%d\n", transfer->speed_hz);
+		spi_dbg("transfer->bits_per_word=%d\n", transfer->bits_per_word);
+
+		bits = chip->bits_per_word;
+		speed = chip->speed_hz;
+
+		if (transfer->speed_hz)
+			speed = transfer->speed_hz;
+
+		if (transfer->bits_per_word)
+			bits = transfer->bits_per_word;
+
+		clk_div = ssp_get_clk_div(drv_data, speed);
+
+		if (bits <= 8) {
+			drv_data->n_bytes = 1;
+			drv_data->read = drv_data->read != null_reader ?
+						u8_reader : null_reader;
+			drv_data->write = drv_data->write != null_writer ?
+						u8_writer : null_writer;
+		} else if (bits <= 16) {
+			drv_data->n_bytes = 2;
+			drv_data->read = drv_data->read != null_reader ?
+						u16_reader : null_reader;
+			drv_data->write = drv_data->write != null_writer ?
+						u16_writer : null_writer;
+		} else if (bits <= 32) {
+			drv_data->n_bytes = 4;
+			drv_data->read = drv_data->read != null_reader ?
+						u32_reader : null_reader;
+			drv_data->write = drv_data->write != null_writer ?
+						u32_writer : null_writer;
+		}
+		/* if bits/word is changed in dma mode, then must check the
+		 * thresholds and burst also */
+		if (chip->enable_dma) {
+			if (pxa2xx_spi_set_dma_burst_and_threshold(chip,
+							message->spi,
+							bits, &dma_burst,
+							&dma_thresh))
+				if (printk_ratelimit())
+					dev_warn(&message->spi->dev,
+						"pump_transfers: "
+						"DMA burst size reduced to "
+						"match bits_per_word\n");
+		}
+		spi_dbg("real clk_div=%x\n",clk_div);
+		switch (drv_data->ssp_type) {
+			case CE5X00_SSP:
+				chip->cr0 = clk_div
+				| CE5X00_SSCR0_Motorola
+				| CE5X00_SSCR0_DataSize(bits > 32 ?
+				8 : bits)
+				| SSCR0_SSE;
+			break;
+			case CE4100_SSP:
+			case PXA25x_SSP:
+			default:
+				chip->cr0 = clk_div
+				| SSCR0_Motorola
+				| SSCR0_DataSize(bits> 16 ?
+				bits - 16 : bits)
+				| SSCR0_SSE
+				| (bits > 16 ? SSCR0_EDSS : 0);
+		}
+		cr0 = chip->cr0;
+	}
+
+	message->state = RUNNING_STATE;
+
+	drv_data->dma_mapped = 0;
+	if (pxa2xx_spi_dma_is_possible(drv_data->len))
+		drv_data->dma_mapped = pxa2xx_spi_map_dma_buffers(drv_data);
+	if (drv_data->dma_mapped) {
+
+		/* Ensure we have the correct interrupt handler */
+		drv_data->transfer_handler = pxa2xx_spi_dma_transfer;
+
+		pxa2xx_spi_dma_prepare(drv_data, dma_burst);
+
+		/* Clear status and start DMA engine */
+		cr1 = chip->cr1 | dma_thresh | drv_data->dma_cr1;
+		write_SSSR(drv_data->clear_sr, reg);
+
+		pxa2xx_spi_dma_start(drv_data);
+	} else {
+		/* Ensure we have the correct interrupt handler	*/
+		drv_data->transfer_handler = interrupt_transfer;
+
+		/* Clear status  */
+		cr1 = chip->cr1 | chip->threshold | drv_data->int_cr1;
+		write_SSSR_CS(drv_data, drv_data->clear_sr);
+	}
+
+	if (is_lpss_ssp(drv_data)) {
+		if ((read_SSIRF(reg) & 0xff) != chip->lpss_rx_threshold)
+			write_SSIRF(chip->lpss_rx_threshold, reg);
+		if ((read_SSITF(reg) & 0xffff) != chip->lpss_tx_threshold)
+			write_SSITF(chip->lpss_tx_threshold, reg);
+	}
+
+	/* see if we need to reload the config registers */
+	if (drv_data->ssp_type == CE5X00_SSP ) {        
+		if ((read_SSCR0(reg) != cr0)
+			|| (read_SSCR1(reg) & CE5X00_SSCR1_CHANGE_MASK) !=
+				(cr1 & CE5X00_SSCR1_CHANGE_MASK)) {
+
+			/* stop the SSP, and update the other bits */
+			write_SSCR0(cr0 & ~SSCR0_SSE, reg);
+			if (!pxa25x_ssp_comp(drv_data))
+			write_SSTO(chip->timeout, reg);
+			/* first set CR1 without interrupt and service enables */
+			write_SSCR1(cr1 & CE5X00_SSCR1_CHANGE_MASK, reg);
+			/* restart the SSP */
+			write_SSCR0(cr0, reg);
+
+		} else {
+			if (!pxa25x_ssp_comp(drv_data))
+				write_SSTO(chip->timeout, reg);
+		}
+	}
+	else {
+		if ((read_SSCR0(reg) != cr0)
+			|| (read_SSCR1(reg) & SSCR1_CHANGE_MASK) !=
+                                  (cr1 & SSCR1_CHANGE_MASK)) {
+
+                     /* stop the SSP, and update the other bits */
+                     write_SSCR0(cr0 & ~SSCR0_SSE, reg);
+                     if (!pxa25x_ssp_comp(drv_data))
+                          write_SSTO(chip->timeout, reg);
+                     /* first set CR1 without interrupt and service enables */
+                     write_SSCR1(cr1 & SSCR1_CHANGE_MASK, reg);
+                     /* restart the SSP */
+                     write_SSCR0(cr0, reg);
+
+                } else {
+                        if (!pxa25x_ssp_comp(drv_data))
+                            write_SSTO(chip->timeout, reg);
+                }
+        }
+
+	cs_assert(drv_data);
+
+	/* after chip select, release the data by enabling service
+	 * requests and interrupts, without changing any mode bits */
+	write_SSCR1(cr1, reg);
+        spi_dbg("pump_transfer: %x,%x,%x,%x\n",read_SSCR0(drv_data->ioaddr),read_SSCR1(drv_data->ioaddr),
+                                        read_SSSR(drv_data->ioaddr),read_SSDR(drv_data->ioaddr));
+
+}
+
+static int pxa2xx_spi_transfer_one_message(struct spi_master *master,
+					   struct spi_message *msg)
+{
+	struct driver_data *drv_data = spi_master_get_devdata(master);
+
+	drv_data->cur_msg = msg;
+	/* Initial message state*/
+	drv_data->cur_msg->state = START_STATE;
+	drv_data->cur_transfer = list_entry(drv_data->cur_msg->transfers.next,
+						struct spi_transfer,
+						transfer_list);
+
+	/* prepare to setup the SSP, in pump_transfers, using the per
+	 * chip configuration */
+	drv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);
+
+	/* Mark as busy and launch transfers */
+	tasklet_schedule(&drv_data->pump_transfers);
+	return 0;
+}
+
+static int pxa2xx_spi_unprepare_transfer(struct spi_master *master)
+{
+	struct driver_data *drv_data = spi_master_get_devdata(master);
+
+	/* Disable the SSP now */
+	write_SSCR0(read_SSCR0(drv_data->ioaddr) & ~SSCR0_SSE,
+		    drv_data->ioaddr);
+
+	return 0;
+}
+
+static int setup_cs(struct spi_device *spi, struct chip_data *chip,
+		    struct pxa2xx_spi_chip *chip_info)
+{
+	int err = 0;
+
+	if (chip == NULL || chip_info == NULL)
+		return 0;
+
+	/* NOTE: setup() can be called multiple times, possibly with
+	 * different chip_info, release previously requested GPIO
+	 */
+	if (gpio_is_valid(chip->gpio_cs))
+		gpio_free(chip->gpio_cs);
+
+	/* If (*cs_control) is provided, ignore GPIO chip select */
+	if (chip_info->cs_control) {
+		chip->cs_control = chip_info->cs_control;
+		return 0;
+	}
+
+	if (gpio_is_valid(chip_info->gpio_cs)) {
+		err = gpio_request(chip_info->gpio_cs, "SPI_CS");
+		if (err) {
+			dev_err(&spi->dev, "failed to request chip select "
+					"GPIO%d\n", chip_info->gpio_cs);
+			return err;
+		}
+
+		chip->gpio_cs = chip_info->gpio_cs;
+		chip->gpio_cs_inverted = spi->mode & SPI_CS_HIGH;
+
+		err = gpio_direction_output(chip->gpio_cs,
+					!chip->gpio_cs_inverted);
+	}
+
+	return err;
+}
+
+static int setup(struct spi_device *spi)
+{
+	struct pxa2xx_spi_chip *chip_info = NULL;
+	struct chip_data *chip;
+	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
+	unsigned int clk_div;
+	uint tx_thres, tx_hi_thres, rx_thres;
+
+	if (is_lpss_ssp(drv_data)) {
+		tx_thres = LPSS_TX_LOTHRESH_DFLT;
+		tx_hi_thres = LPSS_TX_HITHRESH_DFLT;
+		rx_thres = LPSS_RX_THRESH_DFLT;
+	} else {
+	         if (drv_data->ssp_type == CE5X00_SSP) {
+			tx_thres = TX_THRESH_CE5X00_DFLT;
+             		rx_thres = RX_THRESH_CE5X00_DFLT;
+			tx_hi_thres = 0;
+		} else {
+			tx_thres = TX_THRESH_DFLT;
+			tx_hi_thres = 0;
+			rx_thres = RX_THRESH_DFLT;
+		}
+	}
+
+	/* Only alloc on first setup */
+	chip = spi_get_ctldata(spi);
+	if (!chip) {
+		chip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);
+		if (!chip) {
+			dev_err(&spi->dev,
+				"failed setup: can't allocate chip data\n");
+			return -ENOMEM;
+		}
+
+		if (drv_data->ssp_type == CE4100_SSP || drv_data->ssp_type == CE5X00_SSP) {
+			if (spi->chip_select > 4) {
+				dev_err(&spi->dev, "failed setup: "
+				"cs number must not be > 4.\n");
+				kfree(chip);
+				return -EINVAL;
+			}
+
+			chip->frm = spi->chip_select;
+		} else
+			chip->gpio_cs = -1;
+		chip->enable_dma = 0;
+		chip->timeout = TIMOUT_DFLT;
+	}
+
+	/* protocol drivers may change the chip settings, so...
+	 * if chip_info exists, use it */
+	chip_info = spi->controller_data;
+
+	/* chip_info isn't always needed */
+	chip->cr1 = 0;
+        chip->cr0 = 0;
+	if (chip_info) {
+		if (chip_info->timeout)
+			chip->timeout = chip_info->timeout;
+		if (chip_info->tx_threshold)
+			tx_thres = chip_info->tx_threshold;
+		if (chip_info->tx_hi_threshold)
+			tx_hi_thres = chip_info->tx_hi_threshold;
+		if (chip_info->rx_threshold)
+			rx_thres = chip_info->rx_threshold;
+		chip->enable_dma = drv_data->master_info->enable_dma;
+		chip->dma_threshold = 0;
+		if (chip_info->enable_loopback)
+			chip->cr1 = SSCR1_LBM;
+	} else if (ACPI_HANDLE(&spi->dev)) {
+		/*
+		 * Slave devices enumerated from ACPI namespace don't
+		 * usually have chip_info but we still might want to use
+		 * DMA with them.
+		 */
+		chip->enable_dma = drv_data->master_info->enable_dma;
+	}
+
+	chip->lpss_rx_threshold = SSIRF_RxThresh(rx_thres);
+	chip->lpss_tx_threshold = SSITF_TxLoThresh(tx_thres)
+				| SSITF_TxHiThresh(tx_hi_thres);
+
+	/* set dma burst and threshold outside of chip_info path so that if
+	 * chip_info goes away after setting chip->enable_dma, the
+	 * burst and threshold can still respond to changes in bits_per_word */
+	if (chip->enable_dma) {
+		/* set up legal burst and threshold for dma */
+		if (pxa2xx_spi_set_dma_burst_and_threshold(chip, spi,
+						spi->bits_per_word,
+						&chip->dma_burst_size,
+						&chip->dma_threshold)) {
+			dev_warn(&spi->dev, "in setup: DMA burst size reduced "
+					"to match bits_per_word\n");
+		}
+	}
+
+	clk_div = ssp_get_clk_div(drv_data, spi->max_speed_hz);
+	chip->speed_hz = spi->max_speed_hz;
+        switch (drv_data->ssp_type) {
+          case  CE5X00_SSP:
+                chip->cr0 = clk_div
+                                 | CE5X00_SSCR0_Motorola
+                                 | CE5X00_SSCR0_DataSize(spi->bits_per_word > 32 ?
+                                         8 : spi->bits_per_word)
+                                 | SSCR0_SSE;
+                chip->threshold = (CE5X00_SSCR1_RxTresh(rx_thres) & CE5X00_SSCR1_RFT) |
+                        (CE5X00_SSCR1_TxTresh(tx_thres) & CE5X00_SSCR1_TFT);
+
+                break;
+          case  CE4100_SSP:
+          case  PXA25x_SSP:
+          default:
+                chip->cr0 = clk_div
+                                 | SSCR0_Motorola
+                                 | SSCR0_DataSize(spi->bits_per_word > 16 ?
+                                         spi->bits_per_word - 16 : spi->bits_per_word)
+                                 | SSCR0_SSE
+                                 | (spi->bits_per_word > 16 ? SSCR0_EDSS : 0);
+                chip->threshold = (SSCR1_RxTresh(rx_thres) & SSCR1_RFT) |
+                        (SSCR1_TxTresh(tx_thres) & SSCR1_TFT);
+
+        }
+
+
+	chip->cr1 &= ~(SSCR1_SPO | SSCR1_SPH);
+	chip->cr1 |= (((spi->mode & SPI_CPHA) != 0) ? SSCR1_SPH : 0)
+			| (((spi->mode & SPI_CPOL) != 0) ? SSCR1_SPO : 0);
+
+	if (spi->mode & SPI_LOOP)
+		chip->cr1 |= SSCR1_LBM;
+
+	/* NOTE:  PXA25x_SSP _could_ use external clocking ... */
+	if (!pxa25x_ssp_comp(drv_data))
+		dev_dbg(&spi->dev, "%ld Hz actual, %s\n",
+			drv_data->max_clk_rate
+				/ (1 + ((chip->cr0 & SSCR0_SCR(0xfff)) >> 8)),
+			chip->enable_dma ? "DMA" : "PIO");
+	else
+		dev_dbg(&spi->dev, "%ld Hz actual, %s\n",
+			drv_data->max_clk_rate / 2
+				/ (1 + ((chip->cr0 & SSCR0_SCR(0x0ff)) >> 8)),
+			chip->enable_dma ? "DMA" : "PIO");
+
+	if (spi->bits_per_word <= 8) {
+		chip->n_bytes = 1;
+		chip->read = u8_reader;
+		chip->write = u8_writer;
+	} else if (spi->bits_per_word <= 16) {
+		chip->n_bytes = 2;
+		chip->read = u16_reader;
+		chip->write = u16_writer;
+	} else if (spi->bits_per_word <= 32) {
+#ifndef CONFIG_GEN3_SPI
+		chip->cr0 |= SSCR0_EDSS;
+#endif
+		chip->n_bytes = 4;
+		chip->read = u32_reader;
+		chip->write = u32_writer;
+	}
+	chip->bits_per_word = spi->bits_per_word;
+
+	spi_set_ctldata(spi, chip);
+
+	if (drv_data->ssp_type == CE4100_SSP || drv_data->ssp_type == CE5X00_SSP)
+		return 0;
+
+	return setup_cs(spi, chip, chip_info);
+}
+
+static void cleanup(struct spi_device *spi)
+{
+	struct chip_data *chip = spi_get_ctldata(spi);
+	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
+
+	if (!chip)
+		return;
+
+	if (drv_data->ssp_type != CE4100_SSP && gpio_is_valid(chip->gpio_cs))
+		gpio_free(chip->gpio_cs);
+
+	kfree(chip);
+}
+
+#ifdef CONFIG_ACPI
+static struct pxa2xx_spi_master *
+pxa2xx_spi_acpi_get_pdata(struct platform_device *pdev)
+{
+	struct pxa2xx_spi_master *pdata;
+	struct acpi_device *adev;
+	struct ssp_device *ssp;
+	struct resource *res;
+	int devid;
+
+	if (!ACPI_HANDLE(&pdev->dev) ||
+	    acpi_bus_get_device(ACPI_HANDLE(&pdev->dev), &adev))
+		return NULL;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(&pdev->dev,
+			"failed to allocate memory for platform data\n");
+		return NULL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return NULL;
+
+	ssp = &pdata->ssp;
+
+	ssp->phys_base = res->start;
+	ssp->mmio_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ssp->mmio_base))
+		return NULL;
+
+	ssp->clk = devm_clk_get(&pdev->dev, NULL);
+	ssp->irq = platform_get_irq(pdev, 0);
+	ssp->type = LPSS_SSP;
+	ssp->pdev = pdev;
+
+	ssp->port_id = -1;
+	if (adev->pnp.unique_id && !kstrtoint(adev->pnp.unique_id, 0, &devid))
+		ssp->port_id = devid;
+
+	pdata->num_chipselect = 1;
+	pdata->enable_dma = true;
+	pdata->tx_chan_id = -1;
+	pdata->rx_chan_id = -1;
+
+	return pdata;
+}
+
+static struct acpi_device_id pxa2xx_spi_acpi_match[] = {
+	{ "INT33C0", 0 },
+	{ "INT33C1", 0 },
+	{ "INT3430", 0 },
+	{ "INT3431", 0 },
+	{ "80860F0E", 0 },
+	{ "8086228E", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, pxa2xx_spi_acpi_match);
+#else
+static inline struct pxa2xx_spi_master *
+pxa2xx_spi_acpi_get_pdata(struct platform_device *pdev)
+{
+	return NULL;
+}
+#endif
+
+static int pxa2xx_spi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct pxa2xx_spi_master *platform_info;
+	struct spi_master *master;
+	struct driver_data *drv_data;
+	struct ssp_device *ssp;
+	int status;
+
+	platform_info = dev_get_platdata(dev);
+	if (!platform_info) {
+		platform_info = pxa2xx_spi_acpi_get_pdata(pdev);
+		if (!platform_info) {
+			dev_err(&pdev->dev, "missing platform data\n");
+			return -ENODEV;
+		}
+	}
+
+	ssp = pxa_ssp_request(pdev->id, pdev->name);
+	if (!ssp)
+		ssp = &platform_info->ssp;
+
+	if (!ssp->mmio_base) {
+		dev_err(&pdev->dev, "failed to get ssp\n");
+		return -ENODEV;
+	}
+
+	/* Allocate master with space for drv_data and null dma buffer */
+	master = spi_alloc_master(dev, sizeof(struct driver_data) + 16);
+	if (!master) {
+		dev_err(&pdev->dev, "cannot alloc spi_master\n");
+		pxa_ssp_free(ssp);
+		return -ENOMEM;
+	}
+	drv_data = spi_master_get_devdata(master);
+	drv_data->master = master;
+	drv_data->master_info = platform_info;
+	drv_data->pdev = pdev;
+	drv_data->ssp = ssp;
+
+	master->dev.parent = &pdev->dev;
+	master->dev.of_node = pdev->dev.of_node;
+	/* the spi->mode bits understood by this driver: */
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;
+
+	master->bus_num = ssp->port_id;
+	master->num_chipselect = platform_info->num_chipselect;
+	master->dma_alignment = DMA_ALIGNMENT;
+	master->cleanup = cleanup;
+	master->setup = setup;
+	master->transfer_one_message = pxa2xx_spi_transfer_one_message;
+	master->unprepare_transfer_hardware = pxa2xx_spi_unprepare_transfer;
+	master->auto_runtime_pm = true;
+        spi_dbg("bus num=%d, chipselect=%d\n",master->bus_num, master->num_chipselect);
+	drv_data->ssp_type = ssp->type;
+	drv_data->null_dma_buf = (u32 *)PTR_ALIGN(&drv_data[1], DMA_ALIGNMENT);
+
+	drv_data->ioaddr = ssp->mmio_base;
+	drv_data->ssdr_physical = ssp->phys_base + SSDR;
+	if (pxa25x_ssp_comp(drv_data)) {
+		master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
+		drv_data->int_cr1 = SSCR1_TIE | SSCR1_RIE;
+		drv_data->dma_cr1 = 0;
+		drv_data->clear_sr = SSSR_ROR;
+		drv_data->mask_sr = SSSR_RFS | SSSR_TFS | SSSR_ROR;
+	} else {
+		master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);
+		drv_data->int_cr1 = SSCR1_TIE | SSCR1_RIE | SSCR1_TINTE;
+		drv_data->dma_cr1 = DEFAULT_DMA_CR1;
+		drv_data->clear_sr = SSSR_ROR | SSSR_TINT;
+		drv_data->mask_sr = SSSR_TINT | SSSR_RFS | SSSR_TFS | SSSR_ROR;
+	}
+
+	status = request_irq(ssp->irq, ssp_int, IRQF_SHARED, dev_name(dev),
+			drv_data);
+	if (status < 0) {
+		dev_err(&pdev->dev, "cannot get IRQ %d\n", ssp->irq);
+		goto out_error_master_alloc;
+	}
+
+	/* Setup DMA if requested */
+	drv_data->tx_channel = -1;
+	drv_data->rx_channel = -1;
+	if (platform_info->enable_dma) {
+		status = pxa2xx_spi_dma_setup(drv_data);
+		if (status) {
+			dev_dbg(dev, "no DMA channels available, using PIO\n");
+			platform_info->enable_dma = false;
+		}
+	}
+
+	/* Enable SOC clock */
+	clk_prepare_enable(ssp->clk);
+#ifndef CONFIG_GEN3_SPI
+	drv_data->max_clk_rate = clk_get_rate(ssp->clk);
+#else
+	drv_data->max_clk_rate = spi_clk_get_rate(ssp->type);
+#endif
+
+	/* Load default SSP configuration */
+	write_SSCR0(0, drv_data->ioaddr);
+       switch (drv_data->ssp_type) {
+          case CE5X00_SSP:
+                write_SSCR1(CE5X00_SSCR1_RxTresh(RX_THRESH_CE5X00_DFLT) |
+                                     CE5X00_SSCR1_TxTresh(TX_THRESH_CE5X00_DFLT),
+                                drv_data->ioaddr);
+                 /* default using the Motorola SPI protocol and use 8 bit frame */
+                write_SSCR0(SSCR0_SCR(2)
+                        | CE5X00_SSCR0_Motorola
+                        | CE5X00_SSCR0_DataSize(8),
+                        drv_data->ioaddr);
+
+                spi_dbg("probe: %x,%x,%x,%x\n",read_SSCR0(drv_data->ioaddr),read_SSCR1(drv_data->ioaddr),
+                                        read_SSSR(drv_data->ioaddr),read_SSDR(drv_data->ioaddr));
+                break;
+          case CE4100_SSP:
+          case PXA25x_SSP:
+          default:
+        write_SSCR1(SSCR1_RxTresh(RX_THRESH_DFLT) |
+                                SSCR1_TxTresh(TX_THRESH_DFLT),
+                                drv_data->ioaddr);
+                /* default using the Motorola SPI protocol and use 8 bit frame */
+        write_SSCR0(SSCR0_SCR(2)
+                        | SSCR0_Motorola
+                        | SSCR0_DataSize(8),
+                        drv_data->ioaddr);
+
+                spi_dbg("probe: %x,%x,%x,%x\n",read_SSCR0(drv_data->ioaddr),read_SSCR1(drv_data->ioaddr),
+                                        read_SSSR(drv_data->ioaddr),read_SSDR(drv_data->ioaddr));
+        }
+        if (!pxa25x_ssp_comp(drv_data))
+                write_SSTO(0, drv_data->ioaddr);
+#ifndef CONFIG_GEN3_SPI
+        /*
+         *  SSPSP register is resrved on the CEXXXX SOCs.
+         */
+
+	write_SSPSP(0, drv_data->ioaddr);
+#endif
+	lpss_ssp_setup(drv_data);
+
+	tasklet_init(&drv_data->pump_transfers, pump_transfers,
+		     (unsigned long)drv_data);
+
+	/* Register with the SPI framework */
+	platform_set_drvdata(pdev, drv_data);
+	status = spi_register_master(master);
+	if (status != 0) {
+		dev_err(&pdev->dev, "problem registering spi master\n");
+		goto out_error_clock_enabled;
+	}
+
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+
+	return status;
+
+out_error_clock_enabled:
+	clk_disable_unprepare(ssp->clk);
+	pxa2xx_spi_dma_release(drv_data);
+	free_irq(ssp->irq, drv_data);
+
+out_error_master_alloc:
+	spi_master_put(master);
+	pxa_ssp_free(ssp);
+	return status;
+}
+
+static int pxa2xx_spi_remove(struct platform_device *pdev)
+{
+	struct driver_data *drv_data = platform_get_drvdata(pdev);
+	struct ssp_device *ssp;
+
+	if (!drv_data)
+		return 0;
+	ssp = drv_data->ssp;
+
+	pm_runtime_get_sync(&pdev->dev);
+
+	/* Disable the SSP at the peripheral and SOC level */
+	write_SSCR0(0, drv_data->ioaddr);
+	clk_disable_unprepare(ssp->clk);
+
+	/* Release DMA */
+	if (drv_data->master_info->enable_dma)
+		pxa2xx_spi_dma_release(drv_data);
+
+	pm_runtime_put_noidle(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	/* Release IRQ */
+	free_irq(ssp->irq, drv_data);
+
+	/* Release SSP */
+	pxa_ssp_free(ssp);
+
+	/* Disconnect from the SPI framework */
+	spi_unregister_master(drv_data->master);
+
+	return 0;
+}
+
+static void pxa2xx_spi_shutdown(struct platform_device *pdev)
+{
+	int status = 0;
+
+	if ((status = pxa2xx_spi_remove(pdev)) != 0)
+		dev_err(&pdev->dev, "shutdown failed with %d\n", status);
+}
+
+#ifdef CONFIG_PM
+static int pxa2xx_spi_suspend(struct device *dev)
+{
+	struct driver_data *drv_data = dev_get_drvdata(dev);
+	struct ssp_device *ssp = drv_data->ssp;
+	int status = 0;
+
+	status = spi_master_suspend(drv_data->master);
+	if (status != 0)
+		return status;
+	write_SSCR0(0, drv_data->ioaddr);
+
+	if (!pm_runtime_suspended(dev))
+		clk_disable_unprepare(ssp->clk);
+
+	return 0;
+}
+
+static int pxa2xx_spi_resume(struct device *dev)
+{
+	struct driver_data *drv_data = dev_get_drvdata(dev);
+	struct ssp_device *ssp = drv_data->ssp;
+	int status = 0;
+
+	pxa2xx_spi_dma_resume(drv_data);
+
+	/* Enable the SSP clock */
+	if (!pm_runtime_suspended(dev))
+		clk_prepare_enable(ssp->clk);
+
+	/* Start the queue running */
+	status = spi_master_resume(drv_data->master);
+	if (status != 0) {
+		dev_err(dev, "problem starting queue (%d)\n", status);
+		return status;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int pxa2xx_spi_runtime_suspend(struct device *dev)
+{
+	struct driver_data *drv_data = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(drv_data->ssp->clk);
+	return 0;
+}
+
+static int pxa2xx_spi_runtime_resume(struct device *dev)
+{
+	struct driver_data *drv_data = dev_get_drvdata(dev);
+
+	clk_prepare_enable(drv_data->ssp->clk);
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops pxa2xx_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pxa2xx_spi_suspend, pxa2xx_spi_resume)
+	SET_RUNTIME_PM_OPS(pxa2xx_spi_runtime_suspend,
+			   pxa2xx_spi_runtime_resume, NULL)
+};
+
+static struct platform_driver driver = {
+	.driver = {
+		.name	= "pxa2xx-spi",
+		.owner	= THIS_MODULE,
+		.pm	= &pxa2xx_spi_pm_ops,
+		.acpi_match_table = ACPI_PTR(pxa2xx_spi_acpi_match),
+	},
+	.probe = pxa2xx_spi_probe,
+	.remove = pxa2xx_spi_remove,
+	.shutdown = pxa2xx_spi_shutdown,
+};
+
+static int __init pxa2xx_spi_init(void)
+{
+	return platform_driver_register(&driver);
+}
+subsys_initcall(pxa2xx_spi_init);
+
+static void __exit pxa2xx_spi_exit(void)
+{
+	platform_driver_unregister(&driver);
+}
+module_exit(pxa2xx_spi_exit);
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -502,14 +502,33 @@ int spi_register_board_info(struct spi_b
 {
 	struct boardinfo *bi;
 	int i;
-
+#ifndef CONFIG_GEN3_SPI
 	bi = kzalloc(n * sizeof(*bi), GFP_KERNEL);
 	if (!bi)
 		return -ENOMEM;
 
 	for (i = 0; i < n; i++, bi++, info++) {
+#else
+	for (i = 0; i < n; i++, info++) {
+#endif
 		struct spi_master *master;
-
+#ifdef CONFIG_GEN3_SPI
+		struct boardinfo *temp;
+		bi = kzalloc(sizeof(*bi), GFP_KERNEL);
+		    if (!bi) {
+		    for( --i, --info; i >=0; i--, info--)
+			    mutex_lock(&board_lock);
+			    list_for_each_entry_safe(bi, temp, &board_list, list) {
+			         if (!memcmp(&bi->board_info, info, sizeof(*info))) {
+			            list_del(&bi->list);
+			            kfree(bi);
+		                break;
+			         }
+			    }
+			    mutex_unlock(&board_lock);
+		    return -ENOMEM;
+		}
+#endif
 		memcpy(&bi->board_info, info, sizeof(*info));
 		mutex_lock(&board_lock);
 		list_add_tail(&bi->list, &board_list);
@@ -521,6 +540,31 @@ int spi_register_board_info(struct spi_b
 	return 0;
 }
 
+#ifdef CONFIG_GEN3_SPI
+EXPORT_SYMBOL_GPL(spi_register_board_info);
+
+int spi_unregister_board_info(struct spi_board_info  *info, unsigned n)
+{
+	struct boardinfo	*bi,*temp;
+    int i;
+
+	for (i = 0; i < n; i++, info++) {
+	    mutex_lock(&board_lock);
+	    list_for_each_entry_safe(bi, temp, &board_list, list) {
+	        if (!memcmp(&bi->board_info, info, sizeof(*info))) {
+	            list_del(&bi->list);
+	            kfree(bi);
+                break;
+	        }
+	    }
+	    mutex_unlock(&board_lock);
+    }    
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(spi_unregister_board_info);
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /**
@@ -1057,7 +1101,9 @@ static inline void acpi_register_spi_dev
 static void spi_master_release(struct device *dev)
 {
 	struct spi_master *master;
-
+#ifdef CONFIG_GEN3_SPI
+        put_device(dev->parent);
+#endif
 	master = container_of(dev, struct spi_master, dev);
 	kfree(master);
 }
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -87,8 +87,15 @@ struct spidev_data {
 	u8			*buffer;
 };
 
+#ifdef CONFIG_GEN3_SPI
+LIST_HEAD(device_list);
+DEFINE_MUTEX(device_list_lock);
+EXPORT_SYMBOL(device_list);
+EXPORT_SYMBOL(device_list_lock);
+#else
 static LIST_HEAD(device_list);
 static DEFINE_MUTEX(device_list_lock);
+#endif
 
 static unsigned bufsiz = 4096;
 module_param(bufsiz, uint, S_IRUGO);
@@ -105,8 +112,13 @@ static void spidev_complete(void *arg)
 	complete(arg);
 }
 
+#ifdef CONFIG_GEN3_SPI
+ssize_t
+spidev_sync(struct spidev_data *spidev, struct spi_message *message)
+#else
 static ssize_t
 spidev_sync(struct spidev_data *spidev, struct spi_message *message)
+#endif
 {
 	DECLARE_COMPLETION_ONSTACK(done);
 	int status;
@@ -130,8 +142,17 @@ spidev_sync(struct spidev_data *spidev,
 	return status;
 }
 
+#ifdef CONFIG_GEN3_SPI
+EXPORT_SYMBOL(spidev_sync);
+#endif
+
+#ifdef CONFIG_GEN3_SPI
+ssize_t
+spidev_sync_write(struct spidev_data *spidev, size_t len)
+#else
 static inline ssize_t
 spidev_sync_write(struct spidev_data *spidev, size_t len)
+#endif
 {
 	struct spi_transfer	t = {
 			.tx_buf		= spidev->buffer,
@@ -144,8 +165,17 @@ spidev_sync_write(struct spidev_data *sp
 	return spidev_sync(spidev, &m);
 }
 
+#ifdef CONFIG_GEN3_SPI
+EXPORT_SYMBOL(spidev_sync_write);
+#endif
+
+#ifdef CONFIG_GEN3_SPI
+ssize_t
+spidev_sync_read(struct spidev_data *spidev, size_t len)
+#else
 static inline ssize_t
 spidev_sync_read(struct spidev_data *spidev, size_t len)
+#endif
 {
 	struct spi_transfer	t = {
 			.rx_buf		= spidev->buffer,
@@ -158,6 +188,10 @@ spidev_sync_read(struct spidev_data *spi
 	return spidev_sync(spidev, &m);
 }
 
+#ifdef CONFIG_GEN3_SPI
+EXPORT_SYMBOL(spidev_sync_read);
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /* Read-only message with current device setup */
@@ -271,6 +305,15 @@ static int spidev_message(struct spidev_
 		k_tmp->bits_per_word = u_tmp->bits_per_word;
 		k_tmp->delay_usecs = u_tmp->delay_usecs;
 		k_tmp->speed_hz = u_tmp->speed_hz;
+
+#ifdef CONFIG_GEN3_SPI
+		if ((k_tmp->len*8) < k_tmp->bits_per_word) {
+		  printk(KERN_ERR "error :transfer data lenth < bits_per_word\n");
+		  status = -EMSGSIZE;
+		  goto done;
+		}
+#endif
+
 #ifdef VERBOSE
 		dev_dbg(&spidev->spi->dev,
 			"  xfer len %zd %s%s%s%dbits %u usec %uHz\n",
@@ -507,6 +550,10 @@ static int spidev_open(struct inode *ino
 				dev_dbg(&spidev->spi->dev, "open/ENOMEM\n");
 				status = -ENOMEM;
 			}
+#ifdef CONFIG_GEN3_SPI
+			 if (spidev->spi->master->using_slave)
+                		spidev->spi->master->setup(spidev->spi);
+#endif
 		}
 		if (status == 0) {
 			spidev->users++;
@@ -536,7 +583,10 @@ static int spidev_release(struct inode *
 
 		kfree(spidev->buffer);
 		spidev->buffer = NULL;
-
+#ifdef CONFIG_GEN3_SPI
+		 if (spidev->spi->master->using_slave)
+            		spidev->spi->master->cleanup(spidev->spi);
+#endif
 		/* ... after we unbound from the underlying device? */
 		spin_lock_irq(&spidev->spi_lock);
 		dofree = (spidev->spi == NULL);
--- a/include/linux/pxa2xx_ssp.h
+++ b/include/linux/pxa2xx_ssp.h
@@ -106,6 +106,30 @@
 #define SSCR1_TxTresh(x) (((x) - 1) << 6) /* level [1..4] */
 #define SSCR1_RFT	(0x00000c00)	/* Receive FIFO Threshold (mask) */
 #define SSCR1_RxTresh(x) (((x) - 1) << 10) /* level [1..4] */
+
+#ifdef CONFIG_X86_PUMA6
+/* CE5X00 SSCR0 bit definition */
+#define CE5X00_SSCR0_DSS	((1<<5)-1)	/* Data Size Select (mask) */
+#define CE5X00_SSCR0_DataSize(x)  ((x) - 1)	/* Data Size Select [4..32] */
+#define CE5X00_SSCR0_FRF	(((1<<2)-1) << 5)	/* FRame Format (mask) */
+#define CE5X00_SSCR0_Motorola	(0x0 << 5)	/* Motorola's Serial Peripheral Interface (SPI) */
+#define CE5X00_SSCR0_TI	(0x1 << 5)	/* Texas Instruments' Synchronous Serial Protocol (SSP) */
+#define CE5X00_SSCR0_National	(0x2 << 5)	/* National Microwire */
+
+#define RX_THRESH_CE5X00_DFLT	16
+#define TX_THRESH_CE5X00_DFLT	16
+
+#define CE5X00_SSSR_TFL_MASK	(0x1F << 8)	/* Transmit FIFO Level mask */
+#define CE5X00_SSSR_RFL_MASK	(0x1F << 13)	/* Receive FIFO Level mask */
+
+#define CE5X00_SSCR1_TFT	(((1<<5)-1) << 6)	/* Transmit FIFO Threshold (mask) */
+#define CE5X00_SSCR1_TxTresh(x) (((x) - 1) << 6) /* level [1..32] */
+#define CE5X00_SSCR1_RFT	(((1<<5)-1) << 11)	/* Receive FIFO Threshold (mask) */
+#define CE5X00_SSCR1_RxTresh(x) (((x) - 1) << 11) /* level [1..32] */
+#define CE5X00_SSCR1_STRF       (1 << 17)	/* Select FIFO or EFWR */
+#define CE5X00_SSCR1_EFWR	(1 << 16)	/* Enable FIFO Write/Read */
+#endif /* CONFIG_X86_PUMA6 */
+
 #endif
 
 /* extra bits in PXA255, PXA26x and PXA27x SSP ports */
@@ -177,6 +201,7 @@ enum pxa_ssp_type {
 	PXA910_SSP,
 	CE4100_SSP,
 	LPSS_SSP,
+	CE5X00_SSP,
 };
 
 struct ssp_device {
--- a/include/linux/spi/pxa2xx_spi.h
+++ b/include/linux/spi/pxa2xx_spi.h
@@ -31,10 +31,17 @@ struct pxa2xx_spi_master {
 	u16 num_chipselect;
 	u8 enable_dma;
 
-	/* DMA engine specific config */
+#ifdef CONFIG_X86_PUMA7
 	bool (*dma_filter)(struct dma_chan *chan, void *param);
 	void *tx_param;
 	void *rx_param;
+#else
+	/* DMA engine specific config */
+	int rx_chan_id;
+	int tx_chan_id;
+	int rx_slave_id;
+	int tx_slave_id;
+#endif
 
 	/* For non-PXA arches */
 	struct ssp_device ssp;
