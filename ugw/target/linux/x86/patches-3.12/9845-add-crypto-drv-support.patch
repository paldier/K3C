--- a/arch/x86/NetIP_SubSystem/netip_mem_util.c
+++ b/arch/x86/NetIP_SubSystem/netip_mem_util.c
@@ -150,6 +150,7 @@ int netip_memmap_init(void)
         return -2;
     }
 
+    netss_bootcfg_init();
 #ifdef CONFIG_NET_SUBSYSTEM_SNOOPED_MODE
     netss_enable_snooped_mode();
 #endif
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_config.c
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_config.c
@@ -28,19 +28,71 @@
  */
 #include <linux/netip_subsystem.h>
 #include <linux/netip_mem_util.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
 
 #define NETSS_DEV_BOOTCFG_BASE 0xF00C0000
 
-#define MAX_DOMAIN_REGS     (38)
-#define LOCK_REG1_OFF       (0x007c)
-#define LOCK_REG2_OFF       (0x0080)
-#define DOMAIN_BASE_REG_OFF (0x028c)
-#define ENABLE_SNOOPED_MODE (0x0000a000)
-#define UNLOCK1_VALUE       (0x20406080)
-#define UNLOCK2_VALUE       (0x10305070)
-#define LOCK1_VALUE         (0x0204060f)
+#define MAX_DOMAIN_REGS             (38)
+#define LOCK_REG1_OFF               (0x007c)
+#define LOCK_REG2_OFF               (0x0080)
+#define DOMAIN_BASE_REG_OFF         (0x028c)
+#define SECURITY_MODULE_REG_OFF     (0x0268)
+#define ENABLE_SNOOPED_MODE         (0x00008000)
+#define UNLOCK1_VALUE               (0x20406080)
+#define UNLOCK2_VALUE               (0x10305070)
+#define LOCK1_VALUE                 (0x0204060f)
+#define DOCSIS_FUSE_1               (0x0148)
+#define DISABLE_IPSEC_BIT_OFFSET    (24)
 
 static bool snooped_en = false;
+static struct proc_dir_entry *g_netss_subsystem_proc_dir;
+
+static int netss_subsystem_proc_read_ipsec(struct seq_file *seq, void *v)
+{
+    unsigned int mask, readBit;
+    unsigned long *docsisFuseReg;
+
+    docsisFuseReg = netip_mmio_to_virtual(NETSS_DEV_BOOTCFG_BASE + DOCSIS_FUSE_1);
+
+    mask = (1 << DISABLE_IPSEC_BIT_OFFSET);
+
+    readBit = be32_to_cpu(*docsisFuseReg) & mask;
+
+    seq_printf(seq, "%d\n", readBit);
+
+    return 0;
+}
+
+static int netss_subsystem_proc_open_ipsec(struct inode *inode, struct file *file)
+{
+    return single_open(file, netss_subsystem_proc_read_ipsec, NULL);
+}
+
+static struct file_operations g_proc_file_ipsec_seq_fops = {
+    .owner = THIS_MODULE,
+    .open = netss_subsystem_proc_open_ipsec,
+    .read = seq_read,
+    .llseek = seq_lseek,
+    .release = single_release,
+};
+
+void netss_bootcfg_init(void)
+{
+    /* Check if bootcfg folder already exists */
+    if (g_netss_subsystem_proc_dir) {
+        return;
+    }
+
+    g_netss_subsystem_proc_dir = proc_mkdir("bootcfg", NULL);
+
+    if (!g_netss_subsystem_proc_dir) {
+        pr_err("Can't create bootcfg folder\n");
+        return;
+    }
+
+    proc_create("ipsec_disable", S_IRUGO, g_netss_subsystem_proc_dir, &g_proc_file_ipsec_seq_fops);
+}
 
 void netss_enable_snooped_mode(void)
 {
@@ -48,6 +100,7 @@ void netss_enable_snooped_mode(void)
     unsigned long *lock1;
     unsigned long *lock2;
     unsigned long *domain_base;
+    unsigned int reg_val;
 
     if (snooped_en)
         return;
@@ -60,10 +113,17 @@ void netss_enable_snooped_mode(void)
     *lock2 = cpu_to_be32(UNLOCK2_VALUE);
 
     for (i=0; i < MAX_DOMAIN_REGS; i++) {
-        *domain_base = cpu_to_be32(ENABLE_SNOOPED_MODE);
+        reg_val  = be32_to_cpu(*domain_base);
+        reg_val |= ENABLE_SNOOPED_MODE;
+        *domain_base = cpu_to_be32(reg_val);
         domain_base++;
     }
 
+    domain_base = netip_mmio_to_virtual(NETSS_DEV_BOOTCFG_BASE + SECURITY_MODULE_REG_OFF);
+    reg_val  = be32_to_cpu(*domain_base);
+    reg_val |= ENABLE_SNOOPED_MODE;
+    *domain_base = cpu_to_be32(reg_val);
+
     *lock1 = cpu_to_be32(LOCK1_VALUE);
 
     snooped_en = true;
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_config.h
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_config.h
@@ -29,6 +29,7 @@
 #ifndef _NETIP_SUBSYSTEM_CONFIG_H
 #define _NETIP_SUBSYSTEM_CONFIG_H
 
+void netss_bootcfg_init(void);
 void netss_enable_snooped_mode(void);
 
 #endif
--- a/arch/x86/pal_cppi41/pal_cppi41.c
+++ b/arch/x86/pal_cppi41/pal_cppi41.c
@@ -431,7 +431,7 @@ PAL_Cppi4AccChHnd PAL_cppi4AccChOpen(PAL
     ptr_ch_cfg.Param2       =   (accCfg->pacingTickCnt)             |
                                 (accCfg->list.maxPageCnt    << 16)  | (accCfg->list.listEntrySize  << 18)|
                                 (accCfg->list.listCountMode << 20)  | (accCfg->list.stallAvoidance << 21)|
-                                (accCfg->list.pacingMode    << 22);
+                                (accCfg->list.pacingMode    << 22   | (accCfg->mode << 31)); 
 
     rc = __cppi4AccChOpen ( &ptr_ch_cfg);
     if (PP_RC_SUCCESS != rc)
--- a/drivers/net/puma7.Kconfig
+++ b/drivers/net/puma7.Kconfig
@@ -32,3 +32,14 @@ config WIFI_PROXY_EMULATOR
           If wifi proxy emulator is needed
           then select yes.
           else, select no.
+
+#
+# Crypto PDSP / IPSec support
+#
+
+config IPSEC_SUPPORT
+       bool "Enable PP's IPSec Support"
+       default n
+       ---help---
+         Select if IPSec support is needed
+
--- a/include/linux/avalanche/generic/avalanche_pdsp_api.h
+++ b/include/linux/avalanche/generic/avalanche_pdsp_api.h
@@ -195,45 +195,49 @@ typedef enum
 typedef enum
 {
     PDSP_ID_START,
-    PDSP_ID_Sequencer = PDSP_ID_START,      //  Sequencer
+    PDSP_ID_Sequencer = PDSP_ID_START,          //  Sequencer
 
-    PDSP_ID_Prefetcher_0,                   //  Prefetcher   group - PDSP 0
-    PDSP_ID_Prefetcher_1,                   //  Prefetcher   group - PDSP 1
-    PDSP_ID_Prefetcher_2,                   //  Prefetcher   group - PDSP 2
-    PDSP_ID_Prefetcher_3,                   //  Prefetcher   group - PDSP 3
-
-    PDSP_ID_Classifier1_0,                  //  Classifier1  group - PDSP 0
-    PDSP_ID_Classifier1_1,                  //  Classifier1  group - PDSP 1
-    PDSP_ID_Classifier1_2,                  //  Classifier1  group - PDSP 2
-    PDSP_ID_Classifier1_3,                  //  Classifier1  group - PDSP 3
-
-    PDSP_ID_Classifier2_0,                  //  Classifier2  group - PDSP 0
-    PDSP_ID_Classifier2_1,                  //  Classifier2  group - PDSP 1
-    PDSP_ID_Classifier2_2,                  //  Classifier2  group - PDSP 2
-    PDSP_ID_Classifier2_3,                  //  Classifier2  group - PDSP 3
-
-    PDSP_ID_Modifier_0,                     //  Modifier     group - PDSP 0
-    PDSP_ID_Modifier_1,                     //  Modifier     group - PDSP 1
-    PDSP_ID_Modifier_2,                     //  Modifier     group - PDSP 2
-    PDSP_ID_Modifier_3,                     //  Modifier     group - PDSP 3
-
-    PDSP_ID_ReSequencer,                    //  ReSequencer
-
-    PDSP_ID_QoS_0,                          //  QoS          group - PDSP 0
-    PDSP_ID_QoS_1,                          //  QoS          group - PDSP 1
-
-    PDSP_ID_Recycler,                       //  Recycler PDSP
-    PDSP_ID_Accumulator,                    //  Accumulator PDSP
-    PDSP_ID_Wifi_TX,                        //  Wifi proxy - TX PDSP (Wifi_0)
-    PDSP_ID_Wifi_RX,                        //  Wifi proxy - RX PDSP (Wifi_1)
-    PDSP_ID_Moca,                           //  Moca PDSP
-    PDSP_ID_FCC_0,                          //  FCC_1  PDSP
-    PDSP_ID_FCC_1,                          //  FCC_0  PDSP
-
-    PDSP_ID_Session_Cache,                  //  Session Cache PDSP
-    PDSP_ID_AQM,                            //  AQM PDSP
-    PDSP_ID_MC,                             //  MC PDSP
-    PDSP_ID_TurboDOX,                       //  TurboDOX PDSP
+    PDSP_ID_Prefetcher_0,                       //  Prefetcher   group - PDSP 0
+    PDSP_ID_Prefetcher_1,                       //  Prefetcher   group - PDSP 1
+    PDSP_ID_Prefetcher_2,                       //  Prefetcher   group - PDSP 2
+    PDSP_ID_Prefetcher_3,                       //  Prefetcher   group - PDSP 3
+
+    PDSP_ID_Classifier1_0,                      //  Classifier1  group - PDSP 0
+    PDSP_ID_Classifier1_1,                      //  Classifier1  group - PDSP 1
+    PDSP_ID_Classifier1_2,                      //  Classifier1  group - PDSP 2
+    PDSP_ID_Classifier1_3,                      //  Classifier1  group - PDSP 3
+
+    PDSP_ID_Classifier2_0,                      //  Classifier2  group - PDSP 0
+    PDSP_ID_Classifier2_1,                      //  Classifier2  group - PDSP 1
+    PDSP_ID_Classifier2_2,                      //  Classifier2  group - PDSP 2
+    PDSP_ID_Classifier2_3,                      //  Classifier2  group - PDSP 3
+
+    PDSP_ID_Modifier_0,                         //  Modifier     group - PDSP 0
+    PDSP_ID_Modifier_1,                         //  Modifier     group - PDSP 1
+    PDSP_ID_Modifier_2,                         //  Modifier     group - PDSP 2
+    PDSP_ID_Modifier_3,                         //  Modifier     group - PDSP 3
+
+    PDSP_ID_ReSequencer,                        //  ReSequencer
+
+    PDSP_ID_QoS_0,                              //  QoS          group - PDSP 0
+    PDSP_ID_QoS_1,                              //  QoS          group - PDSP 1
+
+    PDSP_ID_Recycler,                           //  Recycler PDSP
+    PDSP_ID_Accumulator,                        //  Accumulator PDSP
+    PDSP_ID_Wifi_TX,                            //  Wifi proxy - TX PDSP (Wifi_0)
+    PDSP_ID_Wifi_RX,                            //  Wifi proxy - RX PDSP (Wifi_1)
+    PDSP_ID_Moca,                               //  Moca PDSP
+
+    PDSP_ID_Encrypt,                            // Encrypt (formerly FCC_0)
+    PDSP_ID_Decrypt,                            // Decrypt (formerly FCC_1)
+    PDSP_ID_DPI,                                // DPI PDSP
+    PDSP_ID_Crypto,                             // Crypto ("Security")
+    PDSP_ID_RCE,                                // RCE PDSP
+
+    PDSP_ID_Session_Cache,                      //  Session Cache PDSP
+    PDSP_ID_AQM,                                //  AQM PDSP
+    PDSP_ID_MC,                                 //  MC PDSP
+    PDSP_ID_TurboDOX,                           //  TurboDOX PDSP
 
     PDSP_ID_DS_RESEQ,
     PDSP_ID_US_START,                           //  US PDSP first index
--- a/include/linux/avalanche/generic/avalanche_pp_api.h
+++ b/include/linux/avalanche/generic/avalanche_pp_api.h
@@ -172,8 +172,12 @@ typedef struct
     Uint32  WifiRxPDSPver;
     Uint32  MocaPPver;
     Uint32  MocaPDSPver;
-    Uint32  IpsecPPver;
-    Uint32  IpsecPDSPver;
+    Uint32  CryptoPPver;
+    Uint32  CryptoPDSPver;
+    Uint32  EncryptPPver;
+    Uint32  EncryptPDSPver;
+    Uint32  DecryptPPver;
+    Uint32  DecryptPDSPver;
 
     Uint32  MinPPver;
     Uint32  MaxPPver;
--- a/include/linux/avalanche/generic/pp_qos_p7.h
+++ b/include/linux/avalanche/generic/pp_qos_p7.h
@@ -1,572 +1,572 @@
-/* 
- * pp_qos_p7.h
- * Description:
- * QoS Manager driver APIs
- 
- 
-  This file is provided under a dual BSD/GPLv2 license.  When using or
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2016 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-  The full GNU General Public License is included in this distribution
-  in the file called LICENSE.GPL.
-
-
-  Contact Information:
-  Intel Corporation
-  2200 Mission College Blvd.
-  Santa Clara, CA  97052
-
-  BSD LICENSE
-
-  Copyright(c) 2016 Intel Corporation. All rights reserved.
-
-  Redistribution and use in source and binary forms, with or without
-  modification, are permitted provided that the following conditions
-  are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-
-    * Neither the name of Intel Corporation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-*/
-
-#ifndef PP_QOS_P7_H
-#define PP_QOS_P7_H
-/************************************************/
-/*                    Includes                  */
-/************************************************/
-
-/************************************************/
-/*                    Defines                   */
-/************************************************/
-
-#define PP_QOS_MAX_CLUSTERS          (64)
-#define PP_QOS_MAX_QUEUES            (192)
-#define PP_QOS_MAX_QUEUES_IN_CLUSTER AVALANCHE_PP_QOS_CLST_MAX_QCNT
-
-#define PP_QOS_MAX_QUEUE_INDEX       (PP_QOS_MAX_QUEUES - 1)
-#define PP_QOS_MAX_CLUSTER_INDEX     (PP_QOS_MAX_CLUSTERS - 1)
-
-#define PP_QOS_Q_REALTIME_FLAG       (1<<0)
-#define PP_QOS_Q_NO_QOS_FLAG         (1<<1)
-
-
-#define PP_QOS_ITERATION_TICK_USEC   (25)
-#define PP_QOS_ITERATION_PER_SECOND  (1000000 / PP_QOS_ITERATION_TICK_USEC)
-
-#define INVALID_QDA_THREAD_ID        (32)
-#define INVALID_QDA_QUEUE            (255)
-#define PP_QOS_INVALID_CLUSTER       (255)
-#define PP_QOS_DEFAULT_PRIORITY      (0)
-
-#define PP_QOS_FW_QCFG_BLK_BASE_PHY  (0xF3E10200)
-#define PP_QOS_FW_CLST_BLK_BASE_PHY  (0xF3E12200)
-
-/* Rate(in Mbps) * 1M) / iteration per second / 8(bits in byte) */
+/* 
+ * pp_qos_p7.h
+ * Description:
+ * QoS Manager driver APIs
+ 
+ 
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2016 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef PP_QOS_P7_H
+#define PP_QOS_P7_H
+/************************************************/
+/*                    Includes                  */
+/************************************************/
+
+/************************************************/
+/*                    Defines                   */
+/************************************************/
+
+#define PP_QOS_MAX_CLUSTERS          (64)
+#define PP_QOS_MAX_QUEUES            (192)
+#define PP_QOS_MAX_QUEUES_IN_CLUSTER AVALANCHE_PP_QOS_CLST_MAX_QCNT
+
+#define PP_QOS_MAX_QUEUE_INDEX       (PP_QOS_MAX_QUEUES - 1)
+#define PP_QOS_MAX_CLUSTER_INDEX     (PP_QOS_MAX_CLUSTERS - 1)
+
+#define PP_QOS_Q_REALTIME_FLAG       (1<<0)
+#define PP_QOS_Q_NO_QOS_FLAG         (1<<1)
+
+
+#define PP_QOS_ITERATION_TICK_USEC   (25)
+#define PP_QOS_ITERATION_PER_SECOND  (1000000 / PP_QOS_ITERATION_TICK_USEC)
+
+#define INVALID_QDA_THREAD_ID        (32)
+#define INVALID_QDA_QUEUE            (255)
+#define PP_QOS_INVALID_CLUSTER       (255)
+#define PP_QOS_DEFAULT_PRIORITY      (0)
+
+#define PP_QOS_FW_QCFG_BLK_BASE_PHY  (0xF3E10200)
+#define PP_QOS_FW_CLST_BLK_BASE_PHY  (0xF3E12200)
+
+/* Rate(in Mbps) * 1M) / iteration per second / 8(bits in byte) */
 #define PP_QOS_MEGA_BIT_PER_SEC_TO_IT_CREDIT_BYTES(x)    ((Uint32)(((Uint64)(x * 1000 * 1000)) / PP_QOS_ITERATION_PER_SECOND / 8 ))
-#define PP_QOS_PPS_TO_IT_CREDIT_PACKETS(x)               ((Uint16)(x / PP_QOS_ITERATION_PER_SECOND))
-
-/************************************************/
-/*                 Structures                   */
-/************************************************/
-/* QoS manager return code */
-typedef enum
-{
-    PP_QOS_RC_SUCCESS,
-    PP_QOS_RC_FAILURE,
-    PP_QOS_RC_INVALID_PARAM,
-    PP_QOS_RC_OUT_OF_MEMORY,
-    PP_QOS_RC_OBJECTS_STARVATION
-}
-PP_QOS_MGR_RET_e;
-
-/* QoS manager scheduling mode */
-typedef enum
-{
-    PP_QOS_SCH_STRICT,
-    PP_QOS_SCH_WFQ
-}
-PP_QOS_SCH_MODE_e;
-
-/* QoS manager Qos-profile */
-typedef struct
-{
-    PP_QOS_SCH_MODE_e sch_mode;                   /* Strict/WFQ */
-    Uint8             num_of_priorities;          /* Number of priorities */
-    Uint8             vpid_id;                    /* VPID ID */
-    Uint16            profile_private_identifier;
-    Uint32            egress_port_queue;          /* Egress queue number */
-    Uint32            egress_queue_depth_packets; /* Egress queue depth (packets) */
-    Uint32            egress_queue_depth_bytes;   /* Egress queue depth (bytes) */
-    Uint32            ingress_queue_depth_packets;/* Ingress queue depth (packets) */
-    Uint32            ingress_queue_depth_bytes;  /* Ingress queue depth (bytes) */
-    Uint32            port_rate_limit_Mbps;       /* Rate limit (in Mbps)*/
-    Uint32            port_pps_limit;             /* PPS limit */
-}
-PP_QOS_PROFILE_t;
-
-/* QoS manager statistics */
-typedef struct
-{
-    Uint8    active_shared_clusters;
-    Uint8    active_private_clusters[AVALANCHE_PP_MAX_PID];
-    Uint8    private_clusters_free_pool_cnt[AVALANCHE_PP_MAX_PID];
-    Uint8    active_shared_queues;
-    Uint8    active_private_queues[AVALANCHE_PP_MAX_PID];
-    Uint8    private_queues_free_pool_cnt[AVALANCHE_PP_MAX_PID];
-    Uint32   clusters_starvation_shared;
-    Uint32   queues_starvation_shared;
-}
-PP_QOS_DB_Counters_t;
-
-typedef struct
-{
-    Uint64      frwd_pkts;            /* Number of packets forwarded to the Egress Queue */
-    Uint64      drp_pkts;             /* Number of packets dropped due to congestion */
-}
-PP_QOS_MIB_STATS_t;
-
-typedef struct
-{
-
-    Uint32                      global_credit_bytes;        /* The amount of global credit bytes available to the next Qos queue in the cluster */
-
-    Uint16                      global_credit_pkts;         /* The amount of global credit packet available to the next Qos queue in the cluster */
-    Uint16                      max_global_credit_pkts;     /* The max amount of global credit pkts allowed carring over to the next queue. */
-
-    Uint32                      max_global_credit_bytes;    /* The max amount of global credit bytes allowed carring over to the next queue. */
-
-    Uint16                      qda_queue;                  /* The queue which we activated QDA on. INVALID_QDA_QUEUE indicates that QDA wasn't activated on any on the cluster queues */
-    Uint8                       egr_q_cnt;                  /* The total number of egress queues sampled to obtain the egress queue congestion estimation */
-    Uint8                       qos_q_cnt;                  /* The number of QOS queues in the cluster (1 to 9) */
-
-    Uint8                       qos_q3;                     /* The queue index (0 to 127) of each QOS queue in the cluster listed in priority order */
-    Uint8                       qos_q2;
-    Uint8                       qos_q1;
-    Uint8                       qos_q0;
-
-    Uint8                       qos_q7;
-    Uint8                       qos_q6;
-    Uint8                       qos_q5;
-    Uint8                       qos_q4;
-
-    Uint16                      egr_q1;                     /* The Queue index of every egress queue enumerated in Egress Queue Count */
-    Uint16                      egr_q0;
-
-    Uint16                      egr_q3;
-    Uint16                      egr_q2;
-
-    Uint32                      egr_congst_thrsh_bytes1;	/* Egress Congestion Threshold bytes point 1  */
-    Uint32                      egr_congst_thrsh_bytes2;	/* Egress Congestion Threshold bytes point 2  */
-    Uint32                      egr_congst_thrsh_bytes3;    /* Egress Congestion Threshold bytes point 3  */
-    Uint32                      egr_congst_thrsh_bytes4;	/* Egress Congestion Threshold bytes point 4  */
-
-    Uint16                      egr_congst_thrsh_pkts1;     /* Egress Congestion Threshold Packets point 4  */
-    Uint16                      egr_congst_thrsh_pkts2;     /* Egress Congestion Threshold Packets point 3  */
-    Uint16                      egr_congst_thrsh_pkts3;     /* Egress Congestion Threshold Packets point 2  */
-    Uint16                      egr_congst_thrsh_pkts4;     /* Egress Congestion Threshold Packets point 1  */
-
-    Uint32                      w14;                        /* Reserved */
-    Uint32                      w15;                        /* Reserved */
-
-}
-PP_QOS_FW_CLST_CFG_t;
-
-typedef struct
-{
-    Uint16 egr_q;                    /* The Queue index of the forwarding queue */
-    Uint8  flags;                    /* Specifies how the frames in the QOS queue should be handled */
-    Uint8  QDAThreadId;              /* Indicates which QDA thread id is working on that queue. INVALID_QDA_THREAD_ID means that no thread is bound to that queue */
-
-    Uint32 iteration_credit_bytes;   /* The amount of byte credit that the queue receives every 25us. */
-    Uint32 total_credit_bytes;       /* The total amount of forwarding byte credit that the queue is currently holding */
-    Uint32 max_credit_bytes;         /* The max amount of forwarding byte crerdit that the queue is allowed to hold at the end of the 25US iteration */
-
-    Uint16 iteration_credit_pkts;    /* The amount of packet credit that the queue receives every 25us. */
-    Uint16 total_credit_pkts;        /* The total amount of forwarding pkt credit that the queue is currently holding */
-
-    Uint16 max_credit_pkts;          /* The max amount of forwarding packet crerdit that the queue is allowed to hold at the end of the 25US iteration */
-    Uint16 congst_thrsh_pkts;        /* The size in packets at which point the Qos queue is considered to be congested */
-
-    Uint32 congst_thrsh_bytes;       /* The size in bytes at which point the Qos queue is considered to be congested */
-    Uint32 w7;                       /* Reserved */
-
-}
-PP_QOS_FW_QUEUE_t;
-
-#ifdef __KERNEL__
-/* **************************************************************************************** */
-/*                                                                                          */
-/*                                                                                          */
-/*                                                                                          */
-/*                      KERNEL only Stuff                                                   */
-/*                                                                                          */
-/*                                                                                          */
-/*                                                                                          */
-/* **************************************************************************************** */
-
-
-/************************************************/
-/* QoS manager APIs                             */
-/************************************************/
-/**************/
-/* Common     */
-/**************/
-/**
- *  pp_qos_mngr_init - Initialized the QoS manager DB
- *  
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_mngr_init(void);
-/**
- *  pp_qos_set_basic_profile - This API should be called while
- *  QoS profile is created for NI
- *  basic profile is 1 cluster with 1 egress queue.
- *  @qos_profile: Pointer to qos profile to set
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_set_basic_profile(PP_QOS_PROFILE_t *qos_profile);
-/**
- *  pp_qos_is_profile_registered - This API return if the QoS
- *  profile is alreadu exist int the QoS manager
- *  @vpid_id: Pointer to qos profile to set
- *  @profile_private_identifier: identifier for profile
- *  @isSupported: pointer to return id profile is registered
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_is_profile_registered(Uint8 vpid_id, Uint16 profile_private_identifier, Bool *isRegistered);
-/**
- *  pp_qos_delete_profile - This API should be called when NI
- *  need to delete QoS profile
- *  @vpid_id: Profile's VPID
- *  @profile_private_identifier: Profile's private identifier
- *  @profile_stats: To return the profile statistics before the
- *                profile will deleted.
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_delete_profile(Uint8 vpid_id, Uint16 profile_private_identifier, PP_QOS_MIB_STATS_t *profile_stats);
-/**
- *  pp_qos_delete_all_profiles - This API should be called while
- *  NI is going down
- *  @vpid_id: VPID ID
- *  @vpid_stats: To return the vpid statistics before the
- *             profiles will deleted.
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_delete_all_profiles(Uint8 vpid_id, PP_QOS_MIB_STATS_t * vpid_stats);
-/**
- *  pp_qos_db_get_counters - Get the QoS DB statistics
- *  @qos_db_stats: Pointer to QoS DB statistics to set
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_db_get_counters(PP_QOS_DB_Counters_t *qos_db_stats);
-/**
- *  pp_qos_enable_psm - Enter to psm mode
- *  
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_enable_psm(void);
-/**
- *  pp_qos_disable_psm - Exit from psm mode
- *  
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_disable_psm(void);
-
-
-/**************/
-/* Cluster    */
-/**************/
-/**
- *  pp_qos_cluster_is_active - Check if cluster is active
- *  @phy_cluster_id: Cluster ID
- *  @is_active: Pointer to return if active or not
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_cluster_is_active(Uint8 phy_cluster_id, Bool *is_active);
-/**
- *  pp_qos_set_cluster_config - Config QoS cluster
- *  @phy_cluster_id: Cluster ID
- *  @vpid_id: VPID ID
- *  @clst_cfg: Pointer to requested cluster
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_set_cluster_config(Uint8 phy_cluster_id, Uint8 vpid_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
-/**
- *  pp_qos_alloc_cluster - Alloc/Create QoS cluster
- *  @vpid_id: VPID ID
- *  @phy_cluster_id: Pointer to return the cluster ID
- *  @profile_private_identifier: unique identifier for profile
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_alloc_cluster(Uint8 vpid_id, Uint16 profile_private_identifier, Uint8 *phy_cluster_id);
-/**
- *  pp_qos_free_cluster - Free/Delete QoS cluster
- *  @phy_cluster_id: Cluster ID
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_free_cluster(Uint8 phy_cluster_id);
-/**
- *  pp_qos_get_cluster_config - Get the cluster configuration
- *  @phy_cluster_id: Cluster ID
- *  @clst_cfg: Pointer to return the cluster configuration
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_get_cluster_config(Uint8 phy_cluster_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
-/**
- *  pp_qos_get_queue_and_cluster_id_by_priority - Get the
- *  cluster and queue ID for given vpid identifier and Q
- *  priority.
- *  @vpid_id: VPID ID
- *  @profile_private_identifier: Private identifier for profile
- *  @priority: queue priority - This Uint8 field represent the
- *           priority of the qos Q, 0 is the lowest priority,
- *           the max priority is the number of qos queues in the
- *           cluster.
- *  @phy_cluster_id: Pointer to return the cluster ID
- *  @phy_queue_id: Pointer to return the queue ID
- *  
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_get_queue_and_cluster_id_by_priority(Uint8 vpid_id, Uint16 profile_private_identifier, Uint8 priority, Uint8 *phy_cluster_id, Uint8 *phy_queue_id);
-/**
- *  pp_qos_get_queue_id_by_cluster_and_priority - Get the queue
- *  ID by given cluster and priority.
- *  @phy_cluster_id: Cluster ID
- *  @priority: queue priority - This Uint8 field represent the
- *           priority of the qos Q, 0 is the lowest priority,
- *           the max priority is the number of qos queues in the
- *           cluster.
- *  @phy_queue_id: Pointer to return the queue ID
- *  
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_get_queue_id_by_cluster_and_priority(Uint8 phy_cluster_id, Uint8 priority, Uint8 *phy_queue_id);
-/**
- *  pp_qos_get_cluster_by_identifier - Get the cluster
- *  configuration by given VPID and identifier.
- *  @profile_private_identifier: Private identifier
- *  @vpid_id: VPID ID
- *  @phy_cluster_id: Pointer to return the cluster ID
- *  @clst_cfg: Pointer to return the cluster configuration
- *  
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_get_cluster_by_identifier(Uint16 profile_private_identifier, Uint8 vpid_id,  Uint8 *phy_cluster_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
-/**
- *  pp_qos_get_cluster_stats - Get QoS statistics for cluster
- *  @phy_cluster_id: Cluster ID
- *  @cluster_stats: Pointer to return the cluster
- *                statistics
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_get_cluster_stats(Uint8 phy_cluster_id, PP_QOS_MIB_STATS_t *cluster_stats);
-/**
- *  pp_qos_get_cluster_by_queue_id - Get the cluster
- *  configuration by a given queue id
- *  @phy_queue_id: Queue ID
- *  @phy_cluster_id: Pointer to return the cluster id
- *  @clst_cfg: Pointer to return the cluster
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_get_cluster_by_queue_id(Uint8 phy_queue_id, Uint8 *phy_cluster_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
-/**************/
-/* Queue      */
-/**************/
-/**
- *  pp_qos_add_queue_to_cluster - Adds queue to cluster
- *  @phy_cluster_id: Cluster ID
- *  @user_priority: User priority of the queue
- *  @queue_cfg: Pointer to AVALANCHE_PP_QOS_QUEUE_t
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_add_queue_to_cluster(Uint8 phy_cluster_id, AVALANCHE_PP_QOS_QUEUE_t *queue_cfg, Uint8 user_priority);
-/**
- *  pp_qos_del_queue_by_cluster_and_user_prio - Deletes queue
- *  from cluster
- *  @phy_cluster_id: Cluster ID
- *  @user_priority: User priority of the queue
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_del_queue_by_cluster_and_user_prio(Uint8 phy_cluster_id, Uint8 user_priority);
-
-PP_QOS_MGR_RET_e pp_qos_get_queue_and_cluster_id_by_user_priority(Uint8 vpid_id, Uint16 profile_private_identifier, Uint8 user_priority,
-																	      Uint8 *phy_cluster_id, Uint8 *phy_queue_id, Uint8 *pp_priority);
-
-/**
- *  pp_qos_queue_is_active - Check if queue is active
- *  @phy_queue_id: Queue ID
- *  @is_active: Pointer to return if active or not
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_queue_is_active(Uint8 phy_queue_id, Bool *is_active);
-/**
- *  pp_qos_alloc_queue - Alloc/Create QoS queue
- *  @phy_cluster_id: Cluster ID
- *  @phy_queue_id: Pointer to return the queue ID
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_alloc_queue(Uint8 phy_cluster_id, Uint8 *phy_queue_id);
-/**
- *  pp_qos_free_queue - Free/Delete QoS queue
- *  @phy_queue_id: Queue ID
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_free_queue(Uint8 phy_queue_id);
-/**
- *  pp_qos_get_queue_config - Get the queue configuration
- *  @phy_queue_id: Queue ID
- *  @queue_cfg: Pointer to return the queue configuration
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_get_queue_config(Uint8 phy_queue_id, AVALANCHE_PP_QOS_QUEUE_t *queue_cfg);
-/**
- *  pp_qos_modify_active_queue - Modify properties for an active
- *  queue
- *  @q_cfg: Pointer to queue new configuration
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_modify_active_queue(AVALANCHE_PP_QOS_QUEUE_t *modified_q_cfg); /* Modify properties for an active queue. */
-/**
- *  pp_qos_get_queue_stats - Get QoS queue statistics
- *  @qos_qnum: Queue ID
- *  @stats: Pointer to return the queue statistics
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_get_queue_stats(Uint32 qos_qnum, PP_QOS_MIB_STATS_t *q_stats);
-/**
- *  pp_qos_inc_session_cnt_for_queue - Increment sessions
- *  counter for QoS queue
- *  @phy_queue_id: Queue ID
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_inc_session_cnt_for_queue(Uint8 phy_queue_id);
-/**
- *  pp_qos_dec_session_cnt_for_queue - Decrement sessions
- *  counter for QoS queue
- *  @phy_queue_id: Queue ID
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_dec_session_cnt_for_queue(Uint8 phy_queue_id);
-
-/**************/
-/* VPID       */
-/**************/
-/**
- *  pp_qos_vpid_is_active - Check if VPID is active (active in the QoS)
- *  @vpid_id: VPID ID
- *  @is_active: Pointer to return if active or not
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */ 
-PP_QOS_MGR_RET_e pp_qos_vpid_is_active(Uint8 vpid_id, Bool *is_active);
-/**
- *  pp_qos_is_vpid_registered - Return True if the given VPID is
- *  currently supported by the QoS
- *  @vpid_id: VPID ID
- *  @isRegistered: Pointer to return if the VPID is active
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_is_vpid_registered(Uint8 vpid_id, Bool *isRegistered);
-/**
- *  pp_qos_vpid_set_qos_mode - Set the QOS clusters of a VPID to
- *  do Qos or not
- *  @vpid_id: VPID ID
- *  @vpidQosMode: If the requsted mode is QoS/no-QoS
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_vpid_set_qos_mode(Uint8 vpid_id, Bool vpidQosMode);
-/**
- *  pp_qos_get_vpid_config - Get the vpid clusters configuration
- *  @phy_cluster_id: Cluster ID
- *  @clst_cfg_arr: Pointer to array of clusters (in size of
- *           PP_QOS_MAX_CLUSTERS)
- *  @clusters_cnt: in -> Pointer to MAX size of clst_cfg array.
- *                 out -> Pointer to return the number of
- *               clusters thet filled by the function.
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_get_vpid_config(Uint8 vpid_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg_arr, Uint8 *clusters_cnt);
-/**
- *  pp_qos_get_vpid_stats - Get QoS statistics for VPID
- *  @vpid_id: VPID ID
- *  @vpid_stats: Pointer to return the vpid statistics
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_get_vpid_stats(Uint8 vpid_id, PP_QOS_MIB_STATS_t *vpid_stats);
-/**
- *  pp_qos_get_profile_stats - Get QoS statistics for
- *  Profile
- *  @vpid_id: VPID ID
- *  @profile_private_identifier: Private identifier
- *  @profile_stats: Pointer to return the profile statistics
- *
- *  Returns PP_QOS_RC_SUCCESS if pass.
- */
-PP_QOS_MGR_RET_e pp_qos_get_profile_stats(Uint8 vpid_id, Uint16 profile_private_identifier, PP_QOS_MIB_STATS_t *profile_stats);
-
-#endif /* __KERNEL__ */
-
-#endif /* PP_QOS_P7_H */
+#define PP_QOS_PPS_TO_IT_CREDIT_PACKETS(x)               ((Uint16)(x / PP_QOS_ITERATION_PER_SECOND))
+
+/************************************************/
+/*                 Structures                   */
+/************************************************/
+/* QoS manager return code */
+typedef enum
+{
+    PP_QOS_RC_SUCCESS,
+    PP_QOS_RC_FAILURE,
+    PP_QOS_RC_INVALID_PARAM,
+    PP_QOS_RC_OUT_OF_MEMORY,
+    PP_QOS_RC_OBJECTS_STARVATION
+}
+PP_QOS_MGR_RET_e;
+
+/* QoS manager scheduling mode */
+typedef enum
+{
+    PP_QOS_SCH_STRICT,
+    PP_QOS_SCH_WFQ
+}
+PP_QOS_SCH_MODE_e;
+
+/* QoS manager Qos-profile */
+typedef struct
+{
+    PP_QOS_SCH_MODE_e sch_mode;                   /* Strict/WFQ */
+    Uint8             num_of_priorities;          /* Number of priorities */
+    Uint8             vpid_id;                    /* VPID ID */
+    Uint16            profile_private_identifier;
+    Uint32            egress_port_queue;          /* Egress queue number */
+    Uint32            egress_queue_depth_packets; /* Egress queue depth (packets) */
+    Uint32            egress_queue_depth_bytes;   /* Egress queue depth (bytes) */
+    Uint32            ingress_queue_depth_packets;/* Ingress queue depth (packets) */
+    Uint32            ingress_queue_depth_bytes;  /* Ingress queue depth (bytes) */
+    Uint32            port_rate_limit_Mbps;       /* Rate limit (in Mbps)*/
+    Uint32            port_pps_limit;             /* PPS limit */
+}
+PP_QOS_PROFILE_t;
+
+/* QoS manager statistics */
+typedef struct
+{
+    Uint8    active_shared_clusters;
+    Uint8    active_private_clusters[AVALANCHE_PP_MAX_PID];
+    Uint8    private_clusters_free_pool_cnt[AVALANCHE_PP_MAX_PID];
+    Uint8    active_shared_queues;
+    Uint8    active_private_queues[AVALANCHE_PP_MAX_PID];
+    Uint8    private_queues_free_pool_cnt[AVALANCHE_PP_MAX_PID];
+    Uint32   clusters_starvation_shared;
+    Uint32   queues_starvation_shared;
+}
+PP_QOS_DB_Counters_t;
+
+typedef struct
+{
+    Uint64      frwd_pkts;            /* Number of packets forwarded to the Egress Queue */
+    Uint64      drp_pkts;             /* Number of packets dropped due to congestion */
+}
+PP_QOS_MIB_STATS_t;
+
+typedef struct
+{
+
+    Uint32                      global_credit_bytes;        /* The amount of global credit bytes available to the next Qos queue in the cluster */
+
+    Uint16                      global_credit_pkts;         /* The amount of global credit packet available to the next Qos queue in the cluster */
+    Uint16                      max_global_credit_pkts;     /* The max amount of global credit pkts allowed carring over to the next queue. */
+
+    Uint32                      max_global_credit_bytes;    /* The max amount of global credit bytes allowed carring over to the next queue. */
+
+    Uint16                      qda_queue;                  /* The queue which we activated QDA on. INVALID_QDA_QUEUE indicates that QDA wasn't activated on any on the cluster queues */
+    Uint8                       egr_q_cnt;                  /* The total number of egress queues sampled to obtain the egress queue congestion estimation */
+    Uint8                       qos_q_cnt;                  /* The number of QOS queues in the cluster (1 to 9) */
+
+    Uint8                       qos_q3;                     /* The queue index (0 to 127) of each QOS queue in the cluster listed in priority order */
+    Uint8                       qos_q2;
+    Uint8                       qos_q1;
+    Uint8                       qos_q0;
+
+    Uint8                       qos_q7;
+    Uint8                       qos_q6;
+    Uint8                       qos_q5;
+    Uint8                       qos_q4;
+
+    Uint16                      egr_q1;                     /* The Queue index of every egress queue enumerated in Egress Queue Count */
+    Uint16                      egr_q0;
+
+    Uint16                      egr_q3;
+    Uint16                      egr_q2;
+
+    Uint32                      egr_congst_thrsh_bytes1;	/* Egress Congestion Threshold bytes point 1  */
+    Uint32                      egr_congst_thrsh_bytes2;	/* Egress Congestion Threshold bytes point 2  */
+    Uint32                      egr_congst_thrsh_bytes3;    /* Egress Congestion Threshold bytes point 3  */
+    Uint32                      egr_congst_thrsh_bytes4;	/* Egress Congestion Threshold bytes point 4  */
+
+    Uint16                      egr_congst_thrsh_pkts1;     /* Egress Congestion Threshold Packets point 4  */
+    Uint16                      egr_congst_thrsh_pkts2;     /* Egress Congestion Threshold Packets point 3  */
+    Uint16                      egr_congst_thrsh_pkts3;     /* Egress Congestion Threshold Packets point 2  */
+    Uint16                      egr_congst_thrsh_pkts4;     /* Egress Congestion Threshold Packets point 1  */
+
+    Uint32                      w14;                        /* Reserved */
+    Uint32                      w15;                        /* Reserved */
+
+}
+PP_QOS_FW_CLST_CFG_t;
+
+typedef struct
+{
+    Uint16 egr_q;                    /* The Queue index of the forwarding queue */
+    Uint8  flags;                    /* Specifies how the frames in the QOS queue should be handled */
+    Uint8  QDAThreadId;              /* Indicates which QDA thread id is working on that queue. INVALID_QDA_THREAD_ID means that no thread is bound to that queue */
+
+    Uint32 iteration_credit_bytes;   /* The amount of byte credit that the queue receives every 25us. */
+    Uint32 total_credit_bytes;       /* The total amount of forwarding byte credit that the queue is currently holding */
+    Uint32 max_credit_bytes;         /* The max amount of forwarding byte crerdit that the queue is allowed to hold at the end of the 25US iteration */
+
+    Uint16 iteration_credit_pkts;    /* The amount of packet credit that the queue receives every 25us. */
+    Uint16 total_credit_pkts;        /* The total amount of forwarding pkt credit that the queue is currently holding */
+
+    Uint16 max_credit_pkts;          /* The max amount of forwarding packet crerdit that the queue is allowed to hold at the end of the 25US iteration */
+    Uint16 congst_thrsh_pkts;        /* The size in packets at which point the Qos queue is considered to be congested */
+
+    Uint32 congst_thrsh_bytes;       /* The size in bytes at which point the Qos queue is considered to be congested */
+    Uint32 w7;                       /* Reserved */
+
+}
+PP_QOS_FW_QUEUE_t;
+
+#ifdef __KERNEL__
+/* **************************************************************************************** */
+/*                                                                                          */
+/*                                                                                          */
+/*                                                                                          */
+/*                      KERNEL only Stuff                                                   */
+/*                                                                                          */
+/*                                                                                          */
+/*                                                                                          */
+/* **************************************************************************************** */
+
+
+/************************************************/
+/* QoS manager APIs                             */
+/************************************************/
+/**************/
+/* Common     */
+/**************/
+/**
+ *  pp_qos_mngr_init - Initialized the QoS manager DB
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_mngr_init(void);
+/**
+ *  pp_qos_set_basic_profile - This API should be called while
+ *  QoS profile is created for NI
+ *  basic profile is 1 cluster with 1 egress queue.
+ *  @qos_profile: Pointer to qos profile to set
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_set_basic_profile(PP_QOS_PROFILE_t *qos_profile);
+/**
+ *  pp_qos_is_profile_registered - This API return if the QoS
+ *  profile is alreadu exist int the QoS manager
+ *  @vpid_id: Pointer to qos profile to set
+ *  @profile_private_identifier: identifier for profile
+ *  @isSupported: pointer to return id profile is registered
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_is_profile_registered(Uint8 vpid_id, Uint16 profile_private_identifier, Bool *isRegistered);
+/**
+ *  pp_qos_delete_profile - This API should be called when NI
+ *  need to delete QoS profile
+ *  @vpid_id: Profile's VPID
+ *  @profile_private_identifier: Profile's private identifier
+ *  @profile_stats: To return the profile statistics before the
+ *                profile will deleted.
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_delete_profile(Uint8 vpid_id, Uint16 profile_private_identifier, PP_QOS_MIB_STATS_t *profile_stats);
+/**
+ *  pp_qos_delete_all_profiles - This API should be called while
+ *  NI is going down
+ *  @vpid_id: VPID ID
+ *  @vpid_stats: To return the vpid statistics before the
+ *             profiles will deleted.
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_delete_all_profiles(Uint8 vpid_id, PP_QOS_MIB_STATS_t * vpid_stats);
+/**
+ *  pp_qos_db_get_counters - Get the QoS DB statistics
+ *  @qos_db_stats: Pointer to QoS DB statistics to set
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_db_get_counters(PP_QOS_DB_Counters_t *qos_db_stats);
+/**
+ *  pp_qos_enable_psm - Enter to psm mode
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_enable_psm(void);
+/**
+ *  pp_qos_disable_psm - Exit from psm mode
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_disable_psm(void);
+
+
+/**************/
+/* Cluster    */
+/**************/
+/**
+ *  pp_qos_cluster_is_active - Check if cluster is active
+ *  @phy_cluster_id: Cluster ID
+ *  @is_active: Pointer to return if active or not
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_cluster_is_active(Uint8 phy_cluster_id, Bool *is_active);
+/**
+ *  pp_qos_set_cluster_config - Config QoS cluster
+ *  @phy_cluster_id: Cluster ID
+ *  @vpid_id: VPID ID
+ *  @clst_cfg: Pointer to requested cluster
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_set_cluster_config(Uint8 phy_cluster_id, Uint8 vpid_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
+/**
+ *  pp_qos_alloc_cluster - Alloc/Create QoS cluster
+ *  @vpid_id: VPID ID
+ *  @phy_cluster_id: Pointer to return the cluster ID
+ *  @profile_private_identifier: unique identifier for profile
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_alloc_cluster(Uint8 vpid_id, Uint16 profile_private_identifier, Uint8 *phy_cluster_id);
+/**
+ *  pp_qos_free_cluster - Free/Delete QoS cluster
+ *  @phy_cluster_id: Cluster ID
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_free_cluster(Uint8 phy_cluster_id);
+/**
+ *  pp_qos_get_cluster_config - Get the cluster configuration
+ *  @phy_cluster_id: Cluster ID
+ *  @clst_cfg: Pointer to return the cluster configuration
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_cluster_config(Uint8 phy_cluster_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
+/**
+ *  pp_qos_get_queue_and_cluster_id_by_priority - Get the
+ *  cluster and queue ID for given vpid identifier and Q
+ *  priority.
+ *  @vpid_id: VPID ID
+ *  @profile_private_identifier: Private identifier for profile
+ *  @priority: queue priority - This Uint8 field represent the
+ *           priority of the qos Q, 0 is the lowest priority,
+ *           the max priority is the number of qos queues in the
+ *           cluster.
+ *  @phy_cluster_id: Pointer to return the cluster ID
+ *  @phy_queue_id: Pointer to return the queue ID
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_queue_and_cluster_id_by_priority(Uint8 vpid_id, Uint16 profile_private_identifier, Uint8 priority, Uint8 *phy_cluster_id, Uint8 *phy_queue_id);
+/**
+ *  pp_qos_get_queue_id_by_cluster_and_priority - Get the queue
+ *  ID by given cluster and priority.
+ *  @phy_cluster_id: Cluster ID
+ *  @priority: queue priority - This Uint8 field represent the
+ *           priority of the qos Q, 0 is the lowest priority,
+ *           the max priority is the number of qos queues in the
+ *           cluster.
+ *  @phy_queue_id: Pointer to return the queue ID
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_queue_id_by_cluster_and_priority(Uint8 phy_cluster_id, Uint8 priority, Uint8 *phy_queue_id);
+/**
+ *  pp_qos_get_cluster_by_identifier - Get the cluster
+ *  configuration by given VPID and identifier.
+ *  @profile_private_identifier: Private identifier
+ *  @vpid_id: VPID ID
+ *  @phy_cluster_id: Pointer to return the cluster ID
+ *  @clst_cfg: Pointer to return the cluster configuration
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_cluster_by_identifier(Uint16 profile_private_identifier, Uint8 vpid_id,  Uint8 *phy_cluster_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
+/**
+ *  pp_qos_get_cluster_stats - Get QoS statistics for cluster
+ *  @phy_cluster_id: Cluster ID
+ *  @cluster_stats: Pointer to return the cluster
+ *                statistics
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_cluster_stats(Uint8 phy_cluster_id, PP_QOS_MIB_STATS_t *cluster_stats);
+/**
+ *  pp_qos_get_cluster_by_queue_id - Get the cluster
+ *  configuration by a given queue id
+ *  @phy_queue_id: Queue ID
+ *  @phy_cluster_id: Pointer to return the cluster id
+ *  @clst_cfg: Pointer to return the cluster
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_cluster_by_queue_id(Uint8 phy_queue_id, Uint8 *phy_cluster_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
+/**************/
+/* Queue      */
+/**************/
+/**
+ *  pp_qos_add_queue_to_cluster - Adds queue to cluster
+ *  @phy_cluster_id: Cluster ID
+ *  @user_priority: User priority of the queue
+ *  @queue_cfg: Pointer to AVALANCHE_PP_QOS_QUEUE_t
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_add_queue_to_cluster(Uint8 phy_cluster_id, AVALANCHE_PP_QOS_QUEUE_t *queue_cfg, Uint8 user_priority);
+/**
+ *  pp_qos_del_queue_by_cluster_and_user_prio - Deletes queue
+ *  from cluster
+ *  @phy_cluster_id: Cluster ID
+ *  @user_priority: User priority of the queue
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_del_queue_by_cluster_and_user_prio(Uint8 phy_cluster_id, Uint8 user_priority);
+
+PP_QOS_MGR_RET_e pp_qos_get_queue_and_cluster_id_by_user_priority(Uint8 vpid_id, Uint16 profile_private_identifier, Uint8 user_priority,
+																	      Uint8 *phy_cluster_id, Uint8 *phy_queue_id, Uint8 *pp_priority);
+
+/**
+ *  pp_qos_queue_is_active - Check if queue is active
+ *  @phy_queue_id: Queue ID
+ *  @is_active: Pointer to return if active or not
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_queue_is_active(Uint8 phy_queue_id, Bool *is_active);
+/**
+ *  pp_qos_alloc_queue - Alloc/Create QoS queue
+ *  @phy_cluster_id: Cluster ID
+ *  @phy_queue_id: Pointer to return the queue ID
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_alloc_queue(Uint8 phy_cluster_id, Uint8 *phy_queue_id);
+/**
+ *  pp_qos_free_queue - Free/Delete QoS queue
+ *  @phy_queue_id: Queue ID
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_free_queue(Uint8 phy_queue_id);
+/**
+ *  pp_qos_get_queue_config - Get the queue configuration
+ *  @phy_queue_id: Queue ID
+ *  @queue_cfg: Pointer to return the queue configuration
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_queue_config(Uint8 phy_queue_id, AVALANCHE_PP_QOS_QUEUE_t *queue_cfg);
+/**
+ *  pp_qos_modify_active_queue - Modify properties for an active
+ *  queue
+ *  @q_cfg: Pointer to queue new configuration
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_modify_active_queue(AVALANCHE_PP_QOS_QUEUE_t *modified_q_cfg); /* Modify properties for an active queue. */
+/**
+ *  pp_qos_get_queue_stats - Get QoS queue statistics
+ *  @qos_qnum: Queue ID
+ *  @stats: Pointer to return the queue statistics
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_queue_stats(Uint32 qos_qnum, PP_QOS_MIB_STATS_t *q_stats);
+/**
+ *  pp_qos_inc_session_cnt_for_queue - Increment sessions
+ *  counter for QoS queue
+ *  @phy_queue_id: Queue ID
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_inc_session_cnt_for_queue(Uint8 phy_queue_id);
+/**
+ *  pp_qos_dec_session_cnt_for_queue - Decrement sessions
+ *  counter for QoS queue
+ *  @phy_queue_id: Queue ID
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_dec_session_cnt_for_queue(Uint8 phy_queue_id);
+
+/**************/
+/* VPID       */
+/**************/
+/**
+ *  pp_qos_vpid_is_active - Check if VPID is active (active in the QoS)
+ *  @vpid_id: VPID ID
+ *  @is_active: Pointer to return if active or not
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */ 
+PP_QOS_MGR_RET_e pp_qos_vpid_is_active(Uint8 vpid_id, Bool *is_active);
+/**
+ *  pp_qos_is_vpid_registered - Return True if the given VPID is
+ *  currently supported by the QoS
+ *  @vpid_id: VPID ID
+ *  @isRegistered: Pointer to return if the VPID is active
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_is_vpid_registered(Uint8 vpid_id, Bool *isRegistered);
+/**
+ *  pp_qos_vpid_set_qos_mode - Set the QOS clusters of a VPID to
+ *  do Qos or not
+ *  @vpid_id: VPID ID
+ *  @vpidQosMode: If the requsted mode is QoS/no-QoS
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_vpid_set_qos_mode(Uint8 vpid_id, Bool vpidQosMode);
+/**
+ *  pp_qos_get_vpid_config - Get the vpid clusters configuration
+ *  @phy_cluster_id: Cluster ID
+ *  @clst_cfg_arr: Pointer to array of clusters (in size of
+ *           PP_QOS_MAX_CLUSTERS)
+ *  @clusters_cnt: in -> Pointer to MAX size of clst_cfg array.
+ *                 out -> Pointer to return the number of
+ *               clusters thet filled by the function.
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_vpid_config(Uint8 vpid_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg_arr, Uint8 *clusters_cnt);
+/**
+ *  pp_qos_get_vpid_stats - Get QoS statistics for VPID
+ *  @vpid_id: VPID ID
+ *  @vpid_stats: Pointer to return the vpid statistics
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_vpid_stats(Uint8 vpid_id, PP_QOS_MIB_STATS_t *vpid_stats);
+/**
+ *  pp_qos_get_profile_stats - Get QoS statistics for
+ *  Profile
+ *  @vpid_id: VPID ID
+ *  @profile_private_identifier: Private identifier
+ *  @profile_stats: Pointer to return the profile statistics
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_profile_stats(Uint8 vpid_id, Uint16 profile_private_identifier, PP_QOS_MIB_STATS_t *profile_stats);
+
+#endif /* __KERNEL__ */
+
+#endif /* PP_QOS_P7_H */
--- a/include/linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h
+++ b/include/linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h
@@ -108,14 +108,14 @@ PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q13)                                         /* PAL_CPPI_PP_QMGR_G2_Q45 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q14)                                         /* PAL_CPPI_PP_QMGR_G2_Q46 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q15)                                         /* PAL_CPPI_PP_QMGR_G2_Q47 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC1_PDSP_Q0)                                         /* PAL_CPPI_PP_QMGR_G2_Q48 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC1_PDSP_Q1)                                         /* PAL_CPPI_PP_QMGR_G2_Q49 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC1_PDSP_Q2)                                         /* PAL_CPPI_PP_QMGR_G2_Q50 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC1_PDSP_Q3)                                         /* PAL_CPPI_PP_QMGR_G2_Q51 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC1_PDSP_Q4)                                         /* PAL_CPPI_PP_QMGR_G2_Q52 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC1_PDSP_Q5)                                         /* PAL_CPPI_PP_QMGR_G2_Q53 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC1_PDSP_Q6)                                         /* PAL_CPPI_PP_QMGR_G2_Q54 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC1_PDSP_Q7)                                         /* PAL_CPPI_PP_QMGR_G2_Q55 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ENCRYPT_PP_IN_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q48 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ENCRYPT_HOST_IN_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G2_Q49 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ENCRYPT_CRYPTO_IN_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q50 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ENCRYPT_HOST_OUT_Q_NUM)                               /* PAL_CPPI_PP_QMGR_G2_Q51 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DECRYPT_PP_IN_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q52 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DECRYPT_HOST_IN_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G2_Q53 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DECRYPT_CRYPTO_IN_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q54 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DECRYPT_HOST_OUT_Q_NUM)                               /* PAL_CPPI_PP_QMGR_G2_Q55 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MC_PDSP_Q0)                                           /* PAL_CPPI_PP_QMGR_G2_Q56 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MC_PDSP_Q1)                                           /* PAL_CPPI_PP_QMGR_G2_Q57 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MC_PDSP_Q2)                                           /* PAL_CPPI_PP_QMGR_G2_Q58 */\
@@ -166,14 +166,14 @@ PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SEQUENCER_CYCLE2_MED_LOW_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G2_Q103 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SEQUENCER_CYCLE2_MED_HI_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G2_Q104 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SEQUENCER_CYCLE2_HI_Q_NUM)                            /* PAL_CPPI_PP_QMGR_G2_Q105 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SECURITY_PDSP_Q0)                                     /* PAL_CPPI_PP_QMGR_G2_Q106 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SECURITY_PDSP_Q1)                                     /* PAL_CPPI_PP_QMGR_G2_Q107 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SECURITY_PDSP_Q2)                                     /* PAL_CPPI_PP_QMGR_G2_Q108 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SECURITY_PDSP_Q3)                                     /* PAL_CPPI_PP_QMGR_G2_Q109 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SECURITY_PDSP_Q4)                                     /* PAL_CPPI_PP_QMGR_G2_Q110 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SECURITY_PDSP_Q5)                                     /* PAL_CPPI_PP_QMGR_G2_Q111 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SECURITY_PDSP_Q6)                                     /* PAL_CPPI_PP_QMGR_G2_Q112 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SECURITY_PDSP_Q7)                                     /* PAL_CPPI_PP_QMGR_G2_Q113 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_ENCRYPT_IN_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q106 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_DECRYPT_IN_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q107 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_AES_Q_NUM)                                     /* PAL_CPPI_PP_QMGR_G2_Q108 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_HCU_Q_NUM)                                     /* PAL_CPPI_PP_QMGR_G2_Q109 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_PDSP_Q4)                                       /* PAL_CPPI_PP_QMGR_G2_Q110 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_PDSP_Q5)                                       /* PAL_CPPI_PP_QMGR_G2_Q111 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_PDSP_Q6)                                       /* PAL_CPPI_PP_QMGR_G2_Q112 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_PDSP_Q7)                                       /* PAL_CPPI_PP_QMGR_G2_Q113 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_0_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q114 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_0_LOW_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q115 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_1_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q116 */\
@@ -480,8 +480,8 @@ PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q417)                                                 /* PAL_CPPI_PP_QMGR_G2_Q417 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q418)                                                 /* PAL_CPPI_PP_QMGR_G2_Q418 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q419)                                                 /* PAL_CPPI_PP_QMGR_G2_Q419 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_MONOLITHIC_FD_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q420 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_FORWARDING_FD_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q421 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_IPSEC_MONOLITHIC_FD_Q_NUM)                            /* PAL_CPPI_PP_QMGR_G2_Q420 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_IPSEC_HOST_FD_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q421 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_STREAMING_FD_Q_NUM)                               /* PAL_CPPI_PP_QMGR_G2_Q422 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DOCSIS_LOW_INFRA_HOST_FD_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G2_Q423 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DOCSIS_HI_INFRA_HOST_FD_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G2_Q424 */\
--- a/include/linux/avalanche/puma7/puma7_cppi_prv.h
+++ b/include/linux/avalanche/puma7/puma7_cppi_prv.h
@@ -466,14 +466,14 @@ typedef enum PAL_CPPI_PP_DESC_REGIONs
     PAL_CPPI_PP_DESC_REGION5,                                           // 5
     PAL_CPPI_PP_DESC_REGION6,                                           // 6
     PAL_CPPI_PP_DESC_REGION7,                                           // 7
-    PAL_CPPI_PP_TEARDOWN_GLOBAL_DESC_REGION,                            // 8
+    PAL_CPPI_PP_DESC_REGION8,                                           // 8
+    PAL_CPPI_PP_DESC_REGION9,                                           // 9
+    PAL_CPPI_PP_TEARDOWN_GLOBAL_DESC_REGION,                            // 10
 
     // On-Chip regions...
-    PAL_CPPI_PP_INTERNAL_EMB_GLOBAL_DESC_REGION,                        // 9
-    PAL_CPPI_PP_WIFI_FW_TX_INTERNAL_EMB_DESC_REGION,                    // 10
-    PAL_CPPI_PP_FCC_MONOLITHIC_GLOBAL_DESC_REGION,                      // 11
-    PAL_CPPI_PP_FCC_FORWARDING_GLOBAL_DESC_REGION,                      // 12
-    PAL_CPPI_PP_FCC_STREAMING_GLOBAL_DESC_REGION,                       // 13
+    PAL_CPPI_PP_INTERNAL_EMB_GLOBAL_DESC_REGION,                        // 11
+    PAL_CPPI_PP_WIFI_FW_TX_INTERNAL_EMB_DESC_REGION,                    // 12
+    PAL_CPPI_PP_IPSEC_MONOLITHIC_GLOBAL_DESC_REGION,                    // 13
     PAL_CPPI_PP_US_FW_MONO_DESC_REGION,                                 // 14
     PAL_CPPI_PP_PACKET_RAM_GLOBAL_DESC_REGION,                          // 15
 
@@ -532,29 +532,11 @@ typedef enum PAL_CPPI_PP_DESC_REGIONs
 #define PAL_CPPI_PP_DOCSIS_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            256
 #endif
 
-#ifdef CONFIG_MACH_PUMA7_FPGA
-#define PAL_CPPI_PP_FCC_MONOLITHIC_FD_BASE                                                  (IO_ADDRESS(0xF3E40900))
-#define PAL_CPPI_PP_FCC_MONOLITHIC_FD_DESC_COUNT                                            64
-#define PAL_CPPI_PP_FCC_MONOLITHIC_FD_DESC_SIZE                                             256
-#define PAL_CPPI_PP_FCC_FORWARDING_FD_BASE                                                  (IO_ADDRESS(0xF3E48900))
-#define PAL_CPPI_PP_FCC_FORWARDING_FD_DESC_COUNT                                            64
-#define PAL_CPPI_PP_FCC_FORWARDING_FD_DESC_SIZE                                             64
-#define PAL_CPPI_PP_FCC_STREAMING_FD_BASE                                                   (IO_ADDRESS(0xF3E49900))
-#define PAL_CPPI_PP_FCC_STREAMING_FD_DESC_COUNT                                             64
-#define PAL_CPPI_PP_FCC_STREAMING_FD_DESC_SIZE                                              32
-#define PAL_CPPI_PP_FCC_TX_CH_COUNT                                                         8
-#else
-#define PAL_CPPI_PP_FCC_MONOLITHIC_FD_BASE                                                  (IO_ADDRESS(0xF3E40900))
-#define PAL_CPPI_PP_FCC_MONOLITHIC_FD_DESC_COUNT                                            128
-#define PAL_CPPI_PP_FCC_MONOLITHIC_FD_DESC_SIZE                                             256
-#define PAL_CPPI_PP_FCC_FORWARDING_FD_BASE                                                  (IO_ADDRESS(0xF3E48900))
-#define PAL_CPPI_PP_FCC_FORWARDING_FD_DESC_COUNT                                            64
-#define PAL_CPPI_PP_FCC_FORWARDING_FD_DESC_SIZE                                             64
-#define PAL_CPPI_PP_FCC_STREAMING_FD_BASE                                                   (IO_ADDRESS(0xF3E49900))
-#define PAL_CPPI_PP_FCC_STREAMING_FD_DESC_COUNT                                             256
-#define PAL_CPPI_PP_FCC_STREAMING_FD_DESC_SIZE                                              32
-#define PAL_CPPI_PP_FCC_TX_CH_COUNT                                                         8
-#endif
+#define PAL_CPPI_PP_IPSEC_MONOLITHIC_FD_BASE                                                (IO_ADDRESS(0xF3E40900))
+#define PAL_CPPI_PP_IPSEC_MONOLITHIC_FD_DESC_COUNT                                          16
+#define PAL_CPPI_PP_IPSEC_MONOLITHIC_FD_DESC_SIZE                                           2048
+#define PAL_CPPI_PP_IPSEC_HOST_FD_DESC_COUNT                                                2048
+#define PAL_CPPI_PP_IPSEC_HOST_FD_DESC_SIZE                                                 64
 
 #define PAL_CPPI_PP_US_FW_MONO_FD_BASE                                                      (IO_ADDRESS(0xF3FA0000))
 #define PAL_CPPI_PP_US_FW_MONO_FD_DESC_COUNT                                                64
@@ -1161,17 +1143,17 @@ typedef enum PAL_CPPI_PP_DMA08_RX_WIFI_P
     PAL_CPPI_PP_DMA08_WIFI_DEVICE3_TX_FW_INFRA_RX_CH,
     PAL_CPPI_PP_DMA08_RX_WIFI_PROXY_INFRA_RX_CHANNELS_NUM
 }PAL_CPPI_PP_DMA08_RX_WIFI_PROXY_INFRA_RX_CHANNELS_e;
-// PAL_CPPI_PP_DMA08_INFRA_TX_FCC_TX
+// PAL_CPPI_PP_DMA08_RX_WIFI_PROXY_INFRA_TX_CHANNELS
 typedef enum PAL_CPPI_PP_DMA08_RX_WIFI_PROXY_INFRA_TX_CHANNELS
 {
-    PAL_CPPI_PP_DMA08_FCC_TX_CH_0,
-    PAL_CPPI_PP_DMA08_FCC_TX_CH_1,
-    PAL_CPPI_PP_DMA08_FCC_TX_CH_2,
-    PAL_CPPI_PP_DMA08_FCC_TX_CH_3,
-    PAL_CPPI_PP_DMA08_FCC_TX_CH_4,
-    PAL_CPPI_PP_DMA08_FCC_TX_CH_5,
-    PAL_CPPI_PP_DMA08_FCC_TX_CH_6,
-    PAL_CPPI_PP_DMA08_FCC_TX_CH_7,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_0,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_1,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_2,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_3,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_4,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_5,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_6,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_7,
     PAL_CPPI_PP_DMA08_UNUSED_TX_CH_8,
     PAL_CPPI_PP_DMA08_UNUSED_TX_CH_9,
     PAL_CPPI_PP_DMA08_UNUSED_TX_CH_10,
@@ -1654,8 +1636,8 @@ typedef enum PAL_CPPI_PP_ACCUMULATOR_INT
     PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_3,                                                                        // 3
     PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_4,                                                                        // 4
     PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_5,                                                                        // 5
-    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_6,                                                                        // 6
-    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_7,                                                                        // 7
+    PAL_CPPI_PP_IPSEC_ENCRYPT_INTD1_ACC_CH_NUM,                                                                     // 6
+    PAL_CPPI_PP_IPSEC_DECRYPT_INTD1_ACC_CH_NUM,                                                                     // 7
     PAL_CPPI_PP_NP2APP_RX_INTD1_ACC_CH_NUM,                                                                         // 8
     PAL_CPPI_PP_NP2APP_TX_COMPLETE_INTD1_ACC_CH_NUM,                                                                // 9
     PAL_CPPI_PP_APP2NP_RX_INTD1_ACC_CH_NUM,                                                                         // 10
@@ -1701,8 +1683,8 @@ typedef enum PAL_CPPI_PP_ACCUMULATOR_INT
 {
     PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_0,                                                                      // 0
     PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_1,                                                                      // 1
-    PAL_CPPI_PP_WiFi_RX_LOW_INTD1_ACC_INTV_NUM,                                                                     // 2
-    PAL_CPPI_PP_WiFi_RX_HIGH_INTD1_ACC_INTV_NUM,                                                                    // 3
+    PAL_CPPI_PP_IPSEC_ENCRYPT_INTD1_ACC_INTV_NUM,                                                                     // 2
+    PAL_CPPI_PP_IPSEC_DECRYPT_INTD1_ACC_INTV_NUM,                                                                    // 3
     PAL_CPPI_PP_NP2APP_RX_INTD1_ACC_INTV_NUM,                                                                       // 4
     PAL_CPPI_PP_NP2APP_TX_COMPLETE_INTD1_ACC_INTV_NUM,                                                              // 5
     PAL_CPPI_PP_APP2NP_RX_INTD1_ACC_INTV_NUM,                                                                       // 6
--- a/include/linux/avalanche/puma7/puma7_pp.h
+++ b/include/linux/avalanche/puma7/puma7_pp.h
@@ -345,12 +345,12 @@ typedef enum {
     *mtu_per_vpid = cpu_to_be16(mtuSize);                                    \
 }
 
-#define AVALANCHE_PP_DS_RESEQ_CMD_RGN_BASE         (IO_ADDRESS(0xF3ec0000))
-#define AVALANCHE_PP_DS_RESEQ_PARAM_RGN_BASE       (IO_ADDRESS(0xF3ec0004))
-#define AVALANCHE_PP_DS_RESEQ_IRAM_RGN_BASE        (IO_ADDRESS(0xF3eec000))
-#define AVALANCHE_PP_DS_RESEQ_CTRL_RGN_BASE        (IO_ADDRESS(0xF3eee000))
-#define AVALANCHE_PP_DS_RESEQ_DBG_RGN_BASE         (IO_ADDRESS(0xF3eef000))
-#define AVALANCHE_PP_DS_RESEQ_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xf3c21340))
+#define AVALANCHE_PP_DS_RESEQ_CMD_RGN_BASE              (IO_ADDRESS(0xF3EC0000))
+#define AVALANCHE_PP_DS_RESEQ_PARAM_RGN_BASE            (IO_ADDRESS(0xF3EC0004))
+#define AVALANCHE_PP_DS_RESEQ_IRAM_RGN_BASE             (IO_ADDRESS(0xF3EEC000))
+#define AVALANCHE_PP_DS_RESEQ_CTRL_RGN_BASE             (IO_ADDRESS(0xF3EEE000))
+#define AVALANCHE_PP_DS_RESEQ_DBG_RGN_BASE              (IO_ADDRESS(0xF3EEF000))
+#define AVALANCHE_PP_DS_RESEQ_INTRPT_BNDL_RGN_BASE      (IO_ADDRESS(0xF3C21340)) 
 
 
 #define AVALANCHE_PP_SESSION_CACHE_CMD_RGN_BASE         (IO_ADDRESS(0xF3330000))
@@ -399,7 +399,7 @@ typedef enum {
 #define AVALANCHE_PP_STATISTICAL_FRC_S1_L_BASE          (IO_ADDRESS(0xF36C3FF8))
 #define AVALANCHE_PP_STATISTICAL_FRC_S1_H_BASE          (IO_ADDRESS(0xF36C3FFC))
 
-#define AVALANCHE_PP_IPSEC_CMD_RGN_BASE                 (IO_ADDRESS(0xF3806000))
+#define AVALANCHE_PP_CRYPTO_CMD_RGN_BASE                (IO_ADDRESS(0xF3806000))
 
 #define AVALANCHE_PP_AQM_IRAM_RGN_BASE                  (IO_ADDRESS(0xF3C00000))
 #define AVALANCHE_PP_AQM_DBG_RGN_BASE                   (IO_ADDRESS(0xF3C02000))
@@ -440,16 +440,16 @@ typedef enum {
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_DPI               0x00004000
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_RECYCLER          0x00002000
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_RCE               0x00001000
-#define AVALANCHE_PP_MAILBOX_CLK_CTRL_FCC_0             0x00000800
-#define AVALANCHE_PP_MAILBOX_CLK_CTRL_FCC_1             0x00000400
-#define AVALANCHE_PP_MAILBOX_CLK_CTRL_DS_PDSP2          0x00000200
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_ENCRYPT           0x00000800
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_DECRYPT           0x00000400
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_DS_RESEQ          0x00000200
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_ACCUMULATOR       0x00000100
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_MOCA              0x00000080
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_WIFI_TX           0x00000040
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_WIFI_RX           0x00000020
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_MC                0x00000010
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_SEC_ENGINE        0x00000008
-#define AVALANCHE_PP_MAILBOX_CLK_CTRL_SEC_PDSP          0x00000004
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_CRYPTO_PDSP       0x00000004
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_SEQUENCER         0x00000002
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_AQM               0x00000001
 
@@ -466,30 +466,34 @@ typedef enum {
 #define AVALANCHE_PP_CLASSIFIER_2_1_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C210A0))
 #define AVALANCHE_PP_CLASSIFIER_2_2_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C210C0))
 #define AVALANCHE_PP_CLASSIFIER_2_3_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C210E0))
-#define AVALANCHE_PP_MODIFIER_0_INTRPT_BNDL_RGN_BASE    (IO_ADDRESS(0xF3C21100))
-#define AVALANCHE_PP_MODIFIER_1_INTRPT_BNDL_RGN_BASE    (IO_ADDRESS(0xF3C21120))
-#define AVALANCHE_PP_MODIFIER_2_INTRPT_BNDL_RGN_BASE    (IO_ADDRESS(0xF3C21140))
-#define AVALANCHE_PP_MODIFIER_3_INTRPT_BNDL_RGN_BASE    (IO_ADDRESS(0xF3C21160))
-#define AVALANCHE_PP_PREFETCHER_0_INTRPT_BNDL_RGN_BASE  (IO_ADDRESS(0xF3C21180))
-#define AVALANCHE_PP_PREFETCHER_1_INTRPT_BNDL_RGN_BASE  (IO_ADDRESS(0xF3C211A0))
-#define AVALANCHE_PP_PREFETCHER_2_INTRPT_BNDL_RGN_BASE  (IO_ADDRESS(0xF3C211C0))
-#define AVALANCHE_PP_PREFETCHER_3_INTRPT_BNDL_RGN_BASE  (IO_ADDRESS(0xF3C211E0))
-#define AVALANCHE_PP_SESSION_CACHE_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C21200))
-#define AVALANCHE_PP_TurboDOX_INTRPT_BNDL_RGN_BASE      (IO_ADDRESS(0xF3C21220))
-#define AVALANCHE_PP_RESEQUENCER_INTRPT_BNDL_RGN_BASE   (IO_ADDRESS(0xF3C21240))
-#define AVALANCHE_PP_QOS_0_INTRPT_BNDL_RGN_BASE         (IO_ADDRESS(0xF3C21260))
-#define AVALANCHE_PP_QOS_1_INTRPT_BNDL_RGN_BASE         (IO_ADDRESS(0xF3C21280))
-#define AVALANCHE_PP_RECYCLER_INTRPT_BNDL_RGN_BASE      (IO_ADDRESS(0xF3C212C0))
-#define AVALANCHE_PP_FCC_0_INTRPT_BNDL_RGN_BASE         (IO_ADDRESS(0xF3C21300))
-#define AVALANCHE_PP_FCC_1_INTRPT_BNDL_RGN_BASE         (IO_ADDRESS(0xF3C21320))
-#define AVALANCHE_PP_ACCUMULATOR_INTRPT_BNDL_RGN_BASE   (IO_ADDRESS(0xF3C21360))
-#define AVALANCHE_PP_MOCA_INTRPT_BNDL_RGN_BASE          (IO_ADDRESS(0xF3C21380))
-#define AVALANCHE_PP_WIFI_TX_INTRPT_BNDL_RGN_BASE       (IO_ADDRESS(0xF3C213A0))
-#define AVALANCHE_PP_WIFI_RX_INTRPT_BNDL_RGN_BASE       (IO_ADDRESS(0xF3C213C0))
-#define AVALANCHE_PP_MC_INTRPT_BNDL_RGN_BASE            (IO_ADDRESS(0xF3C21400))
-#define AVALANCHE_PP_SEQUENCER_INTRPT_BNDL_RGN_BASE     (IO_ADDRESS(0xF3C21420))
-#define AVALANCHE_PP_AQM_INTRPT_BNDL_RGN_BASE           (IO_ADDRESS(0xF3C21440))
-#define AVALANCHE_PP_HOST_INTRPT_0_BNDL_RGN_BASE        (IO_ADDRESS(0xF3C21800))
+#define AVALANCHE_PP_MODIFIER_0_INTRPT_BNDL_RGN_BASE     (IO_ADDRESS(0xF3C21100))
+#define AVALANCHE_PP_MODIFIER_1_INTRPT_BNDL_RGN_BASE     (IO_ADDRESS(0xF3C21120))
+#define AVALANCHE_PP_MODIFIER_2_INTRPT_BNDL_RGN_BASE     (IO_ADDRESS(0xF3C21140))
+#define AVALANCHE_PP_MODIFIER_3_INTRPT_BNDL_RGN_BASE     (IO_ADDRESS(0xF3C21160))
+#define AVALANCHE_PP_PREFETCHER_0_INTRPT_BNDL_RGN_BASE   (IO_ADDRESS(0xF3C21180))
+#define AVALANCHE_PP_PREFETCHER_1_INTRPT_BNDL_RGN_BASE   (IO_ADDRESS(0xF3C211A0))
+#define AVALANCHE_PP_PREFETCHER_2_INTRPT_BNDL_RGN_BASE   (IO_ADDRESS(0xF3C211C0))
+#define AVALANCHE_PP_PREFETCHER_3_INTRPT_BNDL_RGN_BASE   (IO_ADDRESS(0xF3C211E0))
+#define AVALANCHE_PP_SESSION_CACHE_INTRPT_BNDL_RGN_BASE  (IO_ADDRESS(0xF3C21200))
+#define AVALANCHE_PP_TurboDOX_INTRPT_BNDL_RGN_BASE       (IO_ADDRESS(0xF3C21220))
+#define AVALANCHE_PP_RESEQUENCER_INTRPT_BNDL_RGN_BASE    (IO_ADDRESS(0xF3C21240))
+#define AVALANCHE_PP_QOS_0_INTRPT_BNDL_RGN_BASE          (IO_ADDRESS(0xF3C21260))
+#define AVALANCHE_PP_QOS_1_INTRPT_BNDL_RGN_BASE          (IO_ADDRESS(0xF3C21280))
+#define AVALANCHE_PP_DPI_INTRPT_BNDL_RGN_BASE            (IO_ADDRESS(0xF3C212A0))
+#define AVALANCHE_PP_RECYCLER_INTRPT_BNDL_RGN_BASE       (IO_ADDRESS(0xF3C212C0))
+#define AVALANCHE_PP_RCE_INTRPT_BNDL_RGN_BASE            (IO_ADDRESS(0xF3C212E0))
+#define AVALANCHE_PP_ENCRYPT_INTRPT_BNDL_RGN_BASE        (IO_ADDRESS(0xF3C21300))
+#define AVALANCHE_PP_DECRYPT_INTRPT_BNDL_RGN_BASE        (IO_ADDRESS(0xF3C21320))
+#define AVALANCHE_PP_ACCUMULATOR_INTRPT_BNDL_RGN_BASE    (IO_ADDRESS(0xF3C21360))
+#define AVALANCHE_PP_MOCA_INTRPT_BNDL_RGN_BASE           (IO_ADDRESS(0xF3C21380))
+#define AVALANCHE_PP_WIFI_TX_INTRPT_BNDL_RGN_BASE        (IO_ADDRESS(0xF3C213A0))
+#define AVALANCHE_PP_WIFI_RX_INTRPT_BNDL_RGN_BASE        (IO_ADDRESS(0xF3C213C0))
+#define AVALANCHE_PP_MC_INTRPT_BNDL_RGN_BASE             (IO_ADDRESS(0xF3C21400))
+#define AVALANCHE_PP_SEQUENCER_INTRPT_BNDL_RGN_BASE      (IO_ADDRESS(0xF3C21420))
+#define AVALANCHE_PP_AQM_INTRPT_BNDL_RGN_BASE            (IO_ADDRESS(0xF3C21440))
+#define AVALANCHE_PP_CRYPTO_INTRPT_BNDL_RGN_BASE         (IO_ADDRESS(0xF3C21460))
+#define AVALANCHE_PP_HOST_INTRPT_0_BNDL_RGN_BASE         (IO_ADDRESS(0xF3C21800))
+
 #define AVALANCHE_PP_HOST_INTRPT_0_BNDL_PP_EVENT        0x00000002
 // Following are in PP region but are actually used by DS FW Reseqencer PDSP
 #define AVALANCHE_DS_FW_RESEQ_INTRPT_0_BNDL_RGN_BASE    0xF3C21820
@@ -520,16 +524,16 @@ typedef enum {
 #define AVALANCHE_PP_ACCUMULATOR_DBG_RGN_BASE           (IO_ADDRESS(0xF3E32000))
 #define AVALANCHE_PP_ACCUMULATOR_CTRL_RGN_BASE          (IO_ADDRESS(0xF3E33000))
 
-#define AVALANCHE_PP_FCC_0_CMD_RGN_BASE                 (IO_ADDRESS(0xF3E40000))
-#define AVALANCHE_PP_FCC_1_CMD_RGN_BASE                 (IO_ADDRESS(0xF3E40000))
-#define AVALANCHE_PP_FCC_0_PARAM_RGN_BASE               (IO_ADDRESS(0xF3E40004))
-#define AVALANCHE_PP_FCC_1_PARAM_RGN_BASE               (IO_ADDRESS(0xF3E40004))
-#define AVALANCHE_PP_FCC_0_IRAM_RGN_BASE                (IO_ADDRESS(0xF3E60000))
-#define AVALANCHE_PP_FCC_0_DBG_RGN_BASE                 (IO_ADDRESS(0xF3E61000))
-#define AVALANCHE_PP_FCC_0_CTRL_RGN_BASE                (IO_ADDRESS(0xF3E62000))
-#define AVALANCHE_PP_FCC_1_IRAM_RGN_BASE                (IO_ADDRESS(0xF3E63000))
-#define AVALANCHE_PP_FCC_1_DBG_RGN_BASE                 (IO_ADDRESS(0xF3E64000))
-#define AVALANCHE_PP_FCC_1_CTRL_RGN_BASE                (IO_ADDRESS(0xF3E65000))
+#define AVALANCHE_PP_ENCRYPT_CMD_RGN_BASE                 (IO_ADDRESS(0xF3E40000))
+#define AVALANCHE_PP_DECRYPT_CMD_RGN_BASE                 (IO_ADDRESS(0xF3E40100))
+#define AVALANCHE_PP_ENCRYPT_PARAM_RGN_BASE               (IO_ADDRESS(0xF3E40004))
+#define AVALANCHE_PP_DECRYPT_PARAM_RGN_BASE               (IO_ADDRESS(0xF3E40104))
+#define AVALANCHE_PP_ENCRYPT_IRAM_RGN_BASE                (IO_ADDRESS(0xF3E60000))
+#define AVALANCHE_PP_ENCRYPT_DBG_RGN_BASE                 (IO_ADDRESS(0xF3E61000))
+#define AVALANCHE_PP_ENCRYPT_CTRL_RGN_BASE                (IO_ADDRESS(0xF3E62000))
+#define AVALANCHE_PP_DECRYPT_IRAM_RGN_BASE                (IO_ADDRESS(0xF3E63000))
+#define AVALANCHE_PP_DECRYPT_DBG_RGN_BASE                 (IO_ADDRESS(0xF3E64000))
+#define AVALANCHE_PP_DECRYPT_CTRL_RGN_BASE                (IO_ADDRESS(0xF3E65000))
 
 #define AVALANCHE_PP_MOCA_IRAM_RGN_BASE                 (IO_ADDRESS(0xF3EA0000))
 #define AVALANCHE_PP_MOCA_DBG_RGN_BASE                  (IO_ADDRESS(0xF3EA2000))
@@ -558,6 +562,22 @@ typedef enum {
 }
 
 #define AVALANCHE_PP_DPI_CMD_RGN_BASE                   (IO_ADDRESS(0xF3F40000))
+#define AVALANCHE_PP_DPI_PARAM_RGN_BASE                 (IO_ADDRESS(0xF3F40004))
+#define AVALANCHE_PP_DPI_IRAM_RGN_BASE                  (IO_ADDRESS(0xF3F50000))
+#define AVALANCHE_PP_DPI_DBG_RGN_BASE                   (IO_ADDRESS(0xF3F52000))
+#define AVALANCHE_PP_DPI_CTRL_RGN_BASE                  (IO_ADDRESS(0xF3F53000))
+
+#define AVALANCHE_PP_CRYPTO_CMD_RGN_BASE                (IO_ADDRESS(0xF3806000))
+#define AVALANCHE_PP_CRYPTO_PARAM_RGN_BASE              (IO_ADDRESS(0xF3806004))
+#define AVALANCHE_PP_CRYPTO_IRAM_RGN_BASE               (IO_ADDRESS(0xF3800000))
+#define AVALANCHE_PP_CRYPTO_DBG_RGN_BASE                (IO_ADDRESS(0xF3802000))
+#define AVALANCHE_PP_CRYPTO_CTRL_RGN_BASE               (IO_ADDRESS(0xF3803000))
+
+#define AVALANCHE_PP_RCE_CMD_RGN_BASE                   (IO_ADDRESS(0xF3E80000))
+#define AVALANCHE_PP_RCE_PARAM_RGN_BASE                 (IO_ADDRESS(0xF3E80004))
+#define AVALANCHE_PP_RCE_IRAM_RGN_BASE                  (IO_ADDRESS(0xF3E90000))
+#define AVALANCHE_PP_RCE_DBG_RGN_BASE                   (IO_ADDRESS(0xF3E94000))
+#define AVALANCHE_PP_RCE_CTRL_RGN_BASE                  (IO_ADDRESS(0xF3E98000))
 
 #define AVALANCHE_PP_WIFI_TX_CMD_RGN_BASE               (IO_ADDRESS(0xF3F60000))
 #define AVALANCHE_PP_WIFI_TX_PARAM_RGN_BASE             (IO_ADDRESS(0xF3F60004))
