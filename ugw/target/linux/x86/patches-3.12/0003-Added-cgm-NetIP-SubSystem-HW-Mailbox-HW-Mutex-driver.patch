From a5a402850b7226fb3bdabc911a4b141fe782d726 Mon Sep 17 00:00:00 2001
From: Emmanuel Jillela <emmanuel.jillela@intel.com>
Date: Fri, 6 Feb 2015 17:30:40 -0700
Subject: [PATCH 003/441] Added cgm NetIP SubSystem HW Mailbox HW Mutex
 drivers.

---
 arch/x86/Kconfig                               |   65 ++
 arch/x86/Makefile                              |    3 +
 arch/x86/NetIP_SubSystem/Makefile              |   20 +
 arch/x86/NetIP_SubSystem/netip_subsystem_lld.c |  260 +++++
 arch/x86/hw_mailbox/Makefile                   |   43 +
 arch/x86/hw_mailbox/hw_mbox_defs.h             |  522 ++++++++++
 arch/x86/hw_mailbox/hw_mbox_drv.c              | 1267 ++++++++++++++++++++++++
 arch/x86/hw_mailbox/hw_mbox_mem_access.h       | 1248 +++++++++++++++++++++++
 arch/x86/hw_mutex/Makefile                     |   20 +
 arch/x86/hw_mutex/hw_mutex_lld.c               |  436 ++++++++
 arch/x86/hw_mutex/hw_mutex_lld.h               |   63 ++
 arch/x86/hw_mutex/puma6_hw_mutex_lld.h         |  116 +++
 arch/x86/hw_mutex/puma7_hw_mutex_lld.h         |  120 +++
 include/linux/hw_mutex.h                       |  197 ++++
 include/linux/netip_subsystem.h                |   39 +
 kernel/Makefile                                |    2 +
 kernel/hwmutex.c                               |  330 ++++++
 kernel/hwmutex.h                               |   65 ++
 18 files changed, 4816 insertions(+)
 create mode 100755 arch/x86/NetIP_SubSystem/Makefile
 create mode 100755 arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
 create mode 100644 arch/x86/hw_mailbox/Makefile
 create mode 100644 arch/x86/hw_mailbox/hw_mbox_defs.h
 create mode 100644 arch/x86/hw_mailbox/hw_mbox_drv.c
 create mode 100644 arch/x86/hw_mailbox/hw_mbox_mem_access.h
 create mode 100755 arch/x86/hw_mutex/Makefile
 create mode 100755 arch/x86/hw_mutex/hw_mutex_lld.c
 create mode 100755 arch/x86/hw_mutex/hw_mutex_lld.h
 create mode 100644 arch/x86/hw_mutex/puma6_hw_mutex_lld.h
 create mode 100644 arch/x86/hw_mutex/puma7_hw_mutex_lld.h
 create mode 100755 include/linux/hw_mutex.h
 create mode 100644 include/linux/netip_subsystem.h
 create mode 100755 kernel/hwmutex.c
 create mode 100755 kernel/hwmutex.h

--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -441,6 +441,71 @@ config X86_INTEL_CE
 	  This option compiles in support for the CE4100 SOC for settop
 	  boxes and media devices.
 
+menu "Intel Media SOC Gen3 support"
+
+config ARCH_GEN3
+        bool "Enable Intel Media SOC Gen3 support"
+        default y
+
+endmenu
+
+config NET_SUBSYSTEM
+	bool "Net IP controller support for Intel CE2600 platform"
+        depends on ARCH_GEN3
+	default y
+	---help---
+	  This is the NET-IP subsystem support for Intel CE2600 platform.
+
+config HW_MUTEXES
+        tristate "MUTEX controller support for Intel CE2600 platform"
+        depends on ARCH_GEN3 && NET_SUBSYSTEM
+        default y
+	---help---
+	This is the MUTEX controller support for Intel CE2600 platform.
+	If unsure, say Y.
+choice
+	depends on HW_MUTEXES
+	prompt "MUTEX controller support for Intel CE2600 platform"
+	default MUTEX_FIFO
+	help
+	Allows the configuration of the MUTEX controller working mode in Intel CE platform
+
+config MUTEX_FIFO
+	bool "FIFO scheduler"
+	help
+	Mutex works in FIFO scheduler mode, which is the default behaviour
+
+config  MUTEX_NULL
+	bool "Null scheduler"
+	help
+	Mutex works in Null scheduler mode
+
+config MUTEX_POLLING
+	bool "Polling mode"
+	help
+	works in polling mode, interrupt is disabled
+endchoice
+
+choice 
+	depends on HW_MUTEXES
+	prompt "MUTEX controller configuration"
+	default X86_PUMA7
+
+config X86_PUMA6
+	bool "Puma6 Mutex controller"
+	
+config X86_PUMA7
+	bool "Puma7 Mutex controller"
+endchoice
+
+config HW_MAILBOX
+        tristate "HW Mailbox support for Intel CE2600 platform"
+        depends on ARCH_GEN3 && NET_SUBSYSTEM
+        default y
+	---help---
+	This is the HW Mailbox support for Intel CE2600 platform.
+	If unsure, say Y.
+
 config X86_WANT_INTEL_MID
 	bool "Intel MID platform support"
 	depends on X86_32
--- a/arch/x86/Makefile
+++ b/arch/x86/Makefile
@@ -177,6 +177,9 @@ core-y += arch/x86/
 # drivers-y are linked after core-y
 drivers-$(CONFIG_MATH_EMULATION) += arch/x86/math-emu/
 drivers-$(CONFIG_PCI)            += arch/x86/pci/
+drivers-$(CONFIG_NET_SUBSYSTEM)  += arch/x86/NetIP_SubSystem/
+drivers-$(CONFIG_HW_MUTEXES)     += arch/x86/hw_mutex/
+drivers-$(CONFIG_HW_MAILBOX)     += arch/x86/hw_mailbox/
 
 # must be linked after kernel/
 drivers-$(CONFIG_OPROFILE) += arch/x86/oprofile/
--- /dev/null
+++ b/arch/x86/NetIP_SubSystem/Makefile
@@ -0,0 +1,20 @@
+#
+# Copyright (c) 2011, Intel Corporation and its suppliers.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc., 
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#
+
+ccflags-y += -DPUMA7_PRE_SILICON 
+obj-$(CONFIG_NET_SUBSYSTEM) := netip_subsystem_lld.o
--- /dev/null
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
@@ -0,0 +1,260 @@
+/*
+ * net_ss_lld.c
+ *
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2014 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ */
+ 
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/netip_subsystem.h>
+
+/* Time out if we cannot get a MUTEX within half minute */
+#define NET_SUBSYSTEM_IRQ_NAME "netip_subsystem_irq"
+
+static const struct pci_device_id net_subsystem_pci_tbl[] = {
+        { PCI_DEVICE( 0x8086, NET_SUBSYTEM_DEV_ID), .driver_data = 0 },
+        {0},
+};
+MODULE_DEVICE_TABLE(pci, net_subsystem_pci_tbl);
+
+typedef struct net_ip_mmios {
+   unsigned long region1_base;
+   unsigned long region1_size;
+   unsigned long region2_base;
+   unsigned long region2_size;
+}net_ip_mmios_t;
+
+net_ip_mmios_t net_ip_mmios;
+
+struct net_subsystem_drv_data *pnetss_drv_data;
+
+void netss_subdev_register_irq(netss_subdevices_t subdevice, netss_subdev_irq_info_t *irq_info)
+{
+    pnetss_drv_data->irqs[subdevice].func = irq_info->func;
+    pnetss_drv_data->irqs[subdevice].args = irq_info->args;
+}
+
+EXPORT_SYMBOL(netss_subdev_register_irq);
+
+bool netss_driver_ready(void)
+{
+   if(pnetss_drv_data != NULL) {
+      return pnetss_drv_data->netss_driver_initialized;
+   } else {
+     return false;
+   }
+}
+
+EXPORT_SYMBOL(netss_driver_ready);
+
+int netss_get_subdevice_mmio_info(netss_subdevices_t subdevice, netss_subdevice_mmio_t *mmio)
+{
+   int ret = -1;
+   switch (subdevice)
+   {
+      case NETSS_HW_MUTEX:
+          mmio->base = NETSS_SUBDEV_HWMUTEX_MMIO_BASE;
+          mmio->size = NETSS_SUBDEV_HWMUTEX_MMIO_SIZE;
+          ret = 0;
+      break;
+      case NETSS_HW_MAILBOX:
+          mmio->base = NETSS_SUBDEV_HWMBX_MMIO_BASE;
+          mmio->size = NETSS_SUBDEV_HWMBX_MMIO_SIZE;
+          ret = 0;
+      break;
+      default:
+         ret = -1;
+   }
+   return ret;  
+}
+
+EXPORT_SYMBOL(netss_get_subdevice_mmio_info);
+
+/*
+ * Interrupt Handler
+ */
+static irqreturn_t net_subsystem_isr(int irq, void *dev_id)
+{
+   struct net_subsystem_drv_data *pnet_ss = (struct net_subsystem_drv_data *)dev_id;
+   irqreturn_t ret = IRQ_NONE;
+   int i;
+   uint32_t volatile reg_val = 0;
+   
+   reg_val = __raw_readl(pnet_ss->bridge_reg_base + 0x60);
+   if((reg_val & 0xFFFF) == 0) {
+      if(pnet_ss->irqs[NETSS_HW_MUTEX].func != NULL) {
+          pnet_ss->irqs[NETSS_HW_MUTEX].func(irq, pnet_ss->irqs[NETSS_HW_MUTEX].args);
+      }
+   } else if ((reg_val & 0xFFFF) == 1) {
+      if(pnet_ss->irqs[NETSS_HW_MAILBOX].func != NULL) {
+          ((*pnet_ss->irqs[NETSS_HW_MAILBOX].func))(irq, pnet_ss->irqs[NETSS_HW_MAILBOX].args);
+      }
+   } else {
+      printk("Unknown interrupt ignoring %x\n", reg_val);
+   }
+   
+  
+   ret = IRQ_HANDLED;
+   /* clear interrupt status */
+   return ret;
+}
+
+/* 
+ * driver entry point
+ */
+static int netss_probe(struct pci_dev *pdev,
+                       const struct pci_device_id *id)
+{
+   int ret = -ENODEV;
+   int i;
+   //DEBUG_PRINT;
+ 
+   ret = pci_enable_device(pdev);
+   if (ret) {
+      dev_err(&pdev->dev, "pci_enable_device failed.\n");
+      return ret;
+   }
+   ret = pci_enable_msi(pdev);
+   if (ret) {
+      if(-EINVAL == ret) {
+         dev_err(&pdev->dev, "pci_enable_msi returned invalid param. %x", (unsigned int) ret);
+      }
+      dev_err(&pdev->dev, "pci_enable_msi failed. %x", (unsigned int) ret);
+      pci_disable_device(pdev);
+      return ret;
+   }
+
+   net_ip_mmios.region1_base = pci_resource_start(pdev,0);
+   net_ip_mmios.region1_size = pci_resource_len(pdev,0);
+#ifdef PUMA7_PRE_SILICON
+   net_ip_mmios.region2_base = pci_resource_start(pdev,1);
+   net_ip_mmios.region2_size = pci_resource_len(pdev,1);
+#else
+   net_ip_mmios.region2_base = pci_resource_start(pdev,2);
+   net_ip_mmios.region2_size = pci_resource_len(pdev,2);
+#endif
+   printk(KERN_INFO "1: mem_iobase = 0x%x, mem_iosize = 0x%x\n",(unsigned int)net_ip_mmios.region1_base,(unsigned int)net_ip_mmios.region1_size);
+   printk(KERN_INFO "2: mem_iobase = 0x%x, mem_iosize = 0x%x\n",(unsigned int)net_ip_mmios.region2_base,(unsigned int)net_ip_mmios.region2_size);
+   
+   if (pci_request_regions(pdev, "net-subsytem")){
+      dev_err(&pdev->dev, "Cannot obtain PCI resources\n");
+      ret = -EBUSY;
+      goto free_dev;
+   }
+
+   pnetss_drv_data = kzalloc(sizeof(struct net_subsystem_drv_data), GFP_KERNEL);
+   if (!pnetss_drv_data){
+      dev_err(&pdev->dev, "Cannot allocate memory\n");
+      ret = -ENOMEM;
+      goto free_resource;
+   }
+
+   pnetss_drv_data->bridge_reg_base = (void __iomem *)ioremap_nocache(net_ip_mmios.region2_base,net_ip_mmios.region2_size);
+   if (!pnetss_drv_data->bridge_reg_base) {
+      dev_err( &pdev->dev, "error, failed to ioremap mutex registers\n");
+      ret = -ENOMEM;
+      goto free_mem;
+   }
+
+   pnetss_drv_data->irq_num = pdev->irq;
+   pnetss_drv_data->dev = pdev;
+   
+   if (request_irq(pnetss_drv_data->irq_num, net_subsystem_isr, 0, NET_SUBSYSTEM_IRQ_NAME, (void *)pnetss_drv_data)){
+      printk(KERN_ERR "HW Mutex: Unable to allocate IRQ\n");
+      ret = -ENODEV;
+      goto free_iomem;
+   }
+
+   for(i=0; i<NETSS_SUBDEVICE_MAX;i++)
+   {
+      pnetss_drv_data->irqs[i].func = NULL;
+      pnetss_drv_data->irqs[i].args = NULL;
+   }
+
+   pci_set_drvdata(pnetss_drv_data->dev,pnetss_drv_data);
+   pnetss_drv_data->netss_driver_initialized = true;
+   printk(KERN_INFO "Intel(R) NET SUBSYSTEM driver built on %s @ %s\n", __DATE__, __TIME__);
+   return 0;
+
+free_iomem:
+   iounmap(pnetss_drv_data->bridge_reg_base);
+free_mem:
+   kfree(pnetss_drv_data);
+free_resource:
+   pci_release_regions(pdev);
+free_dev:
+   //pci_disable_msi(pdev); 
+   pci_disable_device(pdev);
+
+   return ret;
+}
+/* 
+ * driver exit point 
+ */
+static void netss_remove(struct pci_dev *pdev)
+{
+   struct net_subsystem_drv_data *pnetss_drv_data = pci_get_drvdata(pdev);
+   if (!pnetss_drv_data)
+      return;
+   kfree(pnetss_drv_data);
+   pci_release_regions(pdev);
+   //pci_disable_msi(pnetss_drv_data->dev); 
+   pci_disable_device(pdev);
+   //DEBUG_PRINT;
+   printk(KERN_INFO "NET SubSytem driver: device exit \n");
+ 
+   return;
+}
+
+static struct pci_driver netss_driver = {
+   .name           = "ce-net-subsystem",
+   .id_table       = net_subsystem_pci_tbl,
+   .probe          = netss_probe,
+   .remove      = netss_remove,
+};
+
+static int __init net_subsystem_lld_init (void)
+{
+   return pci_register_driver(&netss_driver);
+}
+static void __exit net_subsystem_lld_exit(void)
+{
+   pci_unregister_driver(&netss_driver);
+}
+
+subsys_initcall(net_subsystem_lld_init);
+module_exit(net_subsystem_lld_exit);
+
+MODULE_DESCRIPTION("Intel(R) NET SUBSYSTEM Driver");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL");
+
+
+
--- /dev/null
+++ b/arch/x86/hw_mailbox/Makefile
@@ -0,0 +1,43 @@
+# File: arch\arm\mach-avalanche\puma7\hw_mbox_drv/Makefile
+#
+# Makefile for the kernel HW_MBOX driver.
+#
+#
+#
+#
+#  GPL LICENSE SUMMARY
+#
+#  Copyright(c) 2014 Intel Corporation. All rights reserved.
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of version 2 of the GNU General Public License as
+#  published by the Free Software Foundation.
+#
+#  This program is distributed in the hope that it will be useful, but
+#  WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#  General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program; if not, write to the Free Software
+#  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#  The full GNU General Public License is included in this distribution
+#  in the file called LICENSE.GPL.
+#
+#  Contact Information:
+#    Intel Corporation
+#    2200 Mission College Blvd.
+#    Santa Clara, CA  97052
+#
+#
+
+
+#EXTRA_CFLAGS += -Iinclude/linux
+#EXTRA_CFLAGS += -Iinclude/asm-arm/arch-avalanche/generic
+#EXTRA_CFLAGS += -Iinclude/asm-arm/arch-avalanche/puma7
+#EXTRA_CFLAGS += -Iinclude/asm-arm/arch-avalanche/puma7/hw_mbox_drv
+
+EXTRA_CFLAGS += -Werror
+
+# for building object
+obj-$(CONFIG_HW_MAILBOX) := hw_mbox_drv.o
--- /dev/null
+++ b/arch/x86/hw_mailbox/hw_mbox_defs.h
@@ -0,0 +1,522 @@
+/*
+ *
+ * hw_mbox_defs.h
+ * Description:
+ * contains basic definitions puma7 HW_MBOX controller SW.
+ *
+ 
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE 
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#ifndef _HW_MBOX_DEFS_H_
+#define _HW_MBOX_DEFS_H_
+
+/******************************************
+|                                         |
+|        HW_MBOX Basic Definitions        |
+|                                         |
+******************************************/
+
+/*! \def HW_MBOX_MASTER_COUNT 
+    \brief Count of HW_MBOX Masters. */
+#define HW_MBOX_MASTER_COUNT     16
+
+/*! \def HW_MBOX_CHANNEL_COUNT 
+    \brief Count of HW_MBOX Channel. */
+#define HW_MBOX_CHANNEL_COUNT    64
+
+#define HW_MBOX_CID_INVALID    0xFFFFFFFF
+
+/*! \def HW_MBOX_MID_VALIDITY_CHECK(paramMID) 
+    \brief evaluates as True if paramMID is a valid MID. */
+#define HW_MBOX_MID_VALIDITY_CHECK(paramMID)    (((paramMID) >= 0) && ((paramMID) < HW_MBOX_MASTER_COUNT))
+
+/*! \def HW_MBOX_CID_VALIDITY_CHECK(paramCID) 
+    \brief evaluates as True if paramCID is a valid CID. */
+#define HW_MBOX_CID_VALIDITY_CHECK(paramCID)    (((paramCID) >= 0) && ((paramCID) < HW_MBOX_CHANNEL_COUNT))
+
+/* HW_MBOX_MASTER_MID defines: */
+/* Note: should be kept in sync with HW_MBOX_IS_MASTER defines and with HW_MBOX_MASTER_TABLE */
+#define HW_MBOX_NP_CPU_MID          0  /*! MID of NP_CPU        */
+#define HW_MBOX_BBU_C_MID           1  /*! MID of BBU_C         */
+#define HW_MBOX_APP_CPU_MID         2  /*! MID of APP_CPU       */
+#define HW_MBOX_RCE_MID             3  /*! MID of RCE           */
+#define HW_MBOX_US_MAC_CPU_MID      4  /*! MID of US_MAC_CPU    */
+#define HW_MBOX_DS_PHY_CPU_MID      5  /*! MID of DS_PHY_CPU    */
+#define HW_MBOX_MOCA_C_MID          6  /*! MID of MOCA_C        */
+#define HW_MBOX_DS_MAC_C_MID        7  /*! MID of DS_MAC_C      */
+#define HW_MBOX_PP_NETSEC_MID       8  /*! MID of PP_NETSEC     */
+#define HW_MBOX_PP_RESEQ_MID        9  /*! MID of PP_RESEQ      */
+#define HW_MBOX_PP_STAGE1_MID      10  /*! MID of PP_STAGE1     */
+#define HW_MBOX_PP_QOS_MID         11  /*! MID of PP_QOS        */
+#define HW_MBOX_C55_MID            12  /*! MID of C55           */
+#define HW_MBOX_FREE0_MID          13  /*! MID of FREE0         */
+#define HW_MBOX_SEC_MID            14  /*! MID of SEC           */
+#define HW_MBOX_CSE_MID            15  /*! MID of CSE           */
+
+/*! \var typedef enum hw_mbox_type hw_mbox_type_e
+    \brief This enum denotes types of mboxs (protocols) that are supported. */
+typedef enum hw_mbox_type
+{
+    hw_mbox_command = 0,  /* Command */
+    hw_mbox_event,        /* Event   */
+} hw_mbox_type_e;
+
+/*! \def HW_MBOX_TYPE_STR(mboxType)
+    \brief gets a string according to <mboxType>
+    \attention <mboxType> should be a value from hw_mbox_type_e 
+*/
+#define HW_MBOX_TYPE_STR(mboxType)    ((mboxType == hw_mbox_event)?("Event"):("Command"))
+
+#define HW_MBOX_DEFAULT_TIMEOUT_SEC    10  /* 10 sec */
+
+/* Error Notification: */
+
+/* supervisor gets notified of access violation errors through a HW_MBOX interrupt.
+   To signal that there's an access violation error a Certain predetermined CID is
+   selected. This CID should not be allocaed to supervisor as a channel. */
+
+/*! \def HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR
+    \brief This CID gets signaled upon HW access violation errors.
+    \attention should only be used by supervisor.
+*/
+#define HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR    63
+
+/* Some General Macros we will use throughout the Code: */
+
+#define HW_MBOX_CONCAT2(a, b)          a ## b
+#define HW_MBOX_CONCAT3(a, b, c)       a ## b ## c
+
+#define HW_MBOX_STRINGIFY(x)    #x
+
+/**********************************************
+|                                             |
+|        HW_MBOX Package Configuration        |
+|                                             |
+**********************************************/
+
+/*! \def HW_MBOX_MONITOR    <MID_of_Monitor>
+    \brief MID of the Master to act as Monitor.
+    \attention use a value from HW_MBOX_MASTER_MID defines.
+    \note Feature is OPTIONAL, comment out define to disable.
+    \note Monitor gets an interrupt upon every HW_MBOX interrupt of any channel and should log the commands.
+    \note There's no lock on the command register value, this Monitoring feature is best effort only!
+*/
+//#define HW_MBOX_MONITOR    HW_MBOX_NP_CPU_MID
+
+/** --------------------------------------- **/
+
+/*! \def HW_MBOX_START_IN_HW_DEBUG_MODE
+    \brief Start HW_MBOX in HW Debug Mode.
+    \attention In HW Debug Mode access protection rules are not enforced and every Master access is permitted.
+    \note Feature is OPTIONAL, comment out define to disable.
+*/
+//#define HW_MBOX_START_IN_HW_DEBUG_MODE
+
+/** --------------------------------------- **/
+
+/*! \def __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO    <MID_of_new_Supervisor>
+    \brief MID of the Master to act as supervisor (instead of default one). 
+    \warning ONLY USE IF YOU ABSOULTLY KNOW WHAT YOU ARE DOING!!!
+    \attention use a value from HW_MBOX_MASTER_MID defines.
+    \note Feature is OPTIONAL, comment out define to disable.
+    \note This will change the default supervisor's MID (MID == 0) to the new value indicated here.
+    \note There has to be a special way to change it since only the supervisor can access the ctrl Register.
+*/
+//#define __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO    HW_MBOX_NP_CPU_MID
+
+/** --------------------------------------- **/
+
+/*! \def HW_MBOX_DEBUG
+    \brief Enable this flag for various debug operations of the HW_MBOX package. 
+    \note Feature is OPTIONAL, comment out define to disable.
+    \note Debug Features:
+    \note 1. Free access to the HW_MBOX registers and Memory via CLI.
+    \note 2. MID Disguise: enable the current Master to access the HW_MBOX "disguised" as a different Master.
+*/
+//#define HW_MBOX_DEBUG
+
+/******************************************************
+|                                                     |
+|        HW_MBOX Specific Master Configuration        |
+|                                                     |
+******************************************************/
+
+/*! \def HW_MBOX_MID    <MID_of_this_Master>
+    \brief MID of this Master, current Master, the one running this code. 
+    \attention use a value from HW_MBOX_MASTER_MID defines.
+    \note It is derived from which physical HW_MBOX interrupt line is connected to this Master.
+    \note Values for all Master are enumerated by hw_mbox_Masters_e, just pick the correct one.
+*/
+#define HW_MBOX_MID    HW_MBOX_APP_CPU_MID
+
+/*! \def HW_MBOX_OS_LINUX\HW_MBOX_OS_FLAT\HW_MBOX_OS_NONE
+    \brief Set one appropriate define according to Variant (OS). 
+    \attention Enable Exactly one of these!
+    \note HW_MBOX_OS_LINUX: U-services.
+    \note HW_MBOX_OS_FLAT:  F-services. 
+    \note HW_MBOX_OS_NONE:  N-services. 
+*/
+#define HW_MBOX_OS_LINUX     /* U-services */
+//#define HW_MBOX_OS_FLAT    /* F-services */
+//#define HW_MBOX_OS_NONE    /* N-services */
+
+/* Variant Selection Check: */
+#if ((defined(HW_MBOX_OS_LINUX) + defined(HW_MBOX_OS_FLAT) + defined(HW_MBOX_OS_NONE)) != 1)
+#   error "HW_MBOX defs: Enable ONE OS Variant exactly!"
+#endif
+
+/*! \var HW_MBOX_HARDCODED_MID
+    \brief Remember the HARDCODED MID of this Master.
+    \attention This is needed as under debug "MID Disguise Feature" undefs HW_MBOX_MID and redefines it as a dynamic field.
+    \note using enum to qualify as CONST.
+*/
+enum { HW_MBOX_HARDCODED_MID = HW_MBOX_MID };
+
+/* HW_MBOX_IS_MASTER defines (useful for #ifdef-ing include for instance): */
+/* Note: These should be kept in sync with HW_MBOX_MASTER_MID defines and with HW_MBOX_MASTER_TABLE  */
+#if (HW_MBOX_MID == HW_MBOX_NP_CPU_MID)
+#define HW_MBOX_IS_NP_CPU               /*! defined if current HW_MBOX Master is NP_CPU     */
+#elif (HW_MBOX_MID == HW_MBOX_BBU_C_MID)
+#define HW_MBOX_IS_BBU_C                /*! defined if current HW_MBOX Master is BBU_C      */
+#elif (HW_MBOX_MID == HW_MBOX_APP_CPU_MID)
+#define HW_MBOX_IS_APP_CPU              /*! defined if current HW_MBOX Master is APP_CPU    */
+#elif (HW_MBOX_MID == HW_MBOX_RCE_MID)
+#define HW_MBOX_IS_RCE                  /*! defined if current HW_MBOX Master is RCE        */
+#elif (HW_MBOX_MID == HW_MBOX_US_MAC_CPU_MID)
+#define HW_MBOX_IS_US_MAC_CPU           /*! defined if current HW_MBOX Master is US_MAC_CPU */
+#elif (HW_MBOX_MID == HW_MBOX_DS_PHY_CPU_MID)
+#define HW_MBOX_IS_DS_PHY_CPU           /*! defined if current HW_MBOX Master is DS_PHY_CPU */
+#elif (HW_MBOX_MID == HW_MBOX_MOCA_C_MID)
+#define HW_MBOX_IS_MOCA_C               /*! defined if current HW_MBOX Master is MOCA_C     */
+#endif
+
+/* Generic Primitive typedefs: */
+
+/* need typedefs of Uint32, Uint8 and Bool(True/False). */
+#if   defined HW_MBOX_IS_NP_CPU
+#include "_tistdtypes.h"
+#elif defined HW_MBOX_IS_APP_CPU
+typedef uint32_t Uint32;
+typedef uint8_t  Uint8;
+typedef bool     Bool;
+#define True true
+#define False false
+#include <linux/types.h> /* include file with generic typedefs for APP-CPU */
+#elif defined HW_MBOX_IS_DS_PHY_CPU
+#include "types.h"
+#endif
+
+/********************************************
+|                                           |
+|        HW_MBOX Master Declarations        |
+|                                           |
+********************************************/
+
+/*! \var typedef enum hw_mbox_support hw_mbox_support_e
+    \brief This enum denotes which SW support exists on each Master. */
+typedef enum hw_mbox_support
+{
+    hw_mbox_support_none = 0, /* No SW support on this Master */
+    hw_mbox_support_static,   /* only supports static channel allocation */
+    hw_mbox_support_dynamic   /* supports static and dynamic channel allocation */
+} hw_mbox_support_e;
+
+/*! \def HW_MBOX_SUPPORT_STR(mboxSupport)
+    \brief gets a string according to <mboxSupport>
+    \attention <mboxSupport> should be a value from hw_mbox_support_e 
+*/
+#define HW_MBOX_SUPPORT_STR(mboxSupport)    ( (mboxSupport == hw_mbox_support_dynamic)?("Dynamic"): \
+                                              ((mboxSupport == hw_mbox_support_static)?("Static"):("None")) )
+
+/*! \var typedefstruct hw_mbox_masterConfig hw_mbox_masterConfig_t
+    \brief Master configuration struct. */
+typedef struct hw_mbox_masterConfig
+{
+    hw_mbox_support_e   support;
+} hw_mbox_masterConfig_t;
+
+/*! \def HW_MBOX_MASTER_CONFIG_SIZE 
+    \brief Master configuration struct's size. */
+#define HW_MBOX_MASTER_CONFIG_SIZE    (sizeof(hw_mbox_masterConfig_t))
+
+/*! \def HW_MBOX_MASTER_TABLE(ENTRY)
+    \brief X-MACRO hardcoded table for HW_MBOX Master declarations.
+    \brief Position in the Table determines MID (Master ID) of the Master, a unique identifier
+           dictated by Hardware (HW_MBOX Interrupt Line Number which connects to the Master).
+    \attention Should be kept in sync with HW_MBOX_MASTER_MID defines and with HW_MBOX_IS_MASTER defines.
+    \note NP_CPU is generic name for ARM11.
+    \note APP_CPU is generic name for ATOM.
+    \note US_MAC_CPU is generic name for Upstream MAC CPU ARM9.
+    \note Interrupt line 13 is not physically connected, reserved for possible SW internal usage.
+*/
+#define HW_MBOX_MASTER_TABLE(ENTRY) \
+/* +------------------------------------------------------------+ */ \
+/* | MID |         | Name /        | HW_MBOX SW support         | */ \
+/* |     |         | Description   | [hw_mbox_support_e]        | */ \
+/* +------------------------------------------------------------+ */ \
+/* |  0  | */ ENTRY( NP_CPU        , hw_mbox_support_static     )    \
+/* |  1  | */ ENTRY( BBU_C         , hw_mbox_support_static     )    \
+/* |  2  | */ ENTRY( APP_CPU       , hw_mbox_support_static     )    \
+/* |  3  | */ ENTRY( RCE           , hw_mbox_support_none       )    \
+/* |  4  | */ ENTRY( US_MAC_CPU    , hw_mbox_support_none       )    \
+/* |  5  | */ ENTRY( DS_PHY_CPU    , hw_mbox_support_static     )    \
+/* |  6  | */ ENTRY( MOCA_C        , hw_mbox_support_static     )    \
+/* |  7  | */ ENTRY( DS_MAC_C      , hw_mbox_support_none       )    \
+/* |  8  | */ ENTRY( PP_NETSEC     , hw_mbox_support_none       )    \
+/* |  9  | */ ENTRY( PP_RESEQ      , hw_mbox_support_none       )    \
+/* | 10  | */ ENTRY( PP_STAGE1     , hw_mbox_support_none       )    \
+/* | 11  | */ ENTRY( PP_QOS        , hw_mbox_support_none       )    \
+/* | 12  | */ ENTRY( C55           , hw_mbox_support_none       )    \
+/* | 13  | */ ENTRY( FREE0         , hw_mbox_support_none       )    \
+/* | 14  | */ ENTRY( SEC           , hw_mbox_support_none       )    \
+/* | 15  | */ ENTRY( CSE           , hw_mbox_support_none       )
+
+/* Master Table Expanders: */
+
+/*! \def HW_MBOX_MASTER_TABLE_AS_ENUM( _desc, _support )
+    \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as enum.
+    \note Masters will be enumerated according to this template: HW_MBOX_MASTER_<_desc> 
+*/
+#define HW_MBOX_MASTER_TABLE_AS_ENUM( _desc, _support )      HW_MBOX_CONCAT2(HW_MBOX_MASTER_, _desc),
+
+/*! \def HW_MBOX_MASTER_TABLE_AS_STRS( _desc, _support )
+    \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as strings.
+    \note Strings are created according to this template: "<_desc>" 
+*/
+#define HW_MBOX_MASTER_TABLE_AS_STRS( _desc, _support )      HW_MBOX_STRINGIFY(_desc),
+
+/*! \def HW_MBOX_MASTER_TABLE_AS_COUNT( _desc, _support )
+    \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as entry count. */
+#define HW_MBOX_MASTER_TABLE_AS_COUNT( _desc, _support )     1+ 
+
+/*! \def HW_MBOX_MASTER_TABLE_AS_DB( _desc, _support )
+    \brief use this as argument to HW_MBOX_MASTER_TABLE to expand table as DB.
+    \note intializes an array of hw_mbox_masterConfig_t.
+    \attention only create inside c file.
+*/
+#define HW_MBOX_MASTER_TABLE_AS_DB( _desc, _support )    { .support = _support },
+
+/* Master Table Expander Wrappers: */
+
+/*! \def HW_MBOX_MASTER_TABLE_STRS
+    \brief wrapper for HW_MBOX_MASTER_TABLE_AS_STRS.
+    \note "<_desc0>", "<_desc1>", ... [so we need] '\0' for array syntax and proper array null termination.
+    \note intializes a char* array.
+    \attention only create inside c file.
+*/
+#define HW_MBOX_MASTER_TABLE_STRS    HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_STRS) '\0'
+
+/*! \def HW_MBOX_MASTER_TABLE_COUNT
+    \brief wrapper for HW_MBOX_MASTER_TABLE_AS_COUNT.
+    \note 1+ 1+ ... [so we need] 0 for syntax.
+*/
+#define HW_MBOX_MASTER_TABLE_COUNT    (HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_COUNT) 0)
+
+/* Basic Sanity Check for Master Table: */
+#if (HW_MBOX_MASTER_COUNT != (HW_MBOX_MASTER_TABLE_COUNT))
+#   error "HW_MBOX MASTER TABLE: entry count in the table must equal the total Master Count!"
+#endif
+
+/*! \var typedef enum hw_mbox_Masters hw_mbox_Masters_e 
+    \brief Enumerate all HW_MBOX Master with MID value.
+    \note name of the Masters is according to HW_MBOX_MASTER_TABLE_AS_ENUM Macro.
+*/
+typedef enum hw_mbox_Masters
+{
+    HW_MBOX_MID_INVALID = -1,
+    HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_ENUM)
+    HW_MBOX_MASTER_LAST_ENTRY
+} hw_mbox_Masters_e;
+
+/**********************************************
+|                                             |
+|        Variant Specific Declarations        |
+|                                             |
+**********************************************/
+
+#ifdef HW_MBOX_OS_LINUX
+/* Defines related to Kernel Driver: */
+
+/*! \def HW_MBOX_DRV_DEV_DIR_NAME
+    \brief directory under /dev containing the chnint char devices. */
+#define HW_MBOX_DRV_DEV_DIR_NAME    "hw_mbox_drv"
+
+/*! \def HW_MBOX_CHNINT_DEV_NAME
+    \brief Prefix name of the chnint char devices, these devices are used to extend interrupt signals from Kernel to User Space.
+    \note for channel XX the device is chnintXX [e.g. channel 8 -> chnint08].
+    \note devices located in directory /dev/<HW_MBOX_DRV_DEV_DIR_NAME> 
+*/
+#define HW_MBOX_CHNINT_DEV_NAME    "chnint"
+
+/** --------------------------------------- **/
+
+/*! \def HW_MBOX_RECENT_COMMAND_LOG    <Command_Count>
+    \brief How many recent commands should be save.
+    \attention use a value > 0.
+    \note Feature is OPTIONAL, comment out define to disable.
+    \note Monitor Thread is in-charge of updating the Log.
+*/
+//#define HW_MBOX_RECENT_COMMAND_LOG    16
+
+#ifdef HW_MBOX_RECENT_COMMAND_LOG
+/* Argument Sanity Check: */
+#if (HW_MBOX_RECENT_COMMAND_LOG <= 0)
+#   error "HW_MBOX RECENT COMMAND LOG: Command Count Must be > 0!" 
+#endif
+
+/*! \def HW_MBOX_RECENT_COMMAND_LOG_ARRAY_ENTRY_COUNT
+    \brief How many entries we should have in the array.
+    \note (+2) Total addition to guarantee we always have an amount of <HW_MBOX_RECENT_COMMAND_LOG> valid entries:
+    \note (+1) entry for NULL termination.
+    \note (+1) entry as one is invalidated in the update process.
+    \note This guarantee obviously applies only after at least <HW_MBOX_RECENT_COMMAND_LOG> commands were actually logged (one buffer fill up).
+*/
+#define HW_MBOX_RECENT_COMMAND_LOG_ARRAY_ENTRY_COUNT    ((HW_MBOX_RECENT_COMMAND_LOG) + 1 + 1)
+#endif // HW_MBOX_RECENT_COMMAND_LOG
+#endif // HW_MBOX_OS_LINUX
+
+/********************************************
+|                                           |
+|        HW_MBOX Channel Definitions        |
+|                                           |
+********************************************/
+
+/*! \var typedef struct hw_mbox_sram hw_mbox_sram_t
+    \brief struct for Channel's SRAM configuration. */
+typedef struct hw_mbox_sram
+{
+    Uint32 start; /* start Offset aligned and relvant to the 4KB of HW_MBOX SRAM */
+    Uint32 size;  /* size is in bytes */
+} hw_mbox_sram_t;
+
+#define HW_MBOX_SRAM_CHUNK    4  /*! Allocated SRAM size must be an integral Multiple of 4B */
+
+/*! \var typedef struct hw_mbox_channelConfig hw_mbox_channelConfig_t
+    \brief struct for Channel's configuration. */
+typedef struct hw_mbox_channelConfig
+{
+    Uint32              cid;
+    hw_mbox_type_e      mboxType;
+    hw_mbox_Masters_e   commander;
+    hw_mbox_Masters_e   subject;
+    hw_mbox_sram_t      memBuff;
+} hw_mbox_channelConfig_t;
+
+/*! \def HW_MBOX_CHANNEL_CONFIG_SIZE 
+    \brief channel configuration struct's size. */
+#define HW_MBOX_CHANNEL_CONFIG_SIZE    sizeof(hw_mbox_channelConfig_t)
+
+/********************************************
+|                                           |
+|        STATIC channel Declarations        |
+|                                           |
+********************************************/
+
+/*! \def HW_MBOX_STATIC_CHANNEL_TABLE
+    \brief X-MACRO hardcoded table for STATIC Channel declarations.
+    \attention SRAM size must be an integral Multiple of HW_MBOX_SRAM_CHUNK = 4B.
+    \attention An event channel must have SRAM allocated to accomdate the event buffer.
+    \attention An event channel SRAM size must be divisible to 2 equal sized valid individual SRAM buffers [for the double buffer] --> meaning it should be an integral multiple of 2 * HW_MBOX_SRAM_CHUNK = 8B.
+*/
+#define HW_MBOX_STATIC_CHANNEL_TABLE(ENTRY) \
+/*       +--------------------------------------------------------------------------------------------------------------------------+ */ \
+/*       |  CID  | Commander                           | Subject                             | HW_MBOX Channel Type     | SRAM size | */ \
+/*       |       | [hw_mbox_Masters_e]                 | [hw_mbox_Masters_e]                 | [hw_mbox_channel_type_e] | [Bytes]   | */ \
+/*       +--------------------------------------------------------------------------------------------------------------------------+ */ \
+    ENTRY(    0  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_command          , 0         )    \
+    ENTRY(    1  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_DS_PHY_CPU           , hw_mbox_command          , 0         )    \
+    ENTRY(    2  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_command          , 0         )    \
+    ENTRY(    3  , HW_MBOX_MASTER_BBU_C                , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
+    ENTRY(    4  , HW_MBOX_MASTER_DS_PHY_CPU           , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
+    ENTRY(    5  , HW_MBOX_MASTER_MOCA_C               , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
+    ENTRY(    6  , HW_MBOX_MASTER_APP_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_command          , 0         )    \
+    ENTRY(    7  , HW_MBOX_MASTER_APP_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )
+
+/* static channel Table Expanders: */
+
+/*! \def HW_MBOX_STATIC_CHANNEL_TABLE_AS_COUNT( _cid, _commander, _subject, _mboxType, _sramSize )
+    \brief use this as argument to HW_MBOX_STATIC_CHANNEL_TABLE to expand table as entry count. */
+#define HW_MBOX_STATIC_CHANNEL_TABLE_AS_COUNT( _cid, _commander, _subject, _mboxType, _sramSize )    1+
+
+/*! \def HW_MBOX_STATIC_CHANNEL_TABLE_AS_DB(_cid, _commander, _subject, _mboxType, _sramSize)
+    \brief use this as argument to HW_MBOX_STATIC_CHANNEL_TABLE to expand table as DB.
+    \note intializes an array of hw_mbox_channelConfig_t.
+    \attention only create inside c file.
+*/
+#define HW_MBOX_STATIC_CHANNEL_TABLE_AS_DB(_cid, _commander, _subject, _mboxType, _sramSize) \
+{ .cid = _cid, .mboxType = _mboxType, .commander = _commander, .subject = _subject, .memBuff.start = 0 /* To be updated when SRAM is allocated */, .memBuff.size = _sramSize },
+
+/* static channel Table Expander Wrappers: */
+
+/*! \def HW_MBOX_STATIC_CHANNEL_COUNT
+    \brief wrapper for HW_MBOX_STATIC_CHANNEL_TABLE_AS_COUNT.
+    \note 1+ 1+ ... [so we need] 0 for syntax.
+*/
+#define HW_MBOX_STATIC_CHANNEL_COUNT    (HW_MBOX_STATIC_CHANNEL_TABLE(HW_MBOX_STATIC_CHANNEL_TABLE_AS_COUNT) 0) /* 1+ ... 1+ [need] 0 for syntax */
+
+/* Basic Sanity Check for static channel Table */
+#if ((HW_MBOX_STATIC_CHANNEL_COUNT) > HW_MBOX_CHANNEL_COUNT)
+#   error "HW_MBOX STATIC CHANNELS: entry count in the table exceeds the total Channel Count!"
+#endif
+
+#endif // !_HW_MBOX_DEFS_H_
--- /dev/null
+++ b/arch/x86/hw_mailbox/hw_mbox_drv.c
@@ -0,0 +1,1267 @@
+/*
+ *
+ * hw_mbox_drv.c
+ * Description:
+ * Kernel implementation for HW_MBOX driver.
+ *
+ *
+ * GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2014 Intel Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify 
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but 
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ *  General Public License for more details.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License 
+ *  along with this program; if not, write to the Free Software 
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution 
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *  Intel Corporation
+ *  2200 Mission College Blvd.
+ *  Santa Clara, CA  97052
+ */
+
+#define DRV_NAME    "Intel(R) HW Mailbox Controller Driver"
+#define DRV_VERSION "0.0.1"
+
+/************************************************************************/
+/*     INCLUDES                                                         */
+/************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/device.h>
+#include <linux/cdev.h>     /* cdev utilities */
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/kern_levels.h>
+
+#include <linux/netip_subsystem.h>
+#include "hw_mbox_defs.h"        /* HW_MBOX definitions and configuration */
+#include "hw_mbox_mem_access.h"  /* HW_MBOX Register and Memory Access    */
+
+#ifdef HW_MBOX_IS_NP_CPU
+#include "puma7.h"       /* for irq number */
+#endif
+#ifdef HW_MBOX_IS_APP_CPU
+/* Include file with irq number */ 
+#endif
+
+/************************************************************************/
+/*     Defines and Macros                                               */
+/************************************************************************/
+
+//#define HW_MBOX_KDBG /*! Use this define to toggle HW_MBOX kernel debug prints */
+#ifdef HW_MBOX_KDBG
+/* note: prints Module header and '\n' is included inside */
+#  define DPRINTK(fmt, args...) printk("HW_MBOX_KDBG: " fmt "\n" , ## args)
+#else
+#  define DPRINTK(fmt, args...)
+#endif
+
+#define PRINTK_INFO(fmt, args...) printk(KERN_INFO "HW_MBOX_KERNEL_INFO: " fmt "\n" , ## args)
+#define PRINTK_ERR(fmt, args...)  printk(KERN_ERR  "HW_MBOX_KERNEL_ERROR(%s:%d): " fmt "\n" , __FUNCTION__, __LINE__, ## args)
+
+/* General Macros: */
+
+#ifndef BIT
+#define BIT(i)  (1UL << (i))
+#endif
+
+/*! YESNO_STR(logicalTerm): return "YES" if (logicalTerm evaluates as True) else return "NO" */
+#define YESNO_STR(logicalTerm)    ((logicalTerm)?("YES"):("NO"))
+
+#ifndef CONCAT2
+#define CONCAT2(a, b)   a ## b
+#endif
+
+/* HW_MBOX driver Macros and Defines:  */
+
+/*! \def HW_MBOX_INT_LINE
+    \brief irq number of the HW_MBOX. */
+#define HW_MBOX_INT_LINE    AVALANCHE_HW_MBOX_INT
+
+/*! \def HW_MBOX_INT_NAME
+    \brief irq name of the HW_MBOX. */
+#define HW_MBOX_INT_NAME    "hw_mbox_irq"
+
+/*! \def HW_MBOX_ERROR_BIT_POS_SUPERVISOR
+    \brief bit position in Interrupt Status H that signals of HW_MBOX access violation Error!
+    \attention this is only true for the supervisor!
+*/
+#define HW_MBOX_ERROR_BIT_POS_SUPERVISOR    ((HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR) % 32)
+
+/*! \def HW_MBOX_ERROR_BIT_FOR_SUPERVISOR
+    \brief single set bit value in Interrupt Status H that signals of HW_MBOX access violation Error!
+    \attention This is only true for the supervisor!
+*/
+#define HW_MBOX_ERROR_BIT_FOR_SUPERVISOR    BIT(HW_MBOX_ERROR_BIT_POS_SUPERVISOR)
+
+/*! \def HW_MBOX_IS_ERROR_BIT_SET_FOR_SUPERVISOR(interruptStatus_H)
+    \brief use this as supervisor to find out whether error bit is set on interrupt status high register value.
+    \param[in] interruptStatus_H - HW_MBOX_MASTER_INTR_STATUS_H register value that was read.
+    \attention Only use as supervisor! 
+*/
+#define HW_MBOX_IS_ERROR_BIT_SET_FOR_SUPERVISOR(interruptStatus_H)      (((interruptStatus_H) & HW_MBOX_ERROR_BIT_FOR_SUPERVISOR) != 0)
+
+/************************************************************************/
+/*     HW_MBOX Package configuration data arrays:                       */
+/************************************************************************/
+
+/* List HW_MBOX Master names (using the Master Table X-MACRO): */
+
+/*! \var static const char *HW_MBOX_MASTER_STRS[] 
+    \brief List all HW_MBOX Master names listed by MID: "<_desc>"
+    \attention use HW_MBOX_MASTER_GET_NAME() to access.
+*/
+static const char *HW_MBOX_MASTER_STRS[] = { HW_MBOX_MASTER_TABLE_STRS };
+
+/*! \def HW_MBOX_MASTER_GET_NAME(paramMID)
+    \brief Get Name of HW_MBOX Master by MID. */
+#define HW_MBOX_MASTER_GET_NAME(paramMID)    HW_MBOX_MASTER_STRS[paramMID]
+
+/* List HW_MBOX Master configurations (using the Master Table X-MACRO): */
+
+/*! \var static const hw_mbox_masterConfig_t HW_MBOX_MASTER_CONFIG[]
+    \brief List all Masters configurations in an Array enabling access.
+    \note index in the array is the MID.
+    \attention use HW_MBOX_MASTER_GET_CONFIG() to access.
+*/
+static const hw_mbox_masterConfig_t HW_MBOX_MASTER_CONFIG[HW_MBOX_MASTER_COUNT] = { HW_MBOX_MASTER_TABLE(HW_MBOX_MASTER_TABLE_AS_DB) };
+
+/*! \def HW_MBOX_MASTER_GET_CONFIG(paramMID)
+    \brief Gets a Master's configuration.
+    \note returns a hw_mbox_masterConfig_t struct.
+*/
+#define HW_MBOX_MASTER_GET_CONFIG(paramMID)    HW_MBOX_MASTER_CONFIG[paramMID]
+
+/* List HW_MBOX static channel configurations (using the Static Channel Table X-MACRO): */
+
+/*! \var static const hw_mbox_channelConfig_t HW_MBOX_STATIC_CHANNEL_CONFIG[]
+    \brief List all static Channel configurations in an Array enabling access.
+    \note index in the array is NOT the CID.
+    \attention use HW_MBOX_STATIC_CHANNEL_GET_CONFIG() to access.
+*/
+static const hw_mbox_channelConfig_t HW_MBOX_STATIC_CHANNEL_CONFIG[HW_MBOX_STATIC_CHANNEL_COUNT] = { HW_MBOX_STATIC_CHANNEL_TABLE(HW_MBOX_STATIC_CHANNEL_TABLE_AS_DB) };
+
+/*! \def HW_MBOX_STATIC_CHANNEL_GET_CONFIG(staticChannelIndex)
+    \brief Gets a static Channel's configuration.
+    \note returns a hw_mbox_channelConfig_t struct.
+*/
+#define HW_MBOX_STATIC_CHANNEL_GET_CONFIG(staticChannelIndex)    HW_MBOX_STATIC_CHANNEL_CONFIG[staticChannelIndex]
+
+/************************************************************************/
+/*     HW_MBOX Channel Interrupt Devices:                               */
+/************************************************************************/
+
+/*  Channel interrupt Devices Defines and Structures: */
+
+/*! \var typedef struct chnint chnint_t
+    \brief Channel Interrupt Device structure. */
+typedef struct chnint 
+{
+    Uint32              chn_cid;           /* CID of the channel this device is reporting about */
+    Uint32              interruptPending;  /* if CHN_INT_PENDING then there's an interrupt on channel CID else CHN_INT_NONE */
+    wait_queue_head_t   chnint_rqueue;     /* unsatisfied read from device sleeps on it */
+    struct cdev         chnint_cdev;       /* channel's char device structure */
+} chnint_t;
+
+#define CHN_INT_NONE       0  /* use with interruptPending field of the chnint devices, this value means that there's no interrupt on the device */
+#define CHN_INT_PENDING    1  /* use with interruptPending field of the chnint devices, this value means that there is an interrupt on the device */
+
+/*! \var static dev_t chnint_dev
+    \brief The first channel interrupt device that will be created, Contains major and first minor number.
+    \note This is the reference point for allocation of all other devices and the chrdev region. */
+static dev_t chnint_dev;
+
+/* Channel interrupt Devices Function Declarations: */
+
+#if defined HW_MBOX_IS_NP_CPU
+/* File Operations: */
+static int chnint_open(struct inode *inode, struct file *filp);
+static ssize_t chnint_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
+static unsigned int chnint_poll(struct file *filp, struct poll_table_struct *wait);
+static int chnint_release(struct inode *inode, struct file *filp);
+#endif
+
+static void chnint_cleanup(int count);
+
+/* Channel interrupt Devices Local Variables: */
+
+
+#if defined HW_MBOX_IS_NP_CPU
+/*! \var static struct class *chnint_class
+    \brief Channel interrupt devices class. */
+static struct class *chnint_class;
+#endif
+
+/*! \var static chnint_t *chnint_devices
+    \brief Array of all the channel interrupt Device structures, one entry per channel.
+    \note Index in the array is the CID of the device. */
+static chnint_t *chnint_devices;    /* one char device per channel */    
+
+#if defined HW_MBOX_IS_NP_CPU
+/*! \var static struct file_operations chnint_fops
+    \brief file operations structure for the channel interrupt devices. */
+static struct file_operations chnint_fops = {
+    .owner      = THIS_MODULE,
+    .read       = chnint_read,
+    .poll       = chnint_poll,
+    .open       = chnint_open,
+    .release    = chnint_release,
+};
+
+/* Channel interrupt Devices Functions Definations: */
+
+/* File Operations: */
+
+static int chnint_open(struct inode *inode, struct file *filp)
+{
+    chnint_t *dev;
+    dev = container_of(inode->i_cdev, chnint_t, chnint_cdev);
+    DPRINTK("chnint_open dev %p, chn_cid %d", dev, dev->chn_cid);
+    DPRINTK("filp=%p", filp);
+    filp->private_data = dev;   /* store for future use */
+    return 0;
+}
+
+static ssize_t chnint_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+    chnint_t *dev = filp->private_data; /* dev was stored in filp during open */
+
+    DPRINTK("chnint_read dev %p, chn_cid %d, interruptPending=%d", dev, dev->chn_cid, dev->interruptPending);
+    DPRINTK("filp=%p, count=%u, *f_pos=%lld", filp, count, (long long)*f_pos);
+
+    if (wait_event_interruptible(dev->chnint_rqueue, dev->interruptPending != CHN_INT_NONE))
+    {
+        return -EINTR;
+    }
+
+    if (copy_to_user(buf, &dev->interruptPending, sizeof(dev->interruptPending)))
+    {
+        return -EFAULT;
+    }
+
+    dev->interruptPending = CHN_INT_NONE;
+    *f_pos += sizeof(dev->interruptPending);
+    return sizeof(dev->interruptPending);
+}
+
+static unsigned int chnint_poll(struct file *filp, struct poll_table_struct *wait)
+{
+    chnint_t *dev = filp->private_data; /* dev was stored in filp during open */
+    unsigned int mask = 0;
+    DPRINTK("chnint_poll dev %p, chn_cid %d: poll Check interruptPending=%d", dev, dev->chn_cid, dev->interruptPending);
+    DPRINTK("filp=%p", filp);
+    poll_wait(filp, &dev->chnint_rqueue, wait);
+    if (dev->interruptPending != CHN_INT_NONE)
+    {
+        DPRINTK("chnint_poll dev %p, chn_cid %d waked up", dev, dev->chn_cid);
+        mask |= POLLIN | POLLRDNORM; /* readable */
+    }
+    DPRINTK("chnint_poll dev %p, chn_cid %d: mask=0x%08x", dev, dev->chn_cid, mask);
+    return mask;
+}
+
+static int chnint_release(struct inode *inode, struct file *filp)
+{
+#ifdef HW_MBOX_KDBG
+    chnint_t *dev;
+    dev = container_of(inode->i_cdev, chnint_t, chnint_cdev);
+#endif
+    DPRINTK("chnint_release: dev %p, chn_cid %d", dev, dev->chn_cid);
+    return 0;
+}
+#endif
+
+/*! \fn static void chnint_cleanup(int count) 
+    \brief use to clean up the Channel Interrupt devices.
+    \param[in] count - amount of devices to clean up. 
+    \note also clears the chrdev region. 
+*/
+static void chnint_cleanup(int count)
+{
+    int i;
+    DPRINTK("cleanup function, count=%d", count);
+    if (chnint_devices)
+    {
+        for (i = 0; i < count; i++)
+        {
+            cdev_del(&chnint_devices[i].chnint_cdev);
+        }
+        kfree(chnint_devices);
+    }
+    unregister_chrdev_region(chnint_dev, HW_MBOX_CHANNEL_COUNT);
+}
+
+
+/************************************************************************/
+/*     HW_MBOX driver data                                              */
+/************************************************************************/
+
+/*! \var typedef struct hw_mbox_drv_data hw_mbox_drv_data_t 
+    \brief struct for HW_MBOX driver Local Data. */
+typedef struct hw_mbox_drv_data
+{
+    /* Core (Hardware) version: */
+    Uint32 coreVerMajor; 
+    Uint32 coreVerMinor;
+
+    /* Control Data: */
+    Bool isSupervisor; /* If True then this Master is the supervisor of the HW_MBOX */
+    Bool isMonitor;    /* If True then this Master is the Monitor of the HW_MBOX */
+
+    Bool masterValid[HW_MBOX_MASTER_COUNT];    /* index is MID, if True then Master has SW support and is not fused out */
+    Uint32 chnIntr[HW_MBOX_CHANNEL_COUNT];     /* index is CID, incremented upon interrupt */
+    Uint32 errIntr;                            /* incremented only for supervisor */
+    Uint32 ghostIntr;                          /* incremented if there's an interrupt but no set bits in Interrupt Status Registers */
+    void __iomem *reg_base;                    /* Mapped io reg base address */
+    struct mutex chnLock[HW_MBOX_CHANNEL_COUNT];
+} hw_mbox_drv_data_t;
+
+/*! \def HW_MBOX_DRIVER_DATA_SIZE 
+    \brief HW_MBOX driver Data struct's size. */
+#define HW_MBOX_DRIVER_DATA_SIZE    sizeof(hw_mbox_drv_data_t)
+
+/*! \var static hw_mbox_drv_data_t hwMboxDriverData
+    \brief HW_MBOX driver Local Data. */
+static hw_mbox_drv_data_t hwMboxDriverData;
+
+/* Access Driver Data Macros: */
+
+#define RESET_DRIVER_DATA()                     memset(&hwMboxDriverData, 0, HW_MBOX_DRIVER_DATA_SIZE)
+
+#define SET_CORE_VER_MAJ(value)                 (hwMboxDriverData.coreVerMajor = value)
+#define SET_CORE_VER_MIN(value)                 (hwMboxDriverData.coreVerMinor = value)
+#define GET_CORE_VER_MAJ()                      (hwMboxDriverData.coreVerMajor)
+#define GET_CORE_VER_MIN()                      (hwMboxDriverData.coreVerMinor)
+
+#define SET_IS_SUPERVISOR()                     (hwMboxDriverData.isSupervisor = True) /* Use to set an indication that current Master is the supervisor. */
+#define SET_IS_MONITOR()                        (hwMboxDriverData.isMonitor = True)    /* Use to set an indication that current Master is the monitor. */
+
+#define IS_SUPERVISOR()                         (hwMboxDriverData.isSupervisor == True)
+#define IS_MONITOR()                            (hwMboxDriverData.isMonitor == True)
+
+#define SET_MASTER_VALID(paramMID, value)       (hwMboxDriverData.masterValid[paramMID] = value)
+#define IS_MASTER_VALID(paramMID)               (hwMboxDriverData.masterValid[paramMID] == True)
+
+#define GET_CHN_INTR(paramCID)                  (hwMboxDriverData.chnIntr[paramCID])
+#define INC_CHN_INTR(paramCID)                  ((hwMboxDriverData.chnIntr[paramCID])++)
+
+#define GET_ERR_INTR()                          (hwMboxDriverData.errIntr)
+#define INC_ERR_INTR()                          ((hwMboxDriverData.errIntr)++)
+
+#define GET_GHOST_INTR()                        (hwMboxDriverData.ghostIntr)
+#define INC_GHOST_INTR()                        ((hwMboxDriverData.ghostIntr)++)
+
+/* SRAM allocation: */
+
+#define GET_FREE_SRAM_LEFT()                    (HW_MBOX_SRAM_SIZE - __currentNonallocatedSramOffset)
+#define GET_NEXT_ALLOCATION_SRAM_OFFSET()       (__currentNonallocatedSramOffset)
+  
+#define ALLOCATE_SRAM(paramCID, requiredSizeInBytes)    \
+do{ \
+     /* Update Memory Map registers: */                                         \
+    HW_MBOX_MEMORY_MAP_START_SET(paramCID, __currentNonallocatedSramOffset);    \
+    HW_MBOX_MEMORY_MAP_SIZE_SET(paramCID, requiredSizeInBytes);                 \
+    /* advance current SRAM offset by size of allocated area: */                \
+    __currentNonallocatedSramOffset += requiredSizeInBytes;                     \
+} while (0)
+
+/*! \var static Uint32 __currentNonallocatedSramOffset
+    \brief keeps track of offset of currently allocated SRAM.
+    \warning Do not modify directly use the Macros!  
+*/
+static Uint32 __currentNonallocatedSramOffset = 0;
+
+/************************************************************************/
+/*     SEQ PROC Interface Macros:                                       */
+/************************************************************************/
+
+//#define DEBUG_SEQ_PROC    /*! debug prints for seq_file interface */
+#ifdef DEBUG_SEQ_PROC
+/* note: prints Feature header */
+#  define DPRINT_SEQ(m, fmt, args...) seq_printf(m, fmt, ## args)
+#else
+#  define DPRINT_SEQ(m, fmt, args...)
+#endif
+
+/* Defines and Structs: */
+
+typedef struct seq_proc_if_control_data 
+{
+    Bool endOfData;    /* if True then there's no more data left and proc should end */
+} seq_proc_if_control_data_t;
+
+#define SEQ_PROC_IF_CONTROL_DATA_SIZE   sizeof(seq_proc_if_control_data_t)
+
+/* Function Declare Macros: */
+
+#define SEQ_PROC_DECLARE_OPEN(procName) \
+static int CONCAT2(procName, _open)(struct inode *inode, struct file *file)
+
+#define SEQ_PROC_DECLARE_START(procName) \
+static void *CONCAT2(procName, _start)(struct seq_file *m, loff_t *pos)
+
+#define SEQ_PROC_DECLARE_NEXT(procName) \
+static void *CONCAT2(procName, _next)(struct seq_file *m, void *v, loff_t *pos)
+
+#define SEQ_PROC_DECLARE_STOP(procName) \
+static void CONCAT2(procName, _stop)(struct seq_file *m, void *v)
+
+#define SEQ_PROC_DECLARE_SHOW(procName) \
+static int CONCAT2(procName, _show)(struct seq_file *m, void *v)
+
+#define SEQ_PROC_DECLARE_SIMPLE(procName) \
+static int procName(struct seq_file *m, void *v)
+
+/* OPs Define Macros: */
+
+#define SEQ_PROC_DEFINE_FOPS(procName) \
+static const struct file_operations CONCAT2(procName, _fops) = {        \
+    .owner   = THIS_MODULE,                                             \
+    .open    = CONCAT2(procName ,_open),                                \
+    .read    = seq_read,                                                \
+    .llseek  = seq_lseek,                                               \
+    .release = seq_release_private /* release also the private data */  \
+}
+
+#define SEQ_PROC_DEFINE_SEQOPS(procName) \
+static const struct seq_operations CONCAT2(procName, _seqops) = { \
+    .start = CONCAT2(procName, _start),                           \
+    .next  = CONCAT2(procName, _next),                            \
+    .stop  = CONCAT2(procName, _stop),                            \
+    .show  = CONCAT2(procName, _show)                             \
+}
+
+#define SEQ_PROC_DEFINE_SIMPLE_FOPS(procName) \
+static const struct file_operations CONCAT2(procName, _fops) = { \
+    .owner   = THIS_MODULE,                                      \
+    .open    = CONCAT2(procName ,_open),                         \
+    .read    = seq_read,                                         \
+    .llseek  = seq_lseek,                                        \
+    .release = single_release                                    \
+}
+
+/* Function Define Macros: */
+
+#define SEQ_PROC_DEFINE_OPEN(procName) \
+static int CONCAT2(procName, _open)(struct inode *inode, struct file *file) \
+{                                                                           \
+    seq_proc_if_control_data_t *controlData;                                \
+    int retVal = -ENOMEM;                                                   \
+    controlData = kzalloc(SEQ_PROC_IF_CONTROL_DATA_SIZE, GFP_KERNEL);       \
+    if (controlData != NULL)                                                \
+    {                                                                       \
+        retVal = seq_open(file, &CONCAT2(procName, _seqops));               \
+        if (!retVal)                                                        \
+        {                                                                   \
+            struct seq_file *m = file->private_data;                        \
+            m->private = controlData;                                       \
+        }                                                                   \
+        else                                                                \
+        {                                                                   \
+            kfree(controlData);                                             \
+        }                                                                   \
+    }                                                                       \
+    return retVal;                                                          \
+}
+
+#define SEQ_PROC_DEFINE_SIMPLE_OPEN(procName) \
+static int CONCAT2(procName, _open)(struct inode *inode, struct file *file) \
+{                                                                           \
+    return single_open(file, procName, NULL);                               \
+}
+
+#define SEQ_PROC_DEFINE_START(procName) \
+static void *CONCAT2(procName, _start)(struct seq_file *m, loff_t *pos)                                     \
+{                                                                                                           \
+    /* This function is entered when proc is first called or a upon new page [also after stop!!!] */        \
+    seq_proc_if_control_data_t *controlData = m->private;                                                   \
+    loff_t *spos = NULL; /* our iterator, default to NULL */                                                \
+    if (!controlData->endOfData)                                                                            \
+    {                                                                                                       \
+        /* New Run or new page, more data, initialize the iterator */                                       \
+        spos = kzalloc(sizeof(loff_t), GFP_KERNEL);                                                         \
+        if (!spos)                                                                                          \
+        {                                                                                                   \
+            /* Allocation Failed!!! */                                                                      \
+            PRINTK_ERR("Can't allocate memory!");                                                           \
+            return NULL;                                                                                    \
+        }                                                                                                   \
+        *spos = *pos;                                                                                       \
+        DPRINT_SEQ(m, "START (*spos=%lld)\n", (long long)*spos);                                            \
+    }                                                                                                       \
+    return spos; /* Iterator if New Run\Page, defaultive NULL in case returning after stop to mark EOF */   \
+}
+
+#define SEQ_PROC_DEFINE_NEXT(procName) \
+static void *CONCAT2(procName, _next)(struct seq_file *m, void *v, loff_t *pos)     \
+{                                                                                   \
+    seq_proc_if_control_data_t *controlData = m->private;                           \
+    loff_t *spos = v; /* the current position */                                    \
+    if (controlData->endOfData)                                                     \
+    {                                                                               \
+        DPRINT_SEQ(m, "LAST NEXT (*spos=%lld)\n", *spos);                           \
+        return NULL; /* NULL to mark EOF */                                         \
+    }                                                                               \
+    else                                                                            \
+    {                                                                               \
+        DPRINT_SEQ(m, "NEXT ");                                                     \
+        DPRINT_SEQ(m, "*pos=%lld->", (long long)*pos);                              \
+        (*spos)++;      /* increment current position */                            \
+        *pos = *spos;   /* set it in *pos [set "next" item] */                      \
+        DPRINT_SEQ(m, "%lld\n", (long long)*pos);                                   \
+        return spos;    /* return ["next"] current position */                      \
+    }                                                                               \
+}
+
+#define SEQ_PROC_DEFINE_STOP(procName) \
+static void CONCAT2(procName, _stop)(struct seq_file *m, void *v) \
+{                                                                 \
+    DPRINT_SEQ(m, "STOP, cleanup.\n");                            \
+    kfree(v); /* finished with the iterator */                    \
+}
+
+/* Interface API Macros: */
+
+/*! \def SEQ_PROC_DEFINE(procName)
+    \brief macro that will define a generic seq proc template, position advances by one per step.
+    \param[in] procName - name designation of the seq proc, to be used as prefix to all the needed functions.
+    \attention user should define a show function with prototype/name: static int <procName>_show(struct seq_file *m, void *v)
+    \attention user must signal end of data setting <endOfData> field of seq_proc_if_control_data_t struct to True.
+    \attention seq_proc_if_control_data_t struct is contained in the seq file private field.
+    \note <procName> can be different then the actual file name that will be used for the proc [see SEQ_PROC_CREATE].
+*/
+#define SEQ_PROC_DEFINE(procName) \
+/* Function Declarations: */      \
+SEQ_PROC_DECLARE_OPEN(procName);  \
+SEQ_PROC_DECLARE_START(procName); \
+SEQ_PROC_DECLARE_NEXT(procName);  \
+SEQ_PROC_DECLARE_STOP(procName);  \
+SEQ_PROC_DECLARE_SHOW(procName);  \
+/* Define OPs structures: */      \
+SEQ_PROC_DEFINE_FOPS(procName);   \
+SEQ_PROC_DEFINE_SEQOPS(procName); \
+/* Define Functions:  */          \
+SEQ_PROC_DEFINE_OPEN(procName);   \
+SEQ_PROC_DEFINE_START(procName);  \
+SEQ_PROC_DEFINE_NEXT(procName);   \
+SEQ_PROC_DEFINE_STOP(procName);
+
+/*! \def SEQ_PROC_DEFINE_SIMPLE(procName)
+    \brief macro that will define a simple generic seq proc template, where no more than one page is needed.
+    \param[in] procName - name designation of the seq proc, to be used as prefix to all the needed functions and also the name of the actual proc function.
+    \attention user should define the proc function with prototype/name: static int <procName>(struct seq_file *m, void *v)
+    \attention This should be used over SEQ_PROC_DEFINE for short procs that surely will not exceed a page. 
+    \note <procName> can be different then the actual file name that will be used for the proc [see SEQ_PROC_CREATE].
+*/
+#define SEQ_PROC_DEFINE_SIMPLE(procName) \
+/* Function Declarations: */             \
+SEQ_PROC_DECLARE_OPEN(procName);         \
+SEQ_PROC_DECLARE_SIMPLE(procName);       \
+/* Define OPs structures: */             \
+SEQ_PROC_DEFINE_SIMPLE_FOPS(procName);   \
+/* no need for SEQ_OPS for simple */     \
+/* Define Functions:  */                 \
+SEQ_PROC_DEFINE_SIMPLE_OPEN(procName);
+
+/*! \def SEQ_PROC_CREATE(procName, procDir)
+    \brief macro that will create a generic seq proc file.
+    \param[in] procFileName - string, actual name of the seq proc file to be created.
+    \param[in] procName - name designation of the seq proc, that was used with SEQ_PROC_DEFINE/SEQ_PROC_DEFINE_SIMPLE.
+    \param[in] procDir - struct proc_dir_entry * of the directory that the seq proc file should be created in.
+    \attention Corresponding call with same <procName> to SEQ_PROC_DEFINE/SEQ_PROC_DEFINE_SIMPLE macro must exist!
+    \attention On unlikely fail return -1 to exit calling function with fail (assumes int type calling function).
+    \note <procFileName> is the name of the file that will be used with shell's # cat command.
+*/
+#define SEQ_PROC_CREATE(procFileName, procName, procDir) \
+if (NULL == (proc_create_data(procFileName, 0, procDir, &CONCAT2(procName, _fops), NULL))) \
+{                                                                                          \
+    PRINTK_ERR("Can't create proc %s!", procFileName);                                     \
+    return -1;                                                                             \
+}
+
+/*! \def PROC_CREATE_DIR(procDirName, procDir)
+    \brief macro that will create a proc directory.
+    \param[in] procDirName - string, directory name.
+    \param[out] procDir - struct proc_dir_entry * for the directory.
+    \attention On unlikely fail return -1 to exit calling function with fail (assumes int type calling function).
+*/
+#define PROC_CREATE_DIR(procDirName, procDir) \
+if (NULL == (procDir = proc_mkdir(procDirName, NULL)))    \
+{                                                         \
+    PRINTK_ERR("Can't create proc dir %s!", procDirName); \
+    return -1;                                            \
+}
+
+/************************************************************************/
+/*     HW_MBOX proc file system utilities:                              */
+/************************************************************************/
+
+/*! \def HW_MBOX_PROC_DIR_STR
+    \brief proc dir: /proc/HW_MBOX */
+#define HW_MBOX_PROC_DIR_STR    "hw_mbox"
+
+/* Define all Simple Procs here: */
+
+SEQ_PROC_DEFINE_SIMPLE(proc_dump_core_version);
+SEQ_PROC_DEFINE_SIMPLE(proc_dump_control_regs);
+SEQ_PROC_DEFINE_SIMPLE(proc_dump_status);
+
+/* Define all SEQ Procs here: */
+
+SEQ_PROC_DEFINE(proc_dump_masters_regs);
+SEQ_PROC_DEFINE(proc_dump_channels_regs);
+SEQ_PROC_DEFINE(proc_dump_interrupts);
+
+/* Implement all simple procs here: */
+
+/*! \fn static int proc_dump_core_version(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Core Version proc (reads ID registers). */
+static int proc_dump_core_version(struct seq_file *m, void *v)
+{
+    seq_printf(m, "HW_MBOX Core Version: %d.%d\n", HW_MBOX_ID_MAJOR_GET(), HW_MBOX_ID_MINOR_GET());
+    return 0;
+}
+
+/*! \fn static int proc_dump_control_regs(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Control Registers proc. */
+static int proc_dump_control_regs(struct seq_file *m, void *v)
+{
+    seq_printf(m, "ID:     0x%08x\n", HW_MBOX_ID_REG_GET());
+    seq_printf(m, "CTRL:   0x%08x\n", HW_MBOX_CTRL_REG_GET());
+    seq_printf(m, "ERROR:  0x%08x\n", HW_MBOX_ERROR_REG_GET());
+    return 0;
+}
+
+/*! \fn static int proc_dump_status(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Status proc (parses data from Control Registers). */
+static int proc_dump_status(struct seq_file *m, void *v)
+{
+    seq_printf(m, "HW_MBOX status:\n");
+    seq_printf(m, "LOCKED:          %s\n", YESNO_STR(HW_MBOX_CTRL_LOCK_GET()));
+    seq_printf(m, "STARTED:         %s\n", YESNO_STR(HW_MBOX_CTRL_START_GET()));
+    seq_printf(m, "HW DEBUG MODE:   %s\n", YESNO_STR(HW_MBOX_CTRL_DEBUG_GET()));
+    seq_printf(m, "Supervisor:      %s(%d)\n", HW_MBOX_MASTER_GET_NAME(HW_MBOX_CTRL_SUPERVISOR_GET()),
+                                               HW_MBOX_CTRL_SUPERVISOR_GET());
+    if (HW_MBOX_CTRL_MON_EXIST_GET())
+    {
+        seq_printf(m, "Monitor:         %s(%d)\n", HW_MBOX_MASTER_GET_NAME(HW_MBOX_CTRL_MONITOR_GET()),
+                                                   HW_MBOX_CTRL_MONITOR_GET());
+    }
+    else
+    {
+        seq_printf(m, "Monitor:         There is no Monitor defined.\n");
+    }
+
+    return 0;
+}
+
+/* Implement all SEQ show functions here: */
+
+/*! \fn static int proc_dump_masters_regs_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Masters Registers. */
+static int proc_dump_masters_regs_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+    if (i < HW_MBOX_MASTER_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+            seq_printf(m, "+------+-----------------------+-----------------------+-------------------------+-----------------------+\n");
+            seq_printf(m, "| MID# |   SHADOW_H SHADOW_L   |     MASK_H MASK_L     | COMMANDER_H COMMANDER_L |  SUBJECT_H SUBJECT_L  |\n");
+            /* Value fmt: "|  ##  | 0x00000000 0x00000000 | 0x00000000 0x00000000 |  0x00000000 0x00000000  | 0x00000000 0x00000000 |" */
+        }
+
+        seq_printf(m, "|  %2d  | 0x%08x 0x%08x | 0x%08x 0x%08x |  0x%08x 0x%08x  | 0x%08x 0x%08x |\n", i,
+                   HW_MBOX_MASTER_PARAM_INTR_CLEAR_H_REG_GET(i), HW_MBOX_MASTER_PARAM_INTR_CLEAR_L_REG_GET(i),
+                   HW_MBOX_MASTER_PARAM_INTR_MASK_H_REG_GET(i), HW_MBOX_MASTER_PARAM_INTR_MASK_L_REG_GET(i),
+                   HW_MBOX_MASTER_PARAM_COMMANDER_H_REG_GET(i), HW_MBOX_MASTER_PARAM_COMMANDER_L_REG_GET(i),
+                   HW_MBOX_MASTER_PARAM_SUBJECT_H_REG_GET(i), HW_MBOX_MASTER_PARAM_SUBJECT_L_REG_GET(i));
+
+        if ((HW_MBOX_MASTER_COUNT - 1) == i)
+        {
+            /* End of table print trailing line */
+            seq_printf(m, "+------+-----------------------+-----------------------+-------------------------+-----------------------+\n");
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_channels_regs_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Channels Registers. */
+static int proc_dump_channels_regs_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+    if (i < HW_MBOX_CHANNEL_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+            seq_printf(m, "+------+-------------+-------------+-------------+-------------+\n");
+            seq_printf(m, "| CHN# |   CHN_CFG   |  CHN_STATE  | CHN_COMMAND |   MEM_MAP   |\n");
+            /* Value fmt: "|  ##  |  0x00000000 |  0x00000000 |  0x00000000 |  0x00000000 |" */
+        }
+
+        seq_printf(m, "|  %2d  |  0x%08x |  0x%08x |  0x%08x |  0x%08x |\n", i, 
+                   HW_MBOX_CHN_CFG_REG_GET(i), HW_MBOX_CHN_STATE_REG_GET(i),
+                   HW_MBOX_CHN_COMMAND_REG_GET(i), HW_MBOX_MEMORY_MAP_REG_GET(i));
+
+        if ((HW_MBOX_CHANNEL_COUNT - 1) == i)
+        {
+            /* End of table print trailing line */
+            seq_printf(m, "+------+-------------+-------------+-------------+-------------+\n");
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/*! \fn static int proc_dump_interrupts_show(struct seq_file *m, void *v)
+    \brief dump HW_MBOX Interrupts Data. */
+static int proc_dump_interrupts_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i,(long long)*spos);
+    if (i < HW_MBOX_CHANNEL_COUNT)
+    {
+        if (0 == i)
+        {
+            /* We are in the first run, print line and headers */
+            seq_printf(m, " CID         INTR\n");
+        }
+        seq_printf(m, " %2d:   %10u\n", i, GET_CHN_INTR(i));
+
+        if (i == HW_MBOX_CHANNEL_COUNT - 1) /* Last Line */
+        {
+            seq_printf(m, "err:   %10u\n", GET_ERR_INTR());
+            seq_printf(m, "ghost: %10u\n", GET_GHOST_INTR());
+            controlData->endOfData = True;
+        }
+    }
+
+    return 0;
+}
+
+/************************************************************************/
+/*     HW_MBOX driver functions                                         */
+/************************************************************************/
+
+static irqreturn_t hw_mbox_drv_isr(int irq, void *dev_id)
+{
+    Uint32 highIntrStatusReg; /* Interrupts from Channels 63-32 [for supervisor 63 is error notify] */
+    Uint32 lowIntrStatusReg;  /* Interrupts from Channels 31-0 */
+
+    Uint32 highIntrMaskReg; /* Interrupt Enable Mask for Channels 63-32 [for supervisor 63 is error notify, mask will be ignored] */
+    Uint32 lowIntrMaskReg;  /* Interrupt Enable Mask for Channels 31-0 */
+
+    chnint_t *dev;
+    Uint32 highCidRange, regVal, chnint_cid;
+    Bool errorBitWasOn = False;
+
+    DPRINTK("isr!");
+    /* We got an interrupt! */
+
+    /* Now we must read all the set bits from both HW_MBOX_MASTER_INTR_STATUS_H and
+       HW_MBOX_MASTER_INTR_STATUS_L. All interrupts must be handled as the bits are
+       reset upon read! [except masked ones...] */
+
+    highIntrStatusReg = HW_MBOX_MASTER_INTR_STATUS_H_REG_GET();
+    lowIntrStatusReg = HW_MBOX_MASTER_INTR_STATUS_L_REG_GET();
+
+    DPRINTK("intrStatus(H L): 0x%08x 0x%08x", highIntrStatusReg, lowIntrStatusReg);
+
+    DPRINTK("interrupt bits should now be cleard [all unmasked ones]...");
+    DPRINTK("verifying using shadowRegs(H L): 0x%08x 0x%08x", HW_MBOX_MASTER_INTR_CLEAR_H_REG_GET(),
+                                                              HW_MBOX_MASTER_INTR_CLEAR_L_REG_GET());
+
+    /* First we will check if error is set, so we can notify hw_mbox_app as quickly as possible */
+    if ((IS_SUPERVISOR()) && (HW_MBOX_IS_ERROR_BIT_SET_FOR_SUPERVISOR(highIntrStatusReg)))
+    {
+        DPRINTK("Hardware signals of Access Violation Error!");
+        INC_ERR_INTR();
+
+        DPRINTK("interrupt on channel %d, waking up dev...", HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
+        dev = &chnint_devices[HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR];
+        dev->interruptPending = CHN_INT_PENDING;
+        wake_up_interruptible(&dev->chnint_rqueue);
+
+        highIntrStatusReg &= (~HW_MBOX_ERROR_BIT_FOR_SUPERVISOR); /* Clear the error interrupt from the register value buffer */
+        errorBitWasOn = True; /* need to remember that error bit was on as we turn it off here */
+    }
+
+    /* Now we should remove the masked bits [interrupt is disabled for them] */
+
+    highIntrMaskReg = HW_MBOX_MASTER_INTR_MASK_H_REG_GET();
+    lowIntrMaskReg  = HW_MBOX_MASTER_INTR_MASK_L_REG_GET();
+    DPRINTK("intrMask(H L): 0x%08x 0x%08x", highIntrMaskReg, lowIntrMaskReg);
+
+    highIntrStatusReg &= (~highIntrMaskReg);
+    lowIntrStatusReg  &= (~lowIntrMaskReg);
+    DPRINTK("intrStatus(H L) [after removed masked CIDs]: 0x%08x 0x%08x", highIntrStatusReg, lowIntrStatusReg);
+
+    if ((0 == highIntrStatusReg) && (0 == lowIntrStatusReg))
+    {
+        if (errorBitWasOn == False)
+        {
+            /* we got an interrupt, but no set bits in interrupt status! */
+            DPRINTK("We got a ghost Interrupt!");
+            INC_GHOST_INTR();
+        }
+        else
+        {
+            /* only error bit was on... */
+            DPRINTK("Only Error bit was on, no need to continue checking...");
+        }
+    }
+    else
+    {
+        for (highCidRange = 0; highCidRange < 2; highCidRange++) 
+        {
+            /* highCidRange determines what CID range we are querying:
+               highCidRange = 0 -> CID range [31-0]
+               highCidRange = 1 -> CID range [63-32] */
+
+            DPRINTK("Handling Interrupts in %s CID range", (highCidRange)?("high [63-32]"):("low [31-0]"));
+
+            regVal = (highCidRange)?(highIntrStatusReg):(lowIntrStatusReg);
+
+            while (regVal)
+            {
+                chnint_cid = fls(regVal) - 1; /* fls gets (position of LSB that is set) + 1 */
+                DPRINTK("position of LSB that is set on regVal=0x%08x is %d", regVal, chnint_cid);
+                regVal &= (~BIT(chnint_cid));       /* turn off bit, we got it... */
+                chnint_cid += (32 * highCidRange);  /* adjusting to range */
+                INC_CHN_INTR(chnint_cid);
+                DPRINTK("interrupt on channel %d, waking up dev...", chnint_cid);
+                dev = &chnint_devices[chnint_cid];
+                dev->interruptPending = CHN_INT_PENDING;
+                wake_up_interruptible(&dev->chnint_rqueue);
+                DPRINTK("new regVal=0x%08x (after handling one interrupt)", regVal);
+            }
+        }
+    }
+
+    /* Use ack_irq:
+       Signal that we handled the Interrupt to clear the bit in the interrupt controller.
+       Otherwise ISR would get called again as the bit is not cleared and it is Level.
+
+       Code preceding the ISR will clear the bit in the Interrupt Controller as the INTR Line
+       is not on (but the ISR runs again anyway when it shouldn't).
+
+       If the INTR Line is back up (after we read INTR_STATUS but before calling ack_irq) then
+       upon exit from ISR the bit in the controller will get turned back on, so we can't miss
+       interrupts by using ack_irq but we will save the unnecessary ISR just to clear the bit
+       in the interrupt controller.
+    */
+    //ack_irq(irq);
+    return IRQ_HANDLED;
+}
+
+int hw_mailbox_register_with_netss(void) 
+{
+   int i, ret = -ENODEV;
+   netss_subdevice_mmio_t hwmailbox_mmio;
+
+   if(!netss_driver_ready())
+   {
+      printk(KERN_INFO "Net SubSystem Driver is not ready, cannot initialize HW MUTEX driver\n");
+      return ret;
+   }
+
+   if(netss_get_subdevice_mmio_info(NETSS_HW_MAILBOX, &hwmailbox_mmio))
+   {
+      printk(KERN_INFO "HW MAILBOX driver could not get mmio info \n");
+      return -1;
+   }
+   else
+   {
+      printk(KERN_INFO "HW Mailbox mem_iobase = 0x%x, mem_iosize = 0x%x\n",(unsigned int)hwmailbox_mmio.base,(unsigned int)hwmailbox_mmio.size);
+   }
+    
+	
+   /* Initialize critical structures */
+   for (i = 0; i< HW_MBOX_CHANNEL_COUNT; i++) {
+      mutex_init(&hwMboxDriverData.chnLock[i]);
+   }
+
+   hwMboxDriverData.reg_base = (void __iomem *)ioremap_nocache(hwmailbox_mmio.base,hwmailbox_mmio.size);
+   if (hwMboxDriverData.reg_base) {
+      printk(KERN_ERR "error, failed to ioremap hw mailbox registers\n");
+      ret = -ENOMEM;
+      return ret;
+   }
+	
+   printk(KERN_INFO "Intel(R) HW MAILBOX driver built on %s @ %s\n", __DATE__, __TIME__);
+   return 0;
+}
+
+static int __init hw_mbox_drv_init_module (void)
+{
+    //int r, devno;
+    int i, paramMID, paramCID;
+    hw_mbox_masterConfig_t masterConfig;
+    hw_mbox_channelConfig_t chnConfig;
+
+    /* Initialize the Driver Local Data: */
+    RESET_DRIVER_DATA();
+
+    DPRINTK("init!");
+    PRINTK_INFO("%s version %s built on %s @ %s", DRV_NAME, DRV_VERSION, __DATE__, __TIME__);
+
+#ifdef HW_MBOX_DEBUG
+    /* If we are in debug mode (MID disguise feature) MID starts as 0
+       it makes more sense to start with the HARDCODED one... */
+    PRINTK_INFO("Master Disguise Feature: Setting initial MID to the Hardcoded one");  
+    __HW_MBOX_DEBUG_SET_MID(HW_MBOX_HARDCODED_MID);
+#endif
+    if( 0 >= hw_mailbox_register_with_netss()) 
+    {
+       PRINTK_INFO("%s version %s built on %s @ %s CANNOT BE INITALIZED", DRV_NAME, DRV_VERSION, __DATE__, __TIME__);
+       return -ENODEV;
+    }
+
+#if defined HW_MBOX_IS_NP_CPU 
+    /* Create Channel interrupt Devices: */
+    if ((r = alloc_chrdev_region(&chnint_dev, 0, HW_MBOX_CHANNEL_COUNT, HW_MBOX_CHNINT_DEV_NAME)) != 0)
+    {
+        PRINTK_ERR("Failed to register character device region %s", HW_MBOX_CHNINT_DEV_NAME);
+        return r;
+    }
+
+    chnint_class = class_create(THIS_MODULE, HW_MBOX_CHNINT_DEV_NAME);
+    DPRINTK("registered with major number %i", MAJOR(chnint_dev));
+
+    if ((chnint_devices = kmalloc(HW_MBOX_CHANNEL_COUNT * sizeof(chnint_t), GFP_KERNEL)) == NULL)
+    {
+        PRINTK_ERR("Failed to allocate %d devices", HW_MBOX_CHANNEL_COUNT);
+        chnint_cleanup(0);
+        return -ENOMEM;
+    }
+
+    DPRINTK("Successfully allocated %d devices!", HW_MBOX_CHANNEL_COUNT);
+    memset(chnint_devices, 0, HW_MBOX_CHANNEL_COUNT * sizeof(chnint_t));
+
+    for (i = 0; i < HW_MBOX_CHANNEL_COUNT; i++)
+    {
+        chnint_devices[i].chn_cid = i;
+
+        /* Create a wait queue that applications will sleep on until interrupt */
+        init_waitqueue_head(&chnint_devices[i].chnint_rqueue);
+        chnint_devices[i].interruptPending = CHN_INT_NONE;
+
+        /* Connect the file operations with the cdev */
+        cdev_init(&chnint_devices[i].chnint_cdev, &chnint_fops);
+
+        devno = MKDEV(MAJOR(chnint_dev), MINOR(chnint_dev) + i);
+        if ((r = cdev_add(&chnint_devices[i].chnint_cdev, devno, 1)) != 0)
+        {
+            PRINTK_ERR("Failed to add %s%02d with error %d", HW_MBOX_CHNINT_DEV_NAME, i, r);
+            chnint_cleanup(i);
+            return (-1);
+        }
+        else
+        {
+            DPRINTK("Successfully added %s%02d", HW_MBOX_CHNINT_DEV_NAME, i);
+        }
+
+        device_create(chnint_class, 0, MKDEV(MAJOR(chnint_dev), MINOR(chnint_dev) + i), 0, "%s/%s%02d", HW_MBOX_DRV_DEV_DIR_NAME, HW_MBOX_CHNINT_DEV_NAME, i);
+        DPRINTK("Created device /dev/%s/%s%02d", HW_MBOX_DRV_DEV_DIR_NAME, HW_MBOX_CHNINT_DEV_NAME, i);
+    }
+
+    PRINTK_INFO("Created %d /dev/%s/%sXX devices", HW_MBOX_CHANNEL_COUNT, HW_MBOX_DRV_DEV_DIR_NAME, HW_MBOX_CHNINT_DEV_NAME);
+
+    /* Create the Proc filesystem utilities ( /proc/<HW_MBOX_PROC_DIR_STR>/ ): */
+    {
+        struct proc_dir_entry *procDir;
+
+        /* Directory: */
+        PROC_CREATE_DIR(HW_MBOX_PROC_DIR_STR, procDir);
+
+        /* Simple Procs: */
+        SEQ_PROC_CREATE("core_version", proc_dump_core_version, procDir);
+        SEQ_PROC_CREATE("control_regs", proc_dump_control_regs, procDir);
+        SEQ_PROC_CREATE("status", proc_dump_status, procDir);
+        
+        /* SEQ Procs: */
+        SEQ_PROC_CREATE("masters_regs", proc_dump_masters_regs, procDir);
+        SEQ_PROC_CREATE("channels_regs", proc_dump_channels_regs, procDir);
+        SEQ_PROC_CREATE("interrupts", proc_dump_interrupts, procDir);
+    }
+    PRINTK_INFO("Created proc directory: /proc/%s", HW_MBOX_PROC_DIR_STR);
+#endif
+
+    /* Get core version from HW_MBOX_ID register: */
+    SET_CORE_VER_MAJ(HW_MBOX_ID_MAJOR_GET());
+    SET_CORE_VER_MIN(HW_MBOX_ID_MINOR_GET());
+
+    DPRINTK("HW_MBOX core version: %d.%d", GET_CORE_VER_MAJ(), GET_CORE_VER_MIN());
+
+#ifdef __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO
+    /* Check if we need to change default supervisor: */
+    /* This needs to be done now since our next step is finding out whether we are the supervisor */
+    if (HW_MBOX_CTRL_SUPERVISOR_GET() != __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO)
+    {
+        PRINTK_INFO("changing supervisor to: %s(%d)",
+                    HW_MBOX_MASTER_GET_NAME(__HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO),
+                    __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO);
+
+        HW_MBOX_CTRL_AS_DEFAULT_SUPERVISOR_SUPERVISOR_SET(__HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO);
+    }
+#endif
+
+    /* Check if this Master is the supervisor: */
+    if (HW_MBOX_IS_SUPERVISOR())
+    {
+        DPRINTK("Current Master is the supervisor: %s(%d)", HW_MBOX_MASTER_GET_NAME(HW_MBOX_MID), HW_MBOX_MID);
+        SET_IS_SUPERVISOR();
+    }
+    else
+    {
+        DPRINTK("supervisor is: %s(%d)", HW_MBOX_MASTER_GET_NAME(HW_MBOX_CTRL_SUPERVISOR_GET()),
+                                         HW_MBOX_CTRL_SUPERVISOR_GET());
+    }
+
+#ifdef HW_MBOX_MONITOR
+    if (HW_MBOX_MONITOR == HW_MBOX_MID)
+    {
+        /* This Master is the Monitor, Update Driver Data... */
+        SET_IS_MONITOR();
+    }
+#endif
+
+    if (IS_SUPERVISOR())
+    {
+        if (HW_MBOX_IS_STARTED())
+        {
+            /* HW_MBOX is already configured and started (probably warm reset)... */
+            PRINTK_INFO("HW_MBOX is already configured and started -> skip configuration...");
+            goto SKIP_CONFIGURATION;
+        }
+
+        DPRINTK("Setting up general control configuration values...");
+#ifdef HW_MBOX_MONITOR
+        DPRINTK("Setting Monitor = %s(%d)", HW_MBOX_MASTER_GET_NAME(HW_MBOX_MONITOR), HW_MBOX_MONITOR);
+
+        /* Setup HW_MBOX Configuration registers: */
+        HW_MBOX_CTRL_MON_EXIST_SET(True);
+        HW_MBOX_CTRL_MONITOR_SET(HW_MBOX_MONITOR);
+#else
+        /* Setup HW_MBOX Configuration registers: */
+        HW_MBOX_CTRL_MON_EXIST_SET(False); /* Default should be False, but it doesn't hurt to make sure */
+#endif // HW_MBOX_MONITOR
+#ifdef HW_MBOX_START_IN_HW_DEBUG_MODE
+        DPRINTK("Setting HW Debug Mode...");
+
+        /* Setup HW_MBOX Configuration registers: */
+        HW_MBOX_CTRL_DEBUG_SET(True);
+#else
+        HW_MBOX_CTRL_DEBUG_SET(False); /* Default should be False, but it doesn't hurt to make sure */
+#endif // HW_MBOX_START_IN_HW_DEBUG_MODE
+
+        /* Check which Masters are Valid: */
+        for (paramMID = 0; paramMID < HW_MBOX_MASTER_COUNT; paramMID++)
+        {
+            memcpy(&masterConfig, &HW_MBOX_MASTER_GET_CONFIG(paramMID), HW_MBOX_MASTER_CONFIG_SIZE);
+
+            /* TBD: add check for fused out Masters */
+
+            if (masterConfig.support != hw_mbox_support_none)
+            {
+                SET_MASTER_VALID(paramMID, True);
+            }
+        }
+        
+        /* INIT static channels: */
+        DPRINTK("Initializing %d static channels", HW_MBOX_STATIC_CHANNEL_COUNT);
+        for (i = 0; i < HW_MBOX_STATIC_CHANNEL_COUNT; i++)
+        {
+            memcpy(&chnConfig, &HW_MBOX_STATIC_CHANNEL_GET_CONFIG(i), HW_MBOX_CHANNEL_CONFIG_SIZE);
+            paramCID = chnConfig.cid;
+
+            DPRINTK("static channel entry %d (cid=%d): mboxType=%d, commander=%d, subject=%d, memSize=%uB",
+                    i, paramCID, chnConfig.mboxType, chnConfig.commander, chnConfig.subject, chnConfig.memBuff.size);
+
+            /* First we should check if the configuration is valid: */
+            DPRINTK("static channel entry %d (cid=%d): verifying configuration...", i, paramCID);
+
+            /* check that both Masters are Valid */
+            if ((!IS_MASTER_VALID(chnConfig.commander)) ||
+                (!IS_MASTER_VALID(chnConfig.subject)))
+            {
+                PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! One of the Masters is invalid!",
+                            i, paramCID);
+                continue; /* invalid configuration skip this channel */
+            }
+
+            /* check that CID is not yet allocated: */
+            if (HW_MBOX_CHN_CFG_VALID_GET(paramCID))
+            {
+                /* CHN_CFG is valid... This CID has already been assigned! */
+                PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! CID already assigned!",
+                            i, paramCID);
+                continue; /* invalid configuration skip this channel */
+            }
+
+            if (paramCID == HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR)
+            {
+                /* We can't allocate CID that's used for error notification with supervisor as Commmander/Subject  */
+                if ((chnConfig.commander == HW_MBOX_MID) || (chnConfig.subject == HW_MBOX_MID))
+                {
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! Notify Error CID %d can't be allocated with supervisor as Commander/Subject!",
+                                i, paramCID, HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
+                    continue; /* invalid configuration skip this channel */
+                }
+#ifdef HW_MBOX_MONITOR
+                /* If Supervisor is also Monitor we can't allocate CID that's used for error notification at all! */
+                if (IS_MONITOR())
+                {
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! Notify Error CID %d can't be allocated at all if supervisor is also Monitor!",
+                                i, paramCID, HW_MBOX_ERROR_NOTIFY_CID_FOR_SUPERVISOR);
+                    continue; /* invalid configuration skip this channel */
+                }
+#endif
+            }
+
+            if (chnConfig.memBuff.size % HW_MBOX_SRAM_CHUNK != 0)
+            {
+                PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! sram size must be an integral Multiple of %d (requested Size=%uB)",
+                            i, paramCID, chnConfig.memBuff.size, HW_MBOX_SRAM_CHUNK);
+                continue; /* invalid configuration skip this channel */
+            }
+
+            if (chnConfig.mboxType == hw_mbox_event)
+            {
+                if (chnConfig.memBuff.size == 0)
+                {
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! for event channels sram size must be > 0 [for event Buffer] (requested Size=%uB)",
+                                i, paramCID, chnConfig.memBuff.size);
+                    continue; /* invalid configuration skip this channel */
+                }
+                if ((chnConfig.memBuff.size / HW_MBOX_SRAM_CHUNK) % 2 != 0)
+                {
+                    PRINTK_INFO("static channel entry %d (cid=%d): Invalid configuration! for event channels sram size must be an evenly divisible amount of %dB chunks (requested Size=%uB)",
+                                i, paramCID, HW_MBOX_SRAM_CHUNK, chnConfig.memBuff.size);
+                    continue; /* invalid configuration skip this channel */
+                }
+            }
+
+            if (chnConfig.memBuff.size > GET_FREE_SRAM_LEFT())
+            {
+                PRINTK_ERR("static channel entry %d (cid=%d): Cannot be configured! Not enough SRAM memory Left (requested Size=%uB, free SRAM left=%uB)!", 
+                           i, paramCID, chnConfig.memBuff.size, GET_FREE_SRAM_LEFT());
+                continue; /* error, not more memory left! skip this channel */
+            }
+
+            /* If we are here the channel configuration is OK we can proceed in setting up the HW_MBOX channel
+               registers with its configuration. */
+            HW_MBOX_CHANNEL_CONFIG_SET(paramCID, chnConfig.mboxType, 0, chnConfig.commander, chnConfig.subject);
+
+            if (chnConfig.memBuff.size > 0)
+            {
+                DPRINTK("static channel entry %d (cid=%d): current Nonallocated SRAM Offset=0x%08x, need %uB of SRAM", 
+                        i, paramCID, GET_NEXT_ALLOCATION_SRAM_OFFSET(), chnConfig.memBuff.size);
+
+                chnConfig.memBuff.start = GET_NEXT_ALLOCATION_SRAM_OFFSET();
+
+                ALLOCATE_SRAM(paramCID, chnConfig.memBuff.size);
+
+                DPRINTK("static channel entry %d (cid=%d): %uB of SRAM allocated, new current Nonallocated SRAM Offset=0x%08x",
+                        i, paramCID, chnConfig.memBuff.size, GET_NEXT_ALLOCATION_SRAM_OFFSET());
+
+                /* We would have liked to reset channel's SRAM if we are Commander,
+                   to cover the case of Kernel Customers but it is impossible to do
+                   so at this point since START is not set...
+                 
+                   If there are Kernel contexts using a channel, Commander should
+                   first reset channel's SRAM. */
+            }
+
+            HW_MBOX_CHN_CFG_VALID_SET(paramCID, True);
+
+            DPRINTK("configured new static channel (cid=%d): %s MBOX, %s(%d) -> %s(%d) [%uB of SRAM]",
+                    paramCID, HW_MBOX_TYPE_STR(chnConfig.mboxType),
+                    HW_MBOX_MASTER_GET_NAME(chnConfig.commander), chnConfig.commander,
+                    HW_MBOX_MASTER_GET_NAME(chnConfig.subject), chnConfig.subject,
+                    chnConfig.memBuff.size);
+        }
+
+        /* Now that all configuration values and static channels are set we can set start! */
+        PRINTK_INFO("initial configuration completed, setting START!");
+        HW_MBOX_CTRL_START_SET(True);
+
+        /* TBD: send interrupt to BBU?! */
+    }
+
+SKIP_CONFIGURATION:
+#if defined HW_MBOX_IS_NP_CPU
+    /* Setup ISR (only after static configuration has been fully completed): */
+    if (request_irq(HW_MBOX_INT_LINE, hw_mbox_drv_isr, IRQF_TRIGGER_HIGH, HW_MBOX_INT_NAME, NULL /* no need for dev as line is not shared */))
+    {
+        PRINTK_ERR("Unable to allocate IRQ!");
+        return -ENODEV;
+    }
+#elif defined HW_MBOX_IS_APP_CPU
+    {
+       netss_subdev_irq_info_t irq_info;
+       irq_info.func = &hw_mbox_drv_isr;
+       irq_info.args = &hwMboxDriverData;
+       netss_subdev_register_irq(NETSS_HW_MAILBOX, &irq_info); 
+    }
+#endif
+    return 0;
+}
+
+static void __exit hw_mbox_drv_exit(void)
+{
+#if defined HW_MBOX_IS_NP_CPU
+   free_irq(HW_MBOX_INT_LINE, NULL);
+#elif defined HW_MBOX_IS_APP_CPU
+   netss_subdev_irq_info_t irq_info;
+   irq_info.func = NULL;
+   irq_info.args = NULL;
+   netss_subdev_register_irq(NETSS_HW_MUTEX, &irq_info);
+   iounmap(hwMboxDriverData.reg_base);
+
+#endif
+   chnint_cleanup(HW_MBOX_CHANNEL_COUNT);
+}
+
+subsys_initcall(hw_mbox_drv_init_module);
+module_exit(hw_mbox_drv_exit);
+
+/* Driver identification: */
+MODULE_DESCRIPTION(DRV_NAME);
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR ("Intel Corporation");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/arch/x86/hw_mailbox/hw_mbox_mem_access.h
@@ -0,0 +1,1248 @@
+/*
+ *
+ * hw_mbox_mem_access.h
+ * Description:
+ * contains memory access functions for the puma7 HW_MBOX controller
+ * registers and SRAM.
+ *
+ 
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE 
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#ifndef _HW_MBOX_MEM_ACCESS_H_
+#define _HW_MBOX_MEM_ACCESS_H_
+
+/************************************
+              INCLUDES:              
+************************************/
+
+/* Include Always: */
+#include "hw_mbox_defs.h"   /* for HW_MBOX_MID, HW_MBOX_CONCAT and Generic types */
+
+/* The following Included files are Determined Accordingly to OS and Master: */
+#ifdef HW_MBOX_OS_LINUX
+#ifdef __KERNEL__
+/* Kernel: */
+#include <linux/byteorder/generic.h>    /* Endianness: cpu_to_be32, be32_to_cpu */
+#include <linux/string.h>               /* for memcpy\memset used in SRAM access */
+#if   defined HW_MBOX_IS_NP_CPU
+#include "puma7.h"    /* for NP_CPU Kernel HW_MBOX Base Address */
+#elif defined HW_MBOX_IS_APP_CPU
+/* include file with Kernel HW_MBOX Base Address for APP CPU */
+#endif
+#else
+/* User Space: */
+#include "endian.h"     /* Endianness: htobe32, be32toh */
+#endif // __KERNEL__
+#endif // HW_MBOX_OS_LINUX
+
+#ifdef HW_MBOX_OS_FLAT
+/* FLAT OS: */
+#include "string.h"    /* for memcpy\memset used in SRAM access */
+#if defined HW_MBOX_IS_DS_PHY_CPU
+#include "phy_cpu_defs.h"    /* for base address of the HW_MBOX and Endianness Configuration */
+#endif
+#endif // HW_MBOX_OS_FLAT
+
+/***********************************************************
+|                                                          |
+|        HW_MBOX MEMORY ACCESS (Registers and SRAM)        |
+|                                                          |
+***********************************************************/
+
+/* Implementing Memory Access Functionality for the HW_MBOX controller
+   will be done in 5 steps:
+
+   1. MAP HW_MBOX ADDRESS SPACE:
+      Map the HW_MBOX address space (Offset that each Master should use for each register or SRAM).
+
+   2. MAP HW_MBOX REGISTERS FIELDS:
+      Map the Fields in the HW_MBOX registers (bit Offset and bit Length).
+
+   3. DEFINE BASIC OPERATIONS: 
+      Define basic Macros to read and write 32 register values, handle Endianness
+      and access specific bit fields.
+
+   4. GENERIC LOW LEVEL MEM ACCESS MACRO TEMPLATES:
+      Define low level generic Macros that enable simple operations: get/set reg32
+      get/set field32 and set bit32 with a specific template.
+
+      If direct access can be used and the base address is known in advance (i.e. Linux
+      Kernel) then these will be defined here. 
+
+      Otherwise (Indirect access) matching name Macros must be defined in the file that
+      can handle the access (i.e. hw_mbox_hal for Linux User Space application access).
+      See section 4 for more details on what macros should be defined.
+
+      SRAM access will also be defined here as it is relatively generic and very platform
+      specific.
+
+   5. SPECIFIC REGISTERS & FIELDS ACCESS MACROS:
+      Define Get/Set Macros for all registers and Fields utilizing the generic Macros
+      (set up at 4) and the basic operations (set up at 3). Using the generic Macros 
+      and basic operation enables to define these once.
+*/
+
+
+/*********************************************
+|                                            |
+|        1. MAP HW_MBOX ADDRESS SPACE        |
+|                                            |
+*********************************************/
+
+/* 
+    Each Master has a different Address space to access to HW_MBOX memory (Registers and SRAM).
+    The HW_MBOX determines which Master is Accessing it according to the address used. Using
+    this information the HW_MBOX can enforce Access Protection.
+ 
+    This section includes the calculation of the proper offsets to be used by every Master.
+ 
+    Under normal conditions the MID is predetermined, therefore most of the calculations will
+    be optimized under "constant folding". This excludes Macros that we want to receive a
+    parameter such as the channel register offsets (one define that will work for all channels).
+ 
+    Another exception will be the Debug feature "MID Disguise": Under this feature we add the
+    option to change the MID on the fly, during runtime.
+ 
+    There are 4 groups (types) of registers:
+    1. Control Registers - contains general information regarding the HW_MBOX setup (shared among Masters).
+    2. Master Registers - contains information relevant for each Master (one set per Master).
+    3. Channel Registers - contains information relevant for each Channel (one set per Channel).
+    4. Memory Map Registers - contains SRAM allocated to each Master (one register per Channel).
+
+    The Address to be used can be Mapped using the Following table (relative to HW_MBOX Base Address):
+ 
+                           +------------------------------------------------------------------------------------+
+      USAGE          bits  | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |    
+    +----------------------+------------------------------------------------------------------------------------+
+    | Control Registers    |  ACCESS MODIFIER  |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  INTERNAL OFFSET  |  
+    +-----------------------------------------------------------------------------------------------------------+
+    | Master Registers     |  ACCESS MODIFIER  |  0 |  0 |  1 |  MID SUBGROUP     |            INTERNAL OFFSET  |
+    +-----------------------------------------------------------------------------------------------------------+
+    | Channel Registers    |  ACCESS MODIFIER  |  0 |  1 |  0 |  CID SUBGROUP               |  INTERNAL OFFSET  |
+    +-----------------------------------------------------------------------------------------------------------+
+    | Memory Map Registers |  ACCESS MODIFIER  |  0 |  1 |  1 |  CID SUBGROUP               |  INTERNAL OFFSET  |
+    +-----------------------------------------------------------------------------------------------------------+
+    | SRAM                 |  ACCESS MODIFIER  |  1 |            SRAM OFFSET                                    |
+    +-----------------------------------------------------------------------------------------------------------+
+ 
+    ACCESS MODIFIER is the MID of the Master performing the Access to the HW_MBOX.
+    SUBGROUP values are determined according to which Channel or Master we are observing (CID/MID).
+    GROUP_OFFSET (denoted later on) are the value of bits [12:10].
+    SRAM_INTERNAL_OFFSET (denoted later on) is (bit(12) = 1) for SRAM.  
+*/ 
+
+#ifdef HW_MBOX_DEBUG
+/* MID Disguise feature:
+
+   Under Debug we have the ability to change the MID of the current Master on the fly, during runtime.
+   This effects: <ACCESS MODIFIER> for all access and <MID SUBGROUP> when accessing our own Master registers.
+*/
+
+#undef HW_MBOX_MID                            /* Undefine the Hardcoded original value */
+#define HW_MBOX_MID ( __debug_HW_MBOX_MID )   /* redefine as a global variable [so will be able to change during runtime] */
+
+/*! \var volatile Uint32 __debug_HW_MBOX_MID
+    \brief changeable MID field for Debug.
+    \attention set by using __HW_MBOX_DEBUG_SET_MID()
+    \note value starts off as 0.
+*/
+volatile Uint32 __debug_HW_MBOX_MID;
+
+/*! \def __HW_MBOX_DEBUG_SET_MID(newMID)
+    \brief set Debug MID to <newMID>.
+    \warning Must Use a Valid MID! 
+*/
+#define __HW_MBOX_DEBUG_SET_MID(newMID)  ( __debug_HW_MBOX_MID = (newMID) )
+#endif // HW_MBOX_DEBUG
+
+/* --- ACCESS MODIFIER (determines address space for this MID, relative to HW_MBOX BASE) --- */
+#define HW_MBOX_MEMDEFS_ACCESS_MODIFIER(paramMID)   ((paramMID) << 13)    /*!   ((paramMID) * 0x2000)   */
+
+/* --- GROUP OFFSETS (Relative to this MIDs Address Space) --- */
+#define HW_MBOX_REGDEFS_CONTROL_GROUP_OFFSET       (0x0)    /*!  bits[12:10] = [0 0 0]  */
+#define HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET        (0x400)  /*!  bits[12:10] = [0 0 1]  */
+#define HW_MBOX_REGDEFS_CHANNEL_GROUP_OFFSET       (0x800)  /*!  bits[12:10] = [0 1 0]  */
+#define HW_MBOX_REGDEFS_MEMORY_MAP_GROUP_OFFSET    (0xC00)  /*!  bits[12:10] = [0 1 1]  */
+
+/* --- SUBGROUP OFFSETS (Relative to Group Offset) --- */
+#define HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(paramMID)     ((paramMID) << 6)    /*!    ((paramMID) * 0x40)    */
+#define HW_MBOX_REGDEFS_CID_SUBGROUP_OFFSET(paramCID)     ((paramCID) << 4)    /*!    ((paramCID) * 0x10)    */
+#define HW_MBOX_REGDEFS_MMAP_SUBGROUP_OFFSET(paramCID)    ((paramCID) << 4)    /*!    ((paramCID) * 0x10)    */
+
+
+/* --- CONTROL REGISTER OFFSETS (Relative to Group Offset) --- */
+#define HW_MBOX_REGDEFS_ID_INTERNAL_OFFSET       (0x0)
+#define HW_MBOX_REGDEFS_CTRL_INTERNAL_OFFSET     (0x4)
+#define HW_MBOX_REGDEFS_ERROR_INTERNAL_OFFSET    (0x8)
+
+/* ---MASTER REGISTER OFFSETS (Relative to Subgroup Offset) --- */
+#define HW_MBOX_REGDEFS_MASTER_INTR_STATUS_L_INTERNAL_OFFSET    (0x0)
+#define HW_MBOX_REGDEFS_MASTER_INTR_STATUS_H_INTERNAL_OFFSET    (0x4)
+#define HW_MBOX_REGDEFS_MASTER_INTR_MASK_L_INTERNAL_OFFSET      (0x8)
+#define HW_MBOX_REGDEFS_MASTER_INTR_MASK_H_INTERNAL_OFFSET      (0xC)
+#define HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_L_INTERNAL_OFFSET     (0x10)
+#define HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_H_INTERNAL_OFFSET     (0x14)
+#define HW_MBOX_REGDEFS_MASTER_COMMANDER_L_INTERNAL_OFFSET      (0x18)
+#define HW_MBOX_REGDEFS_MASTER_COMMANDER_H_INTERNAL_OFFSET      (0x1C)
+#define HW_MBOX_REGDEFS_MASTER_SUBJECT_L_INTERNAL_OFFSET        (0x20)
+#define HW_MBOX_REGDEFS_MASTER_SUBJECT_H_INTERNAL_OFFSET        (0x24)
+
+/* --- Channel Register Offsets (Relative to Group Offset) --- */
+#define HW_MBOX_REGDEFS_CHN_CFG_INTERNAL_OFFSET        (0x0)
+#define HW_MBOX_REGDEFS_CHN_COMMAND_INTERNAL_OFFSET    (0x4)
+#define HW_MBOX_REGDEFS_CHN_STATE_INTERNAL_OFFSET      (0x8)
+
+/* --- Memory Map Register Offsets (Relative to Group Offset) --- */
+#define HW_MBOX_REGDEFS_MEMORY_MAP_INTERNAL_OFFSET    (0x0)
+
+/******************************************
+        Register Offset Calculation        
+******************************************/
+
+/* Now to do the actual calculation of the Offsets:
+ 
+   OFFSET = ACCESS_MODIFIER + GROUP_OFFSET + [Optional] SUBGROUP_OFFSET + INTERNAL_OFFSET
+
+   ACCESS_MODIFIER: According to current MID, translates the request to specific Master's Address Space
+                    [To mark which Master is accessing to HW_MBOX HW (so Access Protection can be enforced)].
+
+   GROUP_OFFSET: According to register group, relative to this MIDs Address Space.
+
+   SUBGROUP_OFFSET: (optional) only used when there are a few subgroup inside a group
+                    e.g. A set of 3 channel registers, per every one of the 64 channel.
+
+   INTERNAL_OFFSET: According to the specific register, relative to group (or subgroup if it exists).
+
+   Please note that we will use a constant naming template for all #defines:
+   register offset: #define HW_MBOX_<regName>_OFFSET
+
+    * regName should always start with REGDEFS_
+
+*/
+
+/* --- General Registers --- */
+#define HW_MBOX_REGDEFS_ID_OFFSET    ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_CONTROL_GROUP_OFFSET + HW_MBOX_REGDEFS_ID_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_CTRL_OFFSET  ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_CONTROL_GROUP_OFFSET + HW_MBOX_REGDEFS_CTRL_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_ERROR_OFFSET ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_CONTROL_GROUP_OFFSET + HW_MBOX_REGDEFS_ERROR_INTERNAL_OFFSET )
+
+/* --- Master Registers --- */
+#define HW_MBOX_REGDEFS_MASTER_INTR_STATUS_L_OFFSET ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_INTR_STATUS_L_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_INTR_STATUS_H_OFFSET ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_INTR_STATUS_H_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_INTR_MASK_L_OFFSET   ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_INTR_MASK_L_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_INTR_MASK_H_OFFSET   ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_INTR_MASK_H_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_L_OFFSET  ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_L_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_H_OFFSET  ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_H_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_COMMANDER_L_OFFSET   ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_COMMANDER_L_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_COMMANDER_H_OFFSET   ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_COMMANDER_H_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_SUBJECT_L_OFFSET     ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_SUBJECT_L_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_SUBJECT_H_OFFSET     ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_SUBJECT_H_INTERNAL_OFFSET )
+
+/* --- Channel Registers --- */
+#define HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID)     ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_CHANNEL_GROUP_OFFSET + HW_MBOX_REGDEFS_CID_SUBGROUP_OFFSET(paramCID) + HW_MBOX_REGDEFS_CHN_CFG_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_CHN_COMMAND_OFFSET(paramCID) ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_CHANNEL_GROUP_OFFSET + HW_MBOX_REGDEFS_CID_SUBGROUP_OFFSET(paramCID) + HW_MBOX_REGDEFS_CHN_COMMAND_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_CHN_STATE_OFFSET(paramCID)   ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_CHANNEL_GROUP_OFFSET + HW_MBOX_REGDEFS_CID_SUBGROUP_OFFSET(paramCID) + HW_MBOX_REGDEFS_CHN_STATE_INTERNAL_OFFSET )
+
+/* --- Memory Map Registers --- */
+#define HW_MBOX_REGDEFS_MEMORY_MAP_OFFSET(paramCID) ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MEMORY_MAP_GROUP_OFFSET + HW_MBOX_REGDEFS_MMAP_SUBGROUP_OFFSET(paramCID) + HW_MBOX_REGDEFS_MEMORY_MAP_INTERNAL_OFFSET )
+
+/***************************************************
+        Parametric Master Registers Mapping        
+***************************************************/
+
+/* These are defined for the purpose of accessing other Master's Master Registers.
+   Generally speaking each Master should only involve itself with its own Master Registers.
+   Still we should map these as we might need to read their values for research purposes.
+   Unless In Package Debug We avoid mapping the interrupt status registers as access to them might prove to be disastrous.
+ 
+   NOTE: The access is done from the MID associated with the current Master!
+*/
+
+#define HW_MBOX_REGDEFS_MASTER_PARAM_INTR_MASK_L_OFFSET(paramMID)   ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(paramMID) + HW_MBOX_REGDEFS_MASTER_INTR_MASK_L_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_PARAM_INTR_MASK_H_OFFSET(paramMID)   ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(paramMID) + HW_MBOX_REGDEFS_MASTER_INTR_MASK_H_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_PARAM_INTR_CLEAR_L_OFFSET(paramMID)  ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(paramMID) + HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_L_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_PARAM_INTR_CLEAR_H_OFFSET(paramMID)  ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(paramMID) + HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_H_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_PARAM_COMMANDER_L_OFFSET(paramMID)   ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(paramMID) + HW_MBOX_REGDEFS_MASTER_COMMANDER_L_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_PARAM_COMMANDER_H_OFFSET(paramMID)   ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(paramMID) + HW_MBOX_REGDEFS_MASTER_COMMANDER_H_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_PARAM_SUBJECT_L_OFFSET(paramMID)     ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(paramMID) + HW_MBOX_REGDEFS_MASTER_SUBJECT_L_INTERNAL_OFFSET )
+#define HW_MBOX_REGDEFS_MASTER_PARAM_SUBJECT_H_OFFSET(paramMID)     ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_REGDEFS_MASTER_GROUP_OFFSET + HW_MBOX_REGDEFS_MID_SUBGROUP_OFFSET(paramMID) + HW_MBOX_REGDEFS_MASTER_SUBJECT_H_INTERNAL_OFFSET )
+
+/*******************************************
+        HW_MBOX SRAM Address Mapping        
+*******************************************/
+
+#define HW_MBOX_MEMDEFS_SRAM_INTERNAL_OFFSET    (0x1000)  /*!  bit(12) = 1  */
+
+/*! \def HW_MBOX_MEMDEFS_SRAM_OFFSET(internalByteOffset)
+    \brief Get HW_MBOX SRAM offset relative to HW_MBOX Base Address.
+    \param[in] internalByteOffset - offset in Bytes with regards to the SRAM's 4KB total actual size.
+*/
+#define HW_MBOX_MEMDEFS_SRAM_OFFSET(internalByteOffset)    ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MID) + HW_MBOX_MEMDEFS_SRAM_INTERNAL_OFFSET + (internalByteOffset) )
+
+#define HW_MBOX_SRAM_SIZE    (0x1000)  /*! 4KB SRAM (total actual size) */
+
+/**********************************************
+        HW_MBOX Special Address Mapping        
+**********************************************/
+
+/*! \def HW_MBOX_REGDEFS_CTRL_AS_DEFAULT_SUPERVISOR_OFFSET
+    \brief Use this offset to change supervisor at initialization.
+    \note This offset accesses the CTRL register as the default supervisor (NP_CPU).
+    \note This is needed as access to this offset from another Master will trigger access violation.
+*/
+#define HW_MBOX_REGDEFS_CTRL_AS_DEFAULT_SUPERVISOR_OFFSET ( HW_MBOX_MEMDEFS_ACCESS_MODIFIER(HW_MBOX_MASTER_NP_CPU) + HW_MBOX_REGDEFS_CONTROL_GROUP_OFFSET + HW_MBOX_REGDEFS_CTRL_INTERNAL_OFFSET )
+
+
+/************************************************
+|                                               |
+|        2. MAP HW_MBOX REGISTERS FIELDS        |
+|                                               |
+************************************************/
+
+/* This Section will list all the HW_MBOX registers structure, followed
+   by a declaration (via #define) of the bit offset and bit length of each
+   field. 
+
+   Please note that we will use a constant naming template for all #defines:
+   field bit offset: #define HW_MBOX_<fieldName>_OFFSET
+   field bit length: #define HW_MBOX_<fieldName>_LENGTH
+
+    * fieldName should always start with FLDDEFS_
+*/
+
+/********************************
+        CONTROL REGISTERS        
+********************************/
+
+/* These registers contain general control data and settings of the HW_MBOX. */
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_ID
+    +---------------------------------------------------------------------------+
+    |   MAJOR   |   MINOR   |   RESERVED                                        |
+    |   31:28   |   27:24   |   23:0                                            |
+    |   RO      |   RO      |   RO                                              |
+    +---------------------------------------------------------------------------/
+
+    MAJOR - Identifies core version (Major).
+    MINOR - Identifies core version (Minor).
+*/
+
+#define HW_MBOX_FLDDEFS_MAJOR_OFFSET (28)
+#define HW_MBOX_FLDDEFS_MAJOR_LENGTH (4)
+
+#define HW_MBOX_FLDDEFS_MINOR_OFFSET (24)
+#define HW_MBOX_FLDDEFS_MINOR_LENGTH (4)
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_CTRL
+    +---------------------------------------------------------------------------+
+    |   RESERVED      | MON_EXIST | MONITOR | LOCK | DEBUG | START | SUPERVISOR |
+    |   31:12         | 11        | 10:7    | 6    | 5     | 4     | 3:0        |
+    |   RO            | RW        | RW      | RWO  | RW    | RW    | RW         |
+    +---------------------------------------------------------------------------/
+
+    NOTE: only the supervisor should write to this register (preferably) until 
+          setting START=TRUE. Once setting LOCK=TRUE the register is RO.
+
+    MON_EXIST - 0 indicates that there is no Monitor.
+                1 indicates that a monitor exists.
+
+    MONITOR - MID of the Monitor Master. This field is relevant only if MON_EXIST=1.
+
+    LOCK - 1 indicates that the MBOX is Locked. The Supervisor can set this bit.
+           Once set, the register is RO.
+
+    DEBUG - 1 indicates that the MBOX is in debug mode, enabling any Master
+            to access MBOX registers without limitations.
+
+    START - 1 indicates that the MBOX is configured and functional. 
+            0 indicates that the MBOX is not configured yet, and the Channels cannot 
+              be used by the Masters.
+
+    SUPERVISOR - MID of the Supervisor.
+*/
+
+#define HW_MBOX_FLDDEFS_MON_EXIST_OFFSET (11)
+#define HW_MBOX_FLDDEFS_MON_EXIST_LENGTH (1)
+
+#define HW_MBOX_FLDDEFS_MONITOR_OFFSET (7)
+#define HW_MBOX_FLDDEFS_MONITOR_LENGTH (4)
+
+#define HW_MBOX_FLDDEFS_LOCK_OFFSET (6)
+#define HW_MBOX_FLDDEFS_LOCK_LENGTH (1)
+
+#define HW_MBOX_FLDDEFS_DEBUG_OFFSET (5)
+#define HW_MBOX_FLDDEFS_DEBUG_LENGTH (1)
+
+/* Possible conflict as there are 2 fields named START:
+   One for the CTRL register(Here) and one in the Memory Map Registers...
+   Will not conflict as this is the real START, for mmap regs we will add
+   some prefix to make it more understandable. */
+
+#define HW_MBOX_FLDDEFS_START_OFFSET (4)
+#define HW_MBOX_FLDDEFS_START_LENGTH (1) 
+
+#define HW_MBOX_FLDDEFS_SUPERVISOR_OFFSET (0)
+#define HW_MBOX_FLDDEFS_SUPERVISOR_LENGTH (4)
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_ERROR
+    +---------------------------------------------------------------------------+
+    |   RESERVED               | COUNT                |  RESERVED  |  ERR       |
+    |   31:16                  | 15:8                 |  7:4       |  3:0       |
+    |   RO                     | RW                   |  RO        |  RO        |
+    +---------------------------------------------------------------------------/
+
+    NOTE: only the supervisor has write access to this register.
+
+    COUNT - Incremented by one upon error detection.
+            Halts when reached the max value (255).
+            Supervisor can clear it by writing 0.
+
+    ERR - The value of the MID of the last HW_MBOX access which violated
+          the protection rules. By default ERR=0.
+*/
+
+/* Adding the word ERROR even though the Field 
+   is called COUNT to make it more understandable. */
+#define HW_MBOX_FLDDEFS_ERROR_COUNT_OFFSET  (8)
+#define HW_MBOX_FLDDEFS_ERROR_COUNT_LENGTH  (8)
+
+/* Adding the word MID even though the Field
+   is called ERR to make it more understandable. */
+#define HW_MBOX_FLDDEFS_ERRMID_OFFSET  (0)
+#define HW_MBOX_FLDDEFS_ERRMID_LENGTH  (4)
+
+/*******************************
+        MASTER REGISTERS        
+*******************************/
+
+/* These Registers contain data related to the Masters. There's a set of these registers
+   for each MASTER.
+
+   These Registers do not contain fields per say, but rather each pair (*_L and *_H) of
+   them is divided into 64 one bit fields. Each field signifies the Channel with a CID
+   corresponding to the position of the set bit [CID = (is *_H reg)*32 + (bit position)].
+   Thus, there's no need to define specific fields here. 
+
+*/
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_MASTER_INTR_STATUS_(L or H)
+    +---------------------------------------------------------------------------+
+    |   STATUS                                                                  |
+    |   31:0                                                                    |
+    |   RO                                                                      |
+    +---------------------------------------------------------------------------/
+
+    These Registers indicate which channel had an interrupt for this MASTER (according
+    to which bits are set).
+
+    NOTE: a read of these registers is always followed by a write to clear the set bits.
+          Once read the software must handle the Interrupts otherwise they'll be lost.
+          Also since there's a write after read it must comply with the access protection
+          rules.
+
+*/
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_MASTER_INTR_MASK_(L or H)
+    +---------------------------------------------------------------------------+
+    |   MASK                                                                    |
+    |   31:0                                                                    |
+    |   RW                                                                      |
+    +---------------------------------------------------------------------------/
+
+    These Registers enable to Mask channels from triggering an interrupt for this 
+    MASTER (according to which bits are set).
+
+    NOTE: a common use of these will be masking a channel in order to use polling.
+*/
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_MASTER_INTR_CLEAR_(L or H)
+    +---------------------------------------------------------------------------+
+    |   CLEAR                                                                   |
+    |   31:0                                                                    |
+    |   RW                                                                      |
+    +---------------------------------------------------------------------------/
+
+    These are Shadow registers of the interrupt status ones. Can be used for probing 
+    the Interrupt status registers without triggering the write after read. These
+    are also used when polling is desired.
+
+    NOTE: After consuming an interrupt when using polling we need to clear the corresponding
+          Interrupt bit from the interrupt status register. This is done by writing the bit
+          pattern of the consumed interrupts to this register (*_L or *_H accordingly).
+
+          Meaning:
+          Upon write of bit pattern (PATTERN) to this register [X is L or H]-
+          HW_MBOX_MASTER_INTR_STATUS_X is changed to ((~PATTERN) & HW_MBOX_MASTER_INTR_STATUS_X).
+*/
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_MASTER_COMMANDER_(L or H)
+    +---------------------------------------------------------------------------+
+    |   SET                                                                     |
+    |   31:0                                                                    |
+    |   RO                                                                      |
+    +---------------------------------------------------------------------------/
+
+    These registers indicates in which channels this MASTER is configured as COMMANDER
+    (as is configured in the channel configuration registers).
+*/
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_MASTER_SUBJECT_(L or H)
+    +---------------------------------------------------------------------------+
+    |   SET                                                                     |
+    |   31:0                                                                    |
+    |   RO                                                                      |
+    +---------------------------------------------------------------------------/
+
+    These registers indicates in which channels this MASTER is configured as SUBJECT
+    (as is configured in the channel configuration registers).
+*/
+
+/********************************
+        CHANNEL REGISTERS        
+********************************/
+
+/* These registers contain data related to the channels. There's a set of these for 
+   each channel. */
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_CHN_CFG
+    +---------------------------------------------------------------------------+
+    | VALID | RESERVED |  TYPE  |  RESERVED  |   REQ_ID   | COMMANDER | SUBJECT |
+    | 31    | 30:28    |  27:24 |  23:16     |   15:8     | 7:4       | 3:0     |
+    | RW    | RW       |  RW    |  RW        |   RW       | RW        | RW      |
+    +---------------------------------------------------------------------------/
+
+    This Register Holds the configuration of the Channel.
+
+    NOTE: only the supervisor has write access to this register and only when 
+          CTRL.START=FALSE or when CTRL.START=TRUE and VALID=FALSE.
+
+    VALID - 1 indicates valid configuration.
+            0 indicates that the channel is not allocated, and hence usage of the
+              channel is illegal.
+
+    TYPE - The Type of MBOX protocol that is employed on the channel.
+           Possible Values: COMMAND=0, EVENT=1.
+
+           * NOTE: we only need 1 bit (for 0/1 possible values). The other bits
+                   are reserved for future type expansion and byte alignment
+                   considerations of the fields.
+
+    REQ_ID - Request ID, a unique identifier (0-255 possible values) for the
+             channel configuration. This field will be set by the supervisor
+             upon configuration of the channels. This value is needed as future
+             implementation may allow 2 identical channel configuration (for Low
+             and High priority variants) in which case one cannot deterministically
+             deduce the usage of channels just by observing <TYPE, COMMANDER, SUBJECT>
+             values.
+
+             * NOTE: we only need 0-63 (as there are 64 channel). The other bits
+                     are reserved for future channel expansion and byte alignment
+                     considerations of the fields.
+
+    COMMANDER - MID of the Commander Master.
+
+    SUBJECT - MID of the Subject Master.
+*/
+
+/* Adding the word CHN even though the Fields 
+   don't have it to make it more understandable. */
+
+#define HW_MBOX_FLDDEFS_CHN_VALID_OFFSET (31)
+#define HW_MBOX_FLDDEFS_CHN_VALID_LENGTH (1)
+
+#define HW_MBOX_FLDDEFS_CHN_TYPE_OFFSET (24)
+#define HW_MBOX_FLDDEFS_CHN_TYPE_LENGTH (4)
+
+#define HW_MBOX_FLDDEFS_CHN_REQ_ID_OFFSET (8)
+#define HW_MBOX_FLDDEFS_CHN_REQ_ID_LENGTH (8)
+
+#define HW_MBOX_FLDDEFS_CHN_COMMANDER_OFFSET (4)
+#define HW_MBOX_FLDDEFS_CHN_COMMANDER_LENGTH (4)
+
+#define HW_MBOX_FLDDEFS_CHN_SUBJECT_OFFSET (0)
+#define HW_MBOX_FLDDEFS_CHN_SUBJECT_LENGTH (4)
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_CHN_COMMAND
+    +---------------------------------------------------------------------------+
+    |   COMMAND                                                                 |
+    |   31:0                                                                    |
+    |   RW                                                                      |
+    +---------------------------------------------------------------------------/
+
+    This Register is the COMMAND buffer of the Channel. Once COMMANDER writes to
+    this register the SUBJECT gets an interrupt. Once the SUBJECT writes to this
+    register the COMMANDER gets an interrupt.
+
+    NOTE: only the channel's COMMANDER and SUBJECT may write to this register.
+          These are indicated by the corresponding CHN_CFG register.
+*/
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_CHN_STATE
+    +---------------------------------------------------------------------------+
+    |   RESERVED                                                      |  STATE  |
+    |   31:2                                                          |  1:0    |
+    |   RW                                                            |  RW     |
+    +---------------------------------------------------------------------------/
+
+    NOTE: only the supervisor has write access to this register and can do so 
+          at any time (even when CTRL.LOCK=TRUE). Any write to this register will
+          reset the channel (Channel goes back to state ready and any possibly 
+          pending interrupt is cleared).
+
+    STATE - Possible values are:
+            Ready=0, Pending=1, Consume=2, Done=3.
+*/
+
+/* Adding the word CHN even though the Fields 
+   don't have it to make it more understandable. */
+
+#define HW_MBOX_FLDDEFS_CHN_STATE_OFFSET (0)
+#define HW_MBOX_FLDDEFS_CHN_STATE_LENGTH (2)
+
+/***********************************
+        MEMORY MAP REGISTERS        
+***********************************/
+
+/* There's one Memory Map Register per channel. It contains the section in the 
+   HW_MBOX SRAM that is allocated to this channel. According to this and the
+   values listed in the CHN_CFG register access protection is enforced (only 
+   the COMMANDER and SUBJECT of the channel may access the allocated SRAM 
+   section). */
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_REG_MEMORY_MAP
+    +---------------------------------------------------------------------------+
+    | RESERVED |    SIZE                  | RESERVED |    START                 |
+    | 31:28    |    27:16                 | 15:12    |    11:0                  |
+    | RW       |    RW                    |  RO      |    RW                    |
+    +---------------------------------------------------------------------------/
+
+    NOTE: only the supervisor has write access to this register and only when 
+          CTRL.LOCK=FALSE.
+
+    SIZE - The size in bytes of the region in SRAM allocated to Channel CID.
+           SIZE is integral multiple of 4.
+
+    START - A 4 bytes aligned offset within the SRAM to the beginning of
+            the region allocated to Channel CID.
+*/
+
+/* Adding the word MMAP to make it more understandable. 
+   (and prevent possible conflict with another field named START in the CTRL reg). */
+
+#define HW_MBOX_FLDDEFS_MMAP_SIZE_OFFSET (16)
+#define HW_MBOX_FLDDEFS_MMAP_SIZE_LENGTH (12)
+
+#define HW_MBOX_FLDDEFS_MMAP_START_OFFSET (0)
+#define HW_MBOX_FLDDEFS_MMAP_START_LENGTH (12)
+
+
+/*******************************************
+|                                          |
+|        3. DEFINE BASIC OPERATIONS        |
+|                                          |
+*******************************************/
+
+/* This section contains basic functionality that we will use later on
+   to define the more complex access function to the HW_MBOX memory. */
+
+/*******************************
+        Basic Mem Access        
+*******************************/
+#ifdef HW_MBOX_IS_APP_CPU
+#define HW_MBOX_REG32_READ(address)                  ( HW_MBOX_CONVERT_FROM_BIG_ENDIAN32(__raw_readl(address)) )
+#define HW_MBOX_REG32_WRITE(address, value)          (__raw_writel( HW_MBOX_CONVERT_TO_BIG_ENDIAN32(value), address) )
+#else
+#define HW_MBOX_REG32(address)                  ( *(volatile Uint32 *)(address) )
+#define HW_MBOX_REG32_READ(address)             ( HW_MBOX_CONVERT_FROM_BIG_ENDIAN32(HW_MBOX_REG32(address)) )
+#define HW_MBOX_REG32_WRITE(address, value)     ( (HW_MBOX_REG32(address)) = (HW_MBOX_CONVERT_TO_BIG_ENDIAN32(value)) )
+#endif
+
+/********************************
+        HANDLE Endianness        
+********************************/
+
+/* HW_MBOX memory should be kept BE, all arithmetic operations 
+   should be done using CPU's native endianness. */
+
+#ifdef HW_MBOX_OS_LINUX
+#ifdef __KERNEL__
+#define HW_MBOX_CONVERT_TO_BIG_ENDIAN32(val)    cpu_to_be32(val)
+#define HW_MBOX_CONVERT_FROM_BIG_ENDIAN32(val)  be32_to_cpu(val)
+#else
+#define HW_MBOX_CONVERT_TO_BIG_ENDIAN32(val)    htobe32(val)
+#define HW_MBOX_CONVERT_FROM_BIG_ENDIAN32(val)  be32toh(val)
+#endif // __KERNEL__
+#endif // HW_MBOX_OS_LINUX
+#ifdef HW_MBOX_OS_FLAT
+#if defined HW_MBOX_IS_DS_PHY_CPU
+#if     defined PHY_CPU_LITTLE_ENDIAN
+#define HW_MBOX_CONVERT_TO_BIG_ENDIAN32(val)    phy_cpu_swab32(val)
+#define HW_MBOX_CONVERT_FROM_BIG_ENDIAN32(val)  phy_cpu_swab32(val)
+#elif   defined PHY_CPU_BIG_ENDIAN
+#define HW_MBOX_CONVERT_TO_BIG_ENDIAN32(val)    (val)
+#define HW_MBOX_CONVERT_FROM_BIG_ENDIAN32(val)  (val)
+#else
+#   error "HW_MBOX mem access (PHY_CPU): endianness undefined!!!"
+#endif
+#endif // HW_MBOX_IS_DS_PHY_CPU
+#endif // HW_MBOX_OS_FLAT
+
+/***********************************************
+        Bit-Field Manipulation Functions        
+***********************************************/
+
+/*! \fn Uint32 hw_mbox_field32_get(Uint32 regData, Uint32 fieldOffset, Uint32 fieldLength)
+ *  \brief gets the value of a specific bit-field from a given 32-bit value (in CPU native endianness)
+ *  \param[in] regData - the value from which to extract the bit-field (in CPU native endianness) 
+ *  \param[in] fieldOffset - the offset (in bits) of the required bit-field
+ *  \param[in] fieldLength - the number of bits in the required bit-field
+ *  \return bit-field value (in CPU native endianness).
+ */
+static inline Uint32 hw_mbox_field32_get(Uint32 regData, Uint32 fieldOffset, Uint32 fieldLength)
+{
+    Uint32 mask;
+    mask = ((0xFFFFFFFF >> (32 - fieldLength)) << fieldOffset);
+    return ((regData & mask) >> fieldOffset);
+}
+
+/*! \fn Uint32 hw_mbox_field32_set(Uint32 regData, Uint32 fieldOffset, Uint32 fieldLength, Uint32 fieldData)
+ *  \brief sets the value of a specific bit-field in a given 32-bit value (in CPU native endianness)
+ *  \param[in] regData - the value to which the bit-field should be written to (in CPU native endianness)
+ *  \param[in] fieldOffset - the offset (in bits) of the required bit-field
+ *  \param[in] fieldLength - the number of bits in the required bit-field
+ *  \param[in] fieldData - the value of the bit-field to be written
+ *  \return the new 32-bit value with the new field value set inside (in CPU native endianness). 
+ */
+static inline Uint32 hw_mbox_field32_set(Uint32 regData, Uint32 fieldOffset, Uint32 fieldLength, Uint32 fieldData)
+{
+    Uint32 mask;
+    mask = ((0xFFFFFFFF >> (32 - fieldLength)) << fieldOffset);
+    regData &= (~mask); 
+    regData |= (mask & (fieldData << fieldOffset));
+    return regData;
+}
+
+/****************************************************************
+|                                                               |
+|        4. GENERIC LOW LEVEL MEM ACCESS MACRO TEMPLATES        |
+|                                                               |
+****************************************************************/
+
+/*
+    As Mentioned before regarding register Access there are 2 cases:
+
+    1. Direct Access - In this case Base Address of the HW_MBOX is always the same, Hardcoded 
+                       determined by system architecture and Low Level memory access is enabled 
+                       (i.e. Linux KERNEL of FLAT OS CPU). We can define the generic access Macros
+                       here.
+
+    2. Indirect Access - In this case Base Address of the HW_MBOX is a not yet determined
+                         parameter which will be later decided (i.e. according to mmap call
+                         for LINUX user space). Direct access to memory can't be used.
+
+                         An intermediate Layer mitigating the actual Access Must be Used!
+                         Due to this need the generic access macros will be defined in the
+                         file that can handle the access (i.e. hw_mbox_hal for Linux User Space).
+
+    IMPORTANT NOTE: If including this file and taking the Indirect Access route you are obliged
+                    to define these Generic Access Macros with same structure (parameters and
+                    functionality), the Macros that should be defined are:
+                    
+                    HW_MBOX_REG_GET(regOffset)          returning Uint32
+                    HW_MBOX_REG_SET(regOffset, value)   returning void
+                    
+                    HW_MBOX_FIELD_GET(regOffset, fieldOffset, fieldLength)          returning Uint32
+                    HW_MBOX_FIELD_SET(regOffset, fieldOffset, fieldLength, value)   returning void
+
+                    HW_MBOX_BIT_SET_VALUE(regOffset, bitPosition, bitVal)   returning void 
+
+    SRAM Access:
+
+    These are generic functions anyways: If using Direct Define here, else define in the wrapping Layer.
+
+*/
+
+#if ((defined(HW_MBOX_OS_LINUX) && defined(__KERNEL__)) || defined(HW_MBOX_OS_FLAT) || defined(HW_MBOX_OS_NONE))
+
+/* Define HW_MBOX Base address here: */
+#if   defined HW_MBOX_IS_NP_CPU
+#define HW_MBOX_BASE    AVALANCHE_MAILBOX
+#elif defined HW_MBOX_IS_APP_CPU
+#define HW_MBOX_BASE hwMboxDriverData.reg_base
+#elif defined HW_MBOX_IS_DS_PHY_CPU
+#define HW_MBOX_BASE    PHY_CPU_HW_MBOX_BASE
+#else
+#define HW_MBOX_BASE    (0) /* TBD: MoCA/BBU/anyNoOS CPU can put it here */
+#endif
+
+/******************************************************************************
+        Generic Low Level Mem Access Macro Templates For Direct Access:        
+******************************************************************************/
+
+#define HW_MBOX_REG_GET(regOffset)           HW_MBOX_REG32_READ(regOffset + HW_MBOX_BASE)
+#define HW_MBOX_REG_SET(regOffset, value)    HW_MBOX_REG32_WRITE(regOffset + HW_MBOX_BASE, value)
+
+#define HW_MBOX_FIELD_GET(regOffset, fieldOffset, fieldLength)    hw_mbox_field32_get(HW_MBOX_REG_GET(regOffset), \
+                                                                                      fieldOffset,                \
+                                                                                      fieldLength)
+
+#define HW_MBOX_FIELD_SET(regOffset, fieldOffset, fieldLength, value)    HW_MBOX_REG_SET(regOffset,                                      \
+                                                                                         hw_mbox_field32_set(HW_MBOX_REG_GET(regOffset), \
+                                                                                                             fieldOffset,                \
+                                                                                                             fieldLength,                \
+                                                                                                             value))
+
+#define HW_MBOX_BIT_SET_VALUE(regOffset, bitPosition, bitVal)    HW_MBOX_REG_SET(regOffset,                                            \
+                                                                                 hw_mbox_field32_set(HW_MBOX_REG_GET(regOffset),       \
+                                                                                                     bitPosition, 1, bitVal))
+/* SRAM ACCESS: */
+
+#define HW_MBOX_POINTER_TO_SRAM(sramOffset)                              ((Uint8 *)(HW_MBOX_MEMDEFS_SRAM_OFFSET(sramOffset) + HW_MBOX_BASE))
+#define HW_MBOX_COPY_FROM_SRAM(srcSramOffset, srcSramLen, pDestBuffer)   memcpy(pDestBuffer, HW_MBOX_POINTER_TO_SRAM(srcSramOffset), srcSramLen)
+#define HW_MBOX_COPY_TO_SRAM(pSrcBuffer, srcBufferLen, destSramOffset)   memcpy(HW_MBOX_POINTER_TO_SRAM(destSramOffset), pSrcBuffer, srcBufferLen)
+#define HW_MBOX_RESET_SRAM(sramOffset, sramLen)                          memset(HW_MBOX_POINTER_TO_SRAM(sramOffset), 0, sramLen)
+
+#endif // ((defined(HW_MBOX_OS_LINUX) && defined(__KERNEL__)) || defined(HW_MBOX_OS_FLAT) || defined(HW_MBOX_OS_NONE))
+
+
+/*************************************************************
+|                                                            |
+|        5. SPECIFIC REGISTERS & FIELDS ACCESS MACROS        |
+|                                                            |
+*************************************************************/
+
+/* These are shared by both direct and Indirect due to the use of the Generic Intermediate Layer! [defined at step 4] */
+
+/*************************************
+        SINGLE BIT OPERATIONS:        
+*************************************/
+
+#define HW_MBOX_BIT_SET(regOffset, bitPosition)      HW_MBOX_BIT_SET_VALUE(regOffset, bitPosition, 1)
+#define HW_MBOX_BIT_UNSET(regOffset, bitPosition)    HW_MBOX_BIT_SET_VALUE(regOffset, bitPosition, 0)
+
+/********************************
+        CONTROL REGISTERS        
+********************************/
+
+/* --------------------------------------------------------------------------- */
+/* HW_MBOX_ID_REG: */
+
+/*! HW_MBOX_ID: Identifies the core version. */
+#define HW_MBOX_ID_REG_GET()      HW_MBOX_REG_GET(HW_MBOX_REGDEFS_ID_OFFSET)
+
+/*! HW_MBOX_ID: MAJOR - Bits[31:28], RO, Identifies core version (Major). */
+#define HW_MBOX_ID_MAJOR_GET()    HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_ID_OFFSET, HW_MBOX_FLDDEFS_MAJOR_OFFSET, HW_MBOX_FLDDEFS_MAJOR_LENGTH)
+
+/*! HW_MBOX_ID: MINOR - Bits[27:24], RO, Identifies core version (Minor). */
+#define HW_MBOX_ID_MINOR_GET()    HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_ID_OFFSET, HW_MBOX_FLDDEFS_MINOR_OFFSET, HW_MBOX_FLDDEFS_MINOR_LENGTH)
+
+/* --------------------------------------------------------------------------- */
+/* HW_MBOX_CTRL_REG: */
+
+/* NOTE: only the supervisor has write access to this register (preferably when START=FALSE).
+         When LOCK is set this register becomes RO. */
+
+/*! HW_MBOX_CTRL: Control and General Configuration information. */
+#define HW_MBOX_CTRL_REG_GET()              HW_MBOX_REG_GET(HW_MBOX_REGDEFS_CTRL_OFFSET)
+
+/*! HW_MBOX_CTRL: MON_EXIST - Bit(11), RW, indicates whether a monitor exists. */
+#define HW_MBOX_CTRL_MON_EXIST_GET()        HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_MON_EXIST_OFFSET, HW_MBOX_FLDDEFS_MON_EXIST_LENGTH)
+#define HW_MBOX_CTRL_MON_EXIST_SET(value)   HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_MON_EXIST_OFFSET, HW_MBOX_FLDDEFS_MON_EXIST_LENGTH, value)
+
+/*! HW_MBOX_IS_MON_EXIST(): Use this Macro to find out if there's a Monitor set. */
+#define HW_MBOX_IS_MON_EXIST()             (HW_MBOX_CTRL_MON_EXIST_GET() == True)
+
+/*! HW_MBOX_CTRL: MONITOR - Bits[10:7], RW, MID of the monitor (only relevant if MON_EXIST=TRUE). */
+#define HW_MBOX_CTRL_MONITOR_GET()         HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_MONITOR_OFFSET, HW_MBOX_FLDDEFS_MONITOR_LENGTH)
+#define HW_MBOX_CTRL_MONITOR_SET(value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_MONITOR_OFFSET, HW_MBOX_FLDDEFS_MONITOR_LENGTH, value)
+
+/*! HW_MBOX_CTRL: LOCK - Bit(6), RWO, indicates whether the MBOX is Locked (once set becomes RO). */
+#define HW_MBOX_CTRL_LOCK_GET()         HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_LOCK_OFFSET, HW_MBOX_FLDDEFS_LOCK_LENGTH)
+#define HW_MBOX_CTRL_LOCK_SET(value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_LOCK_OFFSET, HW_MBOX_FLDDEFS_LOCK_LENGTH, value)
+
+/*! HW_MBOX_LOCK(): Use this Macro to LOCK the HW_MBOX (irreversible, Making all configuration constant)! */
+#define HW_MBOX_LOCK()    HW_MBOX_CTRL_LOCK_SET(True)     /* No need for Unlock since Once locked becomes RO */
+
+/*! HW_MBOX_IS_LOCK(): Use this Macro to find out if the HW_MBOX is Locked. */
+#define HW_MBOX_IS_LOCK()    (HW_MBOX_CTRL_LOCK_GET() == True)
+
+/*! HW_MBOX_CTRL: DEBUG - Bit(5), RW, indicates whether the MBOX is in debug mode. */
+#define HW_MBOX_CTRL_DEBUG_GET()         HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_DEBUG_OFFSET, HW_MBOX_FLDDEFS_DEBUG_LENGTH)
+#define HW_MBOX_CTRL_DEBUG_SET(value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_DEBUG_OFFSET, HW_MBOX_FLDDEFS_DEBUG_LENGTH, value)
+
+/*! HW_MBOX_IS_DEBUG(): Use this Macro to find out if the HW_MBOX is Hardware Debug Mode. */
+#define HW_MBOX_IS_DEBUG()    (HW_MBOX_CTRL_DEBUG_GET() == True)
+
+/*! HW_MBOX_CTRL: START - Bit(4), RW, indicates whether the MBOX is configured and functional. */
+#define HW_MBOX_CTRL_START_GET()         HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_START_OFFSET, HW_MBOX_FLDDEFS_START_LENGTH)
+#define HW_MBOX_CTRL_START_SET(value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_START_OFFSET, HW_MBOX_FLDDEFS_START_LENGTH, value)
+
+/*! HW_MBOX_IS_STARTED(): Use this Macro to find out if the HW_MBOX Hardware is ready with initial configuration set. */
+#define HW_MBOX_IS_STARTED()    (HW_MBOX_CTRL_START_GET() == True)
+
+/*! HW_MBOX_CTRL: SUPERVISOR - Bits[3:0], RW, MID of the SUPERVISOR. */
+#define HW_MBOX_CTRL_SUPERVISOR_GET()         HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_SUPERVISOR_OFFSET, HW_MBOX_FLDDEFS_SUPERVISOR_LENGTH)
+#define HW_MBOX_CTRL_SUPERVISOR_SET(value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CTRL_OFFSET, HW_MBOX_FLDDEFS_SUPERVISOR_OFFSET, HW_MBOX_FLDDEFS_SUPERVISOR_LENGTH, value)
+
+/*! HW_MBOX_IS_SUPERVISOR(): Use this Macro to find out if the current Master is the supervisor. */
+#define HW_MBOX_IS_SUPERVISOR()    (HW_MBOX_CTRL_SUPERVISOR_GET() == HW_MBOX_MID)
+
+/* --------------------------------------------------------------------------- */
+/* HW_MBOX_ERROR(REG): */
+
+/* NOTE: only the supervisor has write access to this register. */
+
+/*! HW_MBOX_ERROR: Contains information regarding HW Access Violation errors. */
+#define HW_MBOX_ERROR_REG_GET()           HW_MBOX_REG_GET(HW_MBOX_REGDEFS_ERROR_OFFSET)
+
+/*! HW_MBOX_ERROR: COUNT - Bits[15:8], RW, Incremented by one upon error detection. */
+#define HW_MBOX_ERROR_COUNT_GET()         HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_ERROR_OFFSET, HW_MBOX_FLDDEFS_ERROR_COUNT_OFFSET, HW_MBOX_FLDDEFS_ERROR_COUNT_LENGTH)
+#define HW_MBOX_ERROR_COUNT_SET(value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_ERROR_OFFSET, HW_MBOX_FLDDEFS_ERROR_COUNT_OFFSET, HW_MBOX_FLDDEFS_ERROR_COUNT_LENGTH, value)
+
+#define HW_MBOX_ERROR_COUNT_MIN        0x0
+#define HW_MBOX_ERROR_COUNT_MAX        0xFF  /*! (255) */
+
+#define HW_MBOX_ERROR_COUNT_RESET()    HW_MBOX_ERROR_COUNT_SET(HW_MBOX_ERROR_COUNT_MIN)
+
+/*! HW_MBOX_ERROR: ERRMID - Bits[3:0], RO, MID of the last HW_MBOX access which violated the protection rules. */
+#define HW_MBOX_ERROR_ERRMID_GET()     HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_ERROR_OFFSET, HW_MBOX_FLDDEFS_ERRMID_OFFSET, HW_MBOX_FLDDEFS_ERRMID_LENGTH)
+
+/*******************************
+        MASTER REGISTERS        
+*******************************/
+
+/* These are mapped so that each Master only sees its own registers.
+   Generally speaking a Master shouldn't access another Master's Master registers.
+   see "Other Masters Master registers" section regarding this issue. */
+
+/* --------------------------------------------------------------------------- */
+/* INTERRUPT STATUS REGISTERS: */
+
+/* NOTE: Reading these registers is followed by write back to clear the interrupts.
+         Hence these should be read only by the Master owner. */
+
+/*! HW_MBOX_MASTER_INTR_STATUS_L(REG), RO:
+    The value 1 in bit number N indicates that Channel N issued interrupt to Master MID.
+    Bit #N is cleared when the interrupt source is cleared. */
+#define HW_MBOX_MASTER_INTR_STATUS_L_REG_GET()       HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_INTR_STATUS_L_OFFSET)
+
+/*! HW_MBOX_MASTER_INTR_STATUS_H(REG), RO:
+    The value 1 in bit number N indicates that Channel (32 + N) issued interrupt to Master MID.
+    Bit #N is cleared when the interrupt source is cleared. */
+#define HW_MBOX_MASTER_INTR_STATUS_H_REG_GET()       HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_INTR_STATUS_H_OFFSET)
+
+/* --------------------------------------------------------------------------- */
+/* INTERRUPT MASK REGISTERS: */
+
+/*! HW_MBOX_MASTER_INTR_MASK_L(REG), RW:
+    The value 1 in bit number N indicates that interrupt from Channel N is not enabled. */
+#define HW_MBOX_MASTER_INTR_MASK_L_REG_GET()         HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_INTR_MASK_L_OFFSET)
+#define HW_MBOX_MASTER_INTR_MASK_L_REG_SET(value)    HW_MBOX_REG_SET(HW_MBOX_REGDEFS_MASTER_INTR_MASK_L_OFFSET, value)
+
+/*! Appends bitPattern onto the Interrupt Enable Mask */
+#define HW_MBOX_MASTER_INTR_MASK_L_REG_APPEND(bitPattern) \
+          HW_MBOX_MASTER_INTR_MASK_L_REG_SET(HW_MBOX_MASTER_INTR_MASK_L_REG_GET() | (bitPattern))
+
+/*! Clears bitPattern from the Interrupt Enable Mask */
+#define HW_MBOX_MASTER_INTR_MASK_L_REG_CLEAR(bitPattern) \
+          HW_MBOX_MASTER_INTR_MASK_L_REG_SET(HW_MBOX_MASTER_INTR_MASK_L_REG_GET() & (~(bitPattern)))
+
+/*! HW_MBOX_MASTER_INTR_MASK_H(REG), RW:
+    The value 1 in bit number N indicates that interrupt from Channel (32 + N) is not enabled. */
+#define HW_MBOX_MASTER_INTR_MASK_H_REG_GET()         HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_INTR_MASK_H_OFFSET)
+#define HW_MBOX_MASTER_INTR_MASK_H_REG_SET(value)    HW_MBOX_REG_SET(HW_MBOX_REGDEFS_MASTER_INTR_MASK_H_OFFSET, value)
+
+/*! Appends bitPattern onto the Interrupt Enable Mask */
+#define HW_MBOX_MASTER_INTR_MASK_H_REG_APPEND(bitPattern) \
+          HW_MBOX_MASTER_INTR_MASK_H_REG_SET(HW_MBOX_MASTER_INTR_MASK_H_REG_GET() | (bitPattern))
+
+/*! Clears bitPattern from the Interrupt Enable Mask */
+#define HW_MBOX_MASTER_INTR_MASK_H_REG_CLEAR(bitPattern) \
+          HW_MBOX_MASTER_INTR_MASK_H_REG_SET(HW_MBOX_MASTER_INTR_MASK_H_REG_GET() & (~(bitPattern)))
+
+/*! Masks interrupts from a specific CID (<paramCID> = [0-63]) */
+#define HW_MBOX_MASTER_INTR_MASK_CID(paramCID) \
+do{ \
+    (((paramCID) > 31)?(HW_MBOX_BIT_SET(HW_MBOX_REGDEFS_MASTER_INTR_MASK_H_OFFSET, (paramCID % 32))): \
+                       (HW_MBOX_BIT_SET(HW_MBOX_REGDEFS_MASTER_INTR_MASK_L_OFFSET, (paramCID))));     \
+} while (0)
+
+/*! Unmasks interrupts from a specific CID (<param> = [0-63]) */
+#define HW_MBOX_MASTER_INTR_UNMASK_CID(paramCID) \
+do{ \
+    (((paramCID) > 31)?(HW_MBOX_BIT_UNSET(HW_MBOX_REGDEFS_MASTER_INTR_MASK_H_OFFSET, ((paramCID) % 32))): \
+                       (HW_MBOX_BIT_UNSET(HW_MBOX_REGDEFS_MASTER_INTR_MASK_L_OFFSET, (paramCID))));       \
+} while (0)
+
+/* --------------------------------------------------------------------------- */
+/* INTERRUPT CLEAR REGISTERS: */
+
+/*! HW_MBOX_MASTER_INTR_CLEAR_L(REG), RW:
+    This is shadow register of HW_MBOX_MASTER_INTR_STATUS_L[MID], used to read it and to clear specific bits.
+    The value 1 in bit number N indicates that Channel N issued interrupt to Master MID. */
+#define HW_MBOX_MASTER_INTR_CLEAR_L_REG_GET()         HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_L_OFFSET)
+
+/*! Upon write of bit pattern (PATTERN) to this register -
+    HW_MBOX_MASTER_INTR_STATUS_L is changed to ((~PATTERN) & HW_MBOX_MASTER_INTR_STATUS_L).
+    Use it to clear consumed Masked interrupts. */
+#define HW_MBOX_MASTER_INTR_CLEAR_L_REG_SET(value)    HW_MBOX_REG_SET(HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_L_OFFSET, value)
+
+/*! HW_MBOX_MASTER_INTR_CLEAR_H(REG), RW:
+    This is shadow register of HW_MBOX_MASTER_INTR_STATUS_H[MID], used to read it and to clear specific bits.
+    The value 1 in bit number N indicates that Channel (32 + N) issued interrupt to Master MID. */
+#define HW_MBOX_MASTER_INTR_CLEAR_H_REG_GET()         HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_H_OFFSET)
+
+/*! Upon write of bit pattern (PATTERN) to this register -
+    HW_MBOX_MASTER_INTR_STATUS_H is changed to ((~PATTERN) & HW_MBOX_MASTER_INTR_STATUS_H).
+    Use it to clear consumed Masked interrupts. */
+#define HW_MBOX_MASTER_INTR_CLEAR_H_REG_SET(value)    HW_MBOX_REG_SET(HW_MBOX_REGDEFS_MASTER_INTR_CLEAR_H_OFFSET, value)
+
+/* --------------------------------------------------------------------------- */
+/* COMMANDER REGISTERS: */
+
+/*! HW_MBOX_MASTER_COMMANDER_L(REG), RO:
+    The value 1 in bit number N indicates that this Master is Commander in Channel N. */
+#define HW_MBOX_MASTER_COMMANDER_L_REG_GET()        HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_COMMANDER_L_OFFSET)
+
+/*! HW_MBOX_MASTER_COMMANDER_H(REG), RO:
+    The value 1 in bit number N indicates that this Master is Commander in Channel (32 + N). */
+#define HW_MBOX_MASTER_COMMANDER_H_REG_GET()        HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_COMMANDER_H_OFFSET)
+
+/* --------------------------------------------------------------------------- */
+/* SUBJECT REGISTERS: */
+
+/*! HW_MBOX_MASTER_SUBJECT_L(REG), RO:
+    The value 1 in bit number N indicates that this Master is Subject in Channel N. */
+#define HW_MBOX_MASTER_SUBJECT_L_REG_GET()          HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_SUBJECT_L_OFFSET)
+
+/*! HW_MBOX_MASTER_SUBJECT_H(REG), RO:
+    The value 1 in bit number N indicates that this Master is Subject in Channel (32 + N). */
+#define HW_MBOX_MASTER_SUBJECT_H_REG_GET()          HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_SUBJECT_H_OFFSET)
+
+/********************************
+        CHANNEL REGISTERS        
+********************************/
+
+/* --------------------------------------------------------------------------- */
+/* HW_MBOX_CHN_CFG[CID](REG): */
+
+/* NOTE: only the supervisor has write access to this register when START=FALSE.
+         If START=TRUE it has access as long as VALID=FALSE. */
+
+/*! HW_MBOX_CHN_CFG[CID]: Channel's Configuration Register. */
+#define HW_MBOX_CHN_CFG_REG_GET(paramCID)           HW_MBOX_REG_GET(HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID))
+
+/*! HW_MBOX_CHN_CFG[CID]: VALID - Bit(31), RW, indicates whether the channel is configured and valid. */
+#define HW_MBOX_CHN_CFG_VALID_GET(paramCID)           HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID), HW_MBOX_FLDDEFS_CHN_VALID_OFFSET, HW_MBOX_FLDDEFS_CHN_VALID_LENGTH)
+#define HW_MBOX_CHN_CFG_VALID_SET(paramCID, value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID), HW_MBOX_FLDDEFS_CHN_VALID_OFFSET, HW_MBOX_FLDDEFS_CHN_VALID_LENGTH, value)
+
+/*! HW_MBOX_CHN_CFG[CID]: TYPE - Bits[27:24], RW, The Type of HW_MBOX protocol that is employed on the channel. */
+#define HW_MBOX_CHN_CFG_TYPE_GET(paramCID)           HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID), HW_MBOX_FLDDEFS_CHN_TYPE_OFFSET, HW_MBOX_FLDDEFS_CHN_TYPE_LENGTH)
+#define HW_MBOX_CHN_CFG_TYPE_SET(paramCID, value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID), HW_MBOX_FLDDEFS_CHN_TYPE_OFFSET, HW_MBOX_FLDDEFS_CHN_TYPE_LENGTH, value)
+
+/*! HW_MBOX_CHN_CFG[CID]: REQ_ID - Bits[15:8], RW, Request ID - a unique identifier for the channel configuration. */
+#define HW_MBOX_CHN_CFG_REQ_ID_GET(paramCID)           HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID), HW_MBOX_FLDDEFS_CHN_REQ_ID_OFFSET, HW_MBOX_FLDDEFS_CHN_REQ_ID_LENGTH)
+#define HW_MBOX_CHN_CFG_REQ_ID_SET(paramCID, value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID), HW_MBOX_FLDDEFS_CHN_REQ_ID_OFFSET, HW_MBOX_FLDDEFS_CHN_REQ_ID_LENGTH, value)
+
+/*! HW_MBOX_CHN_CFG[CID]: COMMANDER - Bits[7:4], RW, MID of the Commander Master. */
+#define HW_MBOX_CHN_CFG_COMMANDER_GET(paramCID)           HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID), HW_MBOX_FLDDEFS_CHN_COMMANDER_OFFSET, HW_MBOX_FLDDEFS_CHN_COMMANDER_LENGTH)
+#define HW_MBOX_CHN_CFG_COMMANDER_SET(paramCID, value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID), HW_MBOX_FLDDEFS_CHN_COMMANDER_OFFSET, HW_MBOX_FLDDEFS_CHN_COMMANDER_LENGTH, value)
+
+/*! HW_MBOX_CHN_CFG[CID]: SUBJECT - Bits[3:0], RW, MID of the Subject Master. */
+#define HW_MBOX_CHN_CFG_SUBJECT_GET(paramCID)           HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID), HW_MBOX_FLDDEFS_CHN_SUBJECT_OFFSET, HW_MBOX_FLDDEFS_CHN_SUBJECT_LENGTH)
+#define HW_MBOX_CHN_CFG_SUBJECT_SET(paramCID, value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CHN_CFG_OFFSET(paramCID), HW_MBOX_FLDDEFS_CHN_SUBJECT_OFFSET, HW_MBOX_FLDDEFS_CHN_SUBJECT_LENGTH, value)
+
+/*! HW_MBOX_CHANNEL_CONFIG_SET(paramCID, _type, _reqID, _commander, _subject): Set complete channel configuration in one Macro. */
+#define HW_MBOX_CHANNEL_CONFIG_SET(paramCID, _type, _reqID, _commander, _subject) \
+do{ \
+    HW_MBOX_CHN_CFG_TYPE_SET(paramCID, _type);              \
+    HW_MBOX_CHN_CFG_REQ_ID_SET(paramCID, _reqID);           \
+    HW_MBOX_CHN_CFG_COMMANDER_SET(paramCID, _commander);    \
+    HW_MBOX_CHN_CFG_SUBJECT_SET(paramCID, _subject);        \
+} while (0)
+    
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_CHN_COMMAND[CID](REG), RW: */
+
+/*! HW_MBOX_CHN_COMMAND: Channel's Command Register. */
+#define HW_MBOX_CHN_COMMAND_REG_GET(paramCID)           HW_MBOX_REG_GET(HW_MBOX_REGDEFS_CHN_COMMAND_OFFSET(paramCID))
+#define HW_MBOX_CHN_COMMAND_REG_SET(paramCID, value)    HW_MBOX_REG_SET(HW_MBOX_REGDEFS_CHN_COMMAND_OFFSET(paramCID), value)
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_CHN_STATE[CID](REG), RW: */
+
+/*! HW_MBOX_CHN_STATE: Channel's State Register. */
+#define HW_MBOX_CHN_STATE_REG_GET(paramCID)        HW_MBOX_REG_GET(HW_MBOX_REGDEFS_CHN_STATE_OFFSET(paramCID))
+
+/* Writing any value to the register resets the Channel, meaning:
+   the Channel returns to state Ready and if interrupt was issued by the Channel then the interrupt is cleared. 
+   Only the Supervisor is allowed to write to this register, and it can do it at any time,
+   even after LOCK in MBOX_CTRL was set. */
+#define HW_MBOX_CHN_STATE_REG_SET(paramCID, value)    HW_MBOX_REG_SET(HW_MBOX_REGDEFS_CHN_STATE_OFFSET(paramCID), value)
+
+#define HW_MBOX_CHN_STATE_RESET(paramCID)    HW_MBOX_CHN_STATE_REG_SET(paramCID, 0) /* Use this to reset the channel and clear any pending interrupts */
+
+/*! HW_MBOX_CHN_STATE[CID]: STATE - Bits[1:0], RW, state of the channel. */
+#define HW_MBOX_CHN_STATE_STATE_GET(paramCID)    HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_CHN_STATE_OFFSET(paramCID), HW_MBOX_FLDDEFS_CHN_STATE_OFFSET, HW_MBOX_FLDDEFS_CHN_STATE_LENGTH)
+
+#define HW_MBOX_CHN_STATE_READY     0
+#define HW_MBOX_CHN_STATE_PENDING   1
+#define HW_MBOX_CHN_STATE_CONSUME   2
+#define HW_MBOX_CHN_STATE_DONE      3
+
+/***********************************
+        MEMORY MAP REGISTERS        
+***********************************/
+
+/* --------------------------------------------------------------------------- */
+/*  HW_MBOX_MEMORY_MAP[CID](REG): */
+
+/*  NOTE: only the supervisor has write access to this register (even when LOCK=TRUE). */
+
+/*! HW_MBOX_MEMORY_MAP[CID]: Channel's SRAM allocation. */
+#define HW_MBOX_MEMORY_MAP_REG_GET(paramCID)           HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MEMORY_MAP_OFFSET(paramCID))
+
+/*! HW_MBOX_MEMORY_MAP[CID]: SIZE - Bits[27:16], RW, The size in bytes of the region in SRAM allocated to Channel CID. */
+#define HW_MBOX_MEMORY_MAP_SIZE_GET(paramCID)           HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_MEMORY_MAP_OFFSET(paramCID), HW_MBOX_FLDDEFS_MMAP_SIZE_OFFSET, HW_MBOX_FLDDEFS_MMAP_SIZE_LENGTH)
+#define HW_MBOX_MEMORY_MAP_SIZE_SET(paramCID, value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_MEMORY_MAP_OFFSET(paramCID), HW_MBOX_FLDDEFS_MMAP_SIZE_OFFSET, HW_MBOX_FLDDEFS_MMAP_SIZE_LENGTH, value)
+
+/*! HW_MBOX_MEMORY_MAP[CID]: START - Bits[27:16], RW, offset within the SRAM to the beginning of the region allocated to Channel CID. */
+#define HW_MBOX_MEMORY_MAP_START_GET(paramCID)           HW_MBOX_FIELD_GET(HW_MBOX_REGDEFS_MEMORY_MAP_OFFSET(paramCID), HW_MBOX_FLDDEFS_MMAP_START_OFFSET, HW_MBOX_FLDDEFS_MMAP_START_LENGTH)
+#define HW_MBOX_MEMORY_MAP_START_SET(paramCID, value)    HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_MEMORY_MAP_OFFSET(paramCID), HW_MBOX_FLDDEFS_MMAP_START_OFFSET, HW_MBOX_FLDDEFS_MMAP_START_LENGTH, value)
+
+/*******************************************
+        Parametric Master Registers        
+*******************************************/
+
+/* For the purpose of reading other Masters' Master registers */
+
+/* --------------------------------------------------------------------------- */
+/* INTERRUPT MASK REGISTERS[paramMID]: */
+
+/*! HW_MBOX_MASTER_PARAM_INTR_MASK_L[paramMID](REG): */
+#define HW_MBOX_MASTER_PARAM_INTR_MASK_L_REG_GET(paramMID)    HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_PARAM_INTR_MASK_L_OFFSET(paramMID))
+
+/*! HW_MBOX_MASTER_PARAM_INTR_MASK_H[paramMID](REG): */
+#define HW_MBOX_MASTER_PARAM_INTR_MASK_H_REG_GET(paramMID)    HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_PARAM_INTR_MASK_H_OFFSET(paramMID))
+
+/* --------------------------------------------------------------------------- */
+/* INTERRUPT CLEAR REGISTERS[paramMID]: */
+
+/*! HW_MBOX_MASTER_PARAM_INTR_CLEAR_L[paramMID](REG): */
+#define HW_MBOX_MASTER_PARAM_INTR_CLEAR_L_REG_GET(paramMID)    HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_PARAM_INTR_CLEAR_L_OFFSET(paramMID))
+
+/*! HW_MBOX_MASTER_PARAM_INTR_CLEAR_H[paramMID](REG): */
+#define HW_MBOX_MASTER_PARAM_INTR_CLEAR_H_REG_GET(paramMID)    HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_PARAM_INTR_CLEAR_H_OFFSET(paramMID))
+
+/* --------------------------------------------------------------------------- */
+/* COMMANDER REGISTERS[paramMID]: */
+
+/*! HW_MBOX_MASTER_PARAM_COMMANDER_L[paramMID](REG): */
+#define HW_MBOX_MASTER_PARAM_COMMANDER_L_REG_GET(paramMID)    HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_PARAM_COMMANDER_L_OFFSET(paramMID))
+
+/*! HW_MBOX_MASTER_PARAM_COMMANDER_H[paramMID](REG): */
+#define HW_MBOX_MASTER_PARAM_COMMANDER_H_REG_GET(paramMID)    HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_PARAM_COMMANDER_H_OFFSET(paramMID))
+
+/* --------------------------------------------------------------------------- */
+/* SUBJECT REGISTERS[paramMID]: */
+
+/*! HW_MBOX_MASTER_PARAM_SUBJECT_L[paramMID](REG): */
+#define HW_MBOX_MASTER_PARAM_SUBJECT_L_REG_GET(paramMID)    HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_PARAM_SUBJECT_L_OFFSET(paramMID))
+
+/*! HW_MBOX_MASTER_PARAM_SUBJECT_H[paramMID](REG): */
+#define HW_MBOX_MASTER_PARAM_SUBJECT_H_REG_GET(paramMID)    HW_MBOX_REG_GET(HW_MBOX_REGDEFS_MASTER_PARAM_SUBJECT_H_OFFSET(paramMID))
+
+#ifdef __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO
+/********************************
+        Change Supervisor        
+********************************/
+
+/* Since only the supervisor has write access to the HW_MBOX_CTRL register, in the case
+   where we might want to have another Master (which is not the default Master) to get active
+   control as the supervisor (and not wait for the initial supervisor to willingly relinquish its
+   control) we have to access the HW_MBOX as though we are this default supervisor and change
+   the value. To make the HW_MBOX think we are this default supervisor we will use a special
+   address Macro that will get us to the Ctrl Register through the address space of the default
+   supervisor (effectively disguising ourselves). */
+
+/*! \def HW_MBOX_CTRL_AS_DEFAULT_SUPERVISOR_SUPERVISOR_SET(newSupervisorMID)
+    \brief Change the default supervisor. 
+    \attention This will only work once, for the initial substitution (and assuming default supervisor is set).
+    \warning Must Use a Valid MID! 
+*/
+#define HW_MBOX_CTRL_AS_DEFAULT_SUPERVISOR_SUPERVISOR_SET(newSupervisorMID) \
+          HW_MBOX_FIELD_SET(HW_MBOX_REGDEFS_CTRL_AS_DEFAULT_SUPERVISOR_OFFSET, HW_MBOX_FLDDEFS_SUPERVISOR_OFFSET, HW_MBOX_FLDDEFS_SUPERVISOR_LENGTH, newSupervisorMID)
+#endif // __HW_MBOX_CHANGE_DEFAULT_SUPERVISOR_TO
+
+#endif // !_HW_MBOX_MEM_ACCESS_H_
--- /dev/null
+++ b/arch/x86/hw_mutex/Makefile
@@ -0,0 +1,20 @@
+#
+# Copyright (c) 2011, Intel Corporation and its suppliers.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc., 
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#
+
+
+obj-$(CONFIG_HW_MUTEXES) := hw_mutex_lld.o
--- /dev/null
+++ b/arch/x86/hw_mutex/hw_mutex_lld.c
@@ -0,0 +1,436 @@
+/*
+ * kernel/hw_mutex.c
+ *
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2011 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ */
+ 
+
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+
+#include <linux/hw_mutex.h>
+#include <linux/netip_subsystem.h>
+#include "hw_mutex_lld.h"
+
+int  hw_mutex_register (struct hw_master *pmaster);
+void hw_mutex_unregister (struct hw_master *pmaster);
+
+#ifdef CONFIG_X86_PUMA6
+static const struct pci_device_id hw_mutex_pci_tbl[] = {
+        { PCI_DEVICE( 0x8086, HW_MUTEX_DEV_ID), .driver_data = 0 },
+        {0},
+};
+MODULE_DEVICE_TABLE(pci, hw_mutex_pci_tbl);
+#endif
+
+
+static inline struct hw_master*hw_mutex_to_master(struct hw_mutex *hmutex)
+{
+
+	return container_of(hmutex, struct hw_master, hw_mutexes[hmutex->lock_name]);
+}
+/* __hw_mutex_clear_interrupt_status
+ * Write 1 to clear the interrupts
+ */
+static inline void __hw_mutex_clear_interrupt_status(struct hw_master * pmaster)
+{
+	hw_mutex_set_reg(pmaster->reg_base + HW_MUTEX_INTR,HW_MUTEX_INTR_IC_BIT(pmaster->master)); 
+}
+
+/* __hw_mutex_is_waiting - check whether we're waiting for the HW mutex
+ *
+ * Return 1, if current master waiting on the mutex
+ * Return 0, if not
+*/
+static inline uint8_t  __hw_mutex_is_waiting(struct hw_mutex *hmutex)
+{
+	struct hw_master * pmaster = hw_mutex_to_master(hmutex);
+
+	return hw_mutex_read_and_test_bits(pmaster->reg_base + hw_mutex_waits[pmaster->master],BIT(hmutex->lock_name));
+}
+
+/* __hw_mutex_is_locked
+ *
+ * Return 1, if current master owns the mutex
+ * Return 0, if not
+*/
+static inline uint8_t __hw_mutex_is_locked(struct hw_mutex *hmutex)
+{
+	struct hw_master * pmaster = hw_mutex_to_master(hmutex);
+	return hw_mutex_read_and_test_bits(pmaster->reg_base + hw_mutex_owns[pmaster->master], BIT(hmutex->lock_name));
+}
+
+
+/*
+  * __lock_hw_mutex - low level function to lock HW mutex
+  *
+  * check HW mutex status first
+  *  When force == 0, check whether a new locking request is needed before we make the request
+  *  When force ===1, make a new reqeust forceblly
+  * Return 1: locked, 0: unlocked
+ */
+static inline int __lock_hw_mutex(struct hw_mutex *hmutex, int force)
+{
+	struct hw_master * pmaster = hw_mutex_to_master(hmutex);
+	int retval = 0;
+	if (!force){
+		if (unlikely(__hw_mutex_is_waiting(hmutex))) return 0;
+		else if (unlikely(__hw_mutex_is_locked(hmutex))) return 1;
+	}
+	/* Make sure we're doing a new request */
+ 	retval = hw_mutex_read_and_test_bits(pmaster->reg_base + hw_mutex_locks[pmaster->master] + (hmutex->lock_name<<2),HW_MUTEX_MTX_UNLOCK_BIT);
+
+	if (!retval) 
+		atomic_set(&hmutex->status,HW_MUTEX_REQUESTING);
+	else 
+		atomic_set(&hmutex->status,HW_MUTEX_LOCKED);
+	return retval;
+}
+
+/*
+ * __unlock_hw_mutex - check HW mutex status, and unlock the mutex if we own it
+ */
+static inline void __unlock_hw_mutex(struct hw_mutex *hmutex)
+{
+	struct hw_master * pmaster = hw_mutex_to_master(hmutex);
+	if (unlikely(!__hw_mutex_is_locked(hmutex))) return ;
+	hw_mutex_set_reg(pmaster->reg_base + hw_mutex_locks[pmaster->master] + (hmutex->lock_name<<2),HW_MUTEX_MTX_UNLOCK_BIT);
+	atomic_set(&hmutex->status,HW_MUTEX_UNLOCKED);
+	return ;
+}
+/*
+ * hw_mutex_unlock_all - unlock all of the HW mutexes at start-up
+ */
+static void hw_mutex_unlock_all(struct hw_master * pmaster)
+{
+	int i = 0;
+	/* Initialize critical structures */
+	for (i = 0; i< HW_MUTEX_TOTAL; i++){
+		__unlock_hw_mutex(&pmaster->hw_mutexes[i]);
+	}
+	return;
+}
+#if 0
+/*
+ * __set_hw_mutex - Set the maser working in FIFO/NULL or polling mode
+ */
+static void __set_hw_mutex(struct hw_master * pmaster,hw_mutex_mode_type mode)
+{
+	switch(mode){
+		case HW_MUTEX_POLLING:
+			hw_mutex_read_and_set_bits(pmaster->reg_base + HW_MUTEX_CFG,HW_MUTEX_CFG_IP_BIT);
+			break;
+		case HW_MUTEX_NULL_SCHE:
+			hw_mutex_read_and_set_bits(pmaster->reg_base + HW_MUTEX_CFG, HW_MUTEX_CFG_IP_BIT);
+			hw_mutex_read_and_set_bits(pmaster->reg_base + hw_mutex_cntls[pmaster->master],HW_MUTEX_CNTL_NF_BIT);
+			break;
+		case HW_MUTEX_FIFO_SCHE:			
+			hw_mutex_read_and_set_bits(pmaster->reg_base + HW_MUTEX_CFG, HW_MUTEX_CFG_IP_BIT);
+			hw_mutex_read_and_set_bits(pmaster->reg_base + hw_mutex_cntls[pmaster->master],HW_MUTEX_CNTL_NF_BIT);
+			break;
+		default:
+			printk(KERN_ERR "error mutex working mode\n");
+	}
+	pmaster->mode	= mode;
+	return;
+}
+#endif
+static struct hw_mutex_operations hw_mutex_ops = {
+	.name			= "hw-mutex-ops",
+	.lock			= __lock_hw_mutex,
+	.unlock			= __unlock_hw_mutex,
+	.is_locked		= __hw_mutex_is_locked,
+	.is_waiting 	= __hw_mutex_is_waiting,
+	.clr_intr		= __hw_mutex_clear_interrupt_status,
+};
+
+#ifdef CONFIG_PM
+int hw_mutex_device_suspend(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	int ret = 0;
+
+	return ret;
+}
+
+int hw_mutex_device_resume(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	int ret = 0;
+
+	/*pci device restore*/
+	return ret;
+}	
+#endif
+
+struct hw_master *pmaster;
+/* 
+ * driver entry point
+ */
+#ifdef CONFIG_X86_PUMA6
+static int hw_mutex_probe(struct pci_dev *pdev,
+                                const struct pci_device_id *id)
+{
+	int i, ret = -ENODEV;
+	resource_size_t mem_iobase;
+	unsigned long mem_iosize;
+	DEBUG_PRINT;
+ 
+	ret = pci_enable_device(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "pci_enable_device failed.\n");
+		return ret;
+	}
+
+	mem_iobase = pci_resource_start(pdev,0);
+	mem_iosize = pci_resource_len(pdev,0);
+	printk(KERN_INFO "mem_iobase = 0x%x, mem_iosize = 0x%x\n",(unsigned int)mem_iobase,(unsigned int)mem_iosize);
+	
+	if (pci_request_regions(pdev, "hw-mutex")){
+		dev_err(&pdev->dev, "Cannot obtain PCI resources\n");
+		ret = -EBUSY;
+		goto free_dev;
+	}
+
+	pmaster = kzalloc(sizeof(struct hw_master), GFP_KERNEL);
+	if (!pmaster){
+		dev_err(&pdev->dev, "Cannot allocate memory\n");
+		ret = -ENOMEM;
+		goto free_resource;
+	}
+	/* Initialize critical structures */
+	for (i = 0; i< HW_MUTEX_TOTAL; i++){
+			pmaster->hw_mutexes[i].lock_name = i;
+			spin_lock_init(&pmaster->hw_mutexes[i].irq_lock);
+			mutex_init(&pmaster->hw_mutexes[i].lock);
+			pmaster->hw_mutexes[i].owner = NULL;
+			atomic_set(&pmaster->hw_mutexes[i].status,HW_MUTEX_UNLOCKED);
+	}
+
+	pmaster->reg_base = (void __iomem *)ioremap_nocache(mem_iobase,mem_iosize);
+	if (!pmaster->reg_base) {
+		dev_err( &pdev->dev, "error, failed to ioremap mutex registers\n");
+		ret = -ENOMEM;
+		goto free_mem;
+	}
+	
+	/* We're running in ATOM */
+	pmaster->master = MASTER_ATOM; 
+	pmaster->irq_num = pdev->irq;
+	pmaster->dev = pdev;	
+	pmaster->ops = &hw_mutex_ops;	
+
+	pci_set_drvdata(pmaster->dev,pmaster);	
+	
+	printk(KERN_INFO "pmaster 0x%x mem_base 0x%x, io_size 0x%x,irq_num %d, reg_base 0x%x\n",(uint32_t)pmaster, (uint32_t)mem_iobase,(uint32_t)mem_iosize,pmaster->irq_num,(uint32_t)pmaster->reg_base);
+
+	/* HW mutex is configured to be fifo scheduler mode by default */	
+	/* Do not config the settings since BIOS already do that */
+#if defined(CONFIG_MUTEX_FIFO)
+	pmaster->mode = HW_MUTEX_FIFO_SCHE;
+#elif defined(CONFIG_MUTEX_NULL)
+	pmaster->mode = HW_MUTEX_NULL_SCHE;
+#else 
+	pmaster->mode = HW_MUTEX_POLLING;
+#endif
+
+	if (hw_mutex_register(pmaster)){
+		ret = -EINTR;
+		goto free_iomem;
+	}
+	printk(KERN_INFO "Intel(R) HW MUTEX driver built on %s @ %s\n", __DATE__, __TIME__);
+	return 0;
+	pci_set_drvdata(pmaster->dev,NULL);		
+free_iomem:
+	iounmap(pmaster->reg_base);
+free_mem:
+	kfree(pmaster);
+free_resource:
+	pci_release_regions(pdev);
+free_dev:	
+	pci_disable_device(pdev);
+
+	return ret;
+}
+#elif CONFIG_X86_PUMA7
+void hw_mutex_register_with_netss(void)
+{
+   int i, ret = -ENODEV;
+   netss_subdevice_mmio_t hwmutex_mmio;
+   DEBUG_PRINT;
+
+   if(!netss_driver_ready())
+   {
+      printk(KERN_INFO "Net SubSystem Driver is not ready, cannot initialize HW MUTEX driver\n");
+      return;
+   }
+
+   if(netss_get_subdevice_mmio_info(NETSS_HW_MUTEX, &hwmutex_mmio))
+   {
+      printk(KERN_INFO "HW MUTEX driver could not get mmio info \n");
+      return;
+   }
+   else
+   {
+      printk(KERN_INFO "HW Mutex mem_iobase = 0x%x, mem_iosize = 0x%x\n",(unsigned int)hwmutex_mmio.base,(unsigned int)hwmutex_mmio.size);
+   }
+	
+   pmaster = kzalloc(sizeof(struct hw_master), GFP_KERNEL);
+   if (!pmaster) {
+      printk(KERN_ERR, "Cannot allocate memory for HW Mutex context\n");
+      ret = -ENOMEM;
+      return;
+   }
+   /* Initialize critical structures */
+   for (i = 0; i< HW_MUTEX_TOTAL; i++) {
+      pmaster->hw_mutexes[i].lock_name = i;
+      spin_lock_init(&pmaster->hw_mutexes[i].irq_lock);
+      mutex_init(&pmaster->hw_mutexes[i].lock);
+      pmaster->hw_mutexes[i].owner = NULL;
+      atomic_set(&pmaster->hw_mutexes[i].status,HW_MUTEX_UNLOCKED);
+   }
+
+   pmaster->reg_base = (void __iomem *)ioremap_nocache(hwmutex_mmio.base,hwmutex_mmio.size);
+   if (!pmaster->reg_base) {
+      printk(KERN_ERR, "error, failed to ioremap hw mutex registers\n");
+      ret = -ENOMEM;
+      goto free_mem;
+   }
+	
+   /* We're running in ATOM */
+   pmaster->master = MASTER_ATOM; 
+   pmaster->ops = &hw_mutex_ops;	
+
+   /* HW mutex is configured to be fifo scheduler mode by default */	
+   /* Do not config the settings since BIOS already do that */
+#if defined(CONFIG_MUTEX_FIFO)
+   pmaster->mode = HW_MUTEX_FIFO_SCHE;
+#elif defined(CONFIG_MUTEX_NULL)
+   pmaster->mode = HW_MUTEX_NULL_SCHE;
+#else 
+   pmaster->mode = HW_MUTEX_POLLING;
+#endif
+
+   if (hw_mutex_register(pmaster)){
+      ret = -EINTR;
+      goto free_iomem;
+   }
+   printk(KERN_INFO "Intel(R) HW MUTEX driver built on %s @ %s\n", __DATE__, __TIME__);
+   return 0;
+
+free_iomem:
+   iounmap(pmaster->reg_base);
+free_mem:
+   kfree(pmaster);
+   return 0;
+}
+
+#endif
+/* 
+ * driver exit point 
+ */
+#ifdef CONFIG_X86_PUMA6
+static void hw_mutex_remove(struct pci_dev *pdev)
+{
+	struct hw_master * pmaster = pci_get_drvdata(pdev);
+	if (!pmaster)
+		return;
+	hw_mutex_unregister(pmaster);
+	/* Unlock all mutexes when driver exit */
+	pci_set_drvdata(pmaster->dev,NULL);		
+	hw_mutex_unlock_all(pmaster);
+	iounmap(pmaster->reg_base);
+	kfree(pmaster);
+	pci_release_regions(pmaster->dev);
+	pci_disable_device(pmaster->dev);
+	DEBUG_PRINT;
+	printk(KERN_INFO "hw-mutex : device exit \n");
+ 
+	return;
+}
+#elif CONFIG_X86_PUMA7
+static void hw_mutex_unregister_with_netss(void)
+{
+   hw_mutex_unregister(pmaster);
+   /* Unlock all mutexes when driver exit */
+   pci_set_drvdata(pmaster->dev,NULL);		
+   hw_mutex_unlock_all(pmaster);
+   iounmap(pmaster->reg_base);
+   kfree(pmaster);
+   DEBUG_PRINT;
+   printk(KERN_INFO "hw-mutex : device exit \n");
+ 
+   return;
+}
+
+#endif
+#ifdef CONFIG_PM
+static const struct dev_pm_ops hw_mutex_pm_ops = {
+	.suspend	= hw_mutex_device_suspend,
+	.resume		= hw_mutex_device_resume,
+};
+#endif
+
+#ifdef CONFIG_X86_PUMA6
+static struct pci_driver hw_mutex_driver = {
+        .name           = "ce-hw-mutex",
+        .id_table       = hw_mutex_pci_tbl,
+        .probe          = hw_mutex_probe,
+        .remove		= hw_mutex_remove,
+#ifdef CONFIG_PM
+	.driver.pm 	= &hw_mutex_pm_ops,
+#endif
+};
+#endif
+static int __init hw_mutex_lld_init (void)
+{
+#ifdef CONFIG_X86_PUMA6
+   return pci_register_driver(&hw_mutex_driver);
+#elif CONFIG_X86_PUMA7
+  hw_mutex_register_with_netss();   
+#endif
+}
+static void __exit hw_mutex_lld_exit(void)
+{
+#ifdef CONFIG_X86_PUMA6
+   pci_unregister_driver(&hw_mutex_driver);
+#elif CONFIG_X86_PUMA7
+   hw_mutex_unregister_with_netss();
+#endif
+}
+
+subsys_initcall(hw_mutex_lld_init);
+module_exit(hw_mutex_lld_exit);
+
+MODULE_DESCRIPTION("Intel(R) HW MUTEX DEVICE Driver");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL");
+
+
+
--- /dev/null
+++ b/arch/x86/hw_mutex/hw_mutex_lld.h
@@ -0,0 +1,63 @@
+
+/*
+ *  kernel/hw_mutex/h
+ *
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2011 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ * The file contains the main data structure and API definitions for Linux Hardware Mutex driver
+ * Intel CE processor supports 4/16 masters and 12/16 mutexes available
+ *
+ */
+#ifndef KERNEL_HW_MUTEX_LLD_H
+#define KERNEL_HW_MUTEX_LLD_H
+
+
+
+#ifdef CONFIG_X86_PUMA6 /* For Puma-6 SoC */
+#include "puma6_hw_mutex_lld.h"
+#endif
+
+#ifdef CONFIG_X86_PUMA7 /* For Puma-7 SoC */
+#include "puma7_hw_mutex_lld.h"
+#endif
+
+#define HW_MUTEX_DEVICE 0x0949 
+
+#define BIT(i)    ((1 << (i)))
+
+/*
+ * Configs Mutex to be in polling or FIFO/NULL scheduler mode
+ *
+ */
+#define SET_HW_MUTEX_POLLING(pMaster) __set_hw_mutex(pMaster, MUTEX_POLLING)
+#define SET_HW_MUTEX_FIFO_INTERRUPT(pMaster) __set_hw_mutex(pMaster, MUTEX_FIFO_SCHE)
+#define SET_HW_MUTEX_NULL_INTERRUPT(pMaster) __set_hw_mutex(pMaster, MUTEX_NULL_SCHE)
+
+
+
+#endif 
+/* end of hw_mutex.h */
+
+
--- /dev/null
+++ b/arch/x86/hw_mutex/puma6_hw_mutex_lld.h
@@ -0,0 +1,116 @@
+
+/*
+ *  kernel/hw_mutex/h
+ *
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2011-2014 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ * The file contains the main data structure and API definitions for Linux Hardware Mutex driver
+ * Intel CE processor supports 4 masters and 12 mutexes available
+ *
+ */
+
+#ifndef _PUMA6_HW_MUTEX_LLD_H_
+#define _PUMA6_HW_MUTEX_LLD_H_
+
+
+/* Identification Register */
+#define CORE_ID 0x000
+
+/* MUTEX status Register */
+#define HW_MUTEX_STATUS             0x004
+#define HW_MUTEX_STATUS_BIT(mutex)  BIT(mutex)
+
+/* MUTEX wait Registers */
+#define HW_MUTEX_WAIT0          0x008
+#define HW_MUTEX_WAIT1          0x00c
+#define HW_MUTEX_WAIT2          0x010
+#define HW_MUTEX_WAIT3          0x014
+#define MUTEX_WAIT_BIT(mutex)   BIT(mutex)
+
+/* MUTEX own registers */
+#define HW_MUTEX_OWN0 0x018
+#define HW_MUTEX_OWN1 0x01C
+#define HW_MUTEX_OWN2 0x020
+#define HW_MUTEX_OWN3 0x024
+
+/* MUTEX interrupt register */
+#define HW_MUTEX_INTR                   0x028
+#define HW_MUTEX_INTR_IC_BIT(master)    BIT(master)
+
+/* MUTEX config register */
+#define HW_MUTEX_CFG            0x02C
+#define HW_MUTEX_CFG_IP_BIT     BIT(0)
+
+/* MUTEX control register */
+#define HW_MUTEX_CNTL0          0x030
+#define HW_MUTEX_CNTL1          0x034
+#define HW_MUTEX_CNTL2          0x038
+#define HW_MUTEX_CNTL3          0x03C
+#define HW_MUTEX_CNTL_NF_BIT    BIT(0)
+
+/* MUTEX LOCK/UNLOCK registers */
+#define HW_MUTEX0_LOCK              0x100
+#define HW_MUTEX1_LOCK              0x180
+#define HW_MUTEX2_LOCK              0x200
+#define HW_MUTEX3_LOCK              0x280
+#define HW_MUTEX_MTX_UNLOCK_BIT     BIT(0)
+
+static const uint32_t hw_mutex_locks[MASTER_TOTAL] = {HW_MUTEX0_LOCK, HW_MUTEX1_LOCK, HW_MUTEX2_LOCK, HW_MUTEX3_LOCK};
+static const uint32_t hw_mutex_waits[MASTER_TOTAL] = {HW_MUTEX_WAIT0, HW_MUTEX_WAIT1, HW_MUTEX_WAIT2, HW_MUTEX_WAIT3};
+static const uint32_t hw_mutex_owns[MASTER_TOTAL] = {HW_MUTEX_OWN0, HW_MUTEX_OWN1, HW_MUTEX_OWN2, HW_MUTEX_OWN3};
+static const uint32_t hw_mutex_cntls[MASTER_TOTAL] = {HW_MUTEX_CNTL0, HW_MUTEX_CNTL1, HW_MUTEX_CNTL2, HW_MUTEX_CNTL3};
+
+/* Defined to perform little endian accesses For ARM11 - If the CPU is running in little endian mode this macro will do nothing ! */
+#define HW_MUTEX_CONVERT_FROM_32LE(le_value)     (le32_to_cpu(le_value)) 
+#define HW_MUTEX_CONVERT_CPU_TO_32LE(be_value)   (cpu_to_le32(be_value))
+
+static inline uint8_t hw_mutex_read_and_test_bits(void __iomem *reg, uint32_t val)
+{
+    return  (((__raw_readl(reg)) & HW_MUTEX_CONVERT_CPU_TO_32LE(val)) > 0);
+}
+
+static inline void hw_mutex_read_and_set_bits(void __iomem *reg, uint32_t val)
+{
+    __raw_writel(__raw_readl(reg) | HW_MUTEX_CONVERT_CPU_TO_32LE(val), reg);
+}
+
+static inline void hw_mutex_read_and_clr_bits(void __iomem *reg, uint32_t val)
+{
+    __raw_writel((__raw_readl(reg) & ~(HW_MUTEX_CONVERT_CPU_TO_32LE(val))), reg);
+}
+
+static inline void hw_mutex_set_reg(void __iomem *reg, uint32_t val)
+{
+    __raw_writel(HW_MUTEX_CONVERT_CPU_TO_32LE(val), reg);
+}
+
+static inline uint32_t hw_mutex_read_reg(void __iomem *reg)
+{
+    unsigned int reg_val = __raw_readl(reg);
+
+    return HW_MUTEX_CONVERT_FROM_32LE(reg_val);
+}
+
+#endif // !_PUMA6_HW_MUTEX_LLD_H_
--- /dev/null
+++ b/arch/x86/hw_mutex/puma7_hw_mutex_lld.h
@@ -0,0 +1,120 @@
+
+/*
+ *  kernel/hw_mutex/h
+ *
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2014 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ * The file contains the main data structure and API definitions for Linux Hardware Mutex driver
+ * Intel CE processor supports 16 masters and 16 mutexes available
+ *
+ */
+
+#ifndef _PUMA7_HW_MUTEX_LLD_H_
+#define _PUMA7_HW_MUTEX_LLD_H_
+
+
+/* Identification Register */
+#define CORE_ID 0x000
+
+/* MUTEX status Register */
+#define HW_MUTEX_STATUS             0x004
+#define HW_MUTEX_STATUS_BIT(mutex)  BIT(mutex)
+
+/* MUTEX wait Registers */
+#define HW_MUTEX_WAIT(master)   (0x0080 + ((master) << 2)) /* 0x0080 + (master * 0x4) */
+#define MUTEX_WAIT_BIT(mutex)   BIT(mutex)
+
+/* MUTEX own registers */
+#define HW_MUTEX_OWN(master)    (0x0100 + ((master) << 2)) /* 0x0100 + (master * 0x4) */
+
+/* MUTEX interrupt register */
+#define HW_MUTEX_INTR                   0x028 
+#define HW_MUTEX_INTR_IC_BIT(master)    BIT(master)
+
+/* MUTEX config register */
+#define HW_MUTEX_CFG            0x02C 
+#define HW_MUTEX_CFG_IP_BIT     BIT(0)
+
+/* MUTEX control register */
+#define HW_MUTEX_CNTL(master)   (0x0180 + ((master) << 2)) /* 0x0180 + (master * 0x4) */
+#define HW_MUTEX_CNTL_NF_BIT    BIT(0)
+
+/* MUTEX LOCK/UNLOCK registers */
+#define HW_MUTEX_LOCK(master, mutex)    (0x1000 + ((master) << 7) + ((mutex) << 2)) /* 0x1000 + (master * 0x80) + (mutex * 0x4) */
+#define HW_MUTEX_MTX_UNLOCK_BIT         BIT(0)
+
+/* hw_mutex_locks array specifies the base address for all lock registers for each master [index is Master ID] */
+static const uint32_t hw_mutex_locks[MASTER_TOTAL] = { HW_MUTEX_LOCK(0, 0), HW_MUTEX_LOCK(1, 0), HW_MUTEX_LOCK(2, 0), HW_MUTEX_LOCK(3, 0),
+                                                       HW_MUTEX_LOCK(4, 0), HW_MUTEX_LOCK(5, 0), HW_MUTEX_LOCK(6, 0), HW_MUTEX_LOCK(7, 0),
+                                                       HW_MUTEX_LOCK(8, 0), HW_MUTEX_LOCK(9, 0), HW_MUTEX_LOCK(10, 0), HW_MUTEX_LOCK(11, 0),
+                                                       HW_MUTEX_LOCK(12, 0), HW_MUTEX_LOCK(13, 0), HW_MUTEX_LOCK(14, 0), HW_MUTEX_LOCK(15, 0) };
+
+static const uint32_t hw_mutex_waits[MASTER_TOTAL] = { HW_MUTEX_WAIT(0), HW_MUTEX_WAIT(1), HW_MUTEX_WAIT(2), HW_MUTEX_WAIT(3),
+                                                       HW_MUTEX_WAIT(4), HW_MUTEX_WAIT(5), HW_MUTEX_WAIT(6), HW_MUTEX_WAIT(7),
+                                                       HW_MUTEX_WAIT(8), HW_MUTEX_WAIT(9), HW_MUTEX_WAIT(10), HW_MUTEX_WAIT(11),
+                                                       HW_MUTEX_WAIT(12), HW_MUTEX_WAIT(13), HW_MUTEX_WAIT(14), HW_MUTEX_WAIT(15) };
+
+static const uint32_t hw_mutex_owns[MASTER_TOTAL] = { HW_MUTEX_OWN(0), HW_MUTEX_OWN(1), HW_MUTEX_OWN(2), HW_MUTEX_OWN(3),
+                                                      HW_MUTEX_OWN(4), HW_MUTEX_OWN(5), HW_MUTEX_OWN(6), HW_MUTEX_OWN(7),
+                                                      HW_MUTEX_OWN(8), HW_MUTEX_OWN(9), HW_MUTEX_OWN(10), HW_MUTEX_OWN(11),
+                                                      HW_MUTEX_OWN(12), HW_MUTEX_OWN(13), HW_MUTEX_OWN(14), HW_MUTEX_OWN(15) };
+
+static const uint32_t hw_mutex_cntls[MASTER_TOTAL] = { HW_MUTEX_CNTL(0), HW_MUTEX_CNTL(1), HW_MUTEX_CNTL(2), HW_MUTEX_CNTL(3),
+                                                       HW_MUTEX_CNTL(4), HW_MUTEX_CNTL(5), HW_MUTEX_CNTL(6), HW_MUTEX_CNTL(7),
+                                                       HW_MUTEX_CNTL(8), HW_MUTEX_CNTL(9), HW_MUTEX_CNTL(10), HW_MUTEX_CNTL(11),
+                                                       HW_MUTEX_CNTL(12), HW_MUTEX_CNTL(13), HW_MUTEX_CNTL(14), HW_MUTEX_CNTL(15) };
+/* Defined to perform little endian accesses For ARM11 - If the CPU is running in little endian mode this macro will do nothing ! */
+#define HW_MUTEX_CONVERT_FROM_32BE(le_value)     (be32_to_cpu(le_value)) 
+#define HW_MUTEX_CONVERT_CPU_TO_32BE(be_value)   (cpu_to_be32(be_value))
+
+static inline uint8_t hw_mutex_read_and_test_bits(void __iomem *reg, uint32_t val)
+{
+    return  (((__raw_readl(reg)) & HW_MUTEX_CONVERT_CPU_TO_32BE(val)) > 0);
+}
+
+static inline void hw_mutex_read_and_set_bits(void __iomem *reg, uint32_t val)
+{
+    __raw_writel(__raw_readl(reg) | HW_MUTEX_CONVERT_CPU_TO_32BE(val), reg);
+}
+
+static inline void hw_mutex_read_and_clr_bits(void __iomem *reg, uint32_t val)
+{
+    __raw_writel((__raw_readl(reg) & ~(HW_MUTEX_CONVERT_CPU_TO_32BE(val))), reg);
+}
+
+static inline void hw_mutex_set_reg(void __iomem *reg, uint32_t val)
+{
+    __raw_writel(HW_MUTEX_CONVERT_CPU_TO_32BE(val), reg);
+}
+
+static inline uint32_t hw_mutex_read_reg(void __iomem *reg)
+{
+    unsigned int reg_val = __raw_readl(reg);
+
+    return HW_MUTEX_CONVERT_FROM_32BE(reg_val);
+}
+
+#endif // !_PUMA7_HW_MUTEX_LLD_H_
+
--- /dev/null
+++ b/include/linux/hw_mutex.h
@@ -0,0 +1,197 @@
+/*
+ *  include/linux/hw_mutex.h
+ *
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2011-2013 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ *
+ */
+#ifndef LINUX_HW_MUTEX_H
+#define LINUX_HW_MUTEX_H
+ 
+
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <asm/atomic.h>
+
+#ifdef CONFIG_X86_PUMA6 /* For Puma-6 SoC */
+/* 4 masters */
+#define MASTER_TOTAL        (4)
+#define HW_MUTEX_DEV_ID         0x0949
+#endif
+#ifdef CONFIG_X86_PUMA7 /* For Puma-7 SoC */
+/* 16 masters */
+#define MASTER_TOTAL        (16)
+#define HW_MUTEX_DEV_ID     0x2BE9
+#endif
+
+
+/* HW MUTEX controller working mode */
+typedef enum {
+	HW_MUTEX_POLLING = 0,
+	HW_MUTEX_FIFO_SCHE,
+	HW_MUTEX_NULL_SCHE
+} hw_mutex_mode_type;
+
+#ifdef CONFIG_X86_PUMA6
+/* Totally 4 masters are supported */
+typedef enum {
+    MASTER_ARM11 = 0,
+    MASTER_PP    = 1,
+    MASTER_ATOM  = 2,
+    MASTER_RESV
+} hw_mutex_master_type;
+#endif
+#ifdef CONFIG_X86_PUMA7
+/* Totally 16 masters are supported */
+typedef enum {
+    MASTER_ARM11   = 0,
+    MASTER_BBU_C   = 1,
+    MASTER_ATOM    = 2,
+    MASTER_ARM9    = 3,
+    MASTER_PHY_CPU = 4,
+    MASTER_CSE     = 5,
+    MASTER_SEC     = 6,
+    MASTER_POLL0   = 7,  /* use for polling */
+    MASTER_POLL1   = 8,  /* use for polling */
+    MASTER_MOCA_C  = 9,
+    MASTER_RCE     = 10,
+    MASTER_RESV,
+    MASTER_RESV1,
+    MASTER_RESV2,
+    MASTER_RESV3,
+    MASTER_RESV4
+} hw_mutex_master_type;
+#endif
+
+/* Devices use HW mutex */
+typedef enum {
+    HW_MUTEX_NOR_SPI   = 0,
+    HW_MUTEX_EMMC      = 1,
+    HW_MUTEX_ARM_MBX   = 2,  /* Mutex for protect the ARM Mbox Structure */
+    HW_MUTEX_ATOM_MBX  = 3,  /* Mutex for protect the ATOM Mbox Structure */
+    HW_MUTEX_GPIO      = 4,  /* Mutex for protect the GPIOs access */
+    HW_MUTEX_MAX_VAL
+} hw_mutex_device_type;
+
+/* 0: SPI_NOR_FLASH, 1: eMMC, 2,3: Mailbox*/
+#define HW_MUTEX_TOTAL        (HW_MUTEX_MAX_VAL)
+
+/* Each HW mutex is controlled by a software mutex */
+struct hw_mutex {
+		hw_mutex_device_type lock_name;
+		spinlock_t irq_lock;
+		struct mutex lock;
+		struct thread_info	*owner; /* Which thread owns the MUTEX */
+		atomic_t	status;			/* 1: unlocked, 0: requesting, negative: locked, possible waiters */
+		
+#define	HW_MUTEX_LOCKED  	(-1)	/* The MUTEX is locked 							*/
+#define	HW_MUTEX_REQUESTING (0)		/* We've requested for the MUTEX, but not get it yet 	*/
+#define	HW_MUTEX_UNLOCKED  	(1)		/* The HW mutex is free 							*/
+
+}__attribute__((aligned(4)));
+
+struct hw_master {
+	hw_mutex_master_type master;
+	hw_mutex_mode_type mode; 		/* polling , fifo_interrupt, null_interrupt */
+	uint32_t irq_num;				/* The irq number used for HW mutex */
+	void __iomem *reg_base;			/* Mapped io reg base address */
+	struct pci_dev *dev;	
+	struct hw_mutex hw_mutexes[HW_MUTEX_TOTAL];
+	struct hw_mutex_operations *ops;	
+}__attribute__((aligned(4)));
+
+/* Abstraction oprations of a HW mutex */
+struct hw_mutex_operations {
+	char *name;
+	void (*clr_intr)(struct hw_master* pmaster);	
+	int (*lock)(struct hw_mutex* hmutex, int force);
+	void (*unlock)(struct hw_mutex* hmutex);
+	uint8_t (*is_locked)(struct hw_mutex* hmutex);
+	uint8_t (*is_waiting)(struct hw_mutex* hmutex);	
+}__attribute__((aligned(4)));
+
+ 
+/*
+  * hw_mutex_lock - acquire the mutex
+  * @mutex: the mutex to be acquired
+  *
+  * Lock the mutex exclusively for this task. If the mutex is not
+  * available right now, it will sleep until we can get it.
+  *
+  * The function is non interruptible
+  */
+
+extern void hw_mutex_lock(uint8_t mutex);
+
+/*
+ * hw_mutex_lock_interruptible - acquire the mutex
+ * @mutex: the mutex to be acquired
+ *
+ * Lock the mutex exclusively for this task. If the mutex is not
+ * available right now, it will sleep until it can get it.
+ * It can be interruptibed by signal, or exit when timeout
+ *
+ * Returns 0 if success, negative if interrupted or timeout
+ */
+
+extern long __must_check hw_mutex_lock_interruptible(uint8_t mutex);
+
+
+/* hw_mutex_is_locked - check whether the current master owns the mutex or not
+ * @mutex: the mutex number to be checked
+ *
+ * Return 1, if current master owns the mutex
+ * Return 0, if not
+ * Return Negative for errors
+*/
+
+extern int __must_check hw_mutex_is_locked(uint8_t mutex);
+
+/*
+ * hw_mutex_unlock - release the mutex
+ * @mutex: the mutex to be released
+ *
+ * release the mutex got previously
+ *
+ */
+extern void hw_mutex_unlock(uint8_t mutex);
+
+
+//#define HW_MUTEX_DEBUG 1
+#ifdef HW_MUTEX_DEBUG
+//#   define DEBUG_PRINT(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ## args)
+#define DEBUG_PRINT printk("\nLine %d.%s: ->\n",__LINE__,__FUNCTION__)
+#define DEBUG_PRINTK(fmt, args...) printk("%d@%s " fmt,__LINE__,__FUNCTION__ , ## args)
+
+#else
+#define DEBUG_PRINT do{} while (0)
+#define DEBUG_PRINTK(fmt, args...) do{} while (0)
+
+#endif
+
+
+
+#endif
+
--- /dev/null
+++ b/include/linux/netip_subsystem.h
@@ -0,0 +1,39 @@
+#define NET_SUBSYTEM_DEV_ID 0x2BE9
+#define NETSS_SUBDEV_HWMUTEX_MMIO_BASE (0xF0190000)
+#define NETSS_SUBDEV_HWMUTEX_MMIO_SIZE (0x10000)
+#define NETSS_SUBDEV_HWMBX_MMIO_BASE (0xF01A0000)
+#define NETSS_SUBDEV_HWMBX_MMIO_SIZE (0x20000)
+
+typedef enum {
+   NETSS_HW_MUTEX = 0,
+   NETSS_HW_MAILBOX = 1,
+   NETSS_SUBDEVICE_MAX
+}netss_subdevices_t;
+
+
+typedef irqreturn_t (* netss_subdevice_irq_func)(int irqnum, void *);
+
+typedef struct netss_subdev_irq_info {
+   netss_subdevice_irq_func func;
+   void * args;
+}netss_subdev_irq_info_t;
+
+typedef struct netss_subdevice_mmio {
+   unsigned long base;
+   unsigned long size;
+}netss_subdevice_mmio_t;
+
+struct net_subsystem_drv_data {
+   uint32_t irq_num;          /* The irq number used for Net SubSystem driver */
+   bool netss_driver_initialized;
+   void __iomem *bridge_reg_base; /* Mapped io bridge register base address mmio region2 of Net-IP  */
+   netss_subdevice_mmio_t subdev_mmios[NETSS_SUBDEVICE_MAX];
+   netss_subdev_irq_info_t irqs[NETSS_SUBDEVICE_MAX];
+   struct pci_dev *dev;
+    
+}__attribute__((aligned(4)));
+
+void netss_subdev_register_irq(netss_subdevices_t subdevice, netss_subdev_irq_info_t *irq_info);
+bool netss_driver_ready(void);
+int netss_get_subdevice_mmio_info(netss_subdevices_t subdevice, netss_subdevice_mmio_t *mmio);
+
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -113,6 +113,8 @@ obj-$(CONFIG_JUMP_LABEL) += jump_label.o
 obj-$(CONFIG_CONTEXT_TRACKING) += context_tracking.o
 obj-$(CONFIG_CRASHLOG) += crashlog.o
 
+obj-$(CONFIG_HW_MUTEXES) += hwmutex.o
+
 $(obj)/configs.o: $(obj)/config_data.h
 
 # config_data.h contains the same information as ikconfig.h but gzipped.
--- /dev/null
+++ b/kernel/hwmutex.c
@@ -0,0 +1,330 @@
+/*
+ * kernel/hw_mutex.c
+ *
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2011-2013 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ */
+ 
+#include <linux/interrupt.h>
+#include <linux/init.h>
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#ifdef CONFIG_X86_PUMA7
+#include <linux/netip_subsystem.h>
+#endif
+#include <linux/hw_mutex.h>
+
+#include "hwmutex.h"
+
+
+struct hw_master *hw_master_glob = NULL;
+
+#define to_hw_mutex_ops() (hw_master_glob->ops)
+#define to_hw_mutex(mutex) (&hw_master_glob->hw_mutexes[mutex])
+
+
+/* hw_mutex_is_locked - check whether the current master owns the mutex or not
+ * @mutex: the mutex number to be checked
+ *
+ * Return 1, if current master owns the mutex
+ * Return 0, if not
+ * Return Negative for errors
+*/
+int hw_mutex_is_locked(uint8_t mutex)
+{
+	struct hw_mutex  * hmutex = NULL;
+	struct hw_mutex_operations *hmutex_ops = to_hw_mutex_ops();
+
+	BUG_ON(mutex >= HW_MUTEX_TOTAL);
+	DEBUG_PRINTK("func %s mutex number: %x\n", __FUNCTION__,mutex);
+	hmutex = to_hw_mutex(mutex);
+	
+	return hmutex_ops->is_locked(hmutex);
+}
+
+EXPORT_SYMBOL(hw_mutex_is_locked);
+
+/*
+ * hw_mutex_isr - interrupt handler
+ * 
+ *  Sequence in case of FIFO interrupt mode:
+     1, Are we the one requesting for it? If not, then go away
+     2, Check whether we own the MUTEX
+     3, Is there a valid waiter waiting for the MUTEX? If not, then release the MUTEX
+     4, Wake up the waiter process
+ *
+ * 
+ *  Sequence in case of NULL interrupt mode: 
+     1, Are we the one wairing for it? If not, then go away
+     2, Is there a valid waiter waiting for the MUTEX? If not, then release the MUTEX
+     3, Try to lock the HW mutex again, if failure, wait for the next interrupt
+ */
+static irqreturn_t hw_mutex_isr(int irq, void *dev_id)
+{
+	struct hw_master *pmaster = (struct hw_master *)dev_id;
+	struct hw_mutex_operations *hmutex_ops = pmaster->ops;
+	struct hw_mutex *hmutex;
+	irqreturn_t	ret = IRQ_NONE;
+	int i;
+
+	switch(pmaster->mode){
+		case HW_MUTEX_FIFO_SCHE:	
+			hmutex_ops->clr_intr(pmaster);
+			ret = IRQ_HANDLED;
+			for (i = 0; i< HW_MUTEX_TOTAL; i++) {
+				hmutex = &pmaster->hw_mutexes[i]; 
+				spin_lock(&hmutex->irq_lock);
+				if (HW_MUTEX_REQUESTING == atomic_read(&hmutex->status)){ 
+					if (hmutex_ops->is_locked(hmutex)) {
+						atomic_set(&hmutex->status, HW_MUTEX_LOCKED);
+						if (likely(hw_mutex_get_owner(hmutex)))
+							wake_up_process(hmutex->owner->task);
+						else
+						/* Nobody need the MUTEX, just unlock it to avoid deadlock */
+							hmutex_ops->unlock(hmutex);				
+					}
+				}
+				spin_unlock(&hmutex->irq_lock);
+			}
+			break;
+		case HW_MUTEX_NULL_SCHE: 		
+			for (i = 0; i< HW_MUTEX_TOTAL; i++){	
+				hmutex = &pmaster->hw_mutexes[i]; 
+				if (hmutex_ops->is_waiting(hmutex)) {
+					hmutex_ops->clr_intr(pmaster);
+					spin_lock(&hmutex->irq_lock);				
+					 if (likely(hw_mutex_get_owner(hmutex))){
+						 /* Forcibly request it again */
+						 if (hmutex_ops->lock(hmutex,1))
+							 wake_up_process(hmutex->owner->task);
+					}
+					 spin_unlock(&hmutex->irq_lock);
+					 ret = IRQ_HANDLED;
+				}
+			}
+			break;
+		case HW_MUTEX_POLLING:
+			return ret;
+	}	
+	/* clear interrupt status */
+	return ret;
+}
+
+static inline long __sched
+do_wait_common(struct hw_mutex_operations *hmutex_ops, struct hw_mutex *hmutex, long timeout, int state, unsigned long flags)
+{
+
+	DEBUG_PRINT;
+	do {
+		if (hmutex_ops->is_locked(hmutex))
+			break;
+		if (unlikely(signal_pending_state(state, current))) {
+			printk(KERN_ERR "interrupt by signal\n");
+			return -EINTR;
+		}
+		__set_current_state(state);
+		spin_unlock_irqrestore(&hmutex->irq_lock,flags);	
+		timeout = schedule_timeout(timeout);
+		/* timeout:0, wake up for timer timeout, positive value: wake up by others */
+		spin_lock_irqsave(&hmutex->irq_lock,flags);	
+	} while (timeout);
+	
+	DEBUG_PRINTK("exit loop timeout 0x%x\n",(unsigned int)timeout);
+	if (likely(hmutex_ops->is_locked(hmutex))) 
+		return 0;
+	else
+    {
+        printk(KERN_ERR "HW_Mutex-ERROR: timeout while waiting to HW mutex id=%d\n",hmutex->lock_name);
+        return -EINTR;
+    }
+}
+
+
+/*
+  * hw_mutex_lock - acquire the mutex
+  * @mutex: the mutex to be acquired
+  *
+  * Lock the mutex exclusively for this task. If the mutex is not
+  * available right now, it will sleep until we can get it.
+  *
+  * The function is non interruptible
+  */
+void hw_mutex_lock(uint8_t mutex)
+{
+	struct hw_mutex  * hmutex = NULL;
+	struct hw_mutex_operations *hmutex_ops = to_hw_mutex_ops();
+	unsigned long flags;
+	long timeout;	
+	
+	BUG_ON(mutex >= HW_MUTEX_TOTAL);
+	
+	hmutex = to_hw_mutex(mutex);
+	
+	DEBUG_PRINTK("lock hmutex 0x%x, number %d\n",(unsigned int)hmutex,hmutex->lock_name);
+	might_sleep();
+		
+	mutex_lock(&hmutex->lock);
+	spin_lock_irqsave(&hmutex->irq_lock,flags);	
+	hw_mutex_set_owner(hmutex);
+	if (hmutex_ops->lock(hmutex,0)) {
+		spin_unlock_irqrestore(&hmutex->irq_lock,flags);	
+		return ;
+	}
+	timeout = do_wait_common(hmutex_ops,hmutex,MAX_SCHEDULE_TIMEOUT, TASK_UNINTERRUPTIBLE, flags);
+	if (timeout == -EINTR) 
+		hw_mutex_clear_owner(hmutex);
+	spin_unlock_irqrestore(&hmutex->irq_lock,flags);	
+
+	/* Lock failure */
+	if (timeout) 
+		mutex_unlock(&hmutex->lock);
+	return ;
+}
+
+EXPORT_SYMBOL(hw_mutex_lock);
+
+/*
+ * hw_mutex_lock_interruptible - acquire the mutex
+ * @mutex: the mutex to be acquired
+ *
+ * Lock the mutex exclusively for this task. If the mutex is not
+ * available right now, it will sleep until it can get it.
+ * It can be interruptibed by signal, or exit when timeout
+ *
+ * Returns 0 if success, negative if interrupted or timeout
+ */
+
+long __sched hw_mutex_lock_interruptible(uint8_t mutex)
+{
+	struct hw_mutex  * hmutex = NULL;
+	struct hw_mutex_operations *hmutex_ops = to_hw_mutex_ops();
+	unsigned long flags;
+	long timeout;	
+	
+	BUG_ON(mutex >= HW_MUTEX_TOTAL);
+	
+	hmutex = to_hw_mutex(mutex);
+	
+	DEBUG_PRINTK("lock hmutex(interruptible) 0x%x, number %d\n",(uint32_t)hmutex,hmutex->lock_name);
+	might_sleep();
+
+	if (mutex_lock_interruptible(&hmutex->lock))
+		return -EINTR;
+	
+	spin_lock_irqsave(&hmutex->irq_lock,flags);	
+	hw_mutex_set_owner(hmutex);
+	/* Locked */	
+	if (hmutex_ops->lock(hmutex,0)) {
+		spin_unlock_irqrestore(&hmutex->irq_lock,flags);	
+		return 0;
+	}
+	timeout = do_wait_common(hmutex_ops,hmutex,IRQ_HW_MUTEX_TIME_OUT, TASK_INTERRUPTIBLE, flags);
+	if (timeout == -EINTR)
+		hw_mutex_clear_owner(hmutex);
+	spin_unlock_irqrestore(&hmutex->irq_lock,flags);	
+
+	/* Lock failure */
+	if (timeout) 
+		mutex_unlock(&hmutex->lock);
+	return timeout;
+
+}
+EXPORT_SYMBOL(hw_mutex_lock_interruptible);
+
+/*
+ * hw_mutex_unlock - release the mutex
+ * @mutex: the mutex to be released
+ */
+void hw_mutex_unlock(uint8_t mutex)
+{
+	struct hw_mutex  * hmutex = NULL;	
+	struct hw_mutex_operations *hmutex_ops = to_hw_mutex_ops();
+	unsigned long  flags;
+	
+	BUG_ON(mutex >= HW_MUTEX_TOTAL);
+	
+	hmutex = to_hw_mutex(mutex);
+	DEBUG_PRINTK("unlock hmutex 0x%x, number %d\n",(uint32_t)hmutex,hmutex->lock_name);
+
+	if (hw_mutex_get_owner(hmutex) != current_thread_info()){	
+		printk(KERN_ERR "WARN: HW MUTEX should be released by the same owner %x\n", mutex);
+		return;
+	} else {		
+		DEBUG_PRINTK("hmutex 0x%x, number %d, owner 0x%x, released by 0x%x\n",(uint32_t)hmutex,hmutex->lock_name,(uint32_t)hw_mutex_get_owner(hmutex),(uint32_t)current_thread_info());
+		spin_lock_irqsave(&hmutex->irq_lock,flags);	
+		hmutex_ops->unlock(hmutex);
+
+		hw_mutex_clear_owner(hmutex);
+		spin_unlock_irqrestore(&hmutex->irq_lock,flags);	
+
+		mutex_unlock(&hmutex->lock);
+	}
+}
+EXPORT_SYMBOL(hw_mutex_unlock);
+
+
+int hw_mutex_register (struct hw_master *pmaster)
+{
+   if (WARN_ON(pmaster == NULL)) return -EINVAL;
+   hw_master_glob = pmaster;
+   if (pmaster->mode != HW_MUTEX_POLLING) {
+#ifdef CONFIG_X86_PUMA6
+      if (request_irq(pmaster->irq_num, hw_mutex_isr, IRQF_SHARED,HW_MUTEX_IRQ_NAME, (void *)pmaster)) {
+         printk(KERN_ERR "HW Mutex: Unable to allocate IRQ\n");
+         return -ENODEV;
+      }
+#elif CONFIG_X86_PUMA7
+     netss_subdev_irq_info_t irq_info;
+     irq_info.func = &hw_mutex_isr;
+     irq_info.args = pmaster;
+     netss_subdev_register_irq(NETSS_HW_MUTEX, &irq_info);
+#endif
+   }
+   return 0;
+}
+EXPORT_SYMBOL(hw_mutex_register);
+void hw_mutex_unregister(struct hw_master *pmaster)
+{
+#ifdef CONFIG_X86_PUMA6
+	if (WARN_ON(pmaster == NULL)) return;
+	if (pmaster->mode != HW_MUTEX_POLLING){
+		free_irq(pmaster->irq_num,(void *)pmaster);
+	}
+#elif CONFIG_X86_PUMA7
+   netss_subdev_irq_info_t irq_info;
+   irq_info.func = NULL;
+   irq_info.args = NULL;
+   netss_subdev_register_irq(NETSS_HW_MUTEX, &irq_info);
+#endif
+
+   hw_master_glob = NULL;
+}
+EXPORT_SYMBOL(hw_mutex_unregister);
+
+
+
+
--- /dev/null
+++ b/kernel/hwmutex.h
@@ -0,0 +1,65 @@
+
+/*
+ *  kernel/hw_mutex/h
+ *
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2011 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ * The file contains the main data structure and API definitions for Linux Hardware Mutex driver
+ * Intel CE processor supports 4 masters and 12 mutexes avalible
+ *
+ */
+#ifndef KERNEL_HWMUTEX_H
+#define KERNEL_HWMUTEX_H
+
+
+/* Time out if we cannot get a MUTEX within half minute */
+#define IRQ_HW_MUTEX_TIME_OUT (30*HZ)
+#define HW_MUTEX_IRQ_NAME "hw_mutex_irq"
+
+
+
+//#ifdef CONFIG_SMP
+static inline void hw_mutex_set_owner(struct hw_mutex *lock)
+{
+	lock->owner = current_thread_info();
+}
+
+static inline void hw_mutex_clear_owner(struct hw_mutex *lock)
+{
+	lock->owner = NULL;
+}
+static inline struct thread_info* hw_mutex_get_owner(struct hw_mutex *lock)
+{
+	return lock->owner;
+}
+
+#endif 
+/* end of hw_mutex.h */
+
+
+
+
+
+
