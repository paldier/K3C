From 7df3effc062805fffd6e410284a1df43bc1f97e2 Mon Sep 17 00:00:00 2001
From: Robert Li <robertx.kar-shing.li@intel.com>
Date: Wed, 8 Jun 2016 13:06:23 -0700
Subject: [PATCH 413/441] Kconfig: Changed the dependency tree for Puma7

The dependencies of all Intel modifications now follow a proper
dependency chain. X86_PUMA7 is now required to be enabled for
any Puma 7 subsystem to be enabled.

Signed-off-by: Robert Li <robertx.kar-shing.li@intel.com>

Kconfig: Removed ARCH_GEN3 from Kconfig

ARCH_GEN3 is being used for both Puma 6 and Puma 7 product lines.
If a merge between branches is desired, ARCH_GEN3 needs to be
separated individually for each PL.

Get rid of ARCH_GEN3 for P7 and replace it with the correct P7 identifier.

Signed-off-by: Robert Li <robertx.kar-shing.li@intel.com>

Kconfig: HW_MUTEX NOW DEPENDS ON X86_PUMA7

CONFIG_HW_MUTEX needs to have P7 as a dependency since it is
not applicable to vanilla i386/x64 defconfigs.

Signed-off-by: Robert Li <robertx.kar-shing.li@intel.com>

Kconfig: Added Selects and changed dependencies

Added missing dependencies for features in P7:
    APPCPU_GW_PP_HANDLE
    MRPC_CONNTRACK_CLIENT

Added selects to features that should always be on if X86_PUMA7 is enabled:
    HW_MUTEXES
    NET_SUBSYSTEM
    HW_MAILBOX
    IOSF_MBI
    PUMA_ACPI

Signed-off-by: Robert Li <robertx.kar-shing.li@intel.com>

Kconfig: IOSF_PRIMARY now depends PUMA_THERMAL

IOSF_PRIMARY is now dependent on PUMA_THERMAL
this is because IOSF_PRIMARY is a option to
enable features in PUMA_THERMAL.

Signed-off-by: Robert Li <robertx.kar-shing.li@intel.com>

Kconfig: No longer is every feature part of Puma7

Edited so that not all features ported from Mainline are
dependent on X86_PUMA7. Only features introduced specfically
for Puma7 is dependent on X86_PUMA7 now.

Removed from X86_PUMA7 dependency:
MTD_SPI_NOR
USB_OTG_FSM
MMC_SDHCI_ACPI
IOSF_MBI
INTEL_MEI_TXE
SPI_PXA2XX_PCI
SERIAL_HSU

Added to X86_PUMA7 dependency:
SPI_INTEL_SPI_PLATFORM
INTEL_CHT_PHY
MMC_SDHCI_ACPI_FORCE_POWER_ON
PUMA_ACPI

Signed-off-by: Robert Li <robertx.kar-shing.li@intel.com>

Kconfig: Changed a few descriptions for Puma6/7

Changed the description for the features below to be more understandable:
TI_PACKET_PROCESSOR_STATS, X86_AVALANCHE_SOC, X86_PUMA6, X86_PUMA7

Signed-off-by: Robert Li <robertx.kar-shing.li@intel.com>

Kconfig: Formatted certain Kconfig changes

Changed some tabs to spaces so that the output aligns on bitbucket.
Removed a comment that was irrelevant.
Changed the config IOSF_PRIMARY to PUMA_THERMAL_USE_IOSF_PRIMARY
Changes were made to drivers/thermal/puma_thermal.c to accommodate this.

Signed-off-by: Robert Li <robertx.kar-shing.li@intel.com>

Kconfig: Merged Puma6 and Puma7 Kconfigs

This uses both the newest P7 Kconfig merged with the
newest P6 Kconfigs.
This merge will not function correctly without
correcting overlaps and P6 or P7 specifics.

Signed-off-by: Robert Li <robertx.kar-shing.li@intel.com>

Kconfig: Merged P7 with P6

This fixes known discrepancies between P7 and P6.
This will add &&s to dependencies that are shared between P6 and P7.
These configs with either (&& X86_PUMA[67]) are shared dependences
which should not be used if possible.
If used improperly it will clutter the Kconfig.

Signed-off-by: Robert Li <robertx.kar-shing.li@intel.com>
---
 arch/x86/Kconfig                              | 88 ++++++++++++++++++---------
 arch/x86/include/asm/hpet.h                   |  2 +-
 arch/x86/include/asm/pci.h                    |  2 +-
 arch/x86/include/uapi/asm/bootparam.h         |  2 +-
 arch/x86/kernel/early_printk.c                |  4 +-
 arch/x86/kernel/hpet.c                        |  2 +-
 arch/x86/kernel/reboot.c                      |  8 +--
 arch/x86/kernel/setup.c                       |  4 +-
 arch/x86/kernel/tsc.c                         |  2 +-
 arch/x86/mm/init_32.c                         |  4 +-
 arch/x86/mm/pat.c                             |  4 +-
 arch/x86/pci/Makefile                         |  2 +-
 arch/x86/pci/acpi.c                           |  2 +-
 drivers/base/core.c                           |  2 +-
 drivers/base/power/main.c                     |  8 +--
 drivers/char/mem.c                            |  2 +-
 drivers/gpio/Kconfig                          | 13 ++--
 drivers/gpio/gpio-sch.c                       |  4 +-
 drivers/gpio/gpiolib.c                        |  6 +-
 drivers/i2c/Kconfig                           |  7 +++
 drivers/i2c/busses/Kconfig                    |  5 +-
 drivers/misc/Kconfig                          |  6 +-
 drivers/misc/heci/Kconfig                     |  1 +
 drivers/mmc/host/Kconfig                      |  1 +
 drivers/mrpc/Kconfig                          |  2 +-
 drivers/mtd/chips/cfi_cmdset_0001.c           |  4 +-
 drivers/mtd/devices/Kconfig                   |  2 +-
 drivers/mtd/spi-nor/Kconfig                   |  1 +
 drivers/net/Kconfig                           | 10 +--
 drivers/net/ethernet/intel/e1000/e1000_hw.c   | 42 ++++++-------
 drivers/net/ethernet/intel/e1000/e1000_hw.h   | 20 +++---
 drivers/net/ethernet/intel/e1000/e1000_main.c | 16 ++---
 drivers/net/ethernet/synopsys/Kconfig         |  3 +-
 drivers/pci/pci-driver.c                      |  4 +-
 drivers/pci/pci.c                             |  6 +-
 drivers/pci/pcie/portdrv.h                    |  2 +-
 drivers/pci/pcie/portdrv_core.c               |  4 +-
 drivers/pci/pcie/portdrv_pci.c                |  2 +-
 drivers/pci/probe.c                           |  2 +-
 drivers/platform/x86/Kconfig                  |  2 +-
 drivers/regulator/Kconfig                     |  3 +-
 drivers/spi/Kconfig                           | 30 ++++++++-
 drivers/thermal/Kconfig                       |  5 +-
 drivers/thermal/puma_thermal.c                | 10 +--
 drivers/tty/serial/8250/Kconfig               |  7 +++
 drivers/tty/serial/hsu/Kconfig                |  2 +-
 drivers/uio/Kconfig                           | 10 +++
 drivers/usb/host/Kconfig                      |  9 +++
 drivers/usb/host/ehci-hcd.c                   |  4 ++
 drivers/usb/phy/Kconfig                       |  1 +
 drivers/watchdog/Kconfig                      | 14 ++++-
 include/asm-generic/gpio.h                    |  8 +--
 include/linux/mm.h                            |  4 ++
 include/linux/tty.h                           |  4 ++
 kernel/irq/chip.c                             |  2 +-
 kernel/irq/irqdesc.c                          |  2 +-
 kernel/pid.c                                  |  2 +-
 kernel/power/main.c                           |  2 +-
 kernel/reboot.c                               |  4 +-
 kernel/signal.c                               |  2 +-
 net/Kconfig                                   |  2 +-
 net/bridge/netfilter/Kconfig                  |  1 +
 62 files changed, 278 insertions(+), 153 deletions(-)

--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -441,17 +441,10 @@ config X86_INTEL_CE
 	  This option compiles in support for the CE4100 SOC for settop
 	  boxes and media devices.
 
-menu "Intel Media SOC Gen3 support"
-
-config ARCH_GEN3
-        bool "Enable Intel Media SOC Gen3 support"
-        default y
-
-endmenu
-
 config NET_SUBSYSTEM
     bool "Net IP controller support for Intel CE2600 platform"
-        depends on ARCH_GEN3
+        depends on X86_PUMA7
+        select HW_MAILBOX
         default y
         ---help---
           This is the NET-IP subsystem support for Intel CE2600 platform.
@@ -471,23 +464,34 @@ menu  "Intel PUMA7 AVALANCHE support"
         default n
     config  TI_PACKET_PROCESSOR
         bool "Packet processor data pipe"
-        depends on X86_PUMA7
         depends on ARM_AVALANCHE_PDSP_PP
         default n
+	---help---
+	  Say yes here to enable the TI packet processor
+	  The TIPP implements packet filtering and logging rules
+	  and is part of the netfilter framework.
+	  Package is part of the P7 platform netfiltering capabilities.
     config TI_PACKET_PROCESSOR_STATS
         bool "Packet processor stats"
-        depends on X86_PUMA7
-        depends on ARM_AVALANCHE_PDSP_PP
+        depends on TI_PACKET_PROCESSOR
         default n
+	---help---
+	  Say yes here to enable the TI packet processor stats feature
+	  TIPP_STATS implements a feature that allows the reading of
+	  TIPP filters.
+	  Package is part of the P7 platform netfiltering capabilities.
     config X86_AVALANCHE_SOC
         bool "Packet processor data pipe support"
-        depends on X86_PUMA7 && TI_PACKET_PROCESSOR
-        depends on ARM_AVALANCHE_PDSP_PP
+        depends on TI_PACKET_PROCESSOR
         default n
+	---help---
+	  Say yes here to enable X86_AVALANCHE_SOC support
+	  X86_AVALANCHE_SOC implements packet processing features
+	  used by the Puma7 SoC.
+	  Package is part of the P7 platform packet processing capabilities.
     config TI_META_DATA
         bool "Packet processor meta data support"
-        depends on X86_PUMA7 && TI_PACKET_PROCESSOR
-        depends on ARM_AVALANCHE_PDSP_PP && X86_AVALANCHE_SOC
+        depends on X86_AVALANCHE_SOC
         default n
 
         
@@ -495,9 +499,10 @@ menu  "Intel PUMA7 AVALANCHE support"
 endmenu
 
 config HW_MUTEXES
-        tristate "MUTEX controller support for Intel CE2600 platform"
-        depends on ARCH_GEN3 && NET_SUBSYSTEM
-        default y
+	bool "MUTEX controller support for Intel CE2600 platform"
+	depends on X86_PUMA7 || X86_PUMA6
+	select CE_MAILBOX if X86_PUMA6
+	default y
 	---help---
 	This is the MUTEX controller support for Intel CE2600 platform.
 	If unsure, say Y.
@@ -524,21 +529,33 @@ config MUTEX_POLLING
 	works in polling mode, interrupt is disabled
 endchoice
 
-choice 
-	depends on HW_MUTEXES
-	prompt "MUTEX controller configuration"
-	default X86_PUMA7
 
 config X86_PUMA6
-	bool "Puma6 Mutex controller"
-	
+	bool "Puma6 Architecture Support"
+	select HW_MUTEXES
+	default n
+	---help---
+	Enables all config options necessary for Puma6 SoC support.
+	Features include but are not limited to:
+	HW_MUTEXES, MTD_NMYX25, CE_MAILBOX, UDMA, GPIO_INTELCE, GEN3_SPI,
+	GEN3_USB, SPI_CE5XX_SPI_SLAVE, SPI_CE5XX_SPI_FLASH, GEN3_UART,
+	INTELCE_WDT, GEN3_I2C, UIO_PCI_CE2600
 config X86_PUMA7
-	bool "Puma7 Mutex controller"
-endchoice
-
+	bool "Puma7 Architecture Support"
+	select IOSF_MBI
+	select HW_MUTEXES
+	select NET_SUBSYSTEM
+	default y
+	---help---
+	Enables all config options necessary for Puma7 SoC support.
+	Features include but are not limited to:
+	HW_MUTEXES, DWC_QOS, NET_SUBSYSTEM, HW_MAILBOX, CE_MAILBOX, MRPC,
+	ARM_AVALANCHE, INTEL_CHT_PHY, INTEL_ISS, MMC_SDHCI_ACPI_POWER_ON,
+	GMIN_INTEL_MID, GPIO_INTELCE2700, INTEL_MEI_TXE, REGULATOR_INT34D9,
+	PUMA_THERMAL, BRIDGE_EBT_FORWARD, SPI_INTEL_SPI_PLATFORM
 config HW_MAILBOX
         tristate "HW Mailbox support for Intel CE2600 platform"
-        depends on ARCH_GEN3 && NET_SUBSYSTEM
+        depends on NET_SUBSYSTEM
         default y
 	---help---
 	This is the HW Mailbox support for Intel CE2600 platform.
@@ -546,7 +563,7 @@ config HW_MAILBOX
 
 config X86_INTEL_CE2700
         tristate "Intel CE2700 Platform Support"
-        depends on ARCH_GEN3
+        depends on X86_PUMA7
         default y
 	---help---
 	Select to build a kernel capable of supporting CE2700 platform drivers.
@@ -590,6 +607,7 @@ endif
 
 config GMIN_INTEL_MID
        bool "G-Min minimal INTEL_MID support"
+       depends on X86_PUMA7
        ---help---
          Select Y to build a kernel capable of booting on G-Min
          enabled devices without the full INTEL_MID/SFI firmware
@@ -609,6 +627,8 @@ config X86_INTEL_LPSS
 config IOSF_MBI
         tristate "Intel SoC IOSF Sideband support for SoC platforms"
         depends on PCI
+	select PUMA_ACPI
+	default y
         ---help---
           This option enables sideband register access support for Intel SoC
           platforms. On these platforms the IOSF sideband is used in lieu of
@@ -835,6 +855,14 @@ endif #HYPERVISOR_GUEST
 
 config NO_BOOTMEM
 	def_bool y
+	bool "Disable Bootmem code"
+        ---help---
+          Use early_res directly instead of bootmem before slab is ready.
+                - allocator (buddy) [generic]
+                - early allocator (bootmem) [generic]
+                - very early allocator (reserve_early*()) [x86]
+                - very very early allocator (early brk model) [x86]
+          So reduce one layer between early allocator to final allocator
 
 config MEMTEST
 	bool "Memtest"
--- a/arch/x86/include/asm/hpet.h
+++ b/arch/x86/include/asm/hpet.h
@@ -71,7 +71,7 @@ extern int hpet_enable(void);
 extern void hpet_disable(void);
 extern unsigned int hpet_readl(unsigned int a);
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 extern void hpet_enable_legacy_int(void);
 extern void hpet_disable_legacy_int(void);
 #endif
--- a/arch/x86/include/asm/pci.h
+++ b/arch/x86/include/asm/pci.h
@@ -165,7 +165,7 @@ struct pci_setup_rom {
 #define CE5300_SOC_DEVICE_ID 0x0C40
 #define CE2600_SOC_DEVICE_ID 0x0931
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 
 
 #define INTELCE_EMMC_PCI_DEVICE_ID       0x070b
--- a/arch/x86/include/uapi/asm/bootparam.h
+++ b/arch/x86/include/uapi/asm/bootparam.h
@@ -7,7 +7,7 @@
 #define SETUP_DTB			2
 #define SETUP_PCI			3
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 #define SETUP_BOARD_TYPE          (0x1000)
 #define SETUP_GMAC_PHY_MODE	  (0x1001)
 #define SETUP_BOARD_REV		  (0x1002)
--- a/arch/x86/kernel/early_printk.c
+++ b/arch/x86/kernel/early_printk.c
@@ -150,7 +150,7 @@ static __init void early_serial_init(cha
 	outb(0x3, early_serial_base + LCR);	/* 8n1 */
 	outb(0, early_serial_base + IER);	/* no interrupt */
 	outb(0, early_serial_base + FCR);	/* no fifo */
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	outb(0x0, early_serial_base + MCR);	/* DTR + RTS */
 #else
 	outb(0x3, early_serial_base + MCR);	/* DTR + RTS */
@@ -162,7 +162,7 @@ static __init void early_serial_init(cha
 			baud = DEFAULT_BAUD;
 	}
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	divisor = BASE_BAUD/baud;
 #else
 	divisor = 115200 / baud;
--- a/arch/x86/kernel/hpet.c
+++ b/arch/x86/kernel/hpet.c
@@ -282,7 +282,7 @@ static void hpet_resume_counter(struct c
 	hpet_resume_device();
 	hpet_restart_counter();
 }
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 void hpet_disable_legacy_int(void)
 {
         unsigned int cfg = hpet_readl(HPET_CFG);
--- a/arch/x86/kernel/reboot.c
+++ b/arch/x86/kernel/reboot.c
@@ -28,7 +28,7 @@
 #include <linux/mc146818rtc.h>
 #include <asm/realmode.h>
 #include <asm/x86_init.h>
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 #include <linux/pci.h>
 #include <linux/punit_reboot_sync.h>
 #endif
@@ -508,7 +508,7 @@ static void native_machine_emergency_res
 	int attempt = 0;
 	int orig_reboot_type = reboot_type;
 	unsigned short mode;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
         int id;
         intelce_get_soc_info(&id, NULL);
 #endif
@@ -533,7 +533,7 @@ static void native_machine_emergency_res
 /*
  * The following code is for Intel Media SOC Gen3 base support.
 */
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 /*
  * Intel Media SOC Gen3 uses this specific method to reboot.
 */
@@ -665,7 +665,7 @@ static void native_machine_power_off(voi
 /*
  * The following code is for Intel Media SOC Gen3 base support.
 */
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 /*
  * Intel Media SOC Gen3 uses this specific way to power off.
 */
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -111,7 +111,7 @@
 #include <asm/alternative.h>
 #include <asm/prom.h>
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 extern int set_gmac_phy_mode(uint32_t phy_mode);
 #endif
 
@@ -452,7 +452,7 @@ static void __init parse_setup_data(void
 		case SETUP_DTB:
 			add_dtb(pa_data);
 			break;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 		case SETUP_BOARD_TYPE:
 			intelce_set_board_type(data_at_addr);
 			break;
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -230,7 +230,7 @@ static unsigned long pit_calibrate_tsc(u
 	pitcnt = 0;
 	tscmax = 0;
 	tscmin = ULONG_MAX;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 /*
  * The following code is for Intel Media SOC Gen3 B0 and B1 workaround.
 */
--- a/arch/x86/mm/init_32.c
+++ b/arch/x86/mm/init_32.c
@@ -55,7 +55,7 @@
 
 #include "mm_internal.h"
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 #define GBE_CONFIG_RAM_BASE    0x60000
 #define GBE_CONFIG_DATA_LENGTH 0x200
 /* from $(KERNEL)/drivers/net/e1000/gbe_mac_access.h */
@@ -696,7 +696,7 @@ void __init setup_bootmem_allocator(void
 	printk(KERN_INFO "  mapped low ram: 0 - %08lx\n",
 		 max_pfn_mapped<<PAGE_SHIFT);
 	printk(KERN_INFO "  low ram: 0 - %08lx\n", max_low_pfn<<PAGE_SHIFT);
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 #ifdef CONFIG_SMP
 	memblock_reserve(GBE_CONFIG_RAM_BASE, GBE_CONFIG_DATA_LENGTH); //RAM reverve for Gbe mac
         memblock_reserve(ACPI_RAM_BASE, ACPI_DATA_LENGTH); //RAM reserve for ACPI data
--- a/arch/x86/mm/pat.c
+++ b/arch/x86/mm/pat.c
@@ -487,7 +487,7 @@ pgprot_t phys_mem_access_prot(struct fil
 	return vma_prot;
 }
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 EXPORT_SYMBOL_GPL(phys_mem_access_prot);
 #endif
 
@@ -556,7 +556,7 @@ int phys_mem_access_prot_allowed(struct
 	return 1;
 }
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 EXPORT_SYMBOL_GPL(phys_mem_access_prot_allowed);
 #endif
 
--- a/arch/x86/pci/Makefile
+++ b/arch/x86/pci/Makefile
@@ -5,7 +5,7 @@ obj-$(CONFIG_PCI_MMCONFIG)	+= mmconfig_$
 obj-$(CONFIG_PCI_DIRECT)	+= direct.o
 obj-$(CONFIG_PCI_OLPC)		+= olpc.o
 obj-$(CONFIG_PCI_XEN)		+= xen.o
-obj-$(CONFIG_ARCH_GEN3)         += intel_media_proc_gen3.o
+obj-$(CONFIG_X86_PUMA6)         += intel_media_proc_gen3.o
 
 obj-y				+= fixup.o
 obj-$(CONFIG_X86_INTEL_CE)      += ce4100.o
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -26,7 +26,7 @@ struct pci_root_info {
  * The following code is for Intel Media SOC SMP support. Since kernel can not get a correct ACPI data from CEFDK,
  * thus by default we force to ignore host bridge windows from ACPI
  */
-#if defined(CONFIG_ARCH_GEN3) & defined(CONFIG_SMP)
+#if defined(CONFIG_X86_PUMA6) & defined(CONFIG_SMP)
 static bool pci_use_crs = false;
 #else
 static bool pci_use_crs = true;
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1327,7 +1327,7 @@ void device_unregister(struct device *de
 }
 EXPORT_SYMBOL_GPL(device_unregister);
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 struct device *next_device(struct klist_iter *i)
 #else
 static struct device *next_device(struct klist_iter *i)
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -33,7 +33,7 @@
 #include "../base.h"
 #include "power.h"
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 int suspend_device(struct device *dev, pm_message_t state);
 int resume_device(struct device *dev, pm_message_t state);
 #endif
@@ -60,7 +60,7 @@ struct suspend_stats suspend_stats;
 static DEFINE_MUTEX(dpm_list_mtx);
 static pm_message_t pm_transition;
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 int async_error;
 #else
 static int async_error;
@@ -671,7 +671,7 @@ static void async_resume(void *data, asy
 	put_device(dev);
 }
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 int resume_device(struct device *dev, pm_message_t state)
 {
         return device_resume(dev,state,false);
@@ -1191,7 +1191,7 @@ static int device_suspend(struct device
 	return __device_suspend(dev, pm_transition, false);
 }
 
-#if CONFIG_ARCH_GEN3
+#if CONFIG_X86_PUMA6
 int suspend_device(struct device *dev, pm_message_t state)
 {
        return  __device_suspend(dev, state, false);
--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@ -37,7 +37,7 @@
 
 #define DEVPORT_MINOR	4
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 int range_is_sys_ram(unsigned long pfn, unsigned long size)
 {
         u64 from = ((u64)pfn) << PAGE_SHIFT;
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -288,10 +288,14 @@ config GPIO_VR41XX
 	  Say yes here to support the NEC VR4100 series General-purpose I/O Uint
 
 config GPIO_INTELCE
-        tristate "INTELCE GPIO support"
-        depends on GPIOLIB && ARCH_GEN3
-        help
-          Say yes here to support GPIO functionality of IntelCE soc I/O controller.
+	tristate "INTELCE GPIO support"
+	depends on X86_PUMA6
+	---help---
+	  Say yes here to support GPIO functionality of IntelCE
+	  soc I/O controller.
+	  General Purpose Input/Output support.
+	  This feature is part of Puma 6.
+
 config GPIO_SCH
 	tristate "Intel SCH/TunnelCreek/Centerton GPIO"
 	depends on PCI && X86
@@ -768,6 +772,7 @@ comment "USB GPIO expanders:"
 
 config GPIO_INTELCE2700
         bool "Intel CE 2700 GPIO gpio support"
+        depends on X86_PUMA7
         depends on GPIOLIB && ACPI && X86
         select IRQ_DOMAIN
         help
--- a/drivers/gpio/gpio-sch.c
+++ b/drivers/gpio/gpio-sch.c
@@ -109,7 +109,7 @@ static int sch_gpio_core_direction_out(s
 		outb(curr_dirs & ~(1 << bit), gpio_ba + offset);
 
 	spin_unlock(&gpio_lock);
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
         sch_gpio_core_set(gc, gpio_num, val);
 #endif
 	return 0;
@@ -223,7 +223,7 @@ static int sch_gpio_probe(struct platfor
 		return -EBUSY;
 
 	gpio_ba = res->start;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
         res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
         gpio_base = res->start;
 #endif
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -512,7 +512,7 @@ found:
 }
 
 static DEVICE_ATTR(edge, 0644, gpio_edge_show, gpio_edge_store);
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 static ssize_t gpio_multi_show(struct device *dev,
                 struct device_attribute *attr, char *buf)
 {
@@ -866,7 +866,7 @@ static int gpiod_export(struct gpio_desc
 		if (status)
 			goto fail_remove_attr_direction;
 	}
-#ifdef CONFIG_ARCH_GEN3                 
+#ifdef CONFIG_X86_PUMA6                 
 	if (!status && (gpio_get_multi_function(desc_to_gpio(desc)) >= 0)) {
 		status = device_create_file(dev, &dev_attr_multi);
                 if (status)
@@ -2133,7 +2133,7 @@ void gpio_set_value_cansleep(unsigned gp
 }
 EXPORT_SYMBOL_GPL(gpio_set_value_cansleep);
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 /*  Some gpio pin supports multi function usage, the following two functions are used to configure 
  *  GPIO mux register.
  */
--- a/drivers/i2c/Kconfig
+++ b/drivers/i2c/Kconfig
@@ -23,6 +23,13 @@ menuconfig I2C
 
 if I2C
 
+config GEN3_I2C
+        bool "Intel Media SOC I2C support"
+        depends on X86_PUMA6
+        default y
+        help
+          This option enables Intel Media SOC I2C support.
+
 config I2C_BOARDINFO
 	boolean
 	default y
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -627,7 +627,10 @@ config I2C_PXA
 	  will be called i2c-pxa.
 
 config I2C_PXA_PCI
-	def_bool I2C_PXA && X86_32 && PCI && OF
+	tristate "Intel CE I2C PCI adapter"
+	depends on I2C_PXA && X86_32 && PCI && OF
+	help
+	  This drivers supports the Intel CEXXXX I2C controller
 
 config I2C_PXA_SLAVE
 	bool "Intel PXA2XX I2C Slave comms support"
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -529,15 +529,13 @@ config SRAM
 	  areas found on many SoCs.
 
 config  CE_MAILBOX
-        tristate "CE Mailbox support for Intel Puma7 platform"
-        depends on ARCH_GEN3
-        depends on HW_MAILBOX
+        tristate "CE Mailbox support for Intel Puma6/7 platform"
+        depends on (HW_MAILBOX && X86_PUMA7) || (HW_MUTEXES && X86_PUMA6)
         default y
         help
          This is a simple CE mailbox driver support for communication
          between NPCPU and APPCPU processor. If unsure, say Y.
 
-
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
--- a/drivers/misc/heci/Kconfig
+++ b/drivers/misc/heci/Kconfig
@@ -1,5 +1,6 @@
 config INTEL_ISS
 	tristate "Intel Integrated Sensors Solution"
+	depends on X86_PUMA7
 	depends on X86 && PCI
 	help
 	  ISS enabled sensors hub functionality on SoC/chipset level.
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -96,6 +96,7 @@ config MMC_SDHCI_ACPI
 
 config MMC_SDHCI_ACPI_FORCE_POWER_ON
 	bool "Force Power On through ACPI methods"
+	depends on X86_PUMA7
 	depends on MMC_SDHCI_ACPI
 	help
 	  This forces the controller and all connected devices to
--- a/drivers/mrpc/Kconfig
+++ b/drivers/mrpc/Kconfig
@@ -28,7 +28,7 @@ config MRPC_SERVER_EXAMPLE
 
 config MRPC_CONNTRACK_CLIENT
     bool "ATOM to ARM CONNTRACK RPC over HW Mailbox"
-    depends on MRPC
+    depends on MRPC && APPCPU_GW_PP_HANDLE
     default n
     help
        Enable Puma7 conntrack MRPC between ATOM and ARM
--- a/drivers/mtd/chips/cfi_cmdset_0001.c
+++ b/drivers/mtd/chips/cfi_cmdset_0001.c
@@ -765,7 +765,7 @@ static int chip_ready (struct map_info *
 
 	case FL_STATUS:
 		for (;;) {
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 			/* Add issuing READ STATUS command before reading
 			 * flash status to guarantee the status read is
 			 * correct.
@@ -2099,7 +2099,7 @@ static int __xipram do_xxlock_oneblock(s
 	}
 
 	xip_enable(map, chip, adr);
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	// Intel specs require this call. Because I don't know how xip works I simply add this call. It shouldn't harm
 	map_write(map, CMD(0xFF), adr);
 #endif
--- a/drivers/mtd/devices/Kconfig
+++ b/drivers/mtd/devices/Kconfig
@@ -129,7 +129,7 @@ config MTD_SST25L
 
 config MTD_NMYX25
 	tristate "Support N25Q256 M25P32 SPI Flash chips"
-	depends on SPI_MASTER && HW_MUTEXES
+	depends on SPI_MASTER && (HW_MUTEXES && X86_PUMA6)
 	help
 	  This enables access to the N25Q256 AND M25P32 SPI flash chips, used
 	  for program and data storage.
--- a/drivers/mtd/spi-nor/Kconfig
+++ b/drivers/mtd/spi-nor/Kconfig
@@ -26,6 +26,7 @@ config SPI_INTEL_SPI
 
 config SPI_INTEL_SPI_PLATFORM
         tristate "Intel PCH/PCU SPI flash platform driver"
+        depends on X86_PUMA7
         depends on X86
         select SPI_INTEL_SPI
         help
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -297,7 +297,7 @@ config NET_SB1000
 
 menuconfig UDMA
 	tristate "Intel(R) UDMA Driver support"
-        depends on ARCH_GEN3
+	depends on X86_PUMA6
 	default y
 	---help---
 	  For general information and support, go to the Intel support
@@ -313,13 +313,13 @@ config UDMA_RATE_LIMITATION
 	bool "UDMA rate limitation support"
 	default n
 	help
-        Add UDMA rate limitation support
+	  Add UDMA rate limitation support
 
 config  UDMA_DEBUG
-    	bool "udma debug tool support"
+	bool "udma debug tool support"
 	default y
-       help
-       Add UDMA debug tool support
+	help
+	  Add UDMA debug tool support
 endif
 
 source "drivers/net/phy/Kconfig"
--- a/drivers/net/ethernet/intel/e1000/e1000_hw.c
+++ b/drivers/net/ethernet/intel/e1000/e1000_hw.c
@@ -137,7 +137,7 @@ static s32 e1000_set_phy_type(struct e10
 		break;
 	case RTL8211B_PHY_ID:
 		hw->phy_type = e1000_phy_8211;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 		if (hw->phy_revision == RTL8211D_PHY_REV_ID)
         	hw->phy_type = e1000_phy_8211d;
 		else if (hw->phy_revision == RTL8211E_PHY_REV_ID)
@@ -147,7 +147,7 @@ static s32 e1000_set_phy_type(struct e10
 	case RTL8201N_PHY_ID:
 		hw->phy_type = e1000_phy_8201;
 		break;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	case RTL8201E_PHY_ID:
 		hw->phy_type = e1000_phy_8201e;
 		if (hw->phy_revision == RTL8201FR_PHY_REV_ID)
@@ -416,7 +416,7 @@ void e1000_set_media_type(struct e1000_h
 	}
 }
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 static DEFINE_SPINLOCK(gbe_cru_lock);
 unsigned long cru_irqlocal;
 
@@ -509,7 +509,7 @@ s32 e1000_reset_hw(struct e1000_hw *hw)
 		/* Reset is performed on a shadow of the control register */
 		ew32(CTRL_DUP, (ctrl | E1000_CTRL_RST));
 		break;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	case e1000_ce4100:
 		/* Reset should synchronize with AVSync register accessed */
 		gbe_cru_lock_acquire(&cru_irqlocal);
@@ -1044,7 +1044,7 @@ static s32 gbe_dhg_phy_setup(struct e100
 {
 	s32 ret_val;
 	u32 ctrl_aux;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	u16 phy_data;
 #endif
 
@@ -1055,7 +1055,7 @@ static s32 gbe_dhg_phy_setup(struct e100
 			e_dbg("e1000_copper_link_rtl_setup failed!\n");
 			return ret_val;
 		}
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 		switch (hw->phy_mode) {
 			case FAKE_PHY_INTERNAL:
 				ctrl_aux = er32(CTL_AUX);
@@ -1073,7 +1073,7 @@ static s32 gbe_dhg_phy_setup(struct e100
 		}
 #endif
 		break;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	case e1000_phy_8211d:
 	case e1000_phy_8211e:
 		ret_val = e1000_copper_link_rtl_setup(hw);
@@ -1102,7 +1102,7 @@ static s32 gbe_dhg_phy_setup(struct e100
 			e_dbg("e1000_copper_link_rtl_setup failed!\n");
 			return ret_val;
 		}
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 		/* RMII mode setting in 8201N PHY chip */
 		ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data);
 		if (ret_val)
@@ -1116,7 +1116,7 @@ static s32 gbe_dhg_phy_setup(struct e100
 #endif
 		break;
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	case e1000_phy_8201e:
 		/* Set RMII mode */
 		ctrl_aux = er32(CTL_AUX);
@@ -1530,7 +1530,7 @@ static s32 e1000_copper_link_autoneg(str
 		hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;
 
 	/* IFE/RTL8201N PHY only supports 10/100 */
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	if ((hw->phy_type == e1000_phy_8201) || (hw->phy_type == e1000_phy_8201e) || \
 		(hw->phy_type == e1000_phy_8201fr) || (hw->phy_type == e1000_phy_lan8720a))
 #else
@@ -1685,7 +1685,7 @@ static s32 e1000_setup_copper_link(struc
 		if (ret_val)
 			return ret_val;
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 		hw->cegbe_is_link_up = (phy_data & MII_SR_LINK_STATUS) != 0;
 #endif
 
@@ -1725,7 +1725,7 @@ s32 e1000_phy_setup_autoneg(struct e1000
 		return ret_val;
 
 	/* Read the MII 1000Base-T Control Register (Address 9). */
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	if ((hw->phy_type == e1000_phy_8201) || (hw->phy_type == e1000_phy_8201e) || \
 		(hw->phy_type == e1000_phy_8201fr) || (hw->phy_type == e1000_phy_lan8720a)) {
 		mii_1000t_ctrl_reg = 0;
@@ -1854,7 +1854,7 @@ s32 e1000_phy_setup_autoneg(struct e1000
 
 	e_dbg("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	if ((hw->phy_type == e1000_phy_8201) || (hw->phy_type == e1000_phy_8201e)|| \
 		(hw->phy_type == e1000_phy_8201fr) || (hw->phy_type == e1000_phy_lan8720a)) {
 #else
@@ -2182,7 +2182,7 @@ static s32 e1000_config_mac_to_phy(struc
 
 		e1000_config_collision_dist(hw);
 		break;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	case e1000_phy_8201e:
 	case e1000_phy_8201fr:
 	case e1000_phy_lan8720a:
@@ -2687,7 +2687,7 @@ s32 e1000_check_for_link(struct e1000_hw
 		if (ret_val)
 			return ret_val;
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 		hw->cegbe_is_link_up = (phy_data & MII_SR_LINK_STATUS) != 0;
 #endif
 
@@ -3053,7 +3053,7 @@ static u16 e1000_shift_in_mdi_bits(struc
 	return data;
 }
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 static s32 e1000_read_phy_reg_fake(struct e1000_hw *hw, u32 reg_addr, u16 *phy_data)
 {
 	switch (reg_addr) {
@@ -3119,7 +3119,7 @@ s32 e1000_read_phy_reg(struct e1000_hw *
 
 	spin_lock_irqsave(&e1000_phy_lock, flags);
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	if(hw->phy_mode != REAL_PHY) {
 	        spin_unlock_irqrestore(&e1000_phy_lock, flags);
             return e1000_read_phy_reg_fake(hw, reg_addr, phy_data);
@@ -3250,7 +3250,7 @@ static s32 e1000_read_phy_reg_ex(struct
 	return E1000_SUCCESS;
 }
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 static s32 e1000_write_phy_reg_fake(struct e1000_hw *hw, u32 reg_addr, u16 phy_data)
 {
 	return E1000_SUCCESS;
@@ -3275,7 +3275,7 @@ s32 e1000_write_phy_reg(struct e1000_hw
 
 	spin_lock_irqsave(&e1000_phy_lock, flags);
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	if(hw->phy_mode != REAL_PHY) {
 	        spin_unlock_irqrestore(&e1000_phy_lock, flags);
             return e1000_write_phy_reg_fake(hw, reg_addr, phy_data);
@@ -3536,7 +3536,7 @@ static s32 e1000_detect_gig_phy(struct e
 			match = true;
 		break;
 	case e1000_ce4100:
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 		if ((hw->phy_id == RTL8211B_PHY_ID) ||
 		    (hw->phy_id == RTL8201N_PHY_ID) ||
 		    (hw->phy_id == RTL8201E_PHY_ID) ||
@@ -3797,7 +3797,7 @@ s32 e1000_phy_get_info(struct e1000_hw *
 
 	if (hw->phy_type == e1000_phy_igp)
 		return e1000_phy_igp_get_info(hw, phy_info);
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	else if ((hw->phy_type == e1000_phy_8211) ||
 			(hw->phy_type == e1000_phy_8201e) ||
 			(hw->phy_type == e1000_phy_lan8720a) ||
--- a/drivers/net/ethernet/intel/e1000/e1000_hw.h
+++ b/drivers/net/ethernet/intel/e1000/e1000_hw.h
@@ -214,7 +214,7 @@ typedef enum {
 	e1000_phy_igp,
 	e1000_phy_8211,
 	e1000_phy_8201,
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	e1000_phy_8201e,
 	e1000_phy_8211d,
 	e1000_phy_8211e,
@@ -1355,7 +1355,7 @@ struct e1000_hw_stats {
 	u64 icrxoc;
 };
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 enum phy_mode {
 	REAL_PHY = 0,
 	FAKE_PHY_INTERNAL,
@@ -1392,7 +1392,7 @@ struct e1000_hw {
 	u32 phy_id;
 	u32 phy_revision;
 	u32 phy_addr;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	enum phy_mode phy_mode;
 #endif
 	u32 original_fc;
@@ -1453,7 +1453,7 @@ struct e1000_hw {
 	bool leave_av_bit_off;
 	bool bad_tx_carr_stats_fd;
 	bool has_smbus;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	bool cegbe_is_link_up;
 #endif
 };
@@ -2275,7 +2275,7 @@ struct e1000_host_command_info {
 #define EEPROM_FLASH_VERSION          0x0032
 #define EEPROM_CHECKSUM_REG           0x003F
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 #define EEPROM_CE4100_FAKE_LENGTH     0x80
 #endif
 
@@ -2544,7 +2544,7 @@ struct e1000_host_command_info {
 #define PHY_1000T_CTRL   0x09	/* 1000Base-T Control Reg */
 #define PHY_1000T_STATUS 0x0A	/* 1000Base-T Status Reg */
 #define PHY_EXT_STATUS   0x0F	/* Extended Status Reg */
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 #define PHY_TEST_REG     0x19 /* Test Register */
 #endif
 
@@ -2631,7 +2631,7 @@ struct e1000_host_command_info {
 #define MII_CR_SPEED_SELECT_LSB 0x2000	/* bits 6,13: 10=1000, 01=100, 00=10 */
 #define MII_CR_LOOPBACK         0x4000	/* 0 = normal, 1 = loopback */
 #define MII_CR_RESET            0x8000	/* 0 = normal, 1 = PHY reset */
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 #define RMII_MODE_SET           0x0200  /* 0 = MII Mode, 1 = RMII Mode */
 #endif
 
@@ -2964,19 +2964,19 @@ struct e1000_host_command_info {
 
 #define RTL8211B_PHY_ID    0x001CC910
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 #define RTL8211B_PHY_REV_ID     0b0010
 #endif
 #define RTL8201N_PHY_ID    0x8200
 #define RTL_PHY_CTRL_FD    0x0100 /* Full duplex.0=half; 1=full */
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 #define RTL_PHY_CTRL_SPD_100    0x2000 /* Force 100Mb */
 #else
 #define RTL_PHY_CTRL_SPD_100    0x200000 /* Force 100Mb */
 #endif
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 #define RTL8201E_PHY_ID     0x001CC810
 #define RTL8211D_PHY_ID     0x001CC910//It's the same as RTL8211B
 #define RTL8211D_PHY_REV_ID     0b0100
--- a/drivers/net/ethernet/intel/e1000/e1000_main.c
+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c
@@ -33,7 +33,7 @@
 #include <linux/bitops.h>
 #include <linux/if_vlan.h>
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 static const char *phy_mode_name[] = {
     "Real Phy Mode",
     "Internal Fake Phy Mode",
@@ -753,7 +753,7 @@ static void e1000_dump_eeprom(struct e10
 	int i;
 	u16 csum_old, csum_new = 0;
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	if (adapter->hw.mac_type == e1000_ce4100)
 		eeprom.len = EEPROM_CE4100_FAKE_LENGTH;
 	else
@@ -892,7 +892,7 @@ static const struct net_device_ops e1000
 	.ndo_set_features	= e1000_set_features,
 };
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 static enum phy_mode g_phy_mode = INVALID_PHY;
 
 int set_gmac_phy_mode(enum phy_mode mode)
@@ -958,7 +958,7 @@ static int e1000_init_hw_struct(struct e
 				struct e1000_hw *hw)
 {
 	struct pci_dev *pdev = adapter->pdev;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	uint32_t socid;
 #endif
 
@@ -968,7 +968,7 @@ static int e1000_init_hw_struct(struct e
 	hw->subsystem_vendor_id = pdev->subsystem_vendor;
 	hw->subsystem_id = pdev->subsystem_device;
 	hw->revision_id = pdev->revision;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	if (INVALID_PHY == g_phy_mode) {
 		intelce_get_soc_info(&socid, NULL);
 		if (CE2600_SOC_DEVICE_ID == socid) {
@@ -2531,7 +2531,7 @@ static void e1000_watchdog(struct work_s
 	struct e1000_tx_ring *txdr = adapter->tx_ring;
 	u32 link, tctl;
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	u16 link_up;
 	s32 ret_val;
 #endif
@@ -2539,7 +2539,7 @@ static void e1000_watchdog(struct work_s
 	if (test_bit(__E1000_DOWN, &adapter->flags))
 		return;
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	/*
 	 * Test the PHY for link status on Intel CE SoC MAC.
 	 * If the link status is different than the last link status stored
@@ -2562,7 +2562,7 @@ static void e1000_watchdog(struct work_s
 	if ((netif_carrier_ok(netdev)) && link)
 		goto link_up;
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	if (hw->mac_type == e1000_ce4100) {
         //FIXME - why are there two calls here?`
 		ret_val = e1000_read_phy_reg(&adapter->hw, PHY_STATUS, &link_up);
--- a/drivers/net/ethernet/synopsys/Kconfig
+++ b/drivers/net/ethernet/synopsys/Kconfig
@@ -1,7 +1,8 @@
 config DWC_QOS
 	tristate "Synopsys Ethernet QOS driver"
+	depends on X86_PUMA7
+	depends on PCI
 	default y
-	depends on ARCH_GEN3 && PCI
 	---help---
 	  This driver supports Synopsys QOS GMAC core controller.
 	  To compile this driver as a module, choose M here: the
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -560,7 +560,7 @@ static void pci_pm_default_resume(struct
 static void pci_pm_default_suspend(struct pci_dev *pci_dev)
 {
 	/* Disable non-bridge devices without PM support */
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	if (!pci_dev->state_saved)
 		pci_save_state(pci_dev);
 #endif
@@ -672,7 +672,7 @@ static int pci_pm_suspend_noirq(struct d
 		return pci_legacy_suspend_late(dev, PMSG_SUSPEND);
 
 	if (!pm) {
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 		if (!pci_dev->state_saved)
 #endif
 		pci_save_state(pci_dev);
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -786,7 +786,7 @@ int pci_set_power_state(struct pci_dev *
 	return error;
 }
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 static int pci_pmcap_exception(struct pci_dev *dev)
 {
        if((dev->vendor == 0x8086) && (dev->device == 0x070b))
@@ -809,7 +809,7 @@ pci_power_t pci_choose_state(struct pci_
 {
 	pci_power_t ret;
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
        if ((!pci_pmcap_exception(dev)) && (!dev->pm_cap))
                return PCI_D0;
 #else
@@ -1792,7 +1792,7 @@ pci_power_t pci_target_state(struct pci_
 {
 	pci_power_t target_state = PCI_D3hot;
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	unsigned int id;
 	intelce_get_soc_info(&id, NULL);
 
--- a/drivers/pci/pcie/portdrv.h
+++ b/drivers/pci/pcie/portdrv.h
@@ -23,7 +23,7 @@
 extern struct bus_type pcie_port_bus_type;
 int pcie_port_device_register(struct pci_dev *dev);
 #ifdef CONFIG_PM
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 int pcie_portdrv_restore_config(struct pci_dev *dev);
 #endif
 int pcie_port_device_suspend(struct device *dev);
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -425,7 +425,7 @@ static int suspend_iter(struct device *d
  */
 int pcie_port_device_suspend(struct device *dev)
 {
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	int ret;
 	struct pci_dev *pdev = to_pci_dev(dev);
 	ret = device_for_each_child(dev, NULL, suspend_iter);
@@ -459,7 +459,7 @@ static int resume_iter(struct device *de
  */
 int pcie_port_device_resume(struct device *dev)
 {
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 	struct pci_dev *pdev = to_pci_dev(dev);
 	pci_set_power_state(pdev, PCI_D0);
 	pci_restore_state(pdev);
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -67,7 +67,7 @@ void pcie_clear_root_pme_status(struct p
 	pcie_capability_set_dword(dev, PCI_EXP_RTSTA, PCI_EXP_RTSTA_PME);
 }
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 int pcie_portdrv_restore_config(struct pci_dev *dev)
 #else
 static int pcie_portdrv_restore_config(struct pci_dev *dev)
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -180,7 +180,7 @@ int __pci_read_base(struct pci_dev *dev,
 
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
-#ifndef CONFIG_ARCH_GEN3
+#ifndef CONFIG_X86_PUMA6
 	/* No printks while decoding is disabled! */
 	if (!dev->mmio_always_on) {
 		pci_read_config_word(dev, PCI_COMMAND, &orig_cmd);
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -821,10 +821,10 @@ config PVPANIC
 
 config PUMA_ACPI
 	tristate "PUMA ACPI Driver"
-	default y
 	depends on ACPI
 	depends on IOSF_MBI
 	depends on REGULATOR
+	default y
 	---help---
 	  This driver provides support for PUMA platform power management.
 	  
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -573,8 +573,9 @@ config REGULATOR_WM8994
 
 config REGULATOR_INT34D9
 	tristate "Puma7 Rohm PMIC"
-	default y
+	depends on X86_PUMA7
 	depends on I2C
+	default y
 	help
 	  This driver controls a Puma7 Rohm voltage output
 	  regulator via I2C bus.
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -35,6 +35,13 @@ config SPI_DEBUG
 	  Say "yes" to enable debug messaging (like dev_dbg and pr_debug),
 	  sysfs, and debugfs support in SPI controller and protocol drivers.
 
+config GEN3_SPI
+        bool "Intel Media SOC SPI support"
+        depends on X86_PUMA6
+        default y
+        help
+          This option enables Intel Media SOC SPI support.
+
 #
 # MASTER side ... talking to discrete SPI slave chips including microcontrollers
 #
@@ -74,6 +81,13 @@ config SPI_ATMEL
 	  This selects a driver for the Atmel SPI Controller, present on
 	  many AT32 (AVR32) and AT91 (ARM) chips.
 
+config SPI_CE5XX_SPI_FLASH
+	tristate "CE5XX SPI FLASH"
+	depends on GEN3_SPI
+	default y
+	help
+	  This selects a driver for CE5XX Serial Flash controler
+
 config SPI_BCM2835
 	tristate "BCM2835 SPI controller"
 	depends on ARCH_BCM2835 || COMPILE_TEST
@@ -369,12 +383,24 @@ config SPI_PXA2XX
 	depends on (ARCH_PXA || PCI || ACPI)
 	select PXA_SSP if ARCH_PXA
 	help
-	  This enables using a PXA2xx or Sodaville SSP port as a SPI master
+	  This enables using a PXA2xx or Intel CE4100/CE4200/CE5300 port as a SPI master
 	  controller. The driver can be configured to use any SSP port and
 	  additional documentation can be found a Documentation/spi/pxa2xx.
 
 config SPI_PXA2XX_PCI
-	def_tristate SPI_PXA2XX && PCI && COMMON_CLK
+	tristate "Intel CE SPI PCI adapter"
+	depends on SPI_PXA2XX && PCI
+	---help---
+	  This driver supports the Intel CE SPI master controller
+	  The driver turns a PXA2xx synchronous serial port into
+	  a SPI master controller.
+	  see (Documentation/spi/spi-summary) for more information
+
+config SPI_CE5XX_SPI_SLAVE
+	tristate "CE5XX SPI SLAVE"
+	depends on GEN3_SPI
+	help
+	  This selects a driver for CE5XX SPI Slave controler, it is emudulated into a spi device
 
 config SPI_RSPI
 	tristate "Renesas RSPI controller"
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -201,8 +201,9 @@ depends on PLAT_SAMSUNG
 source "drivers/thermal/samsung/Kconfig"
 endmenu
 
-config IOSF_PRIMARY
+config PUMA_THERMAL_USE_IOSF_PRIMARY
    tristate "Puma Thermal driver to use IOSF primary"
+   depends on PUMA_THERMAL
    depends on PCI
    default y
    help
@@ -211,7 +212,7 @@ config IOSF_PRIMARY
 
 config PUMA_THERMAL
 	bool "PUMA thermal management"
-	depends on THERMAL
+	depends on X86_PUMA7
 	depends on X86
 	default y
 	help
--- a/drivers/thermal/puma_thermal.c
+++ b/drivers/thermal/puma_thermal.c
@@ -53,7 +53,7 @@
 #define DTS_ENABLE            0x01
 #define DTS_DISABLE           0x0
 
-#if IS_ENABLED(CONFIG_IOSF_PRIMARY)
+#if IS_ENABLED(CONFIG_PUMA_THERMAL_USE_IOSF_PRIMARY)
 #define SOC_DTS_CONTROL       0x0200
 #define DTS_ENABLE_REG        0x02C0
 #define PUNIT_TEMP_REG        0x02C4
@@ -171,7 +171,7 @@ static struct thermal_soc_data *pdata_th
 
 static inline int puma_read_punit_reg(unsigned int addr, u32 *read_val)
 {
-#if IS_ENABLED(CONFIG_IOSF_PRIMARY)
+#if IS_ENABLED(CONFIG_PUMA_THERMAL_USE_IOSF_PRIMARY)
    *read_val = __raw_readl(puma_therm_mmio.reg_base + addr);
    return 0;
 #else
@@ -181,7 +181,7 @@ static inline int puma_read_punit_reg(un
 
 static inline int puma_write_punit_reg(unsigned int addr, u32 val)
 {
-#if IS_ENABLED(CONFIG_IOSF_PRIMARY)
+#if IS_ENABLED(CONFIG_PUMA_THERMAL_USE_IOSF_PRIMARY)
    __raw_writel(val, puma_therm_mmio.reg_base + addr);
    return 0;
 #else
@@ -828,7 +828,7 @@ static struct pci_driver puma_thermal_dr
 
 static int __init puma_thermal_module_init(void)
 {
-#if IS_ENABLED(CONFIG_IOSF_PRIMARY)
+#if IS_ENABLED(CONFIG_PUMA_THERMAL_USE_IOSF_PRIMARY)
    return pci_register_driver(&puma_thermal_driver);
 #else
    return puma_thermal_init();
@@ -837,7 +837,7 @@ static int __init puma_thermal_module_in
 
 static void __exit puma_thermal_module_exit(void)
 {
-#if IS_ENABLED(CONFIG_IOSF_PRIMARY)
+#if IS_ENABLED(CONFIG_PUMA_THERMAL_USE_IOSF_PRIMARY)
       pci_unregister_driver(&puma_thermal_driver);
 #else
       puma_thermal_exit();
--- a/drivers/tty/serial/8250/Kconfig
+++ b/drivers/tty/serial/8250/Kconfig
@@ -57,6 +57,13 @@ config SERIAL_8250_PNP
 	  This builds standard PNP serial support. You may be able to
 	  disable this feature if you only need legacy serial support.
 
+config GEN3_UART
+	bool "Intel Media SOC Gen3 UART support"
+	depends on SERIAL_8250 && X86_PUMA6
+	default y
+	help
+	  This option enables Intel Media SOC Gen3 UART support.
+
 config SERIAL_8250_CONSOLE
 	bool "Console on 8250/16550 and compatible serial port"
 	depends on SERIAL_8250=y
--- a/drivers/tty/serial/hsu/Kconfig
+++ b/drivers/tty/serial/hsu/Kconfig
@@ -17,7 +17,7 @@ config SERIAL_HSU
 
 config SERIAL_HSU_CONSOLE
 	bool "Console on Intel HSU serial port"
-	depends on SERIAL_HSU=y
+	depends on SERIAL_HSU
 	select SERIAL_CORE_CONSOLE
 	---help---
 	  If you say Y here, it will be possible to use a serial port as the
--- a/drivers/uio/Kconfig
+++ b/drivers/uio/Kconfig
@@ -135,4 +135,14 @@ config UIO_MF624
 
 	  If you compile this as a module, it will be called uio_mf624.
 
+config UIO_PCI_CE2600
+	tristate "Intel CE2600 PCI devices "
+	depends on X86_PUMA6
+	depends on PCI
+	default n
+	help
+	  Driver for CE2600 PCI MoCA and L2SW devices.  This
+	  driver requires a userspace component that recognizes and
+	  loads devices.
+
 endif
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -84,6 +84,15 @@ config USB_EHCI_TT_NEWSCHED
 
 	  If unsure, say Y.
 
+config GEN3_USB
+        bool "Intel Media SOC Gen3 USB support"
+        depends on X86_PUMA6
+        depends on USB_EHCI_HCD
+        default y
+        ---help---
+          This option enables Intel Media SOC Gen3 USB support.
+          It makes ISO-IN transfers work well, like audio capture.
+
 config USB_FSL_MPH_DR_OF
 	tristate
 
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -98,8 +98,12 @@ static unsigned park = 0;
 module_param (park, uint, S_IRUGO);
 MODULE_PARM_DESC (park, "park setting; 1-3 back-to-back async packets");
 
+#ifdef CONFIG_X86_PUMA6
+static bool ignore_oc = 1;
+#else
 /* for flakey hardware, ignore overcurrent indicators */
 static bool ignore_oc = 0;
+#endif
 module_param (ignore_oc, bool, S_IRUGO);
 MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 
--- a/drivers/usb/phy/Kconfig
+++ b/drivers/usb/phy/Kconfig
@@ -238,6 +238,7 @@ config USB_ULPI_VIEWPORT
 
 config INTEL_CHT_PHY
 	bool "Intel CherryTrail OTG Transceiver Driver"
+	depends on X86_PUMA7
 	depends on USB_OTG_FSM
 	select USB_OTG
 	select USB_PHY
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -4,6 +4,7 @@
 
 menuconfig WATCHDOG
 	bool "Watchdog Timer Support"
+	default y
 	---help---
 	  If you say Y here (and to one of the following options) and create a
 	  character special file /dev/watchdog with major number 10 and minor
@@ -594,6 +595,18 @@ config I6300ESB_WDT
 	  To compile this driver as a module, choose M here: the
 	  module will be called i6300esb.
 
+config INTELCE_WDT
+	tristate "Intel Watchdog for CE2600"
+	depends on X86_PUMA6
+	depends on X86 && PCI
+	default m
+	---help---
+	  Hardware driver for the watchdog timer built into the Intel
+	  CE2600 platform.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called intelce_wdt.
+
 config IE6XX_WDT
 	tristate "Intel Atom E6xx Watchdog"
 	depends on X86 && PCI
@@ -702,7 +715,6 @@ config KEMPLD_WDT
 config HPWDT_NMI_DECODING
 	bool "NMI decoding support for the HP ProLiant iLO2+ Hardware Watchdog Timer"
 	depends on HP_WATCHDOG
-	default y
 	help
 	  When an NMI occurs this feature will make the necessary BIOS calls to
 	  log the cause of the NMI.
--- a/include/asm-generic/gpio.h
+++ b/include/asm-generic/gpio.h
@@ -25,7 +25,7 @@
  */
 
 #ifndef ARCH_NR_GPIOS
-#ifdef CONFIG_ARCH_GEN3   
+#ifdef CONFIG_X86_PUMA6   
 #define ARCH_NR_GPIOS		256
 #else
 #define ARCH_NR_GPIOS		512
@@ -117,7 +117,7 @@ struct gpio_chip {
 						unsigned offset);
 	int			(*get)(struct gpio_chip *chip,
 						unsigned offset);
-#ifdef CONFIG_ARCH_GEN3        
+#ifdef CONFIG_X86_PUMA6        
        int                     (*get_multi_function)(struct gpio_chip *chip, unsigned offset);
 #endif
 
@@ -128,7 +128,7 @@ struct gpio_chip {
 
 	void			(*set)(struct gpio_chip *chip,
 						unsigned offset, int value);
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
         int                     (*set_multi_function)(struct gpio_chip *chip, unsigned offset, int fn_num);
 #endif
 
@@ -190,7 +190,7 @@ extern int gpio_set_debounce(unsigned gp
 
 extern int gpio_get_value_cansleep(unsigned gpio);
 extern void gpio_set_value_cansleep(unsigned gpio, int value);
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 extern int gpio_get_multi_function(unsigned gpio);
 extern int gpio_set_multi_function(unsigned gpio, int value);
 
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -305,6 +305,10 @@ static inline int get_page_unless_zero(s
 
 extern int page_is_ram(unsigned long pfn);
 
+#ifdef CONFIG_X86_PUMA6
+int range_is_sys_ram(unsigned long pfn, unsigned long size);
+#endif
+
 /* Support for virtually mapped pages */
 struct page *vmalloc_to_page(const void *addr);
 unsigned long vmalloc_to_pfn(const void *addr);
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@ -23,6 +23,10 @@
 #define NR_UNIX98_PTY_RESERVE	1024	  /* Default reserve for main devpts */
 #define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
 
+#ifdef CONFIG_X86_PUMA6
+#define N_PIC		23
+#endif
+
 /*
  * This character is the same as _POSIX_VDISABLE: it cannot be used as
  * a c_cc[] character, but indicates that a particular special character
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -486,7 +486,7 @@ out:
 		goto out_eoi;
 	goto out_unlock;
 }
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 EXPORT_SYMBOL_GPL(handle_fasteoi_irq);
 #endif
 
--- a/kernel/irq/irqdesc.c
+++ b/kernel/irq/irqdesc.c
@@ -264,7 +264,7 @@ struct irq_desc irq_desc[NR_IRQS] __cach
 	}
 };
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 #ifdef CONFIG_SMP
 EXPORT_SYMBOL(irq_desc);
 #endif
--- a/kernel/pid.c
+++ b/kernel/pid.c
@@ -460,7 +460,7 @@ struct task_struct *find_task_by_vpid(pi
 	return find_task_by_pid_ns(vnr, task_active_pid_ns(current));
 }
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 EXPORT_SYMBOL(find_task_by_vpid);
 #endif
 
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -45,7 +45,7 @@ int pm_notifier_call_chain(unsigned long
 	return notifier_to_errno(ret);
 }
 
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 /*
  *	Devices are suspended and resumed synchronously in Intel Media SOCs
 */
--- a/kernel/reboot.c
+++ b/kernel/reboot.c
@@ -41,7 +41,7 @@ enum reboot_mode reboot_mode DEFAULT_REB
  */
 int reboot_default = 1;
 int reboot_cpu;
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 enum reboot_type reboot_type = BOOT_KBD;
 #else
 enum reboot_type reboot_type = BOOT_ACPI;
@@ -239,7 +239,7 @@ SYSCALL_DEFINE4(reboot, int, magic1, int
  * To let the poweroff command proceed, we comment out the following
  * piece of code.
 */
-#ifndef CONFIG_ARCH_GEN3
+#ifndef CONFIG_X86_PUMA6
 	/* Instead of trying to make the power_off code look like
 	 * halt when pm_power_off is not set do it the easy way.
 	 */
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -2509,7 +2509,7 @@ EXPORT_SYMBOL(unblock_all_signals);
 /*
  * The following code is for Intel Media SOC Gen3 base support.
 */
-#ifdef CONFIG_ARCH_GEN3
+#ifdef CONFIG_X86_PUMA6
 EXPORT_SYMBOL(kill_pid_info);   /* Export this symbol for graphic driver */
 #endif
 
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -335,9 +335,9 @@ endmenu
 
 endmenu
 
-#Enable packet processor handling for GW on ATOM
 config APPCPU_GW_PP_HANDLE
 	bool "Enable packet processor handling for GW on ATOM"
+	depends on TI_PACKET_PROCESSOR
 	default n
 
 source "net/ax25/Kconfig"
--- a/net/bridge/netfilter/Kconfig
+++ b/net/bridge/netfilter/Kconfig
@@ -172,6 +172,7 @@ config BRIDGE_EBT_REDIRECT
 
 config BRIDGE_EBT_FORWARD
 	tristate "ebt: forward target support"
+	depends on X86_PUMA7
 	help
 	  This option adds the forward target, which allows bypassing the normal
 	  bridging logic and forcing an Ethernet frame to be forwarded to a specific
