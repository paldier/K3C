From 9fd3a2fbf0247228b090f034693c637299a9a096 Mon Sep 17 00:00:00 2001
From: noammano <noam.manor@intel.com>
Date: Wed, 24 Feb 2016 10:37:05 +0200
Subject: [PATCH 356/441] Title: [HW_MBOX] Integrate SocketAPI

Issue: HSD:245776
IssueType: Feature
Impact: N/A - New Feature.
Resolution: Integrate new HW_MBOX SocketAPI, this will enable user
space applications to open sockets to communicate over HW_MBOX.

Change-Id: I251e3aab8a4b111e931034248f2f318ba9194b29
Signed-off-by: noammano <noam.manor@intel.com>
---
 arch/x86/NetIP_SubSystem/netip_subsystem_lld.c |    5 +
 arch/x86/hw_mailbox/hw_mbox_drv.c              | 2051 ++++++++++++++++++++++--
 arch/x86/hw_mailbox/hw_mbox_mem_access.h       |   47 +-
 include/linux/hw_mailbox.h                     |   32 +-
 include/linux/hw_mbox_defs.h                   |   89 +-
 include/linux/hw_mbox_socket.h                 |  193 +++
 include/linux/netip_subsystem.h                |    3 +
 include/linux/socket.h                         |    4 +-
 8 files changed, 2286 insertions(+), 138 deletions(-)
 create mode 100755 include/linux/hw_mbox_socket.h

--- a/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
@@ -203,6 +203,11 @@ int netss_device_get_info(netss_dev_t su
          mmio->size = NETSS_DEV_BBU_CTRLR_MMIO_SIZE;
          ret = 0;
       break;
+      case NETSS_DEV_PERIPHERAL_SRAM:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_PERIPHERAL_SRAM_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_PERIPHERAL_SRAM_MMIO_SIZE;
+         ret = 0;
+      break;
       default:
          ret = -1;
    }
--- a/arch/x86/hw_mailbox/hw_mbox_drv.c
+++ b/arch/x86/hw_mailbox/hw_mbox_drv.c
@@ -31,8 +31,8 @@
  *  Santa Clara, CA  97052
  */
 
-#define DRV_NAME    "Intel(R) HW Mailbox Controller Driver"
-#define DRV_VERSION "0.0.2"
+#define DRV_NAME    "Intel(R) HW_MBOX Controller Driver"
+#define DRV_VERSION "0.0.3"
 
 /************************************************************************/
 /*     INCLUDES                                                         */
@@ -56,18 +56,40 @@
 #include <linux/kthread.h>      /* Kernel Threads */
 #include <linux/delay.h>        /* for usleep_range */
 
-#include <linux/hw_mbox_defs.h>        /* HW_MBOX definitions and configuration */
-#include <linux/hw_mailbox.h>
-#include "hw_mbox_mem_access.h"  /* HW_MBOX Register and Memory Access    */
+/* Uncomment according to CPU:
+   [can't use the HW_MBOX defines as they are defined inside the following file... ]
+*/
+//#include "hw_mbox_defs.h"             /* HW_MBOX definitions and configuration */
+#include <linux/hw_mbox_defs.h>         /* HW_MBOX definitions and configuration */
 
-#ifdef HW_MBOX_IS_NP_CPU
-#include "puma7.h"       /* for irq number */
+#include "hw_mbox_mem_access.h"         /* HW_MBOX Register and Memory Access    */
+
+#ifdef HW_MBOX_SOCKETS_API
+#include <linux/errno.h>
+#include <net/sock.h>
+#include <linux/stat.h>
+#include <linux/hashtable.h>
+
+#if defined HW_MBOX_IS_NP_CPU
+#include "hw_mbox_socket.h"
+#elif defined HW_MBOX_IS_APP_CPU
+#include <linux/hw_mbox_socket.h>
 #endif
+#endif /* HW_MBOX_SOCKETS_API */
 
-#ifdef HW_MBOX_IS_APP_CPU
+#if defined HW_MBOX_IS_NP_CPU
+#include "puma7.h"                      /* for irq number */
+#include "puma7_npcpu_appcpu_defs.h"
+#elif defined HW_MBOX_IS_APP_CPU
 #include <linux/netip_subsystem.h>
 #endif
 
+#if defined HW_MBOX_IS_NP_CPU
+#include "hw_mbox_drv.h"                /* Driver API */
+#elif defined HW_MBOX_IS_APP_CPU
+#include <linux/hw_mailbox.h>           /* Driver API */
+#endif
+
 #ifdef HW_MBOX_IS_APP_CPU
 /* APP-CPU gets HW MBOX Interrupts as MSI messages triggered upon rising edge of the HW MBOX
    interrupt line [as sampled by the bridge]. Reading the Interrupt Status Register resets its
@@ -90,7 +112,7 @@
 //#define HW_MBOX_KDBG /*! Use this define to toggle HW_MBOX kernel debug prints */
 #ifdef HW_MBOX_KDBG
 /* note: prints Module header and '\n' is included inside */
-#  define DPRINTK(fmt, args...) printk("HW_MBOX_KDBG[%s:%d]: " fmt "\n" , __FUNCTION__, __LINE__, ## args)
+#  define DPRINTK(fmt, args...) printk("HW_MBOX_KDBG[%s:%d]: " fmt "\n", __FUNCTION__, __LINE__, ## args)
 #else
 #  define DPRINTK(fmt, args...) do{ } while(0)
 #endif
@@ -128,12 +150,17 @@
 
 /*! \def HW_MBOX_INT_NAME
     \brief irq name of the HW_MBOX. */
-#define HW_MBOX_INT_NAME    "hw_mbox_irq"
+#define HW_MBOX_INT_NAME        "hw_mbox_irq"
 #endif /* HW_MBOX_IS_NP_CPU */
 
 #ifdef HW_MBOX_IS_APP_CPU
 /* define HW_MBOX_BASE as the memory mapped reg base address: */
-#define HW_MBOX_BASE hwMboxDriverData.reg_base
+#define HW_MBOX_BASE            hwMboxDriverData.reg_base
+
+#ifdef HW_MBOX_EXTENDED_MEMORY
+/* define HW_MBOX_EXT_MEM_BASE as the memory mapped reg base address: */
+#define HW_MBOX_EXTMEM_BASE     hwMboxDriverData.extMem_base
+#endif /* HW_MBOX_EXTENDED_MEMORY */
 #endif /* HW_MBOX_IS_APP_CPU */
 
 /*! \def HW_MBOX_ERROR_BIT_POS_SUPERVISOR
@@ -156,14 +183,13 @@
 #define HW_MBOX_IS_ERROR_BIT_SET_FOR_SUPERVISOR(interruptStatus_H)      (((interruptStatus_H) & HW_MBOX_ERROR_BIT_FOR_SUPERVISOR) != 0)
 
 #ifdef HW_MBOX_IS_APP_CPU
-/*! \def HW_MBOX_OPCODE_MESSAGE_COPY_TO_SRAM( _pHwMboxMsg , _destSramOffset )
+/*! \def HW_MBOX_INTERNAL_MESSAGE_COPY_TO_SRAM( _pHwMboxMsg , _destSramOffset )
     \brief Copy a HW MBOX OPCODE Internal Message to the SRAM.
     \note If CPU is APP_CPU which is LE, handles swap to BE before writing to the SRAM.
-    \param[in] _pHwMboxMsg - pointer to a hwMbox_opcodeMessage_t that holds
-                             the message to be sent.
+    \param[in] _pHwMboxMsg - pointer to a buffer that holds the message to be sent.
     \param[in] _destSramOffset - internal destination offset within the SRAM.
 */
-#define HW_MBOX_OPCODE_MESSAGE_COPY_TO_SRAM( _pHwMboxMsg, _destSramOffset ) \
+#define HW_MBOX_INTERNAL_MESSAGE_COPY_TO_SRAM( _pHwMboxMsg, _destSramOffset ) \
 do{\
     Uint32 _byteCnt = 0;                                    \
     Uint32 *_pWord = (Uint32 *)( _pHwMboxMsg );             \
@@ -179,7 +205,7 @@ do{\
     }                                                               \
 } while (0)
 #else /* HW_MBOX_IS_APP_CPU */
-#define HW_MBOX_OPCODE_MESSAGE_COPY_TO_SRAM( _pHwMboxMsg, _destSramOffset ) \
+#define HW_MBOX_INTERNAL_MESSAGE_COPY_TO_SRAM( _pHwMboxMsg, _destSramOffset ) \
 do{\
     HW_MBOX_COPY_TO_SRAM( _pHwMboxMsg,                  \
                           HW_MBOX_OPCODE_MESSAGE_SIZE,  \
@@ -188,14 +214,13 @@ do{\
 #endif /* ! HW_MBOX_IS_APP_CPU */
 
 #ifdef HW_MBOX_IS_APP_CPU
-/*! \def HW_MBOX_OPCODE_MESSAGE_COPY_FROM_SRAM( _srcSramOffset, _pHwMboxMsg )
+/*! \def HW_MBOX_INTERNAL_MESSAGE_COPY_FROM_SRAM( _srcSramOffset, _pHwMboxMsg )
     \brief Copy a HW MBOX OPCODE Internal Message from the SRAM.
     \note If CPU is APP_CPU which is LE, handles swap from BE after reading from the SRAM.
     \param[in]  _srcSramOffset - internal source offset within the SRAM.
-    \param[out] _pHwMboxMsg - pointer to a hwMbox_opcodeMessage_t that will hold
-                              the message that was sent.
+    \param[out] _pHwMboxMsg - pointer to a buffer that will hold the message that was sent.
 */
-#define HW_MBOX_OPCODE_MESSAGE_COPY_FROM_SRAM( _srcSramOffset, _pHwMboxMsg ) \
+#define HW_MBOX_INTERNAL_MESSAGE_COPY_FROM_SRAM( _srcSramOffset, _pHwMboxMsg ) \
 do{\
     Uint32 _byteCnt = 0;                                \
     Uint32 *_pWord = (Uint32 *)( _pHwMboxMsg );         \
@@ -210,7 +235,7 @@ do{\
     }                                                           \
 } while (0)
 #else /* HW_MBOX_IS_APP_CPU */
-#define HW_MBOX_OPCODE_MESSAGE_COPY_FROM_SRAM( _srcSramOffset, _pHwMboxMsg ) \
+#define HW_MBOX_INTERNAL_MESSAGE_COPY_FROM_SRAM( _srcSramOffset, _pHwMboxMsg ) \
 do{\
     HW_MBOX_COPY_FROM_SRAM( _srcSramOffset,               \
                             HW_MBOX_OPCODE_MESSAGE_SIZE,  \
@@ -218,6 +243,58 @@ do{\
 } while (0)
 #endif /* ! HW_MBOX_IS_APP_CPU */
 
+#ifdef HW_MBOX_SOCKETS_API
+
+#ifdef HW_MBOX_KDBG
+/* note: prints Module header and '\n' is included inside */
+#  define DPRINTK_SKT( _pSocket, fmt, args...) printk("HW_MBOX_KDBG_SKT[%s:%d]: (pSocket=0x%p) " fmt "\n", __FUNCTION__, __LINE__, _pSocket, ## args)
+#else
+#  define DPRINTK_SKT( _pSocket, fmt, args...) do{ } while(0)
+#endif
+
+#define HW_MBOX_COPY_KERNEL     (1)
+#define HW_MBOX_COPY_USER       (0)
+
+#define HW_MBOX_PROTOCOL_BY_APPID( _appid ) \
+    ( ( ((_appid) >= HW_MBOX_APPID_OPCODE_MIN ) && ((_appid) <= HW_MBOX_APPID_OPCODE_MAX ) ) ?  \
+       hw_mbox_opcode :                                                                         \
+       ( (_appid) == HW_MBOX_APPID_COMMAND ) ?                                                  \
+       hw_mbox_command :                                                                        \
+       ( (_appid) == HW_MBOX_APPID_EVENT   ) ?                                                  \
+       hw_mbox_event :                                                                          \
+       (-1) )
+
+#define HW_MBOX_SOCKETS_APPID_VALIDITY_CHECK(paramAPPID) \
+    (( (paramAPPID) >= HW_MBOX_APPID_MIN_VALUE ) && ( (paramAPPID) <= HW_MBOX_APPID_MAX_VALUE ))
+
+#define HW_MBOX_USER_COPY_FROM_ADDR(srcAddr, srcAddrLen, pDestBuffer)          copy_to_user(pDestBuffer,srcAddr, srcAddrLen)
+#define HW_MBOX_USER_COPY_TO_ADDR(pSrcBuffer, srcBufferLen, destAddr)          copy_from_user(destAddr, pSrcBuffer, srcBufferLen)
+#define HW_MBOX_USER_COPY_FROM_SRAM(srcSramOffset, srcSramLen, pDestBuffer)    HW_MBOX_USER_COPY_FROM_ADDR(HW_MBOX_POINTER_TO_SRAM(srcSramOffset), srcSramLen, pDestBuffer)
+#define HW_MBOX_USER_COPY_TO_SRAM(pSrcBuffer, srcBufferLen, destSramOffset)    HW_MBOX_USER_COPY_TO_ADDR(pSrcBuffer, srcBufferLen, HW_MBOX_POINTER_TO_SRAM(destSramOffset))
+#endif /* HW_MBOX_SOCKETS_API */
+
+#ifdef HW_MBOX_EXTENDED_MEMORY
+typedef struct hwMbox_extMemMsgData
+{
+    Uint32 offset;
+    Uint32 lenInBytes;
+} hwMbox_extMemMsgData_t;
+
+typedef Uint32 hwMbox_extMemCtrlHdr_t;
+
+#define HW_MBOX_FLAG_OWNER            0x00000001 /*! if owner bit is set than the owner of EXT MEM is the subject */
+
+#define HW_MBOX_IS_OWNER( _ctrl )     ( HW_MBOX_FLAG_OWNER & ( _ctrl ) )
+#define HW_MBOX_SET_OWNER( _ctrl )    do { ( _ctrl ) |=  HW_MBOX_FLAG_OWNER; } while(0)
+#define HW_MBOX_CLR_OWNER( _ctrl )    do { ( _ctrl ) &= ~HW_MBOX_FLAG_OWNER; } while(0)
+
+#define HW_MBOX_EXTMEM_IS_SUBJECT_OWNER( _ctrl )        ( HW_MBOX_IS_OWNER( _ctrl ) != 0 /* bit is set */ )
+#define HW_MBOX_EXTMEM_IS_COMMANDER_OWNER( _ctrl )      ( HW_MBOX_IS_OWNER( _ctrl ) == 0 /* bit is NOT set */ )
+
+#define HW_MBOX_USER_COPY_FROM_EXTMEM(srcExtmemOffset, srcExtmemLen, pDestBuffer)    HW_MBOX_USER_COPY_FROM_ADDR(HW_MBOX_POINTER_TO_EXTMEM(srcExtmemOffset), srcExtmemLen, pDestBuffer)
+#define HW_MBOX_USER_COPY_TO_EXTMEM(pSrcBuffer, srcBufferLen, destExtmemOffset)      HW_MBOX_USER_COPY_TO_ADDR(pSrcBuffer, srcBufferLen, HW_MBOX_POINTER_TO_EXTMEM(destExtmemOffset))
+#endif /* HW_MBOX_EXTENDED_MEMORY */
+
 /************************************************************************/
 /*     HW_MBOX Package configuration data arrays:                       */
 /************************************************************************/
@@ -472,6 +549,26 @@ static int hwMbox_waitForChannelInterrup
 
 static int hwMbox_recvOpcodeListenerEntry(void *data);
 
+#ifdef HW_MBOX_SOCKETS_API
+/************************************************************************/
+/*     HW_MBOX sockets Local Declarations                               */
+/************************************************************************/
+static struct proto hwMbox_proto;
+static const struct net_proto_family hwMbox_family_ops;
+static const struct proto_ops hwMbox_proto_ops;
+
+static int _hwMbox_SendMsg(Uint32 paramCID, Uint32 paramAppID, Uint8 *dataBuf, Uint32 dataLen, Uint32 userOrKernel);
+static int hwMbox_sendCmdMsg(hw_mbox_Masters_e subject, Uint32 paramAppID, Uint8 *dataBuf, Uint32 dataLen, Uint32 userOrKernel);
+static int hwMbox_sendReplyMsg(hw_mbox_Masters_e commander, Uint32 paramAppID, Uint8 *dataBuf, Uint32 dataLen, Uint32 userOrKernel);
+
+static int _hwMbox_RecvMsg(Uint32 paramCID, Uint32 paramAppID, Uint8 *dataBuf, Uint32 dataLen, Uint32 userOrKernel, Uint32 eraseMemAfter, HW_MBOX_STATUS_e *pHwMboxStatus);
+static int hwMbox_recvReplyMsg(hw_mbox_Masters_e subject, Uint32 paramAppID, Uint8 *dataBuf, Uint32 dataLen, Uint32 userOrKernel, Uint32 eraseMemAfter);
+static int hwMbox_recvCmdMsg(hw_mbox_Masters_e commander, Uint32 paramAppID, Uint8 *dataBuf, Uint32 dataLen, Uint32 userOrKernel, Uint32 eraseMemAfter);
+
+static void _hwMbox_sendOpcodeMsg(Uint32 paramCID, HW_MBOX_STATUS_e status);
+static int hwMbox_socketRecvOpCb(hw_mbox_Masters_e commander, Uint8 *dataBuf, Uint32 dataLen, Uint32 *token);
+#endif /* HW_MBOX_SOCKETS_API */
+
 /************************************************************************/
 /*     HW_MBOX driver data                                              */
 /************************************************************************/
@@ -513,6 +610,12 @@ typedef struct chnDbEntry
 
     hw_mbox_channelConfig_t config;     /* Channel's configuration */
 
+#ifdef HW_MBOX_EXTENDED_MEMORY
+    Bool        isExtMem;
+    Uint32      extMemOffset;
+    Uint32      extMemSize;
+#endif /* HW_MBOX_EXTENDED_MEMORY */
+
     Uint32      intrCount;       /* count channel interrupts */
     Uint32      recvOpcodeIndex; /* indicates relevant entry in recvOpData [only relevant for recvOpcode] */
 } chnDbEntry_t;
@@ -539,8 +642,11 @@ typedef struct hw_mbox_drv_data
     Uint32 ghostIntr;   /* incremented if there's an interrupt but no set bits in Interrupt Status Registers */
 
 #ifdef HW_MBOX_IS_APP_CPU
-    void __iomem *reg_base; /* Mapped io reg base address */
-#endif
+    void __iomem *reg_base;     /* Mapped io reg base address */
+#ifdef HW_MBOX_EXTENDED_MEMORY
+    void __iomem *extMem_base;  /* Mapped io extended memory base address */
+#endif /* HW_MBOX_EXTENDED_MEMORY */
+#endif /* HW_MBOX_IS_APP_CPU */
 } hw_mbox_drv_data_t;
 
 /*! \def HW_MBOX_DRIVER_DATA_SIZE
@@ -622,6 +728,17 @@ static hw_mbox_drv_data_t hwMboxDriverDa
 #define CHN_CFG_MEMBUFF_GET_SIZE( _cid )        (hwMboxDriverData.chnDb[ _cid ].config.memBuff.size)
 #define CHN_CFG_MEMBUFF_GET_START( _cid )       (hwMboxDriverData.chnDb[ _cid ].config.memBuff.start)
 
+#ifdef HW_MBOX_EXTENDED_MEMORY
+#define CHN_CFG_IS_EXTMEM( _cid )                (hwMboxDriverData.chnDb[ _cid ].isExtMem == True)
+#define CHN_CFG_SET_EXTMEM( _cid, _val )         (hwMboxDriverData.chnDb[ _cid ].isExtMem = ( _val ))
+
+#define CHN_CFG_EXTMEM_SET_OFFSET( _cid, _val )  (hwMboxDriverData.chnDb[ _cid ].extMemOffset = ( _val ))
+#define CHN_CFG_EXTMEM_GET_OFFSET( _cid )        (hwMboxDriverData.chnDb[ _cid ].extMemOffset)
+
+#define CHN_CFG_EXTMEM_SET_SIZE( _cid, _val )    (hwMboxDriverData.chnDb[ _cid ].extMemSize = ( _val ))
+#define CHN_CFG_EXTMEM_GET_SIZE( _cid )          (hwMboxDriverData.chnDb[ _cid ].extMemSize)
+#endif /* HW_MBOX_EXTENDED_MEMORY */
+
 /* Check if it's a receive Opcode channel: */
 #define CHN_IS_RECV_OP( _cid )  ( ((CHN_CFG_GET_TYPE( _cid ) == hw_mbox_opcode)  && \
                                    (CHN_CFG_GET_SUBJECT( _cid ) == HW_MBOX_MID)) == True )
@@ -937,6 +1054,18 @@ if (NULL == (procDir = proc_mkdir(procDi
 volatile Uint32 __debug_HW_MBOX_MID = HW_MBOX_HARDCODED_MID;
 #endif /* HW_MBOX_DEBUG */
 
+#ifdef HW_MBOX_SOCKETS_API
+/*! \var struct hlist_head hwMbox_sock_hlist
+    \brief hash list for sockets of AF_HWMBOX family.
+*/
+struct hlist_head hwMbox_sock_hlist = { .first = NULL };
+
+/*! \var static struct semaphore hwMbox_sock_hlist_sem
+    \brief lock for /proc/hw_mbox/sockstat (binary semaphore).
+*/
+struct semaphore hwMbox_sock_hlist_sem;
+#endif /* HW_MBOX_SOCKETS_API */
+
 /*! \var static Uint32 __currentNonallocatedSramOffset
     \brief keeps track of offset of currently allocated SRAM.
     \warning Do not modify directly use the Macros!
@@ -1031,7 +1160,22 @@ static recvOpcodeListenerThreadData_t re
 */
 static recvOpcodeInfrastructure_t recvOpData[HW_MBOX_OPCODE_RECV_COUNT];
 
-#define RESET_RECV_OP_DATA()                    (memset(recvOpData, 0, sizeof(recvOpData)))
+#ifdef HW_MBOX_SOCKETS_API
+#define RESET_RECV_OP_DATA() \
+do{ \
+    int __i,__k;                                                                \
+    memset(recvOpData, 0, sizeof(recvOpData));                                  \
+    for ( __i = 0; __i < HW_MBOX_OPCODE_RECV_COUNT; __i++ )                     \
+    {                                                                           \
+        for ( __k = 0; __k < HW_MBOX_OPCODE_TAG_COUNT; __k++ )                  \
+        {                                                                       \
+            recvOpData[ __i ].registeredTags[ __k ].tag = HW_MBOX_TAG_INVALID;  \
+        }                                                                       \
+    }                                                                           \
+} while (0)
+#else
+#define RESET_RECV_OP_DATA()    (memset(recvOpData, 0, sizeof(recvOpData)))
+#endif
 
 /* Access By Receive Op Index Macros: */
 
@@ -1042,6 +1186,10 @@ static recvOpcodeInfrastructure_t recvOp
 #define RECV_OP_GET_TAG_COUNT_BY_INDEX( _recvOpIndex )                  (recvOpData[ _recvOpIndex ].registeredCount)
 #define RECV_OP_INC_TAG_COUNT_BY_INDEX( _recvOpIndex )                  (recvOpData[ _recvOpIndex ].registeredCount++)
 
+#ifdef HW_MBOX_SOCKETS_API
+# define RECV_OP_DEC_TAG_COUNT_BY_INDEX( _recvOpIndex )                  (recvOpData[ _recvOpIndex ].registeredCount--)
+#endif /* HW_MBOX_SOCKETS_API */
+
 /* Application Queue: */
 #define RECV_OP_APP_WQ_BY_INDEX( _recvOpIndex )                         (recvOpData[ _recvOpIndex ].appWq.waitQueue)
 #define RECV_OP_APP_GET_STATE_BY_INDEX( _recvOpIndex )                  (recvOpData[ _recvOpIndex ].appWq.state)
@@ -1068,6 +1216,7 @@ static recvOpcodeInfrastructure_t recvOp
 
 #define RECV_OP_GET_OPCODE_CNT_BY_INDEX( _recvOpIndex, _tagIndex)       (recvOpData[ _recvOpIndex ].registeredTags[ _tagIndex ].opcodeCount)
 #define RECV_OP_INC_OPCODE_CNT_BY_INDEX( _recvOpIndex, _tagIndex)       (recvOpData[ _recvOpIndex ].registeredTags[ _tagIndex ].opcodeCount++)
+#define RECV_OP_CLR_OPCODE_CNT_BY_INDEX( _recvOpIndex, _tagIndex)       (recvOpData[ _recvOpIndex ].registeredTags[ _tagIndex ].opcodeCount = 0)
 
 /* Access By CID Macros: */
 /* IMPORTANT: Only use the following functions for valid recv Opcode channels! */
@@ -1076,6 +1225,10 @@ static recvOpcodeInfrastructure_t recvOp
 #define RECV_OP_GET_TAG_COUNT( _cid )                   (RECV_OP_GET_TAG_COUNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
 #define RECV_OP_INC_TAG_COUNT( _cid )                   (RECV_OP_INC_TAG_COUNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
 
+#ifdef HW_MBOX_SOCKETS_API
+#define RECV_OP_DEC_TAG_COUNT( _cid )                   (RECV_OP_DEC_TAG_COUNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
+#endif /* HW_MBOX_SOCKETS_API */
+
 /* Application Queue: */
 #define RECV_OP_APP_WQ( _cid )                          (RECV_OP_APP_WQ_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
 #define RECV_OP_APP_GET_STATE( _cid )                   (RECV_OP_APP_GET_STATE_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ) ))
@@ -1102,6 +1255,7 @@ static recvOpcodeInfrastructure_t recvOp
 
 #define RECV_OP_GET_OPCODE_CNT( _cid, _tagIndex )       (RECV_OP_GET_OPCODE_CNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _tagIndex ) ))
 #define RECV_OP_INC_OPCODE_CNT( _cid, _tagIndex )       (RECV_OP_INC_OPCODE_CNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _tagIndex ) ))
+#define RECV_OP_CLR_OPCODE_CNT( _cid, _tagIndex )       (RECV_OP_CLR_OPCODE_CNT_BY_INDEX( CHN_RECV_OPCODE_GET_INDEX( _cid ), ( _tagIndex ) ))
 
 /*** Kernel Statistics: ***/
 
@@ -1110,6 +1264,7 @@ static hwMbox_statistics_t stats;
 #define RESET_STATS()                                         (memset(&stats, 0, sizeof(stats)))
 #define STATS_GET_COUNTER( _peer, _type, _isPeerCommander)    (stats.serviceCounters[ _peer ][ ( ( _type ) << 1 ) + ( _isPeerCommander ) ])
 #define STATS_INC_COUNTER( _peer, _type, _isPeerCommander)    (stats.serviceCounters[ _peer ][ ( ( _type ) << 1 ) + ( _isPeerCommander ) ]++)
+#define STATS_DEC_COUNTER( _peer, _type, _isPeerCommander)    (stats.serviceCounters[ _peer ][ ( ( _type ) << 1 ) + ( _isPeerCommander ) ]--)
 
 #define STATS_PEER_IS_COMMANDER   ( True )
 #define STATS_PEER_IS_SUBJECT     ( False )
@@ -1139,7 +1294,7 @@ do{ \
         {                                                                           \
             /* TBD: what to do in this case... */                                   \
             PRINTK_ERR("cid %d: timeout expired!", ( _cid ));                       \
-            return (-1);                                                            \
+            return -ETIMEDOUT;                                                      \
         }                                                                           \
     }                                                                               \
 } while (0)
@@ -1162,6 +1317,43 @@ int hwMbox_isReady(void)
 EXPORT_SYMBOL(hwMbox_isReady);
 
 /**************************************************************************/
+/*! \fn int hwMbox_getChannelConfig(hw_mbox_Masters_e peer,
+                                    hw_mbox_type_e mboxType,
+                                    Bool isPeerCommander,
+                                    hw_mbox_channelConfig_t *cfg)
+ **************************************************************************
+ *  \brief Get channel configuration.
+ *  \param[in] peer - channel peer .
+ *  \param[in] mboxType - channel type.
+ *  \param[in] isPeerCommander - indicates whether the peer is the commander
+ *                               of the channel.
+ *  \param[out] cfg - channel configuration, if found.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_getChannelConfig(hw_mbox_Masters_e peer,
+                            hw_mbox_type_e mboxType,
+                            Bool isPeerCommander,
+                            hw_mbox_channelConfig_t *cfg)
+{
+    Uint32 paramCID;
+
+    if (cfg == NULL)
+    {
+        PRINTK_ERR("cfg == NULL!");
+        return -1;
+    }
+
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+
+    CHECK_FIND_CID_IN_LUT(peer, mboxType, isPeerCommander, return (-1), paramCID);
+
+    memcpy(cfg, &CHN_CFG(paramCID), HW_MBOX_CHANNEL_CONFIG_SIZE);
+
+    return 0;
+}
+EXPORT_SYMBOL(hwMbox_getChannelConfig);
+
+/**************************************************************************/
 /*! \fn int hwMbox_sendCommand(hw_mbox_Masters_e subject,
                                Uint32 *cmd,
                                Uint8 *dataBuf, Uint32 dataLen)
@@ -1453,7 +1645,7 @@ EXPORT_SYMBOL(hwMbox_sendReplyCommand);
  *         received using the HW_MBOX.
  *  \note should be called when no meaningful response is expected in order
  *        to simply ACK the command.
- *  \note Using this function leaves the command register’s value unchanged
+ *  \note Using this function leaves the command register's value unchanged
  *        (writes the same value that was received).
  *  \attention should only be used after a command has been received from
  *             <commander> using hwMbox_recvCommand.
@@ -1718,8 +1910,8 @@ int hwMbox_sendOpcode(hw_mbox_Masters_e
         DPRINTK("cid %d: copying %uB [out of total %uB channel has] from SRAM at offset 0x%08x",
                 paramCID, opFlds.lenInBytes, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
 
-        HW_MBOX_OPCODE_MESSAGE_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID),
-                                              pOpcodeMsg);
+        HW_MBOX_INTERNAL_MESSAGE_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID),
+                                                pOpcodeMsg);
 
         /* output the Reply size: */
         *replyDataLen = opFlds.lenInBytes;
@@ -1942,8 +2134,8 @@ int hwMbox_sendAckOpcode(hw_mbox_Masters
             paramCID, HW_MBOX_OPCODE_MESSAGE_SIZE, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
 
     /* Copy the opcode message to the SRAM: */
-    HW_MBOX_OPCODE_MESSAGE_COPY_TO_SRAM(&opcodeMsg,
-                                        CHN_CFG_MEMBUFF_GET_START(paramCID));
+    HW_MBOX_INTERNAL_MESSAGE_COPY_TO_SRAM(&opcodeMsg,
+                                          CHN_CFG_MEMBUFF_GET_START(paramCID));
 
     /* Build the opcode: */
     opFlds.tag = HW_MBOX_OPCODE_TAG;
@@ -1969,43 +2161,6 @@ int hwMbox_sendAckOpcode(hw_mbox_Masters
 EXPORT_SYMBOL(hwMbox_sendAckOpcode);
 
 /**************************************************************************/
-/*! \fn int hwMbox_getChannelConfig(hw_mbox_Masters_e peer,
-                                    hw_mbox_type_e mboxType,
-                                    Bool isPeerCommander,
-                                    hw_mbox_channelConfig_t *cfg)
- **************************************************************************
- *  \brief Get channel configuration.
- *  \param[in] peer - channel peer .
- *  \param[in] mboxType - channel type.
- *  \param[in] isPeerCommander - indicates whether the peer is the commander
- *                               of the channel.
- *  \param[out] cfg - channel configuration, if found.
- *  \return [ 0 on success / error otherwise ].
- **************************************************************************/
-int hwMbox_getChannelConfig(hw_mbox_Masters_e peer,
-                            hw_mbox_type_e mboxType,
-                            Bool isPeerCommander,
-                            hw_mbox_channelConfig_t *cfg)
-{
-    Uint32 paramCID;
-
-    if (cfg == NULL)
-    {
-        PRINTK_ERR("cfg == NULL!");
-        return -1;
-    }
-
-    CHECK_IS_DRV_INITIALIZED(return (-1));
-
-    CHECK_FIND_CID_IN_LUT(peer, mboxType, isPeerCommander, return (-1), paramCID);
-
-    memcpy(cfg, &CHN_CFG(paramCID), HW_MBOX_CHANNEL_CONFIG_SIZE);
-
-    return 0;
-}
-EXPORT_SYMBOL(hwMbox_getChannelConfig);
-
-/**************************************************************************/
 /*! \fn int hwMbox_registerRecvOpcode(hw_mbox_Masters_e commander,
                                       hwMboxRecvOpcodeCallback pOpcodeCallbackFunc,
                                       Uint32 tag,
@@ -2027,7 +2182,8 @@ int hwMbox_registerRecvOpcode(hw_mbox_Ma
                               Uint32 token)
 {
     int i;
-    Uint32 paramCID, nextTagIndex;
+    Uint32 paramCID;
+    Int32 nextTagIndex;
 
     CHECK_IS_DRV_INITIALIZED(return (-1));
 
@@ -2064,31 +2220,39 @@ int hwMbox_registerRecvOpcode(hw_mbox_Ma
         return -ERESTARTSYS;
     }
 
-    nextTagIndex = RECV_OP_GET_TAG_COUNT(paramCID);
-    if (nextTagIndex == HW_MBOX_OPCODE_TAG_COUNT)
-    {
-        DPRINTK("register Receive Opcode from %s(%d) - max registered tag count (%d) reached!",
-                HW_MBOX_MASTER_GET_NAME(commander), commander, HW_MBOX_OPCODE_TAG_COUNT);
-
-        /* release lock */
-        up(&CHN_LOCK(paramCID));
-        return (-1);
-    }
+    /* invalid index initially */
+    nextTagIndex = -1;
 
-    /* verify that tag is not already registered... */
-    for (i = 0; i < nextTagIndex; i++)
+    for (i = 0; i < HW_MBOX_OPCODE_TAG_COUNT; i++)
     {
-        if(RECV_OP_GET_TAG(paramCID, i) == tag)
+        /* save first free slot to nextTagIndex */
+        if ( (nextTagIndex < 0) &&
+             (HW_MBOX_TAG_INVALID == RECV_OP_GET_TAG(paramCID, i)) )
+        {
+            nextTagIndex = i;
+        }
+
+        if (tag == RECV_OP_GET_TAG(paramCID, i))
         {
             DPRINTK("register Receive Opcode from %s(%d) - tag %u is already registered!",
                     HW_MBOX_MASTER_GET_NAME(commander), commander, tag);
 
             /* release lock */
             up(&CHN_LOCK(paramCID));
-            return 0;
+            return (-1);
         }
     }
 
+    /* there is no free slot if nextTagIndex remains invalid */
+    if (nextTagIndex < 0)
+    {
+        DPRINTK("register Receive Opcode from %s(%d) - max registered tag count (%d) reached!",
+                HW_MBOX_MASTER_GET_NAME(commander), commander, HW_MBOX_OPCODE_TAG_COUNT);
+
+        up(&CHN_LOCK(paramCID));
+        return (-1);
+    }
+
     RECV_OP_SET_TAG(paramCID, nextTagIndex, tag);
     RECV_OP_SET_CB(paramCID, nextTagIndex, pOpcodeCallbackFunc);
     RECV_OP_SET_TOKEN(paramCID, nextTagIndex, token);
@@ -2104,6 +2268,102 @@ int hwMbox_registerRecvOpcode(hw_mbox_Ma
 }
 EXPORT_SYMBOL(hwMbox_registerRecvOpcode);
 
+/**************************************************************************/
+/*! \fn int hwMbox_unregisterRecvOpcode(hw_mbox_Masters_e commander, Uint32 tag)
+ **************************************************************************
+ *  \brief Unregister Receive Opcode from <commander> using the HW_MBOX.
+ *  \attention This function should be called once per tag.
+ *  \param[in] commander - From which Master should the opcode be received.
+ *  \param[in] tag - indicates the destination.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_unregisterRecvOpcode(hw_mbox_Masters_e commander, Uint32 tag)
+{
+    int i;
+    Uint32 paramCID;
+    Int32 retVal = -1;
+
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+
+    CHECK_FIND_CID_IN_LUT(commander, hw_mbox_opcode, CID_LUT_PEER_IS_COMMANDER, return (-1), paramCID);
+
+    if (CHN_RECV_OPCODE_GET_INDEX(paramCID) == CHN_RECV_OPCODE_INDEX_INVALID)
+    {
+        /* should generally not happen since it is changed by
+           set channel config, but it doesn't hurt to make sure... */
+
+        PRINTK_ERR("recvOpIndex == CHN_RECV_OPCODE_INDEX_INVALID");
+        return (-1);
+    }
+
+    /* seize channel lock */
+    if (down_interruptible(&CHN_LOCK(paramCID)))
+    {
+        return -ERESTARTSYS;
+    }
+
+    for (i = 0; i < HW_MBOX_OPCODE_TAG_COUNT; i++)
+    {
+        if (tag == RECV_OP_GET_TAG(paramCID, i))
+        {
+            DPRINTK("unregister Receive Opcode from %s(%d) - tag %u",
+                    HW_MBOX_MASTER_GET_NAME(commander), commander, tag);
+
+#ifdef HW_MBOX_SOCKETS_API
+            if (RECV_OP_GET_CB(paramCID, i) == hwMbox_socketRecvOpCb)
+            {
+                /* This is a subject opcode socket: */
+                struct socket *sock;
+                struct hwMbox_sock *sk;
+
+                sock = (struct socket *)RECV_OP_GET_TOKEN(paramCID, i);
+                if ((sock) && (sk = hwMbox_sk(sock->sk)))
+                {
+                    if (CHN_INTR_STATE_PENDING == (chnIntrState_e)sk->chnIntr)
+                    {
+                        /* if there's a pending channel Interrupt send opcode reply back */
+                        DPRINTK_SKT(sock, "chnIntr is PENDING, sending HW_MBOX_STATUS_OPCODE_ERROR_INVALID_TAG message...");
+                        _hwMbox_sendOpcodeMsg(paramCID, HW_MBOX_STATUS_OPCODE_ERROR_INVALID_TAG);
+
+                        /* Need to fix statistics in this case:
+                           1. Increment the invalid tag message count.
+                           2. Decrement the received OPCODE count since this one wasn't received by application.
+                           [we are holding channel's semaphore so no race with Listener on the fields].
+                        */
+                        RECV_OP_INC_INVALID_TAG_COUNT(paramCID);
+                        STATS_DEC_COUNTER(sk->mid, hw_mbox_opcode, STATS_PEER_IS_COMMANDER);
+                    }
+                }
+                else
+                {
+                    PRINTK_ERR("NULL pointer! [sock=%p]", sock);
+                }
+            }
+#endif /* HW_MBOX_SOCKETS_API */
+
+            RECV_OP_SET_CB(paramCID, i, NULL);
+            RECV_OP_SET_TOKEN(paramCID, i, 0);
+            RECV_OP_CLR_OPCODE_CNT(paramCID, i);
+            RECV_OP_SET_TAG(paramCID, i, HW_MBOX_TAG_INVALID);
+            RECV_OP_DEC_TAG_COUNT(paramCID);
+
+            retVal = 0;
+            break;
+        }
+    }
+
+    if (retVal < 0)
+    {
+        DPRINTK("unregister Receive Opcode from %s(%d) - tag %u failed!!!",
+                HW_MBOX_MASTER_GET_NAME(commander), commander, tag);
+    }
+
+    /* release lock */
+    up(&CHN_LOCK(paramCID));
+    return retVal;
+}
+EXPORT_SYMBOL(hwMbox_unregisterRecvOpcode);
+
 /************************************************************************/
 /*     HW_MBOX proc file system utilities:                              */
 /************************************************************************/
@@ -2131,6 +2391,9 @@ SEQ_PROC_DEFINE(proc_dump_masterDb);
 SEQ_PROC_DEFINE(proc_dump_chnDb);
 SEQ_PROC_DEFINE(proc_dump_recvOpDb);
 SEQ_PROC_DEFINE(proc_dump_recvOpTagsDb);
+#ifdef HW_MBOX_SOCKETS_API
+SEQ_PROC_DEFINE(proc_dump_sockstat);
+#endif /* HW_MBOX_SOCKETS_API */
 
 /* Implement all simple procs here: */
 
@@ -2600,6 +2863,69 @@ static int proc_dump_recvOpDb_show(struc
     return 0;
 }
 
+#ifdef HW_MBOX_SOCKETS_API
+/*! \fn static int proc_dump_sockstat_show(struct seq_file *m, void *v)
+    \brief dump sockets of AF_HWMBOX family */
+static int proc_dump_sockstat_show(struct seq_file *m, void *v)
+{
+    seq_proc_if_control_data_t *controlData = m->private;
+    static struct sock *curr_sk = NULL;
+    loff_t *spos = v;
+    Uint32 i = (Uint32)(*spos);
+    DPRINT_SEQ(m, "SHOW (i=%d, *spos = %lld)\n", i, (long long)*spos);
+
+    if (0 == i)
+    {
+        seq_printf(m, "+------------+-----------+---------------+-------+----------+------+-----------+------+-------+-----------------------+-----------------------+\n");
+        seq_printf(m, "|   SOCKET   | SOCK TYPE |    MASTER     | APPID | PROTOCOL | CHN# |   STATE   | PEND |  PID  |  SENT: CNT BYTES      |  RECV: CNT BYTES      |\n");
+              /* fmt: "| 0x00000000 | ######### | 00 ########## | ##### | ######## |  00  | ######### |  00  | 65535 | 4294967295 0x00000000 | 4294967295 0x00000000 |" */
+
+        if (down_interruptible(&hwMbox_sock_hlist_sem))
+        {
+            return (-1);
+        }
+
+        curr_sk = hlist_entry_safe(hwMbox_sock_hlist.first, struct sock, sk_node);
+    }
+    else
+    {
+        curr_sk = hlist_entry_safe(curr_sk->sk_node.next, struct sock, sk_node);
+    }
+
+    if (curr_sk == NULL)
+    {
+        up(&hwMbox_sock_hlist_sem);
+        seq_printf(m, "+------------+-----------+---------------+-------+----------+------+-----------+------+-------+-----------------------+-----------------------+\n");
+        controlData->endOfData = True;
+        return 0;
+    }
+
+    DPRINT_SEQ(m, "SHOW (i=%d, curr_sk = %p)\n", i, curr_sk);
+
+    if (curr_sk->sk_socket)
+    {
+        seq_printf(m, "| 0x%p | %-9s | %2d %-10s | %5d | %-8s |  %2d  | %-9s |  %2d  | %5d | %10u 0x%08x | %10u 0x%08x |\n",
+                   curr_sk->sk_socket,
+                   HW_MBOX_SOCK_TYPE_GET_STR(curr_sk->sk_socket->type),
+                   hwMbox_sk(curr_sk)->mid,
+                   HW_MBOX_MASTER_GET_NAME(hwMbox_sk(curr_sk)->mid),
+                   hwMbox_sk(curr_sk)->appid,
+                   HW_MBOX_TYPE_STR(HW_MBOX_PROTOCOL_BY_APPID(hwMbox_sk(curr_sk)->appid)),
+                   hwMbox_sk(curr_sk)->cid,
+                   HW_MBOX_SOCK_STATE_STR(curr_sk->sk_socket->state),
+                   (curr_sk->sk_socket->type == SOCK_COMMANDER) ? CHN_INTR_GET_STATE(hwMbox_sk(curr_sk)->cid) /* commander waits on Channel's WQ */
+                                                                : hwMbox_sk(curr_sk)->chnIntr                 /* subject waits on Socket's WQ */,
+                   hwMbox_sk(curr_sk)->owner_pid,
+                   hwMbox_sk(curr_sk)->stat.sent_cnt,
+                   hwMbox_sk(curr_sk)->stat.sent_bytes,
+                   hwMbox_sk(curr_sk)->stat.recv_cnt,
+                   hwMbox_sk(curr_sk)->stat.recv_bytes);
+    }
+
+    return 0;
+}
+#endif /* HW_MBOX_SOCKETS_API */
+
 /*! \fn static int proc_dump_recvOpTagsDb_show(struct seq_file *m, void *v)
     \brief dump HW_MBOX receive Opcode Tags DB Data. */
 static int proc_dump_recvOpTagsDb_show(struct seq_file *m, void *v)
@@ -2615,9 +2941,9 @@ static int proc_dump_recvOpTagsDb_show(s
         if (0 == i)
         {
             /* We are in the first run, print line and headers */
-            seq_printf(m, "+--------+-----+----------+-------------+\n");
-            seq_printf(m, "| RECVOP | TAG |  CB_PTR  |    TOKEN    |\n");
-                  /* fmt: "|     ## | ### | 00000000 |  0x00000000 |" */
+            seq_printf(m, "+--------+------+------------+------------+------------+\n");
+            seq_printf(m, "| RECVOP | TAG  |   CB_PTR   |   TOKEN    | OPCODE_CNT |\n");
+                  /* fmt: "|     ## | #### | 0x00000000 | 0x00000000 | 4294967295 |" */
         }
 
         /* find the correct internal indices */
@@ -2632,26 +2958,28 @@ static int proc_dump_recvOpTagsDb_show(s
 
         if (RECV_OP_THREAD_BY_INDEX(recvOpIndex) != NULL)
         {
-            if (tagIndex < RECV_OP_GET_TAG_COUNT_BY_INDEX(recvOpIndex))
+            if ( (tagIndex < HW_MBOX_OPCODE_TAG_COUNT) &&
+                 (RECV_OP_GET_TAG_BY_INDEX(recvOpIndex, tagIndex) != HW_MBOX_TAG_INVALID) )
             {
                 /* only prints assigned recvOp indices */
-                seq_printf(m, "|     %2d | %3d | %-8p |  0x%08x |\n",
+                seq_printf(m, "|     %2d | %4d | 0x%p | 0x%08x | %10u |\n",
                            recvOpIndex,
                            RECV_OP_GET_TAG_BY_INDEX(recvOpIndex, tagIndex),
                            RECV_OP_GET_CB_BY_INDEX(recvOpIndex, tagIndex),
-                           RECV_OP_GET_TOKEN_BY_INDEX(recvOpIndex, tagIndex));
+                           RECV_OP_GET_TOKEN_BY_INDEX(recvOpIndex, tagIndex),
+                           RECV_OP_GET_OPCODE_CNT_BY_INDEX(recvOpIndex, tagIndex));
             }
         }
         else
         {
             /* no more data, we can already end here... */
-            seq_printf(m, "+--------+-----+----------+-------------+\n");
+            seq_printf(m, "+--------+------+------------+------------+------------+\n");
             controlData->endOfData = True;
         }
 
         if (i == (HW_MBOX_OPCODE_RECV_COUNT * HW_MBOX_OPCODE_TAG_COUNT) - 1) /* Last Line */
         {
-            seq_printf(m, "+--------+-----+----------+-------------+\n");
+            seq_printf(m, "+--------+------+------------+------------+------------+\n");
             controlData->endOfData = True;
         }
     }
@@ -2814,6 +3142,69 @@ int hwMbox_setChannelConfig(hw_mbox_chan
     /* Copy configuration to the DB: */
     memcpy(&CHN_CFG(paramCID), &config, HW_MBOX_CHANNEL_CONFIG_SIZE);
 
+#ifdef HW_MBOX_EXTENDED_MEMORY
+    /* Opcode Channels between NP-CPU and APP-CPU use EXTENDED Memory: */
+    if ( ( ((HW_MBOX_MASTER_NP_CPU == config.commander) && (HW_MBOX_MASTER_APP_CPU == config.subject)) ||
+           ((HW_MBOX_MASTER_APP_CPU == config.commander) && (HW_MBOX_MASTER_NP_CPU == config.subject)) ) &&
+         (hw_mbox_opcode == config.mboxType) )
+    {
+        CHN_CFG_SET_EXTMEM(paramCID, True);
+
+        /* Hardcoded configuration:
+           Part A is allocated to NP-CPU ---> APP-CPU;
+           Part B is allocated to APP-CPU ---> NP-CPU;
+        */
+        if ( (HW_MBOX_MASTER_NP_CPU == config.commander) && (HW_MBOX_MASTER_APP_CPU == config.subject) )
+        {
+            /* NP-CPU ---> APP-CPU: */
+            CHN_CFG_EXTMEM_SET_OFFSET(paramCID, HW_MBOX_EXTMEM_PART_A_OFFSET);
+        }
+        else
+        {
+            /* APP-CPU ---> NP-CPU: */
+            CHN_CFG_EXTMEM_SET_OFFSET(paramCID, HW_MBOX_EXTMEM_PART_B_OFFSET);
+        }
+
+        /* Size is the same for all parts: */
+        CHN_CFG_EXTMEM_SET_SIZE(paramCID, HW_MBOX_EXTMEM_PART_SIZE);
+
+        DPRINTK("cid %d: configured EXTMEM - offset=0x%08x, size=0x%08x...",
+                paramCID,
+                CHN_CFG_EXTMEM_GET_OFFSET(paramCID),
+                CHN_CFG_EXTMEM_GET_SIZE(paramCID));
+
+        /* clear the ownership flag if commander */
+        if (HW_MBOX_MID == config.commander)
+        {
+            hwMbox_extMemCtrlHdr_t extMemHdr = { 0 };
+
+            DPRINTK("cid %d: clear EXTMEM header at extMem offset=0x%08x...",
+                    paramCID, CHN_CFG_EXTMEM_GET_OFFSET(paramCID));
+
+            HW_MBOX_CLR_OWNER(extMemHdr);
+            HW_MBOX_REG32_WRITE(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(CHN_CFG_EXTMEM_GET_OFFSET(paramCID)), extMemHdr);
+
+            DPRINTK("cid %d: entering reading loop on header at extMem offset=0x%x (current value 0x%08x)...",
+                    paramCID, CHN_CFG_EXTMEM_GET_OFFSET(paramCID),
+                    HW_MBOX_REG32_READ(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(CHN_CFG_EXTMEM_GET_OFFSET(paramCID))));
+
+            /* wait till ownership bit will be changed */
+            do
+            {
+                extMemHdr = HW_MBOX_REG32_READ(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(CHN_CFG_EXTMEM_GET_OFFSET(paramCID)));
+                DPRINTK("cid %d: reading loop on header at extMem offset=0x%x (current value 0x%08x)...",
+                        paramCID, CHN_CFG_EXTMEM_GET_OFFSET(paramCID), extMemHdr);
+            } while (!HW_MBOX_EXTMEM_IS_COMMANDER_OWNER(extMemHdr) /* Loop until the commander the owner */);
+
+            DPRINTK("cid %d: exited from reading loop...", paramCID);
+        }
+    }
+    else
+    {
+        CHN_CFG_SET_EXTMEM(paramCID, False);
+    }
+#endif /* HW_MBOX_EXTENDED_MEMORY */
+
     CHN_SET_ASSIGNED(paramCID, True);
 
     if ((config.mboxType == hw_mbox_opcode) &&
@@ -3172,8 +3563,8 @@ static int hwMbox_recvOpcodeListenerEntr
                                 CHN_CFG_MEMBUFF_GET_START(threadData->cid));
 
             /* Get the opcode message from the SRAM: */
-            HW_MBOX_OPCODE_MESSAGE_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(threadData->cid),
-                                                  &opcodeMsg);
+            HW_MBOX_INTERNAL_MESSAGE_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(threadData->cid),
+                                                    &opcodeMsg);
 
             LOG_RECVOP_LISTENER("incoming message is of type %d", opcodeMsg.msgType);
 
@@ -3318,7 +3709,7 @@ static int hwMbox_recvOpcodeListenerEntr
             continue;
         }
 
-        for (i = 0; i < RECV_OP_GET_TAG_COUNT(threadData->cid); i++)
+        for (i = 0; i < HW_MBOX_OPCODE_TAG_COUNT; i++)
         {
             if (RECV_OP_GET_TAG(threadData->cid, i) == opFlds.tag)
             {
@@ -3336,6 +3727,37 @@ static int hwMbox_recvOpcodeListenerEntr
 
         if (recvOpCb == NULL)
         {
+#ifdef HW_MBOX_SOCKETS_API
+#ifdef HW_MBOX_IS_NP_CPU
+            /* For NP-CPU forward only PM tags to user-space */
+            if ( (opFlds.tag == NPCPU_APPCPU_HW_MBOX_TAG_BOOT) ||
+                 (opFlds.tag == NPCPU_APPCPU_HW_MBOX_TAG_PM) )
+            {
+                /* no registered kernel tag found... */
+                /* This means that if it's a valid tag it's for User-Space! */
+                LOG_RECVOP_LISTENER("tag %u is not for kernel! send to User-Space...", opFlds.tag);
+
+                RECV_OP_APP_SET_STATE(threadData->cid, CHN_INTR_STATE_PENDING);
+                wake_up_interruptible(&RECV_OP_APP_WQ(threadData->cid));
+
+                /* release Lock... */
+                up(&CHN_LOCK(threadData->cid));
+                continue;
+            }
+            else
+#endif /* HW_MBOX_IS_NP_CPU */
+            {
+                LOG_RECVOP_LISTENER("tag %u is invalid! send back internal error message...", opFlds.tag);
+
+                replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_OPCODE_ERROR_INVALID_TAG;
+
+                RECV_OP_INC_INVALID_TAG_COUNT(threadData->cid);
+
+                /* release Lock... */
+                up(&CHN_LOCK(threadData->cid));
+                goto SEND_OP_REPLY;
+            }
+#else /* HW_MBOX_SOCKETS_API */
             /* no registered kernel tag found... */
             LOG_RECVOP_LISTENER("tag %u is not for kernel!", opFlds.tag);
 
@@ -3350,16 +3772,20 @@ static int hwMbox_recvOpcodeListenerEntr
             up(&CHN_LOCK(threadData->cid));
             continue;
 #else /* ! HW_MBOX_IS_APP_CPU */
+
             /* APP-CPU does not support User-space HW MBOX SW,
                so it must be an invalid tag! */
             LOG_RECVOP_LISTENER("tag %u is invalid! send back internal error message...", opFlds.tag);
 
             replyOpcodeMsg.msgData.msgStatus.status = HW_MBOX_STATUS_OPCODE_ERROR_INVALID_TAG;
 
+            RECV_OP_INC_INVALID_TAG_COUNT(threadData->cid);
+
             /* release Lock... */
             up(&CHN_LOCK(threadData->cid));
             goto SEND_OP_REPLY;
 #endif /* HW_MBOX_IS_APP_CPU */
+#endif /* ! HW_MBOX_SOCKETS_API */
         }
 
         paramToken = RECV_OP_GET_TOKEN(threadData->cid, i);
@@ -3414,8 +3840,8 @@ SEND_OP_REPLY:
                             replyOpFlds.lenInBytes, CHN_CFG_MEMBUFF_GET_SIZE(threadData->cid), CHN_CFG_MEMBUFF_GET_START(threadData->cid));
 
         /* Copy the opcode message to the SRAM: */
-        HW_MBOX_OPCODE_MESSAGE_COPY_TO_SRAM(&replyOpcodeMsg,
-                                            CHN_CFG_MEMBUFF_GET_START(threadData->cid));
+        HW_MBOX_INTERNAL_MESSAGE_COPY_TO_SRAM(&replyOpcodeMsg,
+                                              CHN_CFG_MEMBUFF_GET_START(threadData->cid));
 
         /* Create opcode reply value: */
         HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT(cmdRegVal, &replyOpFlds);
@@ -3860,7 +4286,7 @@ int hwMbox_drv_registerWithNetss(void)
     }
     else
     {
-        PRINTK_INFO("mem_iobase = 0x%x, mem_iosize = 0x%x",
+        PRINTK_INFO("HW_MBOX MMIO: mem_iobase = 0x%x, mem_iosize = 0x%x",
                     (unsigned int)hwMbox_mmio.base, (unsigned int)hwMbox_mmio.size);
     }
 
@@ -3873,6 +4299,28 @@ int hwMbox_drv_registerWithNetss(void)
         return ret;
     }
 
+#ifdef HW_MBOX_EXTENDED_MEMORY
+    DPRINTK("Getting extended memory MMIO info...");
+    if(netss_device_get_info(NETSS_DEV_PERIPHERAL_SRAM, &hwMbox_mmio))
+    {
+        PRINTK_ERR("Failed to get extended memory mmio info!");
+        return -1;
+    }
+    else
+    {
+        PRINTK_INFO("EXT_MEM MMIO: mem_iobase = 0x%x, mem_iosize = 0x%x",
+                    (unsigned int)hwMbox_mmio.base, (unsigned int)hwMbox_mmio.size);
+    }
+
+    DPRINTK("ioremap extended memory...");
+    hwMboxDriverData.extMem_base = (void __iomem *)ioremap_nocache(hwMbox_mmio.base, hwMbox_mmio.size);
+    if (!hwMboxDriverData.extMem_base)
+    {
+        PRINTK_ERR("Failed to ioremap extended memory!");
+        ret = -ENOMEM;
+        return ret;
+    }
+#endif /* HW_MBOX_EXTENDED_MEMORY */
     DPRINTK("Registered driver with Net Subsystem successfully!");
     return 0;
 }
@@ -3978,6 +4426,22 @@ static int __init hwMbox_drv_init(void)
 
     DPRINTK("Created %d /dev/%s/%sXX devices", HW_MBOX_CHANNEL_COUNT, HW_MBOX_DRV_DEV_DIR_NAME, HW_MBOX_CHNINT_DEV_NAME);
 
+#ifdef HW_MBOX_SOCKETS_API
+    /* Initialize HW_MBOX sockets */
+    retVal = proto_register(&hwMbox_proto, 0);
+    if (retVal != 0)
+    {
+        PRINTK_ERR("Couldn't initialize hwMbox sockets!");
+        return retVal;
+    }
+
+    sock_register(&hwMbox_family_ops);
+    DPRINTK("AF_HWMBOX socket family registered");
+
+    /* Initialize semaphore for sockstat */
+    sema_init(&hwMbox_sock_hlist_sem, 1);
+#endif /* HW_MBOX_SOCKETS_API */
+
     /* Create the Proc filesystem utilities ( /proc/<HW_MBOX_PROC_DIR_STR>/ ): */
     {
         struct proc_dir_entry *procDir;
@@ -4002,6 +4466,11 @@ static int __init hwMbox_drv_init(void)
         SEQ_PROC_CREATE("chnDb", proc_dump_chnDb, procDir);
         SEQ_PROC_CREATE("recvOpDb", proc_dump_recvOpDb, procDir);
         SEQ_PROC_CREATE("tagsDb", proc_dump_recvOpTagsDb, procDir);
+
+#ifdef HW_MBOX_SOCKETS_API
+        /* AF_HWMBOX sockets Procs: */
+        SEQ_PROC_CREATE("sockstat", proc_dump_sockstat, procDir);
+#endif /* HW_MBOX_SOCKETS_API */
     }
     DPRINTK("Created proc directory: /proc/%s", HW_MBOX_PROC_DIR_STR);
 
@@ -4321,8 +4790,8 @@ static int __init hwMbox_drv_init(void)
                             paramCID, opFlds.lenInBytes, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
 
                     /* Send the opcode message: */
-                    HW_MBOX_OPCODE_MESSAGE_COPY_TO_SRAM(&opcodeMsg,
-                                                        CHN_CFG_MEMBUFF_GET_START(paramCID));
+                    HW_MBOX_INTERNAL_MESSAGE_COPY_TO_SRAM(&opcodeMsg,
+                                                          CHN_CFG_MEMBUFF_GET_START(paramCID));
 
                     DPRINTK("using cid %d as INIT CID master %d, sending cmdRegVal=0x%08x", paramCID, paramMID, cmdRegVal);
 
@@ -4425,22 +4894,1388 @@ static int __init hwMbox_drv_init(void)
  **************************************************************************/
 static void __exit hwMbox_drv_exit(void)
 {
+#ifdef HW_MBOX_SOCKETS_API
+    sock_unregister(PF_HWMBOX);
+    proto_unregister(&hwMbox_proto);
+    DPRINTK("AF_HWMBOX socket family unregistered");
+#endif /* HW_MBOX_SOCKETS_API */
+
 #if defined HW_MBOX_IS_NP_CPU
     free_irq(HW_MBOX_INT_LINE, NULL);
 #elif defined HW_MBOX_IS_APP_CPU
-    netss_interrupt_info_t irq_info;
-    irq_info.func = NULL;
-    irq_info.args = NULL;
-    netss_interrupt_register(NETSS_INTERUPT_HWMBOX, -1, &irq_info);
+    {
+        netss_interrupt_info_t irq_info;
+        irq_info.func = NULL;
+        irq_info.args = NULL;
+        netss_interrupt_register(NETSS_INTERUPT_HWMBOX, -1, &irq_info);
+    }
+
     iounmap(hwMboxDriverData.reg_base);
+#ifdef HW_MBOX_EXTENDED_MEMORY
+    iounmap(hwMboxDriverData.extMem_base);
+#endif /* HW_MBOX_EXTENDED_MEMORY */
 #endif
    chnint_cleanup(HW_MBOX_CHANNEL_COUNT);
 }
 
-subsys_initcall(hwMbox_drv_init);
-module_exit(hwMbox_drv_exit);
+/**************************************************************************/
+/*! \fn void _hwMbox_sendOpcodeMsg(Uint32 paramCID, HW_MBOX_STATUS_e status)
+ **************************************************************************
+ *  \brief send status message in channel.
+ *  \return void.
+ **************************************************************************/
+static void _hwMbox_sendOpcodeMsg(Uint32 paramCID, HW_MBOX_STATUS_e status)
+{
+    hwMbox_opcodeMessage_t replyOpcodeMsg;
+    hwMbox_opcode_t replyOpFlds = { 0 };
+    Uint32 cmdRegVal;
+
+    replyOpFlds.tag = HW_MBOX_OPCODE_TAG;
+    replyOpFlds.lenInBytes = HW_MBOX_OPCODE_MESSAGE_SIZE;
+
+    replyOpcodeMsg.msgType = HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS;
+    replyOpcodeMsg.msgData.msgStatus.status = status;
+
+    /* Use the current values in the Reply OPCODE message and the Reply OPCODE fields structs: */
+    DPRINTK("cid %d: sending back opcode message of type STATUS (%d), with status value 0x%x (%d)",
+            paramCID, replyOpcodeMsg.msgType,
+            replyOpcodeMsg.msgData.msgStatus.status, replyOpcodeMsg.msgData.msgStatus.status);
+
+    DPRINTK("cid %d: copying %uB [out of total %uB channel has] to SRAM at offset=0x%08x",
+            paramCID, replyOpFlds.lenInBytes, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+    /* Copy the opcode message to the SRAM: */
+    HW_MBOX_INTERNAL_MESSAGE_COPY_TO_SRAM(&replyOpcodeMsg, CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+    /* Create opcode reply value: */
+    HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT(cmdRegVal, &replyOpFlds);
+
+    DPRINTK("cid %d: opcode fields - tag=%u, lenInBytes=%u -> cmdRegVal=0x%08x",
+            paramCID, replyOpFlds.tag, replyOpFlds.lenInBytes, cmdRegVal);
+
+    DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+    DPRINTK("cid %d: writing 0x%08x to the command register of the channel...", paramCID, cmdRegVal);
+    HW_MBOX_CHN_COMMAND_REG_SET(paramCID, cmdRegVal); /* send Command... */
+    DPRINTK("cid %d: after write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+}
+
+/**************************************************************************/
+/*! \fn int _hwMbox_SendMsg(Uint32 paramCID, Uint32 paramAppID,
+ *                          Uint8 *dataBuf, Uint32 dataLen,
+ *                          Uint32 userOrKernel)
+ **************************************************************************
+ *  \brief internal routine for hwMbox_sendCmdMsg() and hwMbox_sendReplyMsg().
+ *  \return [ transmitted bytes on success / error otherwise ].
+ **************************************************************************/
+static int _hwMbox_SendMsg(Uint32 paramCID, Uint32 paramAppID,
+                           Uint8 *dataBuf, Uint32 dataLen,
+                           Uint32 userOrKernel)
+{
+    hw_mbox_type_e paramProto;
+    Uint32 cmdRegVal;
+    Int32 retVal = 0;
+
+    CHECK_IS_DRV_INITIALIZED(return -ENETDOWN);
+
+    paramProto = HW_MBOX_PROTOCOL_BY_APPID(paramAppID);
+
+    DPRINTK("cid %d: size of buffer %uB", paramCID, dataLen);
+
+    if ((dataBuf == NULL) || (dataLen == 0))
+    {
+        PRINTK_ERR("cid %d: No Buffer specified! [dataBuf %p, dataLen %uB]",
+                   paramCID, dataBuf, dataLen);
+
+        return -ENOMEM;
+    }
+
+    if (hw_mbox_command == paramProto)
+    {
+        /* command protocol */
+
+        if (dataLen > CHN_CFG_MEMBUFF_GET_SIZE(paramCID))
+        {
+            PRINTK_ERR("cid %d: command - data Buffer size (%uB) > SRAM size allocated to channel (%uB)!",
+                       paramCID, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID));
+            return -EMSGSIZE;
+        }
+
+        switch (userOrKernel)
+        {
+            case HW_MBOX_COPY_USER:
+                get_user(cmdRegVal, (Uint32 *)dataBuf);
+                if (dataLen > 4)
+                {
+                    /* copy from dataBuf with 4 bytes offset */
+                    if (HW_MBOX_USER_COPY_TO_SRAM((dataBuf + sizeof(cmdRegVal)), dataLen, CHN_CFG_MEMBUFF_GET_START(paramCID)))
+                    {
+                        return -ENOMEM;
+                    }
+                }
+                break;
+
+            case HW_MBOX_COPY_KERNEL:
+                cmdRegVal = *((Uint32 *)dataBuf);
+                if (dataLen > 4)
+                {
+                    /* copy from dataBuf with 4 bytes offset */
+                    HW_MBOX_COPY_TO_SRAM((dataBuf + sizeof(cmdRegVal)), dataLen, CHN_CFG_MEMBUFF_GET_START(paramCID));
+                }
+                break;
+
+            default:
+                return -EINVAL;
+        }
+
+        DPRINTK("cid %d: command - [command value 0x%08x with %uB of data]",
+                paramCID, cmdRegVal, dataLen);
+    }
+    else if (hw_mbox_opcode == paramProto)
+    {
+        /* opcode protocol */
+        hwMbox_opcode_t opFlds = { 0 };
+#ifdef HW_MBOX_EXTENDED_MEMORY
+        hwMbox_extMemMsgData_t sramMsg = { 0 };
+#endif /* HW_MBOX_EXTENDED_MEMORY */
+
+        DPRINTK("cid %d: opcode - [tag %u with %uB of data]",
+                paramCID, paramAppID, dataLen);
+
+        if (dataLen < HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES)
+        {
+            PRINTK_ERR("cid %d: opcode - Insufficient Size Buffer specified! [dataLen %uB, minimal size is %dB]",
+                       paramCID, dataLen, HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES);
+
+            return -EBADMSG;
+        }
+
+        opFlds.tag = paramAppID;
+        opFlds.lenInBytes = dataLen;
+
+        retVal = dataLen;
+
+#ifdef HW_MBOX_EXTENDED_MEMORY
+        if (CHN_CFG_IS_EXTMEM(paramCID))
+        {
+            if ((dataLen + sizeof(hwMbox_extMemCtrlHdr_t)) > HW_MBOX_EXTMEM_PART_SIZE)
+            {
+                PRINTK_ERR("cid %d: sendOpcode msg over EXTMEM is too long [(dataLen(%u) + sizeof(hwMbox_extMemCtrlHdr_t)(%u)) > extMem part size (%u)]!",
+                           paramCID, dataLen, sizeof(hwMbox_extMemCtrlHdr_t), HW_MBOX_EXTMEM_PART_SIZE);
+                return -EMSGSIZE;
+            }
+
+            DPRINTK("cid %d: copying %uB to EXTMEM at extMem offset=0x%x",
+                    paramCID, dataLen, CHN_CFG_EXTMEM_GET_OFFSET(paramCID) + sizeof(hwMbox_extMemCtrlHdr_t));
+
+            /* if we have data copy to EXTENDED MEMORY */
+            if (dataLen > 0)
+            {
+                switch (userOrKernel)
+                {
+                    case HW_MBOX_COPY_USER:
+                        if (HW_MBOX_USER_COPY_TO_EXTMEM(dataBuf, dataLen, (CHN_CFG_EXTMEM_GET_OFFSET(paramCID) + sizeof(hwMbox_extMemCtrlHdr_t))))
+                        {
+                            return -ENOMEM;
+                        }
+                        break;
+
+                    case HW_MBOX_COPY_KERNEL:
+                        HW_MBOX_COPY_TO_EXTMEM(dataBuf, dataLen, (CHN_CFG_EXTMEM_GET_OFFSET(paramCID) + sizeof(hwMbox_extMemCtrlHdr_t)));
+                        break;
+
+                    default:
+                        return -EINVAL;
+                }
+            }
+
+            {
+                /*  set ownership bit */
+                hwMbox_extMemCtrlHdr_t  extMemHdr;
+
+                /* first word of Extended Memory is control header */
+                extMemHdr = HW_MBOX_REG32_READ(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(CHN_CFG_EXTMEM_GET_OFFSET(paramCID)));
+
+                /* determine side. set ownership to 1 if commander, 0 overwise */
+                if (HW_MBOX_MID == CHN_CFG_GET_COMMANDER(paramCID))
+                {
+                    HW_MBOX_SET_OWNER(extMemHdr);
+                }
+                else
+                {
+                    HW_MBOX_CLR_OWNER(extMemHdr);
+                }
+
+                DPRINTK("cid %d: writing new control header of extended memory (0x%08x) at extMem offset 0x%x, previous value=0x%08x",
+                        paramCID, extMemHdr, CHN_CFG_EXTMEM_GET_OFFSET(paramCID),
+                        HW_MBOX_REG32_READ(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(CHN_CFG_EXTMEM_GET_OFFSET(paramCID))));
+
+                HW_MBOX_REG32_WRITE(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(CHN_CFG_EXTMEM_GET_OFFSET(paramCID)), extMemHdr);
+
+                DPRINTK("cid %d: after writing control header = 0x%08x",
+                        paramCID, HW_MBOX_REG32_READ(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(CHN_CFG_EXTMEM_GET_OFFSET(paramCID))));
+            }
+
+            sramMsg.lenInBytes = dataLen;
+            sramMsg.offset = CHN_CFG_EXTMEM_GET_OFFSET(paramCID) + sizeof(hwMbox_extMemCtrlHdr_t);
+
+            DPRINTK("cid %d: sramMsg: len=%u, offset=0x%08x",
+                    paramCID, sramMsg.lenInBytes, sramMsg.offset);
+
+            /* overwrite opcode len with 8 bytes of extmem structure */
+            opFlds.lenInBytes = sizeof(sramMsg);
+
+            /* Send the opcode message: */
+            HW_MBOX_INTERNAL_MESSAGE_COPY_TO_SRAM(&sramMsg, CHN_CFG_MEMBUFF_GET_START(paramCID));
+        }
+        else
+#endif /* HW_MBOX_EXTENDED_MEMORY */
+        {
+            if (dataLen > CHN_CFG_MEMBUFF_GET_SIZE(paramCID))
+            {
+                PRINTK_ERR("cid %d: opcode - data Buffer size (%uB) > SRAM size allocated to channel (%uB)!",
+                           paramCID, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID));
+                return -EMSGSIZE;
+            }
+
+            if (dataLen > 0)
+            {
+                switch (userOrKernel)
+                {
+                    case HW_MBOX_COPY_USER:
+                        if (HW_MBOX_USER_COPY_TO_SRAM(dataBuf, dataLen, CHN_CFG_MEMBUFF_GET_START(paramCID)))
+                        {
+                            return -ENOMEM;
+                        }
+                    break;
+
+                    case HW_MBOX_COPY_KERNEL:
+                        HW_MBOX_COPY_TO_SRAM(dataBuf, dataLen, CHN_CFG_MEMBUFF_GET_START(paramCID));
+                        break;
+
+                    default:
+                        return -EINVAL;
+                }
+            }
+        }
+
+        /* Create the opcode value: */
+        HW_MBOX_OPCODE_FIELDS_SET_FROM_STRUCT(cmdRegVal, &opFlds);
+
+        DPRINTK("cid %d: opcode - fields: tag=%u, lenInBytes=%u -> cmdRegVal=0x%08x",
+                paramCID, opFlds.tag, opFlds.lenInBytes, cmdRegVal);
+    }
+    else
+    {
+        /* other protocols not supported*/
+        return -EINVAL;
+    }
+
+    DPRINTK("cid %d: copying %uB [out of total %uB channel has] to SRAM at offset=0x%08x",
+            paramCID, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+    DPRINTK("cid %d: before write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+    DPRINTK("cid %d: writing 0x%08x to the command register of the channel...", paramCID, cmdRegVal);
+    HW_MBOX_CHN_COMMAND_REG_SET(paramCID, cmdRegVal);
+    DPRINTK("cid %d: after write to command register - state=%d", paramCID, HW_MBOX_CHN_STATE_REG_GET(paramCID));
+
+    DPRINTK("cid %d: returning %d", paramCID, retVal);
+    return retVal;
+}
+
+/**************************************************************************/
+/*! \fn int hwMbox_sendCmdMsg(hw_mbox_Masters_e subject, Uint32 paramAppID,
+                              Uint8 *dataBuf, Uint32 dataLen,
+                              Uint32 userOrKernel)
+ **************************************************************************
+ *  \brief lock channel and write message to subject.
+ *  \return [ transmitted bytes on success / -1 on error ].
+ **************************************************************************/
+static int hwMbox_sendCmdMsg(hw_mbox_Masters_e subject, Uint32 paramAppID,
+                             Uint8 *dataBuf, Uint32 dataLen,
+                             Uint32 userOrKernel)
+{
+    Uint32 paramCID;
+    Int32 retVal;
+
+    CHECK_IS_DRV_INITIALIZED(return -ENETDOWN);
+
+    if (!IS_MASTER_INIT(subject))
+    {
+        DPRINTK("master %s(%d) is not initialized!",
+                HW_MBOX_MASTER_GET_NAME(subject), subject);
+        return -EHOSTDOWN;
+    }
+
+    CHECK_FIND_CID_IN_LUT(subject,
+                          HW_MBOX_PROTOCOL_BY_APPID(paramAppID),
+                          CID_LUT_PEER_IS_SUBJECT,
+                          return -EHOSTUNREACH,
+                          paramCID);
+
+    /* seize channel lock */
+    if (down_interruptible(&CHN_LOCK(paramCID)))
+    {
+        DPRINTK("down interrupted by signal...");
+        return -ERESTARTSYS;
+    }
+
+    retVal = _hwMbox_SendMsg(paramCID, paramAppID, dataBuf, dataLen, userOrKernel);
+
+    /* unlock the channel in case of error */
+    if (retVal < 0)
+    {
+        up(&CHN_LOCK(paramCID));
+    }
+
+    return retVal;
+}
+
+/**************************************************************************/
+/*! \fn int hwMbox_sendReplyMsg(hw_mbox_Masters_e commander, Uint32 paramAppID,
+                                Uint8 *dataBuf, Uint32 dataLen,
+                                Uint32 userOrKernel)
+ **************************************************************************
+ *  \brief write reply to commander and unlock channel.
+ *  \return [ transmitted bytes on success / -1 on error ].
+ **************************************************************************/
+static int hwMbox_sendReplyMsg(hw_mbox_Masters_e commander, Uint32 paramAppID,
+                               Uint8 *dataBuf, Uint32 dataLen,
+                               Uint32 userOrKernel)
+{
+    Uint32 paramCID;
+    Int32 retVal;
+
+    CHECK_IS_DRV_INITIALIZED(return -ENETDOWN);
+
+    CHECK_FIND_CID_IN_LUT(commander,
+                          HW_MBOX_PROTOCOL_BY_APPID(paramAppID),
+                          CID_LUT_PEER_IS_COMMANDER,
+                          return -EHOSTUNREACH,
+                          paramCID);
+
+    retVal = _hwMbox_SendMsg(paramCID, paramAppID, dataBuf, dataLen, userOrKernel);
+
+    return retVal;
+}
+
+/**************************************************************************/
+/*! \fn int _hwMbox_RecvMsg(Uint32 paramCID, Uint32 paramAppID,
+                            Uint8 *dataBuf, Uint32 dataLen,
+                            Uint32 userOrKernel,
+                            Uint32 eraseMemAfter,
+                            HW_MBOX_STATUS_e *pHwMboxStatus)
+ **************************************************************************
+ *  \brief internal routine for hwMbox_RecvCmd(), hwMbox_ReadReply().
+ *  \return [ received bytes on success / error otherwise ].
+ **************************************************************************/
+static int _hwMbox_RecvMsg(Uint32 paramCID, Uint32 paramAppID,
+                           Uint8 *dataBuf, Uint32 dataLen,
+                           Uint32 userOrKernel,
+                           Uint32 eraseMemAfter,
+                           HW_MBOX_STATUS_e *pHwMboxStatus)
+{
+    hw_mbox_type_e paramProto;
+    Uint32 cmdRegVal;
+    Int32 retVal = 0;
+
+    paramProto = HW_MBOX_PROTOCOL_BY_APPID(paramAppID);
+
+    if ((dataBuf == NULL) || (dataLen == 0))
+    {
+        PRINTK_ERR("cid %d: No Buffer specified! [dataBuf %p, dataLen %uB]",
+                   paramCID, dataBuf, dataLen);
+
+        return -ENOBUFS;
+    }
+
+    /* get the Reply: */
+    cmdRegVal = HW_MBOX_CHN_COMMAND_REG_GET(paramCID);
+
+    DPRINTK("cid %d: reply from subject cmdRegVal=0x%08x", paramCID, cmdRegVal);
+
+    retVal = dataLen;
+
+    if (hw_mbox_command == paramProto)
+    {
+        /* command protocol */
+
+        if (dataLen > CHN_CFG_MEMBUFF_GET_SIZE(paramCID))
+        {
+            PRINTK_ERR("cid %d: command - data len (%uB) > SRAM size allocated to channel (%uB)!",
+                       paramCID, dataLen, CHN_CFG_MEMBUFF_GET_SIZE(paramCID));
+            return -ENOBUFS;
+        }
+
+        switch (userOrKernel)
+        {
+            case HW_MBOX_COPY_USER:
+                put_user(cmdRegVal, (Uint32 *)dataBuf);
+                if (dataLen > 4)
+                {
+                    /* copy to dataBuf with 4 bytes offset */
+                    if (HW_MBOX_USER_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID), dataLen, (dataBuf + sizeof(cmdRegVal))))
+                    {
+                        return -ENOMEM;
+                    }
+                }
+                break;
+
+            case HW_MBOX_COPY_KERNEL:
+                *(Uint32 *)dataBuf = cmdRegVal;
+                if (dataLen > 4)
+                {
+                    /* copy to dataBuf with 4 bytes offset */
+                    HW_MBOX_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID), dataLen, (dataBuf + sizeof(cmdRegVal)));
+                }
+                break;
+
+            default:
+                return -EINVAL;
+        }
+    }
+    else if (hw_mbox_opcode == paramProto)
+    {
+        /* opcode protocol */
+        hwMbox_opcode_t opFlds = { 0 };
+        hwMbox_opcodeMessage_t *pOpcodeMsg;
+#ifdef HW_MBOX_EXTENDED_MEMORY
+        hwMbox_extMemMsgData_t sramMsg = { 0 };
+#endif /* HW_MBOX_EXTENDED_MEMORY */
+
+        /* parse to opcode fields: */
+        HW_MBOX_OPCODE_FIELDS_GET_TO_STRUCT(cmdRegVal, &opFlds);
+
+        /* First check for internal replies: */
+        if (opFlds.tag == HW_MBOX_OPCODE_TAG)
+        {
+            /* 3 possible options here:
+                 1. this was a HW MBOX TAG sendOpcode.
+                 2. this was not a HW MBOX sendOpcode but it failed and the
+                    data returned is a Status Message with the error code.
+                 3. this was not a HW MBOX sendOpcode and subject used
+                    sendAckOpcode to simply ACK the sent opcode.
+            */
+
+            /* Either way we should check for a status message: */
+            if (opFlds.lenInBytes != HW_MBOX_OPCODE_MESSAGE_SIZE)
+            {
+                PRINTK_ERR("cid %d: invalid message for tag %u [got size %uB, excpected size %uB]!",
+                           paramCID, HW_MBOX_OPCODE_TAG, opFlds.lenInBytes, HW_MBOX_OPCODE_MESSAGE_SIZE);
+
+                /* Output status messge in User Buffer: */
+                pOpcodeMsg = (hwMbox_opcodeMessage_t *)dataBuf;
+
+                /* Change to correct Opcode message to output to User: */
+                pOpcodeMsg->msgType = HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS;
+                pOpcodeMsg->msgData.msgStatus.status = HW_MBOX_STATUS_OPCODE_ERROR_INVALID_MESSAGE;
+
+                /* Set the correct size: */
+                retVal = HW_MBOX_OPCODE_MESSAGE_SIZE;
+
+                return -EBADMSG;
+            }
+
+            /* Opcode message was sent: */
+            pOpcodeMsg = (hwMbox_opcodeMessage_t *)dataBuf;
+
+            /* Copy the Opcode Message from SRAM: */
+
+            DPRINTK("cid %d: copying %uB [out of total %uB channel has] from SRAM at offset 0x%08x",
+                    paramCID, opFlds.lenInBytes, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+            HW_MBOX_INTERNAL_MESSAGE_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID),
+                                                    pOpcodeMsg);
+
+            /* output the Reply size: */
+            retVal = opFlds.lenInBytes;
+
+            DPRINTK("cid %d: received HW_MBOX_OPCODE_MESSAGE - msgType %d",
+                    paramCID, pOpcodeMsg->msgType);
+
+            if (pOpcodeMsg->msgType != HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS)
+            {
+                PRINTK_ERR("cid %d: send Opcode - unexpected message type for tag %u at this point [got type %d, excpected type %d]!",
+                           paramCID, HW_MBOX_OPCODE_TAG, pOpcodeMsg->msgType, HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS);
+
+                /* Change to correct Opcode message to output to User: */
+                pOpcodeMsg->msgType = HW_MBOX_OPCODE_MESSAGE_TYPE_STATUS;
+                pOpcodeMsg->msgData.msgStatus.status = HW_MBOX_STATUS_OPCODE_ERROR_ILLEGAL_MESSAGE;
+
+                return -EBADMSG;
+            }
+
+            /* Opcode Reply Message of type STATUS: */
+
+            DPRINTK("cid %d: received HW_MBOX_OPCODE_MESSAGE of type STATUS(%d) - STATUS = 0x%x (%u)",
+                    paramCID, pOpcodeMsg->msgType,
+                    pOpcodeMsg->msgData.msgStatus.status, pOpcodeMsg->msgData.msgStatus.status);
+
+            /* Check the returned STATUS value: */
+            switch (pOpcodeMsg->msgData.msgStatus.status)
+            {
+                case HW_MBOX_STATUS_OK:
+                    DPRINTK("cid %d: send Opcode - subject replied with ACK!", paramCID);
+
+                    /* ACK should succeed and return with no Data: */
+                    retVal = 0;
+                    break;
+
+                case HW_MBOX_STATUS_OPCODE_ERROR_INVALID_TAG:
+                    DPRINTK("cid %d: send Opcode - subject replied with OPCODE INVALID TAG!", paramCID);
+                    retVal = (-ECONNREFUSED);
+                    break;
+
+                default:
+                    /* Internal Error! */
+                    PRINTK_ERR("cid %d: send Opcode - subject replied with internal error! STATUS = 0x%x (%u)",
+                               paramCID, pOpcodeMsg->msgData.msgStatus.status, pOpcodeMsg->msgData.msgStatus.status);
+
+                    retVal = (-EBADMSG);
+            }
+
+#ifdef HW_MBOX_EXTENDED_MEMORY
+            /* clear the ownership flag if commander and the channel is with extended memory support */
+            if ( CHN_CFG_IS_EXTMEM(paramCID) &&
+                 (CHN_CFG_GET_COMMANDER(paramCID) == HW_MBOX_MID) )
+            {
+                hwMbox_extMemCtrlHdr_t extMemHdr = { 0 };
+                HW_MBOX_CLR_OWNER(extMemHdr);
+                HW_MBOX_REG32_WRITE(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(CHN_CFG_EXTMEM_GET_OFFSET(paramCID)), extMemHdr);
+
+                DPRINTK("cid %d: entering reading loop on header at ext mem offset=%x (current value 0x%08x)...",
+                        paramCID, CHN_CFG_EXTMEM_GET_OFFSET(paramCID),
+                        HW_MBOX_REG32_READ(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(CHN_CFG_EXTMEM_GET_OFFSET(paramCID))));
+
+                /* wait till ownership bit will be changed */
+                do
+                {
+                    extMemHdr = HW_MBOX_REG32_READ(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(CHN_CFG_EXTMEM_GET_OFFSET(paramCID)));
+                    DPRINTK("cid %d: reading loop on header at ext mem offset=%x (current value 0x%08x)...",
+                            paramCID, CHN_CFG_EXTMEM_GET_OFFSET(paramCID), extMemHdr);
+                } while (!HW_MBOX_EXTMEM_IS_COMMANDER_OWNER(extMemHdr) /* Loop until the commander the owner */);
+
+                DPRINTK("cid %d: exited from reading loop...", paramCID);
+            }
+#endif /* HW_MBOX_EXTENDED_MEMORY */
+
+            /* erase is not needed in this case */
+            eraseMemAfter = 0;
+        }
+        else
+        {
+            DPRINTK("cid %d: cmdRegVal=0x%08x -> opcode fields: tag=%u, lenInBytes=%u",
+                    paramCID, cmdRegVal, opFlds.tag, opFlds.lenInBytes);
+
+            /* Copy the Opcode Message from SRAM: */
+            DPRINTK("cid %d: copying %uB [out of total %uB channel has] from SRAM at offset 0x%08x",
+                    paramCID, opFlds.lenInBytes, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+            /* Reply has data! */
+            if (opFlds.lenInBytes > dataLen)
+            {
+                /* Opcode reply data longer than specified buffer... */
+                PRINTK_ERR("cid %d: opcode reply data length (%uB) > specified buffer size (%uB)!",
+                           paramCID, opFlds.lenInBytes, dataLen);
+
+                *pHwMboxStatus = HW_MBOX_STATUS_OPCODE_ERROR_MESSAGE_TOO_LONG;
+
+                return -EMSGSIZE;
+            }
+
+            DPRINTK("cid %d: opcode reply with %uB of data", paramCID, dataLen);
+
+            if ((dataBuf != NULL) && (opFlds.lenInBytes > 0))
+            {
+                DPRINTK("cid %d: copying %uB [out of total %uB channel has] from SRAM at offset=0x%08x",
+                        paramCID, opFlds.lenInBytes, CHN_CFG_MEMBUFF_GET_SIZE(paramCID), CHN_CFG_MEMBUFF_GET_START(paramCID));
+
+#ifdef HW_MBOX_EXTENDED_MEMORY
+                if (CHN_CFG_IS_EXTMEM(paramCID))
+                {
+                    if (sizeof(sramMsg) != opFlds.lenInBytes)
+                    {
+                        /* ext mem data length has wrong length: */
+                        PRINTK_ERR("cid %d: ext mem data length (%uB) != size of extMemMsgData_t (%uB)",
+                                   paramCID, opFlds.lenInBytes, sizeof(sramMsg));
+
+                        *pHwMboxStatus = HW_MBOX_STATUS_OPCODE_ERROR_INVALID_MESSAGE;
+
+                        return -EBADMSG;
+                    }
+
+                    HW_MBOX_INTERNAL_MESSAGE_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID),
+                                                            &sramMsg);
+
+                    DPRINTK("cid %d: received op message of EXTMEM type with offset=0x%08x and lenInBytes=%u",
+                            paramCID, sramMsg.offset, sramMsg.lenInBytes);
+
+                    /* data in EXTMEM more than maximum: */
+                    if ((sramMsg.lenInBytes + sizeof(hwMbox_extMemCtrlHdr_t)) > HW_MBOX_EXTMEM_PART_SIZE)
+                    {
+                        PRINTK_ERR("cid %d: recvOpcode msg over EXTMEM is too long [(lenInBytes(%u) + sizeof(hwMbox_extMemCtrlHdr_t)(%u)) > extMem part size (%u)]!",
+                                   paramCID,
+                                   sizeof(hwMbox_extMemCtrlHdr_t),
+                                   sramMsg.lenInBytes,
+                                   HW_MBOX_EXTMEM_PART_SIZE);
+
+                        *pHwMboxStatus = HW_MBOX_STATUS_OPCODE_ERROR_MESSAGE_TOO_LONG;
+
+                        return -EMSGSIZE;
+                    }
+
+                    /* Sent data over EXTMEM is more than available buffer: */
+                    if (sramMsg.lenInBytes > dataLen)
+                    {
+                        PRINTK_ERR("cid %d: recvOpcode EXTMEM - lenInBytes(%u) > dataLen (%u)!",
+                                   paramCID, sramMsg.lenInBytes, dataLen);
+
+                        *pHwMboxStatus = HW_MBOX_STATUS_OPCODE_ERROR_MESSAGE_TOO_LONG;
+
+                        return -EMSGSIZE;
+                    }
+
+                    DPRINTK("cid %d: copying %uB from extMem offset=0x%08x",
+                            paramCID, sramMsg.lenInBytes, sramMsg.offset);
+
+                    {
+                        /* wait for desired ownership value before read data from extended memory */
+                        hwMbox_extMemCtrlHdr_t    extMemHdr;
+
+                        /* determine side. set ownership to 1 if commander, 0 overwise */
+                        DPRINTK("cid %d: Entering reading loop on header at ext mem offset=%x ...",
+                                paramCID, sramMsg.offset - sizeof(hwMbox_extMemCtrlHdr_t));
+
+                        /* wait till ownership bit will be changed */
+                        do
+                        {
+                            extMemHdr = HW_MBOX_REG32_READ(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(sramMsg.offset) - sizeof(hwMbox_extMemCtrlHdr_t));
+                            DPRINTK("cid %d: entering reading loop on header at ext mem offset=%x (current value 0x%08x)...",
+                                    paramCID, sramMsg.offset - sizeof(hwMbox_extMemCtrlHdr_t), extMemHdr);
+
+                        } while ( (HW_MBOX_MID == CHN_CFG_GET_COMMANDER(paramCID)) ? (!HW_MBOX_EXTMEM_IS_COMMANDER_OWNER(extMemHdr) /* Loop until the commander the owner */)
+                                                                                   : (!HW_MBOX_EXTMEM_IS_SUBJECT_OWNER(extMemHdr) /* Loop until the subject the owner */) );
+
+                        DPRINTK("cid %d: exited from reading loop...", paramCID);
+                    }
+
+                    if (sramMsg.lenInBytes > 0)
+                    {
+                        switch (userOrKernel)
+                        {
+                            case HW_MBOX_COPY_USER:
+                                if (HW_MBOX_USER_COPY_FROM_EXTMEM(sramMsg.offset, sramMsg.lenInBytes, dataBuf))
+                                {
+                                    *pHwMboxStatus = HW_MBOX_STATUS_OPCODE_ERROR;
+
+                                    return -ENOMEM;
+                                }
+                                break;
+
+                            case HW_MBOX_COPY_KERNEL:
+                                HW_MBOX_COPY_FROM_EXTMEM(sramMsg.offset, sramMsg.lenInBytes, dataBuf);
+                                break;
+
+                            default:
+                                return -EINVAL;
+                        }
+
+                        /* erase ExtMem if eraseMemAfter flag is set */
+                        if (eraseMemAfter)
+                        {
+                            HW_MBOX_RESET_EXTMEM(sramMsg.offset, sramMsg.lenInBytes);
+                        }
+                    }
+
+                    DPRINTK("cid %d: AFTER copying %uB from ext memory at offset=0x%08x",
+                            paramCID, dataLen, sramMsg.offset);
+
+                    /* overwrite retVal with len of EXTMEM message size */
+                    retVal = sramMsg.lenInBytes;
+                }
+                else
+#endif /* HW_MBOX_EXTENDED_MEMORY */
+                {
+                    switch (userOrKernel)
+                    {
+                        case HW_MBOX_COPY_USER:
+                            if (HW_MBOX_USER_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID), dataLen, dataBuf))
+                            {
+                                *pHwMboxStatus =  HW_MBOX_STATUS_OPCODE_ERROR;
+
+                                return -ENOMEM;
+                            }
+                            break;
+
+                        case HW_MBOX_COPY_KERNEL:
+                            HW_MBOX_COPY_FROM_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID), dataLen, dataBuf);
+                            break;
+
+                        default:
+                            return -EINVAL;
+                    }
+                }
+            }
+        }
+    }
+    else
+    {
+        /* other except COMMAND and OPCODE protocols are not supported */
+        return -EINVAL;
+    }
+
+    if (eraseMemAfter)
+    {
+        HW_MBOX_RESET_SRAM(CHN_CFG_MEMBUFF_GET_START(paramCID), CHN_CFG_MEMBUFF_GET_SIZE(paramCID));    /* TBD: or dataLen? */
+    }
+
+    return retVal;
+}
+
+/**************************************************************************/
+/*! \fn int hwMbox_recvReplyMsg(hw_mbox_Masters_e subject, Uint32 paramAppID,
+                                Uint8 *dataBuf, Uint32 dataLen,
+                                Uint32 userOrKernel,
+                                Uint32 eraseMemAfter)
+ **************************************************************************
+ *  \brief wait for reply from subject, read it and unlock channel.
+ *  \return [ received bytes on success / -1 on error ].
+ **************************************************************************/
+static int hwMbox_recvReplyMsg(hw_mbox_Masters_e subject, Uint32 paramAppID,
+                               Uint8 *dataBuf, Uint32 dataLen,
+                               Uint32 userOrKernel,
+                               Uint32 eraseMemAfter)
+{
+    Uint32 paramCID;
+    Int32 retVal;
+    HW_MBOX_STATUS_e HwMboxStatus;
+
+    CHECK_IS_DRV_INITIALIZED(return (-1));
+
+    if (!IS_MASTER_INIT(subject))
+    {
+        DPRINTK("master %s(%d) is not initialized!",
+                HW_MBOX_MASTER_GET_NAME(subject), subject);
+        return -EHOSTDOWN;
+    }
+
+    CHECK_FIND_CID_IN_LUT(subject,
+                          HW_MBOX_PROTOCOL_BY_APPID(paramAppID),
+                          CID_LUT_PEER_IS_SUBJECT,
+                          return -EHOSTUNREACH,
+                          paramCID);
+
+    /* We should always use the channel's WQ: */
+    DPRINTK("cid %d: before WAIT_FOR_CHN_INTR sem=%d", paramCID, CHN_LOCK(paramCID).count);
+    WAIT_FOR_CHN_INTR(paramCID, CHN_INTR_DEFAULT_TIMEOUT_MSEC);
+
+    retVal = _hwMbox_RecvMsg(paramCID,
+                             paramAppID,
+                             dataBuf,
+                             dataLen,
+                             userOrKernel,
+                             eraseMemAfter,
+                             &HwMboxStatus);
+
+    STATS_INC_COUNTER(subject,
+                      HW_MBOX_PROTOCOL_BY_APPID(paramAppID),
+                      STATS_PEER_IS_SUBJECT);
+
+    /* release lock */
+    up(&CHN_LOCK(paramCID));
+
+    return retVal;
+}
+
+/**************************************************************************/
+/*! \fn int hwMbox_recvCmdMsg(hw_mbox_Masters_e commander, Uint32 paramAppID,
+                              Uint8 *dataBuf, Uint32 dataLen,
+                              Uint32 userOrKernel,
+                              Uint32 eraseMemAfter)
+ **************************************************************************
+ *  \brief receive command message from commander.
+ *  \note first waits on channel's WQ if it is required.
+ *  \return [ received bytes on success / -1 on error ].
+ **************************************************************************/
+static int hwMbox_recvCmdMsg(hw_mbox_Masters_e commander, Uint32 paramAppID,
+                             Uint8 *dataBuf, Uint32 dataLen,
+                             Uint32 userOrKernel,
+                             Uint32 eraseMemAfter)
+{
+    Uint32 paramCID;
+    Int32 retVal;
+    hw_mbox_type_e paramProto;
+    HW_MBOX_STATUS_e hwMboxStatus = HW_MBOX_STATUS_OK;
+
+    CHECK_IS_DRV_INITIALIZED(return -ENETDOWN);
+
+    paramProto = HW_MBOX_PROTOCOL_BY_APPID(paramAppID);
+
+    CHECK_FIND_CID_IN_LUT(commander,
+                          paramProto,
+                          CID_LUT_PEER_IS_COMMANDER,
+                          return -EHOSTUNREACH,
+                          paramCID);
+
+    if ( !(CHN_IS_RECV_OP(paramCID) && (HW_MBOX_COPY_USER == userOrKernel)) )
+    {
+        /* Any case not socket and recvOpcode should use the channel's WQ.
+           Subject opcode sockets should use their own WQ.
+        */
+        DPRINTK("cid %d: before WAIT_FOR_CHN_INTR", paramCID);
+        WAIT_FOR_CHN_INTR(paramCID, CHN_INTR_NO_TIMEOUT);
+    }
+
+    retVal = _hwMbox_RecvMsg(paramCID,
+                             paramAppID,
+                             dataBuf,
+                             dataLen,
+                             userOrKernel,
+                             eraseMemAfter,
+                             &hwMboxStatus);
+
+    if (hw_mbox_command == paramProto)
+    {
+        /* Increment the counters only for command,
+           for opcode the Listener does it...
+        */
+        STATS_INC_COUNTER(commander,
+                          HW_MBOX_PROTOCOL_BY_APPID(paramAppID),
+                          STATS_PEER_IS_COMMANDER);
+    }
+
+    if ((hw_mbox_opcode == paramProto) && (retVal < 0))
+    {
+        if (hwMboxStatus != HW_MBOX_STATUS_OK)
+        {
+            /* Send internal opcode message to commander */
+            _hwMbox_sendOpcodeMsg(paramCID, hwMboxStatus);
+        }
+    }
+
+    return retVal;
+}
+
+static int hwMbox_RecvEvent(hw_mbox_Masters_e paramMID, Uint32 paramAppID, Uint8 *dataBuf, Uint32 dataLen, Uint32 userOrKernel, Uint32 eraseMemAfter)
+{
+    /* TBD */
+    return -EPROTONOSUPPORT;
+}
+
+#ifdef HW_MBOX_SOCKETS_API
+/**************************************************************************/
+/*! \fn int hwMbox_socketRecvOpCb(hw_mbox_Masters_e commander, Uint8 *dataBuf,
+ *                                Uint32 dataLen, Uint32 *token)
+ **************************************************************************
+ *  \brief recvOp callback function used for sockets.
+ *  \return [ 0 on success / -1 on error ].
+ **************************************************************************/
+static int hwMbox_socketRecvOpCb(hw_mbox_Masters_e commander, Uint8 *dataBuf,
+                                 Uint32 dataLen, Uint32 *token)
+{
+    struct socket *sock = NULL;
+    struct hwMbox_sock *sk;
+
+    if (!token)
+    {
+        PRINTK_ERR("token is NULL!");
+        return (-1);
+    }
+
+    sock = (struct socket *)(*token);
+    if ((sock) && (sk = hwMbox_sk(sock->sk)))
+    {
+        if (sock->wq)
+        {
+            DPRINTK_SKT(sock, "before trigger: chnIntr=%d", sk->chnIntr);
+            sk->chnIntr = (__s32)CHN_INTR_STATE_PENDING;
+            wake_up_interruptible(&sock->wq->wait);
+            DPRINTK_SKT(sock, "after trigger: chnIntr=%d", sk->chnIntr);
+        }
+    }
+    else
+    {
+        PRINTK_ERR("NULL pointer! [sock=%p]", sock);
+    }
+
+    return 0;
+}
+
+/************************************************************************/
+/*     AF_HWMBOX socket family functions                                */
+/************************************************************************/
+
+/**************************************************************************/
+/*! \fn int hwMbox_socket_create(struct net *net, struct socket *sock,
+ *                               int protocol, int kern)
+ **************************************************************************
+ *  \brief AF_HWMBOX socket family socket() handler.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+static int hwMbox_socket_create(struct net *net, struct socket *sock,
+                                int protocol, int kern)
+{
+    struct hwMbox_sock *sk = NULL;
+
+    CHECK_IS_DRV_INITIALIZED(return (-ENETDOWN));
+
+    /* two types of socket are supported */
+    if ((SOCK_COMMANDER != sock->type) && (SOCK_SUBJECT != sock->type))
+    {
+        return -ESOCKTNOSUPPORT;
+    }
+
+    /* kernel sockets are not supported yet */
+    if (kern)
+    {
+        return -EPFNOSUPPORT;
+    }
+
+    /* protocol is defined via appid */
+    if (protocol != 0)
+    {
+        return -EPROTONOSUPPORT;
+    }
+
+    sk = hwMbox_sk(sk_alloc(net, PF_HWMBOX, GFP_ATOMIC, &hwMbox_proto));
+    if (sk == NULL)
+    {
+        return -ENOMEM;
+    }
+
+    sock_init_data(sock, (struct sock *)sk);
+
+    sock->ops = &hwMbox_proto_ops;
+
+    /* initialize the state */
+    sock->state = (socket_state)HW_MBOX_SOCK_STATE_CREATED;
+
+    /* set invalid initial mid value with typecast,
+       it will be used later to test is socket was bound already or not... */
+    sk->mid   = (__typeof__(sk->mid)) HW_MBOX_MID_INVALID;
+
+    /* initialize the chnIntr: */
+    sk->chnIntr = (__s32)CHN_INTR_STATE_NONE;
+
+    /* store pid of creator */
+    sk->owner_pid = current->pid;
+
+    /* zero stat */
+    sk->stat.sent_cnt = 0;
+    sk->stat.sent_bytes = 0;
+    sk->stat.recv_cnt = 0;
+    sk->stat.recv_bytes = 0;
+
+    /* add socket to hwMbox_sock_hlist */
+    if (down_interruptible(&hwMbox_sock_hlist_sem))
+    {
+        return -ERESTARTSYS;
+    }
+
+    hlist_add_head(&sock->sk->sk_node, &hwMbox_sock_hlist);
+
+    up(&hwMbox_sock_hlist_sem);
+
+    return 0;
+}
+
+/**************************************************************************/
+/*! \fn int hwMbox_socket_bind(struct socket *sock, struct sockaddr *uaddr,
+ *                             int addr_len)
+ **************************************************************************
+ *  \brief AF_HWMBOX socket family bind() handler.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+static int hwMbox_socket_bind(struct socket *sock, struct sockaddr *uaddr,
+                              int addr_len)
+{
+    struct sockaddr_hwMbox *addr = (struct sockaddr_hwMbox *)uaddr;
+    struct hwMbox_sock *sk;
+
+    hw_mbox_type_e paramProto;
+    Uint32 paramCID;
+
+    if (!(sk = hwMbox_sk(sock->sk)))
+    {
+        PRINTK_ERR("NULL pointer! [sk=%p]", sk);
+        return -EFAULT;
+    }
+
+    if (addr->shwMbox_family != AF_HWMBOX)
+    {
+        return -EINVAL;
+    }
+
+    if (addr_len != sizeof(struct sockaddr_hwMbox))
+    {
+        return -EINVAL;
+    }
+
+    /* multiple bind() calls not allowed */
+    if (HW_MBOX_MID_VALIDITY_CHECK(sk->mid))
+    {
+        return -EOPNOTSUPP;
+    }
+
+    if (!HW_MBOX_MID_VALIDITY_CHECK(addr->shwMbox_mid))
+    {
+        return -EADDRNOTAVAIL;
+    }
+
+    if (!HW_MBOX_SOCKETS_APPID_VALIDITY_CHECK(addr->shwMbox_appid))
+    {
+        return -EADDRNOTAVAIL;
+    }
+
+    paramProto = HW_MBOX_PROTOCOL_BY_APPID(addr->shwMbox_appid);
+
+    CHECK_FIND_CID_IN_LUT(addr->shwMbox_mid,
+                          paramProto,
+                          (SOCK_COMMANDER == sock->type) ? CID_LUT_PEER_IS_SUBJECT
+                                                         : CID_LUT_PEER_IS_COMMANDER,
+                          return (-EHOSTUNREACH),
+                          paramCID);
+
+    if (SOCK_COMMANDER == sock->type)
+    {
+        if (!IS_MASTER_INIT(addr->shwMbox_mid))
+        {
+            DPRINTK("master %s(%d) is not initialized!",
+                    HW_MBOX_MASTER_GET_NAME(addr->shwMbox_mid), addr->shwMbox_mid);
+            return -EHOSTDOWN;
+        }
+
+        /* event proto for COMMANDER is not available */
+        if (hw_mbox_event == paramProto)
+        {
+            return -EPROTONOSUPPORT;
+        }
+    }
+
+    if ( (SOCK_SUBJECT == sock->type) &&
+         (hw_mbox_opcode == paramProto) )
+    {
+        /* register callback function for the tag with token equal to address of socket: */
+        if (hwMbox_registerRecvOpcode(addr->shwMbox_mid, hwMbox_socketRecvOpCb, addr->shwMbox_appid, (Uint32)sock))
+        {
+            return -EADDRINUSE;
+        }
+    }
+
+    sk->appid = addr->shwMbox_appid;
+    sk->mid   = addr->shwMbox_mid;
+    sk->cid   = paramCID;
+
+    sock->state = HW_MBOX_SOCK_STATE_BOUND;
+
+    return 0;
+}
+
+/**************************************************************************/
+/*! \fn int hwMbox_socket_sendmsg(struct kiocb *kiocb, struct socket *sock,
+ *                                struct msghdr *msg, size_t len)
+ **************************************************************************
+ *  \brief AF_HWMBOX socket family send() handler.
+ *  \return [ amount of bytes sent on success / error otherwise ].
+ **************************************************************************/
+static int hwMbox_socket_sendmsg(struct kiocb *kiocb, struct socket *sock,
+                                 struct msghdr *msg, size_t len)
+{
+    struct hwMbox_sock *sk;
+    Uint8 *pUserBuf = (Uint8 *)msg->msg_iov->iov_base;
+    Int32 retVal = 0;
+
+    hw_mbox_type_e paramProto;
+
+    DPRINTK_SKT(sock, "Enter sendmsg()...");
+
+    if (!(sk = hwMbox_sk(sock->sk)))
+    {
+        PRINTK_ERR("NULL pointer! [sk=%p]", sk);
+        return -EFAULT;
+    }
+
+    /* socket is not bound */
+    if (!HW_MBOX_MID_VALIDITY_CHECK(sk->mid))
+    {
+        return -EOPNOTSUPP;
+    }
+
+    /* vectored IO not supported */
+    if (msg->msg_iovlen > 1)
+    {
+        return -EOPNOTSUPP;
+    }
+
+    paramProto = HW_MBOX_PROTOCOL_BY_APPID(sk->appid);
+
+    DPRINTK_SKT(sock,
+                "type=%d, mid=%d, appId=%d, proto=%d, cid=%d",
+                sock->type, sk->mid, sk->appid, paramProto, sk->cid);
+
+    sock->state = HW_MBOX_SOCK_STATE_SENDING;
+    DPRINTK_SKT(sock, "new socket state: %d", sock->state);
+
+    /* only command and opcode protocols are supported at the moment... */
+    if ((paramProto != hw_mbox_command) && (paramProto != hw_mbox_opcode))
+    {
+        return -EPROTONOSUPPORT;
+    }
+
+    if (SOCK_COMMANDER == sock->type)
+    {
+        retVal = hwMbox_sendCmdMsg(sk->mid, sk->appid, pUserBuf, len, HW_MBOX_COPY_USER);
+    }
+    else if (SOCK_SUBJECT == sock->type)
+    {
+        retVal = hwMbox_sendReplyMsg(sk->mid, sk->appid, pUserBuf, len, HW_MBOX_COPY_USER);
+    }
+    else
+    {
+        return -ESOCKTNOSUPPORT;
+    }
+
+    if (retVal >= 0)
+    {
+        sock->state = HW_MBOX_SOCK_STATE_SENT;
+    }
+    else
+    {
+        sock->state = HW_MBOX_SOCK_STATE_SEND_ERROR;
+    }
+    DPRINTK_SKT(sock, "new socket state: %d", sock->state);
+
+    sk->stat.sent_cnt++;
+
+    if (retVal > 0)
+    {
+        sk->stat.sent_bytes += len;
+    }
+
+    return retVal;
+}
+
+/**************************************************************************/
+/*! \fn int hwMbox_socket_recvmsg(struct kiocb *kiocb, struct socket *sock,
+                                  struct msghdr *msg, size_t len, int flags)
+ **************************************************************************
+ *  \brief AF_HWMBOX socket family recv() handler.
+ *  \return [ amount of bytes received on success / error otherwise ].
+ **************************************************************************/
+static int hwMbox_socket_recvmsg(struct kiocb *kiocb, struct socket *sock,
+                                 struct msghdr *msg, size_t len, int flags)
+{
+    struct hwMbox_sock *sk;
+    Uint8 *pUserBuf = (Uint8 *)msg->msg_iov->iov_base;
+    Uint32 eraseMemAfter = flags & MSG_TRUNC;
+    Int32 retVal = 0;
+
+    hw_mbox_type_e paramProto;
+
+    DPRINTK_SKT(sock, "Enter recvmsg()...");
+
+    if (!(sk = hwMbox_sk(sock->sk)))
+    {
+        PRINTK_ERR("NULL pointer! [sk=%p]", sk);
+        return -EFAULT;
+    }
+
+    /* socket is not bound */
+    if (!HW_MBOX_MID_VALIDITY_CHECK(sk->mid))
+    {
+        return -EOPNOTSUPP;
+    }
+
+    if (!HW_MBOX_SOCKETS_APPID_VALIDITY_CHECK(sk->appid))
+    {
+        return -EADDRNOTAVAIL;
+    }
+
+    /* vectored IO not supported */
+    if (msg->msg_iovlen > 1)
+    {
+        return -EOPNOTSUPP;
+    }
+
+    paramProto = HW_MBOX_PROTOCOL_BY_APPID(sk->appid);
+
+    DPRINTK_SKT(sock,
+                "type=%d, mid=%d, appId=%d, proto=%d, cid=%d",
+                sock->type, sk->mid, sk->appid, paramProto, sk->cid);
+
+    sock->state = HW_MBOX_SOCK_STATE_RECEIVING;
+    DPRINTK_SKT(sock, "new socket state: %d", sock->state);
+
+    if (SOCK_COMMANDER == sock->type)
+    {
+        /* Commanders recv reply from subjects: */
+
+        if (hw_mbox_command == paramProto)
+        {
+            /* For command commander we should wait on channel's wq [with timeout]...
+               [inside hwMbox_recvReplyMsg]
+            */
+            retVal = hwMbox_recvReplyMsg(sk->mid, sk->appid, pUserBuf, len, HW_MBOX_COPY_USER, eraseMemAfter);
+        }
+        else if (hw_mbox_opcode == paramProto)
+        {
+            /* For opcode commander we should wait on channel's wq [with timeout]...
+               [inside hwMbox_recvReplyMsg]
+            */
+            retVal = hwMbox_recvReplyMsg(sk->mid, sk->appid, pUserBuf, len, HW_MBOX_COPY_USER, eraseMemAfter);
+        }
+        else
+        {
+            /* for commander socket only command and opcode
+               protocols are supported... */
+            return -EPROTONOSUPPORT;
+        }
+    }
+    else if (SOCK_SUBJECT == sock->type)
+    {
+        /* Subjects recv cmd from commanders: */
+
+        if (hw_mbox_command == paramProto)
+        {
+            /* For command subject we should wait on channel's wq [without timeout]...
+               [inside hwMbox_recvCmdMsg]
+            */
+            retVal = hwMbox_recvCmdMsg(sk->mid, sk->appid, pUserBuf, len, HW_MBOX_COPY_USER, eraseMemAfter);
+        }
+        else if (hw_mbox_opcode == paramProto)
+        {
+            DPRINTK_SKT(sock, "before wait on socket's WQ [&sock->wq->wait=0x%p, chnIntr=%d]",
+                        &sock->wq->wait, sk->chnIntr);
+            if (wait_event_interruptible(sock->wq->wait, CHN_INTR_STATE_PENDING == (chnIntrState_e)sk->chnIntr))
+            {
+                DPRINTK_SKT(sock, "recvmsg() interrupted by signal while waiting on socket's WQ...");
+                return -ECONNABORTED;
+            }
+            DPRINTK_SKT(sock, "after wait on socket's WQ...");
+
+            DPRINTK_SKT(sock, "before clear: chnIntr=%d", sk->chnIntr);
+            sk->chnIntr = (__s32)CHN_INTR_STATE_NONE;
+            DPRINTK_SKT(sock, "after clear: chnIntr=%d", sk->chnIntr);
+
+            /* Now we can receive... */
+            retVal = hwMbox_recvCmdMsg(sk->mid, sk->appid, pUserBuf, len, HW_MBOX_COPY_USER, eraseMemAfter);
+        }
+        else if (hw_mbox_event == paramProto)
+        {
+            /* event proto */
+            retVal = hwMbox_RecvEvent(sk->mid, sk->appid, pUserBuf, len, HW_MBOX_COPY_USER, eraseMemAfter);
+        }
+        else
+        {
+            return -EPROTONOSUPPORT;
+        }
+    }
+    else
+    {
+        return -ESOCKTNOSUPPORT;
+    }
+
+    sk->stat.recv_cnt++;
+
+    if (retVal > 0)
+    {
+        sk->stat.recv_bytes += retVal;
+    }
+
+    return retVal;
+}
+
+/**************************************************************************/
+/*! \fn int hwMbox_socket_release(struct socket *sock)
+ **************************************************************************
+ *  \brief AF_HWMBOX socket family release() handler.
+ *  \return [ 0 ].
+ **************************************************************************/
+static int hwMbox_socket_release(struct socket *sock)
+{
+    struct hwMbox_sock *sk = hwMbox_sk(sock->sk);
+
+    if (sk)
+    {
+        /* unregister our callback function for SUBJECT-OPCODE protocol */
+        if ( (SOCK_SUBJECT == sock->type) &&
+             (hw_mbox_opcode == HW_MBOX_PROTOCOL_BY_APPID(sk->appid)) &&
+             HW_MBOX_MID_VALIDITY_CHECK(sk->mid) )
+        {
+            DPRINTK_SKT(sock, "unregistering socket's recvOpcode callback...");
+
+            if (hwMbox_unregisterRecvOpcode(sk->mid, sk->appid))
+            {
+                PRINTK_ERR("failed to unregister socket's recvOpcode callback for tag=%u from %s(%d)!",
+                           sk->appid, HW_MBOX_MASTER_GET_NAME(sk->mid), sk->mid);
+            }
+        }
+
+        if (down_interruptible(&hwMbox_sock_hlist_sem))
+        {
+            return -ERESTARTSYS;
+        }
+
+        hlist_del_init(&sock->sk->sk_node);
+
+        up(&hwMbox_sock_hlist_sem);
+
+        sock->sk = NULL;
+        lock_sock((struct sock *)sk);
+        release_sock((struct sock *)sk);
+        sock_put((struct sock *)sk);
+    }
+
+    return 0;
+}
+#endif /* HW_MBOX_SOCKETS_API */
+
+#ifdef HW_MBOX_SOCKETS_API
+/************************************************************************/
+/*     HW_MBOX socket API data                                          */
+/************************************************************************/
+
+static struct proto hwMbox_proto = {
+    .name       = "HWMBOX",
+    .owner      = THIS_MODULE,
+    .obj_size   = sizeof(struct hwMbox_sock),
+};
+
+static const struct net_proto_family hwMbox_family_ops = {
+    .family     = PF_HWMBOX,
+    .create     = hwMbox_socket_create,
+    .owner      = THIS_MODULE,
+};
+
+static const struct proto_ops hwMbox_proto_ops = {
+    .family     = PF_HWMBOX,
+    .owner      = THIS_MODULE,
+    .release    = hwMbox_socket_release,
+    .bind       = hwMbox_socket_bind,
+    .sendmsg    = hwMbox_socket_sendmsg,
+    .recvmsg    = hwMbox_socket_recvmsg,
+    .connect    = sock_no_connect,
+    .socketpair = sock_no_socketpair,
+    .accept     = sock_no_accept,
+    .getname    = sock_no_getname,
+    .poll       = sock_no_poll,
+    .ioctl      = sock_no_ioctl,
+    .listen     = sock_no_listen,
+    .shutdown   = sock_no_shutdown,
+    .setsockopt = sock_no_setsockopt,
+    .getsockopt = sock_no_getsockopt,
+    .mmap       = sock_no_mmap,
+    .sendpage   = sock_no_sendpage,
+};
+#endif /* HW_MBOX_SOCKETS_API */
+
+subsys_initcall(hwMbox_drv_init);
+module_exit(hwMbox_drv_exit);
+
+/* Driver identification: */
+#ifdef HW_MBOX_SOCKETS_API
+MODULE_ALIAS_NETPROTO(PF_HWMBOX);
+#endif /* HW_MBOX_SOCKETS_API */
 
-/* Driver identification: */
 MODULE_DESCRIPTION(DRV_NAME);
 MODULE_VERSION(DRV_VERSION);
 MODULE_AUTHOR ("Intel Corporation");
--- a/arch/x86/hw_mailbox/hw_mbox_mem_access.h
+++ b/arch/x86/hw_mailbox/hw_mbox_mem_access.h
@@ -36,7 +36,7 @@
 
   BSD LICENSE
 
-  Copyright(c) 2014-2015 Intel Corporation. All rights reserved.
+  Copyright(c) 2014-2016 Intel Corporation. All rights reserved.
 
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
@@ -76,7 +76,11 @@
 ************************************/
 
 /* Include Always: */
-#include <linux/hw_mbox_defs.h>   /* for HW_MBOX_MID, HW_MBOX_CONCAT and Generic types */
+#ifndef HW_MBOX_IS_APP_CPU
+#include "hw_mbox_defs.h"          /* for HW_MBOX_MID, HW_MBOX_CONCAT and Generic types */
+#else
+#include <linux/hw_mbox_defs.h>    /* for HW_MBOX_MID, HW_MBOX_CONCAT and Generic types */
+#endif
 
 /* The following Included files are Determined Accordingly to OS and Master: */
 
@@ -853,6 +857,22 @@ static inline Uint32 hw_mbox_field32_set
 #define HW_MBOX_BASE    (0)
 #endif
 
+#ifdef HW_MBOX_EXTENDED_MEMORY
+#define HW_MBOX_EXTMEM_TOTAL_SIZE       0x2000
+#define HW_MBOX_EXTMEM_PART_SIZE        (HW_MBOX_EXTMEM_TOTAL_SIZE >> 1)
+#define HW_MBOX_EXTMEM_PART_A_OFFSET    0
+#define HW_MBOX_EXTMEM_PART_B_OFFSET    HW_MBOX_EXTMEM_PART_SIZE
+
+/* Define HW_MBOX EXT memory address here: */
+#if defined HW_MBOX_IS_NP_CPU
+#define HW_MBOX_EXTMEM_BASE         AVALANCHE_SRAM_BASE
+#elif defined HW_MBOX_IS_APP_CPU
+/* App-CPU Kernel determines extended memory Base address at runtime, driver should
+   define HW_MBOX_EXTMEM_BASE as a variable that holds this mapped base address. */
+#endif
+
+#endif /* HW_MBOX_EXTENDED_MEMORY */
+
 /******************************************************************************
 |       Generic Low Level Mem Access Macro Templates For Direct Access:       |
 ******************************************************************************/
@@ -873,12 +893,25 @@ static inline Uint32 hw_mbox_field32_set
 #define HW_MBOX_BIT_SET_VALUE(regOffset, bitPosition, bitVal)    HW_MBOX_REG_SET(regOffset,                                            \
                                                                                  hw_mbox_field32_set(HW_MBOX_REG_GET(regOffset),       \
                                                                                                      bitPosition, 1, bitVal))
-/* SRAM ACCESS: */
 
-#define HW_MBOX_POINTER_TO_SRAM(sramOffset)                              ((Uint8 *)(HW_MBOX_MEMDEFS_SRAM_OFFSET(sramOffset) + HW_MBOX_BASE))
-#define HW_MBOX_COPY_FROM_SRAM(srcSramOffset, srcSramLen, pDestBuffer)   memcpy(pDestBuffer, HW_MBOX_POINTER_TO_SRAM(srcSramOffset), srcSramLen)
-#define HW_MBOX_COPY_TO_SRAM(pSrcBuffer, srcBufferLen, destSramOffset)   memcpy(HW_MBOX_POINTER_TO_SRAM(destSramOffset), pSrcBuffer, srcBufferLen)
-#define HW_MBOX_RESET_SRAM(sramOffset, sramLen)                          memset(HW_MBOX_POINTER_TO_SRAM(sramOffset), 0, sramLen)
+#define HW_MBOX_POINTER_TO(address)                                             ((Uint8 *)(address))
+#define HW_MBOX_COPY_FROM_ADDR(srcAddr, srcAddrLen, pDestBuffer)                memcpy(pDestBuffer, srcAddr, srcAddrLen)
+#define HW_MBOX_COPY_TO_ADDR(pSrcBuffer, srcBufferLen, destAddr)                memcpy(destAddr, pSrcBuffer, srcBufferLen)
+#define HW_MBOX_RESET_MEM(pMem, memLen)                                         memset(pMem, 0, memLen)
+
+/* SRAM Memory ACCESS: */
+#define HW_MBOX_POINTER_TO_SRAM(sramOffset)                                     HW_MBOX_POINTER_TO(HW_MBOX_MEMDEFS_SRAM_OFFSET(sramOffset) + HW_MBOX_BASE)
+#define HW_MBOX_COPY_FROM_SRAM(srcSramOffset, srcSramLen, pDestBuffer)          HW_MBOX_COPY_FROM_ADDR(HW_MBOX_POINTER_TO_SRAM(srcSramOffset), srcSramLen, pDestBuffer)
+#define HW_MBOX_COPY_TO_SRAM(pSrcBuffer, srcBufferLen, destSramOffset)          HW_MBOX_COPY_TO_ADDR(pSrcBuffer, srcBufferLen, HW_MBOX_POINTER_TO_SRAM(destSramOffset))
+#define HW_MBOX_RESET_SRAM(sramOffset, sramLen)                                 HW_MBOX_RESET_MEM(HW_MBOX_POINTER_TO_SRAM(sramOffset), sramLen)
+
+#ifdef HW_MBOX_EXTENDED_MEMORY
+#define HW_MBOX_EXTMEM_ADDR_BY_OFFSET(extMemOffset)                             ( HW_MBOX_EXTMEM_BASE + extMemOffset )
+#define HW_MBOX_POINTER_TO_EXTMEM(extMemOffset)                                 HW_MBOX_POINTER_TO(HW_MBOX_EXTMEM_ADDR_BY_OFFSET(extMemOffset))
+#define HW_MBOX_COPY_FROM_EXTMEM(srcExtmemOffset, srcExtmemLen, pDestBuffer)    HW_MBOX_COPY_FROM_ADDR(HW_MBOX_POINTER_TO_EXTMEM(srcExtmemOffset), srcExtmemLen, pDestBuffer)
+#define HW_MBOX_COPY_TO_EXTMEM(pSrcBuffer, srcBufferLen, destExtmemOffset)      HW_MBOX_COPY_TO_ADDR(pSrcBuffer, srcBufferLen, HW_MBOX_POINTER_TO_EXTMEM(destExtmemOffset))
+#define HW_MBOX_RESET_EXTMEM(extMemOffset, extMemLen)                           HW_MBOX_RESET_MEM(HW_MBOX_POINTER_TO_EXTMEM(extMemOffset), extMemLen)
+#endif /* HW_MBOX_EXTENDED_MEMORY */
 
 #endif /* ((defined(HW_MBOX_OS_LINUX) && defined(__KERNEL__)) || defined(HW_MBOX_OS_FLAT) || defined(HW_MBOX_OS_NONE)) */
 
--- a/include/linux/hw_mailbox.h
+++ b/include/linux/hw_mailbox.h
@@ -35,7 +35,7 @@
 
   BSD LICENSE
 
-  Copyright(c) 2015 Intel Corporation. All rights reserved.
+  Copyright(c) 2015-2016 Intel Corporation. All rights reserved.
 
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
@@ -88,6 +88,25 @@
 int hwMbox_isReady(void);
 
 /**************************************************************************/
+/*! \fn int hwMbox_getChannelConfig(hw_mbox_Masters_e peer,
+                                    hw_mbox_type_e mboxType,
+                                    Bool isPeerCommander,
+                                    hw_mbox_channelConfig_t *cfg)
+ **************************************************************************
+ *  \brief Get channel configuration.
+ *  \param[in] peer - channel peer .
+ *  \param[in] mboxType - channel type.
+ *  \param[in] isPeerCommander - indicates whether the peer is the commander
+ *                               of the channel.
+ *  \param[out] cfg - channel configuration, if found.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_getChannelConfig(hw_mbox_Masters_e peer,
+                            hw_mbox_type_e mboxType,
+                            Bool isPeerCommander,
+                            hw_mbox_channelConfig_t *cfg);
+
+/**************************************************************************/
 /*! \fn int hwMbox_sendCommand(hw_mbox_Masters_e subject,
                                Uint32 *cmd,
                                Uint8 *dataBuf, Uint32 dataLen)
@@ -243,6 +262,17 @@ int hwMbox_registerRecvOpcode(hw_mbox_Ma
                               hwMboxRecvOpcodeCallback pOpcodeCallbackFunc,
                               Uint32 tag,
                               Uint32 token);
+
+/**************************************************************************/
+/*! \fn int hwMbox_unregisterRecvOpcode(hw_mbox_Masters_e commander, Uint32 tag)
+ **************************************************************************
+ *  \brief Unregister Receive Opcode from <commander> using the HW_MBOX.
+ *  \attention This function should be called once per tag.
+ *  \param[in] commander - From which Master should the opcode be received.
+ *  \param[in] tag - indicates the destination.
+ *  \return [ 0 on success / error otherwise ].
+ **************************************************************************/
+int hwMbox_unregisterRecvOpcode(hw_mbox_Masters_e commander, Uint32 tag);
 #endif /* __KERNEL__ */
 /* IOCTL commands:
 
--- a/include/linux/hw_mbox_defs.h
+++ b/include/linux/hw_mbox_defs.h
@@ -35,7 +35,7 @@
 
   BSD LICENSE
 
-  Copyright(c) 2014-2015 Intel Corporation. All rights reserved.
+  Copyright(c) 2014-2016 Intel Corporation. All rights reserved.
 
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
@@ -190,6 +190,20 @@
 */
 //#define HW_MBOX_DEBUG
 
+/** --------------------------------------- **/
+
+/*! \def HW_MBOX_SOCKETS_API
+    \brief Enable AF_HWMBOX socket family support.
+*/
+#define HW_MBOX_SOCKETS_API
+
+/** --------------------------------------- **/
+
+/*! \def HW_MBOX_EXTENDED_MEMORY
+    \brief Enable usage of extended memory.
+*/
+#define HW_MBOX_EXTENDED_MEMORY
+
 /******************************************************
 |                                                     |
 |        HW_MBOX Specific Master Configuration        |
@@ -660,6 +674,12 @@ typedef struct hwMbox_opcode
     \brief Max value available for tag field when using OPCODE. */
 #define HW_MBOX_OPCODE_TAG_MAX_VALUE    (BIT(HW_MBOX_OPCODE_TAG_BITLEN) - 1)
 
+#ifdef HW_MBOX_SOCKETS_API
+/*! \def HW_MBOX_TAG_INVALID
+    \brief Value that indicates invalid TAG. */
+#define HW_MBOX_TAG_INVALID             0xFFFFFFFF
+#endif /* HW_MBOX_SOCKETS_API */
+
 /* Reserved HW MBOX TAGs: */
 
 #define HW_MBOX_OPCODE_RESERVED_TAGS_START    0xFF0 /*! First Reserved TAG value for HW MBOX */
@@ -702,6 +722,25 @@ typedef enum hwMbox_opcodeReservedTags
 */
 typedef Uint8 __hwMbox_reservedOpcodesEnumExceededAllowedSize[HW_MBOX_OPCODE_TAG_MAX_VALUE - HW_MBOX_RESERVED_OPCODE_LAST];
 
+/*! \enum hwMbox_appId_e
+    \brief This enum denotes HW MBOX APP IDs.
+*/
+typedef enum hwMbox_appId
+{
+    HW_MBOX_APPID_MIN_VALUE  = 0,
+    HW_MBOX_APPID_OPCODE_MIN = HW_MBOX_APPID_MIN_VALUE,
+    /* Opcode Tags... */
+    HW_MBOX_APPID_OPCODE_MAX = HW_MBOX_OPCODE_TAG_MAX_VALUE,
+    /* Other Protocols: */
+    HW_MBOX_APPID_COMMAND,
+    HW_MBOX_APPID_EVENT,
+
+    /* Don't add any values after this line!!! */
+    HW_MBOX_APPID_ONE_AFTER_LAST,
+    HW_MBOX_APPID_LAST = (HW_MBOX_APPID_ONE_AFTER_LAST - 1),
+    HW_MBOX_APPID_MAX_VALUE = HW_MBOX_APPID_LAST
+} hwMbox_appId_e;
+
 /* Recv Opcode Infrastructure: */
 
 #define HW_MBOX_OPCODE_RECV_COUNT    10    /*! max amount of recv opcode channels per Master. */
@@ -815,6 +854,14 @@ typedef Uint8 __hwMbox_opcodeMessageSize
 |                                           |
 ********************************************/
 
+#if (defined CONFIG_TI_KERNEL_GW_APPCPU) || (defined CONFIG_INTEL_KERNEL_PP_DRIVER_ON_ATOM)
+#define HW_MBOX_NP_APP_SRAM_SIZE 256
+#define HW_MBOX_APP_NP_SRAM_SIZE 256
+#else
+#define HW_MBOX_NP_APP_SRAM_SIZE 64
+#define HW_MBOX_APP_NP_SRAM_SIZE 128
+#endif
+
 /*! \def HW_MBOX_STATIC_CHANNEL_TABLE
     \brief X-MACRO hardcoded table for STATIC Channel declarations.
     \attention SRAM size must be an integral Multiple of HW_MBOX_SRAM_CHUNK = 4B.
@@ -824,26 +871,26 @@ typedef Uint8 __hwMbox_opcodeMessageSize
     \attention An opcode channel SRAM size must be >= HW_MBOX_OPCODE_MINIMAL_SRAM_ALLOCATION_IN_BYTES.
 */
 #define HW_MBOX_STATIC_CHANNEL_TABLE(ENTRY) \
-/*       +--------------------------------------------------------------------------------------------------------------------------+ */ \
-/*       |  CID  | Commander                           | Subject                             | HW_MBOX Channel Type     | SRAM size | */ \
-/*       |       | [hw_mbox_Masters_e]                 | [hw_mbox_Masters_e]                 | [hw_mbox_channel_type_e] | [Bytes]   | */ \
-/*       +--------------------------------------------------------------------------------------------------------------------------+ */ \
-    ENTRY(    0  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_command          , 0         )    \
-    ENTRY(    1  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_PHY_CPU              , hw_mbox_command          , 32        )    \
-    ENTRY(    2  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_opcode           , 8         )    \
-    ENTRY(    3  , HW_MBOX_MASTER_BBU_C                , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
-    ENTRY(    4  , HW_MBOX_MASTER_PHY_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 608       )    \
-    ENTRY(    5  , HW_MBOX_MASTER_MOCA_C               , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8         )    \
-    ENTRY(    6  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_opcode           , 8         )    \
-    ENTRY(    7  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_APP_CPU              , hw_mbox_opcode           , 256       )    \
-    ENTRY(    8  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_PHY_CPU              , hw_mbox_opcode           , 8         )    \
-    ENTRY(    9  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_opcode           , 8         )    \
-    ENTRY(   10  , HW_MBOX_MASTER_APP_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_opcode           , 256       )    \
-    ENTRY(   11  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_RCE                  , hw_mbox_command          , 0         )    \
-    ENTRY(   12  , HW_MBOX_MASTER_RCE                  , HW_MBOX_MASTER_NP_CPU               , hw_mbox_command          , 0         )    \
-    ENTRY(   13  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_command          , 64        )    \
-    ENTRY(   14  , HW_MBOX_MASTER_MOCA_C               , HW_MBOX_MASTER_NP_CPU               , hw_mbox_command          , 64        )    \
-    ENTRY(   15  , HW_MBOX_MASTER_DS_MAC_C             , HW_MBOX_MASTER_PHY_CPU              , hw_mbox_command          , 24        )    \
+/*       +------------------------------------------------------------------------------------------------------------------------------------------+ */ \
+/*       |  CID  | Commander                           | Subject                             | HW_MBOX Channel Type     | SRAM size                 | */ \
+/*       |       | [hw_mbox_Masters_e]                 | [hw_mbox_Masters_e]                 | [hw_mbox_channel_type_e] | [Bytes]                   | */ \
+/*       +------------------------------------------------------------------------------------------------------------------------------------------+ */ \
+    ENTRY(    0  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_command          , 0                         )    \
+    ENTRY(    1  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_PHY_CPU              , hw_mbox_command          , 32                        )    \
+    ENTRY(    2  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_opcode           , 8                         )    \
+    ENTRY(    3  , HW_MBOX_MASTER_BBU_C                , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8                         )    \
+    ENTRY(    4  , HW_MBOX_MASTER_PHY_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 608                       )    \
+    ENTRY(    5  , HW_MBOX_MASTER_MOCA_C               , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8                         )    \
+    ENTRY(    6  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_opcode           , 8                         )    \
+    ENTRY(    7  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_APP_CPU              , hw_mbox_opcode           , HW_MBOX_NP_APP_SRAM_SIZE  )    \
+    ENTRY(    8  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_PHY_CPU              , hw_mbox_opcode           , 8                         )    \
+    ENTRY(    9  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_opcode           , 8                         )    \
+    ENTRY(   10  , HW_MBOX_MASTER_APP_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_opcode           , HW_MBOX_APP_NP_SRAM_SIZE  )    \
+    ENTRY(   11  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_RCE                  , hw_mbox_command          , 0                         )    \
+    ENTRY(   12  , HW_MBOX_MASTER_RCE                  , HW_MBOX_MASTER_NP_CPU               , hw_mbox_command          , 0                         )    \
+    ENTRY(   13  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_command          , 64                        )    \
+    ENTRY(   14  , HW_MBOX_MASTER_MOCA_C               , HW_MBOX_MASTER_NP_CPU               , hw_mbox_command          , 64                        )    \
+    ENTRY(   15  , HW_MBOX_MASTER_DS_MAC_C             , HW_MBOX_MASTER_PHY_CPU              , hw_mbox_command          , 24                        )
 
 /* static channel Table Expanders: */
 
--- /dev/null
+++ b/include/linux/hw_mbox_socket.h
@@ -0,0 +1,193 @@
+/*
+ *
+ * hw_mbox_socket.h
+ * Description:
+ * contains AF_HWMBOX family sockets api for the puma7 HW_MBOX controller.
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2015-2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2015-2016 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _HW_MBOX_SOCKET_H_
+#define _HW_MBOX_SOCKET_H_
+
+/*! \enum hwMbox_socket_type
+    \brief This enum denotes HW_MBOX socket types.
+*/
+enum hwMbox_socket_type {
+    SOCK_COMMANDER = 0,
+    SOCK_SUBJECT,
+};
+
+/*! \define HW_MBOX_SOCK_TYPE_GET_STR( _sockTypeVal )
+    \brief Use this define to get string for HW_MBOX socket types.
+    \param[in] _sockTypeVal - HW_MBOX socket type.
+    \return string corresponding to <_sockTypeVal>.
+*/
+#define HW_MBOX_SOCK_TYPE_GET_STR( _sockTypeVal ) \
+    ( (( _sockTypeVal ) == SOCK_COMMANDER) ? "COMMANDER" : \
+      (( _sockTypeVal ) == SOCK_SUBJECT)   ? "SUBJECT"   : \
+      "__ERROR_UNKNOWN_HW_MBOX_SOCKET_TYPE__" )
+
+#ifdef __KERNEL__
+/************************************
+|          KERNEL's part            |
+************************************/
+
+#include <linux/types.h>
+#include <linux/socket.h>
+
+/*! \struct sockaddr_hwMbox
+    \brief This structure denotes socket's address for HW_MBOX.
+*/
+struct sockaddr_hwMbox {
+    __kernel_sa_family_t        shwMbox_family;
+    __u8                        shwMbox_mid;
+    __u16                       shwMbox_appid;
+    __u8                        shwMbox_zero[sizeof(struct sockaddr) - (sizeof(__kernel_sa_family_t) + sizeof(__u8) + sizeof(__u16))];
+} __attribute__((packed));
+
+/*! \struct hwMbox_stat
+    \brief HW_MBOX socket's statistics.
+*/
+struct hwMbox_stat {
+    __u32       sent_cnt;
+    __u32       sent_bytes;
+    __u32       recv_cnt;
+    __u32       recv_bytes;
+};
+
+/*! \struct hwMbox_sock
+    \brief This structure denotes HW_MBOX socket's internals.
+*/
+struct hwMbox_sock {
+    struct sock         sk;
+    struct hwMbox_stat  stat;
+    __u8                mid;
+    __u8                cid;
+    __u16               appid;
+    __u16               owner_pid;
+    __s32               chnIntr;
+};
+
+/*! \enum hwMbox_socket_state_e
+    \brief This enum denotes HW_MBOX socket states.
+*/
+typedef enum hwMbox_socket_state {
+    HW_MBOX_SOCK_STATE_CREATED = 0,
+    HW_MBOX_SOCK_STATE_BOUND,
+    HW_MBOX_SOCK_STATE_RECEIVING,
+    HW_MBOX_SOCK_STATE_RECEIVED,
+    HW_MBOX_SOCK_STATE_RECV_ERROR,
+    HW_MBOX_SOCK_STATE_SENDING,
+    HW_MBOX_SOCK_STATE_SENT,
+    HW_MBOX_SOCK_STATE_SEND_ERROR
+} hwMbox_socket_state_e;
+
+/*! \define HW_MBOX_SOCK_TYPE_GET_STR( _sockStateVal )
+    \brief Use this define to get string for HW_MBOX socket state.
+    \note Value is stored in sock->state.
+    \param[in] _sockStateVal - HW_MBOX socket state.
+    \return string corresponding to <_sockStateVal>.
+*/
+#define HW_MBOX_SOCK_STATE_STR( _sockStateVal ) \
+    ( ((hwMbox_socket_state_e)( _sockStateVal ) == HW_MBOX_SOCK_STATE_CREATED)    ? ("created"   ) : \
+      ((hwMbox_socket_state_e)( _sockStateVal ) == HW_MBOX_SOCK_STATE_BOUND)      ? ("bound"     ) : \
+      ((hwMbox_socket_state_e)( _sockStateVal ) == HW_MBOX_SOCK_STATE_RECEIVING)  ? ("receiving" ) : \
+      ((hwMbox_socket_state_e)( _sockStateVal ) == HW_MBOX_SOCK_STATE_RECEIVED)   ? ("received"  ) : \
+      ((hwMbox_socket_state_e)( _sockStateVal ) == HW_MBOX_SOCK_STATE_RECV_ERROR) ? ("recv err"  ) : \
+      ((hwMbox_socket_state_e)( _sockStateVal ) == HW_MBOX_SOCK_STATE_SENDING)    ? ("sending"   ) : \
+      ((hwMbox_socket_state_e)( _sockStateVal ) == HW_MBOX_SOCK_STATE_SENT)       ? ("sent"      ) : \
+      ((hwMbox_socket_state_e)( _sockStateVal ) == HW_MBOX_SOCK_STATE_SEND_ERROR) ? ("send err"  ) : \
+      "__ERROR_UNKNOWN_HW_MBOX_SOCKET_STATE__" )
+
+/*! \fn struct hwMbox_sock * hwMbox_sk(struct sock *sk)
+   \brief This is a typecast function.
+   \param[in] sk - pointer to struct sock.
+   \return pointer to struct HwMbox_sock.
+*/
+static inline struct hwMbox_sock * hwMbox_sk(struct sock *sk)
+{
+    return (struct hwMbox_sock *)sk;
+}
+
+#else /* __KERNEL__ */
+/************************************
+|           USER's part             |
+************************************/
+
+#include <sys/socket.h>
+
+#define AF_HWMBOX       41
+#define PF_HWMBOX       AF_HWMBOX
+
+/*! \struct sockaddr_hwMbox
+    \brief This structure denotes socket's address for HW_MBOX.
+*/
+struct sockaddr_hwMbox {
+    sa_family_t       shwMbox_family;
+    unsigned char     shwMbox_mid;
+    unsigned short    shwMbox_appid;
+    unsigned char     shwMbox_zero[sizeof(struct sockaddr) - (sizeof(sa_family_t) + sizeof(unsigned char) + sizeof(unsigned short))];
+} __attribute__((packed));
+
+#endif /* ! __KERNEL__ */
+#endif /* ! _HW_MBOX_SOCKET_H_ */
--- a/include/linux/netip_subsystem.h
+++ b/include/linux/netip_subsystem.h
@@ -59,6 +59,8 @@
 #define NETSS_DEV_CLK_CTRL_MMIO_SIZE (0x10000)
 #define NETSS_DEV_BBU_CTRLR_MMIO_OFFSET (0x160000)
 #define NETSS_DEV_BBU_CTRLR_MMIO_SIZE   (0x20000)  /*128 KB */
+#define NETSS_DEV_PERIPHERAL_SRAM_MMIO_OFFSET (0xFFF0000)
+#define NETSS_DEV_PERIPHERAL_SRAM_MMIO_SIZE   (0x4000)
 
 #define NETSS_INTERUPT_ARM11_MAX (64)  /*ARM11 is a bundle of 64 interrupts */
 
@@ -73,6 +75,7 @@ typedef enum {
    NETSS_DEV_GBE,
    NETSS_DEV_CLK_CTRL,
    NETSS_DEV_BBU_CTRLR,
+   NETSS_DEV_PERIPHERAL_SRAM,
    NETSS_DEV_MAX
 }netss_dev_t;
 
--- a/include/linux/socket.h
+++ b/include/linux/socket.h
@@ -180,7 +180,8 @@ struct ucred {
 #define AF_ALG		38	/* Algorithm sockets		*/
 #define AF_NFC		39	/* NFC sockets			*/
 #define AF_VSOCK	40	/* vSockets			*/
-#define AF_MAX		41	/* For now.. */
+#define AF_HWMBOX	41	/* Intel's HW_MBOX sockets	*/
+#define AF_MAX		42	/* For now.. */
 
 /* Protocol families, same as address families. */
 #define PF_UNSPEC	AF_UNSPEC
@@ -225,6 +226,7 @@ struct ucred {
 #define PF_ALG		AF_ALG
 #define PF_NFC		AF_NFC
 #define PF_VSOCK	AF_VSOCK
+#define PF_HWMBOX	AF_HWMBOX
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
