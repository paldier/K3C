# HG changeset patch
# Parent aca7edb0c7533f2fa84bdd91aca016e66e70a49f
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -415,4 +415,6 @@ config LTQ_PPA_API_DIRECTPATH_HAS_NEW_AP
 
 source "drivers/net/hyperv/Kconfig"
 
+source "drivers/net/l2nat/Kconfig"
+
 endif # NETDEVICES
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -75,5 +75,6 @@ obj-$(CONFIG_USB_CDC_PHONET)   += usb/
 obj-$(CONFIG_HYPERV_NET) += hyperv/
 obj-$(CONFIG_NTB_NETDEV) += ntb_netdev.o
 
+obj-$(CONFIG_L2NAT) += l2nat/
 obj-$(CONFIG_LTQ_PPA) += lantiq_ppa/
 obj-$(CONFIG_LPAL_DIRECTPATH) += lpal_api/
diff --git a/drivers/net/l2nat/Kconfig b/drivers/net/l2nat/Kconfig
new file mode 100644
--- /dev/null
+++ b/drivers/net/l2nat/Kconfig
@@ -0,0 +1,11 @@
+#
+# L2NAT configuration
+#
+
+config L2NAT
+	tristate "Layer 2 nat"
+	depends on BRIDGE_NETFILTER
+	default n
+	---help---
+	  Supported Layer 2 network address translation. This configuration is
+	  used in the implementation of a wireless bridged client.
diff --git a/drivers/net/l2nat/Makefile b/drivers/net/l2nat/Makefile
new file mode 100644
--- /dev/null
+++ b/drivers/net/l2nat/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for l2nat driver.
+#
+
+obj-$(CONFIG_L2NAT) += l2nat.o
+l2nat-y = l2nat_core.o l2nat_dev.o l2nat_hash.o l2nat_proc.o
diff --git a/drivers/net/l2nat/l2nat.h b/drivers/net/l2nat/l2nat.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/l2nat/l2nat.h
@@ -0,0 +1,266 @@
+/*
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+*/
+
+#ifndef __L2NAT_H__
+#define __L2NAT_H__
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/kref.h>
+#include <linux/hashtable.h>
+
+#define L2NAT_NUM_ENTRIES_BITS	8	/*256 entries*/
+
+#define L2NAT_AGING_WAIT_INFO	10
+#define L2NAT_AGING_WAIT_ARP	10
+
+#define L2NAT_SEND_ARP_LIMIT	(HZ/3)
+
+#define L2NAT_AGING_TIMEOUT_DEFAULT	(600 * HZ)
+
+#define L2N_DBG_HASH	0x00000001	/* debug hash operations */
+#define L2N_DBG_TX	0x00000002	/* debug tx flow */
+#define L2N_DBG_RX	0x00000004	/* debug rx flow */
+#define L2N_DBG_TMR	0x00000008	/* debug timer callbacks */
+#define L2N_DBG_DHCP	0x00000010	/* debug dhcp modifications */
+#define L2N_DBG_DEV	0x00000020	/* debug l2nat device list ops */
+#define L2N_DBG_DBG	0x00000040	/* general module debugging */
+#define L2N_DBG_INFO	0x00000080	/* general module debugging */
+#define L2N_WARN	0x00000100	/* module warnings */
+#define L2N_ERR		0x00000200	/* module errors */
+
+extern bool hooks_registered;
+extern u32 aging_timeout;
+extern struct l2nat_global_stats glbl_stats;
+
+extern unsigned int dbg_flags;
+
+#define __l2n_pr_unlikely(level, flag, fmt, ...)			\
+	do {								\
+		if (unlikely((flag) & dbg_flags))			\
+			printk(level pr_fmt(fmt), ##__VA_ARGS__);	\
+	} while (0);
+
+#define __l2n_pr_likely(level, flag, fmt, ...)				\
+	do {								\
+		if (likely((flag) & dbg_flags))				\
+			printk(level pr_fmt(fmt) , ##__VA_ARGS__);	\
+	} while (0);
+
+
+#define l2n_dbg_hash(fmt, ...) \
+	__l2n_pr_unlikely(KERN_INFO, L2N_DBG_HASH, fmt, ##__VA_ARGS__)
+
+#define l2n_dbg_tx(fmt, ...) \
+	__l2n_pr_unlikely(KERN_INFO, L2N_DBG_TX, fmt, ##__VA_ARGS__)
+
+#define l2n_dbg_rx(fmt, ...) \
+	__l2n_pr_unlikely(KERN_INFO, L2N_DBG_RX, fmt, ##__VA_ARGS__)
+
+#define l2n_dbg_tmr(fmt, ...) \
+	__l2n_pr_unlikely(KERN_INFO, L2N_DBG_TMR, fmt, ##__VA_ARGS__)
+
+#define l2n_dbg_dhcp(fmt, ...) \
+	__l2n_pr_unlikely(KERN_INFO, L2N_DBG_DHCP, fmt, ##__VA_ARGS__)
+
+#define l2n_dbg_dev(fmt, ...) \
+	__l2n_pr_unlikely(KERN_INFO, L2N_DBG_DEV, fmt, ##__VA_ARGS__)
+
+#define l2n_dbg(fmt, ...) \
+	__l2n_pr_unlikely(KERN_INFO, L2N_DBG_DBG, fmt, ##__VA_ARGS__)
+
+#define l2n_info(fmt, ...) \
+	__l2n_pr_likely(KERN_INFO, L2N_DBG_INFO, fmt, ##__VA_ARGS__)
+
+#define l2n_warn(fmt, ...) \
+	__l2n_pr_likely(KERN_WARNING, L2N_WARN, fmt, ##__VA_ARGS__)
+
+#define l2n_err(fmt, ...) \
+	__l2n_pr_likely(KERN_ERR, L2N_ERR, fmt, ##__VA_ARGS__)
+
+struct snap_hdr {
+	/* out1 + out2 = organization code */
+	u8 out1;
+	u16 out2;
+	/* ethernet type */
+	u16 ether_type;
+};
+
+struct hash_entry {
+	__be32			ip;
+	unsigned char		mac[ETH_ALEN];
+
+	u64			tx_packets;
+	u64			rx_packets;
+
+	atomic_long_t		last_pkt_timestamp;
+	unsigned long		first_pkt_timestamp;
+	struct timer_list	timer;
+	struct l2nat_dev	*l2nat;
+
+	struct hlist_node	hlist;
+	struct rcu_head		rcu;
+	struct kref		kref;
+
+	struct list_head	seqlist;
+};
+
+struct l2nat_global_stats {
+	u64 preroute;
+	u64 postroute;
+};
+
+struct l2nat_dev_stats {
+	u64 rx_packets;
+	u64 rx_bytes;
+	u64 rx_dropped;
+	u64 rx_arp;
+
+	u64 tx_packets;
+	u64 tx_bytes;
+	u64 tx_dropped;
+	u64 tx_arp;
+
+	u64 arp_gen;
+	u64 dhcp;
+
+	u64 entries_add;
+	u64 entries_del;
+};
+
+struct l2nat_dev {
+
+	unsigned char *default_host;
+
+	spinlock_t lock;
+
+	DECLARE_HASHTABLE(hash, L2NAT_NUM_ENTRIES_BITS);
+	u32 aging_timeout;
+
+	wait_queue_head_t wq;
+	atomic_t ent_count;
+
+	unsigned char mac_for_arp[ETH_ALEN];
+	__be32 ip_for_arp;
+	unsigned long last_arp_sent_ts;
+
+	atomic_t arp_info_needed;
+	unsigned long last_arp_info_ts;
+
+	struct l2nat_dev_stats stats;
+
+	bool hash_en;
+
+	struct net_device *dev;
+	struct rcu_head rcu;
+	struct list_head list;
+	struct kref kref;
+};
+
+/* kernel doesn't have structure of the BOOTP/DHCP header
+ * so here it is defined according to rfc2131
+ */
+
+struct dhcphdr {
+	u8	op;
+#define BOOTREQUEST   1
+#define BOOTREPLY     2
+	u8	htype;
+	u8	hlen;
+	u8	hops;
+	u32	xid;
+	u16	secs;
+	u16	flags;
+#define BOOTP_BRD_FLAG 0x8000
+	u32	ciaddr;
+	u32	yiaddr;
+	u32	siaddr;
+	u32	giaddr;
+	u8	chaddr[16];
+	u8	sname[64];
+	u8	file[128];
+	u32	magic; /* NB: actually magic is a part of options */
+	u8	options[0];
+} __packed __aligned(1);
+
+
+void entry_aging_timer_function(unsigned long data);
+
+void l2nat_proc_init(void);
+void l2nat_proc_exit(void);
+
+struct hash_entry *l2nat_entry_get(struct l2nat_dev *l2nat, __be32 ip);
+void l2nat_entry_release(struct kref *kref);
+void l2nat_hash_flush(struct l2nat_dev *l2nat);
+void l2nat_hash_flush_sync(struct l2nat_dev *l2nat);
+int l2nat_entry_check_add(struct l2nat_dev *l2nat, __be32 ip,
+			  unsigned char *mac);
+void entry_aging_timer_fn(unsigned long data);
+void __gen_fake_arp_req(struct l2nat_dev *l2nat, __be32 sip,
+			unsigned char *smac, __be32 dip);
+void gen_fake_arp_req(struct l2nat_dev *l2nat, __be32 sip,
+			     unsigned char *smac, __be32 dip);
+
+void l2nat_del_device(struct net_device *dev);
+int l2nat_add_device(struct net_device *dev);
+
+void l2nat_dev_foreach(void (*fn)(struct l2nat_dev *l2nat, void *data),
+		       void *arg);
+int l2nat_dev_count(void);
+void l2nat_dev_release(struct kref *kref);
+struct l2nat_dev *l2nat_dev_get(const struct net_device *dev);
+int l2nat_dev_del(struct net_device *dev);
+int l2nat_dev_add(struct net_device *dev);
+void l2nat_dev_list_init(void);
+void l2nat_dev_list_exit(void);
+
+static inline unsigned long last_packet_delta(struct hash_entry *ent)
+{
+	return jiffies -
+		(unsigned long)atomic_long_read(&ent->last_pkt_timestamp);
+}
+
+static inline void l2nat_dev_hold(struct l2nat_dev *l2nat)
+{
+	kref_get(&l2nat->kref);
+}
+
+static inline void l2nat_dev_put(struct l2nat_dev *l2nat)
+{
+	kref_put(&l2nat->kref, l2nat_dev_release);
+}
+
+static inline void l2nat_entry_hold(struct hash_entry *ent)
+{
+	kref_get(&ent->kref);
+}
+
+static inline void l2nat_entry_put(struct hash_entry *ent)
+{
+	kref_put(&ent->kref, l2nat_entry_release);
+}
+
+#endif /* __L2NAT_H__ */
diff --git a/drivers/net/l2nat/l2nat_core.c b/drivers/net/l2nat/l2nat_core.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/l2nat/l2nat_core.c
@@ -0,0 +1,885 @@
+/*
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+*/
+
+#define pr_fmt(fmt) "L2NAT:%s:%d " fmt, __func__, __LINE__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/if_vlan.h>
+#include <linux/if_arp.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/stat.h>
+#include <linux/netfilter_bridge.h>
+#include <net/arp.h>
+#include <net/ipx.h>
+#include <net/llc_pdu.h>
+#include <asm/checksum.h>
+#include <net/ppa_api.h>
+#include "l2nat.h"
+
+#define DRV_MODULE_VERSION "0.0.1"
+
+/* l2nat global statistics */
+struct l2nat_global_stats glbl_stats;
+
+/* nf hooks registered */
+bool hooks_registered;
+
+/* RFC 2132: 9.1. Requested IP Address
+ * RFC 2132: 9.7. Server Identifier
+ */
+struct dhcpopt_hdr {
+	u8 code;
+#define DHCP_OPT_REQ_IP		50
+#define DHCP_OPT_MSG_TYPE	53
+#define DHCP_OPT_SRV_ID		54
+#define DHCP_OPT_PAD		0
+#define DHCP_OPT_END		255
+
+	u8 len;
+} __packed __aligned(1);
+
+struct dhcpopt_ip {
+	struct dhcpopt_hdr hdr;
+	u32 ip;
+} __packed __aligned(1);
+
+struct dhcpopt_msg_type {
+	struct	dhcpopt_hdr hdr;
+#define DHCPREQUEST	3
+	u8	type;
+} __packed __aligned(1);
+
+/* magic cookie for DHCP, put at the start of the options field.
+ * it is in network byte order */
+#define DHCP_MAGIC		0x63825363
+
+/* udp ports used in client-server communication */
+#define BOOTP_SERVER_PORT	67
+
+/* 1 ARP request per 300ms */
+#define ARP_REQ_SEND_RATE_MS	300
+
+static void recv_fake_arp_req(struct l2nat_dev *l2nat, __be32 sip,
+			      unsigned char *smac, __be32 dip)
+{
+	struct sk_buff *skb = arp_create(ARPOP_REQUEST, ETH_P_ARP, dip,
+					 l2nat->dev, sip, NULL, smac, NULL);
+
+	if (!skb) {
+		l2n_warn("failed to create arp req for %s\n", l2nat->dev->name);
+		return;
+	}
+
+	skb_reset_mac_header(skb);
+	skb->protocol = eth_type_trans(skb, l2nat->dev);
+
+	netif_rx(skb);
+
+	l2nat->stats.arp_gen++;
+
+	l2n_dbg("receiving arp request: who has %pI4 tell %pI4 in %pM via %s\n",
+		&dip, &sip, smac, l2nat->dev->name);
+}
+
+void __gen_fake_arp_req(struct l2nat_dev *l2nat, __be32 sip,
+			unsigned char *smac, __be32 dip)
+{
+	if (unlikely(!sip || !dip))
+		return;
+
+	/* kind of rate limiting for the messages */
+	if (jiffies - l2nat->last_arp_sent_ts < L2NAT_SEND_ARP_LIMIT)
+		return;
+
+	/* Recv fake ARP request */
+	recv_fake_arp_req(l2nat, sip, smac, dip);
+
+	l2nat->last_arp_sent_ts = jiffies;
+}
+
+void gen_fake_arp_req(struct l2nat_dev *l2nat, __be32 sip,
+		      unsigned char *smac, __be32 dip)
+{
+	spin_lock_bh(&l2nat->lock);
+	__gen_fake_arp_req(l2nat, sip, smac, dip);
+	spin_unlock_bh(&l2nat->lock);
+}
+
+static inline struct dhcpopt_hdr *dhcp_req_find_opt(struct sk_buff *skb,
+						    struct dhcpopt_hdr *hdr,
+						    u8 opt_code)
+{
+	l2n_dbg_dhcp("Looking for %d\n", opt_code);
+	while (hdr->code != DHCP_OPT_END && hdr->code != DHCP_OPT_PAD &&
+	       hdr->code != opt_code && (u8 *)hdr < skb_tail_pointer(skb)) {
+
+		l2n_dbg_dhcp("option %d (0x%02x), length %d\n",
+			     hdr->code, hdr->code, hdr->len);
+
+		hdr = (struct dhcpopt_hdr *)((u8 *)hdr +
+					     hdr->len +
+					     sizeof(*hdr));
+	}
+	if (hdr->code == opt_code)
+		return hdr;
+	return NULL;
+}
+
+static inline int dhcp_req_update(struct l2nat_dev *l2nat, struct sk_buff *skb,
+				  ptrdiff_t offset)
+{
+	struct iphdr *iph;
+	struct udphdr *udph;
+	struct dhcphdr *dhcph;
+	struct dhcpopt_hdr *opt_hdr;
+	struct dhcpopt_ip *opt_ip;
+	int extra_size;
+	bool add_req_ip_opt;
+	bool add_srv_id_opt;
+
+	iph = (struct iphdr *)(skb_mac_header(skb) + offset);
+
+	/* check the protocol to be UDP */
+	if (iph->protocol != IPPROTO_UDP)
+		return 0;
+
+	udph = (struct udphdr *)((char *)iph + iph->ihl * 4);
+
+	/* destination port should be 67 (bootps) */
+	if (likely(udph->dest != __constant_htons(BOOTP_SERVER_PORT)))
+		return 0;
+
+	dhcph = (struct dhcphdr *)((char *)udph + sizeof(*udph));
+
+	/* should be bootp request, no broadcast flag set,
+	 * and have dhcp magic number in .options */
+	if (dhcph->op != BOOTREQUEST || dhcph->htype != ARPHRD_ETHER ||
+	    dhcph->magic != __constant_ntohl(DHCP_MAGIC))
+		return 0;
+
+	add_req_ip_opt = false;
+	add_srv_id_opt = false;
+	extra_size = 0;
+
+	/* adding new options in case when DstAddr!=Broadcast */
+	if (iph->daddr == __constant_htonl(INADDR_BROADCAST)) {
+		/*
+		 * Don't add DHCP_OPT_REQ_IP and DHCP_OPT_SRV_ID to DHCP
+		 * request with limited broadcast destination IP
+		 * (REBOOT-INIT DHCP state).
+		 */
+
+		/* check DHCP message type */
+		opt_hdr = dhcp_req_find_opt(skb,
+					   (struct dhcpopt_hdr *)dhcph->options,
+					   DHCP_OPT_MSG_TYPE);
+		if (opt_hdr) {
+			l2n_dbg_dhcp("DHCP message type is %d %pI4 %pI4\n",
+			    ((struct dhcpopt_msg_type *)opt_hdr)->type,
+			    &iph->saddr, &iph->daddr);
+		}
+
+	} else {
+
+		/* no options */
+		opt_hdr = dhcp_req_find_opt(skb,
+					   (struct dhcpopt_hdr *)dhcph->options,
+					   DHCP_OPT_END);
+		if (!opt_hdr)
+			goto dhcp_opt_done;
+
+		/* check DHCP message type */
+		opt_hdr = dhcp_req_find_opt(skb,
+					   (struct dhcpopt_hdr *)dhcph->options,
+					   DHCP_OPT_MSG_TYPE);
+		if (!opt_hdr)
+			goto dhcp_opt_done;
+
+		l2n_dbg_dhcp("DHCP message type is %d %pI4 %pI4\n",
+			    ((struct dhcpopt_msg_type *)opt_hdr)->type,
+			    &iph->saddr, &iph->daddr);
+
+		if (((struct dhcpopt_msg_type *)opt_hdr)->type != DHCPREQUEST)
+			goto dhcp_opt_done;
+
+		/* Check if the options should be added*/
+		if (!dhcp_req_find_opt(skb,
+				      (struct dhcpopt_hdr *)dhcph->options,
+				      DHCP_OPT_REQ_IP)) {
+
+			add_req_ip_opt = true;
+			extra_size += sizeof(struct dhcpopt_ip);
+		}
+
+		if (!dhcp_req_find_opt(skb,
+				      (struct dhcpopt_hdr *)dhcph->options,
+				      DHCP_OPT_SRV_ID)) {
+
+			add_srv_id_opt = true;
+			extra_size += sizeof(struct dhcpopt_ip);
+		}
+
+		if (skb->len + extra_size > 65535) {
+			add_req_ip_opt = false;
+			add_srv_id_opt = false;
+			extra_size = 0;
+			goto dhcp_opt_done;
+		}
+dhcp_opt_done:
+		if (!extra_size)
+			extra_size = skb_tailroom(skb);
+
+		if (pskb_expand_head(skb, 0, extra_size - skb_tailroom(skb),
+				     GFP_ATOMIC)) {
+			l2n_err("cannot expand skb, dropping packet\n");
+			return -1;
+		}
+	}
+
+	/* update pointers after expand */
+	iph = (struct iphdr *)(skb_mac_header(skb) + offset);
+	udph = (struct udphdr *)((char *)iph + iph->ihl * 4);
+	dhcph = (struct dhcphdr *)((char *)udph + sizeof(*udph));
+
+	if (!(dhcph->flags & __constant_htons(BOOTP_BRD_FLAG))) {
+		/* set the broadcast flag */
+
+		dhcph->flags |= __constant_ntohs(BOOTP_BRD_FLAG);
+		/* change checksum according to added broadcast flag.
+		 * ip_decrease_ttl was used as an example
+		 */
+		if (udph->check) {
+			u32 check;
+
+			check = (u32)udph->check;
+			check += (u32)__constant_ntohs(~((u16)BOOTP_BRD_FLAG));
+			udph->check = (u16)(check +
+					    ((check >= 0xffff) ? 1 : 0));
+
+			/* in udp 0 csum means no checksumming,
+			 * so if csum is 0 it should be set to 0xffff */
+			if (!udph->check)
+				udph->check = 0xffff;
+		}
+	}
+
+	/* At this point we always have enough space for additional DHCP
+	   options */
+
+	/* all DHCP request packet modification which is done below are required
+	 * to force DHCP server to send DHCP ACK as broadcast message*/
+
+	/* adjust to new size */
+	skb_put(skb, extra_size);
+	extra_size = 0;
+
+	/* Add additional field "requested IP" and "server id" -
+	* it's resolved issues with HW like Linksys WRT610N, WRT160*/
+	if (true == add_req_ip_opt) {
+
+		l2n_dbg_dhcp("Adding requested ip %pI4\n", &dhcph->ciaddr);
+		opt_hdr = dhcp_req_find_opt(skb,
+					   (struct dhcpopt_hdr *)dhcph->options,
+					   DHCP_OPT_END);
+
+		opt_ip = (struct dhcpopt_ip *)opt_hdr;
+		/* 9.1. Requested IP Address */
+		opt_ip[0].hdr.code = DHCP_OPT_REQ_IP;
+		opt_ip[0].hdr.len = 4;
+		opt_ip[0].ip = dhcph->ciaddr;
+		opt_ip[1].hdr.code = DHCP_OPT_END;
+
+		extra_size += sizeof(struct dhcpopt_ip);
+	}
+
+	if (true == add_srv_id_opt) {
+
+		l2n_dbg_dhcp("Adding server id %pI4\n", &iph->daddr);
+
+		opt_hdr = dhcp_req_find_opt(skb,
+					   (struct dhcpopt_hdr *)dhcph->options,
+					   DHCP_OPT_END);
+		opt_ip = (struct dhcpopt_ip *)opt_hdr;
+		/* 9.7. Server Identifier */
+		opt_ip[0].hdr.code = DHCP_OPT_SRV_ID;
+		opt_ip[0].hdr.len = 4;
+		opt_ip[0].ip = iph->daddr;
+		opt_ip[1].hdr.code = DHCP_OPT_END;
+
+		extra_size += sizeof(struct dhcpopt_ip);
+	}
+
+	/* cleanup CI address fields DHCP Request - it's resolved issues with
+	 * HW like Cisco E2000 router */
+	dhcph->ciaddr = 0;
+
+	/* Update size fields in headers */
+	iph->tot_len = htons(ntohs(iph->tot_len) + extra_size);
+	udph->len = htons(ntohs(udph->len) + extra_size);
+
+	/* recalculate check sums */
+	iph->check = 0;
+	iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
+	if (udph->check) {
+		int data_len = ntohs(udph->len);
+		udph->check = 0;
+		udph->check = csum_tcpudp_magic(iph->saddr,
+						iph->daddr, data_len,
+						IPPROTO_UDP,
+						csum_partial((char *)udph,
+							     data_len, 0));
+		if (udph->check == 0)
+			udph->check = -1;
+	}
+
+	l2nat->stats.dhcp++;
+
+	return 0;
+}
+
+int l2nat_tx(struct l2nat_dev *l2nat, struct sk_buff *skb)
+{
+	struct ethhdr *eth;
+	struct vlan_hdr *vlanh;
+	struct ipxhdr *ipxh;
+	struct arphdr *arph;
+	struct iphdr *iph;
+	struct snap_hdr *snaph;
+
+	u16 proto;
+	u8 *p;
+	u32 ip;
+	ptrdiff_t offset = sizeof(struct ethhdr);
+
+	/* get the type of the frame and set ip-mac pair to be checked
+	 * (and possibly added) in table
+	 */
+	eth = eth_hdr(skb);
+	proto = eth->h_proto;
+
+analyse:
+	switch (proto) {
+
+	case __constant_htons(ETH_P_8021Q):
+		vlanh = (struct vlan_hdr *)(skb_mac_header(skb) + offset);
+		proto = vlanh->h_vlan_encapsulated_proto;
+		offset += sizeof(struct vlan_hdr);
+		goto analyse;
+
+	case __constant_htons(ETH_P_IP):
+		iph = (struct iphdr *)(skb_mac_header(skb) + offset);
+
+		/* check in the table, add entry if needed.
+		 * ip_header->saddr assumed to be 4-bytes aligned
+		 */
+		l2nat_entry_check_add(l2nat, iph->saddr, eth->h_source);
+
+		/* if dhcp req set broadcast flag,  add DHCP opts if needed
+		 * XXX: eth and iph are invalid after this point */
+		if (dhcp_req_update(l2nat, skb, offset))
+			return -1;
+
+		break;
+
+	case __constant_htons(ETH_P_ARP):
+		arph = (struct arphdr *)(skb_mac_header(skb) + offset);
+
+		if (arph->ar_pro != htons(ETH_P_IP) ||
+		    arph->ar_hrd != htons(ARPHRD_ETHER))
+			break;
+
+		p = (char *)arph + sizeof(*arph);
+
+		/* save ip and mac */
+
+		/* sender IP is 2-bytes aligned, so copy it to temporal storage
+		 * to prevent unaligned access with subsequent data abort
+		 * handling
+		 */
+		memcpy(&ip, p + ETH_ALEN, sizeof(ip));
+
+		/* check in the table, add entry if needed */
+		l2nat_entry_check_add(l2nat, ip, p);
+
+		/* change src mac */
+		memcpy(p, l2nat->dev->dev_addr, ETH_ALEN);
+
+		l2nat->stats.tx_arp++;
+		break;
+
+	case __constant_htons(ETH_P_IPX):
+		ipxh = (struct ipxhdr *)(skb_mac_header(skb) + offset);
+
+		/* set source node to wilreless MAC address */
+		memcpy(ipxh->ipx_source.node, l2nat->dev->dev_addr, ETH_ALEN);
+		break;
+
+	default:
+		if (ntohs(proto) > ETH_DATA_LEN)
+			break;
+
+		/* 802.3 frame header with Length in T/E field */
+		proto = *(u16 *)(skb_mac_header(skb) + offset);
+		switch (proto) {
+		case 0xFFFF:
+			/* checksum of IPX over 802.3 with raw encapsulation */
+			proto = __constant_htons(ETH_P_IPX);
+			goto analyse;
+		case 0xE0E0:
+			/* part of LLC header used with IPX over
+			   802.2 Novel encapsulation */
+			proto = __constant_htons(ETH_P_IPX);
+			 /* skip LLC header */
+			offset += sizeof(struct llc_pdu_un);
+			goto analyse;
+		case 0xAAAA:
+			/* part oh LLC/SNAP header used with (possible)
+			   IPX over 802.2 SNAP encapsulation */
+			snaph = (struct snap_hdr *)(skb_mac_header(skb) +
+						    offset +
+						    sizeof(struct llc_pdu_un));
+			proto = snaph->ether_type;
+			/* skip LLC/SNAP header */
+			offset += sizeof(struct llc_pdu_un) +
+				  sizeof(struct snap_hdr);
+			goto analyse;
+		default:
+			break;
+		}
+		break;
+	}
+
+	memcpy(eth_hdr(skb)->h_source, l2nat->dev->dev_addr, ETH_ALEN);
+	return 0;
+}
+
+
+int l2nat_rx(struct l2nat_dev *l2nat, struct sk_buff *skb)
+{
+	struct hash_entry *ent;
+	struct ethhdr *eth;
+	struct vlan_hdr *vlanh;
+	struct arphdr *arph;
+	struct iphdr  *iph;
+	struct ipxhdr *ipxh;
+	struct snap_hdr *snaph;
+	u32 ip;
+	u16 proto;
+	unsigned char *p, *dnat_mac = NULL;
+	ptrdiff_t offset = sizeof(struct ethhdr);
+	int ret = 0;
+
+	eth = eth_hdr(skb);
+	proto = eth->h_proto;
+
+
+	/* do not touch multicast / broadcast*/
+	if (is_multicast_ether_addr(eth->h_dest))
+		return ret;
+
+	/* use device mac address as default dest address*/
+	dnat_mac = l2nat->default_host;
+
+analyse:
+	switch (proto) {
+	case __constant_htons(ETH_P_PAE):
+		spin_unlock_bh(&l2nat->lock);
+		return ret;
+	case __constant_htons(ETH_P_8021Q):
+		vlanh = (struct vlan_hdr *)(skb_mac_header(skb) + offset);
+		proto = vlanh->h_vlan_encapsulated_proto;
+		offset += sizeof(struct vlan_hdr);
+		goto analyse;
+	case __constant_htons(ETH_P_IP):
+
+		iph = (struct iphdr *)(skb_mac_header(skb) + offset);
+
+		ent = l2nat_entry_get(l2nat, iph->daddr);
+		if (unlikely(!ent)) {
+			gen_fake_arp_req(l2nat, iph->saddr, eth->h_source,
+					 iph->daddr);
+			/* drop this packet to avoid wrong learning */
+			ret = -1;
+			break;
+		}
+
+		if (unlikely(atomic_read(&l2nat->arp_info_needed))) {
+
+			/* copy IP and MAC to be used when generating*/
+			spin_lock_bh(&l2nat->lock);
+
+			memcpy(&l2nat->mac_for_arp, eth->h_source, ETH_ALEN);
+			l2nat->ip_for_arp = iph->saddr;
+			l2nat->last_arp_info_ts = jiffies;
+			atomic_set(&l2nat->arp_info_needed, 0);
+
+			spin_unlock_bh(&l2nat->lock);
+		}
+
+		dnat_mac = ent->mac;
+
+		ent->rx_packets++;
+		l2nat_entry_put(ent);
+		break;
+	case __constant_htons(ETH_P_ARP):
+
+		arph = (struct arphdr *)(skb_mac_header(skb) + offset);
+		if (arph->ar_pro != htons(ETH_P_IP) ||
+		    arph->ar_hrd != htons(ARPHRD_ETHER))
+			break;
+
+		l2nat->stats.rx_arp++;
+
+		/* set p to start of arp payload*/
+		p = (u8 *)arph + sizeof(*arph);
+		/* copy target ip into local variable */
+		memcpy(&ip, p + 2 * ETH_ALEN + sizeof(ip), sizeof(ip));
+
+		/* find entry, set dest mac */
+		ent = l2nat_entry_get(l2nat, ip);
+		if (!ent) {
+			gen_fake_arp_req(l2nat, *(u32 *)(p + ETH_ALEN) , p, ip);
+			/* drop this packet to avoid wrong learning */
+			ret = -1;
+			break;
+		}
+
+		switch (ntohs(arph->ar_op)) {
+		case ARPOP_REPLY:
+			/* change target hw addr to one from found entry */
+			memcpy(p + ETH_ALEN + sizeof(ip), &ent->mac, ETH_ALEN);
+			/* do not break, so that the dnat_mac will be set */
+		case ARPOP_REQUEST: /* arp solicit requests */
+			dnat_mac = ent->mac;
+			break;
+		default:
+			break;
+		}
+
+		ent->rx_packets++;
+		l2nat_entry_put(ent);
+		break;
+
+	case __constant_htons(ETH_P_IPX):
+
+		if (unlikely(dnat_mac == NULL))
+			break;
+
+		ipxh = (struct ipxhdr *)(skb_mac_header(skb) + offset);
+		/* set dest node node to default GW MAC address
+		   (dnat_mac is already set to it) */
+		memcpy(ipxh->ipx_dest.node, dnat_mac, IPX_NODE_LEN);
+		break;
+
+	default:
+		if (ntohs(proto) > ETH_DATA_LEN)
+			break;
+
+		/* 802.3 frame header with Length in T/E field */
+		proto = *(u16 *)(skb_mac_header(skb) + offset);
+		switch (proto) {
+		case 0xFFFF:
+			/* checksum of IPX over 802.3 with raw encapsulation */
+			proto = __constant_htons(ETH_P_IPX);
+			goto analyse;
+		case 0xE0E0:
+			/* part of LLC header used with IPX over802.2
+			   Novel encapsulation */
+			proto = __constant_htons(ETH_P_IPX);
+			/* skip LLC header */
+			offset += sizeof(struct llc_pdu_un);
+			goto analyse;
+		case 0xAAAA:
+			/* part of LLC/SNAP header used with (possible)
+			   IPX over 802.2 SNAP encapsulation */
+			snaph = (struct snap_hdr *)(skb_mac_header(skb) +
+						    offset +
+						    sizeof(struct llc_pdu_un));
+			proto = snaph->ether_type;
+			/* skip LLC/SNAP header */
+			offset += sizeof(struct llc_pdu_un) +
+				  sizeof(struct snap_hdr);
+			goto analyse;
+		default:
+			break;
+		}
+		break;
+	}
+
+	if (likely(dnat_mac != NULL))
+		memcpy(&eth->h_dest, dnat_mac, ETH_ALEN);
+
+	return ret;
+}
+
+
+static unsigned int l2nat_nf_br_pre_routing(unsigned int hook,
+					    struct sk_buff *skb,
+					    const struct net_device *in,
+					    const struct net_device *out,
+					    int (*okfn)(struct sk_buff *))
+{
+	struct l2nat_dev *l2nat;
+
+	glbl_stats.preroute++;
+
+	if (unlikely(!in)) {
+		l2n_err("in device null in prerouting hook\n");
+		goto done;
+	}
+
+	l2nat = l2nat_dev_get(in);
+
+	/* this is not an l2nat device*/
+	if (!l2nat)
+		goto done;
+
+	/* make writeable in case skb is shared */
+	if (!skb_make_writable(skb, skb->len))
+		goto put_drop;
+
+	if (l2nat_rx(l2nat, skb) < 0)
+		goto put_drop;
+
+	l2nat->stats.rx_packets++;
+	l2nat->stats.rx_bytes += skb->len;
+
+	l2nat_dev_put(l2nat);
+done:
+	return NF_ACCEPT;
+
+put_drop:
+	l2nat_dev_put(l2nat);
+	l2nat->stats.rx_dropped++;
+	return NF_DROP;
+}
+
+static unsigned int l2nat_nf_br_post_routing(unsigned int hook,
+					     struct sk_buff *skb,
+					     const struct net_device *in,
+					     const struct net_device *out,
+					     int (*okfn)(struct sk_buff *))
+{
+	struct l2nat_dev *l2nat;
+
+	glbl_stats.postroute++;
+
+	if (unlikely(!out)) {
+		l2n_err("out device null in postrouting hook\n");
+		goto done;
+	}
+
+	l2nat = l2nat_dev_get(out);
+
+	/* this is not an l2nat device*/
+	if (!l2nat)
+		goto done;
+
+	/* make writeable in case skb is shared */
+	if (!skb_make_writable(skb, skb->len))
+		goto put_drop;
+
+	if (l2nat_tx(l2nat, skb) < 0)
+		goto put_drop;
+
+	l2nat->stats.tx_packets++;
+	l2nat->stats.tx_bytes += skb->len;
+
+	l2nat_dev_put(l2nat);
+done:
+	return NF_ACCEPT;
+
+put_drop:
+	l2nat_dev_put(l2nat);
+	l2nat->stats.rx_dropped++;
+	return NF_DROP;
+}
+
+enum nf_l2nat_hook_priorities {
+	NF_BR_PRI_L2NAT = -400,
+};
+
+static struct nf_hook_ops l2nat_nf_br_ops[] __read_mostly = {
+	{
+		.hook = l2nat_nf_br_pre_routing,
+		.owner = THIS_MODULE,
+		.pf = NFPROTO_BRIDGE,
+		.hooknum = NF_BR_PRE_ROUTING,
+		.priority = NF_BR_PRI_L2NAT,
+	},
+	{
+		.hook = l2nat_nf_br_post_routing,
+		.owner = THIS_MODULE,
+		.pf = NFPROTO_BRIDGE,
+		.hooknum = NF_BR_POST_ROUTING,
+		.priority = NF_BR_PRI_L2NAT,
+	},
+};
+
+int l2nat_add_device(struct net_device *dev)
+{
+
+	int ret = l2nat_dev_add(dev);
+
+	if (ret < 0)
+		return ret;
+
+	if (hooks_registered)
+		return 0;
+
+	ret = nf_register_hooks(l2nat_nf_br_ops, ARRAY_SIZE(l2nat_nf_br_ops));
+	if (ret) {
+		l2n_err("failed to register nf hooks\n");
+		return ret;
+	}
+
+	hooks_registered = true;
+	l2n_info("nf hooks registered\n");
+
+	return 0;
+}
+
+void l2nat_del_device(struct net_device *dev)
+{
+
+	int dev_count = l2nat_dev_count();
+
+	if (l2nat_dev_del(dev))
+		return;
+
+	if (dev_count != 1 || !hooks_registered)
+		return;
+
+	nf_unregister_hooks(l2nat_nf_br_ops, ARRAY_SIZE(l2nat_nf_br_ops));
+
+	hooks_registered = false;
+	l2n_info("nf hooks unregistered\n");
+}
+
+int32_t l2nat_check_device(struct net_device *dev, char *name, uint32_t flags)
+{
+	struct net *net;
+	struct l2nat_dev *l2nat;
+
+	if (!dev && !name)
+		return 0;
+
+	if (!dev) {
+		for_each_net(net) {
+			dev = dev_get_by_name(net, name);
+			if (dev)
+				break;
+		}
+	}
+
+	if (!dev)
+		return 0;
+
+	l2nat = l2nat_dev_get(dev);
+
+	if (!l2nat)
+		return 0;
+
+	l2nat_dev_put(l2nat);
+
+	return 1;
+}
+
+/* netdev event handler */
+static int l2nat_netdev_event(struct notifier_block *this, unsigned long event,
+			      void *ptr)
+{
+	struct net_device *netdev = ptr;
+
+	/* try to remove this device, will do nothing if this is not an l2nat
+	   device */
+	if (event == NETDEV_UNREGISTER)
+		l2nat_del_device(netdev);
+
+	return NOTIFY_DONE;
+}
+
+/* notifier block for netdev unregister */
+static struct notifier_block dev_notifier = {
+	.notifier_call = l2nat_netdev_event
+};
+
+int l2nat_init(void)
+{
+	int ret;
+
+	l2nat_dev_list_init();
+
+	ppa_check_if_netif_l2nat_fn = l2nat_check_device;
+
+	l2nat_proc_init();
+
+	ret = register_netdevice_notifier(&dev_notifier);
+	if (ret) {
+		l2n_err("register_netdevice_notifier failed (ret=%d)\n", ret);
+		goto notifier_err;
+	}
+
+	l2n_info("l2nat module loaded\n");
+
+	return 0;
+
+notifier_err:
+	l2nat_proc_exit();
+	l2nat_dev_list_exit();
+
+	return ret;
+}
+
+void l2nat_exit(void)
+{
+	unregister_netdevice_notifier(&dev_notifier);
+
+	if (hooks_registered) {
+		nf_unregister_hooks(l2nat_nf_br_ops,
+				    ARRAY_SIZE(l2nat_nf_br_ops));
+	}
+
+	l2nat_proc_exit();
+
+	ppa_check_if_netif_l2nat_fn = NULL;
+
+	l2nat_dev_list_exit();
+	l2n_info("l2nat module unloaded\n");
+}
+
+module_init(l2nat_init);
+module_exit(l2nat_exit);
+
+
+MODULE_AUTHOR("Yair Weiss <yair.weiss@intel.com>");
+MODULE_DESCRIPTION("intel layer 2 nat driver)");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/net/l2nat/l2nat_dev.c b/drivers/net/l2nat/l2nat_dev.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/l2nat/l2nat_dev.c
@@ -0,0 +1,278 @@
+/*
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+*/
+
+#define pr_fmt(fmt) "L2NAT:%s:%d " fmt, __func__, __LINE__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/kref.h>
+#include <linux/wait.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/rtnetlink.h>
+#include "l2nat.h"
+
+/* device list */
+static struct list_head dev_list;
+
+/* device list lock */
+static spinlock_t list_lock;
+
+/*wait queue for rmmod */
+static wait_queue_head_t wq;
+
+/* device list size*/
+static atomic_t dev_count = ATOMIC_INIT(0);
+
+/* entry aging timeout */
+u32 aging_timeout = L2NAT_AGING_TIMEOUT_DEFAULT;
+
+static inline void l2nat_dev_disable_hash(struct l2nat_dev *l2nat)
+{
+	l2nat->hash_en = false;
+}
+
+int l2nat_dev_count(void)
+{
+	return atomic_read(&dev_count);
+}
+
+void l2nat_dev_foreach(void (*fn)(struct l2nat_dev *l2nat, void *data),
+		       void *arg)
+{
+	struct l2nat_dev *l2nat;
+	rcu_read_lock();
+	list_for_each_entry(l2nat, &dev_list, list)
+		fn(l2nat, arg);
+	rcu_read_unlock();
+}
+
+/* initialize the private data of a l2nat device */
+static int l2nat_dev_init(struct l2nat_dev *l2nat)
+{
+	l2n_dbg_dev("initializing l2nat dev %s\n", l2nat->dev->name);
+
+	spin_lock_init(&l2nat->lock);
+
+	/* init device list and kref */
+	INIT_LIST_HEAD(&l2nat->list);
+	kref_init(&l2nat->kref);
+
+	hash_init(l2nat->hash);
+	l2nat->hash_en = true;
+
+	l2nat->last_arp_sent_ts = jiffies;
+	l2nat->default_host = l2nat->dev->dev_addr;
+	l2nat->aging_timeout = aging_timeout;
+
+	init_waitqueue_head(&l2nat->wq);
+	atomic_set(&l2nat->ent_count, 0);
+
+	atomic_set(&l2nat->arp_info_needed, 0);
+
+	l2n_dbg_dev("l2nat dev initialized for %s\n", l2nat->dev->name);
+
+	return 0;
+}
+
+/* free a l2nat device from the list */
+void l2nat_dev_release(struct kref *kref)
+{
+	struct l2nat_dev *l2nat = container_of(kref, struct l2nat_dev, kref);
+
+	l2n_dbg_dev("freeing l2nat dev %s\n", l2nat->dev->name);
+
+	dev_put(l2nat->dev);
+
+	kfree(l2nat);
+
+	atomic_dec(&dev_count);
+
+	/* wake up in case rmmod is waiting for all devices to be freed */
+	wake_up_interruptible(&wq);
+}
+
+/* put a l2nat device from the list from call_rcu */
+static void l2nat_dev_free_rcu(struct rcu_head *rcu)
+{
+	struct l2nat_dev *l2nat = container_of(rcu, struct l2nat_dev, rcu);
+	l2nat_dev_put(l2nat);
+}
+
+/* remove all netdevices from the l2nat list */
+static void l2nat_dev_list_flush(void)
+{
+	LIST_HEAD(dying_list);
+	struct l2nat_dev *l2nat, *tmp;
+
+	l2n_dbg_dev("flusing l2nat dev list\n");
+
+	spin_lock_bh(&list_lock);
+	list_for_each_entry_safe(l2nat, tmp, &dev_list, list) {
+		l2nat_dev_hold(l2nat);
+		list_del_rcu(&l2nat->list);
+		l2nat_dev_disable_hash(l2nat);
+		list_add(&l2nat->list, &dying_list);
+	}
+	spin_unlock_bh(&list_lock);
+
+	list_for_each_entry(l2nat, &dying_list, list) {
+		l2nat_hash_flush_sync(l2nat);
+		l2nat_dev_put(l2nat);
+		call_rcu(&l2nat->rcu, l2nat_dev_free_rcu);
+	}
+}
+
+/* search for a netdevice in the l2nat list - called under rcu_read_lock */
+static struct l2nat_dev *l2nat_dev_get_rcu(const struct net_device *dev)
+{
+	struct l2nat_dev *l2nat;
+
+	list_for_each_entry_rcu(l2nat, &dev_list, list) {
+		if (dev == l2nat->dev)
+			return l2nat;
+	}
+	return NULL;
+}
+
+/* search for a netdevice in the l2nat list */
+struct l2nat_dev *l2nat_dev_get(const struct net_device *dev)
+{
+	struct l2nat_dev *l2nat;
+
+	rcu_read_lock();
+	l2nat = l2nat_dev_get_rcu(dev);
+	if (l2nat)
+		l2nat_dev_hold(l2nat);
+	rcu_read_unlock();
+
+	return l2nat;
+}
+
+/* remove a netdevice from the l2nat list */
+int l2nat_dev_del(struct net_device *dev)
+{
+	struct l2nat_dev *l2nat = l2nat_dev_get(dev);
+
+	if (!l2nat)
+		return -ENODEV;
+
+	l2n_info("deleting l2nat dev for %s\n", dev->name);
+
+	spin_lock_bh(&list_lock);
+	list_del_rcu(&l2nat->list);
+	l2nat_dev_disable_hash(l2nat);
+	spin_unlock_bh(&list_lock);
+
+	l2nat_hash_flush_sync(l2nat);
+
+	/* remove the reference that we just took */
+	l2nat_dev_put(l2nat);
+
+	call_rcu(&l2nat->rcu, l2nat_dev_free_rcu);
+
+	return 0;
+}
+
+/* add a netdevice to the l2nat list */
+int l2nat_dev_add(struct net_device *dev)
+{
+
+	int ret = 0;
+	struct l2nat_dev *l2nat;
+
+	if (!dev)
+		return -ENODEV;
+
+	l2n_dbg_dev("trying to add l2nat dev for %s\n", dev->name);
+
+	if (!(dev->priv_flags & IFF_BRIDGE_PORT)) {
+		l2n_warn("device %s is not bridged, aborting\n", dev->name);
+		return -EINVAL;
+	}
+
+	l2nat = l2nat_dev_get(dev);
+	if (l2nat) {
+		l2n_warn("l2nat dev %s already added\n", dev->name);
+		l2nat_dev_put(l2nat);
+		return -EEXIST;
+	}
+
+	l2nat = kzalloc(sizeof(struct l2nat_dev), GFP_KERNEL);
+	if (!l2nat) {
+		l2n_err("no memory for adding l2nat dev %s\n", dev->name);
+		ret = -ENOMEM;
+		goto alloc_fail;
+	}
+
+	dev_hold(dev);
+	l2nat->dev = dev;
+
+	ret = l2nat_dev_init(l2nat);
+	if (ret) {
+		l2n_err("l2nat_dev_init failed for dev %s\n", dev->name);
+		goto init_fail;
+	}
+
+	atomic_inc(&dev_count);
+
+	spin_lock_bh(&list_lock);
+	list_add_rcu(&l2nat->list, &dev_list);
+	spin_unlock_bh(&list_lock);
+
+	l2n_info("added l2nat dev for %s\n", dev->name);
+
+	return ret;
+
+init_fail:
+	dev_put(l2nat->dev);
+	kfree(l2nat);
+alloc_fail:
+	return ret;
+}
+
+/* initialize l2net netdev list */
+void l2nat_dev_list_init(void)
+{
+	INIT_LIST_HEAD(&dev_list);
+	spin_lock_init(&list_lock);
+	init_waitqueue_head(&wq);
+
+	l2n_dbg_dev("initialized l2nat dev list\n");
+}
+
+/* uninitialize l2net netdev list */
+void l2nat_dev_list_exit(void)
+{
+	l2nat_dev_list_flush();
+
+	l2n_dbg_dev("exiting l2nat dev list - waiting for mem to be freed\n");
+	/* wait for all memory to be freed */
+	wait_event_interruptible(wq, atomic_read(&dev_count) == 0);
+
+	l2n_dbg_dev("exited l2nat dev list\n");
+}
diff --git a/drivers/net/l2nat/l2nat_hash.c b/drivers/net/l2nat/l2nat_hash.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/l2nat/l2nat_hash.c
@@ -0,0 +1,288 @@
+/*
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+*/
+
+#define pr_fmt(fmt) "L2NAT:%s:%d " fmt, __func__, __LINE__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/kref.h>
+#include <linux/netdevice.h>
+#include "l2nat.h"
+
+/* search for an ip-MAC mapping entry, should be called with rcu_read_lock() */
+static struct hash_entry *l2nat_entry_get_rcu(struct l2nat_dev *l2nat,
+					       __be32 ip)
+{
+	struct hash_entry *ent;
+	hash_for_each_possible_rcu(l2nat->hash, ent, hlist, ntohl(ip)) {
+		if (ent->ip == ip)
+			return ent;
+	}
+
+	return NULL;
+}
+
+/* search for an ip-MAC mapping entry in the hash table */
+struct hash_entry *l2nat_entry_get(struct l2nat_dev *l2nat, __be32 ip)
+{
+	struct hash_entry *ent;
+
+	rcu_read_lock();
+	ent = l2nat_entry_get_rcu(l2nat, ip);
+	if (ent)
+		l2nat_entry_hold(ent);
+	rcu_read_unlock();
+
+	return ent;
+}
+
+/* free an ip-MAC mapping entry */
+void l2nat_entry_release(struct kref *kref)
+{
+	struct hash_entry *ent = container_of(kref, struct hash_entry, kref);
+	struct l2nat_dev *l2nat = ent->l2nat;
+	del_timer(&ent->timer);
+
+	l2n_dbg_hash("%s: freeing entry %pI4 %pM\n", l2nat->dev->name,
+		     &ent->ip, &ent->mac);
+
+	l2nat->stats.entries_del++;
+
+	kfree(ent);
+	atomic_dec(&l2nat->ent_count);
+
+	/* wake up anyone waiting for all entries to release */
+	wake_up_interruptible(&l2nat->wq);
+	l2nat_dev_put(l2nat);
+}
+
+/* put an ip-MAC mapping entry for the hash, called from call_rcu */
+static void l2nat_entry_free_rcu(struct rcu_head *rcu)
+{
+	struct hash_entry *ent = container_of(rcu, struct hash_entry, rcu);
+	l2nat_entry_put(ent);
+}
+
+/* delete ip-MAC mapping entry, should be locked by l2nat->lock */
+static void __l2nat_entry_del(struct hash_entry *ent)
+{
+	l2n_dbg_hash("%s: deleting entry %pI4 %pM\n", ent->l2nat->dev->name,
+	    &ent->ip, &ent->mac);
+
+	hash_del_rcu(&ent->hlist);
+	call_rcu(&ent->rcu, l2nat_entry_free_rcu);
+
+	/* entry has a pending timer, force it to expire to relase the
+	 * counter reference.
+	 * note - a running timer is not pending */
+	if (timer_pending(&ent->timer))
+		mod_timer(&ent->timer, jiffies);
+}
+
+/* flush all ip-MAC mapping entries */
+void l2nat_hash_flush(struct l2nat_dev *l2nat)
+{
+	int i;
+	struct hash_entry *ent;
+	struct hlist_node *tmp;
+
+	l2n_dbg_hash("flushing entries for %s\n", l2nat->dev->name);
+
+	spin_lock_bh(&l2nat->lock);
+	hash_for_each_safe(l2nat->hash, i, tmp, ent, hlist)
+		__l2nat_entry_del(ent);
+	spin_unlock_bh(&l2nat->lock);
+}
+
+/* flush all ip-MAC mapping entries, and wait for them to be freed */
+void l2nat_hash_flush_sync(struct l2nat_dev *l2nat)
+{
+	l2nat_hash_flush(l2nat);
+
+	l2n_dbg_hash("waiting for entries to be freed\n");
+	wait_event_interruptible(l2nat->wq,
+				 atomic_read(&l2nat->ent_count) == 0);
+}
+
+/* initialize a new ip-MAC mapping entry */
+static inline void l2nat_entry_init(struct l2nat_dev *l2nat,
+				    struct hash_entry *ent, __be32 ip, u8 *mac)
+{
+	ent->ip = ip;
+	memcpy(&ent->mac, mac, ETH_ALEN);
+	atomic_long_set(&ent->last_pkt_timestamp, jiffies);
+	ent->first_pkt_timestamp = jiffies;
+	ent->tx_packets++;
+	ent->l2nat = l2nat;
+	l2nat_dev_hold(l2nat);
+	kref_init(&ent->kref);
+	init_timer(&ent->timer);
+	ent->timer.function = entry_aging_timer_fn;
+	ent->timer.data = (unsigned long)ent;
+	INIT_HLIST_NODE(&ent->hlist);
+	atomic_inc(&l2nat->ent_count);
+
+	l2n_dbg_hash("%s: initialized entry %pI4 %pM\n", l2nat->dev->name, &ip,
+		     mac);
+}
+
+/*
+ * check for an ip-MAC mapping entry,
+ * if it is new - add it to the hash table
+ * if it exists - update timestamp
+ * if it exists but mac address changed - replace with new entry
+ */
+int l2nat_entry_check_add(struct l2nat_dev *l2nat, __be32 ip,
+			  unsigned char *mac)
+{
+	int ret = 0;
+	struct hash_entry *old_e, *new_e;
+	unsigned long interval;
+
+	if (unlikely(!ip))
+		return 0;
+
+	if (unlikely(!l2nat->hash_en))
+		return 0;
+
+	old_e = l2nat_entry_get(l2nat, ip);
+
+	/* entry exists and mac did not change */
+	if (likely(old_e && !memcmp(old_e->mac, mac, ETH_ALEN)))
+		goto update_entry;
+
+	new_e = kzalloc(sizeof(*new_e), GFP_ATOMIC);
+	if (!new_e) {
+		l2n_err("%s: failed to allocate entry! %pI4 %pM\n",
+			l2nat->dev->name, &ip, &mac);
+		return -1;
+	}
+
+	l2nat_entry_init(l2nat, new_e, ip, mac);
+
+	spin_lock_bh(&l2nat->lock);
+
+	hash_add_rcu(l2nat->hash, &new_e->hlist, ntohl(ip));
+
+	/* mac address changed, replace old entry with new one */
+	if (old_e && hash_hashed(&old_e->hlist))
+		__l2nat_entry_del(old_e);
+
+	spin_unlock_bh(&l2nat->lock);
+
+
+	l2n_dbg_hash("%s: added entry %pI4 %pM\n", l2nat->dev->name, &ip, mac);
+
+	if (l2nat->aging_timeout) {
+		/* take extra ref for timer */
+		l2nat_entry_hold(new_e);
+		interval = l2nat->aging_timeout -
+			   HZ * (L2NAT_AGING_WAIT_INFO + L2NAT_AGING_WAIT_ARP);
+		mod_timer(&new_e->timer, jiffies + interval);
+	}
+
+	/* release the entry we just took */
+	if (old_e)
+		l2nat_entry_put(old_e);
+
+	l2nat->stats.entries_add++;
+
+	return ret;
+
+update_entry:
+	atomic_long_set(&old_e->last_pkt_timestamp, jiffies);
+	old_e->tx_packets++;
+	l2nat_entry_put(old_e);
+	return ret;
+}
+
+/* ip-MAC mapping entry timer timeout handling */
+void entry_aging_timer_fn(unsigned long data)
+{
+	struct hash_entry *ent = (struct hash_entry *)data;
+	unsigned long delta, next_time_offset, send_arp_timeout;
+	unsigned long get_info_timeout;
+	struct l2nat_dev *l2nat = ent->l2nat;
+
+	spin_lock_bh(&l2nat->lock);
+
+	/* entry was removed by someone, release timer reference */
+	if (!hash_hashed(&ent->hlist)) {
+		l2nat_entry_put(ent);
+		goto done;
+	}
+
+	delta = last_packet_delta(ent);
+	send_arp_timeout = l2nat->aging_timeout - L2NAT_AGING_WAIT_ARP * HZ;
+	get_info_timeout = send_arp_timeout - L2NAT_AGING_WAIT_INFO * HZ;
+
+	/* delete entry if its inactive longer than allowed */
+	if (delta >= l2nat->aging_timeout) {
+		l2n_dbg_tmr("timer deleting entry %pI4 inactive %u sec\n",
+			    &ent->ip,
+			    jiffies_to_msecs(last_packet_delta(ent)) / 1000);
+
+		__l2nat_entry_del(ent);
+		l2nat_entry_put(ent);
+		goto done;
+	}
+
+	if (delta < get_info_timeout) {
+		/* no need for any actions, reschedule on the moment
+		 * of next arp attempt, clear waiting flags if any.
+		 */
+		next_time_offset = get_info_timeout - delta;
+		l2n_dbg_tmr("timer entry %pI4 active, offset %lu, delta %lu\n",
+		    &ent->ip, next_time_offset, delta);
+
+		goto modify_out;
+	}
+
+	if (delta < send_arp_timeout) {
+		atomic_set(&l2nat->arp_info_needed, 1);
+		next_time_offset = L2NAT_AGING_WAIT_INFO * HZ;
+		l2n_dbg_tmr("timer req arp to %pI4, offset %lu, delta %lu\n",
+			    &ent->ip, next_time_offset, delta);
+
+		goto modify_out;
+	}
+
+	next_time_offset = L2NAT_AGING_WAIT_ARP * HZ;
+
+	/* only send arp if info is not stale */
+	if (jiffies - l2nat->last_arp_info_ts <= L2NAT_AGING_WAIT_INFO * HZ) {
+		__gen_fake_arp_req(l2nat, l2nat->ip_for_arp, l2nat->mac_for_arp,
+				   ent->ip);
+
+		l2n_dbg_tmr("timer sent arp to %pI4 offset %lu\n", &ent->ip,
+			    next_time_offset);
+	}
+
+modify_out:
+	mod_timer(&ent->timer, jiffies + next_time_offset);
+done:
+	spin_unlock_bh(&l2nat->lock);
+}
diff --git a/drivers/net/l2nat/l2nat_proc.c b/drivers/net/l2nat/l2nat_proc.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/l2nat/l2nat_proc.c
@@ -0,0 +1,581 @@
+/*
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+*/
+
+#define pr_fmt(fmt) "L2NAT:%s:%d " fmt, __func__, __LINE__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <net/net_namespace.h>
+#include "l2nat.h"
+
+#define L2NAT_DIR_NAME "l2nat"
+
+static struct proc_dir_entry *l2nat_dir;
+
+unsigned int dbg_flags = (L2N_ERR | L2N_WARN | L2N_DBG_INFO);
+
+unsigned long dbg_val[] = {
+	L2N_DBG_HASH,
+	L2N_DBG_TX,
+	L2N_DBG_RX,
+	L2N_DBG_TMR,
+	L2N_DBG_DHCP,
+	L2N_DBG_DEV,
+	L2N_DBG_DBG,
+	L2N_DBG_INFO,
+	L2N_WARN,
+	L2N_ERR,
+};
+
+char *dbg_str[] = {
+	"hash",		/* L2N_DBG_HASH */
+	"tx",		/* L2N_DBG_TX */
+	"rx",		/* L2N_DBG_RX */
+	"timer",	/* L2N_DBG_TMR */
+	"dhcp",		/* L2N_DBG_DHCP */
+	"devices",	/* L2N_DBG_DEV */
+	"genral_dbg",	/* L2N_DBG_DBG */
+	"info",		/* L2N_DBG_INFO */
+	"warning",	/* L2N_WARN */
+	"error",	/* L2N_ERR */
+};
+
+/************************************************************************/
+/* global_stats:							*/
+/* read: show l2nat module stats					*/
+/* write 0: clear l2nat module stats					*/
+/************************************************************************/
+static ssize_t gstats_seq_write(struct file *fp, const char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	unsigned char tmp[4];
+	int op;
+
+	if (count > 4)
+		return -EINVAL;
+
+	if (copy_from_user(tmp, buf, count))
+		return -EFAULT;
+
+	sscanf(tmp, "%d", &op);
+
+	if (op)
+		goto done;
+
+	memset(&glbl_stats, 0, sizeof(struct l2nat_global_stats));
+
+done:
+	return count;
+}
+
+static int gstats_seq_read(struct seq_file *m, void *v)
+{
+
+	seq_printf(m, "hooks_registered  %12d\n", hooks_registered);
+
+	seq_printf(m, "\n");
+
+	seq_printf(m, "preroute         [%12llu]\n", glbl_stats.preroute);
+	seq_printf(m, "postroute        [%12llu]\n", glbl_stats.postroute);
+
+	return 0;
+}
+
+static int gstats_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, gstats_seq_read, NULL);
+}
+
+static const struct file_operations gstats_fops = {
+	.open		= gstats_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= gstats_seq_write
+};
+
+/************************************************************************/
+/* dev:									*/
+/* read: show all l2nat-enabled devices					*/
+/* write:								*/
+/*	add <dev name>: enable l2nat on specified device		*/
+/*	del <dev name>: disable l2nat on specified device		*/
+/************************************************************************/
+static ssize_t devs_seq_write(struct file *fp, const char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	unsigned char tmp[64];
+	unsigned char cmd[64];
+	unsigned char devname[64];
+	struct net *net;
+	struct net_device *dev;
+	enum {DEV_ADD, DEV_DEL} op;
+
+	if (count > 64)
+		return -EINVAL;
+
+	if (copy_from_user(tmp, buf, count))
+		return -EFAULT;
+
+	sscanf(tmp, "%s %s", cmd, devname);
+
+	if (!strncmp(cmd, "add", strlen("add")))
+		op = DEV_ADD;
+	else if (!strncmp(cmd, "del", strlen("del")))
+		op = DEV_DEL;
+	else
+		goto done;
+
+	for_each_net(net) {
+		dev = dev_get_by_name(net, devname);
+		if (dev)
+			break;
+	}
+
+	if (dev && op == DEV_ADD)
+		l2nat_add_device(dev);
+	else if (dev && op == DEV_DEL)
+		l2nat_del_device(dev);
+	else if (!dev)
+		return -ENODEV;
+
+	dev_put(dev);
+done:
+	return count;
+}
+
+static void l2nat_dev_show(struct l2nat_dev *l2nat, void *arg)
+{
+	struct seq_file *m = (struct seq_file *)arg;
+
+	seq_printf(m,
+		"%-16s %-23pM ref:%-6d aging_timeout:%-6u entries:%-10d\n",
+		l2nat->dev->name,
+		l2nat->dev->dev_addr,
+		atomic_read(&l2nat->kref.refcount),
+		l2nat->aging_timeout / HZ,
+		atomic_read(&l2nat->ent_count));
+}
+
+static int devs_seq_read(struct seq_file *m, void *v)
+{
+	l2nat_dev_foreach(&l2nat_dev_show, (void *)m);
+	return 0;
+}
+
+static int devs_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, devs_seq_read, NULL);
+}
+
+static const struct file_operations devs_fops = {
+	.open		= devs_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= devs_seq_write
+};
+
+/************************************************************************/
+/* dbg:									*/
+/* read: show current enabled debug print flags in module		*/
+/* write <dbg flag>: toggle specified debug print flag			*/
+/************************************************************************/
+static ssize_t dbg_seq_write(struct file *fp, const char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	int i;
+	unsigned char tmp[64];
+	unsigned char dbg_op[64];
+
+	if (count > 64)
+		return -EINVAL;
+
+	if (copy_from_user(tmp, buf, count))
+		return -EFAULT;
+
+	sscanf(tmp, "%s", dbg_op);
+
+	for (i = 0; i < ARRAY_SIZE(dbg_str); i++) {
+		if (!strcmp(dbg_op, dbg_str[i])) {
+			dbg_flags ^= dbg_val[i];
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(dbg_str))
+		return -EINVAL;
+
+	return count;
+}
+
+static int dbg_seq_read(struct seq_file *m, void *v)
+{
+
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dbg_val); i++) {
+		if (dbg_flags & dbg_val[i])
+			seq_printf(m, "%-20s on\n", dbg_str[i]);
+		else
+			seq_printf(m, "%-20s off\n", dbg_str[i]);
+	}
+
+	return 0;
+}
+
+static int dbg_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, dbg_seq_read, NULL);
+}
+
+static const struct file_operations dbg_fops = {
+	.open		= dbg_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= dbg_seq_write
+};
+
+/************************************************************************/
+/* stats:								*/
+/* read: show per device statistics					*/
+/* write 0: clear per device statistics					*/
+/************************************************************************/
+static void l2nat_dev_stats_clear(struct l2nat_dev *l2nat, void *arg)
+{
+	memset(&l2nat->stats, 0, sizeof(l2nat->stats));
+}
+
+static ssize_t stats_seq_write(struct file *fp, const char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	unsigned char tmp[4];
+	int cmd;
+
+	if (count > 4)
+		return -EINVAL;
+
+	if (copy_from_user(tmp, buf, count))
+		return -EFAULT;
+
+	sscanf(tmp, "%d", &cmd);
+
+	if (cmd)
+		goto done;
+
+	l2nat_dev_foreach(&l2nat_dev_stats_clear, NULL);
+
+done:
+	return count;
+}
+
+static void l2nat_dev_stats_show(struct l2nat_dev *l2nat, void *arg)
+{
+	struct seq_file *m = (struct seq_file *)arg;
+	struct l2nat_dev_stats *stats = &l2nat->stats;
+
+	seq_printf(m, "%s:\n", l2nat->dev->name);
+	seq_printf(m, "rx_packets       [%12llu]\n", stats->rx_packets);
+	seq_printf(m, "rx_bytes         [%12llu]\n", stats->rx_bytes);
+	seq_printf(m, "rx_dropped       [%12llu]\n", stats->rx_dropped);
+	seq_printf(m, "rx_arp           [%12llu]\n", stats->rx_arp);
+
+	seq_printf(m, "\n");
+
+	seq_printf(m, "tx_packets       [%12llu]\n", stats->tx_packets);
+	seq_printf(m, "tx_bytes         [%12llu]\n", stats->tx_bytes);
+	seq_printf(m, "tx_dropped       [%12llu]\n", stats->tx_dropped);
+	seq_printf(m, "tx_arp           [%12llu]\n", stats->tx_arp);
+
+	seq_printf(m, "\n");
+
+	seq_printf(m, "arp_gen          [%12llu]\n", stats->arp_gen);
+	seq_printf(m, "dhcp             [%12llu]\n", stats->dhcp);
+	seq_printf(m, "entries_add      [%12llu]\n", stats->entries_add);
+	seq_printf(m, "entries_del      [%12llu]\n", stats->entries_del);
+	seq_printf(m, "\n");
+	seq_printf(m, "\n");
+}
+
+static int stats_seq_read(struct seq_file *m, void *v)
+{
+	l2nat_dev_foreach(&l2nat_dev_stats_show, (void *)m);
+
+	return 0;
+}
+
+static int stats_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, stats_seq_read, NULL);
+}
+
+static const struct file_operations stats_fops = {
+	.open		= stats_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= stats_seq_write
+};
+
+/************************************************************************/
+/* aging_timeout:							*/
+/* read: show ip-MAC entry aging timeout				*/
+/* write: clear ip-MAC entry aging timeout				*/
+/************************************************************************/
+static void l2nat_set_aging_to(struct l2nat_dev *l2nat, void *arg)
+{
+	l2nat->aging_timeout = *(u32 *)arg;
+}
+
+static ssize_t aging_to_seq_write(struct file *fp, const char __user *buf,
+					size_t count, loff_t *ppos)
+{
+	unsigned char tmp[16];
+	u32 new_aging_timeout = 0;
+	if (count > 16)
+		return -EINVAL;
+
+	if (copy_from_user(tmp, buf, count))
+		return -EFAULT;
+
+	sscanf(tmp, "%u", &new_aging_timeout);
+
+	aging_timeout = new_aging_timeout * HZ;
+
+	l2nat_dev_foreach(&l2nat_set_aging_to, (void *)&aging_timeout);
+
+	return count;
+}
+
+static int aging_to_seq_read(struct seq_file *m, void *v)
+{
+	seq_printf(m, "%d\n", aging_timeout / HZ);
+	return 0;
+}
+
+static int aging_to_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, aging_to_seq_read, NULL);
+}
+
+static const struct file_operations aging_to_fops = {
+	.open		= aging_to_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= aging_to_seq_write
+};
+
+/************************************************************************/
+/* hash:								*/
+/* read: show ip-MAC hashtable for all devices				*/
+/* write 0: clear ip-MAC hashtable for all devices			*/
+/************************************************************************/
+struct hash_seq_priv {
+	struct list_head ent_list;
+	int counter;
+};
+
+static void l2nat_dev_hash_clear(struct l2nat_dev *l2nat, void *arg)
+{
+	l2nat_hash_flush(l2nat);
+}
+
+static ssize_t hash_seq_write(struct file *fp, const char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	unsigned char tmp[4];
+	int cmd;
+
+	if (count > 4)
+		return -EINVAL;
+
+	if (copy_from_user(tmp, buf, count))
+		return -EFAULT;
+
+	sscanf(tmp, "%d", &cmd);
+
+	if (cmd)
+		goto done;
+
+	l2nat_dev_foreach(&l2nat_dev_hash_clear, NULL);
+
+done:
+	return count;
+}
+
+static void *hash_seq_start(struct seq_file *m, loff_t *pos)
+{
+	struct hash_seq_priv *priv = (struct hash_seq_priv *)m->private;
+	return seq_list_start(&priv->ent_list, *pos);
+}
+
+static void *hash_seq_next(struct seq_file *m, void *p, loff_t *pos)
+{
+	struct hash_seq_priv *priv = (struct hash_seq_priv *)m->private;
+	return seq_list_next(p, &priv->ent_list, pos);
+}
+
+static void hash_seq_stop(struct seq_file *m, void *p)
+{
+}
+
+static int hash_seq_show(struct seq_file *m, void *p)
+{
+	struct hash_seq_priv *priv = (struct hash_seq_priv *)m->private;
+	struct hash_entry *ent = list_entry(p, struct hash_entry, seqlist);
+
+	seq_printf(m,
+		"%-3d] %-7s %-16pI4 %pM   ref %d idle %-3d tx %llu rx %llu\n",
+		priv->counter++,
+		ent->l2nat->dev->name,
+		&ent->ip,
+		&ent->mac,
+		/* remove 1 ref since the proc iteration itself takes a ref*/
+		atomic_read(&ent->kref.refcount) - 1,
+		jiffies_to_msecs(last_packet_delta(ent)) / 1000,
+		ent->tx_packets,
+		ent->rx_packets);
+
+	return 0;
+}
+
+static const struct seq_operations hash_seq_ops = {
+	.start = hash_seq_start,
+	.next = hash_seq_next,
+	.stop = hash_seq_stop,
+	.show  = hash_seq_show,
+};
+
+static void l2nat_dev_release_entries(struct l2nat_dev *l2nat, void *arg)
+{
+	struct hash_entry *ent;
+	struct list_head *itr, *tmp;
+	struct list_head *ent_list = (struct list_head *)arg;
+
+	list_for_each_safe(itr, tmp, ent_list) {
+		ent = list_entry(itr, struct hash_entry, seqlist);
+		list_del(&ent->seqlist);
+		l2nat_entry_put(ent);
+	}
+}
+
+int hash_seq_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct hash_seq_priv *priv = (struct hash_seq_priv *)seq->private;
+
+	l2nat_dev_foreach(&l2nat_dev_release_entries, (void *)&priv->ent_list);
+
+	return seq_release_private(inode, file);
+}
+
+static void l2nat_dev_collect_entries(struct l2nat_dev *l2nat, void *arg)
+{
+	int i;
+	struct hash_entry *ent;
+	struct list_head *ent_list = (struct list_head *)arg;
+
+	rcu_read_lock();
+	hash_for_each_rcu(l2nat->hash, i, ent, hlist) {
+		l2nat_entry_hold(ent);
+		INIT_LIST_HEAD(&ent->seqlist);
+		list_add_tail(&ent->seqlist, ent_list);
+	}
+	rcu_read_unlock();
+}
+
+static int hash_seq_open(struct inode *inode, struct file *file)
+{
+	struct hash_seq_priv *priv;
+
+	priv = __seq_open_private(file, &hash_seq_ops, sizeof(*priv));
+	if (!priv)
+		return -ENOMEM;
+
+	priv->counter = 0;
+	INIT_LIST_HEAD(&priv->ent_list);
+
+	l2nat_dev_foreach(&l2nat_dev_collect_entries, (void *)&priv->ent_list);
+
+	return 0;
+}
+
+static const struct file_operations hash_fops = {
+	.open		= hash_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= hash_seq_release,
+	.write		= hash_seq_write
+};
+
+void l2nat_proc_init(void)
+{
+	l2nat_dir = proc_mkdir(L2NAT_DIR_NAME, NULL);
+	if (!l2nat_dir) {
+		l2n_err("proc_mkdir failed\n");
+		return;
+	}
+
+	if (!proc_create("global_stats" , 0, l2nat_dir, &gstats_fops)) {
+		l2n_err("proc_create failed\n");
+		return;
+	}
+
+	if (!proc_create("dev" , 0, l2nat_dir, &devs_fops)) {
+		l2n_err("proc_create failed\n");
+		return;
+	}
+
+	if (!proc_create("dbg" , 0, l2nat_dir, &dbg_fops)) {
+		l2n_err("proc_create failed\n");
+		return;
+	}
+
+	if (!proc_create("stats" , 0, l2nat_dir, &stats_fops)) {
+		l2n_err("proc_create failed\n");
+		return;
+	}
+
+	if (!proc_create("aging_timeout" , 0, l2nat_dir, &aging_to_fops)) {
+		l2n_err("proc_create failed\n");
+		return;
+	}
+
+	if (!proc_create("hash" , 0, l2nat_dir, &hash_fops)) {
+		l2n_err("proc_create failed\n");
+		return;
+	}
+}
+
+void l2nat_proc_exit(void)
+{
+	proc_remove(l2nat_dir);
+}
