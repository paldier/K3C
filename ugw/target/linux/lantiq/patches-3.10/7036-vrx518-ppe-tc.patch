# HG changeset patch
# Parent 0308a003084c31bc3134aad8b33443c72ad9e439

diff --git a/drivers/net/ethernet/intel/vrx518/tc/Kconfig b/drivers/net/ethernet/intel/vrx518/tc/Kconfig
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/Kconfig
@@ -0,0 +1,36 @@
+#
+# Intel VRX518 TC driver configuration
+#
+choice
+    prompt "SoC Platform Selection"
+    depends on VRX518_TC
+    default VRX518_GRX500
+
+    config VRX518_GRX500
+       depends on SOC_GRX500_A21
+       bool "GRX500"
+       ---help---
+       This selection works on intel GRX5XX SoC platform
+       It requests datapath library, DMA driver, CBM driver and
+       UMT driver support.
+       It works without DC_DP function.
+
+    config VRX518_DC_DP
+       depends on LTQ_DIRECTCONNECT_DP
+       bool "DC_DP"
+       ---help---
+       This selection works on any platform which has DC_DP lib.
+       It should be able to work on any one of below mode:
+       1. fast path
+       2. directpath
+       3. CPU path
+
+    config VRX518_CPU
+       bool "CPU path"
+       ---help---
+       This selection works on any platform.
+       It has no dependency on any other library/function except linux kernel.
+
+       It still requires Intel MEI driver to make VRX518 DSL working.
+
+endchoice
diff --git a/drivers/net/ethernet/intel/vrx518/tc/Makefile b/drivers/net/ethernet/intel/vrx518/tc/Makefile
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/Makefile
@@ -0,0 +1,32 @@
+################################################################################
+#
+# Intel SmartPHY DSL PCIe TC driver
+# Copyright(c) 2016 Intel Corporation.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# The full GNU General Public License is included in this distribution in
+# the file called "COPYING".
+#
+################################################################################
+
+#
+# Makefile for the Intel(R) SmartPHY TC driver
+#
+
+obj-$(CONFIG_VRX518_TC) += vrx518_tc.o
+vrx518_tc-objs := ptm_tc.o atm_tc.o tc_api.o tc_proc.o tc_main.o
+ifneq ($(CONFIG_VRX518_GRX500),)
+	vrx518_tc-objs += platform/grx500_plat.o
+endif
diff --git a/drivers/net/ethernet/intel/vrx518/tc/atm_tc.c b/drivers/net/ethernet/intel/vrx518/tc/atm_tc.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/atm_tc.c
@@ -0,0 +1,3610 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+
+/*             Supported functions           */
+#define DEBUG
+#define pr_fmt(fmt) KBUILD_MODNAME ":%s : " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/atomic.h>
+#include <linux/uaccess.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/wait.h>
+#include <linux/seq_file.h>
+#include <linux/printk.h>
+#include <linux/etherdevice.h>
+#include <linux/atmdev.h>
+#include <linux/atmioc.h>
+#include <linux/skbuff.h>
+#include <net/dsl_tc.h>
+#include <net/datapath_proc_api.h>
+#include <linux/atm.h>
+#include <net/datapath_api.h>
+#include "inc/tc_main.h"
+#include "inc/reg_addr.h"
+#include "inc/tc_common.h"
+#include "inc/tc_api.h"
+#include "inc/reg_addr.h"
+#include "inc/atm_tc.h"
+#include "inc/tc_proc.h"
+#include "inc/fw/unified_qos_ds_base_vrx518_be.h"
+#include "inc/fw/vrx518_a1plus_addr_def.h"
+#include "inc/fw/vrx518_ds_be.h"
+#include "inc/fw/vrx518_ppe_fw.h"
+#include "inc/platform.h"
+#include <net/dc_ep.h>
+
+static void do_oam_tasklet(unsigned long);
+static DECLARE_TASKLET(g_oam_tasklet, do_oam_tasklet, 0);
+static struct atm_priv *g_atm_tc;
+static const char *g_atm_dev_name = "atm-device-0";
+/* tracking the number of ATM devices */
+#define CGU_BASE	0x3000
+#define CGU_CLKFSR	(CGU_BASE + 0x10)
+#define MAX_DATA_LEN	(DMA_PACKET_SZ - 32)
+
+
+static inline unsigned int pvc_num(void)
+{
+	return ATM_PVC_NUMBER;
+}
+
+/*Note: FW RXQ number is 16, TXQ number is 15 */
+static inline unsigned int txq_num(void)
+{
+	return ATM_PRIO_Q_NUM;
+}
+
+/* QSB in VRX518 is fixed as System CLK */
+static u32 get_qsb_clk(struct atm_priv *priv)
+{
+	u32 fpi_dvsn;
+	u32 sys_clk, ppe_clk;
+
+	fpi_dvsn = (tc_r32(CGU_CLKFSR) >> 28) & 0x03;
+	priv->ep->hw_ops->clk_get(priv->ep, &sys_clk, &ppe_clk);
+	sys_clk = sys_clk >> fpi_dvsn;
+
+	return sys_clk;
+}
+
+static void set_qsb_clk(struct atm_priv *priv, u32 div)
+{
+	u32 clk_val;
+	u32 divisor = 0;
+
+	if (div > 8) {
+		tc_dbg(priv->tc_priv, MSG_INIT,
+			"QSB CLK divisor invailid: %d\n", div);
+		return;
+	}
+
+	clk_val = tc_r32(CGU_CLKFSR);
+	for (; div > 1; div >>= 1)
+		divisor += 1;
+
+	clk_val |= divisor << 28;
+	tc_w32(clk_val, CGU_CLKFSR);
+}
+
+static void atm_free_tx_skb_vcc(struct sk_buff *skb)
+{
+	struct atm_vcc *vcc;
+
+	vcc = ATM_SKB(skb)->vcc;
+
+	if (vcc != NULL && vcc->pop != NULL)
+		vcc->pop(vcc, skb);
+	else
+		dev_kfree_skb_any(skb);
+}
+
+/* Description:
+ *    Enable/Disable HTU entries to capture OAM cell.
+ *  Input:
+ *    none
+ *  Output:
+ *    none
+ */
+static void validate_oam_htu_entry(struct atm_priv *priv, int en)
+{
+	struct htu_entry entry;
+	int i;
+
+	for (i = OAM_F4_SEG_HTU_ENTRY; i <= OAM_F5_HTU_ENTRY; i++) {
+		tc_mem_read(priv, &entry, fpi_addr(HTU_ENTRY_TBL(i)),
+			sizeof(entry));
+		entry.vld = en;
+		tc_mem_write(priv, fpi_addr(HTU_ENTRY_TBL(i)), &entry,
+			sizeof(entry));
+	}
+	/*  idle for a while to finish running HTU search   */
+	udelay(10);
+}
+
+/* Description:
+ *    Remove one entry from HTU table.
+ *  Input:
+ *    conn --- unsigned int, connection ID
+ *  Output:
+ *    none
+ */
+static void clear_htu_entry(struct atm_priv *priv, unsigned int conn)
+{
+	struct htu_entry entry;
+
+	tc_mem_read(priv, &entry,
+		fpi_addr(HTU_ENTRY_TBL(conn + OAM_HTU_ENTRY_NUMBER)),
+		sizeof(entry));
+	entry.vld = 0;
+	tc_mem_write(priv, fpi_addr(HTU_ENTRY_TBL(conn + OAM_HTU_ENTRY_NUMBER)),
+		&entry,	sizeof(entry));
+}
+
+/**
+ * valid- return 1
+ * invalid - return 0
+ */
+int conn_valid(unsigned int conn)
+{
+	if (conn < pvc_num())
+		return 1;
+	else
+		return 0;
+}
+
+/**
+ * Description:
+ *   Loop up for connection ID with virtual path ID.
+ * Input:
+ *   vpi --- unsigned int, virtual path ID
+ * Output:
+ *   total number of PVC: failed
+ *   connection ID: Success
+ */
+unsigned int find_vpi(unsigned int vpi)
+{
+	unsigned int i;
+	struct atm_pvc *conn = g_atm_tc->conn;
+	unsigned int max_pvc = pvc_num();
+
+	for (i = 0; i < max_pvc; i++)
+		if ((g_atm_tc->pvc_tbl & (1 << i)) != 0
+			&& conn[i].vcc != NULL
+			&& vpi == conn[i].vcc->vpi)
+			return i;
+
+	return max_pvc;
+}
+/**
+ *  Description:
+ *    Loop up for vpi and vci from given queue id.
+ *  Input:
+ *    vpi --- unsigned int, virtual path ID
+ *    vci --- unsigned int, virtual channel ID
+ *  Output:
+ *    success: 0
+ *    failed: -1
+ */
+unsigned int find_vpivci_from_queue_id(
+	unsigned int queue_id,
+	unsigned int *vpi,
+	unsigned int *vci)
+{
+	unsigned int i;
+	struct atm_pvc *conn = g_atm_tc->conn;
+	unsigned int max_pvc = pvc_num();
+
+	for (i = 0; i < max_pvc; i++)
+		if ((g_atm_tc->pvc_tbl & BIT(i))
+			&& conn[i].vcc != NULL &&
+			conn[i].sw_txq_tbl == BIT(queue_id)) {
+			*vpi = conn[i].vcc->vpi;
+			*vci = conn[i].vcc->vci;
+			return 0;
+		}
+	return -1;
+}
+/**
+ *  Description:
+ *    Loop up for connection ID with virtual path ID and virtual channel ID.
+ *  Input:
+ *    vpi --- unsigned int, virtual path ID
+ *    vci --- unsigned int, virtual channel ID
+ *  Output:
+ *    total number of PVC: failed
+ *    connection ID: Success
+ */
+unsigned int find_vpivci(unsigned int vpi, unsigned int vci)
+{
+	unsigned int i;
+	struct atm_pvc *conn = g_atm_tc->conn;
+	unsigned int max_pvc = pvc_num();
+
+	for (i = 0; i < max_pvc; i++)
+		if ((g_atm_tc->pvc_tbl & BIT(i))
+			&& conn[i].vcc != NULL
+			&& vpi == conn[i].vcc->vpi
+			&& vci == conn[i].vcc->vci)
+			return i;
+
+	return max_pvc;
+}
+
+/*  Description:
+ *    Loop up for connection ID with atm_vcc structure.
+ *  Input:
+ *    vcc --- struct atm_vcc *, atm_vcc structure of opened connection
+ *  Output:
+ *    total number of PVC: failed
+ *    connection ID: Success
+ */
+static int find_vcc(struct atm_vcc *vcc)
+{
+	unsigned int i;
+	struct atm_priv *priv;
+	struct atm_pvc *conn;
+	unsigned int max_pvc = pvc_num();
+
+	if (!vcc) {
+		pr_err("%s : Invalid argument\n", __func__);
+		return max_pvc;
+	}
+
+	priv = g_atm_tc;
+	conn = priv->conn;
+
+	for (i = 0; i < max_pvc; i++)
+		if ((priv->pvc_tbl & (1 << i))
+			&& conn[i].vcc == vcc)
+			return i;
+
+	return max_pvc;
+}
+
+static inline void qsb_param_dbg(struct atm_priv *priv,
+		unsigned int qsb_clk,
+		union qsb_queue_parameter_table *q_parm_tbl,
+		union qsb_queue_vbr_parameter_table *q_vbr_parm_tbl)
+{
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"qsb_clk = %lu\n", (unsigned long)qsb_clk);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"qsb_queue_parameter_table.bit.tp       = %d\n",
+			(int)q_parm_tbl->bit.tp);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"qsb_queue_parameter_table.bit.wfqf     = %d (0x%08X)\n",
+			(int)q_parm_tbl->bit.wfqf,
+			(int)q_parm_tbl->bit.wfqf);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"qsb_queue_parameter_table.bit.vbr      = %d\n",
+			(int)q_parm_tbl->bit.vbr);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"qsb_queue_parameter_table.dword        = 0x%08X\n",
+			(int)q_parm_tbl->dword);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"qsb_queue_vbr_parameter_table.bit.ts   = %d\n",
+			(int)q_vbr_parm_tbl->bit.ts);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"qsb_queue_vbr_parameter_table.bit.taus = %d\n",
+			(int)q_vbr_parm_tbl->bit.taus);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"qsb_queue_vbr_parameter_table.dword    = 0x%08X\n",
+				(int)q_vbr_parm_tbl->dword);
+}
+
+/* Description:
+ *    Setup QSB queue.
+ *  Input:
+ *    vcc        --- struct atm_vcc *, structure of an opened connection
+ *    qos        --- struct atm_qos *, QoS parameter of the connection
+ *    connection --- unsigned int, QSB queue ID, which is same as connection ID
+ *  Output:
+ *    none
+ */
+static void set_qsb(struct atm_priv *priv, struct atm_vcc *vcc,
+		struct atm_qos *qos, unsigned int conn)
+{
+	union qsb_queue_parameter_table q_parm_tbl = { { 0 } };
+	union qsb_queue_vbr_parameter_table q_vbr_parm_tbl = { { 0 } };
+	unsigned int tmp, reg_val;
+	unsigned int qsb_clk;
+	struct tc_param *param;
+	int port;
+	unsigned int max_pcr;
+
+	if (!priv || !vcc || !qos) {
+		pr_err("%s : Invalid VCC/QoS/priv\n", __func__);
+		return;
+	}
+
+	qsb_clk = get_qsb_clk(priv);
+	param = &priv->tc_priv->param;
+	/* QSB cell delay variation due to concurrency */
+	param->qsb_tau   = 1;
+	/*  QSB scheduler burst length */
+	param->qsb_srvm  = 0x0F;
+	param->qsb_tstep = 4;
+	tc_dbg(priv->tc_priv, MSG_INIT, "%s\n", __func__);
+	/* qsb_qos_dbg(qos); */
+	conn += QSB_QUEUE_NUMBER_BASE; /* qsb qid = firmware qid + 1 */
+
+	/* Peak Cell Rate (PCR) Limiter */
+	if (qos->txtp.max_pcr == 0)
+		q_parm_tbl.bit.tp = 0; /* disable PCR limiter */
+	else {
+		/*  peak cell rate would be slightly lower than requested
+		 [maximum_rate / pcr = (qsb_clock / 8) * (time_step / 4) / pcr]
+		*/
+		tmp = ((qsb_clk * param->qsb_tstep) >> 5) / qos->txtp.max_pcr
+			+ 1;
+		/*  check if overflow takes place   */
+		q_parm_tbl.bit.tp
+			= tmp > QSB_TP_TS_MAX ? QSB_TP_TS_MAX : tmp;
+	}
+
+	/* A funny issue. Create two PVCs, one UBR and one UBR with max_pcr.
+	* Send packets to these two PVCs at same time,
+	* it triggers strange behavior.
+	* In A1, RAM from 0x80000000 to 0x0x8007FFFF was corrupted
+	* with fixed pattern 0x00000000 0x40000000.
+	* In A4, PPE firmware keep emiting unknown cell
+	* and no more response to driver.
+	* To work around, create UBR always with max_pcr.
+	* If user want to create UBR without max_pcr,
+	* we give a default one larger than line-rate.
+	*/
+	if (qos->txtp.traffic_class == ATM_UBR &&
+		q_parm_tbl.bit.tp == 0) {
+		port = priv->conn[conn - QSB_QUEUE_NUMBER_BASE].port;
+		max_pcr = priv->port[port].tx_max_cell_rate + 1000;
+
+		tmp = ((qsb_clk * param->qsb_tstep) >> 5) / max_pcr + 1;
+		if (tmp > QSB_TP_TS_MAX)
+			tmp = QSB_TP_TS_MAX;
+		else if (tmp < 1)
+			tmp = 1;
+		q_parm_tbl.bit.tp = tmp;
+	}
+
+	/* Weighted Fair Queueing Factor (WFQF) */
+	switch (qos->txtp.traffic_class) {
+	case ATM_CBR:
+	case ATM_VBR_RT:
+		/*  real time queue gets weighted fair queueing bypass  */
+		q_parm_tbl.bit.wfqf = 0;
+		break;
+	case ATM_VBR_NRT:
+	case ATM_UBR_PLUS:
+		/*  WFQF calculation here is based on virtual cell rates,
+		      to reduce granularity for high rates
+		*/
+		/*  WFQF is maximum cell rate / garenteed cell rate */
+		/*  wfqf = qsb_minimum_cell_rate * QSB_WFQ_NONUBR_MAX /
+			requested_minimum_peak_cell_rate
+		*/
+		if (qos->txtp.min_pcr == 0)
+			q_parm_tbl.bit.wfqf = QSB_WFQ_NONUBR_MAX;
+		else {
+			tmp = QSB_GCR_MIN * QSB_WFQ_NONUBR_MAX /
+				qos->txtp.min_pcr;
+			if (tmp == 0)
+				q_parm_tbl.bit.wfqf = 1;
+			else if (tmp > QSB_WFQ_NONUBR_MAX)
+				q_parm_tbl.bit.wfqf
+					= QSB_WFQ_NONUBR_MAX;
+			else
+				q_parm_tbl.bit.wfqf = tmp;
+		}
+		break;
+
+	case ATM_UBR:
+	default:
+		q_parm_tbl.bit.wfqf = QSB_WFQ_UBR_BYPASS;
+		break;
+	}
+
+	/* Sustained Cell Rate (SCR) Leaky Bucket Shaper VBR.0/VBR.1 */
+	if (qos->txtp.traffic_class == ATM_VBR_RT ||
+		qos->txtp.traffic_class == ATM_VBR_NRT) {
+		if (qos->txtp.scr == 0) {
+			/* disable shaper */
+			q_vbr_parm_tbl.bit.taus = 0;
+			q_vbr_parm_tbl.bit.ts = 0;
+		} else {
+			/* Cell Loss Priority  (CLP) */
+			if ((vcc->atm_options & ATM_ATMOPT_CLP))
+				/* CLP1 */
+				q_parm_tbl.bit.vbr = 1;
+			else
+				/* CLP0 */
+				q_parm_tbl.bit.vbr = 0;
+			/* Rate Shaper Parameter (TS) and
+			    Burst Tolerance Parameter for SCR (tauS)
+			*/
+			tmp = ((qsb_clk * param->qsb_tstep) >> 5) /
+					qos->txtp.scr + 1;
+			q_vbr_parm_tbl.bit.ts
+				= tmp > QSB_TP_TS_MAX ? QSB_TP_TS_MAX : tmp;
+			tmp = (qos->txtp.mbs - 1) *
+				(q_vbr_parm_tbl.bit.ts -
+					q_parm_tbl.bit.tp) / 64;
+			if (tmp == 0)
+				q_vbr_parm_tbl.bit.taus = 1;
+			else if (tmp > QSB_TAUS_MAX)
+				q_vbr_parm_tbl.bit.taus
+					= QSB_TAUS_MAX;
+			else
+				q_vbr_parm_tbl.bit.taus = tmp;
+		}
+	} else {
+		q_vbr_parm_tbl.bit.taus = 0;
+		q_vbr_parm_tbl.bit.ts = 0;
+	}
+
+	/* Queue Parameter Table (QPT) */
+	tc_w32(QSB_QPT_SET_MASK, QSB_RTM);
+	tc_w32(q_parm_tbl.dword, QSB_RTD);
+	reg_val = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) |
+			QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_QPT) |
+			QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) |
+			QSB_RAMAC_TESEL_SET(conn);
+	tc_w32(reg_val, QSB_RAMAC);
+
+	/* Queue VBR Paramter Table (QVPT) */
+	tc_w32(QSB_QVPT_SET_MASK, QSB_RTM);
+	tc_w32(q_vbr_parm_tbl.dword, QSB_RTD);
+	reg_val = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) |
+			QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_VBR) |
+			QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) |
+			QSB_RAMAC_TESEL_SET(conn);
+	tc_w32(reg_val, QSB_RAMAC);
+
+	qsb_param_dbg(priv, qsb_clk, &q_parm_tbl, &q_vbr_parm_tbl);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"QSB setting for conn: %d is done\n", conn - 1);
+}
+
+static void do_oam_tasklet(unsigned long arg)
+{
+	unsigned long sys_flag;
+	rx_descriptor_t desc;
+	struct uni_cell_header *header;
+	int ep_id;
+	struct atm_vcc *vcc;
+	desq_cfg_ctxt_t ds_oam_cfg_ctxt, local_oam_cfg_ctxt;
+	dma_addr_t phy_addr;
+	struct atm_priv *priv;
+	u32 conn, ds_oam_dbase, oam_idx, oam_max_num;
+	u32 mbox1_ier, rx_cnt, dq_cnt, *oam_dlist;
+
+	priv = g_atm_tc;
+	if (!priv) {
+		pr_err("%s : Invalid argument\n", __func__);
+		return;
+	}
+	ep_id = priv->ep_id;
+	oam_dlist = priv->oam_llst.oam_des_list;
+	oam_idx = priv->oam_llst.oam_idx;
+	oam_max_num = priv->oam_llst.oam_num;
+
+	tc_mem_read(priv, &ds_oam_cfg_ctxt,
+		fpi_addr(__DS_OAM_DESQ_CFG_CTXT), sizeof(ds_oam_cfg_ctxt));
+	ds_oam_dbase = ds_oam_cfg_ctxt.des_base_addr;
+	rx_cnt = ds_oam_cfg_ctxt.enq_pkt_cnt;
+	dq_cnt = ds_oam_cfg_ctxt.deq_pkt_cnt;
+
+	while (1) {
+		tc_mem_read(priv, &desc, fpi_addr(ds_oam_dbase + oam_idx * 2),
+				sizeof(desc));
+		if (desc.own == DS_OAM_DES_OWN) { /* desc not belong to CPU */
+			/* Update idx as will exit loop */
+			priv->oam_llst.oam_idx = oam_idx;
+			/* probe if there's still availble oam packet */
+			tc_mem_read(priv, &ds_oam_cfg_ctxt,
+				fpi_addr(__DS_OAM_DESQ_CFG_CTXT),
+				sizeof(ds_oam_cfg_ctxt));
+			tc_mem_write(priv,
+				fpi_addr(__DS_OAM_DESQ_CFG_CTXT +
+					offsetof(desq_cfg_ctxt_t,
+					deq_pkt_cnt) / sizeof(u32)),
+					&dq_cnt, sizeof(dq_cnt));
+			tc_mem_read(priv, &local_oam_cfg_ctxt,
+				fpi_addr(__DS_TC_OAM_LOCAL_Q_CFG_CTXT),
+				sizeof(local_oam_cfg_ctxt));
+			if ((local_oam_cfg_ctxt.enq_pkt_cnt !=
+					ds_oam_cfg_ctxt.enq_pkt_cnt) ||
+				(ds_oam_cfg_ctxt.enq_pkt_cnt !=
+					ds_oam_cfg_ctxt.deq_pkt_cnt))
+				tasklet_schedule(&g_oam_tasklet);
+			else {
+				/* No more oam pkt, should enable irq again */
+				spin_lock_irqsave(&priv->oam_lock, sys_flag);
+				mbox1_ier = tc_r32(MBOX_IGU_IER(MBOX_IGU1));
+				mbox_set_ier(priv, MBOX_IGU1,
+					mbox1_ier | MBOX_OAM_RX);
+				spin_unlock_irqrestore(&priv->oam_lock,
+							sys_flag);
+			}
+			break;
+		}
+
+		phy_addr = dma_map_single(priv->pdev,
+				(void *)oam_dlist[oam_idx],
+				ATM_OAM_SIZE, DMA_FROM_DEVICE);
+
+		dma_unmap_single(priv->pdev, phy_addr,
+				ATM_OAM_SIZE, DMA_FROM_DEVICE);
+
+		header = (struct uni_cell_header *)oam_dlist[oam_idx];
+
+		if (header->pti == ATM_PTI_SEGF5 ||
+			header->pti == ATM_PTI_E2EF5)
+			conn = find_vpivci(header->vpi, header->vci);
+		else if (header->vci == 0x03 || header->vci == 0x04)
+			conn = find_vpi(header->vpi);
+		else
+			conn = -1; /* invalid */
+
+		if (conn_valid(conn) && priv->conn[conn].vcc != NULL) {
+			vcc = priv->conn[conn].vcc;
+			priv->conn[conn].access_time = current_kernel_time();
+
+			tc_dbg(priv->tc_priv, MSG_OAM_RX, "conn=%d, vpi: %d, vci:%d\n",
+				conn, header->vpi, header->vci);
+			/* dump_oam_cell(header, 1); */
+			if (vcc->push_oam != NULL)
+				vcc->push_oam(vcc, header);
+			else {
+				#if IS_ENABLED(CONFIG_LTQ_OAM)
+					ifx_push_oam((unsigned char *)header);
+				#else
+					tc_dbg(priv->tc_priv, MSG_OAM_RX,
+						"Receive OAM packet\n");
+				#endif
+			}
+			priv->conn[conn].stats.oam_rx_pkts++;
+			priv->conn[conn].stats.oam_rx_bytes
+						+= desc.data_len;
+			priv->stats.oam_rx_pkts++;
+			priv->stats.oam_rx_bytes += desc.data_len;
+		} else {
+			priv->stats.oam_rx_errors++;
+		}
+
+		/* update desc */
+		desc.c = 0;
+		desc.own = DS_OAM_DES_OWN;
+		desc.data_len = ATM_OAM_SIZE;
+		tc_mem_write(priv, fpi_addr(ds_oam_dbase + oam_idx * 2), &desc,
+				sizeof(desc));
+
+		oam_idx = (oam_idx + 1) % oam_max_num;
+		dq_cnt++;
+	}
+}
+
+static void atm_umt_start(struct atm_priv *priv)
+{
+	priv->tc_priv->tc_ops.umt_start(0);
+}
+
+static void atm_aca_init(struct atm_priv *priv)
+{
+	struct aca_param param;
+	struct aca_modem_param mdm;
+	struct aca_cfg_param *txin;
+	struct aca_cfg_param *txout;
+	struct aca_cfg_param *rxout;
+	struct soc_cfg *cfg;
+	u32 phybase = priv->ep->phy_membase;
+	u32 stop;
+
+	memset(&param, 0, sizeof(param));
+	priv->tc_priv->tc_ops.soc_cfg_get(&priv->tc_priv->cfg, 0);
+	cfg = &priv->tc_priv->cfg;
+
+	txin = &param.aca_txin;
+	txin->byteswap = 1;
+	txin->hd_size_in_dw = cfg->desc_dw_sz;
+	txin->pd_desc_base = SB_XBAR_ADDR(__ACA_TX_IN_PD_LIST_BASE);
+	txin->pd_desc_num = __ACA_TX_IN_PD_LIST_NUM;
+	txin->pd_size_in_dw = DESC_DWSZ;
+	txin->soc_desc_base = cfg->txin_dbase;
+	txin->soc_desc_num = cfg->txin_dnum;
+	txin->pp_buf_desc_num = ACA_TXIN_HD_DESC_NUM;
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"txin: bswp: %d, hdsz:%d, pd: dbase(0x%x), dnum(%d)\n",
+		txin->byteswap, txin->hd_size_in_dw, txin->pd_desc_base,
+		txin->pd_desc_num);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"\t\tsz_indw(%d), soc_dbase:0x%x, soc_dnum:0x%x\n",
+		txin->pd_size_in_dw, txin->soc_desc_base, txin->soc_desc_num);
+	txout = &param.aca_txout;
+	txout->byteswap = 1;
+	txout->hd_size_in_dw = 1;
+	txout->pd_desc_base = SB_XBAR_ADDR(__ACA_TX_OUT_PD_LIST_BASE);
+	txout->pd_desc_num = __ACA_TX_OUT_PD_LIST_NUM;
+	txout->pd_size_in_dw = DESC_DWSZ;
+	txout->soc_desc_base = cfg->txout_dbase;
+	txout->soc_desc_num = cfg->txout_dnum;
+	txout->pp_buf_desc_num = ACA_TXOUT_HD_DESC_NUM;
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"txout: bswp: %d, hdsz:%d, pd: dbase(0x%x), dnum(%d)\n",
+		txout->byteswap, txout->hd_size_in_dw, txout->pd_desc_base,
+		txout->pd_desc_num);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"\tsz_indw(%d), soc_dbase:0x%x, soc_dnum:0x%x\n",
+		txout->pd_size_in_dw, txout->soc_desc_base,
+		txout->soc_desc_num);
+	rxout = &param.aca_rxout;
+	rxout->byteswap = 1;
+	rxout->hd_size_in_dw = cfg->desc_dw_sz;
+	rxout->pd_desc_base = SB_XBAR_ADDR(__ACA_RX_OUT_PD_LIST_BASE);
+	rxout->pd_desc_num = __ACA_RX_OUT_PD_LIST_NUM;
+	rxout->pd_size_in_dw = DESC_DWSZ;
+	rxout->soc_desc_base = cfg->rxout_dbase;
+	rxout->soc_desc_num = cfg->rxout_dnum;
+	rxout->pp_buf_desc_num = ACA_RXOUT_HD_DESC_NUM;
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"rxout: bswp: %d, hdsz:%d, pd: dbase(0x%x), dnum(%d)\n",
+		rxout->byteswap, rxout->hd_size_in_dw, rxout->pd_desc_base,
+		rxout->pd_desc_num);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"\tsz_indw(%d), soc_dbase:0x%x, soc_dnum:0x%x\n",
+		rxout->pd_size_in_dw,
+		rxout->soc_desc_base, rxout->soc_desc_num);
+
+	mdm.mdm_txout.stat
+		= SB_XBAR_ADDR(__TX_OUT_ACA_ACCUM_STATUS) | phybase;
+	mdm.mdm_txout.pd
+		= SB_XBAR_ADDR(__TX_OUT_QUEUE_PD_BASE_ADDR_OFFSET) | phybase;
+	mdm.mdm_txout.acc_cnt
+		= SB_XBAR_ADDR(__TX_OUT_ACA_ACCUM_COUNT) | phybase;
+
+	mdm.mdm_rxout.stat
+		= SB_XBAR_ADDR(__RX_OUT_ACA_ACCUM_STATUS) | phybase;
+	mdm.mdm_rxout.pd
+		= SB_XBAR_ADDR(__RX_OUT_QUEUE_PD_BASE_ADDR_OFFSET) | phybase;
+	mdm.mdm_rxout.acc_cnt
+		= SB_XBAR_ADDR(__RX_OUT_ACA_ACCUM_COUNT) | phybase;
+
+	mdm.mdm_rxin.stat
+		= SB_XBAR_ADDR(__RX_IN_ACA_ACCUM_STATUS) | phybase;
+	mdm.mdm_rxin.pd
+		= SB_XBAR_ADDR(__RX_IN_QUEUE_PD_BASE_ADDR_OFFSET) | phybase;
+	mdm.mdm_rxin.acc_cnt
+		= SB_XBAR_ADDR(__RX_IN_ACA_ACCUM_COUNT) | phybase;
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"txout: (stat:0x%x, pd: 0x%x, cnt: 0x%x)\n",
+		mdm.mdm_txout.stat, mdm.mdm_txout.pd, mdm.mdm_txout.acc_cnt);
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"rxout: (stat:0x%x, pd: 0x%x, cnt: 0x%x)\n",
+		mdm.mdm_rxout.stat, mdm.mdm_rxout.pd, mdm.mdm_rxout.acc_cnt);
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"rxin: (stat:0x%x, pd: 0x%x, cnt: 0x%x)\n",
+		mdm.mdm_rxin.stat, mdm.mdm_rxin.pd, mdm.mdm_rxin.acc_cnt);
+
+	priv->ep->hw_ops->aca_init(priv->ep, &param, &mdm);
+	stop = ACA_ALL_EN; /* ACA FW started all by default */
+	priv->ep->hw_ops->aca_stop(priv->ep, &stop, 0);
+	priv->ep->hw_ops->aca_start(priv->ep,
+		ACA_TXOUT_EN | ACA_RXIN_EN | ACA_RXOUT_EN, 1);
+}
+
+static int print_datetime(char *buffer, const struct timespec *datetime)
+{
+	struct timeval tv;
+	struct tm nowtm;
+	char tmbuf[64];
+	s64 nsec;
+
+	if (buffer == NULL || datetime == NULL) {
+		pr_err("%s : Invalid arguments\n", __func__);
+		return -1;
+	}
+	nsec = timespec_to_ns(datetime);
+	tv = ns_to_timeval(nsec);
+	time_to_tm(tv.tv_sec, 0, &nowtm);
+	memset(tmbuf, 0, 64);
+
+	snprintf(tmbuf, sizeof(tmbuf), "%ld-%d-%d %d:%d:%d",
+			1900 + nowtm.tm_year,
+			1 + nowtm.tm_mon,
+			nowtm.tm_mday,
+			nowtm.tm_hour,
+			nowtm.tm_min,
+			nowtm.tm_sec);
+	snprintf(buffer, sizeof(buffer), "%s.%06d", tmbuf, (int)tv.tv_usec);
+
+	return 0;
+}
+
+void print_stat_mib(struct seq_file *seq, struct atm_stats *stat)
+{
+	seq_printf(seq, "AAL5 RX PKTs:\t\t %llu\n", stat->aal5_rx_pkts);
+	seq_printf(seq, "AAL5 RX Bytes:\t\t %llu\n", stat->aal5_rx_bytes);
+	seq_printf(seq, "AAL5 RX Err:\t\t %llu\n", stat->aal5_rx_errors);
+	seq_printf(seq, "AAL5 RX Drop:\t\t %llu\n", stat->aal5_rx_dropped);
+
+	seq_printf(seq, "OAM  RX PKTs:\t\t %llu\n", stat->oam_rx_pkts);
+	seq_printf(seq, "OAM  RX Bytes:\t\t %llu\n", stat->oam_rx_bytes);
+	seq_printf(seq, "OAM  RX Err:\t\t %llu\n", stat->oam_rx_errors);
+	seq_printf(seq, "OAM  RX Drop:\t\t %llu\n", stat->oam_rx_dropped);
+
+	seq_printf(seq, "AAL5 TX PKTs:\t\t %llu\n", stat->aal5_tx_pkts);
+	seq_printf(seq, "AAL5 TX Bytes:\t\t %llu\n", stat->aal5_tx_bytes);
+	seq_printf(seq, "AAL5 TX Err:\t\t %llu\n", stat->aal5_tx_errors);
+	seq_printf(seq, "AAL5 TX Drop:\t\t %llu\n", stat->aal5_tx_dropped);
+
+	seq_printf(seq, "OAM  TX PKTs:\t\t %llu\n", stat->oam_tx_pkts);
+	seq_printf(seq, "OAM  TX Bytes:\t\t %llu\n", stat->oam_tx_bytes);
+	seq_printf(seq, "OAM  TX Err:\t\t %llu\n", stat->oam_tx_errors);
+	seq_printf(seq, "OAM  TX Drop:\t\t %llu\n\n", stat->oam_tx_dropped);
+}
+
+void print_drv_mib(struct seq_file *seq, struct atm_priv *priv)
+{
+	seq_puts(seq, "Driver Total MIB:\n");
+	print_stat_mib(seq, &(priv->stats));
+}
+static int atm_tc_stats(struct atm_priv *priv,
+	struct intel_tc_stats *stats
+)
+{
+	int i, vpi, vci;
+	struct intel_tc_atm_stats *atm_stats32;
+	if (!priv) {
+		pr_err("priv pointer is NULL!!!\n");
+		return -EINVAL;
+	}
+	atm_stats32 = &(stats->stats.atm_tc_stats);
+	stats->tc_info = TC_ATM_SL_MODE;
+	atm_stats32->wrx_drophtu_cell = sb_r32(__WRX_DROPHTU_CELL);
+	atm_stats32->wrx_dropdes_pdu = sb_r32(__WRX_DROPDES_PDU);
+	atm_stats32->wrx_correct_pdu = sb_r32(__WRX_CORRECT_PDU);
+	atm_stats32->wrx_err_pdu = sb_r32(__WRX_ERR_PDU);
+	atm_stats32->wrx_dropdes_cell = sb_r32(__WRX_DROPDES_CELL);
+	atm_stats32->wrx_correct_cell = sb_r32(__WRX_CORRECT_CELL);
+	atm_stats32->wrx_err_cell = sb_r32(__WRX_ERR_CELL);
+	atm_stats32->wrx_total_byte = sb_r32(__WRX_TOTAL_BYTE);
+	atm_stats32->wtx_total_pdu = sb_r32(__WTX_TOTAL_PDU);
+	atm_stats32->wtx_total_cell = sb_r32(__WTX_TOTAL_CELL);
+	atm_stats32->wtx_total_byte = sb_r32(__WTX_TOTAL_BYTE);
+	for (i = 0; i < txq_num(); i++) {
+		atm_stats32->rx_mib[i].valid =
+			priv->sw_txq_tbl & BIT(i);
+		if (atm_stats32->rx_mib[i].valid)
+			if (find_vpivci_from_queue_id(
+				i,
+				&vpi,
+				&vci) == 0) {
+				atm_stats32->rx_mib[i].vpi = vpi;
+				atm_stats32->rx_mib[i].vci = vci;
+			}
+
+		atm_stats32->rx_mib[i].idx = i;
+		atm_stats32->rx_mib[i].pdu = sb_r32(DSL_Q_RX_MIB_TBL(i));
+		atm_stats32->rx_mib[i].bytes =
+			sb_r32(DSL_Q_RX_MIB_TBL(i) + 1);
+	}
+	for (i = 0; i < txq_num(); i++) {
+		atm_stats32->tx_mib[i].valid =
+			priv->sw_txq_tbl & BIT(i);
+		if (atm_stats32->tx_mib[i].valid)
+			if (find_vpivci_from_queue_id(
+				i,
+				&vpi,
+				&vci) == 0) {
+				atm_stats32->tx_mib[i].vpi = vpi;
+				atm_stats32->tx_mib[i].vci = vci;
+			}
+		atm_stats32->tx_mib[i].idx = i;
+		atm_stats32->tx_mib[i].pdu = sb_r32(DSL_Q_TX_MIB_TBL(i));
+		atm_stats32->tx_mib[i].bytes =
+			sb_r32(DSL_Q_TX_MIB_TBL(i) + 1);
+	}
+
+	atm_stats32->aal5_rx_pkts = priv->stats.aal5_rx_pkts;
+	atm_stats32->aal5_rx_bytes = priv->stats.aal5_rx_bytes;
+	atm_stats32->aal5_rx_errors = priv->stats.aal5_rx_errors;
+	atm_stats32->aal5_rx_dropped = priv->stats.aal5_rx_dropped;
+	atm_stats32->oam_rx_pkts = priv->stats.oam_rx_pkts;
+	atm_stats32->oam_rx_bytes = priv->stats.oam_rx_bytes;
+	atm_stats32->oam_rx_errors = priv->stats.oam_rx_errors;
+	atm_stats32->oam_rx_dropped = priv->stats.oam_rx_dropped;
+	atm_stats32->aal5_tx_pkts = priv->stats.aal5_tx_pkts;
+	atm_stats32->aal5_tx_bytes = priv->stats.aal5_tx_bytes;
+	atm_stats32->aal5_tx_errors = priv->stats.aal5_tx_errors;
+	atm_stats32->aal5_tx_dropped = priv->stats.aal5_tx_dropped;
+	atm_stats32->oam_tx_pkts = priv->stats.oam_tx_pkts;
+	atm_stats32->oam_tx_bytes = priv->stats.oam_tx_bytes;
+	atm_stats32->oam_tx_errors = priv->stats.oam_tx_errors;
+	atm_stats32->oam_tx_dropped = priv->stats.oam_tx_dropped;
+	return 0;
+}
+int proc_read_atm_wanmib(struct seq_file *seq, void *v)
+{
+	struct intel_tc_stats stats;
+	struct intel_tc_atm_stats *atm_stat;
+	struct atm_priv *priv = (struct atm_priv *)seq->private;
+	int i;
+
+	if (!priv) {
+		pr_err("priv pointer is NULL!!!\n");
+		return -EINVAL;
+	}
+	atm_tc_stats(priv, &stats);
+	atm_stat = &(stats.stats.atm_tc_stats);
+	seq_puts(seq, "DSL WAN MIB:\n");
+	seq_printf(seq, "  wrx_drophtu_cell: %u\n", atm_stat->wrx_drophtu_cell);
+	seq_printf(seq, "  wrx_dropdes_pdu:  %u\n", atm_stat->wrx_dropdes_pdu);
+	seq_printf(seq, "  wrx_correct_pdu:  %u\n", atm_stat->wrx_correct_pdu);
+	seq_printf(seq, "  wrx_err_pdu:      %u\n", atm_stat->wrx_err_pdu);
+	seq_printf(seq, "  wrx_dropdes_cell: %u\n", atm_stat->wrx_dropdes_cell);
+	seq_printf(seq, "  wrx_correct_cell: %u\n", atm_stat->wrx_correct_cell);
+	seq_printf(seq, "  wrx_err_cell:     %u\n", atm_stat->wrx_err_cell);
+	seq_printf(seq, "  wrx_total_byte:   %u\n", atm_stat->wrx_total_byte);
+	seq_printf(seq, "  wtx_total_pdu:    %u\n", atm_stat->wtx_total_pdu);
+	seq_printf(seq, "  wtx_total_cell:   %u\n", atm_stat->wtx_total_cell);
+	seq_printf(seq, "  wtx_total_byte:   %u\n", atm_stat->wtx_total_byte);
+	seq_puts(seq, "DSL RX QUEUE MIB:\n");
+	seq_puts(seq, "  idx     pdu       bytes\n");
+	for (i = 0; i < txq_num(); i++)
+		seq_printf(seq, "   %2d %10u %10u\n",
+			atm_stat->rx_mib[i].idx,
+			atm_stat->rx_mib[i].pdu,
+			atm_stat->rx_mib[i].bytes);
+
+	seq_puts(seq, "DSL TX QUEUE MIB:\n");
+	seq_puts(seq, "  idx     pdu       bytes\n");
+
+	for (i = 0; i < txq_num(); i++)
+		seq_printf(seq, "   %2d %10u %10u\n",
+			atm_stat->tx_mib[i].idx,
+			atm_stat->tx_mib[i].pdu,
+			atm_stat->tx_mib[i].bytes
+		);
+
+	print_drv_mib(seq, priv);
+
+	return 0;
+}
+
+int proc_clear_atm_wanmib(struct atm_priv *priv)
+{
+	int i, ep_id;
+
+	if (!priv) {
+		pr_err("<%s>: priv pointer is NULL!!!\n", __func__);
+		return -EINVAL;
+	}
+
+	ep_id = priv->ep_id;
+
+	for (i = 0; i < sizeof(struct dsl_wan_mib_table) / 4; i++)
+		sb_w32(0, DSL_WAN_MIB_TBL + i);
+
+	for (i = 0; i < QOSQ_NUM; i++) {
+		tc_memset(priv,
+			fpi_addr(DSL_Q_RX_MIB_TBL(i)),
+			0,
+			sizeof(struct dsl_queue_mib));
+		tc_memset(priv,
+			fpi_addr(DSL_Q_TX_MIB_TBL(i)),
+			0,
+			sizeof(struct dsl_queue_mib));
+	}
+
+	spin_lock_bh(&priv->atm_lock);
+	for (i = 0; i < pvc_num(); i++) {
+		if (priv->pvc_tbl & BIT(i)) {
+			memset(&priv->conn[i].stats, 0,
+				sizeof(priv->conn[i].stats));
+			memset(&priv->conn[i].prio_tx_packets, 0,
+				sizeof(priv->conn[i].prio_tx_packets));
+		}
+		memset(&priv->stats, 0, sizeof(priv->stats));
+	}
+	spin_unlock_bh(&priv->atm_lock);
+
+	return 0;
+}
+
+/*             Exported functions            */
+void show_atm_pvc(struct seq_file *seq, const struct atm_pvc *pvc)
+{
+	char buf[64];
+
+	seq_printf(seq, "\tNet device: %s\n", pvc->dev->name);
+	print_datetime(buf, &(pvc->access_time));
+	seq_printf(seq, "\tLast user cell: %s\n", buf);
+	seq_printf(seq, "\tPort: %d\n", pvc->port);
+	seq_printf(seq, "\tSoftware TX Queue: %u\n", pvc->sw_txq_tbl);
+}
+
+int proc_read_queue(struct seq_file *seq, void *v)
+{
+
+	static const char *mpoa_type_str[]
+		= {"EoA w/o FCS", "EoA w FCS", "PPPoA", "IPoA"};
+
+	struct wrx_queue_config_t rx;
+	struct wtx_queue_config_t tx;
+	char qmap_str[64];
+	char qmap_flag;
+	int qmap_str_len;
+	int i, k;
+	unsigned int bit;
+	struct atm_priv *priv;
+
+	if (!seq) {
+		pr_err("%s : invalid seq data\n", __func__);
+		return 0;
+	}
+
+	priv = (struct atm_priv *)seq->private;
+	if (!priv) {
+		pr_err("%s : invalid atm private\n", __func__);
+		return 0;
+	}
+	seq_printf(seq, "RX Queue Config (0x%08X):\n", WRX_Q_CFG(0));
+
+	for (i = 0; i < txq_num(); i++) {
+		tc_mem_read(priv, &rx, fpi_addr(WRX_Q_CFG(i)),
+				sizeof(rx));
+		seq_printf(seq, "\t%d: MPoA type - %s", i,
+				mpoa_type_str[rx.mpoa_type]);
+		seq_puts(seq, ", MPoA mode - ");
+		seq_printf(seq, "%s", rx.mpoa_mode ? "LLC" : "VC mux");
+		seq_printf(seq, ", IP version %d", rx.ip_ver ? 6 : 4);
+		seq_printf(seq, "\t\tOversize - %d", rx.oversize);
+		seq_printf(seq, ", Undersize - %d", rx.undersize);
+		seq_printf(seq, ", Max Frame size - %d\n", rx.mfs);
+		seq_printf(seq, "\t\tuu mask - 0x%02X", rx.uumask);
+		seq_printf(seq, ", cpi mask - 0x%02X\n", rx.cpimask);
+		seq_printf(seq, "\t\tuu exp - 0x%02X", rx.uuexp);
+		seq_printf(seq, ", cpi exp - 0x%02X\n", rx.cpiexp);
+		if (rx.vlan_ins)
+			seq_printf(seq, "     new_vlan = 0x%08X\n",
+				rx.new_vlan);
+	}
+
+	seq_printf(seq, "TX Queue Config (0x%08X):\n", WTX_Q_CFG(0));
+
+	for (i = 0; i < txq_num(); i++) {
+		tc_mem_read(priv, &tx, fpi_addr(WTX_Q_CFG(i)),
+				sizeof(tx));
+		qmap_flag = 0;
+		qmap_str_len = 0;
+		for (k = 0, bit = 1; k < 15; k++, bit <<= 1)
+			if (tx.same_vc_qmap & bit) {
+				if (qmap_flag++)
+					qmap_str_len +=
+					sprintf(qmap_str + qmap_str_len,
+								", ");
+				qmap_str_len +=
+					sprintf(qmap_str + qmap_str_len,
+					"%d", k);
+			}
+		seq_printf(seq, "\t%d: uu - 0x%02X, cpi - 0x%02X\n", i,
+			tx.uu, tx.cpi);
+		seq_puts(seq, "\t\tsame VC queue map - ");
+		seq_printf(seq, "%s\n", qmap_flag ? qmap_str : "null");
+		seq_puts(seq, "\t\tbearer channel - ");
+		seq_printf(seq, "%d, QSB ID - %d\n", tx.sbid, tx.qsb_vcid);
+		seq_puts(seq, "\t\tMPoA mode - ");
+		seq_printf(seq, "%s\n", tx.mpoa_mode ? "LLC" : "VC mux");
+		seq_printf(seq, "\t\tATM header - 0x%08X\n", tx.atm_header);
+	}
+
+	return 0;
+}
+
+/* Main functions */
+static int ppe_open(struct atm_vcc *vcc)
+{
+	int vpi = vcc->vpi;
+	int vci = vcc->vci;
+	struct atm_priv *priv = g_atm_tc;
+	struct atm_port *port = &priv->port[(int)vcc->dev->phy_data];
+	int sw_txq, i, ret;
+	unsigned int conn;
+
+	tc_dbg(priv->tc_priv, MSG_INIT, "%s\n", __func__);
+
+	if (priv->tc_priv->tc_stat != TC_RUN
+		|| priv->tc_priv->tc_mode != TC_ATM_SL_MODE) {
+		tc_dbg(priv->tc_priv, MSG_INIT, "PPE Open fail! TC Status: %d, TC Mode: %d\n",
+			(u32)priv->tc_priv->tc_stat,
+			(u32)priv->tc_priv->tc_mode);
+		return -EACCES;
+	}
+
+	if (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0) {
+		tc_dbg(priv->tc_priv, MSG_INIT, "aal proto not supported: %d\n",
+			vcc->qos.aal);
+		return -EPROTONOSUPPORT;
+	}
+
+	/* check bandwidth */
+	if ((vcc->qos.txtp.traffic_class == ATM_CBR &&
+		vcc->qos.txtp.max_pcr >
+			(port->tx_max_cell_rate - port->tx_used_cell_rate))
+		|| (vcc->qos.txtp.traffic_class == ATM_VBR_RT &&
+		vcc->qos.txtp.max_pcr >
+			(port->tx_max_cell_rate - port->tx_used_cell_rate))
+		|| (vcc->qos.txtp.traffic_class == ATM_VBR_NRT &&
+		vcc->qos.txtp.scr >
+			(port->tx_max_cell_rate - port->tx_used_cell_rate))
+		|| (vcc->qos.txtp.traffic_class == ATM_UBR_PLUS &&
+		vcc->qos.txtp.min_pcr >
+			(port->tx_max_cell_rate - port->tx_used_cell_rate))) {
+		tc_dbg(priv->tc_priv, MSG_INIT, "exceed TX line rate\n");
+		return -EINVAL;
+	}
+
+	tc_dbg(priv->tc_priv, MSG_INIT, "PVC (%d.%d)\n", vpi, vci);
+
+	/*  check existing vpi,vci  */
+	conn = find_vpivci(vpi, vci);
+	if (conn_valid(conn)) {
+		tc_dbg(priv->tc_priv, MSG_INIT,
+				"PVC (%d.%d) has been in used\n", vpi, vci);
+		return -EADDRINUSE;
+	}
+
+	spin_lock_bh(&priv->atm_lock);
+	/*  allocate software TX queue  */
+	for (sw_txq = 0; sw_txq < txq_num(); sw_txq++)
+		if (!(priv->sw_txq_tbl & BIT(sw_txq)))
+			break;
+
+	if (sw_txq >= txq_num()) {
+		ret = -ENOSPC;
+		tc_dbg(priv->tc_priv, MSG_INIT, "no free TX queue\n");
+		goto OPEN_ERR;
+	}
+
+	if (!priv->pvc_tbl)
+		validate_oam_htu_entry(priv, 1);
+
+	/* allocate PVC */
+	for (conn = 0; conn < pvc_num(); conn++)
+		if (!(priv->pvc_tbl & BIT(conn))) {
+			priv->sw_txq_tbl |= BIT(sw_txq);
+			priv->conn[conn].vcc = vcc;
+			priv->conn[conn].port
+				= (unsigned int)vcc->dev->phy_data;
+			priv->conn[conn].sw_txq_tbl = BIT(sw_txq);
+
+			for (i = 0; i < txq_num(); i++)
+				priv->conn[conn].prio_queue_map[i] = sw_txq;
+			priv->pvc_tbl |= BIT(conn);
+			break;
+		}
+
+	if (!conn_valid(conn)) {
+		ret = -ENOSPC;
+		tc_dbg(priv->tc_priv, MSG_INIT, "exceed PVC limit\n");
+		goto OPEN_ERR;
+	}
+	spin_unlock_bh(&priv->atm_lock);
+
+	/*  reserve bandwidth */
+	switch (vcc->qos.txtp.traffic_class) {
+	case ATM_CBR:
+	case ATM_VBR_RT:
+		port->tx_used_cell_rate += vcc->qos.txtp.max_pcr;
+		break;
+	case ATM_VBR_NRT:
+		port->tx_used_cell_rate += vcc->qos.txtp.scr;
+		break;
+	case ATM_UBR_PLUS:
+		port->tx_used_cell_rate += vcc->qos.txtp.min_pcr;
+		break;
+	}
+
+	/* update atm_vcc structure */
+	vcc->itf = (int)vcc->dev->phy_data;
+	set_bit(ATM_VF_ADDR, &vcc->flags);
+	set_bit(ATM_VF_READY, &vcc->flags);
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"ppe_open(%d.%d): conn = %d, ep_id: %d\n",
+		vcc->vpi, vcc->vci, conn, priv->ep_id);
+
+	return 0;
+
+OPEN_ERR:
+	spin_unlock_bh(&priv->atm_lock);
+	return ret;
+}
+
+static void ppe_close(struct atm_vcc *vcc)
+{
+	u32 cid;
+	struct atm_port *port;
+	struct atm_pvc *conn;
+	struct atm_priv *priv;
+	struct net_device *dev;
+	char dev_name[32];
+
+	if (!vcc) {
+		pr_err("%s: VCC ptr invalid\n", __func__);
+		return;
+	}
+
+	priv = vcc->dev->dev_data;
+	if (!priv) {
+		pr_err("%s: priv ptr invalid\n", __func__);
+		return;
+	}
+
+	if (priv->tc_priv->tc_stat != TC_RUN
+		|| priv->tc_priv->tc_mode != TC_ATM_SL_MODE) {
+		tc_err(priv->tc_priv, MSG_INIT, "PPE Close fail! TC Status: %d, TC Mode: %d\n",
+			priv->tc_priv->tc_stat, priv->tc_priv->tc_mode);
+		return;
+	}
+
+	tc_dbg(priv->tc_priv, MSG_INIT, "ppe close, vpi:%d, vci:%d\n",
+		vcc->vpi, vcc->vci);
+
+	/*  get connection id   */
+	cid = find_vcc(vcc);
+	if (!conn_valid(cid)) {
+		tc_err(priv->tc_priv, MSG_INIT, "can't find vcc\n");
+		return;
+	}
+
+	conn = &priv->conn[cid];
+	port = &priv->port[conn->port];
+
+	clear_bit(ATM_VF_READY, &vcc->flags);
+	clear_bit(ATM_VF_ADDR, &vcc->flags);
+
+	/* clear htu */
+	clear_htu_entry(priv, cid);
+
+	/*  release connection  */
+	spin_lock_bh(&priv->atm_lock);
+	priv->pvc_tbl &= ~(BIT(cid));
+	priv->sw_txq_tbl &= ~(conn->sw_txq_tbl);
+	dev = conn->dev;
+	if (!dev)
+		sprintf(dev_name, "atm_%d%d",
+			conn->vcc->vpi, conn->vcc->vci);
+
+	memset(conn, 0, sizeof(*conn));
+	if (priv->pvc_tbl == 0)
+		validate_oam_htu_entry(priv, 0);
+	spin_unlock_bh(&priv->atm_lock);
+
+	priv->tc_priv->tc_ops.dev_unreg(dev, (!dev) ? dev_name : dev->name,
+					priv->conn[cid].subif_id, 0);
+
+	/* release bandwidth */
+	switch (vcc->qos.txtp.traffic_class) {
+	case ATM_CBR:
+	case ATM_VBR_RT:
+		port->tx_used_cell_rate -= vcc->qos.txtp.max_pcr;
+		break;
+	case ATM_VBR_NRT:
+		port->tx_used_cell_rate -= vcc->qos.txtp.scr;
+		break;
+	case ATM_UBR_PLUS:
+		port->tx_used_cell_rate -= vcc->qos.txtp.min_pcr;
+		break;
+	}
+	/* idle for a while to let parallel operation finish */
+	udelay(100);
+
+	return;
+}
+
+static int ppe_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
+{
+	int ret = 0;
+	struct intel_tc_stats stats;
+	struct atm_priv *priv = g_atm_tc;
+	switch (cmd) {
+	case INTEL_ATM_TC_IOCTL_STATS:
+		if (atm_tc_stats(priv, &stats) == 0)
+			ret = copy_to_user(arg,
+					(void *)&stats,
+					sizeof(stats));
+		break;
+	default:
+		ret = -ENOIOCTLCMD;
+		break;
+	}
+	return ret;
+}
+
+static int ppe_send(struct atm_vcc *vcc, struct sk_buff *skb)
+{
+	int ret, qid, mpoa_pt, mpoa_type, vid;
+	unsigned int prio, conn;
+	struct atm_priv *priv;
+
+	if (!vcc) {
+		pr_err("%s: Invalid VCC PTR\n", __func__);
+		return -EINVAL;
+	}
+
+	priv = vcc->dev->dev_data;
+	if (!priv) {
+		pr_err("%s: Invalid private data\n", __func__);
+		return -EINVAL;
+	}
+	if (!skb || !vcc || vcc->qos.aal != ATM_AAL5)
+		goto PARAM_ERR;
+
+	ATM_SKB(skb)->vcc = vcc;
+	if (priv->tc_priv->tc_stat != TC_RUN
+		|| priv->tc_priv->tc_mode != TC_ATM_SL_MODE) {
+		tc_dbg(priv->tc_priv, MSG_TX, "Drop packet due to tc_stat: %d, tc_mode: %d, ep_id: %d\n",
+			(u32)priv->tc_priv->tc_stat,
+			(u32)priv->tc_priv->tc_mode,
+			priv->ep_id);
+		atm_free_tx_skb_vcc(skb);
+		return -EACCES;
+	}
+
+	skb_get(skb);
+	atm_free_tx_skb_vcc(skb);
+	ATM_SKB(skb)->vcc = NULL;
+
+	conn = find_vcc(vcc);
+	if (!conn_valid(conn)) {
+		tc_dbg(priv->tc_priv, MSG_TX, "Cannot find vcc: vpi/vci: %d/%d\n",
+			vcc->vpi, vcc->vci);
+		ret = -EINVAL;
+		goto FIND_VCC_FAIL;
+	}
+
+	if (!showtime_stat(priv->tc_priv)) {
+		tc_dbg(priv->tc_priv, MSG_TX, "DSL not in showtime\n");
+		ret = -EIO;
+		goto CHECK_SHOWTIME_FAIL;
+	}
+
+	dump_skb_info(priv->tc_priv, skb, (MSG_TX | MSG_TXDATA));
+	prio = skb->priority >= ATM_PRIO_Q_NUM ?
+			ATM_PRIO_Q_NUM - 1 : skb->priority;
+	mpoa_pt = 1;
+	mpoa_type = 0; /* Ignore by FW if mpoa_pt set */
+	qid = priv->conn[conn].prio_queue_map[prio];
+	vid = priv->conn[conn].subif_id;
+	qid = (vid & (~0x7f)) |
+		ATM_DESC_SUBIF_ID(qid, mpoa_pt, mpoa_type);
+
+	tc_dbg(priv->tc_priv, MSG_TX, "vid: 0x%x, qid: 0x%x\n",
+			vid, qid);
+
+	if (priv->tc_priv->tc_ops.send(priv->dev,
+			skb, qid, ATM_SL_PKT) == 0) {
+		priv->stats.aal5_tx_pkts++;
+		priv->stats.aal5_tx_bytes += skb->len;
+		priv->conn[conn].stats.aal5_tx_pkts++;
+		priv->conn[conn].stats.aal5_tx_bytes += skb->len;
+		priv->conn[conn].prio_tx_packets[prio]++;
+	} else {
+		tc_dbg(priv->tc_priv, MSG_TX, "ATM: TX fail\n");
+		priv->stats.aal5_tx_dropped++;
+		priv->conn[conn].stats.aal5_tx_dropped++;
+	}
+
+	if (vcc->stats)
+		atomic_inc(&vcc->stats->tx);
+
+	return 0;
+
+PARAM_ERR:
+	if (!skb) {
+		tc_err(priv->tc_priv, MSG_TX, "SKB is NULL\n");
+		return -EINVAL;
+	} else if (!vcc) {
+		tc_err(priv->tc_priv, MSG_TX, "VCC is NULL\n");
+		return -EINVAL;
+	} else if (vcc->qos.aal != ATM_AAL5) {
+		tc_err(priv->tc_priv, MSG_TX, "AAL protocol is not ATM_ALL5\n");
+		return -EPROTONOSUPPORT;
+	}
+
+	return -EINVAL;
+
+FIND_VCC_FAIL:
+	if (!vcc) {
+		atm_free_tx_skb_vcc(skb);
+		return ret;
+	} else if (vcc->stats)
+		atomic_inc(&vcc->stats->tx_err);
+
+	if (vcc->qos.aal == ATM_AAL5)
+		priv->stats.aal5_tx_errors++;
+	atm_free_tx_skb_vcc(skb);
+	return ret;
+
+CHECK_SHOWTIME_FAIL:
+	if (vcc->stats)
+		atomic_inc(&vcc->stats->tx_err);
+	if (vcc->qos.aal == ATM_AAL5) {
+		priv->stats.aal5_tx_dropped++;
+		priv->conn[conn].stats.aal5_tx_dropped++;
+	}
+	atm_free_tx_skb_vcc(skb);
+	return ret;
+}
+
+static struct sk_buff *alloc_skb_tx(int len)
+{
+	struct sk_buff *skb;
+	len = (len + TCPRIV_ALIGN - 1) & ~(TCPRIV_ALIGN - 1);
+	skb = dev_alloc_skb(len);
+	if (skb)
+		ATM_SKB(skb)->vcc = NULL;
+	return skb;
+}
+
+int ppe_send_oam(struct atm_vcc *vcc, void *cell, int flags)
+{
+	int vid, qid, mpoa_pt, mpoa_type;
+	struct uni_cell_header *cell_header = (struct uni_cell_header *)cell;
+	struct atm_priv *priv = g_atm_tc;
+	struct sk_buff *skb;
+	unsigned int conn;
+	dp_subif_t dp_id;
+
+	if (!vcc)
+		return -EINVAL;
+
+	if (!showtime_stat(priv->tc_priv)) {
+		tc_dbg(priv->tc_priv, MSG_TX, "ATM not in showtime\n");
+		return -EIO;
+	}
+
+	/* dump_oam_cell(cell, 0); */
+	if (((cell_header->pti == ATM_PTI_SEGF5 ||
+		cell_header->pti == ATM_PTI_E2EF5)
+		&& !conn_valid(find_vpivci(cell_header->vpi, cell_header->vci)))
+		|| ((cell_header->vci == 0x03 || cell_header->vci == 0x04)
+		&& !conn_valid(find_vpi(cell_header->vpi)))) {
+
+		tc_err(priv->tc_priv, MSG_TX, "Cell pti/vpi/vci not match: %d/%d/%d\n",
+			cell_header->pti, cell_header->vpi, cell_header->vci);
+		return -EINVAL;
+	}
+
+	/*  find queue ID   */
+	conn = find_vcc(vcc);
+	if (!conn_valid(conn)) {
+		tc_err(priv->tc_priv, MSG_TX,
+			"VCC is not invalid: VPI/VCI: %d/%d\n",
+			vcc->vpi, vcc->vci);
+		return -EINVAL;
+	}
+	mpoa_pt = 1;
+	mpoa_type = 0; /* Ignore by FW  */
+	qid = priv->conn[conn].prio_queue_map[priv->tc_priv->param.oam_prio];
+	vid = priv->conn[conn].subif_id;
+	dp_id.subif = (vid & (~0x7f)) |
+		ATM_DESC_SUBIF_ID(qid, mpoa_pt, mpoa_type);
+
+	/*  allocate sk_buff    */
+	skb = (struct sk_buff *)alloc_skb_tx(MAX_DATA_LEN);
+	if (skb == NULL) {
+		tc_err(priv->tc_priv, MSG_TX,
+				"%s: allocate cbm buffer fail\n", __func__);
+		return -ENOMEM;
+	}
+
+	/*  copy data   */
+	skb_put(skb, CELL_SIZE);
+	memcpy(skb->data, cell, CELL_SIZE);
+	/* SET SUBIFID */
+	skb->DW0 = (skb->DW0 & ~0x7FFF) | dp_id.subif;
+	skb->dev = priv->conn[conn].dev;
+
+	tc_dbg(priv->tc_priv, MSG_TX, "conn: %d, dev name: %s, qid: 0x%x len:%d\n",
+		conn, skb->dev->name, dp_id.subif, skb->len);
+	if (priv->tc_priv->tc_ops.send(priv->dev,
+			skb, qid, ATM_OAM_PKT) == 0) {
+		priv->stats.oam_tx_pkts++;
+		priv->stats.oam_tx_bytes += skb->len;
+		priv->conn[conn].stats.oam_tx_pkts++;
+		priv->conn[conn].stats.oam_tx_bytes += skb->len;
+	} else {
+		priv->stats.oam_tx_dropped++;
+		priv->conn[conn].stats.oam_tx_dropped++;
+	}
+
+	return 0;
+}
+
+static int ppe_change_qos(struct atm_vcc *vcc, struct atm_qos *qos, int flags)
+{
+	int conn;
+
+	if (vcc == NULL || qos == NULL)
+		return -EINVAL;
+
+	conn = find_vcc(vcc);
+	if (conn < 0)
+		return -EINVAL;
+
+	set_qsb((struct atm_priv *)vcc->dev->dev_data, vcc, qos, conn);
+
+	return 0;
+}
+
+static struct atmdev_ops g_ppe_atm_ops = {
+	.owner =	THIS_MODULE,
+	.open =		ppe_open,
+	.close =	ppe_close,
+	.ioctl =	ppe_ioctl,
+	.send =		ppe_send,
+	.send_oam =	ppe_send_oam,
+	.change_qos =	ppe_change_qos,
+};
+
+/**
+ * Disable Powersaving
+ * Enable MBOX1 Interrupt (MBOX_FRAME_STOP)
+ * Send MBOX5 Interrupt to wake up PPE FW
+ */
+static void atm_ppe_wakeup(struct atm_priv *priv)
+{
+	u32 mbox_ier;
+
+	if (priv->tc_priv->param.ps) {
+		atm_power_saving(priv, 0, 1);
+		priv->tc_priv->param.ps = 1;
+	}
+
+	mbox_ier = tc_r32(MBOX_IGU_IER(MBOX_IGU1));
+	mbox_ier |= MBOX_FRAME_STOP;
+	mbox_set_ier(priv, MBOX_IGU1, mbox_ier);
+
+	if (priv->tc_priv->param.ps)
+		mbox_set_isr(priv, PPE_FW_MBOX0, MBOX_FW_WAKEUP);
+}
+
+
+/**
+ * Restore Powersaving setting.
+ */
+static void atm_ppe_ps_restore(struct atm_priv *priv)
+{
+	u32 mbox_ier;
+	mbox_ier = tc_r32(MBOX_IGU_IER(MBOX_IGU1));
+	mbox_ier &= ~MBOX_FRAME_STOP;
+	mbox_set_ier(priv, MBOX_IGU1, mbox_ier);
+
+	if (priv->tc_priv->param.ps)
+		atm_power_saving(priv, 1, 1);
+}
+
+/* Note, must lock oam lock if change the ier other than OAM_INT bit */
+static irqreturn_t atm_irq_handler(int irq, void *dev_id)
+{
+	u32 mbox1_isr, mbox1_ier, mbox1_isrc;
+	struct atm_priv *priv = dev_id;
+
+	mbox1_ier = tc_r32(MBOX_IGU_IER(MBOX_IGU1));
+	mbox1_isrc = tc_r32(MBOX_IGU_ISR(MBOX_IGU1));
+	mbox1_isr = mbox1_isrc & mbox1_ier;
+
+	/* Any other bit except OAM_INT_BIT, need lock oam_lock */
+	if (mbox1_isr & MBOX_OAM_RX) {
+		mbox1_ier &= ~MBOX_OAM_RX;
+		mbox_set_ier(priv, MBOX_IGU1, mbox1_ier);
+		tasklet_schedule(&g_oam_tasklet);
+	}
+
+	if (mbox1_isr & MBOX_FRAME_STOP) {
+		ttha_disable(priv, 0);
+		tc_dbg(priv->tc_priv, MSG_EVENT,
+			"Disable TTHA\n"
+		);
+	}
+
+#ifdef CONFIG_LTQ_VRX318_CPUFREQ
+	if (mbox1_isr & MBOX_PKT_RX) {
+		mbox1_ier &= ~MBOX_PKT_RX;
+		spin_lock(&priv->oam_lock);
+		mbox_set_ier(priv, MBOX_IGU1, mbox1_ier);
+		spin_unlock(&priv->oam_lock);
+		tasklet_schedule(&g_coc_tasklet);
+	}
+#endif
+
+	/**
+	* Clear TX interrupt at this moment.
+	* Implement flow control mechansim if there is specific requirement.
+	*/
+	mbox_clr_isr(priv, MBOX_IGU1, mbox1_isrc);
+
+	return IRQ_HANDLED;
+}
+
+static void atm_umt_init(struct atm_priv *priv)
+{
+	struct tc_priv *tcpriv;
+	u32 dst;
+	u32 period;
+
+	tcpriv = priv->tc_priv;
+	dst = priv->ep->hw_ops->umt_msg_addr(priv->ep);
+	dst |= priv->ep->phy_membase;
+	period = tcpriv->param.umt_period;
+
+	tc_dbg(priv->tc_priv, MSG_INIT, "\tUMT period: %d, dst: 0x%x\n",
+		period, dst);
+	tcpriv->tc_ops.umt_init(0, period, dst);
+}
+
+/**
+*  Load ATM firmware to corresponding PP32
+**/
+static void atm_fw_load(struct atm_priv *priv)
+{
+	struct ppe_fw *fw = &priv->fw;
+	struct fw_bin *binfw = &priv->tc_priv->fw;
+
+	memcpy(&fw->atm_ver, &binfw->fw_hdr.atm_ver, sizeof(fw->atm_ver));
+	fw->atm_fw.size[PP32_TX] =
+		binfw->fw_hdr.fw_info[FW_ATM].fw_size;
+	fw->atm_fw.data[PP32_TX] =
+		(const u32 *)binfw->fw_ptr[FW_ATM];
+
+	tc_dbg(priv->tc_priv, MSG_INIT, "%s: Firmware size[%d] ptr[%p]\n",
+			__func__,
+			fw->atm_fw.size[PP32_TX],
+			fw->atm_fw.data[PP32_TX]);
+}
+
+static inline void atm_pdma_init(struct atm_priv *priv)
+{
+	u32 reg;
+
+	tc_w32(0x00000008, PDMA_CFG);
+	tc_w32(0x00203580, SAR_PDMA_RX_CMDBUF_CFG);
+	tc_w32(0x004035A0, SAR_PDMA_RX_FW_CMDBUF_CFG);
+
+	/* Enable RX idle cell */
+	reg = tc_r32(SFSM_CFG0);
+	reg |= BIT(15);
+	tc_w32(reg, SFSM_CFG0);
+	reg = tc_r32(SFSM_CFG1);
+	reg |= BIT(15);
+	tc_w32(reg, SFSM_CFG1);
+	return;
+}
+
+/**
+* Configure ATM's Firmware
+* vrx318_atm_fw_init
+*/
+static void atm_fw_init(struct atm_priv *priv)
+{
+	qos_cfg_t qos_cfg;
+	struct psave_cfg ps_cfg;
+
+	sb_w32(0x3C30, __VRX218_FLOW_CTRL_CFG);
+
+	memset((void *)&qos_cfg, 0, sizeof(qos_cfg));
+	/* PPE FW use this timer to wake up in the sleep mode.
+	    It's the only way to wake up FW in the ATM mode.
+	*/
+	/* cgu_get_pp32_clock() / 62500 / 3 */
+	qos_cfg.time_tick = 2304; /* tc_ppe_clkget(atm_priv->ep); */
+	tc_mem_write(priv, fpi_addr(__QOS_CFG), &qos_cfg, sizeof(qos_cfg));
+	memset((void *)&ps_cfg, 0, sizeof(ps_cfg));
+	ps_cfg.start_state = 0;
+	ps_cfg.sleep_en = priv->tc_priv->param.ps;
+	tc_mem_write(priv, fpi_addr(__PSAVE_CFG), &ps_cfg, sizeof(ps_cfg));
+
+	sb_w32(15 + 3, __CFG_WRX_HTUTS);
+	sb_w32(0x03, __CFG_WRX_DMACH_ON);
+	sb_w32(4, __CFG_WRX_HUNT_BITTH);
+	sb_w32(1, __SOC_FAMILY);
+
+	return;
+}
+
+/* vrx318_atm_wrx_queue_cfg_init */
+static void atm_wrx_queue_cfg_init(struct atm_priv *priv)
+{
+	int i;
+	struct wrx_queue_config_t wrx_queue_config;
+	memset((void *)&wrx_queue_config, 0, sizeof(struct wrx_queue_config_t));
+
+	wrx_queue_config.new_vlan  = 0;
+	wrx_queue_config.vlan_ins  = 0;
+	/* 0: EoA without FCS, 1: EoA with FCS, 2: PPPoA, 3:IPoA */
+	wrx_queue_config.mpoa_type	= MPOA_IPOA;
+	/* 0: IPv4, 1: IPv6 */
+	wrx_queue_config.ip_ver		= ATM_IP_IPV4;
+	/* 0: VCmux, 1: LLC */
+	wrx_queue_config.mpoa_mode	= MPOA_VCMUX_MODE;
+	wrx_queue_config.oversize	= MAX_DATA_LEN;
+	wrx_queue_config.undersize	= 0;
+	/* Max fragment size */
+	wrx_queue_config.mfs		= MAX_DATA_LEN;
+	wrx_queue_config.uumask		= 0xFF;
+	wrx_queue_config.cpimask	= 0xFF;
+	wrx_queue_config.uuexp		= 0;
+	wrx_queue_config.cpiexp		= 0;
+
+	for (i = 0; i < 2; i++)
+		tc_mem_write(priv, fpi_addr(WRX_Q_CFG(i)),
+			&wrx_queue_config,
+			sizeof(struct wrx_queue_config_t));
+
+	return;
+}
+
+/* vrx318_atm_wtx_queue_cfg_init */
+static void atm_wtx_queue_cfg_init(struct atm_priv *priv, int qsb_en)
+{
+	int i;
+	struct wtx_queue_config_t wtx_queue_config;
+
+	memset((void *)&wtx_queue_config, 0, sizeof(struct wtx_queue_config_t));
+	wtx_queue_config.same_vc_qmap = 0;
+	wtx_queue_config.uu           = 0;
+	wtx_queue_config.cpi          = 0;
+	wtx_queue_config.sbid         = 0;
+	/*  Which QSB queue (VCID) does this TX queue map to. */
+	wtx_queue_config.qsb_vcid     = 0;
+	wtx_queue_config.mpoa_mode    = 0; /*  0: VCmux, 1: LLC */
+	wtx_queue_config.qsben        = qsb_en;
+	wtx_queue_config.atm_header   = 0;
+
+	for (i = 0; i < txq_num(); i++) {
+		tc_mem_write(priv, fpi_addr(WTX_Q_CFG(i)),
+			&wtx_queue_config,
+			sizeof(struct wtx_queue_config_t)
+			);
+	}
+
+	return;
+}
+
+/* vrx318_atm_wtx_port_cfg_init */
+static void atm_wtx_port_cfg_init(struct atm_priv *priv,
+		int qsb_en)
+{
+	struct wtx_port_config_t wtx_port_config;
+
+	memset((void *)&wtx_port_config, 0, sizeof(struct wtx_port_config_t));
+	wtx_port_config.qsben = qsb_en;
+	/* BC0: Use TX Queue 0 - if QSB is Disabled */
+	wtx_port_config.qid = 0;
+	tc_mem_write(priv, fpi_addr(__WTX_PORT_CONFIG0),
+			&wtx_port_config,
+		sizeof(struct wtx_port_config_t));
+	/* BC1: Use TX Queue 1 - if QSB is Disabled */
+	wtx_port_config.qid = 1;
+	tc_mem_write(priv, fpi_addr(__WTX_PORT_CONFIG1), &wtx_port_config,
+		sizeof(struct wtx_port_config_t));
+
+	return;
+}
+
+/* vrx318_atm_htu_init */
+static void atm_htu_init(struct atm_priv *priv)
+{
+	/* OAM_F4_SEG_HTU_ENTRY */
+	sb_w32(0x00000031, HTU_ENTRY_TBL(OAM_F4_SEG_HTU_ENTRY));
+	sb_w32(0xfff0000e, HTU_MASK_TBL(OAM_F4_SEG_HTU_ENTRY));
+	sb_w32(0x00000600, HTU_RESULT_TBL(OAM_F4_SEG_HTU_ENTRY));
+
+	/* OAM_F4_TOT_HTU_ENTRY */
+	sb_w32(0x00000041, HTU_ENTRY_TBL(OAM_F4_TOT_HTU_ENTRY));
+	sb_w32(0xfff0000e, HTU_MASK_TBL(OAM_F4_TOT_HTU_ENTRY));
+	sb_w32(0x00000600, HTU_RESULT_TBL(OAM_F4_TOT_HTU_ENTRY));
+
+	/* OAM_F5_HTU_ENTRY */
+	sb_w32(0x00000009, HTU_ENTRY_TBL(OAM_F5_HTU_ENTRY));
+	sb_w32(0xfffffff2, HTU_MASK_TBL(OAM_F5_HTU_ENTRY));
+	sb_w32(0x00000600, HTU_RESULT_TBL(OAM_F5_HTU_ENTRY));
+
+	return;
+}
+
+/* ATM Downstream initialization
+* vrx318_ds_aal5_desq_cfg_ctxt_init
+* - RXIN
+* - RXOUT
+*/
+static int atm_ds_aal5_desq_cfg_ctxt_init(struct atm_priv *priv)
+{
+	int i;
+	rx_descriptor_t rx_descriptor;
+	dma_addr_t phy_addr;
+	desq_cfg_ctxt_t ds_desq_cfg_ctxt;
+
+	memset((void *)&ds_desq_cfg_ctxt, 0, sizeof(ds_desq_cfg_ctxt));
+	/* Initialize Downstream Descriptor Queue Config/Context */
+	ds_desq_cfg_ctxt.des_in_own_val		= 0;
+	ds_desq_cfg_ctxt.fast_path		= 0;
+	ds_desq_cfg_ctxt.mbox_int_en		= 0;
+	ds_desq_cfg_ctxt.des_sync_needed	= 0;
+	ds_desq_cfg_ctxt.des_num = ACA_RXOUT_HD_DESC_NUM;
+	ds_desq_cfg_ctxt.des_base_addr		= __DS_PKT_DES_LIST_BASE;
+	tc_mem_write(priv, fpi_addr(__DS_PKT_DESQ_CFG_CTXT),
+		&ds_desq_cfg_ctxt, sizeof(desq_cfg_ctxt_t));
+
+	memset((void *)&rx_descriptor, 0, sizeof(rx_descriptor));
+	rx_descriptor.own = 1;/*!ds_desq_cfg_ctxt.des_in_own_val;*/
+	rx_descriptor.sop = 0;
+	rx_descriptor.eop = 0;
+	rx_descriptor.data_len = MAX_DATA_LEN;
+	/* Initialize DS Descriptors */
+	for (i = 0; i < ds_desq_cfg_ctxt.des_num; i++) {
+		if (!tc_buf_alloc(priv, DMA_PACKET_SZ,
+				&phy_addr, DS_DIR, priv->pdev)) {
+			set_tc_status(priv->tc_priv, TC_ERR);
+			return -ENOMEM;
+		}
+		rx_descriptor.data_ptr
+			= (unsigned int)phy_addr;
+		tc_mem_write(priv,
+			fpi_addr(ds_desq_cfg_ctxt.des_base_addr + (i * 2)),
+			&rx_descriptor, sizeof(rx_descriptor));
+	}
+
+	return 0;
+}
+
+/* vrx318_ds_oam_desq_cfg_ctxt_init */
+static int atm_ds_oam_desq_cfg_ctxt_init(struct atm_priv *priv)
+{
+	int i;
+	desq_cfg_ctxt_t oam_desq_cfg_ctxt;
+	rx_descriptor_t rx_descriptor;
+	dma_addr_t phy_addr;
+
+	/* Initialize Downstream OAM Descriptor Queue Config/Context */
+	memset((void *)&oam_desq_cfg_ctxt, 0, sizeof(oam_desq_cfg_ctxt));
+	oam_desq_cfg_ctxt.des_in_own_val	= 0;
+	oam_desq_cfg_ctxt.fast_path		= 0;
+	oam_desq_cfg_ctxt.mbox_int_en		= 0;
+
+	/*FW does not it copy to SoC, driver launch a tasklet
+	* to directly fetch from vrx318 des list
+	*/
+	oam_desq_cfg_ctxt.des_sync_needed	= 0;
+	oam_desq_cfg_ctxt.des_num		= DS_OAM_DES_NUM;
+	oam_desq_cfg_ctxt.des_base_addr		= __DS_OAM_DES_LIST_BASE;
+	tc_mem_write(priv, fpi_addr(__DS_OAM_DESQ_CFG_CTXT),
+		&oam_desq_cfg_ctxt, sizeof(oam_desq_cfg_ctxt));
+
+	priv->oam_llst.oam_num = oam_desq_cfg_ctxt.des_num;
+	priv->oam_llst.oam_des_list
+		= kzalloc(priv->oam_llst.oam_num * sizeof(unsigned int),
+			GFP_KERNEL);
+	if (!priv->oam_llst.oam_des_list) {
+		tc_err(priv->tc_priv, MSG_INIT, "Invalid OAM DES List\n");
+		return -ENOMEM;
+	}
+	priv->oam_llst.oam_idx = 0;
+
+	/* Init OWN bit of all the Descriptors in Shadow DS Descriptor List */
+	rx_descriptor.own = !oam_desq_cfg_ctxt.des_in_own_val;
+	rx_descriptor.sop = 0;
+	rx_descriptor.eop = 0;
+	/*0 EDMA doesn't require the data_len */
+	rx_descriptor.data_len = ATM_OAM_SIZE;
+	for (i = 0; i < oam_desq_cfg_ctxt.des_num; i++) {
+		priv->oam_llst.oam_des_list[i] =
+			(u32)tc_buf_alloc(priv, ATM_OAM_SIZE, &phy_addr,
+			DS_DIR, priv->pdev);
+		if (!priv->oam_llst.oam_des_list[i]) {
+			tc_err(priv->tc_priv,
+				MSG_INIT,
+				"Failed to allocate buffer for DS OAM\n");
+			set_tc_status(priv->tc_priv, TC_ERR);
+			return -ENOMEM;
+		}
+		rx_descriptor.data_ptr = phy_addr;
+		tc_mem_write(priv,
+			fpi_addr(oam_desq_cfg_ctxt.des_base_addr + (i * 2)),
+			&rx_descriptor, sizeof(rx_descriptor));
+	}
+
+	return 0;
+}
+
+static void atm_us_fastpath_desq_cfg_ctxt_init(struct atm_priv *priv)
+{
+	int i, own;
+	desq_cfg_ctxt_t us_fp_desq_cfg_ctxt;
+
+	memset(&us_fp_desq_cfg_ctxt, 0, sizeof(us_fp_desq_cfg_ctxt));
+	/* Initialize Up-Stream Fast-Path Descriptor Queue Config/Context */
+	/*1 - owned by SoC CDMA, 0 - owned by VRX318 */
+	us_fp_desq_cfg_ctxt.des_in_own_val	= 1;
+	us_fp_desq_cfg_ctxt.fast_path		= 1;
+	us_fp_desq_cfg_ctxt.mbox_int_en		= 0;
+	us_fp_desq_cfg_ctxt.des_sync_needed	= 0;/* 318 is 1*/
+	us_fp_desq_cfg_ctxt.des_num		= __US_FAST_PATH_DES_LIST_NUM;
+	us_fp_desq_cfg_ctxt.des_base_addr	= __US_FAST_PATH_DES_LIST_BASE;
+
+	tc_mem_write(priv, fpi_addr(__US_FP_INQ_DES_CFG_CTXT),
+		&us_fp_desq_cfg_ctxt, sizeof(desq_cfg_ctxt_t));
+
+	/* Init OWN bit of all the Descriptors in Shadow Fast Path Des List */
+	own = !us_fp_desq_cfg_ctxt.des_in_own_val;
+	own = (own & 1) << 31;
+
+	for (i = 0; i < us_fp_desq_cfg_ctxt.des_num; i++)
+		sb_w32(own,	us_fp_desq_cfg_ctxt.des_base_addr + (i * 2));
+
+	return;
+}
+
+/* Initialize QoS related configuration for
+* vrx318_atm_us_qos_cfg_init
+* Initializes the below PPE FW Data Structures
+* 1. INQ_QoS_CFG
+* 2. QoSQ_CFG_CTXT
+* 4. SHAPING_WFQ_CFG
+* 5. QOSQ_MIB
+* 6. QOSQ_FLOW_CTRL_CFG
+* 7. STD_DES_CFG
+*/
+static void atm_us_qos_cfg_init(struct atm_priv *priv)
+{
+	int i, offset;
+	qosq_flow_ctrl_cfg_t qosq_flow_ctrl_cfg;
+	std_des_cfg_t std_des_cfg;
+	inq_qos_cfg_t fp_qos_cfg, cpu_qos_cfg;
+	qosq_cfg_ctxt_t qosq_cfg_ctxt;
+
+	/* Initialize QOSQ_FLOW_CTRL_CFG */
+	memset(&qosq_flow_ctrl_cfg, 0, sizeof(qosq_flow_ctrl_cfg));
+	qosq_flow_ctrl_cfg.large_frame_size = 1024;
+	qosq_flow_ctrl_cfg.large_frame_drop_th = 28;
+	tc_mem_write(priv, fpi_addr(__QOSQ_FLOW_CTRL_CFG),
+		&qosq_flow_ctrl_cfg, sizeof(qosq_flow_ctrl_cfg));
+
+	/* Initialize STD_DES_CFG */
+	memset(&std_des_cfg, 0, sizeof(std_des_cfg));
+	std_des_cfg.byte_off = 0;
+	std_des_cfg.data_len = MAX_DATA_LEN;
+	tc_mem_write(priv, fpi_addr(__STD_DES_CFG),
+		&std_des_cfg, sizeof(std_des_cfg));
+
+	/* Setup INQ_QoS_CFG for Fast-Path & CPU-Path */
+	memset(&fp_qos_cfg, 0, sizeof(fp_qos_cfg));
+	memset(&cpu_qos_cfg, 0, sizeof(cpu_qos_cfg));
+
+	/* Fast path */
+	fp_qos_cfg.qos_en         = 1;
+	fp_qos_cfg.qid_mask       = 0xF;
+	fp_qos_cfg.qosq_base_qid  = 0;
+	fp_qos_cfg.desq_cfg_ctxt  = __US_FP_INQ_DES_CFG_CTXT;
+	tc_mem_write(priv, INQ_QOS_CFG_BASE(0), &fp_qos_cfg,
+			sizeof(fp_qos_cfg));
+
+	/* Setup Fast-Path DESQ_CFG_CTXT */
+	atm_us_fastpath_desq_cfg_ctxt_init(priv);
+
+	/* Setup QoSQ_CFG_CTXT */
+	memset(&qosq_cfg_ctxt, 0, sizeof(qosq_cfg_ctxt));
+
+	qosq_cfg_ctxt.threshold = 8;
+	qosq_cfg_ctxt.des_num   = TOTAL_QOS_DES_NUM / txq_num();
+
+	offset = 0;
+	for (i = 0; i < txq_num(); i++) { /* txq_num() was 8*/
+		qosq_cfg_ctxt.des_base_addr = __US_QOSQ_DES_LIST_BASE + offset;
+		tc_mem_write(priv,
+			fpi_addr((__QOSQ_CFG_CTXT_BASE
+				+ (i * __QOSQ_CFG_CTXT_SIZE))),
+			&qosq_cfg_ctxt, sizeof(qosq_cfg_ctxt));
+		offset += qosq_cfg_ctxt.des_num * 2;
+	}
+
+	return;
+}
+
+/** vrx318_atm_us_qos_des_cfg_ctxt_init
+ * vrx218_atm_us_qos_des_init: should be 512 descriptor
+ */
+static int atm_us_qos_des_cfg_ctxt_init(struct atm_priv *priv)
+{
+	int i, offset;
+	tx_descriptor_t tx_descriptor;
+	desq_cfg_ctxt_t desq_cfg_ctxt;
+	u32 dst_addr;
+	dma_addr_t phy_addr;
+
+	/* Setup QoSQ PSEUDO DES_CFG_CTXT */
+	memset(&desq_cfg_ctxt, 0, sizeof(desq_cfg_ctxt));
+
+	desq_cfg_ctxt.des_in_own_val = 1;
+	desq_cfg_ctxt.mbox_int_en = 0;
+	desq_cfg_ctxt.des_sync_needed = 0;
+	desq_cfg_ctxt.des_num = TOTAL_QOS_DES_NUM / txq_num();
+	offset = 0;
+
+	for (i = 0; i < txq_num(); i++) {
+		desq_cfg_ctxt.des_base_addr = __US_QOSQ_DES_LIST_BASE + offset;
+		dst_addr = fpi_addr(__QOSQ_PSEUDO_DES_CFG_BASE +
+			(i * sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int)));
+		tc_mem_write(priv, dst_addr, &desq_cfg_ctxt,
+			sizeof(desq_cfg_ctxt));
+		offset += desq_cfg_ctxt.des_num * 2;
+	}
+
+	memset(&tx_descriptor, 0, sizeof(tx_descriptor));
+	tx_descriptor.own = !desq_cfg_ctxt.des_in_own_val;
+	tx_descriptor.data_len = MAX_DATA_LEN;
+
+	/* Initialize QoSQ Descriptors */
+	for (i = 0; i < TOTAL_QOS_DES_NUM; i++) {
+		tx_descriptor.data_ptr =
+			(u32)tc_buf_alloc(priv, tx_descriptor.data_len,
+				&phy_addr, US_DIR, priv->pdev);
+		if (!tx_descriptor.data_ptr) {
+			tc_err(priv->tc_priv, MSG_INIT, "Failed alloc buffer for QoSQ\n");
+			set_tc_status(priv->tc_priv, TC_ERR);
+			return -ENOMEM;
+		}
+		tx_descriptor.data_ptr = phy_addr;
+		tc_mem_write(priv, fpi_addr(__US_QOSQ_DES_LIST_BASE + (i * 2)),
+			&tx_descriptor, sizeof(tx_descriptor));
+	}
+
+	return 0;
+}
+
+#define PDBRAM_RX_PKT_BUFFER_END	0x22BFFF
+#define PDBRAM_RX_OAM_BUFFER_BASE	(PDBRAM_RX_PKT_BUFFER_END + 1)
+/** vrx318_atm_local_des_cfg_ctxt_init
+* Initialize VRX218 ATM-TC Local Descriptor List
+* Performs below actions
+* (1) Allocate and Initialize TC UpStream Local Descriptors
+* (2) Allocate and Initialize TC DownStream Local Descriptors
+*/
+static void atm_local_des_cfg_ctxt_init(struct atm_priv *priv)
+{
+	int i, des_cnt;
+	tx_descriptor_t tx_descriptor;
+	rx_descriptor_t rx_descriptor;
+	desq_cfg_ctxt_t desq_cfg_ctxt;
+	u32 ds_addr, dst_addr;
+	cdma_ch_ctxt_t cdma_ch_ctxt;
+
+	/* Setup the Local DESQ Configuration/Context for 16 UpStream Queues */
+	memset(&desq_cfg_ctxt, 0, sizeof(desq_cfg_ctxt));
+	desq_cfg_ctxt.des_in_own_val = 0;
+	des_cnt = 0;
+	for (i = 0; i < txq_num(); i++) {
+		if (i == 0)
+			desq_cfg_ctxt.des_num
+				= 3;
+		else
+			desq_cfg_ctxt.des_num = 2;
+		desq_cfg_ctxt.des_base_addr
+			= __US_TC_LOCAL_Q_DES_LIST_BASE + (des_cnt * 2);
+		dst_addr = fpi_addr(__US_TC_LOCAL_Q_CFG_CTXT_BASE
+			+ i * (sizeof(desq_cfg_ctxt_t)/sizeof(unsigned int)));
+		tc_mem_write(priv, dst_addr, &desq_cfg_ctxt,
+				sizeof(desq_cfg_ctxt));
+		des_cnt += desq_cfg_ctxt.des_num;
+	}
+
+	/* Initialize UpStream Descriptors */
+	memset(&tx_descriptor, 0, sizeof(tx_descriptor));
+	tx_descriptor.own = !desq_cfg_ctxt.des_in_own_val;
+	tx_descriptor.data_len = MAX_DATA_LEN;
+	ds_addr = PDBRAM_PPE_BASE;
+	/* Note: ATM US PDBRAM pointer need convert to DWORD pointer */
+	for (i = 0; i < ATM_PDBRAM_US_BUF_LEN; i++) {
+		tx_descriptor.data_ptr = priv->ep->phy_membase
+			+ (ds_addr + (i * tx_descriptor.data_len));
+		dst_addr = fpi_addr(__US_TC_LOCAL_Q_DES_LIST_BASE + (i * 2));
+		tc_mem_write(priv, dst_addr, &tx_descriptor,
+				sizeof(tx_descriptor));
+	}
+
+	if (priv->tc_priv->param.sharing_cdma_en) {
+		tc_dbg(priv->tc_priv, MSG_INIT,
+			"Configure sharing CDMA context\n");
+		memset(&rx_descriptor, 0, sizeof(rx_descriptor));
+		/* rx_descriptor.own = 1; */
+		rx_descriptor.data_len = MAX_DATA_LEN;
+
+		/* Initialize UpStream Descriptors */
+		for (i = 0; i < __US_LOCAL_Q_SHARED_CDMA_NUM; i++) {
+			dst_addr = (u32)fpi_addr((__US_LOCAL_Q_SHARED_CDMA_BASE
+				+ (i * 2)));
+			tc_mem_write(priv, dst_addr,
+				&rx_descriptor,
+				sizeof(rx_descriptor));
+		}
+
+		memset(&cdma_ch_ctxt, 0, sizeof(cdma_ch_ctxt));
+		cdma_ch_ctxt.cdma_num = __US_QOS_Q_SHARED_CDMA_NUM;
+		cdma_ch_ctxt.cdma_tx_sb_base = __US_QOS_Q_SHARED_CDMA_BASE;
+		cdma_ch_ctxt.cdma_ext_sb_base = __US_CDMA_EXT_SB_BASE;
+		cdma_ch_ctxt.cdma_rx_sb_base = __US_LOCAL_Q_SHARED_CDMA_BASE;
+		dst_addr = (u32)fpi_addr(__US_CDMA_READ_CH_CFG_CTXT);
+		tc_mem_write(priv, dst_addr, &cdma_ch_ctxt,
+			sizeof(cdma_ch_ctxt));
+	}
+
+	/* Setup the Local DESQ Configuration/Context for AAL5 DownStream Q*/
+	memset(&desq_cfg_ctxt, 0, sizeof(desq_cfg_ctxt));
+	desq_cfg_ctxt.des_in_own_val = 1;
+	desq_cfg_ctxt.des_num
+		= __DS_TC_LOCAL_AAL5Q_DES_LIST_NUM;
+	desq_cfg_ctxt.des_base_addr = __DS_TC_LOCAL_AAL5Q_DES_LIST_BASE;
+	tc_mem_write(priv, fpi_addr(__DS_TC_AAL5_LOCAL_Q_CFG_CTXT),
+			&desq_cfg_ctxt, sizeof(desq_cfg_ctxt));
+
+	memset(&rx_descriptor, 0, sizeof(rx_descriptor));
+	rx_descriptor.own = 0;/* !desq_cfg_ctxt.des_in_own_val; */
+	rx_descriptor.data_len = MAX_DATA_LEN;
+	ds_addr = PDBRAM_PPE_BASE + ATM_PDBRAM_US_BUF_LEN * DMA_PACKET_SZ;
+	/* Initialize DownStream AAL5 Descriptors */
+	/* for (i = 0; i < ATM_PDBRAM_DS_BUF_LEN; i++) { */
+	for (i = 0; i < __DS_TC_LOCAL_AAL5Q_DES_LIST_NUM; i++) {
+		rx_descriptor.data_ptr = priv->ep->phy_membase +
+				(ds_addr +	(i * DMA_PACKET_SZ));
+		dst_addr = fpi_addr(__DS_TC_LOCAL_AAL5Q_DES_LIST_BASE +
+				(i * 2));
+		tc_mem_write(priv, dst_addr, &rx_descriptor,
+				sizeof(rx_descriptor));
+	}
+
+	/* Setup the Local DESQ Configuration/Context for OAM DownStream Q */
+	memset(&desq_cfg_ctxt, 0, sizeof(desq_cfg_ctxt));
+	desq_cfg_ctxt.des_in_own_val = 1;
+	desq_cfg_ctxt.des_num = ATM_PDBRAM_DS_OAM_LEN;
+	desq_cfg_ctxt.des_base_addr = __DS_TC_LOCAL_OAMQ_DES_LIST_BASE;
+	tc_mem_write(priv, fpi_addr(__DS_TC_OAM_LOCAL_Q_CFG_CTXT),
+			&desq_cfg_ctxt, sizeof(desq_cfg_ctxt));
+
+	memset(&rx_descriptor, 0, sizeof(rx_descriptor));
+	rx_descriptor.own = 0;/* !desq_cfg_ctxt.des_in_own_val; */
+	rx_descriptor.data_len = __US_LOCAL_Q_SHARED_CDMA_NUM;
+
+	/* Initialize DownStream OAM Descriptors */
+	/* for (i = 0; i < ARRAY_SIZE(oam_sb_addr); i++) { */
+	for (i = 0; i < 10; i++) {
+		/* rx_descriptor.data_ptr = fpi_addr(oam_sb_addr[i]); */
+		rx_descriptor.data_ptr = (PDBRAM_RX_OAM_BUFFER_BASE +
+			(i * rx_descriptor.data_len)) | priv->ep->phy_membase;
+		dst_addr = fpi_addr(__DS_TC_LOCAL_OAMQ_DES_LIST_BASE +
+					(i * 2));
+		tc_mem_write(priv, dst_addr, &rx_descriptor,
+				sizeof(rx_descriptor));
+	}
+
+	return;
+}
+
+static void atm_ppe_aca_cfg(struct atm_priv *priv)
+{
+	us_aca_cfg_ctxt_t us_ctxt;
+	ds_aca_cfg_ctxt_t ds_ctxt;
+	struct aca_event_reg_addr aca;
+	u32 phybase;
+
+	sb_w32(1, __TX_IN_ACA_ACCUM_STATUS);
+	sb_w32(1, __TX_OUT_ACA_ACCUM_STATUS);
+	sb_w32(1, __RX_IN_ACA_ACCUM_STATUS);
+	sb_w32(1, __RX_OUT_ACA_ACCUM_STATUS);
+
+	memset(&us_ctxt, 0, sizeof(us_ctxt));
+	memset(&ds_ctxt, 0, sizeof(ds_ctxt));
+
+	phybase = priv->ep->phy_membase;
+	priv->ep->hw_ops->aca_event_addr_get(priv->ep, &aca);
+	us_ctxt.tx_in_aca_msg_ptr = aca.txin_acc_sub | phybase;
+	us_ctxt.tx_out_aca_msg_ptr = aca.txout_acc_add | phybase;
+	us_ctxt.tx_out_aca_status_ptr
+		= SB_XBAR_ADDR(__TX_OUT_ACA_ACCUM_STATUS) | phybase;
+	ds_ctxt.rx_in_aca_msg_ptr = aca.rxin_acc_sub | phybase;
+	ds_ctxt.rx_out_aca_msg_ptr = aca.rxout_acc_add | phybase;
+	ds_ctxt.rx_in_aca_status_ptr
+		= SB_XBAR_ADDR(__RX_IN_ACA_ACCUM_STATUS) | phybase;
+	ds_ctxt.rx_out_aca_status_ptr
+		= SB_XBAR_ADDR(__RX_OUT_ACA_ACCUM_STATUS) | phybase;
+	tc_mem_write(priv, fpi_addr(__US_ACA_CFG_CTXT_BASE),
+		&us_ctxt, sizeof(us_ctxt));
+	tc_mem_write(priv, fpi_addr(__DS_ACA_CFG_CTXT_BASE),
+		&ds_ctxt, sizeof(ds_ctxt));
+
+	sb_w32(phybase, __EP_ADDR_BAR);
+}
+
+/* vrx218_atm_cdma_copy_ch_init */
+static void atm_cdma_copy_ch_init(struct atm_priv *priv)
+{
+	cdma_copy_ch_cfg_t cpch_cfg;
+	unsigned int dst_addr, i;
+
+	/* Setup 8 UpStream CDMA Copy Channel */
+	cpch_cfg.srcq_ctxt_ptr = __QOSQ_PSEUDO_DES_CFG_BASE;
+	cpch_cfg.dstq_ctxt_ptr = __US_TC_LOCAL_Q_CFG_CTXT_BASE;
+	dst_addr = fpi_addr(__US_CDMA_COPY_CH_CFG);
+	tc_mem_write(priv, dst_addr, &cpch_cfg, sizeof(cpch_cfg));
+
+	for (i = 1; i < txq_num(); i++) {
+		cpch_cfg.srcq_ctxt_ptr +=
+				sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+		cpch_cfg.dstq_ctxt_ptr +=
+				sizeof(desq_cfg_ctxt_t) / sizeof(unsigned int);
+		dst_addr += sizeof(cdma_copy_ch_cfg_t);
+		tc_mem_write(priv, dst_addr, &cpch_cfg, sizeof(cpch_cfg));
+	}
+
+	/* Setup AAL5 DownStream eDMA Copy Channel */
+	cpch_cfg.srcq_ctxt_ptr = __DS_TC_AAL5_LOCAL_Q_CFG_CTXT;
+	cpch_cfg.dstq_ctxt_ptr = __DS_PKT_DESQ_CFG_CTXT;
+	dst_addr = fpi_addr(__DS_CDMA_COPY_CH_CFG);
+	tc_mem_write(priv, dst_addr, &cpch_cfg, sizeof(cpch_cfg));
+
+	/* Setup OAM DownStream eDMA Copy Channel */
+	cpch_cfg.srcq_ctxt_ptr = __DS_TC_OAM_LOCAL_Q_CFG_CTXT;
+	cpch_cfg.dstq_ctxt_ptr = __DS_OAM_DESQ_CFG_CTXT;
+	dst_addr += sizeof(cdma_copy_ch_cfg_t);
+	tc_mem_write(priv, dst_addr, &cpch_cfg, sizeof(cpch_cfg));
+
+	return;
+}
+
+static void atm_cdma_init(struct atm_priv *priv)
+{
+	u32 rxbase, txbase;
+	u32 rxnum, txnum;
+	u32 phybase;
+
+	phybase = priv->ep->phy_membase;
+	/* Initialize CDMA control */
+	tc_cdma_init(priv);
+	/* Enable CDMA channel for US */
+	if (priv->tc_priv->param.sharing_cdma_en) {
+		tc_dbg(priv->tc_priv, MSG_INIT,
+			"Configure CDMA in sharing mode\n");
+		/* Channel 0 and 1 set to US */
+		/* Setup RX Channel desc base address and len */
+		rxbase = phybase +
+			SB_XBAR_ADDR(__US_LOCAL_Q_SHARED_CDMA_BASE);
+		rxnum = __US_QOS_Q_SHARED_CDMA_NUM;
+
+		/* Setup TX Channel desc base address and len */
+		txbase = phybase +
+			SB_XBAR_ADDR(__US_QOS_Q_SHARED_CDMA_BASE);
+		txnum = __US_QOS_Q_SHARED_CDMA_NUM;
+		/* configure CDMA channel sharing */
+		cdma_ch_cfg(priv, ATM_US_DMA_RXCH, ATM_US_DMA_TXCH,
+			rxbase, rxnum, txbase, txnum);
+		cdma_ch_on(priv, ATM_US_DMA_RXCH, ATM_US_DMA_TXCH);
+	}
+
+	/* Channel 16, 17 set to DS AAL5 */
+	rxbase = phybase + SB_XBAR_ADDR(__DS_PKT_DES_LIST_BASE);
+	txbase = phybase + SB_XBAR_ADDR(__DS_TC_LOCAL_AAL5Q_DES_LIST_BASE);
+	rxnum = __DS_PKT_DES_LIST_NUM;
+	txnum = __DS_TC_LOCAL_AAL5Q_DES_LIST_NUM;
+	cdma_ch_cfg(priv, DS_AAL5_DMA_RXCH, DS_AAL5_DMA_TXCH,
+		rxbase, rxnum, txbase, txnum);
+	cdma_ch_on(priv, DS_AAL5_DMA_RXCH, DS_AAL5_DMA_TXCH);
+	/* Channel 18, 19 set to DS OAM*/
+	rxbase = phybase + SB_XBAR_ADDR(__DS_OAM_DES_LIST_BASE);
+	txbase = phybase + SB_XBAR_ADDR(__DS_TC_LOCAL_OAMQ_DES_LIST_BASE);
+	rxnum = __DS_OAM_DES_LIST_NUM;
+	txnum = __DS_TC_LOCAL_OAMQ_DES_LIST_NUM;
+	cdma_ch_cfg(priv, DS_OAM_DMA_RXCH, DS_OAM_DMA_TXCH,
+		rxbase, rxnum, txbase, txnum);
+	cdma_ch_on(priv, DS_OAM_DMA_RXCH, DS_OAM_DMA_TXCH);
+
+	return;
+}
+
+static void atm_cdma_exit(struct atm_priv *priv)
+{
+	cdma_ch_off(priv, ATM_US_DMA_RXCH, ATM_US_DMA_TXCH);
+	cdma_ch_off(priv, DS_AAL5_DMA_RXCH, DS_AAL5_DMA_TXCH);
+	cdma_ch_off(priv, DS_OAM_DMA_RXCH, DS_OAM_DMA_TXCH);
+}
+
+/**
+* ATM TC HW and FW Initialization: vrx318_ppe_atm_init
+*/
+static void ppe_atm_fw_hw_init(struct atm_priv *priv,
+				u32 ep_id, int qsb_en)
+{
+	/* Clear PPE SB */
+	ppe_sb_clear(priv);
+	/* Clear PDBRAM */
+	pdbram_clear(priv);
+	/* Configure DMA */
+	atm_pdma_init(priv);
+	/* Configure ATM firmware */
+	atm_fw_init(priv);
+	atm_htu_init(priv);
+
+	/* always enable qsb */
+	atm_wtx_queue_cfg_init(priv, qsb_en);
+	atm_wtx_port_cfg_init(priv, qsb_en);
+	atm_wrx_queue_cfg_init(priv);
+	atm_ds_aal5_desq_cfg_ctxt_init(priv);
+
+	/* Initialize Downstream OAM Descriptors and desc config context */
+	atm_ds_oam_desq_cfg_ctxt_init(priv);
+	atm_us_qos_cfg_init(priv);
+	atm_us_qos_des_cfg_ctxt_init(priv);
+	atm_local_des_cfg_ctxt_init(priv);
+
+	atm_cdma_init(priv);
+	atm_cdma_copy_ch_init(priv);
+	atm_ppe_aca_cfg(priv);
+	/* Enable TTHA */
+	ttha_enable(priv);
+}
+
+static int atm_dev_init(struct atm_priv *atm_priv, int ep_id)
+{
+	int i, err;
+
+	for (i = 0; i < ATM_PORT_NUMBER; i++) {
+		if (atm_priv->port[i].dev)
+			continue;
+		atm_priv->port[i].tx_max_cell_rate = DEFAULT_CELL_RATE;
+		atm_priv->port[i].dev = atm_dev_register(g_atm_dev_name,
+				atm_priv->tc_priv->ep_dev[ep_id].dev,
+				&g_ppe_atm_ops, -1, NULL);
+		if (!atm_priv->port[i].dev) {
+			err = -EIO;
+			goto ATM_DEV_REGISTER_FAIL;
+		} else {
+			atm_priv->port[i].dev->ci_range.vpi_bits = 8;
+			atm_priv->port[i].dev->ci_range.vci_bits = 16;
+			/* assume 3200 cell rate
+			 * before get real information
+			 */
+			atm_priv->port[i].dev->link_rate =
+				DEFAULT_CELL_RATE;
+			atm_priv->port[i].dev->dev_data = atm_priv;
+			atm_priv->port[i].dev->phy_data =
+				(void *)(unsigned long)i;
+		}
+	}
+
+	return 0;
+
+ATM_DEV_REGISTER_FAIL:
+	pr_err("ATM device registration fail\n");
+	for (i = 0; i < ATM_PORT_NUMBER; i++)
+		if (atm_priv->port[i].dev)
+			atm_dev_deregister(atm_priv->port[i].dev);
+
+	return err;
+}
+
+static int atm_dev_deinit(struct atm_priv *atm_priv)
+{
+	int i;
+
+	for (i = 0; i < ATM_PORT_NUMBER; i++)
+		if (atm_priv->port[i].dev)
+			atm_dev_deregister(atm_priv->port[i].dev);
+
+	return 0;
+}
+
+/* Description: Setup QSB. */
+static void qsb_global_set(struct atm_priv *priv)
+{
+	u32 qsb_clk = get_qsb_clk(priv);
+	int i;
+	u32 tmp1, tmp2, tmp3;
+	u32 reg_val;
+	struct tc_param *param = &priv->tc_priv->param;
+
+	/* QSB cell delay variation due to concurrency */
+	param->qsb_tau   = 1;
+	/* QSB scheduler burst length */
+	param->qsb_srvm  = 0x0F;
+	param->qsb_tstep = 4;
+	tc_w32(param->qsb_tau, QSB_ICDV);
+	tc_w32(param->qsb_srvm, QSB_SBL);
+	tc_w32(param->qsb_tstep >> 1, QSB_CFG);
+
+	/* set SCT and SPT per port */
+	for (i = 0; i < ATM_PORT_NUMBER; i++)
+		if (priv->port[i].tx_max_cell_rate != 0) {
+			tmp1 = ((qsb_clk *
+					param->qsb_tstep) >> 1) /
+					priv->port[i].tx_max_cell_rate;
+			tmp2 = tmp1 >> 6; /* integer value of Tsb */
+			/* fractional part of Tsb */
+			tmp3 = (tmp1 & ((1 << 6) - 1)) + 1;
+			/*  carry over to integer part (?)  */
+			if (tmp3 == (1 << 6)) {
+				tmp3 = 0;
+				tmp2++;
+			}
+			if (tmp2 == 0)
+				tmp2 = tmp3 = 1;
+			/*  1. set mask  */
+			/*  2. write value to data transfer register */
+			/*  3. start the tranfer */
+			/*  SCT (FracRate)  */
+			tc_w32(QSB_SET_SCT_MASK, QSB_RTM);
+			tc_w32(tmp3, QSB_RTD);
+			reg_val = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) |
+					QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_SCT) |
+					QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) |
+					QSB_RAMAC_TESEL_SET(i & 0x01);
+			tc_w32(reg_val, QSB_RAMAC);
+
+			/*  SPT (SBV + PN + IntRage)    */
+			tc_w32(QSB_SET_SPT_MASK, QSB_RTM);
+			reg_val = QSB_RTD_TTV_SET(QSB_SPT_SBV_VALID) |
+					QSB_SPT_PN_SET(i & 0x01) |
+					QSB_SPT_INTRATE_SET(tmp2);
+			tc_w32(reg_val, QSB_RTD);
+			reg_val = QSB_RAMAC_RW_SET(QSB_RAMAC_RW_WRITE) |
+					QSB_RAMAC_TSEL_SET(QSB_RAMAC_TSEL_SPT) |
+					QSB_RAMAC_LH_SET(QSB_RAMAC_LH_LOW) |
+					QSB_RAMAC_TESEL_SET(i & 0x01);
+			tc_w32(reg_val, QSB_RAMAC);
+		}
+}
+
+static int print_htu(struct seq_file *seq, int i)
+{
+	struct htu_entry entry;
+	struct htu_mask mask;
+	struct htu_result result;
+
+	struct atm_priv *priv = (struct atm_priv *)seq->private;
+
+	if (!priv) {
+		pr_err("<%s>: Invalid private data\n", __func__);
+		return -EINVAL;
+	}
+
+	tc_mem_read(priv, &entry, fpi_addr(HTU_ENTRY_TBL(i)), sizeof(entry));
+	tc_mem_read(priv, &mask, fpi_addr(HTU_MASK_TBL(i)), sizeof(mask));
+	tc_mem_read(priv, &result, fpi_addr(HTU_RESULT_TBL(i)), sizeof(result));
+
+	if (entry.vld) {
+		seq_printf(seq, "%2d. valid\n", i);
+		seq_printf(seq,  "    entry  0x%08x - pid %01x, vpi %02x",
+			*(u32 *)&entry, entry.pid, entry.vpi);
+		seq_printf(seq,  ", vci %04x, pti %01x\n",
+					entry.vci, entry.pti);
+		seq_printf(seq,  "    mask   0x%08x - pid %01x, vpi %02x",
+			*(u32 *)&mask, mask.pid_mask, mask.vpi_mask);
+		seq_printf(seq,  ", vci %04x, pti %01x\n",
+			mask.vci_mask, mask.pti_mask);
+		seq_printf(seq,  "    result 0x%08x - type: %s, qid: %d",
+			*(u32 *)&result, result.type ? "cell" : "AAL5",
+			result.qid);
+		if (result.type)
+			seq_printf(seq,  ", cell id: %d, verification: %s",
+				result.cellid, result.ven ? "on" : "off");
+		seq_puts(seq,  "\n");
+	} else
+		seq_printf(seq, "%2d. invalid\n", i);
+
+	return 0;
+}
+
+int proc_read_htu(struct seq_file *seq, void *v)
+{
+	int htuts;
+	int i;
+
+	struct atm_priv *priv = (struct atm_priv *)seq->private;
+
+	if (!priv) {
+		pr_err("<%s>: Invalid private data\n", __func__);
+		return -EINVAL;
+	}
+	htuts = sb_r32(__CFG_WRX_HTUTS);
+
+	for (i = 0; i < htuts; i++)
+		print_htu(seq, i);
+
+	return 0;
+}
+
+/* Description:
+ *    Add one entry to HTU table.
+ *  Input:
+ *    vpi        --- unsigned int, virtual path ID
+ *    vci        --- unsigned int, virtual channel ID
+ *    connection --- unsigned int, connection ID
+ *    aal5       --- int, 0 means AAL0, else means AAL5
+ *  Output:
+ *    none
+ */
+static void set_htu_entry(struct atm_priv *priv, unsigned int vpi,
+			unsigned int vci, unsigned int conn, int aal5)
+{
+	struct htu_entry htu_entry = {
+		.res1 = 0x00,
+		.pid  = priv->conn[conn].port & 0x01,
+		.vpi  = vpi,
+		.vci  = vci,
+		.pti  = 0x00,
+		.vld  = 0x01};
+
+	struct htu_mask htu_mask = {
+		.set      = 0x03,
+		.pid_mask = 0x02,
+		.vpi_mask = 0x00,
+		.vci_mask = 0x0000,
+		.pti_mask = 0x03, /* 0xx, user data */
+		.clear    = 0x00};
+
+	struct htu_result htu_result = {
+		.res1   = 0x00,
+		.cellid = conn,
+		.res2   = 0x00,
+		.type   = aal5 ? 0x00 : 0x01,
+		.ven    = 0x01,
+		.res3   = 0x00,
+		.qid    = conn};
+
+	tc_mem_write(priv,
+		fpi_addr(HTU_RESULT_TBL(conn + OAM_HTU_ENTRY_NUMBER)),
+		&htu_result, sizeof(htu_result));
+	tc_mem_write(priv,
+		fpi_addr(HTU_MASK_TBL(conn + OAM_HTU_ENTRY_NUMBER)),
+		&htu_mask, sizeof(htu_mask));
+	tc_mem_write(priv,
+		fpi_addr(HTU_ENTRY_TBL(conn + OAM_HTU_ENTRY_NUMBER)),
+		&htu_entry, sizeof(htu_entry));
+}
+
+static void mpoa_setup_sync(struct atm_priv *priv, unsigned int conn)
+{
+	unsigned int sw_txq_tbl;
+	int sw_tx_queue;
+	struct wrx_queue_config_t rx_qcfg;
+	struct wtx_queue_config_t tx_qcfg;
+	struct uni_cell_header *cell_header;
+	struct atm_vcc *vcc;
+	struct net_device *dev;
+	char dev_name[32];
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"sync: conn: %d, vpi: %d, vci: %d, mpoa_type: %d, mpoa_mode: %d\n",
+		conn, priv->conn[conn].vcc->vpi, priv->conn[conn].vcc->vci,
+		priv->conn[conn].mpoa_type, priv->conn[conn].mpoa_mode);
+
+	dev = priv->conn[conn].dev;
+
+	if (!dev)
+		sprintf(dev_name, "atm_%d%d",
+			priv->conn[conn].vcc->vpi, priv->conn[conn].vcc->vci);
+
+	priv->tc_priv->tc_ops.dev_reg(dev, (!dev) ? dev_name : dev->name,
+				&priv->conn[conn].subif_id, 0);
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"conn[%d]subif_id[%x]", conn, priv->conn[conn].subif_id);
+	vcc = priv->conn[conn].vcc;
+
+	/*  set htu entry   */
+	set_htu_entry(priv, vcc->vpi, vcc->vci, conn,
+		vcc->qos.aal == ATM_AAL5 ? 1 : 0);
+
+	memset(&rx_qcfg, 0, sizeof(struct wrx_queue_config_t));
+	/* setup RX queue cfg and TX queue cfg */
+	rx_qcfg.new_vlan	= 0; /* No Vlan insert for GRX500 */
+	rx_qcfg.vlan_ins	= 0; /* No Vlan insert */
+	rx_qcfg.mpoa_type	= priv->conn[conn].mpoa_type;
+	rx_qcfg.ip_ver		= ATM_IP_IPV4; /* set IPv4 as default */
+	rx_qcfg.mpoa_mode	= priv->conn[conn].mpoa_mode;
+	rx_qcfg.oversize	= MAX_DATA_LEN;/*param->aal5r_max_pktsz;*/
+	rx_qcfg.undersize	= 0;/*param->aal5r_min_pktsz;*/
+	rx_qcfg.mfs		= MAX_DATA_LEN;/*param->aal5s_max_pktsz;*/
+	rx_qcfg.cpimask		= 0xFF;
+	rx_qcfg.uumask		= 0xFF;
+	rx_qcfg.uuexp		= 0;
+	rx_qcfg.cpiexp		= 0;
+
+	tc_mem_write(priv, fpi_addr(WRX_Q_CFG(conn)), &rx_qcfg,
+			sizeof(struct wrx_queue_config_t));
+
+	memset(&tx_qcfg, 0, sizeof(struct wtx_queue_config_t));
+	/* only one TX queue is assigned now */
+	/* use ioctl/proc to add other TX queues */
+	tx_qcfg.same_vc_qmap   = 0x00;
+	tx_qcfg.sbid           = priv->conn[conn].port;
+	/* qsb qid = firmware qid + 1 */
+	tx_qcfg.qsb_vcid       = conn + QSB_QUEUE_NUMBER_BASE;
+	tx_qcfg.mpoa_mode      = priv->conn[conn].mpoa_mode;
+	/* reserved in A4, however put 1 for backward compatible */
+	tx_qcfg.qsben          = 1;
+
+	cell_header = (struct uni_cell_header *)((unsigned int *)&tx_qcfg + 2);
+	cell_header->clp = (vcc->atm_options & ATM_ATMOPT_CLP) ? 1 : 0;
+	cell_header->pti = ATM_PTI_US0;
+	cell_header->vci = vcc->vci;
+	cell_header->vpi = vcc->vpi;
+	cell_header->gfc = 0;
+
+	for (sw_txq_tbl = priv->conn[conn].sw_txq_tbl, sw_tx_queue = 0;
+		sw_tx_queue < pvc_num();
+		sw_tx_queue++) {
+		if ((sw_txq_tbl & BIT(sw_tx_queue)) != 0) {
+			tx_qcfg.same_vc_qmap
+				= sw_txq_tbl & ~(BIT(sw_tx_queue));
+			tc_mem_write(priv,
+				fpi_addr(WTX_Q_CFG(sw_tx_queue)),
+				&tx_qcfg, sizeof(struct wtx_queue_config_t));
+		}
+	}
+
+	/*  set qsb */
+	set_qsb(priv, vcc, &vcc->qos, conn);
+
+}
+
+static void mpoa_setup(struct atm_vcc *vcc, int mpoa_type,
+			int f_llc, struct net_device *dev)
+{
+	unsigned int conn;
+	struct atm_priv *priv;
+	int ep_id;
+
+	if (!vcc) {
+		pr_err("%s: Invalid VCC or Invalid network device\n", __func__);
+		return;
+	}
+
+	priv = (struct atm_priv *)vcc->dev->dev_data;
+	if (!priv) {
+		pr_err("%s : Invalid ATM private data\n", __func__);
+		return;
+	}
+	tc_dbg(priv->tc_priv, MSG_EVENT, "Add VPC/VCI: mpoa_type: %d, f_llc: %d, dev: %s\n",
+		mpoa_type, f_llc, dev->name);
+
+	ep_id = priv->ep_id;
+
+	spin_lock_bh(&priv->atm_lock);
+	conn = find_vcc(vcc);
+	if (!conn_valid(conn))
+		goto err1;
+
+	priv->conn[conn].dev = dev;
+	priv->conn[conn].mpoa_mode = f_llc;
+	priv->conn[conn].mpoa_type = mpoa_type;
+	spin_unlock_bh(&priv->atm_lock);
+
+	mpoa_setup_sync(priv, conn);
+
+	return;
+
+err1:
+	spin_unlock_bh(&priv->atm_lock);
+	return;
+}
+
+static void setup_oam_htu_entry(struct atm_priv *priv)
+{
+	struct htu_entry htu_entry = {0};
+	struct htu_result htu_result = {0};
+	struct htu_mask htu_mask = {0};
+	int ven = 1;
+	int i;
+	int max_pvc = pvc_num();
+
+	if (priv->tc_priv->param.dfe_loopback)
+		ven = 0;
+	else
+		ven = 1;
+
+	htu_mask.set = 0x03;
+
+	/* Clear HTU Tables */
+	for (i = 0; i < max_pvc; i++) {
+		htu_result.qid = (unsigned int)i;
+		tc_mem_write(priv,
+			fpi_addr(HTU_ENTRY_TBL(i + OAM_HTU_ENTRY_NUMBER)),
+			&htu_entry, sizeof(htu_entry));
+		tc_mem_write(priv,
+			fpi_addr(HTU_MASK_TBL(i + OAM_HTU_ENTRY_NUMBER)),
+			&htu_mask, sizeof(htu_mask));
+		tc_mem_write(priv,
+			fpi_addr(HTU_RESULT_TBL(i + OAM_HTU_ENTRY_NUMBER)),
+			&htu_result, sizeof(htu_result));
+	}
+
+	/*  OAM HTU Entry   */
+	htu_entry.vci		= 0x03;
+	htu_mask.pid_mask	= 0x03;
+	htu_mask.vpi_mask	= 0xFF;
+	htu_mask.vci_mask	= 0x0000;
+	htu_mask.pti_mask	= 0x07;
+	htu_result.cellid	= 0;
+	htu_result.type		= 1;
+	htu_result.ven		= ven;
+	htu_result.qid		= 0;
+	tc_mem_write(priv,
+		fpi_addr(HTU_RESULT_TBL(OAM_F4_SEG_HTU_ENTRY)),
+		&htu_result, sizeof(htu_result));
+	tc_mem_write(priv,
+		fpi_addr(HTU_MASK_TBL(OAM_F4_SEG_HTU_ENTRY)),
+		&htu_mask, sizeof(htu_mask));
+	tc_mem_write(priv,
+		fpi_addr(HTU_ENTRY_TBL(OAM_F4_SEG_HTU_ENTRY)),
+		&htu_entry, sizeof(htu_entry));
+
+	htu_entry.vci		= 0x04;
+	htu_result.cellid	= 0;
+	htu_result.type		= 1;
+	htu_result.ven		= ven;
+	htu_result.qid		= 0;
+	tc_mem_write(priv,
+		fpi_addr(HTU_RESULT_TBL(OAM_F4_TOT_HTU_ENTRY)),
+		&htu_result, sizeof(htu_result));
+	tc_mem_write(priv,
+		fpi_addr(HTU_MASK_TBL(OAM_F4_TOT_HTU_ENTRY)),
+		&htu_mask, sizeof(htu_mask));
+	tc_mem_write(priv,
+		fpi_addr(HTU_ENTRY_TBL(OAM_F4_TOT_HTU_ENTRY)),
+		&htu_entry, sizeof(htu_entry));
+
+	htu_entry.vci		= 0x00;
+	htu_entry.pti		= 0x04;
+	htu_mask.vci_mask	= 0xFFFF;
+	htu_mask.pti_mask	= 0x01;
+	htu_result.cellid	= 0;
+	htu_result.type		= 1;
+	htu_result.ven		= ven;
+	htu_result.qid		= 0;
+	tc_mem_write(priv,
+		fpi_addr(HTU_RESULT_TBL(OAM_F5_HTU_ENTRY)),
+		&htu_result, sizeof(htu_result));
+	tc_mem_write(priv,
+		fpi_addr(HTU_MASK_TBL(OAM_F5_HTU_ENTRY)),
+		&htu_mask, sizeof(htu_mask));
+	tc_mem_write(priv,
+		fpi_addr(HTU_ENTRY_TBL(OAM_F5_HTU_ENTRY)),
+		&htu_entry, sizeof(htu_entry));
+}
+
+static unsigned int atm_get_pvc_id(struct sk_buff *skb)
+{
+	struct pmac_rx_hdr *pmac_hdr;
+
+	if (!skb) {
+		pr_err("%s : Invalid skb\n", __func__);
+		return -EINVAL;
+	}
+	pmac_hdr = (struct pmac_rx_hdr *)skb->data;
+	if (!pmac_hdr) {
+		pr_err("%s : skb'data is NULL\n", __func__);
+		return -EINVAL;
+	}
+	return (pmac_hdr->src_sub_inf_id2 >> 3) & 0xF;
+}
+
+static int atm_get_qid_by_vcc(struct net_device *dev, struct sk_buff *skb,
+		void *vcc, uint32_t flags)
+{
+	struct atm_priv *priv;
+	unsigned int conn;
+	int qid, type, prio;
+
+	if (!dev || !vcc) {
+		pr_err("%s: Invalid dev/skb/vcc\n", __func__);
+		return -EINVAL;
+	}
+
+	priv = g_atm_tc;
+	if (!priv) {
+		pr_err("%s: ATM not init\n", __func__);
+		return -EINVAL;
+	}
+
+	spin_lock_bh(&priv->atm_lock);
+	if (skb)
+		prio = skb->priority < ATM_PRIO_Q_NUM ?
+			skb->priority : ATM_PRIO_Q_NUM - 1;
+	else
+		prio = 0;
+	conn = find_vcc(vcc);
+
+	if (!conn_valid(conn)) {
+		tc_dbg(priv->tc_priv, MSG_EVENT,
+			"%s: given VCC is not attached\n", __func__);
+		spin_unlock_bh(&priv->atm_lock);
+		return -ENODEV;
+	} else {
+		qid = priv->conn[conn].prio_queue_map[prio];
+		type = priv->conn[conn].mpoa_type;
+		qid = priv->conn[conn].subif_id
+				| ATM_DESC_SUBIF_ID(qid, 0, type);
+	}
+
+	spin_unlock_bh(&priv->atm_lock);
+
+	return qid;
+}
+
+int sw_tx_queue_del(struct atm_priv *priv, int conn)
+{
+	int i;
+	int qid, txq_id;
+	wtx_queue_config_t wtx_q_cfg;
+	u32 new_q_tbl, q_tbl;
+	struct atm_pvc *connect;
+
+	spin_lock_bh(&priv->atm_lock);
+	connect = &priv->conn[conn];
+	q_tbl = connect->sw_txq_tbl;
+
+	qid = txq_id = -1;
+	for (i = (pvc_num() - 1); i >= 0; i--) {
+		if (q_tbl & BIT(i)) {
+			if (qid == -1)
+				qid = i;
+			else {
+				txq_id = i;
+				break;
+			}
+		}
+	}
+
+	/* Last Queue or something wrong */
+	if (qid < 0 || q_tbl == BIT(qid)
+		|| ((q_tbl & BIT(qid)) == 0) || txq_id < 0) {
+		spin_unlock_bh(&priv->atm_lock);
+		return -EIO;
+	}
+
+	/* Update queue map table */
+	new_q_tbl = connect->sw_txq_tbl & (~(BIT(qid)));
+
+	connect->sw_txq_tbl = new_q_tbl;
+	priv->sw_txq_tbl &= ~(BIT(qid));
+
+	for (i = 0; i < ATM_PRIO_Q_NUM; i++) {
+		if (connect->prio_queue_map[i] == qid)
+			connect->prio_queue_map[i] = txq_id;
+	}
+	spin_unlock_bh(&priv->atm_lock);
+
+	for (i = 0; i < qid; i++) {
+		tc_mem_read(priv, &wtx_q_cfg, fpi_addr(WTX_Q_CFG(i)),
+			sizeof(wtx_q_cfg));
+		wtx_q_cfg.same_vc_qmap &= ~(BIT(qid));
+		tc_mem_write(priv, fpi_addr(WTX_Q_CFG(i)),
+			&wtx_q_cfg, sizeof(wtx_q_cfg));
+	}
+	tc_memset(priv, fpi_addr(WTX_Q_CFG(qid)), 0, sizeof(wtx_q_cfg));
+
+	return 0;
+}
+
+int sw_tx_queue_add(struct atm_priv *priv, int conn)
+{
+	int i;
+	int qid;
+	wtx_queue_config_t wtx_q_cfg;
+	u32 new_q_tbl, q_tbl;
+	struct atm_pvc *connect;
+
+	/* Get available Phyiscal Queue ID */
+	spin_lock_bh(&priv->atm_lock);
+	for (qid = 0; qid < pvc_num(); qid++) {
+		if ((priv->sw_txq_tbl & BIT(qid)) == 0)
+			break;
+	}
+
+	if (qid >= pvc_num()) {
+		tc_err(priv->tc_priv, MSG_INIT, "No available physical queue\n");
+		spin_unlock_bh(&priv->atm_lock);
+		return -ENOSPC;
+	}
+
+	connect = &priv->conn[conn];
+	/* Reconfigure Existing Queue's QMAP */
+	q_tbl = connect->sw_txq_tbl;
+	new_q_tbl = q_tbl | BIT(qid);
+
+	/* Update local and global tx queue table */
+	connect->sw_txq_tbl = new_q_tbl;
+	priv->sw_txq_tbl |= BIT(qid);
+	spin_unlock_bh(&priv->atm_lock);
+
+	for (i = 0; i < pvc_num(); i++) {
+		if (q_tbl & BIT(i)) {
+			tc_mem_read(priv, &wtx_q_cfg, fpi_addr(WTX_Q_CFG(i)),
+				sizeof(wtx_q_cfg));
+			wtx_q_cfg.same_vc_qmap = new_q_tbl & (~(BIT(i)));
+			tc_mem_write(priv, fpi_addr(WTX_Q_CFG(i)),
+				&wtx_q_cfg, sizeof(wtx_q_cfg));
+		}
+	}
+	/* Add new Queue Setting */
+	wtx_q_cfg.same_vc_qmap = new_q_tbl & (~(BIT(qid)));
+	tc_mem_write(priv, fpi_addr(WTX_Q_CFG(qid)),
+		&wtx_q_cfg, sizeof(wtx_q_cfg));
+
+	return 0;
+}
+
+static void atm_encapsulate_frame(struct sk_buff *skb, int conn)
+{
+	unsigned int proto_type;
+	int mpoa_type, mpoa_mode;
+
+	mpoa_type = g_atm_tc->conn[conn].mpoa_type;
+	mpoa_mode = g_atm_tc->conn[conn].mpoa_mode;
+
+	/* ETH packet, need recover ATM encapsulation  */
+	if (mpoa_mode) {
+		/*  LLC */
+		switch (mpoa_type) {
+		case 0: /* EoA w/o FCS */
+			skb_push(skb, 10);
+			((u32 *)skb->data)[0] = 0xAAAA0300;
+			((u32 *)skb->data)[1] = 0x80C20007;
+			((u16 *)skb->data)[4] = 0x0000;
+			break;
+
+		case 1: /* EoA w FCS */
+			skb_push(skb, 10);
+			((u32 *)skb->data)[0] = 0xAAAA0300;
+			((u32 *)skb->data)[1] = 0x80C20001;
+			((u16 *)skb->data)[4] = 0x0000;
+			break;
+
+		case 2: /* PPPoA */
+			proto_type = ntohs(*(u16 *)(skb->data + 12));
+			switch (proto_type) {
+			case 0x0800:
+				proto_type = 0x0021;
+				break;
+			case 0x86DD:
+				proto_type = 0x0057;
+				break;
+			}
+			skb_pull(skb, ETH_HLEN - 6);
+			((u32 *)skb->data)[0] = 0xFEFE03CF;
+			((u16 *)skb->data)[2] = (u16)proto_type;
+			break;
+
+		case 3: /*  IPoA */
+			skb_pull(skb, ETH_HLEN - 8);
+			((u32 *)skb->data)[0] = 0xAAAA0300;
+			((u16 *)skb->data)[2] = 0x0000;
+			break;
+		}
+	} else {
+		/*  VC-mux  */
+		switch (mpoa_type) {
+		case 0: /* EoA w/o FCS */
+			skb_push(skb, 2);
+			*(u16 *)skb->data = 0x0000;
+			break;
+
+		case 1: /* EoA w FCS */
+			skb_push(skb, 2);
+			*(u16 *)skb->data = 0x0000;
+			break;
+
+		case 2: /* PPPoA */
+			proto_type = ntohs(*(u16 *)(skb->data + 12));
+			switch (proto_type) {
+			case 0x0800:
+				proto_type = 0x0021;
+				break;
+			case 0x86DD:
+				proto_type = 0x0057;
+				break;
+			}
+			skb_pull(skb, ETH_HLEN - 2);
+			*(u16 *)skb->data = (u16)proto_type;
+			break;
+		case 3: /*  IPoA */
+			skb_pull(skb, ETH_HLEN);
+			break;
+		}
+	}
+	dump_skb_info(g_atm_tc->tc_priv, skb, (MSG_RX | MSG_RXDATA));
+}
+
+static void atm_push(struct net_device *rxif,
+		struct sk_buff *skb)
+{
+	unsigned int conn;
+	struct atm_vcc *vcc = NULL;
+	struct atm_priv *priv = g_atm_tc;
+
+	if (!priv) {
+		pr_err("%s : Invalid ATM private data\n", __func__);
+		goto err;
+	}
+	conn = atm_get_pvc_id(skb);
+	skb_pull(skb, PMAC_SIZE);
+	if (unlikely(!conn_valid(conn)
+		|| (priv->conn[conn].vcc == NULL)
+		|| (priv->pvc_tbl & BIT(conn)) == 0)) {
+		tc_dbg(priv->tc_priv, MSG_RX,
+			"invalid conn: %d or NULL Vcc\n", conn);
+	} else {
+		vcc = priv->conn[conn].vcc;
+		if (atm_charge(vcc, skb->truesize)) {
+
+			if (vcc->stats)
+				atomic_inc(&vcc->stats->rx);
+
+			spin_lock_bh(&priv->atm_lock);
+			if (vcc->qos.aal == ATM_AAL5) {
+				priv->stats.aal5_rx_pkts++;
+				priv->stats.aal5_rx_bytes += skb->len;
+				priv->conn[conn].stats.aal5_rx_pkts++;
+				priv->conn[conn].stats.aal5_rx_bytes
+					+= skb->len;
+			} else
+				priv->stats.aal5_rx_errors++;
+			priv->conn[conn].access_time = current_kernel_time();
+			spin_unlock_bh(&priv->atm_lock);
+
+			ATM_SKB(skb)->vcc = vcc;
+			atm_encapsulate_frame(skb, conn);
+			vcc->push(vcc, skb);
+
+			return;
+		} else {
+			tc_dbg(priv->tc_priv, MSG_RX,
+				"inactive qid %d\n", conn);
+
+			if (vcc->stats)
+				atomic_inc(&vcc->stats->rx_drop);
+
+			spin_lock_bh(&priv->atm_lock);
+			if (vcc->qos.aal == ATM_AAL5)
+				priv->stats.aal5_rx_dropped++;
+			priv->conn[conn].stats.aal5_rx_dropped++;
+			spin_unlock_bh(&priv->atm_lock);
+		}
+	}
+err:
+	dev_kfree_skb_any(skb);
+}
+
+static void atm_irq_on(u32 irq_id)
+{
+	u32 irq_ier;
+	struct atm_priv *priv = g_atm_tc;
+
+	spin_lock_irq(&priv->atm_lock);
+	irq_ier = tc_r32(MBOX_IGU_IER(MBOX_IGU1));
+	irq_ier |= irq_id;
+	mbox_set_ier(priv, MBOX_IGU1, irq_ier);
+	spin_unlock_irq(&priv->atm_lock);
+}
+
+static void atm_irq_off(u32 irq_id)
+{
+	u32 irq_ier;
+	struct atm_priv *priv = g_atm_tc;
+
+	spin_lock_irq(&priv->atm_lock);
+	irq_ier = tc_r32(MBOX_IGU_IER(MBOX_IGU1));
+	irq_ier &= ~irq_id;
+	mbox_set_ier(priv, MBOX_IGU1, irq_ier);
+	spin_unlock_irq(&priv->atm_lock);
+}
+
+static int atm_showtime_enter(const unsigned char idx,
+		struct port_cell_info *port_cell, void *xdata_addr)
+{
+	int i, j;
+	struct atm_priv *priv = g_atm_tc;
+	struct dc_ep_dev *ep;
+
+	tc_dbg(priv->tc_priv, MSG_EVENT, "ATM Showtime: Enter\n");
+	atm_ppe_ps_restore(priv);
+	if (port_cell != NULL) {
+		for (j = 0; j < ATM_PORT_NUMBER && j < port_cell->port_num;
+				j++)
+			if (port_cell->tx_link_rate[j] > 0)
+				break;
+		if (j >= ATM_PORT_NUMBER) {
+			tc_err(priv->tc_priv, MSG_EVENT,
+				"Invalid tx link rate: %d, %d\n",
+				port_cell->tx_link_rate[0],
+				port_cell->tx_link_rate[1]);
+			return -EINVAL;
+		}
+		for (i = 0; i < ATM_PORT_NUMBER && i < port_cell->port_num;
+			i++) {
+			priv->port[i].tx_max_cell_rate
+				= port_cell->tx_link_rate[i] > 0 ?
+					port_cell->tx_link_rate[i] :
+					port_cell->tx_link_rate[j];
+			/* test QSB */
+			tc_dbg(priv->tc_priv, MSG_EVENT,
+				"ATM Showtime: max rate[%u] args[%u %u]\n",
+				priv->port[i].tx_max_cell_rate,
+				port_cell->tx_link_rate[i],
+				port_cell->tx_link_rate[j]);
+		}
+	} else
+		tc_err(priv->tc_priv, MSG_EVENT, "Invalid PORT CELL\n");
+
+
+	if (idx != priv->ep_id) {
+		tc_err(priv->tc_priv, MSG_EVENT,
+			"Invalid Line [%d]#[%d]\n",
+			idx, priv->ep_id);
+		return 0;
+	}
+
+	/* qsb_global_set(priv); */
+
+	for (i = 0; i < pvc_num(); i++)
+		if ((priv->pvc_tbl & BIT(i)) && priv->conn[i].vcc != NULL)
+			set_qsb(priv, priv->conn[i].vcc,
+				&priv->conn[i].vcc->qos, i);
+	ep = priv->ep;
+	ep->hw_ops->aca_start(priv->ep, ACA_TXIN_EN, 0);
+	tc_info(priv->tc_priv, MSG_EVENT,
+		"ATM line[%d]:enter showtime, cell rate: 0 - %d, 1 - %d\n",
+		idx, priv->port[0].tx_max_cell_rate,
+		priv->port[1].tx_max_cell_rate);
+	atm_dev_signal_change(priv->port[idx].dev, ATM_PHY_SIG_FOUND);
+	return 0;
+}
+
+int atm_power_saving(struct atm_priv *priv, int ps_en, int flag)
+{
+	struct psave_cfg ps_cfg;
+
+	memset(&ps_cfg, 0, sizeof(ps_cfg));
+
+	if (!flag) {
+		tc_mem_read(priv, &ps_cfg,
+			fpi_addr(__PSAVE_CFG), sizeof(ps_cfg));
+		return ps_cfg.sleep_en;
+	} else {
+		tc_mem_read(priv, &ps_cfg,
+			fpi_addr(__PSAVE_CFG), sizeof(ps_cfg));
+		ps_cfg.sleep_en = !!(ps_en);
+		tc_mem_write(priv, fpi_addr(__PSAVE_CFG),
+			&ps_cfg, sizeof(ps_cfg));
+		priv->tc_priv->param.ps = ps_en;
+	}
+
+	return 0;
+}
+
+static int atm_showtime_exit(const unsigned char idx)
+{
+	struct atm_priv *priv = g_atm_tc;
+	u32 stop = ACA_TXIN_EN;
+	struct dc_ep_dev *ep;
+
+	if (!g_atm_tc || g_atm_tc->ep_id != idx)
+		return 0;
+
+	tc_info(priv->tc_priv, MSG_EVENT, "Line[%d]: show time exit!\n", idx);
+
+	atm_dev_signal_change(priv->port[idx].dev, ATM_PHY_SIG_LOST);
+	ep = priv->ep;
+	ep->hw_ops->aca_stop(ep, &stop, 0);
+	/* Stop TXIN traffic, then wait for PPE FW signal */
+	atm_ppe_wakeup(priv);
+
+	return 0;
+}
+
+static int atm_framer_requst_en(const unsigned char idx)
+{
+	struct atm_priv *priv = g_atm_tc;
+
+	ttha_enable(priv);
+	tc_info(priv->tc_priv, MSG_EVENT, "Enable TTHA!\n");
+	return 0;
+}
+
+static void atm_cb_setup(struct atm_priv *priv, int flags)
+{
+	spin_lock_bh(&priv->atm_lock);
+	if (flags) {
+		priv->tc_priv->tc_ops.recv = atm_push;
+		priv->tc_priv->tc_ops.get_qid = atm_get_qid_by_vcc;
+		priv->tc_priv->tc_ops.irq_on = atm_irq_on;
+		priv->tc_priv->tc_ops.irq_off = atm_irq_off;
+		priv->tc_priv->tc_ops.showtime_enter = atm_showtime_enter;
+		priv->tc_priv->tc_ops.showtime_exit = atm_showtime_exit;
+		priv->tc_priv->tc_ops.framer_request_en = atm_framer_requst_en;
+	} else {
+		priv->tc_priv->tc_ops.recv = NULL;
+		priv->tc_priv->tc_ops.get_qid = NULL;
+		priv->tc_priv->tc_ops.irq_on = NULL;
+		priv->tc_priv->tc_ops.irq_off = NULL;
+		priv->tc_priv->tc_ops.showtime_enter = NULL;
+		priv->tc_priv->tc_ops.showtime_exit = NULL;
+		priv->tc_priv->tc_ops.framer_request_en = NULL;
+	}
+	priv->tc_priv->tc_ops.erb_addr_get = NULL;
+	spin_unlock_bh(&priv->atm_lock);
+}
+
+static int atm_datapath_init(struct atm_priv *priv)
+{
+	int err;
+	int ep_id;
+	int irq_id;
+
+	ep_id = priv->ep_id;
+	irq_id = priv->tc_priv->ep_dev[ep_id].irq;
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"%s : ep_id[%d] irq_id[%d]\n", __func__, ep_id, irq_id);
+
+	/* request irq (enable by default) */
+	err = devm_request_irq(priv->ep->dev, priv->ep->irq,
+			atm_irq_handler, 0,
+			g_atm_dev_name, (void *)priv);
+	if (err) {
+		tc_err(priv->tc_priv, MSG_SWITCH,
+			"Failed to request PCIe MSI irq %u\n",
+			irq_id);
+		return err;
+	}
+
+	qsb_global_set(priv);
+	setup_oam_htu_entry(priv);
+
+	atm_hook_mpoa_setup = mpoa_setup;
+	atm_cb_setup(priv, 1);
+
+	return 0;
+}
+
+/* This API no lock protect, should only be called in initialization part */
+static void atm_fw_cfg_init(struct atm_priv *priv)
+{
+	u32 conn;
+
+	tc_dbg(priv->tc_priv, MSG_INIT, "ATM FW PVC init\n");
+
+	if (priv->pvc_tbl)
+		validate_oam_htu_entry(priv, 1);
+	else {
+		tc_dbg(priv->tc_priv, MSG_INIT,
+			"%s : No PVC table\n", __func__);
+		return;
+	}
+
+	for (conn = 0; conn < pvc_num(); conn++) {
+		if ((priv->pvc_tbl & BIT(conn)) != 0)
+			mpoa_setup_sync(priv, conn);
+	}
+
+}
+
+static void ppe_stop(struct atm_priv *priv)
+{
+	pp32_stop(priv, PP32_TX);
+}
+
+static void ppe_start(struct atm_priv *priv)
+{
+	pp32_start(priv, PP32_TX);
+}
+
+
+/**
+* Corresponding to vrx318_atm_tc_hw_fw_init
+* Reset PP32
+* Load firmware
+* Configure PP32
+* Configure registers
+* Configure hardware modules
+*/
+static int atm_tc_hw_fw_init(struct atm_priv *priv)
+{
+	int ep_id;
+	int i;
+
+	ep_id = priv->ep_id;
+	tc_dbg(priv->tc_priv, MSG_INIT, "port	  = %d\n", ep_id);
+	tc_dbg(priv->tc_priv, MSG_INIT, "irq	  = %u\n",
+			priv->tc_priv->ep_dev[ep_id].irq);
+	tc_dbg(priv->tc_priv, MSG_INIT, "membase	  = 0x%08x\n",
+		(unsigned int)priv->tc_priv->ep_dev[ep_id].membase);
+	tc_dbg(priv->tc_priv, MSG_INIT, "phy_membase = 0x%08x\n",
+		(unsigned int)priv->tc_priv->ep_dev[ep_id].phy_membase);
+
+	/* Power on Modem component */
+	tc_clkon(priv->ep, PMU_ATM);
+	/* Reset PPE HW */
+	tc_ppe_rst(priv->ep);
+	/* Set VRX318 PPE clock 576MHz */
+	tc_ppe_clkset(priv->ep, PPE_CLK_576MHZ);
+	set_qsb_clk(priv, 0);
+	/* Clear and disable mailbox   */
+	for (i = MBOX_IGU0; i <= MBOX_IGU2; i++) {
+		mbox_set_ier(priv, i, 0);
+		mbox_clr_isr(priv, i, MBOX_MASK(i));
+	}
+	/* Load firmware to PP32 */
+	ppe_stop(priv);
+	ppe_atm_fw_hw_init(priv, ep_id, 1);
+	atm_fw_load(priv);
+	pp32_load(priv, &priv->fw, 1);
+
+	/* init datapath */
+	atm_datapath_init(priv);
+
+	/* start hardware */
+	setup_dfe_loopback(priv, 0);
+	ppe_start(priv);
+	dfe_loopback_linkup(priv);
+
+
+	/* Init FW tx/rx queue /qsb configuration for pre-set PVCs */
+	atm_fw_cfg_init(priv);
+
+	/* Indicate DSL FW all configuration is ready */
+	/* PPE FW is ready to receive/send packets */
+	tc_stat_indicate(priv, priv->tc_priv->tc_mode, 1);
+
+	/* enable mailbox Interrupts */
+	mbox_set_ier(priv, MBOX_IGU0, 0);
+	/* enable OAM, TC switch */
+	mbox_set_ier(priv, MBOX_IGU1, MBOX_OAM_RX | MBOX_FRAME_STOP);
+	tc_info(priv->tc_priv, MSG_SWITCH, "ATM TC init successfully\n");
+
+	return 0;
+}
+
+int atm_tc_load(struct tc_priv *tc_priv,
+		u32 ep_id, enum dsl_tc_mode tc_mode)
+{
+	int err;
+	struct atm_priv *priv;
+
+	if (tc_priv == NULL) {
+		pr_err("%s : Invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	tc_dbg(tc_priv, MSG_INIT, "TC switch to ATM\n");
+	if (!g_atm_tc) { /*First time initialization */
+		priv = kzalloc(sizeof(struct atm_priv), GFP_KERNEL);
+		if (!priv) {
+			tc_err(tc_priv, MSG_INIT, "Failed to alloc priv buffer\n");
+			err = -ENOMEM;
+			goto err1;
+		}
+		priv->tc_priv = tc_priv;
+		spin_lock_init(&priv->atm_lock);
+		spin_lock_init(&priv->oam_lock);
+		init_completion(&priv->comp);
+		g_atm_tc = priv;
+	} else
+		priv = g_atm_tc;
+
+	/* register atm device */
+	err = atm_dev_init(priv, ep_id);
+	if (err) {
+		tc_err(tc_priv, MSG_INIT,
+			"atm_dev_init failed\n");
+		goto err2;
+	}
+
+	priv->ep = &tc_priv->ep_dev[ep_id];
+	priv->ep_id = ep_id;
+	priv->pdev = priv->ep->dev;
+
+	/* PPE FW/HW init */
+	err = atm_tc_hw_fw_init(priv);
+	if (err) {
+		tc_dbg(tc_priv, MSG_INIT, "failed\n");
+		goto err2;
+	}
+	tc_priv->priv = (void *)priv;
+
+	/* Proc Init */
+	if (atm_tc_proc_init(priv) != 0) {
+		tc_dbg(tc_priv, MSG_INIT, "failed\n");
+		goto err2;
+	}
+	atm_umt_init(priv);
+	atm_aca_init(priv);
+	atm_umt_start(priv);
+
+	if (priv->tc_priv->tc_ops.disable_us != NULL)
+		priv->tc_priv->tc_ops.disable_us(0);
+
+	/* Send userspace TC UP message */
+	tc_ntlk_msg_send(tc_priv, 0, ATM_TC, TC_LOADED, 0, ep_id);
+
+	tc_info(tc_priv, MSG_INIT, "ATM TC Loaded\n");
+	return 0;
+
+err2:
+	kfree(priv);
+	priv = NULL;
+	g_atm_tc = NULL;
+err1:
+	return err;
+}
+
+static void atm_datapath_exit(struct atm_priv *priv)
+{
+	devm_free_irq(priv->pdev, priv->ep->irq, priv);
+}
+
+static void atm_free_mem(struct atm_priv *priv)
+{
+	int i;
+	u32 phy_addr;
+	for (i = 0; i < TOTAL_QOS_DES_NUM; i++) {
+		phy_addr = sb_r32(__US_QOSQ_DES_LIST_BASE + (i << 1));
+		priv->tc_priv->tc_ops.free(phy_addr, US_DIR);
+	}
+	for (i = 0; i < DS_OAM_DES_NUM; i++) {
+		phy_addr = sb_r32(__DS_OAM_DES_LIST_BASE + (i << 1));
+		priv->tc_priv->tc_ops.free(phy_addr, DS_DIR);
+	}
+	/* Free QoS queue buffers */
+	for (i = 0; i < ACA_RXOUT_HD_DESC_NUM; i++) {
+		phy_addr = sb_r32(__DS_PKT_DES_LIST_BASE + (i << 1));
+		priv->tc_priv->tc_ops.free(phy_addr, DS_DIR);
+	}
+	kfree(priv->oam_llst.oam_des_list);
+	return;
+}
+
+/**
+* 1. Indicate DSL FW/PPE FW unload
+* 2. Disable idle cell
+* 3. Wait for PPE FW to complete stop
+* 4. stop PPE and disable TTHA
+* 5. CDMA channel off
+* 6. Clear interrupt
+* 7. Free pre-allocated SoC memory
+*/
+static void atm_ppe_exit(struct atm_priv *priv)
+{
+	int i;
+
+	/* Indicate DSL FW TC Clear */
+	tc_stat_indicate(priv, TC_ATM_SL_MODE, 0);
+
+	/* Disable Idle cell for RX */
+	rtha_idle_keep_disable(priv);
+
+	/* Indicate PPE FW TC switch */
+	sb_w32(1, __MODE_SW_CFG);
+
+	/* Test only, without CBM flush, using PPE FW flush */
+        priv->ep->hw_ops->aca_start(priv->ep, ACA_TXIN_EN, 0);
+
+        /* Delay some time to allow PPE FW complete its task */
+        msleep(1);
+
+	/* Stop PPE FW */
+	ppe_stop(priv);
+
+	/* STOP DMA */
+	atm_cdma_exit(priv);
+
+	/* Disable and Clear all Interrupts */
+	for (i = MBOX_IGU0; i < MBOX_IGU2; i++) {
+		mbox_set_ier(priv, i, 0);
+		mbox_clr_isr(priv, i, MBOX_MASK(i));
+	}
+
+	atm_datapath_exit(priv);
+
+	/* free ptm pre-allocated memory */
+	atm_free_mem(priv);
+
+	return;
+}
+
+
+static void atm_aca_txin_poll(struct atm_priv *priv,
+			u32 dbase, u32 *idx, u32 dnum, u32 *pkt_num)
+{
+	rx_descriptor_t desc;
+	u32 off, cnt, dst, wrp_rd;
+
+	off = *idx;
+	cnt = 0;
+	wrp_rd = dnum * DW_SZ(desc);
+
+	tc_dbg(priv->tc_priv, MSG_SWITCH,
+		"dbase: 0x%x, idx: %u, pending num: %u, wrap_round: %u\n",
+		dbase, off, *pkt_num, wrp_rd);
+
+	while (1) {
+		dst = fpi_addr(dbase + off);
+		tc_mem_read(priv, &desc, dst, sizeof(desc));
+		if (desc.own == 1) {
+			tc_dbg(priv->tc_priv, MSG_SWITCH,
+				"addr: 0x%x, desc ptr: 0x%x\n",
+				dbase + off, desc.data_ptr);
+			priv->tc_priv->tc_ops.free(desc.data_ptr, US_DIR);
+			desc.own = !desc.own;
+			tc_mem_write(priv, dst, &desc, sizeof(desc));
+			cnt++;
+			off = (off + 2) % wrp_rd;
+		} else
+			break;
+	}
+
+	if (cnt != 0) {
+		*idx = off;
+		priv->ep->hw_ops->aca_txin_ack_sub(priv->ep, cnt);
+		sb_w32(1, __TX_IN_ACA_ACCUM_STATUS);
+		*pkt_num -= cnt;
+	} else {
+		tc_err(priv->tc_priv, MSG_SWITCH,
+			"No ACA TXIN PENDING packets!!!\n");
+		*pkt_num = 0;
+	}
+
+	tc_dbg(priv->tc_priv, MSG_SWITCH,
+		"ACA TXIN POLL free %d packets\n", cnt);
+}
+
+static inline void aca_txin_wait(struct atm_priv *priv)
+{
+	msleep(ACA_TXIN_POLL_INTVAL);
+}
+
+static int atm_clear_aca_txin(struct atm_priv *priv,
+			u32 dbase, u32 *idx, u32 dnum, u32 pkt_num)
+{
+	if (!sb_r32(__RX_IN_ACA_ACCUM_STATUS)) {
+		tc_err(priv->tc_priv, MSG_SWITCH,
+			"ACA RXIN not clean\n");
+		return -EBUSY;
+	}
+
+	while (pkt_num > 0) {
+		tc_dbg(priv->tc_priv, MSG_SWITCH,
+			"pending pkt num: %d\n", pkt_num);
+		aca_txin_wait(priv);
+		atm_aca_txin_poll(priv, dbase, idx, dnum, &pkt_num);
+	}
+	return 0;
+}
+
+static void atm_aca_exit(struct atm_priv *priv, u32 pkt_num)
+{
+	struct dc_ep_dev *ep;
+	u32 flag, idx;
+	desq_cfg_ctxt_t desq_cfg;
+
+	ep = priv->ep;
+	tc_mem_read(priv, &desq_cfg,
+		fpi_addr(__US_FP_INQ_DES_CFG_CTXT), sizeof(desq_cfg));
+	idx = desq_cfg.deq_idx;
+	atm_clear_aca_txin(priv, desq_cfg.des_base_addr,
+			&idx, desq_cfg.des_num, pkt_num);
+
+	flag = ACA_TXIN_EN | ACA_TXOUT_EN | ACA_RXIN_EN | ACA_RXOUT_EN;
+	if (ep->hw_ops->aca_stop(ep, &flag, 1) < 0)
+		tc_err(priv->tc_priv, MSG_SWITCH, "ACA is busy: %u!\n", flag);
+}
+
+static void atm_umt_exit(struct atm_priv *priv)
+{
+	struct tc_priv *tcpriv;
+
+	tcpriv = priv->tc_priv;
+	tcpriv->tc_ops.umt_exit(0);
+}
+
+/**
+* Unload Sequence
+* 1. Stop US traffic
+* 2. Disable US/DS idle cell
+* 3. Indicate PPE FW unload and Wait PPE to clear pending packets
+* 4. PPE stop, CDMA chan off, TTHA disable, interrupt clear
+* 5. free pre-allocated SoC memory
+* 6. ACA stop
+* 7. SoC DMA exit, UMT exit
+* 8. power down PPE component including CDMA
+* 9. reset soc port to start from base address
+*/
+void atm_tc_unload(void)
+{
+	struct atm_priv *priv = g_atm_tc;
+	u32 pending_num;
+
+	if (!priv) {
+		pr_err("<%s>: Invalid ATM TC\n", __func__);
+		return;
+	}
+
+	/* Disable US traffic */
+	priv->tc_priv->tc_ops.disable_us(1);
+	/* stop PPE */
+	atm_ppe_exit(priv);
+	/* Get pending ACA TXIN PKT num */
+	/* pending_num = priv->ep->hw_ops->aca_txin_hd_cnt(priv->ep); */
+	/* Enable ACA TXIN */
+	/* priv->ep->hw_ops->aca_start(priv->ep, ACA_TXIN_EN, 0); */
+	/* stop UMT */
+	atm_umt_exit(priv);
+	/* stop ACA */
+	atm_aca_exit(priv, pending_num);
+
+	/* atm_dev_deinit(priv); */
+	/* modem module power off */
+	tc_clkoff(priv->ep, PMU_ATM);
+	/* remove proc */
+	atm_tc_proc_exit(priv);
+	/* remove ATM callback function */
+	atm_cb_setup(priv, 0);
+	/* message for TC DOWN */
+	tc_ntlk_msg_send(priv->tc_priv, 0, ATM_TC, TC_UNLOADED, 0, priv->ep_id);
+
+	tc_info(priv->tc_priv, MSG_SWITCH, "Unload ATM TC successfully\n");
+}
+
+void atm_exit(void)
+{
+	struct atm_priv *priv = g_atm_tc;
+
+	if (!priv)
+		return;
+	atm_dev_deinit(priv);
+	kfree(priv);
+	g_atm_tc = NULL;
+
+	pr_info("ATM TC exit!\n");
+}
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/atm_tc.h b/drivers/net/ethernet/intel/vrx518/tc/inc/atm_tc.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/atm_tc.h
@@ -0,0 +1,393 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#ifndef __VRX318_ATM_TC_H__
+#define __VRX318_ATM_TC_H__
+
+#include <linux/atm.h>
+
+/* ATM Info */
+#define CELL_SIZE		ATM_AAL0_SDU
+#define ATM_PORT_NUMBER		2
+#define ATM_PVC_NUMBER		15
+#define QSB_QUEUE_NUMBER_BASE	1
+#define DEFAULT_RX_HUNT_BITTH	4
+#define DEFAULT_CELL_RATE	320000
+#define ATM_PRIO_Q_NUM		16
+
+#define ATM_PDBRAM_US_BUF_LEN	16
+#define ATM_PDBRAM_DS_OAM_LEN	10
+#define ATM_PDBRAM_DS_BUF_LEN	12
+#define ATM_SB_DS_BUF_LEN	12
+
+/* OAM Definitions */
+#define OAM_HTU_ENTRY_NUMBER	3
+#define OAM_F4_SEG_HTU_ENTRY	0
+#define OAM_F4_TOT_HTU_ENTRY	1
+#define OAM_F5_HTU_ENTRY	2
+#define OAM_F4_CELL_ID		0
+#define OAM_F5_CELL_ID		15
+
+#define HTU_ENTRY_TBL(x)	(__HTU_ENTRY_TABLE + (x)) /* x < 24 */
+#define HTU_MASK_TBL(x)		(__HTU_MASK_TABLE + (x)) /* x < 24 */
+#define HTU_RESULT_TBL(x)	(__HTU_RESULT_TABLE + (x)) /* x < 24 */
+
+#define DS_OAM_DES_NUM          32 /* MAX 32 */
+#define ATM_OAM_SIZE		64
+#define DS_OAM_DES_OWN		1
+
+/* align is required because buffer may allocated in pdb ram */
+#define ATM_TXQ_NUM(qos_en)	((qos_en) ? (QOSQ_NUM / 2) : QOSQ_NUM)
+#define ATM_PVC_NUM(qos_en) ((qos_en) ? (QOSQ_NUM / 2) : ATM_PVC_NUMBER)
+#define DESC_QID(qid)		(((qid) & 0xF) << 3)
+/* Pass Through (No AAL5 encapsulation required) */
+#define DESC_MPOA_PT(pt)	(((pt) & 0x1) << 2)
+#define DESC_MPOA_MD(mode)	((mode) & 0x3) /* MPoA Type */
+#define ATM_DESC_SUBIF_ID(qid, pt, mode) \
+		(DESC_QID(qid) | DESC_MPOA_PT(pt) | DESC_MPOA_MD(mode))
+#define SUBIF_ID_GET(id)	(((id) & 0xF00) >> 8)
+
+#define WRX_Q_CFG(i)		(__WRX_QUEUE_CONFIG + (i) * 10) /* i < 16 */
+#define WTX_Q_CFG(i)		(__WTX_QUEUE_CONFIG + (i) * 25) /* i < 16 */
+
+
+#define TOTAL_QOS_DES_NUM	512
+
+/* QSB Queue Scheduling and Shaping Definitions */
+#define QSB_WFQ_NONUBR_MAX	0x3f00
+#define QSB_WFQ_UBR_BYPASS	0x3fff
+#define QSB_TP_TS_MAX		65472
+#define QSB_TAUS_MAX		64512
+#define QSB_GCR_MIN		18
+
+/* QSB Command Set */
+#define QSB_RAMAC_RW_READ	0
+#define QSB_RAMAC_RW_WRITE	1
+
+#define QSB_RAMAC_TSEL_QPT	0x01
+#define QSB_RAMAC_TSEL_SCT	0x02
+#define QSB_RAMAC_TSEL_SPT	0x03
+#define QSB_RAMAC_TSEL_VBR	0x08
+
+#define QSB_RAMAC_LH_LOW	0
+#define QSB_RAMAC_LH_HIGH	1
+
+#define QSB_QPT_SET_MASK	0x0
+#define QSB_QVPT_SET_MASK	0x0
+#define QSB_SET_SCT_MASK	0x0
+#define QSB_SET_SPT_MASK	0x0
+#define QSB_SET_SPT_SBVALID_MASK 0x7FFFFFFF
+
+#define QSB_RAMAC_RW_SET(x)	(((x) & 0x1) << 31)
+#define QSB_RAMAC_TSEL_SET(x)	(((x) & 0xF) << 24)
+#define QSB_RAMAC_LH_SET(x)	(((x) & 0x1) << 16)
+#define QSB_RAMAC_TESEL_SET(x)	((x) & 0x3FF)
+
+#define QSB_SPT_SBV_VALID	(1 << 31)
+#define QSB_SPT_PN_SET(x)	(((x) & 0x01) << 16)
+#define QSB_SPT_INTRATE_SET(x)	((x) & 0x3FFF)
+
+#define QSB_RTD_TTV_SET(x)	((x) & 0xFFFFFFFF)
+
+/* DSL MIB */
+#define DSL_WAN_MIB_TBL		0x4EF0
+#define DSL_Q_RX_MIB_TBL(i)	(__WRX_VC_MIB_BASE + (i) * 2) /* i < 16 */
+#define DSL_Q_TX_MIB_TBL(i)	(__WTX_VC_MIB_BASE + (i) * 2) /* i < 16 */
+
+#define INQ_QOS_CFG_BASE(off)		fpi_addr(__INQ_QOS_CFG_BASE + (off))
+
+#ifndef ATM_VBR_NRT 
+#define ATM_VBR_NRT	ATM_VBR
+#define ATM_VBR_RT	6
+#define ATM_UBR_PLUS	7
+#define ATM_GFR		8
+#endif
+
+struct tc_priv;
+
+struct htu_entry {
+	unsigned int res1:2;
+	unsigned int pid:2;
+	unsigned int vpi:8;
+	unsigned int vci:16;
+	unsigned int pti:3;
+	unsigned int vld:1;
+};
+
+struct htu_mask {
+	unsigned int set:2;
+	unsigned int pid_mask:2;
+	unsigned int vpi_mask:8;
+	unsigned int vci_mask:16;
+	unsigned int pti_mask:3;
+	unsigned int clear:1;
+};
+
+struct htu_result {
+	unsigned int res1:12;
+	unsigned int cellid:4;
+	unsigned int res2:5;
+	unsigned int type:1;
+	unsigned int ven:1;
+	unsigned int res3:5;
+	unsigned int qid:4;
+};
+
+struct dsl_wan_mib_table {
+	unsigned int res1;
+	unsigned int wrx_drophtu_cell;
+	unsigned int wrx_dropdes_pdu;
+	unsigned int wrx_correct_pdu;
+	unsigned int wrx_err_pdu;
+	unsigned int wrx_dropdes_cell;
+	unsigned int wrx_correct_cell;
+	unsigned int wrx_err_cell;
+	unsigned int wrx_total_byte;
+	unsigned int res2;
+	unsigned int wtx_total_pdu;
+	unsigned int wtx_total_cell;
+	unsigned int wtx_total_byte;
+	unsigned int res3[3];
+};
+
+struct dsl_queue_mib {
+	unsigned int pdu;
+	unsigned int bytes;
+};
+
+struct dsl_queue_drop_mib {
+	unsigned int pdu;
+};
+
+enum {
+	MPOA_TYPE_EOA_WO_FCS	= 0,
+	MPOA_TYPE_EOA_W_FCS	= 1,
+	MPOA_TYPE_PPPOA		= 2,
+	MPOA_TYPE_IPOA		= 3,
+};
+
+enum {
+	MPOA_MODE_VCMUX	= 0,
+	MPOA_MODE_LLC	= 1,
+};
+
+enum {
+	ATM_US_DMA_RXCH = 0,
+	ATM_US_DMA_TXCH = 1,
+	DS_AAL5_DMA_RXCH = 16,
+	DS_AAL5_DMA_TXCH = 17,
+	DS_OAM_DMA_RXCH = 18,
+	DS_OAM_DMA_TXCH = 19,
+};
+
+/* QSB Queue Parameter Table Entry and Queue VBR Parameter Table Entry */
+union qsb_queue_parameter_table {
+	struct {
+		unsigned int res1:1;
+		unsigned int vbr:1;
+		unsigned int wfqf:14;
+		unsigned int tp:16;
+	} bit;
+	unsigned int dword;
+};
+
+union qsb_queue_vbr_parameter_table {
+	struct {
+		unsigned int taus:16;
+		unsigned int ts:16;
+	} bit;
+	unsigned int dword;
+};
+
+enum mpoa_type {
+	MOPA_EOA_WO_FCS	= 0,
+	MPOA_EOA_W_FCS	= 1,
+	MPOA_PPPOA	= 2,
+	MPOA_IPOA	= 3
+};
+
+enum mpoa_mode {
+	MPOA_VCMUX_MODE	= 0,
+	MPOA_LLC_MODE	= 1
+};
+
+enum ip_ver {
+	ATM_IP_IPV4 = 0,
+	ATM_IP_IPV6 = 1
+};
+
+struct atm_oam_llst {
+	u32 *oam_des_list;
+	u32 oam_num;
+	u32 oam_idx;
+};
+
+struct atm_stats {
+	__u64 aal5_rx_pkts;
+	__u64 aal5_rx_bytes;
+	__u64 aal5_rx_errors;
+	__u64 aal5_rx_dropped;
+
+	__u64 oam_rx_pkts;
+	__u64 oam_rx_bytes;
+	__u64 oam_rx_errors;
+	__u64 oam_rx_dropped;
+
+	__u64 aal5_tx_pkts;
+	__u64 aal5_tx_bytes;
+	__u64 aal5_tx_errors;
+	__u64 aal5_tx_dropped;
+
+	__u64 oam_tx_pkts;
+	__u64 oam_tx_bytes;
+	__u64 oam_tx_errors;
+	__u64 oam_tx_dropped;
+};
+
+struct uni_cell_header {
+	unsigned int gfc:4;
+	unsigned int vpi:8;
+	unsigned int vci:16;
+	unsigned int pti:3;
+	unsigned int clp:1;
+};
+
+struct wrx_queue_config_t {
+	/*  0h  */
+	unsigned int new_vlan:16;
+	unsigned int res1:3;
+	unsigned int vlan_ins:1;
+	/* 0: EoA without FCS, 1: EoA with FCS, 2: PPPoA, 3:IPoA */
+	unsigned int mpoa_type:2;
+	/* 0: IPv4, 1: IPv6 */
+	unsigned int ip_ver:1;
+	/* 0: VCmux, 1: LLC */
+	unsigned int mpoa_mode:1;
+	unsigned int res2:8;
+	/*  1h  */
+	unsigned int oversize:16;
+	unsigned int undersize:16;
+	/*  2h  */
+	unsigned int res3:16;
+	unsigned int mfs:16;
+	/*  3h  */
+	unsigned int uumask:8;
+	unsigned int cpimask:8;
+	unsigned int uuexp:8;
+	unsigned int cpiexp:8;
+};
+
+struct wtx_port_config_t {
+	unsigned int res1:27;
+	unsigned int qid:4;
+	unsigned int qsben:1;
+};
+
+struct wtx_queue_config_t {
+	/*  0h  */
+	unsigned int res0:16;
+	/* TX Q0, Q2, Q4 is VCID1, config TX Q0, */
+	/* value is binary 0000000000010100.*/
+	/*Set all queue in this VC with 1 except this queue.*/
+	unsigned int same_vc_qmap:16;
+	/*  1h  */
+	unsigned int uu:8;
+	unsigned int cpi:8;
+	unsigned int res1:9;
+	unsigned int sbid:1;
+	/* Which QSB queue (VCID) does this TX queue map to. */
+	unsigned int qsb_vcid:4;
+	/* 0: VCmux, 1: LLC */
+	unsigned int mpoa_mode:1;
+	/* reserved in A5 */
+	unsigned int qsben:1;
+	/*  2h  */
+	unsigned int atm_header:32;
+};
+
+struct atm_port {
+	struct atm_dev *dev;
+	/* maximum cell rate */
+	unsigned int tx_max_cell_rate;
+	/* currently used cell rate */
+	unsigned int tx_used_cell_rate;
+};
+
+struct atm_pvc {
+	struct atm_vcc *vcc; /* opened VCC */
+	struct net_device *dev; /* net device associated with atm VCC */
+	struct timespec access_time; /* time when last user cell arrived */
+	int prio_queue_map[ATM_PRIO_Q_NUM];
+	unsigned int prio_tx_packets[ATM_PRIO_Q_NUM];
+	struct atm_stats stats;
+	unsigned int port; /* to which port the connection belongs */
+	unsigned int sw_txq_tbl; /* Software TX Q used for this connection */
+	int subif_id;
+	int mpoa_type;
+	int mpoa_mode;
+};
+
+struct atm_priv {
+	struct dc_ep_dev *ep;
+	struct tc_priv *tc_priv;
+	int ep_id;
+	struct ppe_fw fw;
+	struct atm_port port[ATM_PORT_NUMBER];
+	struct atm_pvc conn[ATM_PVC_NUMBER]; /*conn id is same as subif id*/
+	struct net_device *dev;
+	struct device *pdev;
+	u32 pvc_tbl; /* PVC opened status, one for one connection*/
+	u32 sw_txq_tbl; /*including pvc and its sw tx queue */
+	spinlock_t atm_lock;
+	spinlock_t oam_lock;
+	struct proc_dir_entry *proc_dir;
+	struct atm_oam_llst oam_llst;
+	struct atm_stats stats;
+	struct completion comp;
+	int subif_id;
+};
+
+extern void (*atm_hook_mpoa_setup)(struct atm_vcc *, int,
+				int, struct net_device *);
+#if defined(CONFIG_LTQ_OAM) || defined(CONFIG_LTQ_OAM_MODULE)
+extern void ifx_push_oam(unsigned char *);
+#endif
+extern void show_atm_pvc(struct seq_file *, const struct atm_pvc *);
+extern int atm_in_showtime(void);
+extern int proc_read_queue(struct seq_file *, void *);
+extern int proc_read_htu(struct seq_file *, void *);
+extern int sw_tx_queue_add(struct atm_priv *, int);
+extern int sw_tx_queue_del(struct atm_priv *, int);
+extern void print_drv_mib(struct seq_file *, struct atm_priv *);
+extern void print_stat_mib(struct seq_file *, struct atm_stats *);
+extern int atm_power_saving(struct atm_priv *, int, int);
+extern int proc_read_atm_wanmib(struct seq_file *, void *);
+extern int proc_clear_atm_wanmib(struct atm_priv *);
+extern int sw_tx_queue_del(struct atm_priv *, int);
+extern int sw_tx_queue_add(struct atm_priv *, int);
+extern unsigned int find_vpi(unsigned int);
+extern unsigned int find_vpivci(unsigned int, unsigned int);
+extern int ppe_send_oam(struct atm_vcc *, void *, int);
+extern int conn_valid(unsigned int);
+
+#endif /* __VRX318_ATM_TC_H__ */
+
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/dfe.h b/drivers/net/ethernet/intel/vrx518/tc/inc/dfe.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/dfe.h
@@ -0,0 +1,49 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+
+#ifndef __DFE_H__
+#define __DFE_H__
+
+#define MEI_OFFSET		0x2C0000
+#define DSL_OFFSET		0x2D0000
+#define MEIAD(a)		((a)+MEI_OFFSET)
+
+/* Dsp Mgmt Address Constants */
+#define DSP_MGMT_BASE		(0x0000)
+#define DSP_MGMT_REG(r)		(DSP_MGMT_BASE + (r))
+#define ME_ARC2ME_STAT		DSP_MGMT_REG(0x0004)
+#define ME_DBG_RD_AD		DSP_MGMT_REG(0x002C)
+#define ME_DBG_WR_AD		DSP_MGMT_REG(0x0030)
+#define ME_DBG_DATA		DSP_MGMT_REG(0x0034)
+
+
+struct me_cfg_def {
+	u32 addr;
+	u32 data;
+	u32 type;
+};
+
+/* Header file to set the Loopback rate to programmable! */
+#include "prograte.h"
+
+#endif /* __DFE_H__ */
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/fw/unified_qos_ds_base_vrx518_be.h b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/unified_qos_ds_base_vrx518_be.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/unified_qos_ds_base_vrx518_be.h
@@ -0,0 +1,256 @@
+
+#ifndef __UNIFIED_QOS_DS_BASE_VRX518_BE_H_
+#define __UNIFIED_QOS_DS_BASE_VRX518_BE_H_
+
+	typedef struct {
+
+		unsigned int enq_mbox_addr;
+
+		unsigned int enq_mbox_int_q0_val;
+
+		unsigned int deq_mbox_addr;
+
+		unsigned int deq_mbox_int_q0_val;
+
+	} qosq_event_mbox_int_cfg_t;
+
+	typedef struct {
+
+		unsigned int time_tick:16;
+		unsigned int qosq_num:8;
+		unsigned int _res0:7;
+		unsigned int qos_en:1;
+
+	} qos_cfg_t;
+
+	typedef struct {
+
+		unsigned int _res0:11;
+		unsigned int port_shaper_enable_map:1;
+		unsigned int outq_shaper_enable_map:4;
+		unsigned int qosq_shaper_enable_map:16;
+
+	} shaping_cfg_t;
+
+	typedef struct {
+
+		unsigned int wfq_force_reload_map:16;
+		unsigned int wfq_reload_enable_map:16;
+
+	} wfq_cfg_t;
+
+	typedef struct {
+
+		unsigned int time_tick:16;
+		unsigned int overhd_bytes:8;
+		unsigned int eth1_eg_qnum:4;
+		unsigned int _res0:1;
+		unsigned int eth1_qss:1;
+		unsigned int shape_en:1;
+		unsigned int wfq_en:1;
+
+	} tx_qos_cfg_t;
+
+	typedef struct {
+
+		unsigned int mailbox_int_addr;
+
+		unsigned int mailbox_value;
+
+	} desq_mbox_int_cfg_t;
+
+	typedef struct {
+
+		unsigned int des_in_own_val:1;
+		unsigned int _res0:1;
+		unsigned int mbox_int_en:1;
+		unsigned int _res1:5;
+		unsigned int des_num:8;
+		unsigned int des_base_addr:16;
+
+		unsigned int mbox_int_cfg_ptr:16;
+		unsigned int enq_idx:16;
+
+	} swapq_cfg_ctxt_t;
+
+	typedef struct {
+
+		unsigned int des_in_own_val:1;
+		unsigned int fast_path:1;
+		unsigned int mbox_int_en:1;
+		unsigned int des_sync_needed:1;
+		unsigned int _res0:1;
+		unsigned int gif_id:3;
+		unsigned int des_num:8;
+		unsigned int des_base_addr:16;
+
+		unsigned int mbox_int_cfg_ptr:16;
+		unsigned int bp_des_base_addr:16;
+
+		unsigned int deq_idx:16;
+		unsigned int enq_idx:16;
+
+		unsigned int _dw_res0;
+
+		unsigned int enq_pkt_cnt;
+
+		unsigned int enq_byte_cnt;
+
+		unsigned int deq_pkt_cnt;
+
+		unsigned int deq_byte_cnt;
+
+	} desq_cfg_ctxt_t;
+
+	typedef struct {
+
+		unsigned int qos_en:1;
+		unsigned int _res0:7;
+		unsigned int qid_mask:4;
+		unsigned int qosq_base_qid:4;
+		unsigned int desq_cfg_ctxt:16;
+
+	} inq_qos_cfg_t;
+
+	typedef struct {
+
+		unsigned int threshold:8;
+		unsigned int des_num:8;
+		unsigned int des_base_addr:16;
+
+		unsigned int deq_idx:16;
+		unsigned int enq_idx:16;
+
+	} qosq_cfg_ctxt_t;
+
+	typedef struct {
+
+		unsigned int qmap:16;
+		unsigned int overhd_bytes:8;
+		unsigned int _res0:4;
+		unsigned int weight_reload:1;
+		unsigned int wfq_en:1;
+		unsigned int shape_en:1;
+		unsigned int qos_en:1;
+
+		unsigned int l2_shaping_cfg_ptr:16;
+		unsigned int l3_shaping_cfg_ptr:16;
+
+		unsigned int _res1:2;
+		unsigned int l2_shaping_cfg_idx:5;
+		unsigned int l3_shaping_cfg_idx:5;
+		unsigned int _res2:4;
+		unsigned int desq_cfg_ctxt:16;
+
+		unsigned int weight_negative_qmap:16;
+		unsigned int shaping_done_qmap:16;
+
+	} outq_qos_cfg_ctxt_t;
+
+	typedef struct {
+
+		unsigned int t:8;
+		unsigned int w:24;
+
+		unsigned int s:16;
+		unsigned int r:16;
+
+		unsigned int _res0:8;
+		unsigned int d:24;
+
+		unsigned int q_off:1;
+		unsigned int shaping_min_b_check:1;
+		unsigned int _res1:6;
+		unsigned int tick_cnt:8;
+		unsigned int b:16;
+
+	} shaping_wfq_cfg_t;
+
+	typedef struct {
+
+		unsigned int rx_pkt_cnt;
+
+		unsigned int rx_byte_cnt;
+
+		unsigned int tx_pkt_cnt;
+
+		unsigned int tx_byte_cnt;
+
+		unsigned int small_pkt_drop_cnt;
+
+		unsigned int small_pkt_drop_byte_cnt;
+
+		unsigned int large_pkt_drop_cnt;
+
+		unsigned int large_pkt_drop_byte_cnt;
+
+	} qosq_mib_t;
+
+	typedef struct {
+
+		unsigned int large_frame_drop_th:16;
+		unsigned int large_frame_size:16;
+
+	} qosq_flow_ctrl_cfg_t;
+
+	typedef struct {
+
+		unsigned int _res0:14;
+		unsigned int byte_off:2;
+		unsigned int data_len:16;
+
+	} std_des_cfg_t;
+
+	typedef struct {
+
+		unsigned int data_ptr:32;
+
+		unsigned int own:1;
+		unsigned int c:1;
+		unsigned int sop:1;
+		unsigned int eop:1;
+		unsigned int dic:1;
+		unsigned int pdu_type:1;
+		unsigned int byte_off:3;
+		unsigned int qos:4;
+		unsigned int mpoa_pt:1;
+		unsigned int mpoa_type:2;
+		unsigned int data_len:16;
+
+	} tx_descriptor_t;
+
+	typedef struct {
+
+		unsigned int _res0:30;
+		unsigned int data_len_adj:2;
+
+	} des_sideband_t;
+
+	typedef struct {
+
+		unsigned int data_ptr:32;
+
+		unsigned int own:1;
+		unsigned int c:1;
+		unsigned int sop:1;
+		unsigned int eop:1;
+		unsigned int dic:1;
+		unsigned int pdu_type:1;
+		unsigned int byte_off:3;
+		unsigned int qos:4;
+		unsigned int mpoa_pt:1;
+		unsigned int gid:2;
+		unsigned int data_len:16;
+
+	} rx_descriptor_t;
+
+	typedef struct {
+
+		unsigned int _res0:16;
+		unsigned int overflow_state_threshold:8;
+		unsigned int non_overflow_state_threshold:8;
+
+	} flow_control_cfg_t;
+
+#endif
+
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vr9_bonding_fw_data_structure_base_vrx518_be.h b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vr9_bonding_fw_data_structure_base_vrx518_be.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vr9_bonding_fw_data_structure_base_vrx518_be.h
@@ -0,0 +1,341 @@
+
+#ifndef __VR9_BONDING_FW_DATA_STRUCTURE_BASE_VRX518_BE_H_
+#define __VR9_BONDING_FW_DATA_STRUCTURE_BASE_VRX518_BE_H_
+
+	typedef struct {
+
+		unsigned int data_ptr:32;
+
+		unsigned int own:1;
+		unsigned int c:1;
+		unsigned int sop:1;
+		unsigned int eop:1;
+		unsigned int res0:3;
+		unsigned int byte_off:2;
+		unsigned int qos:4;
+		unsigned int res1:3;
+		unsigned int data_len:16;
+
+	} cdma_rx_des_t;
+
+	typedef struct {
+
+		unsigned int data_ptr:32;
+
+		unsigned int own:1;
+		unsigned int c:1;
+		unsigned int sop:1;
+		unsigned int eop:1;
+		unsigned int byte_off:5;
+		unsigned int res0:7;
+		unsigned int data_len:16;
+
+	} cdma_tx_des_t;
+
+	typedef struct {
+
+		unsigned int data_ptr:32;
+
+		unsigned int own:1;
+		unsigned int c:1;
+		unsigned int sop:1;
+		unsigned int eop:1;
+		unsigned int byte_off:5;
+		unsigned int last_frag:1;
+		unsigned int frag_num:6;
+		unsigned int data_len:16;
+
+	} us_bond_pkt_des_t;
+
+	typedef struct {
+
+		unsigned int data_ptr:32;
+
+		unsigned int own:1;
+		unsigned int c:1;
+		unsigned int sop:1;
+		unsigned int eop:1;
+		unsigned int byte_off:5;
+		unsigned int qid:4;
+		unsigned int res0:2;
+		unsigned int bp_tx_done:1;
+		unsigned int data_len:16;
+
+	} us_e1_frag_des_t;
+
+	typedef struct {
+
+		unsigned int frag_header:16;
+		unsigned int status:1;
+		unsigned int pkt_des_ptr:15;
+
+	} us_e1_frag_des_bp_t;
+
+	typedef struct {
+
+		unsigned int data_ptr:32;
+
+		unsigned int own:1;
+		unsigned int c:1;
+		unsigned int sop:1;
+		unsigned int eop:1;
+		unsigned int byte_off:5;
+		unsigned int gid:2;
+		unsigned int res0:5;
+		unsigned int data_len:16;
+
+	} ds_e1_frag_des_t;
+
+	typedef struct {
+
+		unsigned int next_des_ptr:16;
+		unsigned int data_len:16;
+
+		unsigned int data_ptr:32;
+
+	} ds_bond_gif_ll_des_t;
+
+	typedef struct {
+
+		unsigned int family:4;
+		unsigned int fw_type:4;
+		unsigned int interface:4;
+		unsigned int fw_mode:4;
+		unsigned int major:8;
+		unsigned int minor:8;
+
+	} fw_ver_id_t;
+
+	typedef struct {
+
+		unsigned int max_frag_size:16;
+		unsigned int polling_ctrl_cnt:8;
+		unsigned int dplus_fp_fcs_en:1;
+		unsigned int bg_num:3;
+		unsigned int bond_mode:1;
+		unsigned int e1_bond_en:1;
+		unsigned int d5_acc_dis:1;
+		unsigned int d5_b1_en:1;
+
+	} bond_conf_t;
+
+	typedef struct {
+
+		unsigned int queue_map3:8;
+		unsigned int queue_map2:8;
+		unsigned int queue_map1:8;
+		unsigned int queue_map0:8;
+
+	} us_bg_qmap_t;
+
+	typedef struct {
+
+		unsigned int gif_map3:8;
+		unsigned int gif_map2:8;
+		unsigned int gif_map1:8;
+		unsigned int gif_map0:8;
+
+	} us_bg_gmap_t;
+
+	typedef struct {
+
+		unsigned int gif_map3:8;
+		unsigned int gif_map2:8;
+		unsigned int gif_map1:8;
+		unsigned int gif_map0:8;
+
+	} ds_bg_gmap_t;
+
+	typedef struct {
+
+		unsigned int time;
+
+	} curr_time_stamp_t;
+
+	typedef struct {
+
+		unsigned int bp_desba:16;
+		unsigned int desba:16;
+
+	} us_e1_frag_desba_t;
+
+	typedef struct {
+
+		unsigned int dma_des_ba:16;
+		unsigned int desba:16;
+
+	} ds_e1_frag_desba_t;
+
+	typedef struct {
+
+		unsigned int prefix:16;
+		unsigned int mask:16;
+
+	} data_ptr_pdma_prefix_cfg_t;
+
+	typedef struct {
+
+		unsigned int _res0:16;
+		unsigned int outq_erb_cfg_ctxt:16;
+
+		unsigned int _res1:16;
+		unsigned int outq_erb_peer_cfg_ctxt:16;
+
+		unsigned int _res2:31;
+		unsigned int peer_flag:1;
+
+		unsigned int _dw_res0;
+
+	} bg_erb_cfg_ctxt_t;
+
+	typedef struct {
+
+		unsigned int sid:14;
+		unsigned int sop:1;
+		unsigned int eop:1;
+		unsigned int pkt_status:1;
+		unsigned int des_addr:15;
+
+		unsigned int data_ptr:32;
+
+		unsigned int erb_pkt:1;
+		unsigned int erb_peer:1;
+		unsigned int res1:4;
+		unsigned int byte_off:3;
+		unsigned int qid:4;
+		unsigned int gif_id:3;
+		unsigned int rem_len:16;
+
+		unsigned int _res0:16;
+		unsigned int desq_cfg_ctxt_ptr:16;
+
+	} us_bg_ctxt_t;
+
+	typedef struct {
+
+		unsigned int tail_ptr:16;
+		unsigned int head_ptr:16;
+
+		unsigned int sid:14;
+		unsigned int sop:1;
+		unsigned int eop:1;
+		unsigned int fh_valid:1;
+		unsigned int des_num:15;
+
+		unsigned int max_des_num:8;
+		unsigned int to_buff_thres:8;
+		unsigned int max_delay:16;
+
+		unsigned int timeout;
+
+	} ds_bond_gif_ll_ctxt_t;
+
+	typedef struct {
+
+		unsigned int total_rx_frag_cnt;
+
+		unsigned int total_rx_byte_cnt;
+
+		unsigned int overflow_frag_cnt;
+
+		unsigned int overflow_byte_cnt;
+
+		unsigned int out_of_range_frag_cnt;
+
+		unsigned int missing_frag_cnt;
+
+		unsigned int timeout_frag_cnt;
+
+		unsigned int _dw_res0[9];
+
+	} ds_bond_gif_mib_t;
+
+	typedef struct {
+
+		unsigned int conform_pkt_cnt;
+
+		unsigned int conform_frag_cnt;
+
+		unsigned int conform_byte_cnt;
+
+		unsigned int no_sop_pkt_cnt;
+
+		unsigned int no_sop_frag_cnt;
+
+		unsigned int no_sop_byte_cnt;
+
+		unsigned int no_eop_pkt_cnt;
+
+		unsigned int no_eop_frag_cnt;
+
+		unsigned int no_eop_byte_cnt;
+
+		unsigned int oversize_pkt_cnt;
+
+		unsigned int oversize_frag_cnt;
+
+		unsigned int oversize_byte_cnt;
+
+		unsigned int noncosec_pkt_cnt;
+
+		unsigned int noncosec_frag_cnt;
+
+		unsigned int noncosec_byte_cnt;
+
+		unsigned int _dw_res0;
+
+	} ds_bg_mib_t;
+
+	typedef struct {
+
+		unsigned int link_state_chg:1;
+		unsigned int res0:15;
+		unsigned int expected_sid:14;
+		unsigned int last_sop:1;
+		unsigned int last_eop:1;
+
+		unsigned int res1:22;
+		unsigned int bg_pkt_state:2;
+		unsigned int res2:3;
+		unsigned int noncosec_flag:1;
+		unsigned int oversize_flag:1;
+		unsigned int no_eop_flag:1;
+		unsigned int no_sop_flag:1;
+		unsigned int no_err_flag:1;
+
+		unsigned int curr_pkt_frag_cnt;
+
+		unsigned int curr_pkt_byte_cnt;
+
+		unsigned int tail_ptr:16;
+		unsigned int head_ptr:16;
+
+		unsigned int sid:14;
+		unsigned int sop:1;
+		unsigned int eop:1;
+		unsigned int fh_valid:1;
+		unsigned int des_num:15;
+
+		unsigned int _dw_res0[2];
+
+	} ds_bg_ctxt_t;
+
+	typedef struct {
+
+		unsigned int byte_cnt:10;
+		unsigned int int_mem_addr_off:11;
+		unsigned int res0:6;
+		unsigned int eop:1;
+		unsigned int pdma:1;
+		unsigned int sar:1;
+		unsigned int bc:2;
+
+		unsigned int res1:1;
+		unsigned int ext_mem_addr:29;
+		unsigned int release:1;
+		unsigned int pdma_cmd_type:1;
+
+	} pdma_dira_cmd_t;
+
+#endif
+
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_a1plus_addr_def.h b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_a1plus_addr_def.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_a1plus_addr_def.h
@@ -0,0 +1,773 @@
+#ifndef	__VRX518_A1PLUS_ADDR_DEF_INC
+#define	__VRX518_A1PLUS_ADDR_DEF_INC
+
+/*==========================================================================
+	Defines for "PPE	DSL	Notifications" Module
+	==========================================================================*/
+#define	__DREG_BC0_LINK_STATUS							0x7DC0
+#define	__DREG_BC1_LINK_STATUS							0x7DD0
+#define	__DREG_MEI_STATE										0x7DC1
+#define	__DREG_PDBRAM_S_44K_OWN							0x7DC2
+#define	__DREG_SIGNATURE										0x7DC3
+#define	__SFSM_PGCNT0												0x741C
+#define	__SFSM_PGCNT1												0x741D
+
+/*==========================================================================
+	General Configuration:	 0x2000	-	0x202F
+	Need	to be	refined	further
+	==========================================================================*/
+#define	__FW_VER_ID											0x2001
+#define	__PP32_0_TIME										0x2002
+#define	__PP32_1_TIME										0x2003
+
+#define	__DSL_LINK_DOWN									0x2004
+
+/* to support unified driver	for	ATM/PTM*/
+#define	__TC_SWITCH_FLAG								0x2005
+#define	__PREV_TC_SWITCH_FLAG						0x2006
+
+/*Number of	times	DREG_PDBRAM_S_44K_OWN	changes	from S_44K_OWN_PPE to	S_44K_OWN_DSL*/
+#define	__PDBRAM_OWN_CHG_CNT						0x34B7
+
+#define	__CFG_WRX_HTUTS									0x2010
+#define	__STD_DES_CFG										0x2011
+#define	__CFG_STD_DATA_LEN							__STD_DES_CFG
+#define	__QOS_CFG												0x2012
+#define	__TX_QOS_CFG										__QOS_CFG
+#define	__QOSQ_FLOW_CTRL_CFG						0x2013
+#define	__CFG_TX_QOSQ_BANDWIDTH_CTRL		__QOSQ_FLOW_CTRL_CFG
+
+#define	__PSAVE_CFG											0x2014
+
+#define	__CFG_WRX_DMACH_ON							0x2015
+#define	__CFG_WTX_DMACH_ON							0x2016
+#define	__CFG_WRX_HUNT_BITTH						0x2017
+#define	__CFG_WAN_WRDES_DELAY						0x2018
+
+#define	__QOS_SHADOW_TTICK							0x201E
+#define	__TX_QOS_CFG_SHADOW							__QOS_SHADOW_TTICK
+
+#define	__PP32_0_TASK_CFG								0x2020
+#define	__PP32_1_TASK_CFG								0x2021
+
+#define	__PP32_0_MODULE_ACTIVITY				0x2022
+#define	__PP32_1_MODULE_ACTIVITY				0x2023
+#define	__VRX218_FLOW_CTRL_CFG					 0x2026	 /*	new	*/
+
+/*=============================================================================
+	Unified QoS Part
+	=============================================================================*/
+#define	__INQ_QOS_CFG_BASE							0x2508	/* 0x2508-0x2509	2		x	1	=	2				*/
+
+
+/*#define	__US_FAST_PATH_DES_LIST_BASE		0x2580*/	/* 0x2580-0x25FF	64	x	2	=	128			*/
+
+#define	__US_FAST_PATH_DES_LIST_BASE		0xA070	/* 0xA070-0xA0EF	64	x	2	=	128			*/
+#define	__US_FAST_PATH_DES_LIST_SIZE		128
+#define	__US_FAST_PATH_DES_LIST_NUM			64
+#define	__US_FAST_PATH_DES_LIST_GUARD		63
+
+
+#define	__US_CPU_PATH_DEST_LIST_BASE		0x3D00	/* 0x3D00-0x3D7F	64	x	2	=	128			*/
+#define	__QOSQ_OVERFLOW_STATE_BMAP			0x250c	/* 0x250c-0x250c	1		x	1	=	1				*/
+
+#define	__QOSQ_CFG_CTXT_BASE						0x2FE0	/* 0x2FE0-0x2FFF	16	x	2	=	32			*/
+#define	__QOSQ_PSEUDO_DES_CFG_BASE			0x2E80	/* 0x2E80-0x2EFF	16	x	8	=	128			*/
+/*#define	__US_QOSQ_DES_LIST_BASE					0x2800*/	/* 0x2800-0x2BFF	512	x	2	=	1024		*/
+
+
+#define	__US_QOSQ_DES_LIST_BASE					0xA9F0			/* 0xA9F0-0xADEF	16 x 32	x	2	=	1024 (VRX318:	0x2800)		*/
+#define	__US_QOSQ_DES_LIST_SIZE					256
+#define	__US_QOSQ_DES_LIST_NUM_Q				2						/* Number	of QOSQ	-one for preemption, one for non-preemption	*/
+#define	__US_QOSQ_DES_LIST_PERQ_NUM			64					/* Number	of descriptors per QOSQ	*/
+
+
+#define	__QOSQ_PKT_CNT									0x2680	 /*	0x2680-0x268f	16	 x 1 = 1			 */
+
+#define	__QOSQ_MIB_BASE									0x2030	/* 0x2030-0x20AF	16	x	8	=	128			*/
+#define	__QOSQ_EVENT_MBOX_INT_CFG				0x3F10	/* 0x3F10-0x3F13	1		x	4	=	4				*/
+#define	__SWAPQ_CFG_CTXT_BASE						0x2500	/* 0x2500-0x2501	1		*	2	=	2				*/
+#define	__SWAPQ_DES_LIST_BASE						0x3F60	/* 0x3F60-0x3F9F	32	*	2	=	64			*/
+#define	__DESQ_MBOX_INT_CFG							0x3F14	/* 0x3F14-0x3F1F	6		 x 2 = 12			*/
+
+#define	__US_FP_INQ_DES_CFG_CTXT				0x20B0	/* 0x20B0-0x20B7	1	 x 8 = 8			*/
+#define	__US_CPU_INQ_DES_CFG_CTXT				0x20B8	/* 0x20B8-0x20BF	1	 x 8 = 8			*/
+
+/*=============================================================================
+	Des Queues, CDMA	 copy	channel	mgm, des_sync	(SmartPhy	Part)
+	=============================================================================*/
+#define	__US_TC_LOCAL_Q_CFG_CTXT_BASE		0x2E00	/* 0x2E00-0x2E7F	16 x 8 = 128 */
+/*#define	__US_TC_LOCAL_Q_DES_LIST_BASE		0x2360*/	/* 0x2360-0x238F	1	 x 48= 48	 */
+
+
+#define	__US_TC_LOCAL_Q_DES_LIST_BASE				0xA000	/* 0xA000-0xA03F	2	x	16 x 2=	64	*/
+#define	__US_TC_LOCAL_Q_DES_LIST_SIZE				64
+#define	__US_TC_LOCAL_Q_DES_LIST_NUM_Q			16
+#define	__US_TC_LOCAL_Q_DES_LIST_PERQ_NUM		2
+
+
+#define	__DS_TC_AAL5_LOCAL_Q_CFG_CTXT		0x20E0	/* 0x20E0-0x20E7	1	 x 8 = 8	*/
+#define	__DS_TC_OAM_LOCAL_Q_CFG_CTXT		0x20E8	/* 0x20E8-0x20EF	1	 x 8 = 8	*/
+
+/*#define	__DS_TC_LOCAL_AAL5Q_DES_LIST_BASE		0x3F20*/	/* 0x3F20-0x3F5F	32	x	2	=	64	*/
+
+/*cdma read*/
+#define	__US_CDMA_COPY_CH_CFG						0x2340	/* 0x2350-0x2350	1	x	1	=	1		*/
+#define	__US_CDMA_CHAN_NO				8
+#define	__US_CDMA_READ_CH_CFG_CTXT			0x2798	/* 0x2798-0x279F	1	 x 8 = 8	 */
+#define	__US_CDMA_EXT_SB_BASE						0xBA80	/* 0xBA80-0xBC7F	128x4=512*/
+
+#define	__US_LOCAL_Q_SHARED_CDMA_BASE		0xB980
+#define	__US_LOCAL_Q_SHARED_CDMA_NUM		128
+#define	__US_QOS_Q_SHARED_CDMA_BASE			0xB880
+#define	__US_QOS_Q_SHARED_CDMA_NUM			128
+
+
+/*PDBRAM limitation, allocate	extra	SB for descriptors only, to	match	PTM	descriptor list*/
+#define	__DS_TC_LOCAL_AAL5Q_DES_LIST_BASE		0xB000	/* 0xB000-0xB03F	30 x 2 = 60	(VRX318:0x3F20)	*/
+#define	__DS_TC_LOCAL_AAL5Q_DES_LIST_SIZE		48
+#define	__DS_TC_LOCAL_AAL5Q_DES_LIST_NUM		24
+
+
+/*#define	__DS_TC_LOCAL_OAMQ_DES_LIST_BASE		0x24D0*/	/* 0x24D0-0x24EF	16	x	2	=	32	*/
+
+#define	__DS_TC_LOCAL_OAMQ_DES_LIST_BASE	 0xB040	 /*	0xB040-0xB053	 10	x	2	=	20 (VRX318:0x24D0) */
+#define	__DS_TC_LOCAL_OAMQ_DES_LIST_SIZE	 20
+#define	__DS_TC_LOCAL_OAMQ_DES_LIST_NUM		 10
+
+#define	__DS_PKT_DESQ_CFG_CTXT					0x20F0	/* 0x20F0-0x20F7	1	 x 8 = 8	 */
+
+#define	__DS_PKT_DES_LIST_BASE					0xB100	/* 0xB100-0xB13F	32 x 2 = 64	(VRX318: 0x2600)*/
+#define	__DS_PKT_DES_LIST_SIZE					64
+#define	__DS_PKT_DES_LIST_NUM						32
+#define	__DS_PKT_DES_LIST_GUARD					31
+
+#define	__DS_OAM_DESQ_CFG_CTXT					0x20F8	/* 0x20F8-0x20FF	1	 x 8 = 8	 */
+/*#define	__DS_OAM_DES_LIST_BASE					0x2640*/	/* 0x2640-0x267F	32 x 2 = 64*/
+
+#define	__DS_OAM_DES_LIST_BASE					0xB060	/* 0xB060-0xB09F	32 x 2 = 64	(VRX318: 0x2640)*/
+#define	__DS_OAM_DES_LIST_SIZE					64
+#define	__DS_OAM_DES_LIST_NUM						32
+#define	__DS_OAM_DES_LIST_GUARD					31
+
+#define	__DES_SYNC_CFG_CTXT							0x2F00	/* 0x2F00-0x2FBF	6	 x 32= 192*/
+#define	__CDMA_DES_SYNC_DEST_LIST_BASE	0x27A0	/* 0x27A0-0x27FF	6	 x 4 x 2 x 2 = 96	*/
+
+/*----------------------------------------------------------
+	Detailed	Memory Allocation
+	----------------------------------------------------------*/
+
+/***********************************************
+	"Unified QoS"	Module Memory	Allocation - START
+	***********************************************/
+
+/*2	INQs;	CPU	Path & Fast	Path*/
+#define	__INQ_QOS_CFG_BASE							0x2508
+#define	__INQ_QOS_CFG_END								0x2509
+#define	__INQ_QOS_CFG_SIZE							1
+
+/*16 QoSQs*/
+#define	__QOSQ_CFG_CTXT_BASE						0x2FE0
+#define	__QOSQ_CFG_CTXT_END							0x2FFF
+#define	__QOSQ_CFG_CTXT_SIZE						2
+
+/*16 QoSQs*/
+#define	__QOSQ_MIB_BASE									0x2030
+#define	__QOSQ_MIB_END									0x20AF
+#define	__QOSQ_MIB_SIZE									8
+
+
+/*#define	__SWAPQ_CFG_CTXT_BASE						0x2500*/
+#define	__SWAPQ_CFG_CTXT_DW1_ADDR				0x2501
+#define	__SWAPQ_CFG_CTXT_END						0x2501
+#define	__SWAPQ_CFG_CTXT_SIZE						2
+
+/***********************************************
+	"Unified QoS"	Module Memory	Allocation - END
+	***********************************************/
+
+#define	__DES_SYNC_CFG_CTXT_BASE				__DES_SYNC_CFG_CTXT
+#define	__DES_SYNC_CFG_CTXT_BASE_END		0x2FBF
+
+#define	__DES_READ_SYNC_CFG_CTXT_BASE	 __DES_SYNC_CFG_CTXT_BASE
+#define	__DES_READ_SYNC_CFG_CTXT_END	 __DES_SYNC_CFG_CTXT_BASE_END
+
+#define	__DES_WRITE_SYNC_CFG_CTXT_BASE	__DES_SYNC_CFG_CTXT_BASE
+#define	__DES_WRITE_SYNC_CFG_CTXT_END		__DES_SYNC_CFG_CTXT_BASE_END
+
+#define	__CDMA_READ_COPY_CH_CFG_BASE		__US_CDMA_COPY_CH_CFG
+#define	__CDMA_READ_COPY_CH_CFG_END			0x2350
+#define	__SIZE_OF_CDMA_COPY_CH_CFG		1
+
+/*cdma write*/
+#define	__DS_CDMA_COPY_CH_CFG						0x2350	/* 0x2350-0x2351	1	x	1	=	1		*/
+#define	__REG_STACK_PI									0x2352	/* 0x2352-0x2352	2	x	1	=	2		*/
+
+#define	__CDMA_READ_CH_CTXT				__US_CDMA_READ_CH_CFG_CTXT
+#define	__CDMA_READ_CH_CTXT_END					0x27A0
+#define	__SIZE_OF_CDMA_READ_CH_CTXT			8
+
+#define	__DES_SIDEBAND_WR_PTR						0x2354	/*0x2354-0x2355	*/
+
+#define	__DES_SIDEBAND_LIST_BASE		0x2800	/* 0x2800-0x283F	64 x 2 = 128 */
+#define	__DES_SIDEBAND_LIST_SIZE				__DS_PKT_DES_LIST_NUM
+
+/* SB	=	0x7000 */
+#define	__WRITE_CH_DOORBELL_EXT_ADDR		0x1E700980
+#define	__WRITE_CH_DOORBELL_EXT_ADDR_HI	0x1E70
+#define	__WRITE_CH_DOORBELL_EXT_ADDR_LO	0x0980
+
+/* SB	=	0x7001 */
+#define	__READ_CH_DOORBELL_EXT_ADDR			0x1E709A0
+#define	__READ_CH_DOORBELL_EXT_ADDR_HI	0x1E70
+#define	__READ_CH_DOORBELL_EXT_ADDR_LO	0x09A0
+
+#if	0
+/*Prior	PPA2.16
+	=============================================================================
+	Extra DS	packet buffer	for	A1Plus to	avoid	DS packet	drop (due	to no	descriptors)
+	total 13	packets
+	packet	size = 400 DWs = 1600	bytes
+=============================================================================*/
+#define	__DS_SB_PKT_DATA_PTR_0	0x2100	/* 0x2100-0x228F,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_1	0x2C00	/* 0x2C00-0x2D8F,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_2	0x3000	/* 0x3000-0x318F,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_3	0x3190	/* 0x3190-0x331F,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_4	0x3D80	/* 0x3D80-0x3F0F,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_5	0x44E0	/* 0x44E0-0x466F,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_6	0x4670	/* 0x4670-0x47FF,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_7	0x4800	/* 0x4800-0x498F,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_8	0x4990	/* 0x4990-0x4B1F,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_9	0x4D40	/* 0x4D40-0x4ECF,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_10	0x5B00	/* 0x5B00-0x5C8F,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_11	0x5C90	/* 0x5C90-0x5E1F,	size = 400DW */
+#define	__DS_SB_PKT_DATA_PTR_12	0x5E20	/* 0x5E20-0x5FAF,	size = 400DW */
+
+#else
+
+/*PPA2.16	MTU
+	=============================================================================
+	 Extra DS	packet buffer	for	A1Plus to	avoid	DS packet	drop (due	to no	descriptors)
+	 total 12	packets
+	 packet	size = 408 DWs = 1632	bytes
+	=============================================================================*/
+
+#define	__DS_SB_PKT_DATA_PTR_0	0x2100	/* 0x2100-0x2297,	size = 408DW */
+#define	__DS_SB_PKT_DATA_PTR_1	0x2C00	/* 0x2C00-0x2D97,	size = 408DW */
+#define	__DS_SB_PKT_DATA_PTR_2	0x3000	/* 0x3000-0x3197,	size = 408DW */
+#define	__DS_SB_PKT_DATA_PTR_3	0x3198	/* 0x3198-0x332F,	size = 408DW */
+#define	__DS_SB_PKT_DATA_PTR_4	0x44E0	/* 0x44E0-0x4677,	size = 408DW */
+#define	__DS_SB_PKT_DATA_PTR_5	0x4678	/* 0x4678-0x480F,	size = 408DW */
+#define	__DS_SB_PKT_DATA_PTR_6	0x4810	/* 0x4810-0x49A7,	size = 408DW */
+#define	__DS_SB_PKT_DATA_PTR_7	0x49A8	/* 0x49A8-0x4B3F,	size = 408DW */
+#define	__DS_SB_PKT_DATA_PTR_8	0x4D40	/* 0x4D40-0x4ED7,	size = 408DW */
+#define	__DS_SB_PKT_DATA_PTR_9	0x5B00	/* 0x5B00-0x5C97,	size = 408DW */
+#define	__DS_SB_PKT_DATA_PTR_10	0x5C98	/* 0x5C98-0x5E2F,	size = 408DW */
+#define	__DS_SB_PKT_DATA_PTR_11	0x5E30	/* 0x5E30-0x5EC7,	size = 408DW */
+
+#endif
+
+/*=============================================================================
+	 DS	OAM	packet in	share	buffer for A1Plus
+	 total	10 packets
+	packet size	=	32 DWs = 128 bytes
+	=============================================================================*/
+
+#define	__DS_SB_OAM_DATA_PTR_0	0x3BC0	/* 0x3BC0-0x3BDF,	size = 32	DW */
+#define	__DS_SB_OAM_DATA_PTR_1	0x3BE0	/* 0x3BE0-0x3BFF,	size = 32	DW */
+#define	__DS_SB_OAM_DATA_PTR_2	0x3C00	/* 0x3C00-0x3C1F,	size = 32	DW */
+#define	__DS_SB_OAM_DATA_PTR_3	0x3C20	/* 0x3C20-0x3C3F,	size = 32	DW */
+#define	__DS_SB_OAM_DATA_PTR_4	0x3C40	/* 0x3C40-0x3C5F,	size = 32	DW */
+#define	__DS_SB_OAM_DATA_PTR_5	0x3C60	/* 0x3C60-0x3C7F,	size = 32	DW */
+#define	__DS_SB_OAM_DATA_PTR_6	0x3C80	/* 0x3C80-0x3C9F,	size = 32	DW */
+#define	__DS_SB_OAM_DATA_PTR_7	0x3CA0	/* 0x3CA0-0x3CBF,	size = 32	DW */
+#define	__DS_SB_OAM_DATA_PTR_8	0x3CC0	/* 0x3CC0-0x3CDF,	size = 32	DW */
+#define	__DS_SB_OAM_DATA_PTR_9	0x3CE0	/* 0x3CE0-0x3CFF,	size = 32	DW */
+
+#define	__SOC_FAMILY										0x2507
+
+/*=============================================================================
+	 A1+ part
+	=============================================================================*/
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+																										S_addr	E_addr	Size
+		General	Context	1																5000		51FF		512
+
+		DSL	WAN	MIB	Length															4EF0		4EFF		16
+		DSL	WAN	RX VC	MIB	Length (A5 Only)							4F00		4F3F		64
+		DSL	WAN	TX VC	MIB	Length (A5 Only)							4F40		4F7F		64
+		HTU	table																				26A0		26FF		96
+		WAN	RX Queue Configuration/Context Length				4C00		4D3F		320
+		WAN	RX DMA Channel Configuration/Context Length	4F80		4FB7		56
+		WAN	TX Queue/DMA Configuration/Context Length		3A00		3BAF		432
+		WAN	TX Port	Configuration	Length								4FB8		4FB9		2
+
+		SFSM 0 (pages) - Data														5200		557F		896
+		SFSM 0 (pages) - Ctrl														5A80		5ABF		64
+		FFSM 0 (pages) -	Data													4000		422F		560
+		SFSM 1 (pages) - Data														5640		59BF		896
+		SFSM 1 (pages) - Ctrl														5AC0		5AFF		64
+		FFSM 1 (pages) -	Data													42A8		44D7		560
+		EMA	Command	Buffer															5580		559F		32
+		EMA	Data Buffer																	55A0		55DF		64
+
+		WAN	RX Port	Context															55E0		55EF		16
+		WAN	TX Port	Context															4FBA		4FBB		2
+		WAN	TX&RX	Port Context EXT Length								55F0		55FF		16
+		WAN	RX Descriptor	Prefetch Buffer								3900		39FF		256
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+
+/*********************************************
+	 detailed	allocation
+	*********************************************/
+
+		/*----------------------------------
+			 WAN RX	Descriptor Prefetch	Buffer
+			 0x5B00	-	0x5BFF
+			 Size	=	16 * 16	=	256	dwords
+			----------------------------------*/
+/*		#define	__WRX_DES_PREFETCH_BUF									0x2600*/
+
+
+		/*------------------------------------
+			 WAN RX	ALL5 Channel Descriptor	List
+			 0x5B00	-	0x5B3F
+			 Size	=	32 * 2 = 64	dwords
+			------------------------------------*/
+/*		#define	__WRX_PKT_DES_BUF												0x2600*/
+
+		/*------------------------------------
+			 WAN RX	OAM	Channel	Descriptor List
+			 0x5B40	-	0x5B7F
+			 Size	=	32 * 2 = 64	dwords
+			------------------------------------*/
+/*		#define	__WRX_OAM_DES_BUF												0x2640*/
+
+		/*---------------------------------------------
+			 DSL WAN MIB (0x4EF0 - 0x4EFF)
+			---------------------------------------------*/
+		#define	__WRX_DROPHTU_CELL											0x4EF1
+		#define	__WRX_DROPDES_PDU												0x4EF2
+		#define	__WRX_CORRECT_PDU												0x4EF3
+		#define	__WRX_ERR_PDU														0x4EF4
+		#define	__WRX_DROPDES_CELL											0x4EF5
+		#define	__WRX_CORRECT_CELL											0x4EF6
+		#define	__WRX_ERR_CELL													0x4EF7
+		#define	__WRX_TOTAL_BYTE												0x4EF8
+		#define	__WTX_TOTAL_PDU													0x4EFA
+		#define	__WTX_TOTAL_CELL												0x4EFB
+		#define	__WTX_TOTAL_BYTE												0x4EFC
+
+		/*--------------------------
+			 DSL WAN RX	VC MIB
+			 0x4F00	-	0x4F3F
+			 Size	=	16 * 4 = 64	dwords
+			--------------------------*/
+		#define	__WRX_VC_MIB_BASE												0x4F00
+		#define	__WRX_VC_IG_PKTS_OFF										0
+		#define	__WRX_VC_IG_BYTES_OFF										1
+
+		/*--------------------------
+			 DSL WAN TX	VC MIB
+			 0x4F40	-	0x4F7F
+			 Size	=	16 * 4 = 64	dwords
+			--------------------------*/
+		#define	__WTX_VC_MIB_BASE												0x4F40
+		#define	__WRX_VC_EG_PKTS_OFF										1
+		#define	__WRX_VC_EG_BYTES_OFF										2
+
+		/*----------------------------
+			HTU Table (0x26A0 - 0x26FF)
+			----------------------------*/
+		#define	__HTU_ENTRY_TABLE												0x26A0
+		#define	__HTU_MASK_TABLE												0x26C0
+		#define	__HTU_RESULT_TABLE											0x26E0
+
+		/*--------------------------------------
+			WAN RX	Queue	(Configuration + Context)
+			0x4C00	-	0x4D3F
+			---------------------------------------*/
+		#define	__WRX_QUEUE_CONFIG											0x4C00
+
+		/*---------------------------------------------
+			WAN RX	DMA	Channel	Configuration/Context
+			0x4F80	-	0x4FB7
+			pkt queue descriptor	rdptr, wrptr
+			oam queue descriptor	rdptr, wrptr
+			---------------------------------------------*/
+		#define	__WRX_QUEUE_CHANNEL_CONTEXT							0x4F80
+
+		/*---------------------------------------
+			 WAN TX	Queue/DMA	Configuration/Context
+			---------------------------------------*/
+		#define	__WTX_QUEUE_CONFIG											0x3A00
+
+		/*------------------------
+			DSL WAN RX	Port Context
+			 0x55E0	-	0x55EF
+			------------------------*/
+		#define	__WRXCTXT_TC_RdPtr0											0x55E0
+		#define	__WRXCTXT_TC_RdPtr1											0x55E1
+		#define	__WRXCTXT_L2_RdPtr0											0x55E2
+		#define	__WRXCTXT_L2_RdPtr1											0x55E3
+		#define	__WRXCTXT_L2Pages0											0x55E4
+		#define	__WRXCTXT_L2Pages1											0x55E5
+		#define	__WRXCTXT_MatchCells0										0x55E6
+		#define	__WRXCTXT_MatchCells1										0x55E7
+		#define	__WRXCTXT_NoMatchCells0									0x55E8
+		#define	__WRXCTXT_NoMatchCells1									0x55E9
+		#define	__WRXCTXT_PortState0										0x55EA
+		#define	__WRXCTXT_PortState1										0x55EB
+		#define	__WRXCTXT_Hunt_Cnt0											0x55EC
+		#define	__WRXCTXT_Hunt_Cnt1											0x55ED
+
+/***************************
+	DSL	WAN	context	definition
+	***************************/
+
+		/*---------------------------------------
+			WAN EMA	CMD	BUFFER	:	0x5580 - 0x559F
+					 EMA	DATA BUFFER	:	0x55A0 - 0x55DF
+			---------------------------------------*/
+		#define	__EMA_CMD_BUF														0x5580
+		#define	__EMA_DATA_BUF													0x55A0
+		#define	__WAN_EMA_CMD_BUF												__EMA_CMD_BUF
+		#define	__WAN_EMA_DATA_BUF											__EMA_DATA_BUF
+
+		/*--------------------------------------
+			WAN TX	Port Context (0x4FBA - 0x4FBB)
+			--------------------------------------*/
+		#define	__WTXCTXT_TC_WRPTR0											0x4FBA
+		#define	__WTXCTXT_TC_WRPTR1											0x4FBB
+
+		/*--------------------------------------------------
+			WAN TX	Port Context (extension) (0x55F0 - 0x55F1)
+			--------------------------------------------------*/
+		#define	__WTXCTXT_WtxDBufStart0									0x55F0
+		#define	__WTXCTXT_WtxDBufStart1									0x55F1
+
+		/*--------------------------------------------------
+			WAN RX	Port Context (extension) (0x55FC - 0x55FF)
+			--------------------------------------------------*/
+		#define	__WRXCTXT_WrxDBufStart0									0x55FC
+		#define	__WRXCTXT_WrxDBufStart1									0x55FD
+		#define	__WRXCTXT_WrxCBufStart0									0x55FE
+		#define	__WRXCTXT_WrxCBufStart1									0x55FF
+
+		/*--------------------------------------------
+			WAN TX	Port Configuration (0x4FB8 - 0x4FB9)
+			--------------------------------------------*/
+		#define	__WTX_PORT_CONFIG0											0x4FB8
+		#define	__WTX_PORT_CONFIG1											0x4FB9
+
+		/*=============================================
+			General Context (0x5000 - 0x51FF)
+			0x5000	-	0x50FF used	in addr_def_vr9.inc
+			=============================================*/
+
+		/*Verify
+			----------------------------------------------------
+			WAN TX	ETH	HEADER PREFETCH	BUFFER (0x5100 - 0x513F)
+			----------------------------------------------------*/
+		#define	__WTX_ETH_HEADER_BUF_BASE								0x5100
+
+		/*---------------------------------------------
+			WAN - ATM General Context (0x5140 - 0x517F)
+			---------------------------------------------*/
+		#define	__FWGEN_BITS_WORD0											0x5140
+		#define	__FWGEN_WRX_WREMA_PEND_DID							0x5141
+		#define	__FWGEN_WTX_WRDES_PEND_DID							0x5142
+		#define	__FWGEN_WRX_WRDES_PEND_DID							0x5143
+		#define	__FWGEN_WTX_WRDES_FINAL_PEND_DID				0x5144
+		#define	__FWGEN_WRX_WRDES_FINAL_PEND_DID				0x5145
+		#define	__FWGEN_WTX_RDDATA_PEND_QID							0x5146
+		#define	__FWGEN_WTX_CELLBUF_EMPTY_STATUS				0x5147
+		#define	__FWGEN_WTX_DMACH_NONEMPTY_STATUS				0x5148
+		#define	__FWGEN_WRX_DMACH_NONEMPTY_STATUS				0x5149
+		#define	__FWGEN_WRX_DMACH_VLD_STATUS						0x514A
+		#define	__FWGEN_WRX_VEN													0x514B
+		#define	__FWGEN_WRX_DES_PREFETCH_DID						0x514C
+		#define	__FWGEN_WRX_DID													0x514D
+		#define	__FWGEN_EMA_CMD0												0x514E
+		#define	__FWGEN_EMA_CMD1												0x514F
+		#define	__FWGEN_WRX_CELL_TYPE										0x5150
+		#define	__FWGEN_WRX_CELLID											0x5151
+		#define	__FWGEN_WRX_DESBUF_NONFULL_STATUS				0x5152
+		#define	__FWGEN_WTX_DES_PREFETCH_QID						0x5153
+		#define	__FWGEN_WTX_DES_PREFETCH_DID						0x5154
+		#define	__FWGEN_WTX_CURRDES_VLD_STATUS					0x5155
+		#define	__FWGEN_WTX_DESBUF_NONFULL_STATUS				0x5156
+		#define	__FWGEN_VAR_DES0												0x5158
+		#define	__FWGEN_VAR_DES1												0x5159
+		#define	__FWGEN_WRX_CELL_HEADER									0x515A
+		/*#define	__FWGEN_VAR_EMADATA_WRPTR								0x515B*/
+		#define	__FWGEN_WRX_QID													0x515C
+		#define	__FWGEN_VAR_DWNUM												0x515D
+		#define	__FWGEN_VAR_CURR_LEN										0x515E
+		#define	__FWGEN_VAR_TRAILER_LEN									0x515F
+		#define	__FWGEN_VAR_TRAILER_UU									0x5160
+		#define	__FWGEN_VAR_TRAILER_CPI									0x5161
+		#define	__FWGEN_VAR_STW													0x5162
+		#define	__FWGEN_WTX_QID													0x5163
+		#define	__FWGEN_VAR_BMC_CMD0										0x5164
+		#define	__FWGEN_VAR_DW_OFF											0x5165
+		#define	__FWGEN_VAR_LAST_CELL										0x5166
+		#define	__FWGEN_VAR_FILL_CELL										0x5167
+		#define	__FWGEN_VAR_EXP_LEN											0x5168
+		#define	__FWGEN_WTX_CELL_HEADER									0x5169
+		#define	__FWGEN_VAR_BYTEOFF											0x516A
+		#define	__FWGEN_WTX_DATA_PREFETCH_QID						0x516B
+		#define	__FWGEN_WRX_PID													0x516C
+		#define	__FWGEN_WTX_PID													0x516D
+		#define	__FWGEN_CELLS_QUEUED_0									0x516E
+		#define	__FWGEN_CELLS_QUEUED_1									0x516F
+		#define	__FWGEN_SPACE_PENDING0									0x5170
+		#define	__FWGEN_SPACE_PENDING1									0x5171
+		#define	__FWGEN_VAR_BMC_CMD1										0x5172
+		#define	__FWGEN_WRX_DESREQ_NONPEND_STATUS				0x5173
+		#define	__FWGEN_WTX_DESREQ_NONPEND_STATUS				0x5174
+		#define	__FWGEN_WTX_CELLREQ_NONPEND_STATUS			0x5175
+		#define	__FWGEN_PREV_EMA_ISR										0x5176
+		#define	__FWGEN_MBOX0_ISR												0x5177
+		#define	__FWGEN_WTX_1ST_CELL_READ_FLAG0					0x5178
+		#define	__FWGEN_WTX_1ST_CELL_READ_FLAG1					0x5179
+
+		/*upstream	local	queue	nonempty flag
+			bit0	to bit15 correspond	to q0	to q15
+			if	a	bit	is set,	the	corresponding	queue	is nonempty*/
+		#define	__US_TC_LOCAL_Q_FULL_FLAG								0x517A
+
+		#ifdef VR9_FIRMWARE_DESCRAMBER
+				#define	_FW_DESCRAMBER_POLY_H								0x517E
+				#define	_FW_DESCRAMBER_POLY_L								0x517F
+		#endif
+
+		/*=============================================
+			EMA Context	(0x518E-0x518F)
+			=============================================*/
+		#define	__EMA_CONTEXT_CMD_WRPTR									0x518E
+		#define	__EMA_CONTEXT_DATA_WRPTR								0x518F
+		#define	__WAN_EMA_CONTEXT_CMD_WRPTR							__EMA_CONTEXT_CMD_WRPTR
+		#define	__WAN_EMA_CONTEXT_DATA_WRPTR						__EMA_CONTEXT_DATA_WRPTR
+
+		/*-----------------------------------------------------
+			WAN RX	Decap	buffer (0x5190 - 0x51AF)	//temp address
+			-----------------------------------------------------*/
+		#define	__WRX_DECAP_BUF_BASE										0x5190
+		#define	__WRX_DECAP_BUF_BASE_HW									0x3190
+
+		/*0x51B0 - 0x51BF*/
+		#define	__FWGEN_WTX_QSB_VC_CONTEXT_BASE					0x51B0
+
+		/*--------------------------------------
+			WRX General Context (0x51C0 - 0x51C8)
+			--------------------------------------*/
+		#define	__FWGEN_WRX_2684_ORIGINAL_FLAG					0x51C0
+		#define	__FWGEN_WRX_2684_CELL_ALIGN_OFF					0x51C1
+		#define	__FWGEN_WRX_2684_MPOA_TYPE							0x51C2
+		#define	__FWGEN_WRX_AAL5_CELL1_ROUNDDOWN_DWNUM	0x51C3
+		#define	__FWGEN_WRX_DES_BYTES										0x51C4
+		#define	__FWGEN_WRX_FIRST_CELL									0x51C5
+		#define	__FWGEN_WRX_PKT_LEN_WO_FCS							0x51C6
+		#define	__FWGEN_WRX_ETH_TYPE										0x51C7
+		#define	__FWGEN_WRX_MAC_BYTE										0x51C8
+
+		/*--------------------------------------
+			WTX General Context (0x51C9 - 0x51DF)
+			--------------------------------------*/
+		#define	__FWGEN_WTX_ETH_IS_VLAN									0x51C9
+		#define	__FWGEN_WTX_MPOA_PT											0x51CA
+		#define	__FWGEN_WTX_ENCAP_PARSE_DROP						0x51CB
+
+		#define	__FWGEN_WTX_2684_RM_LEN									0x51CC
+		#define	__FWGEN_WTX_2684_INSERT_LEN							0x51CD
+		#define	__FWGEN_WTX_RDWNUM											0x51CE
+		#define	__FWGEN_WTX_SWOFF												0x51CF
+
+		#define	__FWGEN_WTX_CELL1_BYTEOFF								0x51D0
+		#define	__FWGEN_WTX_ETH_IS_IPV4									0x51D1
+		#define	__FWGEN_WTX_ETH_IPOFF										0x51D2
+
+		#define	__FWGEN_WTX_QPKT_LEVEL_CONTROL					0x51D3
+
+		#define	__FWGEN_WTX_ETH_HD_DONE									0x51D4
+
+/*---------------------------------------------------
+	Task	pending	flag for power save	in A1plus
+	---------------------------------------------------*/
+#define	__TASK_PENDING_FLAG_VRX318_PPA						0x51E0
+#define	__TASK_PENDING_FLAG											 __TASK_PENDING_FLAG_VRX318_PPA
+
+#define	__WAKEUP_MIB_VRX318												0x51E1
+
+		#define	MPOA_TYPE_EOA1									0		/*without	FCS*/
+		#define	MPOA_TYPE_EOA2									1		/*with FCS*/
+		#define	MPOA_TYPE_PPPOA_IPV4						2
+		#define	MPOA_TYPE_IPOA_IPV4							3
+		#define	MPOA_TYPE_PPPOA_IPV6						6
+		#define	MPOA_TYPE_IPOA_IPV6							7
+		#define	MPOA_TYPE_PPPOA_OTHER						10
+		#define	MPOA_TYPE_IPOA_OTHER						11
+		#define	BITS_OF_BUCK_DEPTH							4
+		#define	CONST_HASH_BUCKET_SIZE					16
+		#define	CONST_HASH_BUCKET_NO						32
+
+		#define	CONST_IPV6_CNV_TBL_SIZE					64
+
+/*==============================================================================
+	FROM	vr9	bonding
+	--------------
+	PDMA Registers
+	--------------*/
+#define	__DMAL_BAR0_FIFO_STATUS							0x7600
+#define	__DMAL_BAR1_FIFO_STATUS							0x7601
+#define	__PDMA_BAR0													0x7602
+#define	__PDMA_BAR1													0x7603
+
+#define	__BAR0_WINDOW_SB_ADDR								0x6000
+#define	__BAR0_WINDOW_SB_ADDR_PLUS_1				0x6001
+#define	__BAR1_WINDOW_SB_ADDR								0x6800
+#define	__BAR1_WINDOW_SB_ADDR_PLUS_1				0x6801
+
+
+/* hardware	registers */
+#define	__SAR_PDMA_RX_FW_DATABUF_CFG				0x7F02
+#define	__SAR_PDMA_TX_FW_DATABUF_CFG				0x7F03
+#define	__PDMA_IER													0x7A0B
+
+
+/*---------------------------------------------------
+	ACA FW	Context
+	2 * 8 = 16
+	---------------------------------------------------*/
+#define	__US_ACA_CFG_CTXT_BASE							 0x4BB0	/* 0x4BB0--0x4BB7	 1 x 8 = 8	 */
+#define	__DS_ACA_CFG_CTXT_BASE							 0x4BB8	/* 0x4BB8--0x4BBF	 1 x 8 = 8	 */
+
+
+/*----------------------------------------------------------
+	ACA Shadow	Registers
+	3 * 4 = 12
+	*_STATUS	need to	be initialized to	nonzero	by PPE driver
+	----------------------------------------------------------*/
+
+#define	__ACA_SHADOW_REG_BASE								 0xADF0
+
+#define	__TX_IN_ACA_ACCUM_COUNT							 0xADF0
+
+#define	__TX_IN_ACA_ACCUM_STATUS						 0xADF1
+
+#define	__TX_IN_QUEUE_PD_BASE_ADDR_OFFSET		 0xADF2
+
+#define	__TX_OUT_ACA_ACCUM_COUNT						 0xADF3
+
+#define	__TX_OUT_ACA_ACCUM_STATUS						 0xADF4
+
+#define	__TX_OUT_QUEUE_PD_BASE_ADDR_OFFSET	 0xADF5
+
+#define	__RX_IN_ACA_ACCUM_COUNT							 0xADF6
+
+#define	__RX_IN_ACA_ACCUM_STATUS						 0xADF7	/*0x1E22AFDC for VRX318	*/
+
+#define	__RX_IN_QUEUE_PD_BASE_ADDR_OFFSET		 0xADF8
+
+#define	__RX_OUT_ACA_ACCUM_COUNT						 0xADF9
+
+#define	__RX_OUT_ACA_ACCUM_STATUS						 0xADFA
+
+#define	__RX_OUT_QUEUE_PD_BASE_ADDR_OFFSET	 0xADFB
+
+
+#define	__QOSQ_NO_DROP										 0x4BFE
+
+#define	__TOTAL_DS_ACA_DEQ_CNT								0x4BFF
+
+#define	__TOTAL_RX_IN_ACA_ACCUM_CNT							0x347F
+
+
+/*---------------------------------------------------------------
+	Programmable	Address	Mapping	(To	be initialized by	PPE	driver)
+	---------------------------------------------------------------*/
+#define	__EP_ADDR_BAR										 0x2028
+
+
+/*----------------------------------------------------------------
+	ACA TX_IN PD	List
+	----------------------------------------------------------------*/
+#define	__ACA_TX_IN_PD_LIST_BASE				__US_FAST_PATH_DES_LIST_BASE
+#define	__ACA_TX_IN_PD_LIST_SIZE				__US_FAST_PATH_DES_LIST_SIZE
+#define	__ACA_TX_IN_PD_LIST_NUM					__US_FAST_PATH_DES_LIST_NUM
+
+/*__ACA_TX_IN_PD_LIST_GUARD	<= __ACA_TX_IN_PD_LIST_NUM - 1*/
+#define	__ACA_TX_IN_PD_LIST_GUARD				__US_FAST_PATH_DES_LIST_GUARD
+
+/*----------------------------------------------------------------
+	ACA TX_OUT	PD List
+	----------------------------------------------------------------*/
+
+#define	__ACA_TX_OUT_PD_LIST_BASE				 0xA960	/* 0xA960-0xA9DF	128	 */
+#define	__ACA_TX_OUT_PD_LIST_SIZE				 128
+#define	__ACA_TX_OUT_PD_LIST_NUM				 64
+
+/*__ACA_TX_OUT_PD_LIST_GUARD <=	__ACA_TX_OUT_PD_LIST_NUM - 1*/
+#define	__ACA_TX_OUT_PD_LIST_GUARD			 63
+
+
+/*----------------------------------------------------------------
+	ACA RX_IN PD	List
+	----------------------------------------------------------------*/
+#define	__ACA_RX_IN_PD_LIST_BASE				__DS_PKT_DES_LIST_BASE
+#define	__ACA_RX_IN_PD_LIST_SIZE				__DS_PKT_DES_LIST_SIZE
+#define	__ACA_RX_IN_PD_LIST_NUM					__DS_PKT_DES_LIST_NUM
+
+/*__ACA_RX_IN_PD_LIST_GUARD	<= __ACA_RX_IN_PD_LIST_NUM - 1*/
+#define	__ACA_RX_IN_PD_LIST_GUARD				__DS_PKT_DES_LIST_GUARD
+
+/*----------------------------------------------------------------
+	ACA RX_OUT	PD List
+	----------------------------------------------------------------*/
+#define	__ACA_RX_OUT_PD_LIST_BASE				 __DS_PKT_DES_LIST_BASE
+#define	__ACA_RX_OUT_PD_LIST_SIZE				 __DS_PKT_DES_LIST_SIZE
+#define	__ACA_RX_OUT_PD_LIST_NUM				 __DS_PKT_DES_LIST_NUM
+
+/*__ACA_RX_OUT_PD_LIST_GUARD <=	__ACA_RX_OUT_PD_LIST_NUM - 1 */
+#define	__ACA_RX_OUT_PD_LIST_GUARD			 __DS_PKT_DES_LIST_GUARD
+
+/* DSL showtime/leave showtime interrupt from MIPS to PP32_2 
+   (TC_RX core for PTM) and PP32_0 for ATM                  */
+#define	__MBOX2_PPM_IER						__MBOX_IGU5_IER
+#define	__MBOX2_PPM_ISR						__MBOX_IGU5_ISR
+#define	__MBOX2_PPM_ISRS					__MBOX_IGU5_ISRS
+#define	__MBOX2_PPM_ISRC					__MBOX_IGU5_ISRC
+
+#define	BIT_MBOX2_PPM						BIT0
+#define	__ISRS_SET_CNT_MBOX2_PPM			0x5FC8
+#define	__ISR_CHECK_CNT_MBOX2_PPM			0x5FC9
+
+#define	__INT_MBOX2_PPM_CNT					0x5FCA
+#define	__INT_MBOX2_PPM_WAKEUP_CNT			0x5FCB
+
+/* 0x2FC0--0x2FDF 1 x 32 = 32  */
+#define	__INT_PP32_2_CNT					0x5FCC 
+
+
+#define	__MODE_SW_CFG						__DREG_MEI_STATE
+#define	__MODE_SW_INT						0x5FCD
+
+/* 0x5FCE--0x5FCD 1 x 32 = 32 */
+#define	__MODE_SW_CNT						0x5FCE
+
+#define	__DS_ACA_DELAY						0x4BC1
+
+#define	__DS_ACA_TIMEOUT_CNT				0x4BC2
+
+#define	__PCIE_SWITCH_PRESENT				0x4BC3
+
+#define	__TX_IN_OUT_TOTAL_CNT				0x4BC4
+
+#define	__PD_SHADOW_PRESENT					0x4BC5
+
+#define	__TX_OUT_SHADOW_PTR					0x4BC6
+
+#define	__RX_OUT_SHADOW_PTR					0x4BC7
+
+#endif
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_addr_def.h b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_addr_def.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_addr_def.h
@@ -0,0 +1,1424 @@
+#ifndef	__SMARTPHY_ADDR_DEF_INC
+#define	__SMARTPHY_ADDR_DEF_INC
+
+/*==========================================================================
+ Defines for "PPE	DSL	Notifications" Module
+============================================================================*/
+#define	__DREG_BC0_LINK_STATUS							0x7DC0
+#define	__DREG_BC1_LINK_STATUS							0x7DD0
+#define	__DREG_MEI_STATE								0x7DC1
+#define	__DREG_PDBRAM_S_44K_OWN							0x7DC2
+#define	__DREG_SIGNATURE								0x7DC3
+#define	__DREG_FRAMER_REQUEST_STOPPED					0x7DC7
+#define	__DREG_CW_FILL_LEVEL        					0x7DCA
+#define	__SFSM_PGCNT0									0x741C
+#define	__SFSM_PGCNT1									0x741D
+
+/*==========================================================================
+ General Configuraton:	0x2000 - 0x202F
+ Need	to be	refined	further
+============================================================================*/
+
+#define	__FW_VER_ID													0x2000
+#define	__FW_FEATURE												0x2001
+
+#define	__PP32_0_TIME												0x2002	/* New */
+#define	__PP32_1_TIME												0x2003	/* New */
+#define	__PP32_2_TIME												0x2004	/* New */
+
+#define	__DSL_LINK_DOWN											0x2007	/* New */
+
+/*	#define	__TFA_MAILBOX_PDMA_ADDR0					0x2004	(Deleted)
+		#define	__TFA_MAILBOX_PDMA_ADDR1					0x2005	(Deleted)
+		#define	__LINK_UP_NOTIFY_ADDR						0x2006	(Deleted)
+		#define	__LINK_DOWN_NOTIFY_ADDR					0x2007	(Deleted)*/
+#define	__BOND_CONF											0x2008
+#define	__US_BG_QMAP										0x2009
+#define	__US_BG_GMAP										0x200A
+#define	__DS_BG_GMAP										0x200B
+
+#define	__PEER_GIF_LINK_STATE_TMP					0x200C
+#define	__ISR_CHECK_CNT_NORMAL_LINK_DOWN	0x200D
+#define	__ISRS_SET_CNT_NORMAL_LINK_DOWN		0x200E
+#define	__ISR_CHECK_CNT_FORCE_LINK_DOWN		0x2018
+#define	__ISRS_SET_CNT_FORCE_LINK_DOWN		0x2019
+#define	__LINK_STATE_INTERMEDIATE					0x201C
+#define	__LINK_STABLE_CNT									0x201D
+
+/*#define	__CURR_TIME_STAMP							0x200C	(Deleted)
+	#define	__E1_DES_PDMA_BAR							0x200D	(Deleted)
+	#define	__B1_DES_PDMA_BAR							0x200E	(Deleted)
+	#define	__DATA_PTR_PDMA_PREFIX_CFG		0x200F	(Deleted)
+																				0x2010	(Reused)*/
+
+/*Only for DEBUG!!*/
+#define	_PDMA_RX_CMD_ERR_FLAG						0x200F
+#define	_PDMA_TX_CMD_ERR_FLAG						0x2010
+
+#define	__STD_DES_CFG										0x2011
+#define	__QOS_CFG												0x2012
+#define	__QOSQ_FLOW_CTRL_CFG						0x2013
+
+#define	__CFG_STD_DATA_LEN							__STD_DES_CFG
+#define	__TX_QOS_CFG										__QOS_CFG
+#define	__CFG_TX_QOSQ_BANDWIDTH_CTRL		__QOSQ_FLOW_CTRL_CFG
+
+
+#define	__PSAVE_CFG_TX									0x2014
+#define	__PSAVE_CFG_BOND								0x2015
+#define	__PSAVE_CFG_RX									0x2016
+
+/*																			0x2018
+	#define __GPIO_ADDR									0x2019	(Deleted)*/
+
+
+/*Added	by Naveen	(31/01/2012) --	START*/
+#define	__SHAPING_CFG										0x201A	/* New */
+#define	__WFQ_CFG												0x201B	/* New */
+/*Added	by Naveen	(31/01/2012) --	END*/
+
+/*	#define __GPIO_MODE									0x201C	(Deleted,	Reused)
+		#define __GPIO_WM_CFG								0x201D	(Deleted,	Reused)*/
+
+#define	__QOS_SHADOW_TTICK							0x201E
+#define	__TX_QOS_CFG_SHADOW							__QOS_SHADOW_TTICK
+
+#define	__TEST_MODE											0x201F
+/*#define	__US_CDMA_RX_DES_PDMA_BAR			0x2020	(Deleted)
+	#define	__US_CDMA_RX_DES_BASE					0x2021	(Deleted)
+	#define	__US_FRAG_READY_NOTICE_ADDR		0x2022	(Deleted)
+																				0x2023
+																				0x2024
+																				0x2025
+																				0x2026
+																				0x2027
+																				0x2028
+																				0x2029
+	#define	__US_E1_FRAG_DESBA_CFG				0x202A	(Deleted)
+	#define	__DS_E1_FRAG_DESBA_CFG				0x202B	(Deleted)
+																				0x202C
+																				0x202D
+																				0x202E
+																				0x202F*/
+
+#define	__PP32_0_TASK_CFG								0x2020	/* new */
+#define	__PP32_1_TASK_CFG								0x2021	/* new */
+#define	__PP32_2_TASK_CFG								0x2027	/* new */
+/*must 4 Dword aligned*/
+#define	__PP32_0_MODULE_ACTIVITY				0x2024
+#define	__PP32_1_MODULE_ACTIVITY				0x2025
+
+/*valid below for PP32	address	range:
+		sb_addr range:			0x2000-0x5FFF
+	 hw_reg	range	:			0x7000-0x7FFF
+ a vrx218	can	access any <pp32_addr> in	above	range	in its peer	vrx218 with
+	an effective external	address	of	*__BOND_PEER_SB_BASE + (pp32_addr	<< 4)*/
+#define	__BOND_PEER_SB_BASE								0xA800	/* New */
+
+#define	PCIE_EP_MSI_SR_ADDR_HIGH					0x1E10
+#define	PCIE_EP_MSI_SR_ADDR_LOW						0x2484
+
+/*																			0x2019*/
+
+#define	__DS_PKT_PMAC_HEADER						0x2022	/* new */
+#define	__VRX218_FLOW_CTRL_CFG					 0x2023	/*	new	*/
+
+/*==========================================================================
+Unified QoS Part
+============================================================================*/
+#define	__INQ_QOS_CFG_BASE							0x2508	/* 0x2508-0x2509	2	x	1	=	2*/
+
+#define	__US_FAST_PATH_DES_LIST_BASE		0xA070	/*0xA070-0xA0EF	64	x	2	=	128*/
+#define	__US_FAST_PATH_DES_LIST_SIZE		128
+#define	__US_FAST_PATH_DES_LIST_NUM			64
+#define	__US_FAST_PATH_DES_LIST_GUARD		63
+
+#define	__US_CPU_PATH_DEST_LIST_BASE		0x3D00		/* 0x3D00-0x3D7F	64x2=	128*/
+#define	__QOSQ_OVERFLOW_STATE_BMAP			0x250c		/* 0x250c-0x250c	1x1=1*/
+
+#define	__QOSQ_CFG_CTXT_BASE						0x2FE0			/* 0x2FE0-0x2FFF	16x2=32*/
+
+#define	__US_QOSQ_DES_LIST_BASE					0xA9F0	/* 0xA9F0-0xADEF	16x32x2=1024*/
+																								/*(VRX318:	0x2800)*/
+#define	__US_QOSQ_DES_LIST_SIZE					256
+#define	__US_QOSQ_DES_LIST_NUM_Q				2		/* Number	of QOSQ	-*/
+																						/*one for preemption*/
+																						/*one for non-preemption*/
+#define	__US_QOSQ_DES_LIST_PERQ_NUM			64	/*Number of descriptors per QOSQ*/
+
+
+#define	__QOSQ_MIB_BASE									0x2030	/* 0x2030-0x20AF	16x8=128*/
+#define	__QOSQ_EVENT_MBOX_INT_CFG				0x3F10	/* 0x3F10-0x3F13	1x4=4*/
+/*#define	__QOSQ_PKT_CNT									0x2680	(0x2680-0x268F	16x1=16)*/
+
+#define	__SHAPING_WFQ_CFG_BASE					0x3420	/* 0x3420-0x3473	21x4=84*/
+
+#define	__SWAPQ_CFG_CTXT_BASE						0x2500	/* 0x2500-0x2501	1*2=2*/
+#define	__SWAPQ_DES_LIST_BASE						0x3F60	/* 0x3F60-0x3F9F	32*2=64*/
+
+#define	__OUTQ_QOS_CFG_CTXT_BASE				0x2550	/* 0x2550-0x255F	4x4=16*/
+
+
+/*#define	__US_OUTQ_DES_LIST_BASE					0x2100*/	/*0x2100-0x217F	64x2=128*/
+#define	__US_OUTQ_DES_LIST_BASE					0xA1F0	/* 0xA1F0-0xA26F	2x32x2=128*/
+#define	__US_OUTQ_DES_LIST_SIZE					128
+#define	__US_OUTQ0_DES_LIST_NUM					 32
+#define	__US_OUTQ1_DES_LIST_NUM					 32
+
+
+#define	__DESQ_MBOX_INT_CFG							0x3F14	/* 0x3F14-0x3F1F	6x2=12*/
+
+#define	__US_FP_INQ_DES_CFG_CTXT				0x20B0	/* 0x20B0-0x20B7	1x8=8*/
+#define	__US_CPU_INQ_DES_CFG_CTXT				0x20B8	/* 0x20B8-0x20BF	1x8=8*/
+#define	__US_QOS_OUTQ_DES_CFG_CTXT_BASE	0x20C0	/* 0x20C0-0x20DF	4x8=32*/
+
+/*==========================================================================
+ Des Queues, CDMA	 copy	channel	mgm, des_sync	(SmartPhy	Part)
+============================================================================*/
+#define	__US_FRAGQ_CFG_CTXT_BASE				0xA810	/* 0xA810-0xA84F	8x8=64*/
+
+/*#define	__US_FRAGQ_DES_LIST_BASE				0x21C0*/	/*0x21C0-0x233F	8x48=384*/
+#define	__US_FRAGQ_DES_LIST_BASE				0xA270	/* 0xA270-A3EF	8x16x3=384*/
+#define	__US_FRAGQ_DES_LIST_SIZE				384
+#define	__US_FRAGQ_DES_LIST_NUM_Q				8	 /*	Number of	fragment queues*/
+#define	__US_FRAGQ_DES_LIST_PERQ_NUM		16 /*	Number of	descriptors	per	FRAGQ*/
+
+#define	__US_TC_LOCAL_Q_CFG_CTXT_BASE		0x2E00	/*0x2E00-0x2E7F	16x8=128*/
+
+#define	__US_BP_TC_LOCAL_Q_CFG_CTXT_BASE		0x2390	/* 0x2390-0x23A2	1*19=19*/
+
+
+/*#define	__US_TC_LOCAL_Q_DES_LIST_BASE		0x2360*/	/* 0x2360-0x2385	1x48=48*/
+
+#define	__US_TC_LOCAL_Q_DES_LIST_BASE		0xA000	/* 0xA000-0xA023	18x2=36*/
+#define	__US_TC_LOCAL_Q_DES_LIST_SIZE		36
+#define	__US_TC_LOCAL_Q0_DES_LIST_NUM		16
+#define	__US_TC_LOCAL_Q1_DES_LIST_NUM		2
+
+#define	__US_TC_LOCAL_Q_DES_LIST_BP_BASE	 0xA030	 /*	0xA030-0xA053	 18x2=36*/
+#define	__US_TC_LOCAL_Q_DES_LIST_BP_SIZE	 36
+#define	__US_TC_LOCAL_Q0_DES_LIST_BP_NUM	 16
+#define	__US_TC_LOCAL_Q1_DES_LIST_BP_NUM	 2
+
+#define	__DS_TC_LOCAL_Q_CFG_CTXT				0x20E0	/* 0x20E0-0x20EF	2x8=16*/
+
+#define __DS_TC_LOCAL_Q_BASE_SRAM_HI               0x0028
+#define __DS_TC_LOCAL_Q_BASE_SRAM_LOW              0x4000
+#define	__DS_TC_LOCAL_Q_DES_LIST_BASE		0xB000	/* 0xB000-0xB03B	30x2=60*/
+																								/*(VRX318:0x24D0)*/
+#define	__DS_TC_LOCAL_Q_DES_LIST_SIZE		60
+#define	__DS_TC_LOCAL_Q_DES_LIST_NUM		30
+
+#define	__DS_TC_LOCAL_Q_DES_LIST_BP_BASE	 0xB040	 /*0xB040-0xB05D	 30x1=30*/
+																									/*(VRX318: 0x24F0)*/
+#define	__DS_TC_LOCAL_Q_DES_LIST_BP_SIZE	 30
+#define	__DS_TC_LOCAL_Q_DES_LIST_BP_NUM		 30
+
+
+#define	__DS_FRAGQ_CFG_CTXT_BASE				0xB550	/* 0xB550-0xB55F	2x8=16*/
+
+/*FRAGQ	includes non-bonding and bonding part*/
+#define	__DS_FRAGQ_DES_LIST_BASE				0xB300	/* 0xB300-0xB47F	2x96x3=576*/
+																								/*(VRX318: 0x26D0)*/
+#define	__DS_FRAGQ_DES_LIST_SIZE				576	/*Total size	in number	of dwords*/
+#define	__DS_FRAGQ_DES_LIST_NUM_Q				2		/*Number	of fragment	queues*/
+#define	__DS_FRAGQ_DES_LIST_PERQ_NUM		96	/*Number of descriptors per FRAGQ*/
+
+#define	__DS_PKT_DESQ_CFG_CTXT					0x24C0	/* 0x24C0-0x24CF	2	 x 8 = 16*/
+
+#define	__DS_PKT_DES_LIST_BASE					0xB100	/* 0xB100-0xB2FF	256x2=512*/
+																								/*(VRX318: 0x2600)*/
+#define	__DS_PKT_DES_LIST_SIZE					510
+#define	__DS_PKT_DES_LIST_NUM						255
+#define	__DS_PKT_DES_LIST_GUARD					254
+
+#define	__MAINLOOP_CFG_ADDR						0x27A0
+#define	__MAINLOOP_CNT_ADDR						0X27A1
+
+#define	__DES_SYNC_CFG_CTXT							0x2F00	/* 0x2F00-0x2FBF	6x32=192*/
+/*In Bonding,	Upstream Bonding Master	only synchronizes	2
+	Upstream Queues	(FP	&	CPU) Downstream Bonding Master	only synchronizes
+	1	Downstream Queue Since	Peer-to-Peer writes	are	not	allowed, we	need to
+	synchronize	Bonding	Descriptors!
+		Re-using the space reserved	for	"Descriptor	Sync"
+		__DES_SYNC_CFG_CTXT	==>	0x2F00 - 0x2F3F	(Upstream	Bonding	Master)
+		__DES_SYNC_CFG_CTXT	==>	0x2F00 - 0x2F1F	(Downstream	Bonding	Master)*/
+#define	__BOND_US_DES_SYNC_CFG_CTXT						0x2F48	/*0x2F48-0x2F67;4*8=32*/
+
+#define	__BOND_US_DES_SYNC_QUEUE_ID						0x2F68	/*0x2F68-0x2F68;1*1=1*/
+
+#define	__US_BOND_SOC_SYNC_ADDR_GIF4					0x2F6C	/*0x2F6C-0x2F6C;1*1=1*/
+#define	__US_BOND_SOC_SYNC_ADDR_GIF5					0x2F6D	/*0x2F6D-0x2F6D;1*1=1*/
+#define	__US_BOND_SOC_SYNC_ADDR_GIF6					0x2F6E	/*0x2F6E-0x2F6E;1*1=1*/
+#define	__US_BOND_SOC_SYNC_ADDR_GIF7					0x2F6F	/*0x2F6F-0x2F6F;1*1=1*/
+
+#define	__BOND_US_DES_SYNC_TX_DES_DW0					0x2F78	/*0x2F78-0x2F78;1*1=1*/
+#define	__BOND_US_DES_SYNC_TX_DES_DW1					0x2F79	/*0x2F79-0x2F79;1*1=1*/
+#define	__BOND_US_DES_SYNC_RX_DES_DW0					0x2F7A	/*0x2F7A-0x2F7A;1*1=1*/
+#define	__BOND_US_DES_SYNC_RX_DES_DW1					0x2F7B	/*0x2F7B-0x2F7B;1*1=1*/
+
+#define	__BOND_US_DES_SYNC_BUF_BASE					0x2F80	/*0x2F80-0x2FBF;64 DWORDS*/
+#define	__BOND_US_DES_SYNC_ENQ_PKT_CNT			0x2F80	/*0x2F80-0x2F80;1*1=1*/
+#define	__BOND_US_DES_SYNC_DEQ_PKT_CNT			0x2F81	/*0x2F81-0x2F81;1*1=1*/
+#define	__BOND_US_DES_SYNC_DES_BASE					0x2F88	/*0x2F88-0x2FA7;32 DWORDs*/
+#define	__BOND_US_DES_SYNC_DES_BP_BASE			0x2FA8	/*0x2FA8-0x2FB7;16 DWORDs*/
+
+#define	__BOND_DS_DES_SYNC_CFG_CTXT						0x2FC0	/*0x2FC0-0x2FC7;1*8=8*/
+#define	__BOND_DS_DES_SYNC_QUEUE_ID						0x2FC8	/*0x2FC8-0x2FC8;1*1=1*/
+#define	__DS_BOND_SOC_SYNC_ADDR								0x2FC9	/*0x2FC9-0x2FC9;1*1=1*/
+#define	__DS_BOND_SOC_SYNC_ENQ_CNT_ADDR				0x2FCA	/*0x2FCA-0x2FCA;1*1=1*/
+#define	__DS_BOND_SOC_SYNC_DEQ_CNT_ADDR				0x2FCB	/*0x2FCB-0x2FCB;1*1=1*/
+
+#define	__BOND_DS_DES_SYNC_BUF_BASE					0x2458	/*0x2458-0x24BF;104DWORDS*/
+#define	__BOND_DS_DES_SYNC_ENQ_PKT_CNT			0x2458	/*0x2458-0x2458;1*1=1*/
+#define	__BOND_DS_DES_SYNC_DEQ_PKT_CNT			0x2459	/*0x2459-0x2459;1*1=1*/
+#define	__BOND_DS_DES_SYNC_DES_BASE					0x2460	/*0x2460-0x249F; 64DWORDS*/
+#define	__BOND_DS_DES_SYNC_DES_BP_BASE			0x24A0	/*0x24A0-0x24BF; 32DWORDs*/
+
+#define	__BOND_DES_SYNC_CFG_CTXT_SIZE						8
+#define	__BOND_DES_SYNC_ENQ_PKT_CNT_OFFSET			0
+#define	__BOND_DES_SYNC_DEQ_PKT_CNT_OFFSET			1
+#define	__BOND_DES_SYNC_DES_BASE_OFFSET					2
+
+#define	__CDMA_DES_SYNC_DEST_LIST_BASE	0x27A0	/* 0x27A0-0x27FF	6x4x2x2=96*/
+
+/*----------------------------------------------------------
+	Detailed	Memory Allocation
+	----------------------------------------------------------*/
+
+/***********************************************
+	"Unified QoS"	Module Memory	Allocation - START
+	***********************************************/
+
+/*2	INQs;	CPU	Path & Fast	Path*/
+#define	__INQ_QOS_CFG_BASE							0x2508
+#define	__INQ_QOS_CFG_END								0x2508
+#define	__INQ_QOS_CFG_SIZE							1
+
+/*16 QoSQs*/
+#define	__QOSQ_CFG_CTXT_BASE						0x2FE0
+#define	__QOSQ_CFG_CTXT_END							0x2FFF
+#define	__QOSQ_CFG_CTXT_SIZE						2
+
+/*16 QoSQs;	4	L2 Shapers;	1	L3 Shaper*/
+#define	__SHAPING_WFQ_CFG_BASE					0x3420
+#define	__SHAPING_WFQ_CFG_END						0x3473
+#define	__SHAPING_WFQ_CFG_SIZE					4
+
+/*16 QoSQs*/
+#define	__QOSQ_MIB_BASE									0x2030
+#define	__QOSQ_MIB_END									0x20AF
+#define	__QOSQ_MIB_SIZE									8
+
+#define	__QOSQ_PKT_CNT									0x2680
+
+/*#define	__SWAPQ_CFG_CTXT_BASE						0x2500*/
+#define	__SWAPQ_CFG_CTXT_DW1_ADDR				0x2501
+#define	__SWAPQ_CFG_CTXT_END						0x2501
+#define	__SWAPQ_CFG_CTXT_SIZE						2
+
+#define	__OUTQ_QOS_CFG_CTXT_BASE				0x2550
+#define	__OUTQ_QOS_CFG_CTXT_END					0x255F
+#define	__OUTQ_QOS_CFG_CTXT_SIZE				4
+
+/*==========================================================================
+ Defines for ERB Module
+============================================================================*/
+
+#define	__OUTQ_ERB0_BASE								0xA3F0	/*	0xA3F0-0xA40F	 16x2=32*/
+#define	__OUTQ_ERB0_SIZE								18
+#define	__OUTQ_ERB0_NUM									9
+
+#define	__OUTQ_ERB_PEER_BASE						0xA410	/*	0xA410-0xA42F	 16x2=32*/
+#define	__OUTQ_ERB_PEER_SIZE						18
+#define	__OUTQ_ERB_PEER_NUM							9
+
+#define	__FRAGQ_ERB0_BASE								0xA430	/*	0xA430-0xA44F	 16x2=32*/
+#define	__FRAGQ_ERB0_SIZE								18
+#define	__FRAGQ_ERB0_NUM								9
+
+#define	__FRAGQ_ERB0_BP_BASE						0xA450	/*	0xA450-0xA45F	 16x1=16*/
+#define	__FRAGQ_ERB0_BP_SIZE						9
+#define	__FRAGQ_ERB0_BP_NUM							9
+
+#define	__FRAGQ_ERB_PEER_BASE						0xA460	/*	0xA460-0xA47F	 16x2=32*/
+#define	__FRAGQ_ERB_PEER_SIZE						18
+#define	__FRAGQ_ERB_PEER_NUM						9
+
+#define	__FRAGQ_ERB_PEER_BP_BASE				0xA480	/*	0xA480-0xA48F	 16x1=16*/
+#define	__FRAGQ_ERB_PEER_BP_SIZE				9
+#define	__FRAGQ_ERB_PEER_BP_NUM					9
+
+#define	__OUTQ_ERB0_CFG_CTXT_BASE				0xA490	/*	0xA490-0xA497	 1x8=8*/
+#define	__OUTQ_ERB0_CFG_CTXT_SIZE				8
+#define	__OUTQ_ERB0_CFG_CTXT_NUM				1
+
+#define	__OUTQ_ERB_PEER_CFG_CTXT_BASE		0xA4A0	/*	0xA4A0-0xA4A7	 1x8=8*/
+#define	__OUTQ_ERB_PEER_CFG_CTXT_SIZE		8
+#define	__OUTQ_ERB_PEER_CFG_CTXT_NUM		1
+
+#define	__FRAGQ_ERB0_CFG_CTXT_BASE			0xA4B0	/*	0xA4B0-0xA4B7	 1x8=8*/
+#define	__FRAGQ_ERB0_CFG_CTXT_SIZE			8
+#define	__FRAGQ_ERB0_CFG_CTXT_NUM				1
+
+#define	__FRAGQ_ERB_PEER_CFG_CTXT_BASE	0xA4C0	/*	0xA4C0-0xA4C7	 1x8=8*/
+#define	__FRAGQ_ERB_PEER_CFG_CTXT_SIZE	8
+#define	__FRAGQ_ERB_PEER_CFG_CTXT_NUM		1
+
+#define	__BG_ERB_CFG_CTXT_BASE				0xA4D0	/*	0xA4D0-0xA4D3	 4x4=16*/
+#define	__BG_ERB_CFG_CTXT_SIZE				16
+#define	__BG_ERB_CFG_CTXT_NUM				4
+
+#define	__FRAGQ_ERB0_FREE_FRAG_CNT		0xA4E0
+#define	__FRAGQ_ERB_PEER_FREE_FRAG_CNT	0xA4E1
+
+#define	__FRAGQ_ERB0_REL_FRAG_MIB		0xA4F0
+#define	__FRAGQ_ERB_PEER_REL_FRAG_MIB	0xA4F1
+
+#define	__OUTQ_ERB0_REL_PKT_MIB			0xA4F2
+#define	__OUTQ_ERB_PEER_REL_PKT_MIB		0xA4F3
+
+#define	__ERB_FRAG_MIB					0xA4F4
+#define	__ERB_PEER_FRAG_MIB				0xA4F5
+
+#define	__FRAGQ_ERB0_REL_IDX			0xA4F6
+#define	__FRAGQ_ERB_PEER_REL_IDX		0xA4F7
+
+#define	__NUM_ERB						2
+
+#define	__ERB_STD_DATA_LEN				0x2354
+
+#define	__ERB_REG_STACK					0x2355 /*	0x2355-0x2357	*/
+
+#define __ERB_TIMER_ON                  0x2358
+
+#define __US_DISPATCH_CNT_CFG           0x24D0
+#define __US_DISPATCH_CNT               0x24D1
+
+#define __US_BOND_CNT_CFG               0x24D2
+#define __US_BOND_CNT                   0x24D3
+
+/***********************************************
+	"Unified QoS"	Module Memory	Allocation - END
+	**********************************************/
+
+#define	__DES_SYNC_CFG_CTXT_BASE				__DES_SYNC_CFG_CTXT
+#define	__DES_SYNC_CFG_CTXT_BASE_END		0x2FBF
+
+#define	__DES_READ_SYNC_CFG_CTXT_BASE	 __DES_SYNC_CFG_CTXT_BASE
+#define	__DES_READ_SYNC_CFG_CTXT_END	 __DES_SYNC_CFG_CTXT_BASE_END
+
+#define	__DES_WRITE_SYNC_CFG_CTXT_BASE	__DES_SYNC_CFG_CTXT_BASE
+#define	__DES_WRITE_SYNC_CFG_CTXT_END		__DES_SYNC_CFG_CTXT_BASE_END
+
+/*temp defined US_CDMA_COPY_CH related structure from	 0x2340to0x4f
+	(reuse__US_EDMA_COPY_CH_CFG)*/
+#define	__US_CDMA_COPY_CH_CFG						0x2340	/* 0x2340-0x2347	1x8=8*/
+#define	__US_CDMA_READ_CH_CFG_CTXT			0x2798	/* 0x2798-0x279F	1x8=8*/
+/*					VRX518 specific	definition */
+#define	__US_CDMA_CHAN_NO												8
+
+#define	__CDMA_READ_COPY_CH_CFG_BASE		__US_CDMA_COPY_CH_CFG
+#define	__CDMA_READ_COPY_CH_CFG_END			0x2350
+#define	__SIZE_OF_CDMA_COPY_CH_CFG		1
+#define	__CDMA_READ_CH_CTXT				__US_CDMA_READ_CH_CFG_CTXT
+#define	__CDMA_READ_CH_CTXT_END					0x27A0
+#define	__SIZE_OF_CDMA_READ_CH_CTXT			8
+#define __US_CDMA_EXT_SB_BASE						0xBA80	/* 0xBA80-0xBC7F	128x4=512*/
+
+#define	__US_LOCAL_Q_SHARED_CDMA_BASE		0xB980
+#define	__US_LOCAL_Q_SHARED_CDMA_NUM		128
+#define	__US_QOS_Q_SHARED_CDMA_BASE			0xB880
+#define	__US_QOS_Q_SHARED_CDMA_NUM			128
+
+/*PPA2.16	PI*/
+#define	__DS_CDMA_COPY_CH_CFG						0x2350	/* 0x2350-0x2351	1x2=1*/
+
+#define	__REG_STACK_PI									0x2351	/* 0x2351-0x2352	2x1=2*/
+
+#define	__DES_SIDEBAND_WR_PTR						0x2353	/*0x2352-0x2353	*/
+
+#define	__DES_SIDEBAND_LIST_BASE				0xB780	/* 0xB780-0xB87F	256x1=256*/
+
+/*Match	the	DS_PKT_DES_LIST	SIZE for Single	Line */
+#define	__DES_SIDEBAND_LIST_SIZE				__DS_PKT_DES_LIST_NUM
+
+/*Match	the	DS_FRAG_Q_LIST SIZE for Bonding */
+#define	__DES_SIDEBAND_BOND_LIST_SIZE			__DS_FRAGQ_DES_LIST_PERQ_NUM
+
+
+#define	__SOC_FAMILY										0x2507
+
+/*SB	=	0x7000*/
+#define	__WRITE_CH_DOORBELL_EXT_ADDR		0x1E700980
+#define	__WRITE_CH_DOORBELL_EXT_ADDR_HI	0x1E70
+#define	__WRITE_CH_DOORBELL_EXT_ADDR_LO	0x0980
+
+/*SB	=	0x7001*/
+#define	__READ_CH_DOORBELL_EXT_ADDR			0x1E709A0
+#define	__READ_CH_DOORBELL_EXT_ADDR_HI	0x1E70
+#define	__READ_CH_DOORBELL_EXT_ADDR_LO	0x09A0
+
+
+/*==========================================================================
+	TC	Part (E1 part)
+	==========================================================================*/
+#define	__RX_BC_CFG_STATS_CFG_BASE			0x3E80	/* 0x3E80-0x3EBF	2x32=64*/
+#define	__TX_BC_CFG_STATS_CFG_BASE			0x3EC0	/* 0x3EC0-0x3EFF	2x32=64*/
+#define	__RX_GIF_CFG_STATS_CFG_BASE			0x3D80	/* 0x3D80-0x3DFF	4x32=128*/
+#define	__TX_GIF_CFG_STATS_CFG_BASE			0x3E00	/* 0x3E00-0x3E7F	4x32=128*/
+#define	__RX_GIF_MIB_BASE								0x3400	/* 0x3400-0x341F	4x8=32*/
+
+/*---------------------------------------------------
+	detailed	SB allocation
+	---------------------------------------------------*/
+
+/*---------------------------------------------------
+	WAN RX	BC Config/Status/Context Table
+	 32	*	2	=	64
+	---------------------------------------------------*/
+#define	__RX_BC0_CFG_STATS_CFG							__RX_BC_CFG_STATS_CFG_BASE
+/* #define __RX_BC1_CFG_STATS_CFG							 0x3EA0*/
+
+/*---------------------------------------------------
+	WAN TX	BC Config/Status/Context Table
+	32	*	2	=	64
+	---------------------------------------------------*/
+#define	__TX_BC0_CFG_STATS_CFG							__TX_BC_CFG_STATS_CFG_BASE
+/*#define	__TX_BC1_CFG_STATS_CFG							0x3EE0*/
+
+/*---------------------------------------------------
+	WAN RX	Path Config/Status/Context Table
+	i.e.	Gamma	Interface	Config/Status/Context
+	32	*	4	=	128
+	---------------------------------------------------*/
+#define	__RX_GIF0_CFG_STATS_CFG							__RX_GIF_CFG_STATS_CFG_BASE
+/*	#define __RX_GIF1_CFG_STATS_CFG						0x3DA0
+		#define __RX_GIF2_CFG_STATS_CFG						0x3DC0
+		#define __RX_GIF3_CFG_STATS_CFG						0x3DE0*/
+
+/*---------------------------------------------------
+	WAN TX	Path Config/Status/Context Table
+	i.e.	Gamma	Interface	Config/Status/Context
+	32	*	4	=	128
+	---------------------------------------------------*/
+#define	__TX_GIF0_CFG_STATS_CFG							__TX_GIF_CFG_STATS_CFG_BASE
+/* #define __TX_GIF1_CFG_STATS_CFG						 0x3E20
+	#define __TX_GIF2_CFG_STATS_CFG						 0x3E40
+	#define __TX_GIF3_CFG_STATS_CFG						 0x3E60*/
+
+/*---------------------------------------------------
+	WAN RX	Gamma	Interface	MIB	Table
+	4 * 8 = 32
+	---------------------------------------------------*/
+#define	__RX_GIF0_MIB_BASE									__RX_GIF_MIB_BASE
+#define	__RX_GIF1_MIB_BASE									0x3408
+#define	__RX_GIF2_MIB_BASE									0x3410
+#define	__RX_GIF3_MIB_BASE									0x3418
+
+
+/*==========================================================================
+	Bonding Part	(B1	part)
+	==========================================================================*/
+#define	__DS_BOND_GIF_LL_DES_BA					0x9300 	/* 0x9300-0x9EFF	1536x2=3072*/
+
+#define	__US_BG_CTXT_BASE								0x3F00	/* 0x3F00-0x3F0F	4x4=16*/
+#define	__DS_BOND_LL_CTXT_BASE					0x26A4	/* 0x26A4-0x26C7	9x4=36*/
+#define	__DS_BOND_GIF_MIB_BASE					0x2E80	/* 0x2E80-0x2EFF	8x16=128*/
+#define	__DS_BG_MIB_BASE								0x3F20	/* 0x3F20-0x3F5F	4x16=64*/
+#define	__DS_BG_CTXT_BASE								0x3FE0	/* 0x3FE0-0x3FFF	4x8=32*/
+#define	__DS_BOND_GIF_LL_DESBP_BA				0xB900 /* 0xB900-0xBEFF	1536x1=1536*/
+
+#define __TO_BUF_FULL_CNT						0x2456
+
+
+/*-------------------------------------
+	SB	allocation in	detail
+	-------------------------------------*/
+/*US Bonding Group Context
+	Section	5.7	in Spec*/
+#define	__US_BG_CTXT												__US_BG_CTXT_BASE
+#define	__US_BG_CTXT_SIZE										16
+#define	__US_BG_CTXT_SIZE_PER_BG						4
+
+/*DS Bonding Gamma Interface Linked-List Context
+	Section	5.8	in Spec*/
+#define	__DS_BOND_FREE_LL_CTXT							__DS_BOND_LL_CTXT_BASE
+#define	__DS_BOND_FREE_LL_CTXT_SIZE					4
+
+#define	__DS_BOND_GIF_LL_CTXT								0x26A8
+#define	__DS_BOND_GIF_LL_CTXT_SIZE					32
+#define	__DS_BOND_GIF_LL_CTXT_SIZE_PER_GIF	4
+
+/*DS Bonding Gamma Interface MIB
+	Section	5.9	in Spec*/
+#define	__DS_BOND_GIF_MIB										__DS_BOND_GIF_MIB_BASE
+#define	__DS_BOND_GIF_MIB_SIZE							128
+#define	__DS_BOND_GIF_MIB_SIZE_PER_BG				16
+
+/*DS Bonding Group MIB
+	Section	5.10 in	Spec*/
+#define	__DS_BG_MIB													__DS_BG_MIB_BASE
+#define	__DS_BG_MIB_SIZE										64
+#define	__DS_BG_MIB_SIZE_PER_BG							16
+
+/*DS Bonding Group Context
+	Section	5.11 in	Spec*/
+#define	__DS_BG_CTXT												__DS_BG_CTXT_BASE
+#define	__DS_BG_CTXT_SIZE										32
+#define	__DS_BG_CTXT_SIZE_PER_BG						8
+
+#define	__MAX_PKT_SIZE_CFG					0x2502
+
+
+/*	Link	UP/DOWN	info
+		E1	forwards link	up/down	info generated by	DSL	firmware
+		to	B1 with	 __MBOX_IGU4_ISRS	and	__MBOX_IGU4_ISRC
+		to	indicate link	UP and DOWN*/
+#define	__LINK_UP_DOWN_STATUS								__MBOX_IGU4_ISR
+
+
+/*==========================================================================
+	General Context
+	==========================================================================*/
+#define	__GENERAL_CONTEXT_BASE							0x3000	/*0x3000-0x31FF	512x1=512*/
+
+/*------------------------------------------------
+	detailed	SB allocation
+	------------------------------------------------*/
+/*US Internal	Variables*/
+#define	__US_E1_FRAG_Q_FRAG_MIB							0x3100
+#define	__US_E1_FRAG_Q_NON_EMPTY_FLAG				0x3108
+
+#define	__US_E1_FRAG_Q_DES_WRIDX						0x3110
+#define	__US_E1_FRAG_Q_DES_RDIDX						0x3118
+
+/*free	des	per	gif	0x3120-0x3127*/
+#define	__US_E1_FRAG_Q_FREE_FRAG_CNT				0x3120
+/*number	of fragment	released by	release	proc per gif
+	0x3128-0x312F*/
+#define	__US_E1_FRAG_Q_REL_FAG_MIB					0x3128
+
+/*===========================================================
+	Debug Variable
+	===========================================================*/
+#define	__MAX_XPCI_WDES_NUM									0x3130
+#define	__FLUSH_NO_DES_NUM									0x3131
+
+/*===========================================================
+	XPCI	desc read	data buffer: 0x3140-0x314F
+	===========================================================*/
+#define	__XPCI_RDES_DES_BASE								0x3140
+#define	__XPCI_RDES_DES_BASE_HW							0x1140
+#define	__XPCI_RDES_DES_SIZE								16
+
+
+/*	0x3150	-	0x31F0*/
+#define	__XPCI_DES_READ_OWN_CHECK_CNT				0x3150
+
+
+/*DS Internal	Variables*/
+#define	__DS_SM_E1_FRAG_DES_RDIDX						0x3180
+#define	__DS_BM_E1_FRAG_DES_RDIDX						0x3181
+#define	__RX_FRAG_DISP_RDIDX								__DS_SM_E1_FRAG_DES_RDIDX
+
+#define	__DS_BOND_GIF_LL_NONEMPTY_FLAG			0x3182
+
+#define	__IS_PKT_FLUSHING										0x3183
+#define	__DMA_PKT_FLUSHING_CURR_BG					0x3184
+#define	__DMA_TX_CH1_DES_WRPTR							0x3185
+
+/*	task	activity*/
+#define	__PP32_0_TASK_ACTV_FLAG							0x3188
+#define	__PP32_1_TASK_ACTV_FLAG							0x3189
+
+/*=====================================================================
+	debug counter,	to counter cycles	needed to	read/write cross pci
+	=====================================================================*/
+#define	__READ_NUM													0x3190
+#define	__READ_MAX_CYCLES										0x3191
+#define	__READ_MIN_CYCLES										0x3192
+#define	__TOTAL_READ_CYCLES_HI							0x3194
+#define	__TOTAL_READ_CYCLES_LO							0x3195
+
+#define	__WRITE_NUM													0x3198
+#define	__WRITE_MAX_CYCLES									0x3199
+#define	__WRITE_MIN_CYCLES									0x319A
+#define	__TOTAL_WRITE_CYCLES_HI							0x319C
+#define	__TOTAL_WRITE_CYCLES_LO							0x319D
+
+/*=====================================================================
+	cross PCI optimization	variables
+	=====================================================================*/
+#define	__IS_XPCI_DES_READ_STATUS						0x31A0
+#define	__XPCI_DES_READ_SPTR								0x31A1
+#define	__XPCI_DES_READ_EPTR								0x31A2
+#define	__XPCI_DES_READ_PDMA_CMD0						0x31A3
+#define	__XPCI_DES_READ_PDMA_CMD1						0x31A4
+
+#define	__IS_XPCI_DES_WRITE_STATUS					0x31A5
+#define	__XPCI_DES_WRITE_SPTR								0x31A6
+#define	__XPCI_DES_WRITE_EPTR								0x31A7
+#define	__XPCI_DES_WRITE_PDMA_CMD0					0x31A8
+#define	__XPCI_DES_WRITE_PDMA_CMD1					0x31A9
+
+
+#define	__TOTAL_SUCC_CNT										0x31AA
+#define	__TOTAL_FAIL_CNT										0x31AB
+
+#define	__FAILD_DATA_PTR0										0x31AC
+#define	__FAILD_DATA_PTR1										0x31AD
+#define	__FAILD_DATA_PTR2										0x31AE
+#define	__FAILD_DATA_PTR3										0x31AF
+
+/*	0x31B0-0x31BF for 4 consecutive des own bit combinnation*/
+#define	__XPCI_DES_READ_OWN_FAIL_CNT				0x31B0
+
+/*0x31C0-0x31CF for 4 data_ptr	violation	combinaton count*/
+#define	__XPCI_DES_READ_DPTR_FAIL_CNT				0x31C0
+
+
+
+/*==========================================================================
+	TC	Part (E1 Part)
+	==========================================================================*/
+#define	__TC_GENERAL_CONTEXT_BASE				0x3480	/* 0x3480-0x35FF	1x384=384*/
+
+#define	__SFSM0_DATA_BUF_BASE						0x8000	/* 0x8000-0x90FF	256x17=4352*/
+																								/*(VRX318: 0x5000)*/
+#define	__SFSM0_CTRL_BUF_BASE						0x9100	/* 0x9100-0x91FF	256x1= 256*/
+																								/*(VRX318: 0x5EE0)*/
+
+
+#define	__FFSM0_DATA_BUF_BASE						0x4000	/* 0x4000-0x454F	80x17=1360*/
+/*#define	__SFSM1_DATA_BUF_BASE					0x5770*/	/*0x5770-0x5EDF	112x17=1904*/
+/*#define	__SFSM1_CTRL_BUF_BASE					0x5F50*/	/* 0x5F50-0x5FBF	112x1=112*/
+
+#define	__FFSM1_DATA_BUF_BASE						0x4550	/*0x4550-0x4A9F	80x17=1360*/
+#define	__CTRL_K_TBL_BASE								0x4AA0	/*0x4AA0-0x4AAF	1x16=16*/
+#define	__RX_SARPDMA_CMD_BUF_BASE				0x3900	/*0x3900-0x39FF	128x 2=256*/
+#define	__TX_SARPDMA_CMD_BUF_BASE				0x3A00	/*0x3A00-0x3AFF	128x 2=256*/
+#define	__RX_SAR_CTXT_BUF_BASE					0x3200	/*0x3200-0x33FF	64 x 8=512*/
+#define	__RX_PDMA_CTXT_BUF_BASE					0x4C00	/*0x4C00-0x4DFF	64 x 8=512*/
+#define	__TX_SAR_CTXT_BUF_BASE					0x4E00	/*0x4E00-0x4FFF	64 x 8=512*/
+#define	__TX_PDMA_CTXT_BUF_BASE					0x3B00	/*0x3B00-0x3CFF	64 x 8=512*/
+#define	__PDMA_RX_DATA_BUFFER						0x5FC0	/*0x5FC0-0x5FDF	32 x 1=32*/
+#define	__PDMA_TX_DATA_BUFFER						0x5FE0	/*0x5FE0-0x5FFF	64 x 1=32*/
+
+/*---------------------------------------------------
+	detailed	SB allocation
+	---------------------------------------------------*/
+
+/*---------------------------------------------------
+	VR9 EFM-TC	general	context	[0x3480..0x35FF]
+	---------------------------------------------------*/
+#define	__BC_ID															0x3480
+
+/*---------------------------------------------------
+	RX	&	TX SAR PDMA	CMD	Write	Pointers
+	---------------------------------------------------*/
+#define	__TX_SARPDMA_CMD_RDPTR							0x3481
+#define	__RX_SARPDMA_CMD_WRPTR							0x3482
+#define	__TX_SARPDMA_CMD_WRPTR							0x3483
+
+/*---------------------------------------------------
+	RX	DMA	Descriptor - Read	&	Write	Pointers
+	---------------------------------------------------*/
+#define	__RX_DMA_DESC_RDPTR									0x3484
+#define	__RX_DMA_DESC_WRPTR									0x3485
+
+/*---------------------------------------------------
+	RX	Context	Use	Flag
+	---------------------------------------------------*/
+#define	__RX_CTX_USE_FLAG_0									0x3486
+#define	__RX_CTX_USE_FLAG_1									0x3487
+
+#define	__RX_CTXT_QID										0x2100
+#define	__RX_CTX_REUSE_FLAG_0								0x250E
+#define	__RX_CTX_REUSE_FLAG_1								0x250F
+
+/*---------------------------------------------------
+	TX	Context	Use	Flag
+	---------------------------------------------------*/
+#define	__TX_CTX_USE_FLAG_0									0x3488
+#define	__TX_CTX_USE_FLAG_1									0x3489
+
+/*---------------------------------------------------
+	TX	QoS	SWAP read	pointer
+	---------------------------------------------------*/
+#define	__FP_IN_DESC_RDPTR									0x348A
+#define	__CPU_IN_DESC_RDPTR									0x348B
+#define	__SWAP_DESC_RDPTR										0x348C
+
+/*---------------------------------------------------
+	Upstream	backpressure GPIO	control	value
+	---------------------------------------------------*/
+#define	__GPIO_BP_CURR_VAL									0x348D
+
+/*---------------------------------------------------
+	Task	pending	flag for power save
+	---------------------------------------------------*/
+#define	__TASK_PENDING_FLAG_TC_TX									0x3490
+#define	__TASK_PENDING_FLAG_TC_RX									0x3491
+#define	__TASK_PENDING_FLAG_TC_BOND								0x3492
+
+
+
+/*---------------------------------------------------
+	Downstream	Pending	Receive	packet counter
+	to	avoid	read pointer and write pointer overlap issue
+	---------------------------------------------------*/
+#define	__DS_PENDING_RECV_PKT_CNT						0x348F
+#define	DS_RW_PTR_GUARD											2
+
+/*---------------------------------------------------
+	Task	pending	flag for power save	in PP32	1
+	---------------------------------------------------*/
+/*#define	__TASK_PENDING_FLAG_VRX318_PPA						0x3490*/
+
+#define	__WAKEUP_MIB_VRX318_TX											0x3494
+#define	__WAKEUP_MIB_VRX318_RX											0x3495
+#define	__WAKEUP_MIB_VRX318_BOND										0x3496
+
+#define	__RTHA_INT_CNT															0x3497	/*NEW*/
+#define	__WAKEUP_RTHA_INT_CNT												0x3498	/*NEW*/
+#define	__TOTAL_TX_WAKEUP_CNT												0x3499	/*NEW*/
+#define	__TOTAL_RX_WAKEUP_CNT												0x349A	/*NEW*/
+#define	__TOTAL_BOND_WAKEUP_CNT											0x349B
+
+#define	__RTHA_INT_TIMEOUT													0x349C
+
+/*---------------------------------------------------
+	Receive Non Idle	Cell Count
+	---------------------------------------------------*/
+#define	__RECEIVE_NON_IDLE_CELL_CNT_0				0x34A0
+#define	__RECEIVE_NON_IDLE_CELL_CNT_1				0x34A1
+
+/*---------------------------------------------------
+	Receive Idle	Cell Count
+	---------------------------------------------------*/
+#define	__RECEIVE_IDLE_CELL_CNT_0						0x34A2
+#define	__RECEIVE_IDLE_CELL_CNT_1						0x34A3
+
+/*---------------------------------------------------
+	Transmit	Cell Count
+	---------------------------------------------------*/
+#define	__TRANSMIT_CELL_CNT_0								0x34A4
+#define	__TRANSMIT_CELL_CNT_1								0x34A5
+
+/*---------------------------------------------------
+	Receive Packet	Count	-	From Switch
+	---------------------------------------------------*/
+#define	__FP_RECEIVE_PKT_CNT								0x34A6
+#define	__CPU_PATH_RECEIVE_PKT_CNT					0x34A7
+
+/*---------------------------------------------------
+	Receive Packet	Count	-	From Switch
+	---------------------------------------------------*/
+#define	__TIMER_INT_COUNT										0x34A8
+
+/*---------------------------------------------------
+	address of	pkt_cnt	that is	used to	control	GPIO
+	for VR9,	it is	initialized	to 0x7E08	in tc_init.asm
+	for debug/test	purpose, it	should be	changed	to 0x3490
+	since 0x7e08	is not writable, note	that the address
+	should	be 8 dword aligned
+	---------------------------------------------------*/
+#define	__GPIO_CTRL_PKT_CNT_ADDR_CFG				0x34A9
+
+/*---------------------------------------------------
+	bonding variables
+	---------------------------------------------------*/
+
+/*	polling control
+		MBOX_IGU6_ISR is	used to	as signal	of new fragment	ready*/
+#define	__GIF_TX_POLLING_CTRL								0x34AA
+#define	__GIF_TX_FRAG_AVAILABLE							0x34AB
+
+
+/*	read	index	for	TX descritpor	0x34AC-0X34AF*/
+#define	__GIF_TX_DES_RDIDX									0x34AC
+#define	__GIF_TX_DES_SIZE										32
+#define	__GIF_TX_DES_SIZE_BIT_SHIFT					5
+
+#define	__GIF_TX_DES_BP_SIZE								16
+#define	__GIF_TX_DES_BP_SIZE_BIT_SHIFT			4
+
+/*	bit0-3	indicate if	GIF0-GIF3	is up	or down
+		0:link is	down,	means	local_state	!= SYNC	or SYNC_TRUE or	remote_state = 0
+		1:link is	on,	means	locase_state = SYNC	or SYNC_TRUE and remote_state	=	1*/
+#define	__PREV_GIF_LINK_STATE								0xA802
+#define	__PEER_GIF_LINK_STATE								0xA803
+
+/* Bonding debug information */
+#define	__US_FRAG_OWN_DEBUG									0xA805
+#define	__US_FRAG_PEER_PTR_DEBUG							0xAE00
+
+#define	__PREV_LINK_UP_DOWN_STATUS					0x34B2
+
+/*	busy	polling	couter for each	GIF	when link	is down*/
+#define	__GIF_BUSY_POLLING_CNT							0x34B3
+
+/*	waiting for RX	descriptor*/
+#define	__RX_WAIT_FOR_DES										0x34B4
+#define	__CONTEXT_DESC_INIT_RET_ADDR				0x34B5
+#define	__RX_NO_DES_CNT											0x34B6
+
+/*Number of	times	DREG_PDBRAM_S_44K_OWN	changes	from
+	S_44K_OWN_PPE to	S_44K_OWN_DSL*/
+#define	__PDBRAM_OWN_CHG_CNT								0x34B7
+
+
+/*---------------------------------------------------
+	SFSM0 (Pages) - Data
+	112 * 17	=	1904
+	---------------------------------------------------*/
+/*#define	__SFSM0_DATA_BUF_BASE*/
+#define	__SFSM0_DATA_BUF_SIZE								4335
+#define	__SFSM0_DATA_PAGE_NUM								255
+
+/*---------------------------------------------------
+	SFSM0 (Pages) - Ctrl
+	112 * 1 = 64
+	---------------------------------------------------*/
+/*#define	__SFSM0_CTRL_BUF_BASE*/
+#define	__SFSM0_CTRL_BUF_SIZE								__SFSM0_DATA_PAGE_NUM
+#define	__SFSM0_CTRL_PAGE_NUM								__SFSM0_DATA_PAGE_NUM
+
+/*---------------------------------------------------
+	FFSM0 (Pages) - Data
+	80	*	17 = 1360
+	---------------------------------------------------*/
+/*#define	__FFSM0_DATA_BUF_BASE*/
+#define	__FFSM0_DATA_BUF_SIZE								1360
+#define	__FFSM0_DATA_PAGE_NUM								80
+
+/*---------------------------------------------------
+	SFSM1 (Pages) - Data
+	112 * 17	=	1904
+	---------------------------------------------------*/
+/*#define	__SFSM1_DATA_BUF_BASE*/
+#define	__SFSM1_DATA_BUF_SIZE								0
+#define	__SFSM1_DATA_PAGE_NUM								0
+
+/*---------------------------------------------------
+	SFSM1 (Pages) - Ctrl
+	112 * 1 = 112
+	---------------------------------------------------*/
+/*#define	__SFSM1_CTRL_BUF_BASE*/
+#define	__SFSM1_CTRL_BUF_SIZE								__SFSM1_DATA_PAGE_NUM
+#define	__SFSM1_CTRL_PAGE_NUM								__SFSM1_DATA_PAGE_NUM
+
+/*---------------------------------------------------
+	FFSM1 (Pages) - Data
+	89	*	17 = 1360
+	---------------------------------------------------*/
+/*#define	__FFSM1_DATA_BUF_BASE*/
+#define	__FFSM1_DATA_BUF_SIZE								1360
+#define	__FFSM1_DATA_PAGE_NUM								80
+
+/*---------------------------------------------------
+	Control K Table
+	1 * 16	=	16
+	---------------------------------------------------*/
+/*#define	__CTRL_K_TBL_BASE*/
+#define	__CTRL_K_TBL_SIZE										16
+#define	__CTRL_K_TBL_NUM										1
+
+/*---------------------------------------------------
+	RX	SARPDMA	Command	Buffer
+	128 * 2 = 256
+	---------------------------------------------------*/
+/*#define	__RX_SARPDMA_CMD_BUF_BASE*/
+#define	__RX_SARPDMA_CMD_BUF_SIZE						254
+#define	__RX_SARPDMA_CMD_NUM								127
+
+/*---------------------------------------------------
+	TX	SARPDMA	Command	Buffer
+	128 * 2 = 256
+	---------------------------------------------------*/
+/*#define	__TX_SARPDMA_CMD_BUF_BASE*/
+#define	__TX_SARPDMA_CMD_BUF_SIZE						254
+#define	__TX_SARPDMA_CMD_NUM								127
+
+/*---------------------------------------------------
+	RX	SAR	Context	Buffer
+	64	*	8	=	512
+	---------------------------------------------------*/
+/*#define	__RX_SAR_CTXT_BUF_BASE*/
+#define	__RX_SAR_CTXT_BUF_SIZE							512
+#define	__RX_SAR_CTXT_NUM										64
+
+/*---------------------------------------------------
+	RX	PDMA Context Buffer
+	64	*	8	=	512
+	---------------------------------------------------*/
+/*#define	__RX_PDMA_CTXT_BUF_BASE*/
+#define	__RX_PDMA_CTXT_BUF_SIZE							512
+#define	__RX_PDMA_CTXT_NUM									64
+
+/*---------------------------------------------------
+	TX	SAR	Context	Buffer
+	64	*	8	=	512
+	---------------------------------------------------*/
+/*#define	__TX_SAR_CTXT_BUF_BASE*/
+#define	__TX_SAR_CTXT_BUF_SIZE							512
+#define	__TX_SAR_CTXT_NUM										64
+
+/*---------------------------------------------------
+	TX	PDMA Context Buffer
+	64	*	8	=	512
+	---------------------------------------------------*/
+/*#define	__TX_PDMA_CTXT_BUF_BASE*/
+#define	__TX_PDMA_CTXT_BUF_SIZE							512
+#define	__TX_PDMA_CTXT_NUM									64
+
+
+/*==========================================================================
+	Performance Monitor And Event Trace
+	==========================================================================*/
+#define	__PP32_0_INIT_CNT								0x385C
+#define	__PP32_1_INIT_CNT								0x385D
+#define	__PP32_0_MAIN_LOOP_CNT					0x385E
+#define	__PP32_1_MAIN_LOOP_CNT					0x385F
+#define	__EVENT_TRACE_INDEX_BASE				0x2570	/*0x2570-0x257F 1x16=16*/
+
+/*use SFSM	RX buffer	to store more	event, start_cmd_process will
+	disable store for BC1*/
+#define	__EVENT_TRACE_USE_BC1_SFSM_BASE	0x5800	/*0x5800-0x5BFF : 16x64=1024*/
+
+#define	__MODULE_PERF_STATISTICS				0x3860	/*0x3860-0x38FF 20x8=160*/
+#define	__PROFILING_START_TIME_HI			0x3474
+#define	__PROFILING_START_TIME_LO			0x3475
+#define	__PROFILING_END_TIME_HI					0x3476
+#define	__PROFILING_END_TIME_LO					0x3477
+#define	__RROF_EVENT_CMD							0x3478
+#define	__TIMER_SYNC_STATE							0x3479
+#define	__TC_RX_FIFO_PKT_CNT						0x347A	/*number of correct packet*/
+																					/*received in	RX_FIFO_INT_POLLING	*/
+
+#define	PROF_EVENT_CMD_START						0x1
+#define	PROF_EVENT_STATUS_STARTED				0x8001
+#define	PROF_EVENT_CMD_STOP							0x2
+#define	PROF_EVENT_STATUS_STOPPED				0x8002
+#define	TIMER_SYNC_END_STATE						2
+#define	EM_TICK_WIDTH										19
+#define	EM_CLK_WIDTH										13
+
+
+/*	frag_header tracing*/
+#define	__FRAG_HEADER_TRACE_IDX					0x26C8
+
+#define	FH_TRACE_NUM										128
+#define	FH_TRACE_NUM_BIT_WIDTH					7
+
+#define	__EP0_US_SEG_IDX								0x26C8
+#define	__EP1_US_SEG_IDX								0x26C9
+#define	__EP0_DS_TC_RECV_IDX						0x26CA
+#define	__EP1_DS_TC_RECV_IDX						0x26CB
+/*#define	__EP0_DS_EDMA_PP_IDX						0x26CC*/
+/*#define	__EP1_DS_EDMA_PP_IDX						0x26CD*/
+#define	__EP0_DS_BONDING_DISP_IDX				0x26CE
+#define	__EP1_DS_BONDING_DISP_IDX				0x26CF
+
+#define	__EP0_US_SEG_FH_BASE						0x5800
+#define	__EP1_US_SEG_FH_BASE						0x5880
+#define	__EP0_DS_TC_RECV_FH_BASE				0x5900
+#define	__EP1_DS_TC_RECV_FH_BASE				0x5980
+/*#define	__EP0_DS_EDMA_PP_FH_BASE				0x5A00*/
+/*#define	__EP1_DS_EDMA_PP_FH_BASE				0x5A80*/
+#define	__EP0_DS_BONDING_DISP_FH_BASE		0x5B00
+#define	__EP1_DS_BONDING_DISP_FH_BASE		0x5B80
+
+
+/*==========================================================================
+	Free	Spaces
+	==========================================================================*/
+/*--------------------------------------------------------------------------
+		From		To			 Size
+----------------------------------------------------------------------------*/
+
+
+/*==========================================================================
+	FROM	vr9	bonding
+	--------------
+	PDMA Registers
+	--------------*/
+#define	__DMAL_BAR0_FIFO_STATUS							0x7600
+#define	__DMAL_BAR1_FIFO_STATUS							0x7601
+#define	__PDMA_BAR0													0x7602
+#define	__PDMA_BAR1													0x7603
+
+#define	__BAR0_WINDOW_SB_ADDR								0x6000
+#define	__BAR0_WINDOW_SB_ADDR_PLUS_1				0x6001
+#define	__BAR1_WINDOW_SB_ADDR								0x6800
+#define	__BAR1_WINDOW_SB_ADDR_PLUS_1				0x6801
+
+
+/*	hardware	registers*/
+#define	__SAR_PDMA_RX_FW_DATABUF_CFG				0x7F02
+#define	__SAR_PDMA_TX_FW_DATABUF_CFG				0x7F03
+#define	__PDMA_IER													0x7A0B
+
+/*--------------------
+	Constant Definitions
+	--------------------*/
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//---------------------
+//Descriptors Addresses
+//---------------------
+//E1 TX Fragment Descriptor Base Address (Non-Bonding Part)
+//Section 5.2.4 (Non-Bonding Part)
+#define	__US_E1_FRAG_DESBA											0x3800
+#define	__US_E1_FRAG_DES_NUM										128
+#define	__US_E1_FRAG_DES_SIZE										2
+#define	__US_E1_FRAG_DES_TOTAL_SIZE             256
+//__US_E1_FRAG_DES_NUM_PER_GIF = __US_E1_FRAG_DES_NUM/__NUM_US_GIFS
+#define	__US_E1_FRAG_DES_NUM_PER_GIF						16
+//__US_E1_FRAG_DES_TOTAL_SIZE_PER_GIF=__US_E1_FRAG_DES_TOTAL_SIZE/__NUM_US_GIFS
+#define	__US_E1_FRAG_DES_TOTAL_SIZE_PER_GIF			32
+
+//E1 TX Fragment Descriptor Base Address	(Bonding Part)
+//Section 5.2.4 (Bonding Part)
+#define	__US_E1_FRAG_BP_DESBA										0x3F60
+#define	__US_E1_FRAG_BP_DES_NUM									128
+#define	__US_E1_FRAG_BP_DES_SIZE								1
+#define	__US_E1_FRAG_BP_DES_TOTAL_SIZE					128
+//__US_E1_FRAG_BP_DES_NUM_PER_GIF = __US_E1_FRAG_BP_DES_NUM/__NUM_US_GIFS
+#define	__US_E1_FRAG_BP_DES_NUM_PER_GIF					16
+//__US_E1_FRAG_BP_DES_TOTAL_SIZE_PER_GIF = \
+		__US_E1_FRAG_BP_DES_TOTAL_SIZE/__NUM_US_GIFS
+#define	__US_E1_FRAG_BP_DES_TOTAL_SIZE_PER_GIF	16
+
+//System Master E1 RX Fragment Descriptor Base Address
+#define	__DS_SM_E1_FRAG_DESBA										0x3D00
+#define	__DS_SM_E1_FRAG_DES_NUM									32
+#define	__DS_SM_E1_FRAG_DES_SIZE								2
+#define	__DS_SM_E1_FRAG_DES_TOTAL_SIZE					64
+
+//Bonding Master E1 RX Fragment Descriptor Base Address
+#define	__DS_BM_E1_FRAG_DESBA										0x3D40
+#define	__DS_BM_E1_FRAG_DES_NUM									32
+#define	__DS_SM_E1_FRAG_DES_SIZE								2
+#define	__DS_SM_E1_FRAG_DES_TOTAL_SIZE					64
+
+//DS Bonding GIF Link List Descriptor Base Address
+#define	__DS_BOND_GIF_LL_DESBA									0x5210
+#define	__DS_BOND_GIF_LL_DES_NUM								512
+
+//DMA TX Channel 1 Descriptor List
+#define	__DMA_TX_CH1_DESBA											0xB070
+#define	__DMA_TX_CH1_DESBA_HW										0x9070
+#define	__DMA_TX_CH1_DES_NUM										256
+#define	__DMA_TX_CH1_DES_TOTAL_SIZE							512
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
+
+/*----------------
+	FW Context & MIB
+	----------------*/
+
+/*US Bonding Priority	Queue	Descriptor Configuraton	Table
+	Section	5.4	in Spec	-	Already	defined	in E1*/
+
+/*US Bonding Priority	Queue	Shaping	&	Scheduling Configuration Table
+	Section	5.5	in Spec	-	Already	defined	in E1*/
+
+/*US Bonding Priority	Queue	MIB	Counters
+	Section	5.6	in Spec	-	Already	defined	in E1*/
+
+
+
+
+
+
+/*---------------------
+	FW Internal	Variables
+
+	============================================================================
+	 FROM	e1
+
+
+	==========================================================================
+	 EFM-TC	Address	definition
+	==========================================================================*/
+
+/*
+//---------------------------------------------------
+// WAN CPU TX channel Descriptor List
+// 64 * 2 = 128
+//---------------------------------------------------
+#define __CPU_TX_DESC_LIST                  0x3D00
+#define __CPU_TX_DESC_LIST_SIZE             128
+#define __CPU_TX_DESC_NUM                   64
+
+//---------------------------------------------------
+// WAN SWAP TX channel Descriptor List Length
+// 64 * 2 = 128
+//---------------------------------------------------
+#define __SWAP_TX_DESC_LIST                 0x2E80
+#define __SWAP_TX_DESC_LIST_SIZE            64
+#define __SWAP_TX_DESC_NUM                  32
+
+//---------------------------------------------------
+// DSL Fastpath TX Channel Descriptor
+// 64 * 2 = 128
+//---------------------------------------------------
+#define __DSL_FASTPATH_TX_DESC_LIST         0x2580
+#define __DSL_FASTPATH_TX_DESC_LIST_SIZE    128
+#define __DSL_FASTPATH_TX_DESC_NUM          64
+
+
+
+//---------------------------------------------------
+// DMA RX Channel 1 Descriptor
+// 64 * 2 = 128
+//---------------------------------------------------
+#define	__DMA_RX_CH1_DESC_LIST						__DSL_FASTPATH_TX_DESC_LIST
+#define	__DMA_RX_CH1_DESC_LIST_SIZE					__DSL_FASTPATH_TX_DESC_LIST_SIZE
+#define	__DMA_RX_CH1_DESC_NUM						__DSL_FASTPATH_TX_DESC_NUM
+
+//---------------------------------------------------
+// DSL RX Channel Descriptor
+// 64 * 2 = 128
+//---------------------------------------------------
+#define	__DSL_RX_DESC_LIST							0x2600
+#define	__DSL_RX_DESC_LIST_SIZE						128
+#define	__DSL_RX_DESC_NUM							64
+
+//---------------------------------------------------
+// DMA TX Channel 1 Descriptor List
+// 64 * 2 = 128
+//---------------------------------------------------
+#define	__DMA_TX_CH1_DESC_LIST						__DSL_RX_DESC_LIST
+#define	__DMA_TX_CH1_DESC_LIST_SIZE					__DSL_RX_DESC_LIST_SIZE
+#define	__DMA_TX_CH1_DESC_NUM						__DSL_RX_DESC_NUM
+
+//---------------------------------------------------
+// DSL Shaping and Scheduling Configure
+// 8 * 4 = 32
+//---------------------------------------------------
+#define	__DSL_SHAPING_SCHEDULING_CFG			0x2680
+#define	__DSL_SHAPING_SCHEDULING_CFG_SIZE		32
+#define	__DSL_SHAPING_SCHEDULING_CFG_NUM		8
+
+//---------------------------------------------------
+// ETH0 RX (Pages) - Data
+// 20 * 32 = 640
+//---------------------------------------------------
+#define	__ETH0_RX_DATA_BUF_BASE					0x4550
+#define	__ETH0_RX_DATA_BUF_SIZE					640
+#define	__ETH0_RX_DATA_PAGE_NUM					20
+
+//---------------------------------------------------
+// ETH0 RX (Pages) - Ctrl
+// 20 * 1 = 20
+//---------------------------------------------------
+#define	__ETH0_RX_CTRL_BUF_BASE					0x47D0
+#define	__ETH0_RX_CTRL_BUF_SIZE					__ETH0_RX_DATA_PAGE_NUM
+#define	__ETH0_RX_CTRL_PAGE_NUM					__ETH0_RX_DATA_PAGE_NUM
+
+
+*/
+
+/*---------------------------------------------------
+	ACA FW	Context
+	2 * 8 = 16
+	---------------------------------------------------*/
+#define	__US_ACA_CFG_CTXT_BASE					0x4BB0	/* 0x4BB0--0x4BB7	1x8=8*/
+#define	__DS_ACA_CFG_CTXT_BASE					0x4BB8	/* 0x4BB8--0x4BBF	1x8=8*/
+
+
+/*----------------------------------------------------------
+	ACA Shadow	Registers
+	3 * 4 = 12
+	*_STATUS	need to	be initialized to	nonzero	by PPE driver
+	----------------------------------------------------------*/
+
+#define	__ACA_SHADOW_REG_BASE					0xADF0
+
+#define	__TX_IN_ACA_ACCUM_COUNT					0xADF0
+
+#define	__TX_IN_ACA_ACCUM_STATUS				0xADF1
+
+#define	__TX_IN_QUEUE_PD_BASE_ADDR_OFFSET		0xADF2
+
+#define	__TX_OUT_ACA_ACCUM_COUNT				0xADF3
+
+#define	__TX_OUT_ACA_ACCUM_STATUS				0xADF4
+
+#define	__TX_OUT_QUEUE_PD_BASE_ADDR_OFFSET		0xADF5
+
+#define	__RX_IN_ACA_ACCUM_COUNT					0xADF6
+
+#define	__RX_IN_ACA_ACCUM_STATUS				0xADF7	/*0x1E22AFDC for VRX318*/
+
+#define	__RX_IN_QUEUE_PD_BASE_ADDR_OFFSET		0xADF8
+
+#define	__RX_OUT_ACA_ACCUM_COUNT				0xADF9
+
+#define	__RX_OUT_ACA_ACCUM_STATUS				0xADFA
+
+#define	__RX_OUT_QUEUE_PD_BASE_ADDR_OFFSET		0xADFB
+
+
+/*dummy	ACA	registers, FPI addresses to	be configured	in *_ACA_CFG_CTXT, used
+	for	testing	without	ACA	HW*/
+
+/*#define TX_IN_ACA_ACCUM_SUB					0x4BFC*/	/*0x1E22AFF0 for VRX318	*/
+/*#define TX_OUT_ACA_ACCUM_ADD					0x4BFD*/	/*0x1E22AFF4 for VRX318*/
+
+
+/*#define RX_IN_ACA_ACCUM_SUB					0x4BE0*/	/*0x1E22AF80	for	VRX318 */
+/*#define RX_OUT_ACA_ACCUM_ADD					0x4BE1*/	/*0x1E22AF84 for	VRX318*/
+
+#define	_CHK_PREEMP_MAP							0x4BFC
+
+#define	_QID2PREEMP_MAP							0x4BFD
+
+#define	__QOSQ_NO_DROP							0x4BFE
+
+#define	__TOTAL_DS_ACA_DEQ_CNT					0x4BFF
+
+#define	__TOTAL_RX_IN_ACA_ACCUM_CNT				0x347F
+
+
+/*---------------------------------------------------------------
+	Programmable	Address	Mapping	(To	be initialized by	PPE	driver)
+	---------------------------------------------------------------*/
+#define	__EP_ADDR_BAR							0x2028
+
+
+/*----------------------------------------------------------------
+	ACA TX_IN PD	List
+	----------------------------------------------------------------*/
+#define	__ACA_TX_IN_PD_LIST_BASE				__US_FAST_PATH_DES_LIST_BASE
+#define	__ACA_TX_IN_PD_LIST_SIZE				__US_FAST_PATH_DES_LIST_SIZE
+#define	__ACA_TX_IN_PD_LIST_NUM					__US_FAST_PATH_DES_LIST_NUM
+
+/*__ACA_TX_IN_PD_LIST_GUARD	<= __ACA_TX_IN_PD_LIST_NUM - 1*/
+#define	__ACA_TX_IN_PD_LIST_GUARD				__US_FAST_PATH_DES_LIST_GUARD
+
+/*----------------------------------------------------------------
+	ACA TX_OUT	PD List
+	----------------------------------------------------------------*/
+
+#define	__ACA_TX_OUT_PD_LIST_BASE				0xA960	/* 0xA960-0xA9DF	128	 */
+#define	__ACA_TX_OUT_PD_LIST_SIZE				128
+#define	__ACA_TX_OUT_PD_LIST_NUM				64
+
+/*__ACA_TX_OUT_PD_LIST_GUARD <=	__ACA_TX_OUT_PD_LIST_NUM - 1*/
+#define	__ACA_TX_OUT_PD_LIST_GUARD				32
+
+
+/*----------------------------------------------------------------
+	ACA RX_IN PD	List
+	----------------------------------------------------------------*/
+#define	__ACA_RX_IN_PD_LIST_BASE				__DS_PKT_DES_LIST_BASE
+#define	__ACA_RX_IN_PD_LIST_SIZE				__DS_PKT_DES_LIST_SIZE
+#define	__ACA_RX_IN_PD_LIST_NUM					__DS_PKT_DES_LIST_NUM
+
+/*__ACA_RX_IN_PD_LIST_GUARD	<= __ACA_RX_IN_PD_LIST_NUM - 1*/
+#define	__ACA_RX_IN_PD_LIST_GUARD				__DS_PKT_DES_LIST_GUARD
+
+/*----------------------------------------------------------------
+	ACA RX_OUT	PD List
+	----------------------------------------------------------------*/
+#define	__ACA_RX_OUT_PD_LIST_BASE				__DS_PKT_DES_LIST_BASE
+#define	__ACA_RX_OUT_PD_LIST_SIZE				__DS_PKT_DES_LIST_SIZE
+#define	__ACA_RX_OUT_PD_LIST_NUM				__DS_PKT_DES_LIST_NUM
+
+/*__ACA_RX_OUT_PD_LIST_GUARD <=	__ACA_RX_OUT_PD_LIST_NUM - 1*/
+#define	__ACA_RX_OUT_PD_LIST_GUARD				__DS_PKT_DES_LIST_GUARD
+
+
+#define	__INT_ACA_TX_IN_CNT							0x3D00
+#define	__INT_ACA_TX_IN_TIMEOUT						0x3D01
+#define	__INT_ACA_TX_IN_WAKEUP_CNT					0x3D02
+
+#define	__INT_ACA_RX_IN_CNT							0x3D04
+#define	__INT_ACA_RX_IN_TIMEOUT						0x3D05
+#define	__INT_ACA_RX_IN_WAKEUP_CNT					0x3D06
+
+
+/*RX interrupt from	PP32_2(TC_RX core) to	PP32_0 (TC_TX	core)
+	or PP32_1	(TC_BOND core)*/
+#define	__MBOX_PPM_IER								__MBOX_IGU3_IER
+#define	__MBOX_PPM_ISR								__MBOX_IGU3_ISR
+#define	__MBOX_PPM_ISRS								__MBOX_IGU3_ISRS
+#define	__MBOX_PPM_ISRC								__MBOX_IGU3_ISRC
+
+#define	BIT_MBOX_PPM								BIT0
+#define	__ISRS_SET_CNT_MBOX_PPM						0x3D08
+#define	__ISR_CHECK_CNT_MBOX_PPM					0x3D09
+
+#define	__INT_MBOX0_PPM_CNT							0x3D0A
+#define	__INT_MBOX0_PPM_TIMEOUT						0x3D0B
+#define	__INT_MBOX0_PPM_WAKEUP_CNT					0x3D0C
+
+
+/*cdma_read_data_pp	interrupt	from PP32_1(Bonding	Core)	to
+	PP32_0	(TC_TX core)*/
+#define	__MBOX1_PPM_IER							__MBOX_IGU4_IER
+#define	__MBOX1_PPM_ISR							__MBOX_IGU4_ISR
+#define	__MBOX1_PPM_ISRS						__MBOX_IGU4_ISRS
+#define	__MBOX1_PPM_ISRC						__MBOX_IGU4_ISRC
+
+#define	BIT_MBOX1_PPM							BIT0
+#define	__ISRS_SET_CNT_MBOX1_PPM				0x3D10
+#define	__ISR_CHECK_CNT_MBOX1_PPM				0x3D11
+
+#define	__INT_MBOX1_PPM_CNT						0x3D12
+#define	__INT_MBOX1_PPM_TIMEOUT					0x3D13
+#define	__INT_MBOX1_PPM_WAKEUP_CNT				0x3D14
+
+/*DSL showtime/leave showtime interrupt from MIPS to PP32_2 (TC_RX core) */
+#define	__MBOX2_PPM_IER						__MBOX_IGU5_IER
+#define	__MBOX2_PPM_ISR						__MBOX_IGU5_ISR
+#define	__MBOX2_PPM_ISRS					__MBOX_IGU5_ISRS
+#define	__MBOX2_PPM_ISRC					__MBOX_IGU5_ISRC
+
+#define	BIT_MBOX2_PPM						BIT0
+#define	__ISRS_SET_CNT_MBOX2_PPM			0x3D15
+#define	__ISR_CHECK_CNT_MBOX2_PPM			0x3D16
+
+#define	__INT_MBOX2_PPM_CNT					0x3D17
+#define	__INT_MBOX2_PPM_WAKEUP_CNT			0x3D18
+
+#define	__SLEEP_UPAGE_CNT					0x3D19
+
+/* 0x2FC0--0x2FDF 1 x 32 = 32  */
+#define	__INT_PP32_2_CNT					0x2FC0 
+
+
+#define	__MODE_SW_CFG						__DREG_MEI_STATE
+#define	__MODE_SW_INT						0x250D
+
+/* 0x3FC0--0x3FDF 1 x 32 = 32 */
+#define	__MODE_SW_CNT						0x3FC0
+
+#define	__MODE_SW_CNT_CFG					0x4BC0
+
+#define	__DS_ACA_DELAY						0x4BC1
+
+#define	__DS_ACA_TIMEOUT_CNT				0x4BC2
+
+#define	__PCIE_SWITCH_PRESENT				0x4BC3
+
+#define	__TX_IN_OUT_TOTAL_CNT				0x4BC4
+
+#define	__PD_SHADOW_PRESENT					0x4BC5
+
+#define	__TX_OUT_SHADOW_PTR					0x4BC6
+
+#define	__RX_OUT_SHADOW_PTR					0x4BC7
+
+/*PDBRAM addresses used for manual testing */
+#define	__TX_OUT_PDBRAM_BASE_HI				0x0023
+#define	__TX_OUT_PDBRAM_BASE_LOW			0x6000
+
+#define	__RX_OUT_PDBRAM_BASE_HI				0x0023
+#define	__RX_OUT_PDBRAM_BASE_LOW			0x5000
+
+
+#endif
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_ds_be.h b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_ds_be.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_ds_be.h
@@ -0,0 +1,378 @@
+
+#ifndef	__VRX518_DS_BE_H_
+#define	__VRX518_DS_BE_H_
+
+		typedef	struct {
+
+				unsigned int _res0:31;
+				unsigned int module_unload:1;
+
+		}	mode_switch_t;
+
+		typedef	struct {
+
+				unsigned int des_deq_cnt;
+
+				unsigned int tx_in_aca_msg_ptr;
+
+				unsigned int tx_out_aca_accum_cnt;
+
+				unsigned int tx_out_aca_wr_ptr;
+
+				unsigned int tx_out_aca_rd_ptr;
+
+				unsigned int tx_out_aca_msg_ptr;
+
+				unsigned int tx_out_aca_status_ptr;
+
+				unsigned int _dw_res0;
+
+		}	us_aca_cfg_ctxt_t;
+
+		typedef	struct {
+
+				unsigned int des_enq_cnt;
+
+				unsigned int rx_in_aca_msg_ptr;
+
+				unsigned int rx_in_aca_status_ptr;
+
+				unsigned int rx_in_aca_accum_cnt;
+
+				unsigned int rx_in_aca_wr_ptr;
+
+				unsigned int rx_out_aca_msg_ptr;
+
+				unsigned int rx_out_aca_status_ptr;
+
+				unsigned int _dw_res0;
+
+		}	ds_aca_cfg_ctxt_t;
+
+		typedef	struct {
+
+				unsigned int ctxt_ptr:16;
+				unsigned int transfer_type:4;
+				unsigned int _res0:7;
+				unsigned int rie:1;
+				unsigned int lie:1;
+				unsigned int llp:1;
+				unsigned int tcb:1;
+				unsigned int cb:1;
+
+				unsigned int transfer_size;
+
+				unsigned int sar_low;
+
+				unsigned int sar_high;
+
+				unsigned int dar_low;
+
+				unsigned int dar_high;
+
+		}	edma_lle_t;
+
+		typedef	struct {
+
+				unsigned int srcq_ctxt_ptr:16;
+				unsigned int src_des_ptr:16;
+
+				unsigned int dstq_ctxt_ptr:16;
+				unsigned int dst_des_ptr:16;
+
+				unsigned int src_des_bp_ptr:16;
+				unsigned int dst_des_bp_ptr:16;
+
+				unsigned int ctxt_ptr:16;
+				unsigned int transfer_type:4;
+				unsigned int _res0:4;
+				unsigned int des_sync_size:8;
+
+				unsigned int _dw_res0[2];
+
+		}	edma_lle_ext_t;
+
+		typedef	struct {
+
+				unsigned int sync_type:1;
+				unsigned int us_des_polling_needed:1;
+				unsigned int running_cnt:4;
+				unsigned int polling_intv:4;
+				unsigned int max_polling_intv:4;
+				unsigned int _res0:1;
+				unsigned int soc_des_own_val:1;
+				unsigned int desq_cfg_ctxt:16;
+
+				unsigned int sync_rd_status:3;
+				unsigned int sync_rd_size:13;
+				unsigned int sync_rd_idx:16;
+
+				unsigned int rd_cmd_sar;
+
+				unsigned int rd_cmd_dar;
+
+				unsigned int sync_wr_status:3;
+				unsigned int sync_wr_size:13;
+				unsigned int sync_wr_idx:16;
+
+				unsigned int wr_cmd_sar;
+
+				unsigned int wr_cmd_dar;
+
+				unsigned int ext_desc_base_addr;
+
+				unsigned int ext_bp_des_base_addr;
+
+				unsigned int _dw_res0;
+
+				unsigned int cdma_dst_des_dw0;
+
+				unsigned int cdma_dst_des_dw1;
+
+				unsigned int sync_rd_cmd_cnt;
+
+				unsigned int sync_wr_cmd_cnt;
+
+				unsigned int sync_rd_cnt;
+
+				unsigned int sync_wr_cnt;
+
+				unsigned int rd_des_buf[16];
+
+		}	des_sync_cfg_ctxt_t;
+
+		typedef	struct {
+
+				unsigned int des_idx:8;
+				unsigned int _res0:3;
+				unsigned int dir:1;
+				unsigned int _res1:2;
+				unsigned int state:1;
+				unsigned int sync_type:1;
+				unsigned int desq_cfg_ctxt:16;
+
+				unsigned int soc_sync_addr;
+
+				unsigned int enq_pkt_cnt;
+
+				unsigned int deq_pkt_cnt;
+
+				unsigned int cdma_tx_des_dw0;
+
+				unsigned int cdma_tx_des_dw1;
+
+				unsigned int cdma_rx_des_dw0;
+
+				unsigned int cdma_rx_des_dw1;
+
+		}	bond_des_sync_cfg_ctxt_t;
+
+		typedef	struct {
+
+				unsigned int edma_ch_type:1;
+				unsigned int edma_pcs:1;
+				unsigned int edma_lle_num:6;
+				unsigned int edma_lle_sb_size:8;
+				unsigned int edma_lle_sb_base:16;
+
+				unsigned int edma_lle_ext_sb_base:16;
+				unsigned int fw_pp_idx:8;
+				unsigned int fw_wr_idx:8;
+
+				unsigned int edma_lle_fpi_base;
+
+				unsigned int edma_rd_idx:8;
+				unsigned int fw_pp_cnt:8;
+				unsigned int edma_rd_cnt:8;
+				unsigned int fw_wr_cnt:8;
+
+				unsigned int edma_extra_db_cnt:24;
+				unsigned int edma_zero_complete_cnt:4;
+				unsigned int _res0:2;
+				unsigned int edma_ch_status:2;
+
+				unsigned int edma_lle_pending_cnt;
+
+				unsigned int edma_lle_pending_wr_ptr;
+
+				unsigned int edma_lle_pending_wr_dw0;
+
+		}	edma_ch_ctxt_t;
+
+		typedef	struct {
+
+				unsigned int srcq_ctxt_ptr:16;
+				unsigned int dstq_ctxt_ptr:16;
+
+		}	edma_copy_ch_cfg_t;
+
+		typedef	struct {
+
+				unsigned int _res0:29;
+				unsigned int ch_id:1;
+				unsigned int state:2;
+
+				unsigned int _dw_res0;
+
+				unsigned int wch_idx_write_pdma_cmd0;
+
+				unsigned int wch_idx_write_pdma_cmd1;
+
+				unsigned int wch_ll_ptr_read_pdma_cmd0;
+
+				unsigned int wch_ll_ptr_read_pdma_cmd1;
+
+				unsigned int rch_idx_write_pdma_cmd0;
+
+				unsigned int rch_idx_write_pdma_cmd1;
+
+				unsigned int rch_ll_ptr_read_pdma_cmd0;
+
+				unsigned int rch_ll_ptr_read_pdma_cmd1;
+
+				unsigned int pdma_bc3_rd_cmd_issue_cnt;
+
+				unsigned int pdma_bc3_rd_cmd_finish_cnt;
+
+				unsigned int _dw_res1[4];
+
+		}	edma_rd_cnt_sm_t;
+
+		typedef	struct {
+
+				unsigned int pp32_core_id:2;
+				unsigned int us_segment_en:1;
+				unsigned int us_buf_release_en:1;
+				unsigned int profiling_en:1;
+				unsigned int event_monitor_en:1;
+				unsigned int _res0:2;
+				unsigned int ds_bonding_master:1;
+				unsigned int ds_pkt_dispatch_en:1;
+				unsigned int ds_pkt_reconstruct_en:1;
+				unsigned int ds_pkt_flush_en:1;
+				unsigned int us_bonding_master:1;
+				unsigned int _res1:1;
+				unsigned int us_bonding_des_sync:1;
+				unsigned int ds_bonding_des_sync:1;
+				unsigned int tc_us_en:1;
+				unsigned int tc_ds_en:1;
+				unsigned int _res2:5;
+				unsigned int des_sync_en:1;
+				unsigned int edma_write_cnt_update_en:1;
+				unsigned int edma_read_cnt_update_en:1;
+				unsigned int edma_write_lle_gen_en:1;
+				unsigned int edma_read_lle_gen_en:1;
+				unsigned int edma_post_proc_en:1;
+				unsigned int qos_wfq_shaping_en:1;
+				unsigned int qos_dispatch_en:1;
+				unsigned int qos_replenish_en:1;
+
+		}	task_cfg_t;
+
+		typedef	struct {
+
+				unsigned int enter_time;
+
+				unsigned int total_call_num;
+
+				unsigned int idle_call_num;
+
+				unsigned int working_call_num;
+
+				unsigned int idle_call_time_hi;
+
+				unsigned int idle_call_time_lo;
+
+				unsigned int working_call_time_hi;
+
+				unsigned int working_call_time_lo;
+
+		}	module_perf_statistics_t;
+
+		typedef	struct {
+
+				unsigned int _res0:12;
+				unsigned int pp32_1_main_loop:1;
+				unsigned int pp32_0_main_loop:1;
+				unsigned int _res1:1;
+				unsigned int ds_bonding_flush:1;
+				unsigned int ds_bonding_pkt_reconst:1;
+				unsigned int ds_bonding_pkt_dispatch:1;
+				unsigned int ds_bonding_link_state_check:1;
+				unsigned int us_bonding_buf_release:1;
+				unsigned int us_bonding_segment:1;
+				unsigned int tc_update_link_state:1;
+				unsigned int tc_rx_fifo_proc:1;
+				unsigned int tc_rx_main:1;
+				unsigned int tc_tx_main:1;
+				unsigned int edma_rd_cnt_update:1;
+				unsigned int edma_rwch_pp:1;
+				unsigned int edma_wch_lle_prod:1;
+				unsigned int edma_rch_lle_prod:1;
+				unsigned int us_wfq_shaping:1;
+				unsigned int us_qos_dispatch:1;
+				unsigned int des_sync:1;
+
+		}	module_index_t;
+
+		typedef	struct {
+
+				unsigned int srcq_ctxt_ptr:16;
+				unsigned int dstq_ctxt_ptr:16;
+
+		}	cdma_copy_ch_cfg_t;
+
+		typedef	struct {
+
+				unsigned int _res0:8;
+				unsigned int cdma_num:8;
+				unsigned int cdma_tx_sb_base:16;
+
+				unsigned int cdma_ext_sb_base:16;
+				unsigned int fw_ext_idx:8;
+				unsigned int fw_cdma_idx:8;
+
+				unsigned int _res1:16;
+				unsigned int cdma_rx_sb_base:16;
+
+				unsigned int _dw_res0[5];
+
+		}	cdma_ch_ctxt_t;
+
+		typedef	struct {
+
+				unsigned int srcq_ctxt_ptr:16;
+				unsigned int src_des_ptr:16;
+
+				unsigned int dstq_ctxt_ptr:16;
+				unsigned int dst_des_ptr:16;
+
+				unsigned int _dw_res0[2];
+
+		}	cdma_ext_t;
+
+		typedef	struct {
+
+				unsigned int _res0:31;
+				unsigned int grx500:1;
+
+		}	soc_family_t;
+
+		typedef struct {
+			/*  0h  */
+			unsigned int res0:16;
+			unsigned int same_vc_qmap:16;
+			/*  1h  */
+			unsigned int uu:8;
+			unsigned int cpi:8;
+			unsigned int res1:9;
+			unsigned int sbid:1;
+			unsigned int qsb_vcid:4;
+			unsigned int mpoa_mode:1;
+			unsigned int qsben:1;
+			/*  2h  */
+			unsigned int atm_header:32;
+		} wtx_queue_config_t;
+
+#endif
+
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_ppe_fw.h b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_ppe_fw.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/fw/vrx518_ppe_fw.h
@@ -0,0 +1,13 @@
+#ifndef	VRX518_PPE_FW_H
+#define	VRX518_PPE_FW_H
+
+#define	PPE_FW_COMPATIBILITY_ID	0x00000004	/* Define	all	4	bytes	*/
+#define	HEADER_LENGTH						0x00000010	/* Define	all	4	bytes	*/
+
+#define	NUM_FW									0x00000004	/* Define	all	4	bytes	*/
+#define	TC_TX_FW_NUM						0x00000000	/* Define	all	4	bytes	*/
+#define	BONDING_FW_NUM					0x00000001	/* Define	all	4	bytes	*/
+#define	TC_RX_FW_NUM						0x00000002	/* Define	all	4	bytes	*/
+#define	ATM_FW_NUM							0x00000003	/* Define	all	4	bytes	*/
+
+#endif
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/platform.h b/drivers/net/ethernet/intel/vrx518/tc/inc/platform.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/platform.h
@@ -0,0 +1,29 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+extern size_t plat_priv_sz(void);
+extern int platform_init(struct tc_priv *, const char *);
+extern void platform_exit(void);
+extern void simu_tc_request(const u8, int);
+extern void platform_dsl_exit(void);
+
+
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/prograte.h b/drivers/net/ethernet/intel/vrx518/tc/inc/prograte.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/prograte.h
@@ -0,0 +1,730 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#ifndef __PROG_RATE_H
+#define __PROG_RATE_H
+
+#define ME_DBG_RD 0
+#define ME_DBG_WR 1
+
+#define NUM_ME_VAR 697
+static struct me_cfg_def dfe_cfg_seq[] = {
+{0x00000020, 0x00000001, ME_DBG_WR},
+{0x00000024, 0x00000001, ME_DBG_WR},
+{0x00000028, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000542e8, ME_DBG_WR},
+{0x00000034, 0x00000001, ME_DBG_WR},
+{0x00000030, 0x000542ec, ME_DBG_WR},
+{0x00000034, 0x000050bd, ME_DBG_WR},
+{0x00000030, 0x000542f4, ME_DBG_WR},
+{0x00000034, 0x43b78b12, ME_DBG_WR},
+{0x00000030, 0x000542f8, ME_DBG_WR},
+{0x00000034, 0x11110000, ME_DBG_WR},
+{0x00000030, 0x000542fc, ME_DBG_WR},
+{0x00000034, 0x4856af00, ME_DBG_WR},
+{0x00000030, 0x00054300, ME_DBG_WR},
+{0x00000034, 0x00100005, ME_DBG_WR},
+{0x00000030, 0x00054304, ME_DBG_WR},
+{0x00000034, 0x01029d9f, ME_DBG_WR},
+{0x00000030, 0x00054308, ME_DBG_WR},
+{0x00000034, 0x000d0123, ME_DBG_WR},
+{0x00000030, 0x0005430c, ME_DBG_WR},
+{0x00000034, 0x01000002, ME_DBG_WR},
+{0x00000030, 0x00054310, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054314, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054318, ME_DBG_WR},
+{0x00000034, 0x00000050, ME_DBG_WR},
+{0x00000030, 0x0005431c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054320, ME_DBG_WR},
+{0x00000034, 0x0000008e, ME_DBG_WR},
+{0x00000030, 0x00054324, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054328, ME_DBG_WR},
+{0x00000034, 0x00795d50, ME_DBG_WR},
+{0x00000030, 0x0005432c, ME_DBG_WR},
+{0x00000034, 0x00c99b4a, ME_DBG_WR},
+{0x00000030, 0x00054330, ME_DBG_WR},
+{0x00000034, 0x00000002, ME_DBG_WR},
+{0x00000030, 0x00054334, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054338, ME_DBG_WR},
+{0x00000034, 0x00420000, ME_DBG_WR},
+{0x00000030, 0x0005433c, ME_DBG_WR},
+{0x00000034, 0x00000016, ME_DBG_WR},
+{0x00000030, 0x00054340, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054344, ME_DBG_WR},
+{0x00000034, 0x17ae0012, ME_DBG_WR},
+{0x00000030, 0x00054348, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005434c, ME_DBG_WR},
+{0x00000034, 0x883b39c1, ME_DBG_WR},
+{0x00000030, 0x00054350, ME_DBG_WR},
+{0x00000034, 0xd674a488, ME_DBG_WR},
+{0x00000030, 0x00054354, ME_DBG_WR},
+{0x00000034, 0x000053fd, ME_DBG_WR},
+{0x00000030, 0x00054358, ME_DBG_WR},
+{0x00000034, 0x0000540d, ME_DBG_WR},
+{0x00000030, 0x0005435c, ME_DBG_WR},
+{0x00000034, 0x03fd4bf4, ME_DBG_WR},
+{0x00000030, 0x00054360, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054364, ME_DBG_WR},
+{0x00000034, 0x000000a5, ME_DBG_WR},
+{0x00000030, 0x00054368, ME_DBG_WR},
+{0x00000034, 0x03fd4cf4, ME_DBG_WR},
+{0x00000030, 0x0005436c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054370, ME_DBG_WR},
+{0x00000034, 0x000000a5, ME_DBG_WR},
+{0x00000030, 0x00054374, ME_DBG_WR},
+{0x00000034, 0x03fd4df4, ME_DBG_WR},
+{0x00000030, 0x00054378, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005437c, ME_DBG_WR},
+{0x00000034, 0x000000a5, ME_DBG_WR},
+{0x00000030, 0x00054380, ME_DBG_WR},
+{0x00000034, 0x03fd4ef4, ME_DBG_WR},
+{0x00000030, 0x00054384, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054388, ME_DBG_WR},
+{0x00000034, 0x010000a5, ME_DBG_WR},
+{0x00000030, 0x0005438c, ME_DBG_WR},
+{0x00000034, 0x00010011, ME_DBG_WR},
+{0x00000030, 0x00054390, ME_DBG_WR},
+{0x00000034, 0x01193505, ME_DBG_WR},
+{0x00000030, 0x00054394, ME_DBG_WR},
+{0x00000034, 0x00007c10, ME_DBG_WR},
+{0x00000030, 0x00054398, ME_DBG_WR},
+{0x00000034, 0x000003ba, ME_DBG_WR},
+{0x00000030, 0x0005439c, ME_DBG_WR},
+{0x00000034, 0x00000035, ME_DBG_WR},
+{0x00000030, 0x000543a0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543a4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543a8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543ac, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543b0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543b4, ME_DBG_WR},
+{0x00000034, 0x01013501, ME_DBG_WR},
+{0x00000030, 0x000543b8, ME_DBG_WR},
+{0x00000034, 0x00007fcc, ME_DBG_WR},
+{0x00000030, 0x000543bc, ME_DBG_WR},
+{0x00000034, 0xfc382855, ME_DBG_WR},
+{0x00000030, 0x000543c0, ME_DBG_WR},
+{0x00000034, 0x8d577dd7, ME_DBG_WR},
+{0x00000030, 0x000543c4, ME_DBG_WR},
+{0x00000034, 0x04906540, ME_DBG_WR},
+{0x00000030, 0x000543c8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543cc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543d0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543d4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543d8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543dc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543e0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543e4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543e8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543ec, ME_DBG_WR},
+{0x00000034, 0x00000003, ME_DBG_WR},
+{0x00000030, 0x000543f0, ME_DBG_WR},
+{0x00000034, 0x51c951bd, ME_DBG_WR},
+{0x00000030, 0x000543f4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543f8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000543fc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054400, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054404, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054408, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005440c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054410, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054414, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054418, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005441c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054420, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054424, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054428, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005442c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054430, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054434, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054438, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005443c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054440, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054444, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054448, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005444c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054450, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054454, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054458, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005445c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054460, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054464, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054468, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005446c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054470, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054474, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054478, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005447c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054480, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054484, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054488, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005448c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054490, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054494, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x00054498, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005449c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544a0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544a4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544a8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544ac, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544b0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544b4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544b8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544bc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544c0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544c4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544c8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000544cc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b940, ME_DBG_WR},
+{0x00000034, 0x00000001, ME_DBG_WR},
+{0x00000030, 0x0005b944, ME_DBG_WR},
+{0x00000034, 0x00006e53, ME_DBG_WR},
+{0x00000030, 0x0005b94c, ME_DBG_WR},
+{0x00000034, 0x43b78b12, ME_DBG_WR},
+{0x00000030, 0x0005b950, ME_DBG_WR},
+{0x00000034, 0x11110000, ME_DBG_WR},
+{0x00000030, 0x0005b954, ME_DBG_WR},
+{0x00000034, 0x48560010, ME_DBG_WR},
+{0x00000030, 0x0005b958, ME_DBG_WR},
+{0x00000034, 0x00100005, ME_DBG_WR},
+{0x00000030, 0x0005b95c, ME_DBG_WR},
+{0x00000034, 0x01029d9f, ME_DBG_WR},
+{0x00000030, 0x0005b960, ME_DBG_WR},
+{0x00000034, 0x000d0123, ME_DBG_WR},
+{0x00000030, 0x0005b964, ME_DBG_WR},
+{0x00000034, 0x01000002, ME_DBG_WR},
+{0x00000030, 0x0005b968, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b96c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b970, ME_DBG_WR},
+{0x00000034, 0x00000054, ME_DBG_WR},
+{0x00000030, 0x0005b974, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b978, ME_DBG_WR},
+{0x00000034, 0x0000008e, ME_DBG_WR},
+{0x00000030, 0x0005b97c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b980, ME_DBG_WR},
+{0x00000034, 0x00795d50, ME_DBG_WR},
+{0x00000030, 0x0005b984, ME_DBG_WR},
+{0x00000034, 0x00c99b4a, ME_DBG_WR},
+{0x00000030, 0x0005b988, ME_DBG_WR},
+{0x00000034, 0x00000002, ME_DBG_WR},
+{0x00000030, 0x0005b98c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b990, ME_DBG_WR},
+{0x00000034, 0x00420000, ME_DBG_WR},
+{0x00000030, 0x0005b994, ME_DBG_WR},
+{0x00000034, 0x00000016, ME_DBG_WR},
+{0x00000030, 0x0005b998, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b99c, ME_DBG_WR},
+{0x00000034, 0x17ae0012, ME_DBG_WR},
+{0x00000030, 0x0005b9a0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9a4, ME_DBG_WR},
+{0x00000034, 0x00016ca0, ME_DBG_WR},
+{0x00000030, 0x0005b9a8, ME_DBG_WR},
+{0x00000034, 0xd674a488, ME_DBG_WR},
+{0x00000030, 0x0005b9ac, ME_DBG_WR},
+{0x00000034, 0x00007193, ME_DBG_WR},
+{0x00000030, 0x0005b9b0, ME_DBG_WR},
+{0x00000034, 0x000071a3, ME_DBG_WR},
+{0x00000030, 0x0005b9b4, ME_DBG_WR},
+{0x00000034, 0x3ffdc24c, ME_DBG_WR},
+{0x00000030, 0x0005b9b8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9bc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9c0, ME_DBG_WR},
+{0x00000034, 0x3ffdc34c, ME_DBG_WR},
+{0x00000030, 0x0005b9c4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9c8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9cc, ME_DBG_WR},
+{0x00000034, 0x3ffdc44c, ME_DBG_WR},
+{0x00000030, 0x0005b9d0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9d4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9d8, ME_DBG_WR},
+{0x00000034, 0x3ffdc54c, ME_DBG_WR},
+{0x00000030, 0x0005b9dc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9e0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9e4, ME_DBG_WR},
+{0x00000034, 0x00010011, ME_DBG_WR},
+{0x00000030, 0x0005b9e8, ME_DBG_WR},
+{0x00000034, 0x01193501, ME_DBG_WR},
+{0x00000030, 0x0005b9ec, ME_DBG_WR},
+{0x00000034, 0x00016ca0, ME_DBG_WR},
+{0x00000030, 0x0005b9f0, ME_DBG_WR},
+{0x00000034, 0x00000424, ME_DBG_WR},
+{0x00000030, 0x0005b9f4, ME_DBG_WR},
+{0x00000034, 0x0003ffff, ME_DBG_WR},
+{0x00000030, 0x0005b9f8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005b9fc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba00, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba04, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba08, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba0c, ME_DBG_WR},
+{0x00000034, 0x01013505, ME_DBG_WR},
+{0x00000030, 0x0005ba10, ME_DBG_WR},
+{0x00000034, 0x000170c4, ME_DBG_WR},
+{0x00000030, 0x0005ba14, ME_DBG_WR},
+{0x00000034, 0x59ff2c4b, ME_DBG_WR},
+{0x00000030, 0x0005ba18, ME_DBG_WR},
+{0x00000034, 0xe849da6d, ME_DBG_WR},
+{0x00000030, 0x0005ba1c, ME_DBG_WR},
+{0x00000034, 0xb8de14a9, ME_DBG_WR},
+{0x00000030, 0x0005ba20, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba24, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba28, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba2c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba30, ME_DBG_WR},
+{0x00000034, 0x00000088, ME_DBG_WR},
+{0x00000030, 0x0005ba34, ME_DBG_WR},
+{0x00000034, 0x000001a8, ME_DBG_WR},
+{0x00000030, 0x0005ba38, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba3c, ME_DBG_WR},
+{0x00000034, 0x11000000, ME_DBG_WR},
+{0x00000030, 0x0005ba40, ME_DBG_WR},
+{0x00000034, 0x000082a8, ME_DBG_WR},
+{0x00000030, 0x0005ba44, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba48, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba4c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba50, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba54, ME_DBG_WR},
+{0x00000034, 0x84044000, ME_DBG_WR},
+{0x00000030, 0x0005ba58, ME_DBG_WR},
+{0x00000034, 0x00000ffe, ME_DBG_WR},
+{0x00000030, 0x0005ba5c, ME_DBG_WR},
+{0x00000034, 0x00000004, ME_DBG_WR},
+{0x00000030, 0x0005ba60, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba64, ME_DBG_WR},
+{0x00000034, 0x00006f53, ME_DBG_WR},
+{0x00000030, 0x0005ba68, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba6c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba70, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba74, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba78, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba7c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba80, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba84, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba88, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba8c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba90, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba94, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba98, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005ba9c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baa0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baa4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baa8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baac, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bab0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bab4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bab8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005babc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bac0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bac4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bac8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bacc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bad0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bad4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bad8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005badc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bae0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bae4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bae8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baec, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baf0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baf4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005baf8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bafc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb00, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb04, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb08, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb0c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb10, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb14, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb18, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb1c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb20, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb24, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb28, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb2c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb30, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb34, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb38, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0005bb3c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020d9ec, ME_DBG_WR},
+{0x00000034, 0x00000001, ME_DBG_WR},
+{0x00000030, 0x0020d9f4, ME_DBG_WR},
+{0x00000034, 0x000050ba, ME_DBG_WR},
+{0x00000030, 0x0020d9f8, ME_DBG_WR},
+{0x00000034, 0x00001055, ME_DBG_WR},
+{0x00000030, 0x0020d9fc, ME_DBG_WR},
+{0x00000034, 0x00001055, ME_DBG_WR},
+{0x00000030, 0x0020da00, ME_DBG_WR},
+{0x00000034, 0x07ae0012, ME_DBG_WR},
+{0x00000030, 0x0020da04, ME_DBG_WR},
+{0x00000034, 0x00000a66, ME_DBG_WR},
+{0x00000030, 0x0020da08, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020da0c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020da10, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020da14, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020de38, ME_DBG_WR},
+{0x00000034, 0x00006e50, ME_DBG_WR},
+{0x00000030, 0x0020de3c, ME_DBG_WR},
+{0x00000034, 0x00001055, ME_DBG_WR},
+{0x00000030, 0x0020de40, ME_DBG_WR},
+{0x00000034, 0x00001055, ME_DBG_WR},
+{0x00000030, 0x0020de44, ME_DBG_WR},
+{0x00000034, 0x07ae0012, ME_DBG_WR},
+{0x00000030, 0x0020de48, ME_DBG_WR},
+{0x00000034, 0x00000a66, ME_DBG_WR},
+{0x00000030, 0x0020de4c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020de50, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020de54, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020de58, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020de5c, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x000546f4, ME_DBG_WR},
+{0x00000034, 0x6c1ac016, ME_DBG_WR},
+{0x00000030, 0x000546f8, ME_DBG_WR},
+{0x00000034, 0x405a0800, ME_DBG_WR},
+{0x00000030, 0x000546fc, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x00054700, ME_DBG_WR},
+{0x00000034, 0x40580800, ME_DBG_WR},
+{0x00000030, 0x00054704, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x00054708, ME_DBG_WR},
+{0x00000034, 0x80000c14, ME_DBG_WR},
+{0x00000030, 0x0005470c, ME_DBG_WR},
+{0x00000034, 0x80000c0c, ME_DBG_WR},
+{0x00000030, 0x00054710, ME_DBG_WR},
+{0x00000034, 0x80000c16, ME_DBG_WR},
+{0x00000030, 0x00054714, ME_DBG_WR},
+{0x00000034, 0x80000c0e, ME_DBG_WR},
+{0x00000030, 0x00054718, ME_DBG_WR},
+{0x00000034, 0x40320000, ME_DBG_WR},
+{0x00000030, 0x0005471c, ME_DBG_WR},
+{0x00000034, 0x00004000, ME_DBG_WR},
+{0x00000030, 0x00054720, ME_DBG_WR},
+{0x00000034, 0x40020000, ME_DBG_WR},
+{0x00000030, 0x00054724, ME_DBG_WR},
+{0x00000034, 0x6c16e000, ME_DBG_WR},
+{0x00000030, 0x00054728, ME_DBG_WR},
+{0x00000034, 0x405a0800, ME_DBG_WR},
+{0x00000030, 0x0005472c, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x00054730, ME_DBG_WR},
+{0x00000034, 0x40580800, ME_DBG_WR},
+{0x00000030, 0x00054734, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x00054738, ME_DBG_WR},
+{0x00000034, 0x80030c14, ME_DBG_WR},
+{0x00000030, 0x0005473c, ME_DBG_WR},
+{0x00000034, 0x80030c0c, ME_DBG_WR},
+{0x00000030, 0x00054740, ME_DBG_WR},
+{0x00000034, 0x80032c16, ME_DBG_WR},
+{0x00000030, 0x00054744, ME_DBG_WR},
+{0x00000034, 0x80032c0e, ME_DBG_WR},
+{0x00000030, 0x00054748, ME_DBG_WR},
+{0x00000034, 0x40320000, ME_DBG_WR},
+{0x00000030, 0x0005474c, ME_DBG_WR},
+{0x00000034, 0x40020000, ME_DBG_WR},
+{0x00000030, 0x00055474, ME_DBG_WR},
+{0x00000034, 0x00004000, ME_DBG_WR},
+{0x00000030, 0x00055478, ME_DBG_WR},
+{0x00000034, 0x40020000, ME_DBG_WR},
+{0x00000030, 0x0005bd4c, ME_DBG_WR},
+{0x00000034, 0x6c16c01a, ME_DBG_WR},
+{0x00000030, 0x0005bd50, ME_DBG_WR},
+{0x00000034, 0x405a0800, ME_DBG_WR},
+{0x00000030, 0x0005bd54, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x0005bd58, ME_DBG_WR},
+{0x00000034, 0x40580800, ME_DBG_WR},
+{0x00000030, 0x0005bd5c, ME_DBG_WR},
+{0x00000034, 0x40a20000, ME_DBG_WR},
+{0x00000030, 0x0005bd60, ME_DBG_WR},
+{0x00000034, 0x80030c14, ME_DBG_WR},
+{0x00000030, 0x0005bd64, ME_DBG_WR},
+{0x00000034, 0x80031c0c, ME_DBG_WR},
+{0x00000030, 0x0005bd68, ME_DBG_WR},
+{0x00000034, 0x80032c16, ME_DBG_WR},
+{0x00000030, 0x0005bd6c, ME_DBG_WR},
+{0x00000034, 0x80033c0e, ME_DBG_WR},
+{0x00000030, 0x0005bd70, ME_DBG_WR},
+{0x00000034, 0x40320000, ME_DBG_WR},
+{0x00000030, 0x0005bd74, ME_DBG_WR},
+{0x00000034, 0x00004000, ME_DBG_WR},
+{0x00000030, 0x0005bd78, ME_DBG_WR},
+{0x00000034, 0x40020000, ME_DBG_WR},
+{0x00000030, 0x0005cacc, ME_DBG_WR},
+{0x00000034, 0x00004000, ME_DBG_WR},
+{0x00000030, 0x0005cad0, ME_DBG_WR},
+{0x00000034, 0x40020000, ME_DBG_WR},
+{0x00000030, 0x0020c400, ME_DBG_WR},
+{0x00000034, 0x0000003c, ME_DBG_WR},
+{0x00000030, 0x0020c404, ME_DBG_WR},
+{0x00000034, 0x00000014, ME_DBG_WR},
+{0x00000030, 0x0020c408, ME_DBG_WR},
+{0x00000034, 0x00000004, ME_DBG_WR},
+{0x00000030, 0x0020c40c, ME_DBG_WR},
+{0x00000034, 0x0007ffe1, ME_DBG_WR},
+{0x00000030, 0x0020c414, ME_DBG_WR},
+{0x00000034, 0x0cd2ac05, ME_DBG_WR},
+{0x00000030, 0x0020c424, ME_DBG_WR},
+{0x00000034, 0x1a0009e8, ME_DBG_WR},
+{0x00000030, 0x0020c434, ME_DBG_WR},
+{0x00000034, 0x34000000, ME_DBG_WR},
+{0x00000030, 0x0020c444, ME_DBG_WR},
+{0x00000034, 0x32000000, ME_DBG_WR},
+{0x00000030, 0x0020c474, ME_DBG_WR},
+{0x00000034, 0x04000040, ME_DBG_WR},
+{0x00000030, 0x0020c478, ME_DBG_WR},
+{0x00000034, 0x00000806, ME_DBG_WR},
+{0x00000030, 0x0020c47c, ME_DBG_WR},
+{0x00000034, 0x00000040, ME_DBG_WR},
+{0x00000030, 0x0020c480, ME_DBG_WR},
+{0x00000034, 0x00004800, ME_DBG_WR},
+{0x00000030, 0x0020c48c, ME_DBG_WR},
+{0x00000034, 0x04000040, ME_DBG_WR},
+{0x00000030, 0x0020c490, ME_DBG_WR},
+{0x00000034, 0x00000806, ME_DBG_WR},
+{0x00000030, 0x0020c494, ME_DBG_WR},
+{0x00000034, 0x00000040, ME_DBG_WR},
+{0x00000030, 0x0020c498, ME_DBG_WR},
+{0x00000034, 0x00004800, ME_DBG_WR},
+{0x0000002c, 0x0020c4a8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_RD},
+{0x00000030, 0x0020c4a8, ME_DBG_WR},
+{0x00000034, 0x00421a54, ME_DBG_WR},
+{0x0000002c, 0x0020c4b0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_RD},
+{0x00000030, 0x0020c4b0, ME_DBG_WR},
+{0x00000034, 0x101a09ec, ME_DBG_WR},
+{0x00000030, 0x0020c4b4, ME_DBG_WR},
+{0x00000034, 0x00400000, ME_DBG_WR},
+{0x00000030, 0x0020c4b8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4bc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4c0, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4c4, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4c8, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4cc, ME_DBG_WR},
+{0x00000034, 0x00000000, ME_DBG_WR},
+{0x00000030, 0x0020c4d0, ME_DBG_WR},
+{0x00000034, 0x00400000, ME_DBG_WR},
+{0x00000030, 0x0020c4d4, ME_DBG_WR},
+{0x00000034, 0x00014416, ME_DBG_WR},
+{0x00000030, 0x0020c4d8, ME_DBG_WR},
+{0x00000034, 0x0000a4d0, ME_DBG_WR},
+{0x00000030, 0x0020c4dc, ME_DBG_WR},
+{0x00000034, 0x0090deda, ME_DBG_WR},
+{0x00000030, 0x0020c4e0, ME_DBG_WR},
+{0x00000034, 0x00014d3a, ME_DBG_WR},
+{0x00000030, 0x0020c4e4, ME_DBG_WR},
+{0x00000034, 0x000bf21e, ME_DBG_WR},
+{0x00000030, 0x0020c4ec, ME_DBG_WR},
+{0x00000034, 0xb9ec4000, ME_DBG_WR},
+{0x00000030, 0x0020c4f0, ME_DBG_WR},
+{0x00000034, 0x99a376e5, ME_DBG_WR},
+{0x00000030, 0x0020c4f4, ME_DBG_WR},
+{0x00000034, 0x0013969e, ME_DBG_WR},
+{0x00000030, 0x0020c4f8, ME_DBG_WR},
+{0x00000034, 0x33900000, ME_DBG_WR},
+{0x00000030, 0x0020c4fc, ME_DBG_WR},
+{0x00000034, 0xc8078407, ME_DBG_WR},
+{0x00000030, 0x0020c500, ME_DBG_WR},
+{0x00000034, 0x30f00000, ME_DBG_WR},
+{0x00000030, 0x0020c504, ME_DBG_WR},
+{0x00000034, 0xc002e029, ME_DBG_WR},
+};
+
+#endif /* __PROG_RATE_H */
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/ptm_tc.h b/drivers/net/ethernet/intel/vrx518/tc/inc/ptm_tc.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/ptm_tc.h
@@ -0,0 +1,148 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#ifndef __PTM_TC_H__
+#define __PTM_TC_H__
+
+#define OUTQ_DESC_PER_Q		32
+#define OUTQ_PNUM		2
+#define OUTQ_DESC_NUM		(OUTQ_DESC_PER_Q * OUTQ_PNUM)
+#define MAX_FRAGQ_NUM		1
+#define BOND_DESC_SZ		1 /* DW Size, struct not open to driver */
+
+#define QOSQ_ID_MASK		((QOSQ_NUM - 1) | ((QOSQ_NUM - 1) >> 1) | \
+				((QOSQ_NUM - 1) >> 2) | ((QOSQ_NUM - 1) >> 3))
+#define QOSQ_PORT_SSID		16 /* PORT SHAPER STARD ID */
+#define QOSQ_L3_SHAPER_ID	20 /* All the outqss share one L3 shaper */
+
+#define US_FP_DES_OWN		1
+#define US_OUTQ_DES_OWN		1
+#define US_FRAGQ_DES_OWN	1
+#define US_LOCALQ_DES_OWN	0
+#define DS_LOCALQ_DES_OWN	1
+#define DS_FRAGQ_DES_OWN	0
+#define DS_PKT_DES_OWN		0
+#define ERB_DES_PPE_OWN		1
+#define ERB_FRAG_DES_OWN	1
+
+#define PTM_PRIO_Q_NUM		8
+#define PTM_DESC_QID(qid)	(((qid) & 0xF) << 3)
+#define US_BG_NUM		4
+#define DS_BG_NUM		4
+#define BOND_LL_NUM		9
+#define BOND_LL_DES_NUM		1536
+#define BOND_GIF_NUM		8
+#define DEF_BOND_FRAG_SIZE	512
+#define QOS_DES_NUM		510
+#define ERB_PKT_SIZE		1056
+
+/* SB ADDRESS */
+#define TX_CTRL_K_TABLE(i)		fpi_addr(__CTRL_K_TBL_BASE + (i))
+#define DS_FRAGQ_DES_LIST_BASE(off, i)		\
+	fpi_addr(__DS_FRAGQ_DES_LIST_BASE + (off) + ((i) << 1))
+#define DS_BOND_GIF_LL_DES_BA(i)		\
+	fpi_addr(__DS_BOND_GIF_LL_DES_BA + ((i) << 1))
+#define DES_SYNC_CFG_CTXT(idx)			\
+	fpi_addr(__DES_SYNC_CFG_CTXT + ((idx) * 32))
+#define BOND_US_DES_SYNC_CFG_CTXT(i)		\
+	fpi_addr(__BOND_US_DES_SYNC_CFG_CTXT + ((i) * 8))
+#define INQ_QOS_CFG_BASE(off)		fpi_addr(__INQ_QOS_CFG_BASE + (off))
+#define PSAVE_CFG(x)			(__PSAVE_CFG_TX + (x))
+#define US_BOND_GIF_MIB(i)		fpi_addr(__US_E1_FRAG_Q_FRAG_MIB + (i))
+#define DS_BOND_GIF_MIB(i)		fpi_addr(__DS_BOND_GIF_MIB + ((i) << 4))
+#define DS_BG_MIB(i)			fpi_addr(__DS_BG_MIB + ((i) << 2))
+#define CW_PAGE_SZ			65
+#define FFSM_PNUM			0xA0
+#define SFSM_PNUM			0xF0
+#define SFSM_DBACE			0x6000
+#define SFSM_CBACE			0x7100
+
+enum {
+	US_DMA_PRE_RXCH = 0,
+	US_DMA_PRE_TXCH,
+	US_DMA_NOPRE_RXCH,
+	US_DMA_NOPRE_TXCH,
+	DS_DMA_RXCH,
+	DS_DMA_TXCH
+};
+
+enum {
+	PDBRAM_US,
+	PDBRAM_DS,
+	PDBRAM_ACA_TXOUT,
+	PDBRAM_ACA_RXOUT,
+	PDBRAM_ERB,
+};
+
+struct ptm_hw_mib {
+	unsigned int rx_total_pdu[4];
+	unsigned int rx_crc_err_pdu[4];
+	unsigned int rx_cv_cw_cnt[4];
+	unsigned int rx_bc_overdrop_cnt[2];
+	unsigned int tx_total_pdu[4];
+	unsigned int tx_total_bytes[4];
+};
+
+/* First three parameter should be same as tc_comm structure */
+struct ptm_ep_priv {
+	struct dc_ep_dev *ep;
+	struct tc_priv *tc_priv;
+	u32 ep_id;
+	struct ptm_priv *ptm_tc;
+	struct ptm_hw_mib ptm_mib;
+	struct proc_dir_entry *proc_dir;
+	u32 dfe_rate;
+};
+
+struct ptm_priv {
+	struct tc_priv *tc_priv;
+	u32 ep_id;
+	struct ppe_fw fw;
+	struct net_device *dev;
+	spinlock_t ptm_lock;
+	struct rtnl_link_stats64 stats64;
+	int subif_id;
+	u32 prio_q_map[PTM_PRIO_Q_NUM];
+	u32 outq_map[OUTQ_PNUM];
+	struct completion comp;
+};
+
+enum {
+	US_BOND = 0,
+	DS_BOND = 1,
+	BOND_MAX,
+};
+
+extern int proc_read_ptm_wanmib(struct seq_file *, void *);
+extern ssize_t proc_write_ptm_wanmib(struct file *, const char __user *,
+				size_t, loff_t *);
+extern int ptm_power_saving(struct ptm_ep_priv *, int, int);
+extern int proc_ptm_read_bond(struct seq_file *, void *);
+extern int proc_ptm_read_bondmib(struct seq_file *, void *);
+extern ssize_t proc_ptm_write_bondmib(struct file *, const char __user *,
+				size_t, loff_t *);
+extern void ptm_set_q_preempt(struct ptm_ep_priv *, u32, u32);
+extern u32 ptm_get_q_preempt(struct ptm_ep_priv *, u32);
+
+
+
+#endif /* __PTM_TC_H__ */
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/reg_addr.h b/drivers/net/ethernet/intel/vrx518/tc/inc/reg_addr.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/reg_addr.h
@@ -0,0 +1,551 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#ifndef __REG_ADDR_H__
+#define __REG_ADDR_H__
+
+/**
+ * PPE SB address
+ */
+#define SB_REG_BASE		0x0
+#define SB_REG_END		0xFFF
+#define SB_SEG0_BASE		0x2000
+#define SB_SEG0_END		0x7FFF
+#define SB_SEG1_BASE		0x8000
+#define SB_SEG1_END		0xBFFF
+#define SB_SEG2_BASE		0xF000
+#define SB_SEG2_END		0xF7FF
+
+/**
+ * Note: SB4/7/8 is not real HW Memory.
+ * So it's calculated SB address mapping
+ * but not included in real SEG0/SEG1 size
+ */
+
+/* SB0-SB3, size in bytes */
+#define SB_SEG0_SIZE		(0x4000 << 2)
+/* SB6, 9, 10, 11, (6A,6B,6C,6D), size in bytes */
+#define SB_SEG1_SIZE		(0x4000 << 2)
+
+/**
+ * PPE FPI address
+ */
+#define PPE_BASE		(0x300000)
+#define PPM_CODE_MEM_BASE(x)	(PPE_BASE + (((x) * 0x10000 + 0x1000) << 2))
+#define PPM_DATA_MEM_BASE(x)	(PPE_BASE + (((x) * 0x10000 + 0x4000) << 2))
+#define PPM0_DATA_EXT_BASE	(PPE_BASE + ((0xF000) << 2))
+#define FPI_SB_SEG_BASE(x)	(((x) << 16) + 0x8000)
+#define CDM_SZ(x)		\
+	(((x) == 0 || (x) == 2) ? (0x1000 << 2) : (0x800 << 2))
+#define PPE_SB_ADDR(x, off)	\
+	(PPE_BASE + ((FPI_SB_SEG_BASE(x) + (off)) << 2))
+#define PPE_REG_ADDR(off)	(PPE_BASE + ((0x0D000 + (off)) << 2))
+
+
+/* PPE REG FPI Address */
+#define PPE_FREEZE			PPE_REG_ADDR(0x0)
+#define FREEZE_PP32(n)			\
+	(((n) == 2) ? ((n) << 23) :	\
+	(((n) == 1) ? ((n) << 16) : 1))
+
+#define PP32_RST			PPE_REG_ADDR(0x20)
+#define PPE_CDM				PPE_REG_ADDR(0x0100)
+
+/* RTHA /TTHA REG */
+#define RFBI_CFG			PPE_REG_ADDR(0x0400)
+#define RBA_CFG0			PPE_REG_ADDR(0x0404)
+#define RBA_CFG1			PPE_REG_ADDR(0x0405)
+#define RCA_CFG0			PPE_REG_ADDR(0x0408)
+#define RCA_CFG1			PPE_REG_ADDR(0x0409)
+#define RDES_CFG0			PPE_REG_ADDR(0x040C)
+#define RDES_CFG1			PPE_REG_ADDR(0x040D)
+#define SFSM_STATE0			PPE_REG_ADDR(0x0410)
+#define SFSM_STATE1			PPE_REG_ADDR(0x0411)
+#define SFSM_DBA0			PPE_REG_ADDR(0x0412)
+#define SFSM_DBA1			PPE_REG_ADDR(0x0413)
+#define SFSM_CBA0			PPE_REG_ADDR(0x0414)
+#define SFSM_CBA1			PPE_REG_ADDR(0x0415)
+#define SFSM_CFG0			PPE_REG_ADDR(0x0416)
+#define SFSM_CFG1			PPE_REG_ADDR(0x0417)
+#define SFSM_PGCNT0			PPE_REG_ADDR(0x041C)
+#define SFSM_PGCNT1			PPE_REG_ADDR(0x041D)
+#define FFSM_DBA0			PPE_REG_ADDR(0x0508)
+#define FFSM_DBA1			PPE_REG_ADDR(0x0509)
+#define FFSM_CFG0			PPE_REG_ADDR(0x050A)
+#define FFSM_CFG1			PPE_REG_ADDR(0x050B)
+#define FFSM_IDLE_HEAD_BC0		PPE_REG_ADDR(0x050E)
+#define FFSM_IDLE_HEAD_BC1		PPE_REG_ADDR(0x050F)
+#define FFSM_PGCNT0			PPE_REG_ADDR(0x0514)
+#define FFSM_PGCNT1			PPE_REG_ADDR(0x0515)
+
+#define RBA_CFG(x)			(RBA_CFG0 + ((x) << 2))
+#define RCA_CFG(x)			(RCA_CFG0 + ((x) << 2))
+#define RDES_CFG(x)			(RDES_CFG0 + ((x) << 2))
+#define SFSM_STATE(x)			(SFSM_STATE0 + ((x) << 2))
+#define SFSM_DBA(x)			(SFSM_DBA0 + ((x) << 2))
+#define SFSM_CBA(x)			(SFSM_CBA0 + ((x) << 2))
+#define SFSM_CFG(x)			(SFSM_CFG0 + ((x) << 2))
+#define SFSM_PGCNT(x)			(SFSM_PGCNT0 + ((x) << 2))
+#define FFSM_DBA(x)			(FFSM_DBA0 + ((x) << 2))
+#define FFSM_CFG(x)			(FFSM_CFG0 + ((x) << 2))
+#define FFSM_IDLE_HEAD_BC(x)		(FFSM_IDLE_HEAD_BC0 + ((x) << 2))
+#define FFSM_PGCNT(x)			(FFSM_PGCNT0 + ((x) << 2))
+
+/* SAR REG */
+#define SAR_MODE_CFG			PPE_REG_ADDR(0x080A)
+#define SAR_RX_CMDCNT			PPE_REG_ADDR(0x080B)
+#define SAR_TX_CMDCNT			PPE_REG_ADDR(0x080C)
+#define SAR_RX_CTX_CFG			PPE_REG_ADDR(0x080D)
+#define SAR_TX_CTX_CFG			PPE_REG_ADDR(0x080E)
+#define SAR_TX_CMD_DONE_CNT		PPE_REG_ADDR(0x080F)
+#define SAR_ISR				PPE_REG_ADDR(0x0810)
+#define SAR_IER				PPE_REG_ADDR(0x0811)
+#define SAR_POLY_CFG_SET0		PPE_REG_ADDR(0x0812)
+#define SAR_POLY_CFG_SET1		PPE_REG_ADDR(0x0813)
+#define SAR_POLY_CFG_SET2		PPE_REG_ADDR(0x0814)
+#define SAR_POLY_CFG_SET3		PPE_REG_ADDR(0x0815)
+#define SAR_CRC_SIZE_CFG		PPE_REG_ADDR(0x0816)
+
+/* PDMA/EMA REG */
+#define PDMA_CFG			PPE_REG_ADDR(0x0A00)
+#define PDMA_RX_CMDCNT			PPE_REG_ADDR(0x0A01)
+#define PDMA_TX_CMDCNT			PPE_REG_ADDR(0x0A02)
+#define PDMA_RX_FWDATACNT		PPE_REG_ADDR(0x0A03)
+#define PDMA_TX_FWDATACNT		PPE_REG_ADDR(0x0A04)
+#define PDMA_RX_CTX_CFG			PPE_REG_ADDR(0x0A05)
+#define PDMA_TX_CTX_CFG			PPE_REG_ADDR(0x0A06)
+#define PDMA_RX_MAX_LEN_REG		PPE_REG_ADDR(0x0A07)
+#define PDMA_RX_DELAY_CFG		PPE_REG_ADDR(0x0A08)
+#define PDMA_INT_FIFO_RD		PPE_REG_ADDR(0x0A09)
+#define PDMA_ISR			PPE_REG_ADDR(0x0A0A)
+#define PDMA_IER			PPE_REG_ADDR(0x0A0B)
+#define PDMA_SUBID			PPE_REG_ADDR(0x0A0C)
+#define PDMA_BAR0			PPE_REG_ADDR(0x0A0D)
+#define PDMA_BAR1			PPE_REG_ADDR(0x0A0E)
+#define EMA_CMDCFG			PPE_REG_ADDR(0x0F00)
+#define EMA_DATACFG			PPE_REG_ADDR(0x0F02)
+#define EMA_CMDCNT			PPE_REG_ADDR(0x0A02)
+#define EMA_RX_DATACNT			PPE_REG_ADDR(0x0A03)
+#define EMA_TX_DATACNT			PPE_REG_ADDR(0x0A04)
+#define EMA_IER				PPE_REG_ADDR(0x0A05)
+#define EMA_CFG				PPE_REG_ADDR(0x0A06)
+#define EMA_SUBID			PPE_REG_ADDR(0x0A07)
+
+/* PPE TC Logic REG (partial) */
+#define DREG_A_VERSION			PPE_REG_ADDR(0x0D00)
+#define DREG_A_CFG			PPE_REG_ADDR(0x0D01)
+#define DREG_AT_CTRL			PPE_REG_ADDR(0x0D02)
+#define DREG_AT_CB_CFG0			PPE_REG_ADDR(0x0D03)
+#define DREG_AT_CB_CFG1			PPE_REG_ADDR(0x0D04)
+#define DREG_AR_CTRL			PPE_REG_ADDR(0x0D08)
+#define DREG_AR_CB_CFG0			PPE_REG_ADDR(0x0D09)
+#define DREG_AR_CB_CFG1			PPE_REG_ADDR(0x0D0A)
+#define DREG_A_UTPCFG			PPE_REG_ADDR(0x0D0E)
+#define DREG_A_STATUS			PPE_REG_ADDR(0x0D0F)
+#define DREG_AT_CFG0			PPE_REG_ADDR(0x0D20)
+#define DREG_AT_CFG1			PPE_REG_ADDR(0x0D21)
+#define DREG_AT_FB_SIZE0		PPE_REG_ADDR(0x0D22)
+#define DREG_AT_FB_SIZE1		PPE_REG_ADDR(0x0D23)
+#define DREG_AT_CELL0			PPE_REG_ADDR(0x0D24)
+#define DREG_AT_CELL1			PPE_REG_ADDR(0x0D25)
+#define DREG_AT_IDLE_CNT0		PPE_REG_ADDR(0x0D26)
+#define DREG_AT_IDLE_CNT1		PPE_REG_ADDR(0x0D27)
+#define DREG_AT_IDLE0			PPE_REG_ADDR(0x0D28)
+#define DREG_AT_IDLE1			PPE_REG_ADDR(0x0D29)
+#define DREG_AR_CFG0			PPE_REG_ADDR(0x0D60)
+#define DREG_AR_CFG1			PPE_REG_ADDR(0x0D61)
+#define DREG_AR_CELL0			PPE_REG_ADDR(0x0D68)
+#define DREG_AR_CELL1			PPE_REG_ADDR(0x0D69)
+#define DREG_AR_IDLE_CNT0		PPE_REG_ADDR(0x0D6A)
+#define DREG_AR_IDLE_CNT1		PPE_REG_ADDR(0x0D6B)
+#define DREG_AR_AIIDLE_CNT0		PPE_REG_ADDR(0x0D6C)
+#define DREG_AR_AIIDLE_CNT1		PPE_REG_ADDR(0x0D6D)
+#define DREG_AR_BE_CNT0			PPE_REG_ADDR(0x0D6E)
+#define DREG_AR_BE_CNT1			PPE_REG_ADDR(0x0D6F)
+#define DREG_AR_HEC_CNT0		PPE_REG_ADDR(0x0D70)
+#define DREG_AR_HEC_CNT1		PPE_REG_ADDR(0x0D71)
+#define DREG_AR_IDLE0			PPE_REG_ADDR(0x0D74)
+#define DREG_AR_IDLE1			PPE_REG_ADDR(0x0D75)
+#define DREG_AR_OVDROP_CNT0		PPE_REG_ADDR(0x0D98)
+#define DREG_AR_OVDROP_CNT1		PPE_REG_ADDR(0x0D99)
+#define DREG_AR_CERRN_CNT0		PPE_REG_ADDR(0x0DA0)
+#define DREG_AR_CERRN_CNT1		PPE_REG_ADDR(0x0DA1)
+#define DREG_AR_CERRNP_CNT0		PPE_REG_ADDR(0x0DA2)
+#define DREG_AR_CERRNP_CNT1		PPE_REG_ADDR(0x0DA3)
+#define DREG_AR_CVN_CNT0		PPE_REG_ADDR(0x0DA4)
+#define DREG_AR_CVN_CNT1		PPE_REG_ADDR(0x0DA5)
+#define DREG_AR_CVNP_CNT0		PPE_REG_ADDR(0x0DA6)
+#define DREG_AR_CVNP_CNT1		PPE_REG_ADDR(0x0DA7)
+#define DREG_B0_LADR			PPE_REG_ADDR(0x0DA8)
+#define DREG_B1_LADR			PPE_REG_ADDR(0x0DA9)
+#define BC0_LINK_STATUS			PPE_REG_ADDR(0x0DC0)
+#define PDBRAM_OWN_STATUS		PPE_REG_ADDR(0x0DC2)
+#define DSL_TC_INDICATE			PPE_REG_ADDR(0x0DC4)
+#define PPE_BC0_CW_SIZE			PPE_REG_ADDR(0x0DC5)
+#define DSL_FRAMER_REQ_START		PPE_REG_ADDR(0x0DC6)
+#define DSL_FRAMER_REQ_STOP		PPE_REG_ADDR(0x0DC7)
+#define ERB_DESC_BASE			PPE_REG_ADDR(0x0DC8)
+#define ERB_DESC_NUM			PPE_REG_ADDR(0x0DC9)
+
+#define DREG_AT_CB_CFG(x)		(DREG_AT_CB_CFG0 + ((x) << 2))
+#define DREG_AR_CB_CFG(x)		(DREG_AR_CB_CFG0 + ((x) << 2))
+#define DREG_AT_CFG(x)			(DREG_AT_CFG0 + ((x) << 2))
+#define DREG_AT_FB_SIZE(x)		(DREG_AT_FB_SIZE0 + ((x) << 2))
+#define DREG_AT_CELL(x)			(DREG_AT_CELL0 + ((x) << 2))
+#define DREG_AT_IDLE_CNT(x)		(DREG_AT_IDLE_CNT0 + ((x) << 2))
+#define DREG_AT_IDLE(x)			(DREG_AT_IDLE0 + ((x) << 2))
+#define DREG_AR_CFG(x)			(DREG_AR_CFG0 + ((x) << 2))
+#define DREG_AR_CELL(x)			(DREG_AR_CELL0 + ((x) << 2))
+#define DREG_AR_IDLE_CNT(x)		(DREG_AR_IDLE_CNT0 + ((x) << 2))
+#define DREG_AR_AIIDLE_CNT(x)		(DREG_AR_AIIDLE_CNT0 + ((x) << 2))
+#define DREG_AR_BE_CNT(x)		(DREG_AR_BE_CNT0 + ((x) << 2))
+#define DREG_AR_HEC_CNT(x)		(DREG_AR_HEC_CNT0 + ((x) << 2))
+#define DREG_AR_IDLE(x)			(DREG_AR_IDLE0 + ((x) << 2))
+#define DREG_AR_OVDROP_CNT(x)		(DREG_AR_OVDROP_CNT0 + ((x) << 2))
+#define DREG_AR_CERRN_CNT(x)		(DREG_AR_CERRN_CNT0 + ((x) << 2))
+#define DREG_AR_CVN_CNT(x)		(DREG_AR_CVN_CNT0 + ((x) << 2))
+#define DREG_AR_CVNP_CNT(x)		(DREG_AR_CVNP_CNT0 + ((x) << 2))
+#define DREG_B_LADR(x)			(DREG_B0_LADR + ((x) << 2))
+
+/* SAR_PDMA REG*/
+#define SAR_PDMA_RX_CMDBUF_CFG		PPE_REG_ADDR(0x0F00)
+#define SAR_PDMA_TX_CMDBUF_CFG		PPE_REG_ADDR(0x0F01)
+#define SAR_PDMA_RX_FW_CMDBUF_CFG	PPE_REG_ADDR(0x0F02)
+#define SAR_PDMA_TX_FW_CMDBUF_CFG	PPE_REG_ADDR(0x0F03)
+#define SAR_PDMA_RX_CMDBUF_STATUS	PPE_REG_ADDR(0x0F04)
+#define SAR_PDMA_TX_CMDBUF_STATUS	PPE_REG_ADDR(0x0F05)
+
+#define GIF0_RX_CRC_ERR_CNT		DREG_AR_CERRN_CNT0
+#define GIF1_RX_CRC_ERR_CNT		DREG_AR_CERRNP_CNT0
+#define GIF2_RX_CRC_ERR_CNT		DREG_AR_CERRN_CNT1
+#define GIF3_RX_CRC_ERR_CNT		DREG_AR_CERRNP_CNT1
+#define GIF0_RX_CV_CNT			DREG_AR_CVN_CNT0
+#define GIF1_RX_CV_CNT			DREG_AR_CVNP_CNT0
+#define GIF2_RX_CV_CNT			DREG_AR_CVN_CNT1
+#define GIF3_RX_CV_CNT			DREG_AR_CVNP_CNT1
+#define B0_OVERDROP_CNT			DREG_AR_OVDROP_CNT0
+#define B1_OVERDROP_CNT			DREG_AR_OVDROP_CNT1
+
+/* QSB REG */
+#define QSB_BASE			0x338000
+#define QOS_REG(off)			(QSB_BASE + (off))
+#define QSB_ICDV			QOS_REG(0x1C)
+#define QSB_SBL				QOS_REG(0x24)
+#define QSB_CFG				QOS_REG(0x28)
+#define QSB_RTM				QOS_REG(0x2C)
+#define QSB_RTD				QOS_REG(0x30)
+#define QSB_RAMAC			QOS_REG(0x34)
+#define QSB_ISTAT			QOS_REG(0x38)
+#define QSB_IMR				QOS_REG(0x3C)
+#define QSB_SRC				QOS_REG(0x40)
+
+/* SB FPI address on xBar SSX1 */
+#define SB_XBAR_BASE			0x280000
+#define SB_XBAR_ADDR(x)			\
+	(SB_XBAR_BASE + (((x) - 0xA000) << 2))
+
+/* PDBRAM FPI address */
+#define PDBRAM_BASE			0x200000
+#define PDBRAM_PPE_BASE			(PDBRAM_BASE + 0x18000)
+#define PDBRAM_PPE_SIZE			(0x20000) /* Size in Bytes */
+
+/* Mailbox interrupt address */
+#define MBOX_BASE			0x334800
+#define MBOX_OFF(id)			\
+	(((id) < 2) ? ((id) << 4) : (0x40 + (((id) - 2) << 4)))
+#define MBOX_IGU_ISRS(id)		(MBOX_BASE + MBOX_OFF(id))
+#define MBOX_IGU_ISRC(id)		(MBOX_BASE + MBOX_OFF(id) + 0x4)
+#define MBOX_IGU_ISR(id)		(MBOX_BASE + MBOX_OFF(id) + 0x8)
+#define MBOX_IGU_IER(id)		(MBOX_BASE + MBOX_OFF(id) + 0xC)
+#define MBOX_MASK(id)			((id == 2) ? 0xFF : 0xFFFFFFFF)
+
+/* Mailbox interrupt bit */
+#define MBOX_PKT_RX			BIT(0)
+#define MBOX_OAM_RX			BIT(1)
+#define MBOX_P2P_STAT			BIT(4)
+#define MBOX_FRAME_STOP			BIT(6)
+#define MBOX_INT_ALL			\
+	(MBOX_PKT_RX | MBOX_OAM_RX | MBOX_P2P_STAT | MBOX_FRAME_STOP)
+
+/* Mailbox interrupt to PPE FW */
+#define MBOX_FW_WAKEUP			BIT(0)
+#define PPE_FW_MBOX0			MBOX_IGU5
+
+/**
+ * PP32 Debug Register and Macro
+ */
+#define LSH(n, bits)			((n) << (bits))
+#define LLSH(a, b, bits)		(LSH(a, LSH(b, bits)))
+#define PP32_DBG_REG(n, off)		(PPE_BASE + (((off) + LSH(n, 16)) << 2))
+
+#define PP32_CTRL_CMD(n)		PP32_DBG_REG(n, 0x0B00)
+#define CTRL_CMD_RESTART		BIT(0)
+#define CTRL_CMD_STOP			BIT(1)
+#define CTRL_CMD_STEP			BIT(2)
+#define CTRL_CMD_BREAKOUT		BIT(3)
+
+#define PP32_CTRL_OPT(n)		PP32_DBG_REG(n, 0x0C00)
+#define BREAKOUT_ON_STOP_ON		(3 << 0)
+#define BREAKOUT_ON_STOP_OFF		(2 << 0)
+#define BREAKOUT_ON_BREAKIN_ON		(3 << 2)
+#define BREAKOUT_ON_BREAKIN_OFF		(2 << 2)
+#define STOP_ON_BREAKIN_ON		(3 << 4)
+#define STOP_ON_BREAKIN_OFF		(2 << 4)
+#define STOP_ON_BREAKPOINT_ON		(3 << 6)
+#define STOP_ON_BREAKPOINT_OFF		(2 << 6)
+#define BREAKOUT_ON_STOP(n)		(tc_r32(PP32_CTRL_OPT(n)) & BIT(0))
+#define BREAKOUT_ON_BREAKIN(n)		(tc_r32(PP32_CTRL_OPT(n)) & BIT(2))
+#define STOP_ON_BREAKIN(n)		(tc_r32(PP32_CTRL_OPT(n)) & BIT(4))
+#define STOP_ON_BREAKPOINT(n)		(tc_r32(PP32_CTRL_OPT(n)) & BIT(6))
+
+#define BRK_PC(n, pc)			(PP32_DBG_REG(n, 0x0900 + LSH(pc, 1)))
+#define BRK_PC_MASK(n, pc)		(PP32_DBG_REG(n, 0x0901 + LSH(pc, 1)))
+#define BRK_DATA_ADDR(n, pc)		(PP32_DBG_REG(n, 0x0904 + LSH(pc, 1)))
+#define BRK_DATA_ADDR_MASK(n, pc)	(PP32_DBG_REG(n, 0x0905 + LSH(pc, 1)))
+#define BRK_DATA_VAL_RD(n, pc)		(PP32_DBG_REG(n, 0x0908 + LSH(pc, 1)))
+#define BRK_DATA_VAL_RD_MASK(n, pc)	(PP32_DBG_REG(n, 0x0909 + LSH(pc, 1)))
+#define BRK_DATA_VAL_WR(n, pc)		(PP32_DBG_REG(n, 0x090C + LSH(pc, 1)))
+#define BRK_DATA_VAL_WR_MASK(n, pc)	(PP32_DBG_REG(n, 0x090D + LSH(pc, 1)))
+#define BRK_CONTEXT_MASK		(0xF)
+#define BRK_CONTEXT_MASK_EN		(BIT(4))
+/* valid for break data value rd/wr only */
+#define BRK_COMPARE_GREATER_EQUAL	(BIT(5))
+#define BRK_COMPARE_LOWER_EQUAL		(BIT(6))
+#define BRK_COMPARE_EN			(BIT(7))
+
+#define BRK_TRIG(n)			PP32_DBG_REG(n, 0x0F00)
+#define BRK_GRP_PC_ON(i, n)		(LLSH(LLSH(3, n, 1), i, 4))
+#define BRK_GRP_PC_OFF(i, n)		(LLSH(LLSH(2, n, 1), i, 4))
+#define BRK_GRP_DATA_ADDR_ON(i, n)	(LLSH(LSH(3, LSH(n, 1) + 4), i, 4))
+#define BRK_GRP_DATA_ADDR_OFF(i, n)	(LLSH(LSH(2, LSH(n, 1) + 4), i, 4))
+#define BRK_GRP_DATA_VAL_RD_ON(i, n)	(LLSH(LSH(3, LSH(n, 1) + 8), i, 4))
+#define BRK_GRP_DATA_VAL_RD_OFF(i, n)	(LLSH(LSH(2, LSH(n, 1) + 8), i, 4))
+#define BRK_GRP_DATA_VAL_WR_ON(i, n)	(LLSH(LSH(3, LSH(n, 1) + 12), i, 4))
+#define BRK_GRP_DATA_VAL_WR_OFF(i, n)	(LLSH(LSH(2, LSH(n, 1) + 12), i, 4))
+#define TRIG_VAL(k)			(tc_r32(BRK_TRIG(k)))
+#define BRK_GRP_PC(k, i, n)		(TRIG_VAL(k) & LLSH(BIT(n), i, 3))
+#define BRK_GRP_DATA_ADDR(k, i, n)	(TRIG_VAL(k) & LLSH(BIT((n) + 2), i, 3))
+#define BRK_GRP_DATA_VAL_RD(k, i, n)	(TRIG_VAL(k) & LLSH(BIT((n) + 4), i, 3))
+#define BRK_GRP_DATA_VAL_WR(k, i, n)	(TRIG_VAL(k) & LLSH(BIT((n) + 6), i, 3))
+
+#define PP32_CPU_STATUS(n)		PP32_DBG_REG(n, 0x0D00)
+#define PP32_HALT_STAT(n)		PP32_CPU_STATUS(n)
+#define PP32_DBG_CUR_PC(n)		PP32_CPU_STATUS(n)
+#define PP32_STATUS(n)			(tc_r32(PP32_CPU_STATUS(n)))
+#define USER_STOPPED(n)			(PP32_STATUS(n) & BIT(0))
+#define USER_BREAKIN_RCV(n)		(PP32_STATUS(n) & BIT(1))
+#define USER_BREAKPOINT_MET(n)		(PP32_STATUS(n) & BIT(2))
+#define CUR_PC(n)			(PP32_STATUS(n) >> 16)
+
+#define BREAKPOINT_REASONS(n)		PP32_DBG_REG(n, 0x0A00)
+#define BRKPT_RSNS(n)			(tc_r32(BREAKPOINT_REASONS(n)))
+#define BRK_PC_MET(n, i)		(BRKPT_RSNS(n) & (1 << (i)))
+#define BRK_DATA_ADDR_MET(n, i)		(BRKPT_RSNS(n) & (1 << ((i) + 2)))
+#define BRK_DATA_VAL_RD_MET(n, i)	(BRKPT_RSNS(n) & (1 << ((i) + 4)))
+#define BRK_DATA_VAL_WR_MET(n, i)	(BRKPT_RSNS(n) & (1 << ((i) + 6)))
+#define BRK_DATA_VAL_RD_LO_EQ(n, i)	(BRKPT_RSNS(n) & (1 << ((i) * 2 + 8)))
+#define BRK_DATA_VAL_RD_GT_EQ(n, i)	(BRKPT_RSNS(n) & (1 << ((i) * 2 + 9)))
+#define BRK_DATA_VAL_WR_LO_EQ(n, i)	(BRKPT_RSNS(n) & (1 << ((i) * 2 + 12)))
+#define BRK_DATA_VAL_WR_GT_EQ(n, i)	(BRKPT_RSNS(n) & (1 << ((i) * 2 + 13)))
+#define BRK_CUR_CONTEXT(n)		((PP32_STATUS(n) >> 8) & 0x03)
+
+#define GP_REG_BASE(n)			PP32_DBG_REG(n, 0x0E00)
+#define GP_CONTEXT_REG(n, i, j)		\
+	tc_r32(PP32_DBG_REG(n, 0x0E00 + (i) * 16 + (j)))
+
+/* PP32 RSR BIT */
+#define TTHA_RST		BIT(0)
+#define RTHA_RST		BIT(1)
+#define DREG_RST		BIT(2)
+#define SLL0_RST		BIT(3)
+#define TCDMA0_RST		BIT(4)
+#define SB_RST			BIT(5)
+#define SAR_RST			BIT(6)
+#define SLL1_RST		BIT(7)
+#define PDMA_RST		BIT(8)
+#define QSB_RST			BIT(9)
+#define DMAL_RST		BIT(10)
+#define PPM0_RST		BIT(16)
+#define PPM1_RST		BIT(17)
+#define PPM2_RST		BIT(18)
+#define PP32_RST_ALL		(TTHA_RST | RTHA_RST | DREG_RST | SLL0_RST\
+				TCDMA0_RST | SB_RST | SAR_RST | SLL1_RST |\
+				PDMA_RST | QSB_RST | DMAL_RST | PPM0_RST |\
+				PPM1_RST | PPM2_RST)
+
+/* CDMA REG */
+#define CDMA_BASE		0x2D0000
+#define CDMA_REG(off)		(CDMA_BASE + (off))
+#define CDMA_CLC		CDMA_REG(0x0)
+#define CDMA_ID			CDMA_REG(0x8)
+#define CDMA_CTRL		CDMA_REG(0x10)
+#define CDMA_CPOLL		CDMA_REG(0x14)
+#define CDMA_CS			CDMA_REG(0x18)
+#define CDMA_CCTRL		CDMA_REG(0x1C)
+#define CDMA_CDBA		CDMA_REG(0x20)
+#define CDMA_CDLEN		CDMA_REG(0x24)
+#define CDMA_CIS		CDMA_REG(0x28)
+#define CDMA_CIE		CDMA_REG(0x2C)
+#define CDMA_CDPTNRD		CDMA_REG(0x34)
+#define CDMA_PS			CDMA_REG(0x40)
+#define CDMA_PCTRL		CDMA_REG(0x44)
+#define CDMA_IRNEN		CDMA_REG(0xF4)
+#define CDMA_IRNCR		CDMA_REG(0xF8)
+#define CDMA_IRNICR		CDMA_REG(0xFC)
+
+/* DMA CCTRL BIT */
+#define CCTRL_RST_S		1
+#define CCTRL_ONOFF_S		0
+
+/* DMA CTRL BIT */
+#define CTRL_PKTARB_S		31	/* Packet Arbitration */
+#define CTRL_MDC_S		15	/* Meta data copy */
+#define CTRL_DDBR_S		14	/* Dynamic Burst */
+#define CTRL_DCNF_S		13	/* Descriptor Length CFG*/
+#define CTRL_ENBE_S		9	/* Byte Enable */
+#define CTRL_DRB_S		8	/* Descriptor Read back */
+#define CTRL_DSRAM_S		1	/* Dedicated Desc access port */
+#define CTRL_RST_S		0	/* Global Reset */
+
+/* DMA PORT BIT */
+#define PCTRL_GPC_S		16	/* FLUSH MEMORY PORT */
+#define PCTRL_TXENDI_S		10	/* TX DIR Endianess */
+#define PCTRL_RXENDI_S		8	/* RX DIR Endianess */
+#define PCTRL_TXBL_S		4	/* TX burst 2/4/8 */
+#define PCTRL_RXBL_S		2	/* RX burst 2/4/8 */
+#define PCTRL_TXBL16_S		1	/* TX burst of 16 */
+#define PCTRL_RXBL16_S		0	/* RX burst of 16 */
+
+/*DMA ID BIT */
+#define ID_CHNR			0x3F
+#define ID_CHNR_S		20	/* Channel Number */
+
+/*DMA POLLING */
+#define POLL_EN			1
+#define POLL_EN_S		31	/* Polling Enable */
+#define POLL_CNT		0xFFF
+#define POLL_CNT_S		4	/* Polling Counter */
+#define POLL_DEF_CNT		24
+
+#define CDMA_CI_EOP		BIT(1)
+#define CDMA_CI_DUR		BIT(2)
+#define CDMA_CI_DESCPT		BIT(3)
+#define CDMA_CI_CHOFF		BIT(4)
+#define CDMA_CI_RDERR		BIT(5)
+#define CDMA_CI_ALL		(CDMA_CI_EOP | CDMA_CI_DUR | CDMA_CI_DESCPT\
+				| CDMA_CI_CHOFF | CDMA_CI_RDERR)
+
+/*CGU REG BIT */
+#define PMU_PPE_ALL		(PMU_CDMA | PMU_PPE_QSB | PMU_PPE_SLL01 | \
+				PMU_PPE_TC | PMU_EMA | PMU_PPM2 | PMU_PPE_TOP)
+
+#define PMU_PTM			(PMU_CDMA | PMU_PPE_SLL01 | PMU_PPE_TC | \
+				PMU_EMA | PMU_PPM2 | PMU_PPE_TOP)
+
+#define PMU_ATM			(PMU_CDMA | PMU_PPE_QSB | PMU_PPE_SLL01 | \
+				 PMU_PPE_TC | PMU_EMA | PMU_PPE_TOP)
+
+/* RCU RED BIT */
+#define RST_PPE_ALL		(RST_DSL_IF | RST_PPE | RST_PPE_ATM_TC)
+
+#define mem(p)			(((struct tc_comm *)p)->ep->membase)
+#define tc_r32(reg)		(readl(mem(priv) + (reg)))
+#define tc_w32(val, reg)	(writel(val, mem(priv) + (reg)))
+#define tc_w32_flush(val, reg)		\
+do {					\
+	tc_w32(val, reg);		\
+	tc_r32(reg);			\
+} while (0)
+
+#define MS(_v, _m)		((_v) >> (_m##_S) & (_m))
+#define SM(_v, _m)		(((_v) & (_m)) << (_m##_S))
+#define CLR(v, m, b)		((v) & (~((m) << (b))))
+#define SET(s, m, b)		(((s) & (m)) << (b))
+
+#define set_mask_bit(val, set, mask, bits)			\
+	(val = (CLR(val, mask, bits) | SET(set, mask, bits)))
+
+static inline void rw32_mask(void *priv, u32 set,
+			u32 mask, u32 bits, u32 reg_addr)
+{
+	u32 val;
+
+	val = tc_r32(reg_addr);
+	tc_w32(set_mask_bit(val, set, mask, bits), reg_addr);
+}
+
+#define TO_DWSZ(a)	((a) >> 2)
+#define TO_BYSZ(a)	((a) << 2)
+
+/**
+ * API to convert SB address to FPI address
+ * input:
+ *	sb_addr:  SB address
+ *
+ * return:
+ *	Success:  FPI address
+ *	Fail:  0
+ */
+static inline u32 fpi_addr(u32 sb_addr)
+{
+	u32 fpi_addr;
+	if (sb_addr <= SB_REG_END)
+		fpi_addr = PPE_REG_ADDR(sb_addr);
+	else if (sb_addr >= SB_SEG0_BASE && sb_addr <= SB_SEG0_END)
+		fpi_addr = PPE_SB_ADDR(0, (sb_addr - SB_SEG0_BASE));
+	else if ((sb_addr >= SB_SEG1_BASE && sb_addr <= SB_SEG1_END)
+		|| (sb_addr >= SB_SEG2_BASE && sb_addr <= SB_SEG2_END))
+		fpi_addr = PPE_SB_ADDR(1, (sb_addr - SB_SEG1_BASE));
+	else
+		fpi_addr = sb_addr;
+
+	return fpi_addr;
+}
+
+/* API to write DWORD to PPE SB */
+#define sb_w32(val, addr)	(tc_w32((val), fpi_addr(addr)))
+/* API to read DWORD from PPE SB */
+#define sb_r32(addr)		(tc_r32(fpi_addr(addr)))
+
+enum {
+	PP32_TX = 0,
+	PP32_BOND = 1,
+	PP32_RX = 2,
+	PP32_MAX
+};
+
+enum {
+	NO_SWAP		= 0,	/* B0_B1_B2_B3 */
+	BYTE_SWAP	= 1,	/* B1_B0_B3_B2 */
+	WORD_SWAP	= 2,	/* B2_B3_B0_B1 */
+	BYTE_WORD_SWAP	= 3,	/* B3_B2_B1_B0 */
+};
+
+
+enum cdma_onoff {
+	DMA_CH_OFF	= 0,
+	DMA_CH_ON	= 1,
+};
+
+
+#endif /*__REG_ADDR_H__ */
+
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/tc_api.h b/drivers/net/ethernet/intel/vrx518/tc/inc/tc_api.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/tc_api.h
@@ -0,0 +1,205 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#ifndef __TC_API_H__
+#define __TC_API_H__
+
+#include <net/genetlink.h>
+
+static inline int tc_clkon(struct dc_ep_dev *ep_dev, u32 pset)
+{
+	return ep_dev->hw_ops->clk_on(ep_dev, pset);
+}
+
+static inline int tc_clkoff(struct dc_ep_dev *ep_dev, u32 pset)
+{
+	return ep_dev->hw_ops->clk_off(ep_dev, pset);
+}
+
+static inline int tc_ppe_rst(struct dc_ep_dev *ep_dev)
+{
+	return ep_dev->hw_ops->reset_device(ep_dev, RST_PPE_ALL);
+}
+
+static inline int tc_ppe_clkset(struct dc_ep_dev *ep_dev, u32 ppe_clk)
+{
+	return ep_dev->hw_ops->clk_set(ep_dev, SYS_CLK_288MHZ, ppe_clk);
+}
+
+static inline void set_tc_status(struct tc_priv *tcpriv, enum tc_status status)
+{
+	tcpriv->tc_stat = status;
+}
+
+static inline int tc_ppe_clkget(struct dc_ep_dev *ep_dev)
+{
+	u32 sys_clk, ppe_clk;
+
+	ep_dev->hw_ops->clk_get(ep_dev, &sys_clk, &ppe_clk);
+
+	switch (ppe_clk) {
+	case PPE_CLK_576MHZ:
+		return 576000000;
+	case PPE_CLK_494MHZ:
+		return 494000000;
+	case PPE_CLK_432MHZ:
+		return 432000000;
+	case PPE_CLK_288MHZ:
+		return 288000000;
+	case PPE_CLK_36MHZ:
+		return 36000000;
+	default:
+		WARN(1, "PPE CLK error: 0x%x\n", ppe_clk);
+		return 0;
+	}
+}
+static inline void tc_stat_indicate(void *priv, enum dsl_tc_mode tc, int set)
+{
+	if (set) {
+		if (tc == TC_PTM_BND_MODE || tc == TC_PTM_SL_MODE)
+			tc_w32(BIT(TC_PTM_SL_MODE), DSL_TC_INDICATE);
+		else
+			tc_w32(BIT(tc), DSL_TC_INDICATE);
+	} else
+		tc_w32(0, DSL_TC_INDICATE);
+}
+
+/**
+ * API to debug PP32, set PC instruction trigger on/off
+ * Input:
+ *	priv: ATM/PTM/Bonding priv structure
+ *	pp32:  PPM index (0 -2)
+ *	pc: break point (0 - 2)
+ *	addr: break point instruction address
+ *	flag: 0 - off, 1 - on
+ */
+static inline void pp32_dbg_set_pc(void *priv, int pp32,
+			int pc, u32 addr, int flag)
+{
+	if (!flag) { /* off */
+		tc_w32(BRK_GRP_PC_OFF(pc, pc), BRK_TRIG(pp32));
+		tc_w32(BRK_CONTEXT_MASK_EN, BRK_PC_MASK(pp32, pc));
+		tc_w32(0, BRK_PC(pp32, pc));
+	} else { /* on */
+		tc_w32(addr, BRK_PC(pp32, pc));
+		tc_w32(BRK_CONTEXT_MASK_EN | BRK_CONTEXT_MASK,
+			BRK_PC_MASK(pp32, pc));
+		tc_w32(BRK_GRP_PC_ON(pc, pc), BRK_TRIG(pp32));
+	}
+
+	if (tc_r32(BRK_TRIG(pp32)))
+		tc_w32(STOP_ON_BREAKPOINT_ON, PP32_CTRL_OPT(pp32));
+	else
+		tc_w32(STOP_ON_BREAKPOINT_OFF, PP32_CTRL_OPT(pp32));
+}
+
+/**
+ * API to debug PP32, set data trigger on/off
+ * Input:
+ *	priv: ATM/PTM/Bonding priv structure
+ *	pp32:  PPM index (0 -2)
+ *	pc: break point (0 - 2)
+ *	addr: break point data address
+ *	flag: 0 - off, 1 - on
+ */
+static inline void pp32_dbg_set_addr(void *priv, int pp32,
+			int pc, u32 addr, int flag)
+{
+	if (!flag) { /* off */
+		tc_w32(BRK_GRP_DATA_ADDR_OFF(pc, pc), BRK_TRIG(pp32));
+		tc_w32(BRK_CONTEXT_MASK_EN, BRK_DATA_ADDR_MASK(pp32, pc));
+		tc_w32(0, BRK_DATA_ADDR(pp32, pc));
+	} else { /* on */
+		tc_w32(addr, BRK_DATA_ADDR(pp32, pc));
+		tc_w32(BRK_CONTEXT_MASK_EN | BRK_CONTEXT_MASK,
+			BRK_DATA_ADDR_MASK(pp32, pc));
+		tc_w32(BRK_GRP_DATA_ADDR_ON(pc, pc), BRK_TRIG(pp32));
+	}
+	if (tc_r32(BRK_TRIG(pp32)))
+		tc_w32(STOP_ON_BREAKPOINT_ON, PP32_CTRL_OPT(pp32));
+	else
+		tc_w32(STOP_ON_BREAKPOINT_OFF, PP32_CTRL_OPT(pp32));
+}
+
+/* APIs for pp32 debug*/
+static inline void pp32_dbg_start(void *priv, int pp32)
+{
+	tc_w32(CTRL_CMD_RESTART, PP32_CTRL_CMD(pp32));
+}
+
+static inline void pp32_dbg_stop(void *priv, int pp32)
+{
+	tc_w32(CTRL_CMD_STOP, PP32_CTRL_CMD(pp32));
+}
+
+static inline void pp32_dbg_step(void *priv, int pp32)
+{
+	tc_w32(0, PP32_CTRL_CMD(pp32));
+	tc_w32(CTRL_CMD_STEP, PP32_CTRL_CMD(pp32));
+}
+
+static inline void mbox_set_ier(void *priv, u32 id, u32 ier_en_mask)
+{
+	tc_w32_flush(ier_en_mask, MBOX_IGU_IER(id));
+}
+
+static inline void mbox_clr_isr(void *priv, u32 id, u32 isr_mask)
+{
+	tc_w32_flush(isr_mask, MBOX_IGU_ISRC(id));
+}
+
+static inline void mbox_set_isr(void *priv, u32 id, u32 isr_set)
+{
+	tc_w32(isr_set, MBOX_IGU_ISRS(id));
+}
+
+extern int showtime_stat(struct tc_priv *);
+extern void dump_skb_info(struct tc_priv *, struct sk_buff *, u32);
+extern void *tc_buf_alloc(void *, size_t, dma_addr_t *,
+		enum tc_dir, struct device *);
+extern void setup_dfe_loopback(void *, u32);
+extern void dfe_loopback_linkup(void *);
+extern void tc_gentlk_exit(void);
+extern int tc_gentlk_init(struct tc_priv *);
+extern int tc_ntlk_msg_send(struct tc_priv *, int, int, int, int, int);
+extern void cdma_ch_off(void *, int, int);
+extern void cdma_ch_on(void *, int, int);
+extern void cdma_ch_cfg(void *, int, int, u32, u32, u32, u32);
+extern void tc_cdma_init(void *);
+extern void pp32_load(void *, struct ppe_fw *, int);
+extern void pp32_reset(void *, u32);
+extern void pdbram_clear(void *);
+extern void ppe_sb_clear(void *);
+extern void pp32_stop(void *, int);
+extern void pp32_start(void *, int);
+extern void tc_memset(void *, u32, int, size_t);
+extern void tc_mem_read(void *, void *, u32, size_t);
+extern void tc_mem_write(void *, u32, const void *, size_t);
+extern int ppe_fw_load(struct tc_priv *);
+extern void ppe_fw_unload(struct tc_priv *);
+extern int fw_version_info(struct tc_priv *, char *);
+extern u32 tc_addr(u32, u32, u32);
+extern void ttha_disable(void *, int);
+extern void ttha_enable(void *);
+extern void rtha_idle_keep_disable(void *);
+
+#endif /* __TC_API_H__ */
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/tc_common.h b/drivers/net/ethernet/intel/vrx518/tc/inc/tc_common.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/tc_common.h
@@ -0,0 +1,345 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#ifndef __TC_COMMON_H__
+#define __TC_COMMON_H__
+
+#define HD_RSRV_SZ		32
+#define UMT_DEF_PERIOD		200	/* microseconds */
+
+#define MAX_MTU			(DMA_PACKET_SZ - ETH_HLEN - HD_RSRV_SZ)
+#define QOSQ_NUM		2
+#define FW_STOP_TIMEOUT		20	/* millisecond */
+#define QOS_DISPATCH_OWN	0
+#define ACA_TXIN_POLL_INTVAL	10	/* millisecond */
+#define ACA_TXIN_HD_DESC_NUM	32
+#define ACA_TXOUT_HD_DESC_NUM	32
+#define ACA_RXIN_HD_DESC_NUM	32
+#define ACA_RXOUT_HD_DESC_NUM	32
+
+enum {
+	LOC_IN_SRAM = 0,
+	LOC_IN_FPI,
+	LOC_IN_PDBRAM,
+};
+
+enum {
+	TC_SRAM_ADDR = 0,
+	TC_FPI_ADDR,
+};
+
+/* Mailbox Interrupt Generate Unit */
+enum {
+	MBOX_IGU0 = 0,
+	MBOX_IGU1,
+	MBOX_IGU2,
+	MBOX_IGU3,
+	MBOX_IGU4,
+	MBOX_IGU5,
+	MBOX_IGU6,
+};
+
+/* Powersaving flags */
+enum {
+	PPE_PS_SAVE = 0,
+	PPE_PS_RESTORE,
+};
+
+struct ppe_fw_data {
+	const u32 *data[PP32_MAX];
+	size_t size[PP32_MAX];
+};
+
+struct ppe_fw {
+	struct fw_ver_id ptm_ver;
+	struct fw_ver_id atm_ver;
+
+	struct ppe_fw_data ptm_fw;
+	struct ppe_fw_data atm_fw;
+};
+
+struct psave_cfg { /*@2014*/
+	unsigned int res1:15;
+	/*1: start from partial PPE reset, 0: start from full PPE reset */
+	unsigned int start_state:1;
+	unsigned int res2:15;
+	/*1: enable sleep mode, 0: disable sleep mode */
+	unsigned int sleep_en:1;
+} __packed;
+
+struct rx_bc_cfg {
+	unsigned int res1:14;
+	/**
+	* 0: local receiver is "Looking",
+	* 1: local receiver is "Freewheel Sync False",
+	* 2: local receiver is "Synced",
+	* 3: local receiver is "Freewheel Sync Truee"
+	*/
+	unsigned int local_state:2;
+	unsigned int res2:15;
+	/**
+	 * 0: remote receiver is "Out-of-Sync",
+	 * 1: remote receiver is "Synced"
+	 */
+	unsigned int remote_state:1;
+
+	/* the number of consecutive "Miss Sync" for
+	 * leaving "Freewheel Sync False" to "Looking" (default 3)
+	 */
+	unsigned int to_false_th:16;
+	/**
+	 * the number of consecutive "Miss Sync" for
+	 * leaving "Freewheel Sync True" to "Freewheel Sync False" (default 7)
+	 */
+	unsigned int to_looking_th:16;
+	/* firmware use only (total 30 dwords) */
+	unsigned int rx_cw_rdptr;
+	unsigned int cw_cnt;
+	unsigned int missed_sync_cnt;
+	unsigned int bitmap_last_cw[3]; /* Bitmap of the Last Codeword */
+	/* Bitmap of the Second Last Codeword */
+	unsigned int bitmap_second_last_cw[3];
+	/*Bitmap of the Third Last Codeword */
+	unsigned int bitmap_third_last_cw[3];
+	unsigned int looking_cw_cnt;
+	unsigned int looking_cw_th;
+	unsigned int byte_shift_cnt;
+	unsigned int byte_shift_val;
+	unsigned int res_word1[14];
+};
+
+struct rx_gamma_itf_cfg {
+	unsigned int res1:31;
+	/* 0: "Out-of-Fragment", 1: "In-Fragment" */
+	unsigned int receive_state:1;
+	unsigned int res2:16;
+	/* min length of packet,
+	 * padding if packet length is smaller than this value
+	 */
+	unsigned int rx_min_len:8;
+	unsigned int rx_pad_en:1; /*0:  padding disabled, 1: padding enabled */
+	unsigned int res3:2;
+	/* 0: ETH FCS verification is enabled, 1: disabled */
+	unsigned int rx_eth_fcs_ver_dis:1;
+	/* 0: ETH FCS field is not removed, 1: ETH FCS field is removed*/
+	unsigned int rx_rm_eth_fcs:1;
+	/* 0: TC CRC verification enabled, 1: disabled */
+	unsigned int rx_tc_crc_ver_dis:1;
+	/* 0: 0-bit, 1: 16-bit, 2: 32-bit */
+	unsigned int rx_tc_crc_size:2;
+	/* if the ETH FCS result matches this magic number,
+	 then the packet is valid packet
+	 */
+	unsigned int rx_eth_fcs_result;
+	/* if the TC CRC result matches this magic number,
+	 then the packet is valid packet
+	 */
+	unsigned int rx_tc_crc_result;
+	/* TC CRC config, please check the description of
+	 SAR context data structure in the hardware spec
+	 */
+	unsigned int rx_crc_cfg:16;
+	unsigned int res4:16;
+	/* ETH FCS initialization value */
+	unsigned int rx_eth_fcs_init_value;
+	/* TC CRC initialization value */
+	unsigned int rx_tc_crc_init_value;
+	unsigned int res_word1;
+	/* 0: normal, the max length is given by MAX_LEN_NORMAL,
+	 1: fragment, the max length is given by MAX_LEN_FRAG
+	 */
+	unsigned int rx_max_len_sel:1;
+	unsigned int res5:2;
+	/* number of bytes to be inserted/removed */
+	unsigned int rx_edit_num2:4;
+	/* first byte position to be edited */
+	unsigned int rx_edit_pos2:7;
+	/* 0: remove, 1: insert */
+	unsigned int rx_edit_type2:1;
+	/* 0: disable insertion or removal of data, 1: enable */
+	unsigned int rx_edit_en2:1;
+	unsigned int res6:3;
+	/* number of bytes to be inserted/removed */
+	unsigned int rx_edit_num1:4;
+	/* first byte position to be edited */
+	unsigned int rx_edit_pos1:7;
+	/* 0: remove, 1: insert */
+	unsigned int rx_edit_type1:1;
+	/* 0: disable insertion or removal of data, 1: enable */
+	unsigned int rx_edit_en1:1;
+	unsigned int res_word2[2];
+	unsigned int rx_inserted_bytes_1l;
+	unsigned int rx_inserted_bytes_1h;
+	unsigned int rx_inserted_bytes_2l;
+	unsigned int rx_inserted_bytes_2h;
+	/* the packet length adjustment, it is sign integer */
+	int rx_len_adj;
+	unsigned int res_word3[16];
+};
+
+struct tx_bc_cfg {
+	unsigned int fill_wm:16; /* default 2 */
+	unsigned int uflw_wm:16; /* default 2 */
+	/* firmware use only (total 31 dwords) */
+	unsigned int res0;
+	/* FW Internal Use */
+	unsigned int holding_pages;
+	unsigned int ready_pages;
+	unsigned int pending_pages;
+	unsigned int cw_wrptr; /* TX codeword write pointer for e*/
+	unsigned int res_word[26];
+};
+
+struct tx_gamma_itf_cfg {
+	unsigned int res_word1;
+	unsigned int res1:8;
+	/* 4 * (not TX_ETH_FCS_GEN_DIS) + TX_TC_CRC_SIZE */
+	unsigned int tx_len_adj:4;
+	/* 4 + TX_TC_CRC_SIZE */
+	unsigned int tx_crc_off_adj:4;
+	/* min length of packet, if length
+	 is less than this value, packet is padded
+	 */
+	unsigned int tx_min_len:8;
+	unsigned int res2:3;
+	/* 0: ETH FCS generation enabled, 1: disabled */
+	unsigned int tx_eth_fcs_gen_dis:1;
+	unsigned int res3:2;
+	/* 0: 0-bit, 1: 16-bit, 2: 32-bit */
+	unsigned int tx_tc_crc_size:2;
+	unsigned int res4:24;
+	/* TX queue attached to this Gamma interface */
+	unsigned int queue_mapping:8;
+	unsigned int res_word2;
+	/* TC CRC config, please check the
+	 description of SAR context data structure in the hardware spec
+	 */
+	unsigned int tx_crc_cfg:16;
+	unsigned int res5:16;
+	unsigned int tx_eth_fcs_init_value; /* ETH FCS initialization value */
+	unsigned int tx_tc_crc_init_value; /* TC CRC initialization value */
+	unsigned int res_word3[9];
+	/* firmware use only (total 25 dwords) */
+	/* FW Internal Use */
+	unsigned int curr_qid;
+	unsigned int fill_pkt_state;
+	unsigned int post_pkt_state;
+	unsigned int curr_pdma_context_ptr;
+	unsigned int curr_sar_context_ptr;
+	unsigned int des_addr;
+	unsigned int des_qid;
+	unsigned int rem_data;
+	unsigned int rem_crc;
+	/* bonding fields */
+	unsigned int rem_fh_len;
+	unsigned int des_dw0;
+	unsigned int des_dw1;
+	unsigned int des_bp_dw;
+	/* MIB field */
+	unsigned int tx_pkt_cnt;
+	unsigned int tx_byte_cnt;
+	/* Reserved */
+	unsigned int res_word4;
+};
+
+struct wan_rx_mib_table {
+	unsigned int res1[2];
+	unsigned int wrx_dropdes_pdu;
+	unsigned int wrx_total_bytes;
+	unsigned int res2[4];
+};
+
+struct sfsm_cfg {
+	unsigned int res:14;
+	unsigned int rlsync:1;
+	unsigned int endian:1;
+	unsigned int idlekeep:1;
+	unsigned int sen:1;
+	unsigned int res1:6;
+	unsigned int pnum:8;
+};
+
+struct sfsm_dba {
+	unsigned int res:17;
+	unsigned int dbase:15;
+};
+
+struct sfsm_cba {
+	unsigned int res:15;
+	unsigned int cbase:17;
+};
+
+struct ffsm_dba {
+	unsigned int res:17;
+	unsigned int dbase:15;
+};
+
+struct ffsm_cfg  {
+	unsigned int en:1;
+	unsigned int cf:1;
+	unsigned int res:10;
+	unsigned int rstptr:1;
+	unsigned int clvpage:1;
+	unsigned int fidle:1;
+	unsigned int endian:1;
+	unsigned int res1:8;
+	unsigned int pnum:8;
+};
+
+enum tc_attr {
+	TC_A_UNSPEC = 0,
+	TC_A_TC_MODE,
+	TC_A_TC_ACTION,
+	TC_A_BOND,
+	TC_A_LINENO,
+	TC_A_MAX,
+};
+
+enum tc_cmd {
+	TC_C_UNSPEC = 0,
+	TC_C_NOTIFY,
+	TC_C_MAX,
+};
+
+#define TC_MCAST_GRP_NAME	"vrx_mcgrp"
+#define TC_FAMILY_NAME		"vrx_tc_notify"
+
+enum tc_type {
+	ATM_TC = 1,
+	PTM_TC,
+};
+
+enum tc_action {
+	TC_UNLOADED = 0,
+	TC_LOADED,
+};
+
+enum bonding_stat {
+	NON_BONDING_MODE = 0,
+	BONDING_MODE,
+};
+
+#define DW_SZ(a)		(sizeof(a) / sizeof(u32))
+#define DESC_SZ			8
+#define DESC_DWSZ		(DESC_SZ >> 2)
+
+#endif /*__TC_COMMON_H__ */
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/tc_main.h b/drivers/net/ethernet/intel/vrx518/tc/inc/tc_main.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/tc_main.h
@@ -0,0 +1,253 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#ifndef __TC_MAIN_H__
+#define __TC_MAIN_H__
+
+#include <net/dc_ep.h>
+#include <net/dsl_tc.h>
+
+#define EP_MAX_NUM	(DC_EP_MAX_PEER + 1)
+#define TCPRIV_ALIGN	32
+#define DMA_PACKET_SZ	2048
+#define PMAC_SIZE		8
+enum {
+	MSG_RX		= BIT(0),
+	MSG_TX		= BIT(1),
+	MSG_EVENT	= BIT(2),
+	MSG_RXDATA	= BIT(3),
+	MSG_TXDATA	= BIT(4),
+	MSG_INIT	= BIT(5),
+	MSG_OAM_RX	= BIT(6),
+	MSG_OAM_TX	= BIT(7),
+	MSG_OAM_RXDATA	= BIT(8),
+	MSG_OAM_TXDATA	= BIT(9),
+	MSG_QOS		= BIT(10),
+	MSG_SWITCH	= BIT(11),
+	MSG_LOOPBACK	= BIT(12),
+	MSG_COC		= BIT(13),
+	MSG_MIB		= BIT(14),
+};
+
+#define tc_level(level, priv, type, fmt, args...)	\
+do {							\
+	if (priv->msg_enable & (type))			\
+		pr_##level##_ratelimited(fmt, ##args);	\
+} while (0)
+
+#define tc_dbg(priv, type, fmt, args...)		\
+	tc_level(debug, priv, type, fmt, ##args)
+#define tc_err(priv, type, fmt, args...)		\
+	tc_level(err, priv, type, fmt, ##args)
+#define tc_info(priv, type, fmt, args...)		\
+	tc_level(info, priv, type, fmt, ##args)
+
+#define TC_DEF_DBG	(MSG_INIT | MSG_SWITCH | MSG_EVENT | MSG_LOOPBACK)
+#define DUMP_HDR_SZ	32
+
+enum tc_dir {
+	US_DIR = 0,
+	DS_DIR = 1,
+};
+
+enum tc_status {
+	TC_RUN = 0,	/* TC loaded succesfully */
+	TC_INIT,	/* in Initialization */
+	NO_TC,		/* Init done, but NO TC loaded */
+	TC_SWITCHING,	/* TC is swiching */
+	TC_EXIT,	/* module is going to be unloadeds */
+	TC_ERR,
+};
+
+enum dsl_tc_mode {
+	TC_ATM_SL_MODE = 0, /* ATM Single line mode */
+	TC_PTM_SL_MODE = 1, /* PTM Single line mode */
+	TC_PTM_BND_MODE = 2, /* PTM Bonding mode */
+	TC_NONE_MODE,
+};
+
+enum tc_pkt_type {
+	ATM_SL_PKT = 0,
+	PTM_SL_PKT,
+	PTM_BOND_PKT,
+	ATM_OAM_PKT,
+};
+
+struct soc_cfg {
+	u32 txin_dbase;
+	u32 txin_dnum;
+	u32 txout_dbase;
+	u32 txout_dnum;
+	u32 rxin_dbase;
+	u32 rxin_dnum;
+	u32 rxout_dbase;
+	u32 rxout_dnum;
+	u32 desc_dw_sz;
+};
+
+struct tc_param {
+	unsigned int p2p:1;
+	unsigned int dfe_loopback:1;
+	unsigned int bonding_en:1;
+	unsigned int sharing_cdma_en:1;
+	unsigned int cdma_desc_loc:2;
+	unsigned int ps:1;
+	unsigned int res0:25;
+
+	unsigned int umt_period;
+	unsigned int qsb_tstep;
+	unsigned int qsb_tau;
+	unsigned int qsb_srvm;
+	unsigned int aal5r_max_pktsz;
+	unsigned int aal5r_min_pktsz;
+	unsigned int aal5s_max_pktsz;
+	unsigned int oam_prio;
+};
+
+struct cdma {
+	u32 chans;
+};
+
+struct tc_hw_ops {
+	/*PTM/ATM/BONDING callback functions */
+	void (*recv)(struct net_device *pdev, struct sk_buff *skb);
+	int (*get_qid)(struct net_device *pdev, struct sk_buff *skb,
+		void *vcc, uint32_t flags);
+	void (*irq_on)(u32 irq_no);
+	void (*irq_off)(u32 irq_no);
+	int (*showtime_enter)(const unsigned char idx,
+		struct port_cell_info *port_cell, void *xdata_addr);
+	int (*showtime_exit)(const unsigned char idx);
+	/*int (*tc_reset)(const unsigned char idx, u32 type);*/
+	int (*erb_addr_get)(const unsigned char idx,
+		unsigned int *data_addr, unsigned int *desc_addr);
+	int (*framer_request_en)(const unsigned char idx);
+
+	/*SoC callback functions */
+	int (*send)(struct net_device *pdev, struct sk_buff *skb,
+			int qid, enum tc_pkt_type type);
+	void *(*alloc)(size_t size, enum tc_dir dir);
+	void (*free)(dma_addr_t phyaddr, enum tc_dir dir);
+	int (*dev_reg)(struct net_device *pdev, char *dev_name,
+			int *subif_id, int flag);
+	void (*dev_unreg)(struct net_device *pdev, char *dev_name,
+			int subif_id, int flag);
+	/*umt init/exit including the corresponding DMA init/exit */
+	int (*umt_init)(u32 umt_id, u32 umt_period, u32 umt_dst);
+	void (*umt_exit)(u32 umt_id);
+	void (*umt_start)(u32 umt_id);
+	int (*soc_cfg_get)(struct soc_cfg *cfg, u32 umt_id);
+	void (*coc_req)(void);
+	void (*disable_us)(int en);
+	int (*get_mib)(struct net_device *pdev, struct rtnl_link_stats64 *stat);
+};
+
+enum fw_id {
+	FW_TX = 0,
+	FW_BONDING,
+	FW_RX,
+	FW_ATM,
+	FW_MAX
+};
+
+struct fw_info {
+	__be32 fw_id;
+	__be32 fw_size;
+};
+
+struct fw_ver_id {
+	/* DWORD 0 */
+	unsigned int family:4;
+	unsigned int package:4;
+	unsigned int major:8;
+	unsigned int mid:8;
+	unsigned int minor:8;
+
+	/* DWORD 1 */
+	unsigned int features;
+} __packed;
+
+struct fw_hdr {
+	/* header information */
+	struct fw_ver_id ptm_ver;
+	struct fw_ver_id atm_ver;
+	__be32 comp_id;
+	__be32 hdr_sz;
+	__be32 date;
+	__be32 res[9];
+	/* firmware information */
+	__be32 fw_num;
+	struct fw_info fw_info[FW_MAX];
+};
+
+struct fw_bin {
+	const struct firmware *fw;
+	struct fw_hdr fw_hdr;
+	const u8 *fw_ptr[FW_MAX];
+};
+
+struct tc_priv {
+	struct dc_ep_dev ep_dev[EP_MAX_NUM]; /* EP info from EP driver */
+	int ep_num; /* EP num, if two, Bonding feature will be enabled */
+	int showtime[EP_MAX_NUM]; /* showtime status */
+	enum tc_status tc_stat;
+	enum dsl_tc_mode tc_mode;
+	u32 tc_idx;
+	u32 msg_enable;
+	struct fw_bin fw;
+	struct proc_dir_entry *proc_dir;
+	struct tc_hw_ops tc_ops;
+	struct tc_param param;
+	struct soc_cfg cfg;
+	struct cdma dma;
+	void *priv; /* point to ATM/PTM TC structure */
+	u32 switch_exist;
+	spinlock_t tc_lock;
+};
+
+/**
+ * Common share struct for ATM/PTM/Bonding priv structure
+ */
+struct tc_comm {
+	struct dc_ep_dev *ep; /* This should be always the first one */
+	struct tc_priv *tc_priv;
+	u32 ep_id;
+};
+
+/* p is a pointer to ATM/PTM/Bonding priv structure */
+#define to_tcpriv(p)	(((struct tc_comm __force *)p)->tc_priv)
+#define to_epdev(p)	(((struct tc_comm __force *)p)->ep)
+
+
+extern void ptm_tc_unload(enum dsl_tc_mode);
+extern void ptm_tc_load(struct tc_priv *, u32, enum dsl_tc_mode);
+extern void ptm_exit(void);
+extern void tc_request(u32, enum dsl_tc_mode);
+extern void tc_unload(struct tc_priv *);
+extern void tc_load(struct tc_priv *, u32, enum dsl_tc_mode);
+extern void tc_get_drv_version(const char **, const char **);
+
+extern int atm_tc_load(struct tc_priv *, u32 , enum dsl_tc_mode);
+extern void atm_tc_unload(void);
+extern void atm_exit(void);
+#endif /* __TC_MAIN_H__ */
+
diff --git a/drivers/net/ethernet/intel/vrx518/tc/inc/tc_proc.h b/drivers/net/ethernet/intel/vrx518/tc/inc/tc_proc.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/inc/tc_proc.h
@@ -0,0 +1,82 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#ifndef __TC_PROC_H__
+#define __TC_PROC_H__
+
+#define TC_PROC_DIR "driver/vrx518"
+#define TC_PROC_ATM_DIR "atm"
+#define TC_PROC_PTM_DIR "ptm"
+enum {
+	PPE_PROC_READ = 1,
+	PPE_PROC_WRITE
+};
+
+#define set_vrx_dbg_flag(v, e, f) do {	\
+	if (e > 0)			\
+		v |= (uint32_t)(f);	\
+	else				\
+		v &= (uint32_t) (~f); }	\
+	while (0)
+
+struct tc_proc_list {
+	char proc_name[32];
+	umode_t mode;
+	const struct file_operations *fops;
+	int is_folder;
+};
+
+#define CW_PAGE_SIZE 17
+struct atm_cw_ctrl_t {
+	unsigned int	state:1;
+	unsigned int	bad:1;
+	unsigned int	ber:9;
+	unsigned int	drop:1;
+	unsigned int	idle:1;
+	unsigned int	csp:9;
+	unsigned int	bsm:1;
+	unsigned int	cvc:8;
+	unsigned int	cvm:1;
+};
+
+struct ptm_cw_ctrl_t {
+	unsigned int	state:1;
+	unsigned int	bad:1;
+	unsigned int	ber:9;
+	unsigned int	spos:7;
+	unsigned int	ffbn:7;
+	unsigned int	shrt:1;
+	unsigned int	preempt:1;
+	unsigned int	cwer:2;
+	unsigned int	cwid:3;
+};
+
+extern int tc_proc_init(struct tc_priv *);
+extern void tc_proc_exit(struct tc_priv *);
+extern int ptm_tc_proc_init(void *);
+extern void ptm_tc_proc_exit(void *);
+extern int atm_tc_proc_init(void *);
+extern int atm_tc_proc_exit(void *);
+extern int vrx_split_buffer(char *, char **, int);
+extern int vrx_strcmpi(char const *, char const *);
+
+#endif /*__TC_PROC_H__ */
diff --git a/drivers/net/ethernet/intel/vrx518/tc/platform/grx500_plat.c b/drivers/net/ethernet/intel/vrx518/tc/platform/grx500_plat.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/platform/grx500_plat.c
@@ -0,0 +1,896 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/atomic.h>
+#include <linux/uaccess.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/wait.h>
+#include <linux/seq_file.h>
+#include <linux/printk.h>
+#include <linux/etherdevice.h>
+#include <linux/workqueue.h>
+#include <linux/ltq_hwmcpy.h>
+#include <net/dsl_tc.h>
+#include <net/lantiq_cbm.h>
+#include <net/lantiq_cbm_api.h>
+#include <lantiq_dmax.h>
+#include <net/datapath_api.h>
+
+
+#include "../inc/tc_main.h"
+#include "../inc/reg_addr.h"
+
+
+#define DS_DEF_DESC_NUM		2048
+
+/* PMAC configuration */
+#define PMAC_SPPID		0xF
+#define PMAC_SPPID_S		4
+#define PMAC_PMAP_EN		0x1
+#define PMAC_PMAP_EN_S		0x7
+#define PMAC_FCS_INS		0x1
+#define PMAC_FCS_INS_S		0x7
+
+/* skb port configuration */
+#define SKB_PORT_ID		0xF
+#define SKB_PORT_ID_S		8
+#define SKB_PORT_SUBID		0x7FFF
+#define SKB_PORT_SUBID_S	0
+
+struct plat_dma {
+	u32 chan; /* CHAN IID */
+	u32 dma_chan; /* CONTROLLER/PORT/CHAN ID */
+	u32 ds_dnum; /* DS descriptor number */
+};
+
+struct plat_umt {
+	u32 id;
+	u32 cbm_id;
+	u32 period;
+	u32 dst;
+};
+
+struct tc_req {
+	struct work_struct work;
+	u32 id;
+	enum dsl_tc_mode tc_mode;
+};
+
+struct tc_coc {
+	enum ltq_cpufreq_state coc_stat;
+	struct tasklet_struct coc_task;
+};
+
+struct plat_priv {
+	struct tc_priv *tc_priv;
+	struct module *owner;
+	u32 port_id;
+	dp_cb_t	cb;
+	struct plat_umt umt[EP_MAX_NUM];
+	struct plat_dma dma[EP_MAX_NUM];
+	struct ltq_mei_atm_showtime_info dsl_ops;
+	struct tc_req req_work;
+	struct tc_coc coc;
+	u32 cbm_pid;
+};
+
+static struct plat_priv *g_plat_priv;
+static struct module tc_mod;
+
+void *ppa_callback_get(e_ltq_mei_cb_type type)
+{
+	struct plat_priv *priv;
+
+	priv = g_plat_priv;
+	if (WARN_ON(priv == NULL))
+		return NULL;
+
+	switch (type) {
+	case LTQ_MEI_SHOWTIME_CHECK:
+		return priv->dsl_ops.check_ptr;
+	case LTQ_MEI_SHOWTIME_ENTER:
+		return priv->dsl_ops.enter_ptr;
+	case LTQ_MEI_SHOWTIME_EXIT:
+		return priv->dsl_ops.exit_ptr;
+	case LTQ_MEI_TC_REQUEST:
+		return priv->dsl_ops.req_tc_ptr;
+	case LTQ_MEI_TC_RESET:
+		return priv->dsl_ops.tc_reset_ptr;
+	case LTQ_MEI_ERB_ADDR_GET:
+		return priv->dsl_ops.erb_addr_ptr;
+
+	default:
+		tc_err(priv->tc_priv, MSG_INIT,
+			"get mei unknown function type %d\n", type);
+		return NULL;
+	}
+}
+EXPORT_SYMBOL(ppa_callback_get);
+
+int ppa_callback_set(e_ltq_mei_cb_type type, void *func)
+{
+	struct plat_priv *priv;
+
+	priv = g_plat_priv;
+	if (WARN_ON(priv == NULL))
+		return -ENODEV;
+
+	switch (type) {
+	/* save func address within global struct */
+	case LTQ_MEI_SHOWTIME_CHECK:
+		priv->dsl_ops.check_ptr = func;
+		break;
+	case LTQ_MEI_SHOWTIME_ENTER:
+		priv->dsl_ops.enter_ptr = func;
+		break;
+	case LTQ_MEI_SHOWTIME_EXIT:
+		priv->dsl_ops.exit_ptr = func;
+		break;
+	case LTQ_MEI_TC_REQUEST:
+		priv->dsl_ops.req_tc_ptr = func;
+		break;
+	case LTQ_MEI_TC_RESET:
+		priv->dsl_ops.tc_reset_ptr = func;
+		break;
+	case LTQ_MEI_ERB_ADDR_GET:
+		priv->dsl_ops.erb_addr_ptr = func;
+		break;
+
+	default:
+		tc_err(priv->tc_priv, MSG_INIT,
+			"set mei unknown function type: %d\n", type);
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ppa_callback_set);
+
+size_t plat_priv_sz(void)
+{
+	return sizeof(struct plat_priv);
+}
+
+static inline void *tc_plat_priv(struct tc_priv *priv)
+{
+	return (char *)priv + ALIGN(sizeof(struct tc_priv), TCPRIV_ALIGN);
+}
+
+static inline struct tc_priv *plat_to_tcpriv(void)
+{
+	return g_plat_priv->tc_priv;
+}
+
+static int32_t plat_rx(struct net_device *rxdev, struct net_device *txdev,
+	struct sk_buff *skb, int32_t len)
+{
+	int32_t err;
+	struct tc_priv *tc_priv = plat_to_tcpriv();
+
+	if (unlikely(!tc_priv)) {
+		tc_dbg(tc_priv, MSG_RX,
+			"Invalid TC private data\n");
+		err = -EINVAL;
+		goto err1;
+	}
+	/* remove PMAC header */
+	if (tc_priv->tc_mode != TC_ATM_SL_MODE)
+		skb_pull(skb, PMAC_SIZE);
+
+	tc_priv->tc_ops.recv(rxdev, skb);
+	return 0;
+
+err1:
+	dev_kfree_skb_any(skb);
+
+	return err;
+}
+
+static int32_t plat_get_subifid(struct net_device *dev, struct sk_buff *skb,
+	void *subif_data, uint8_t dst_mac[MAX_ETH_ALEN],
+	dp_subif_t *subif, uint32_t flags)
+{
+	int qid;
+	struct tc_priv *priv = plat_to_tcpriv();
+
+	qid = priv->tc_ops.get_qid(dev, skb, subif_data, flags);
+	if (qid < 0)
+		return qid;
+	else
+		subif->subif = qid;
+
+	return 0;
+}
+
+static void plat_coc_tasklet(unsigned long arg)
+{
+	/* change state to D0 */
+	if (g_plat_priv->coc.coc_stat == LTQ_CPUFREQ_PS_D0)
+		return;
+
+	g_plat_priv->coc.coc_stat = LTQ_CPUFREQ_PS_D0;
+	/* call datapath to inform about the new state */
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_CPUFREQ)
+	dp_coc_new_stat_req(LTQ_CPUFREQ_PS_D0, DP_COC_REQ_VRX318);
+#endif
+}
+
+static void plat_coc_req(void)
+{
+	tasklet_schedule(&g_plat_priv->coc.coc_task);
+}
+
+static int32_t plat_coc_stat(enum ltq_cpufreq_state new_state,
+	enum ltq_cpufreq_state old_state, uint32_t flags)
+{
+	struct tc_priv *priv = plat_to_tcpriv();
+	tc_dbg(priv, MSG_COC,
+		"COC current state: %d, new state: %d, old state: %d\n",
+		g_plat_priv->coc.coc_stat, new_state, old_state);
+
+	if (g_plat_priv->coc.coc_stat != new_state) {
+		g_plat_priv->coc.coc_stat = new_state;
+
+		if (new_state == LTQ_CPUFREQ_PS_D3) {
+			/* Enable interrupt for DS packet */
+			priv->tc_ops.irq_on(MBOX_PKT_RX);
+		} else {
+			/* Disable interrupt for DS packet */
+			priv->tc_ops.irq_off(MBOX_PKT_RX);
+		}
+	}
+
+	return 0;
+}
+
+static int plat_send(struct net_device *pdev, struct sk_buff *skb,
+	int qid, enum tc_pkt_type type)
+{
+	struct plat_priv *priv = g_plat_priv;
+	dp_subif_t dp_id;
+	u32 flags;
+
+	dp_id.port_id = priv->port_id;
+	dp_id.subif = qid;
+	flags = 0;
+
+	set_mask_bit(skb->DW1, priv->port_id, SKB_PORT_ID, SKB_PORT_ID_S);
+	set_mask_bit(skb->DW0, qid, SKB_PORT_SUBID, SKB_PORT_SUBID_S);
+
+	if (type == PTM_BOND_PKT)
+		flags = DP_TX_DSL_FCS;
+	if (type == ATM_OAM_PKT)
+		flags = DP_TX_OAM;
+
+	return dp_xmit(pdev, &dp_id, skb, skb->len, flags);
+}
+
+/* return virtual address */
+static void *plat_mem_alloc(size_t size, enum tc_dir dir)
+{
+	if (dir == US_DIR && size > CBM_STD_BUF_SIZE) {
+		tc_err(plat_to_tcpriv(), MSG_INIT,
+			"US alloc size(%d) bigger than CBM STD SIZE %d\n",
+			size, CBM_STD_BUF_SIZE);
+		return NULL;
+	}
+
+	if (dir == US_DIR) { /* ALLOC CBM buffer */
+		return cbm_buffer_alloc(0, 0);
+	} else {
+		return kmalloc(size, GFP_KERNEL);
+	}
+}
+
+static void plat_mem_free(u32 phy_addr, enum tc_dir dir)
+{
+	void *mem;
+
+	if (dir == US_DIR)
+		cbm_buffer_free(0, phy_addr, 1);
+	else {
+		mem = (void * __force)__va(phy_addr);
+		kfree(mem);
+	}
+}
+
+static void pmac_cfg_set(u32 pid, enum dsl_tc_mode tc_mode)
+{
+	struct dp_pmac_cfg pmac_cfg;
+
+	memset(&pmac_cfg, 0, sizeof(pmac_cfg));
+
+	if (tc_mode >= TC_NONE_MODE)
+		return;
+
+	pmac_cfg.eg_pmac_flags = EG_PMAC_F_PMAC |
+			EG_PMAC_F_FCS | EG_PMAC_F_TCENA;
+
+	pmac_cfg.eg_pmac.pmac = 0;
+	pmac_cfg.eg_pmac.tc_enable = 1;
+	pmac_cfg.eg_pmac.fcs = (tc_mode == TC_PTM_BND_MODE) ? 1 : 0;
+
+	pmac_cfg.ig_pmac_flags = IG_PMAC_F_PRESENT | IG_PMAC_F_SPID
+				| IG_PMAC_F_PMACHDR3 | IG_PMAC_F_PMACHDR5;
+
+	if (tc_mode == TC_PTM_BND_MODE)
+		pmac_cfg.ig_pmac.tx_dma_chan = g_plat_priv->dma[1].chan;
+	else
+		pmac_cfg.ig_pmac.tx_dma_chan = g_plat_priv->dma[0].chan;
+
+	pmac_cfg.ig_pmac.pmac = 0;
+	pmac_cfg.ig_pmac.def_pmac_src_port = 1;
+	pmac_cfg.ig_pmac.def_pmac_hdr[2] = SM(pid, PMAC_SPPID);
+	if (tc_mode == TC_ATM_SL_MODE) /* Packet has NO FCS in ATM mode */
+		pmac_cfg.ig_pmac.def_pmac_hdr[4] = SM(0, PMAC_FCS_INS);
+	else
+		pmac_cfg.ig_pmac.def_pmac_hdr[4] = SM(1, PMAC_FCS_INS);
+
+	dp_pmac_set(pid, &pmac_cfg);
+}
+
+static int plat_dp_init(struct plat_priv *priv, const char *drv_name)
+{
+	struct tc_priv *tcpriv;
+	int dp_id;
+	int err;
+	int flags;
+
+	tcpriv = priv->tc_priv;
+	priv->owner = THIS_MODULE;
+	if (!priv->owner) {
+		memset(&tc_mod.name, 0, sizeof(tc_mod.name));
+		snprintf(tc_mod.name, MODULE_NAME_LEN - 1, "%s", drv_name);
+		priv->owner = &tc_mod;
+	}
+
+	flags = DP_F_FAST_DSL | DP_F_FAST_WLAN;
+	if (tcpriv->ep_num > 1)
+		flags |= DP_F_DSL_BONDING;
+	dp_id  = dp_alloc_port(priv->owner, NULL, 0, 0, NULL, flags);
+	if (dp_id == DP_FAILURE) {
+		tc_err(tcpriv, MSG_INIT, "dp_alloc_port fail!\n");
+		return -ENOMEM;
+	}
+	priv->port_id		= dp_id;
+	priv->cb.stop_fn	= NULL;
+	priv->cb.restart_fn	= NULL;
+	priv->cb.rx_fn		= plat_rx;
+	priv->cb.get_subifid_fn = plat_get_subifid;
+	priv->cb.dp_coc_confirm_stat_fn = plat_coc_stat;
+	priv->coc.coc_stat	= LTQ_CPUFREQ_PS_D0;
+
+	if (dp_register_dev(priv->owner, dp_id, &priv->cb, 0) != DP_SUCCESS) {
+		tc_err(tcpriv, MSG_INIT,
+			"dp_register_dev failed for port id %d", dp_id);
+		err = -ENODEV;
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	dp_alloc_port(priv->owner, NULL, 0, dp_id, NULL, DP_F_DEREGISTER);
+	return err;
+}
+
+static void plat_dp_exit(struct plat_priv *priv)
+{
+	dp_register_dev(priv->owner, priv->port_id, NULL, DP_F_DEREGISTER);
+	dp_alloc_port(priv->owner, NULL, 0,
+		priv->port_id, NULL, DP_F_DEREGISTER);
+}
+
+static void plat_umt_start(u32 id)
+{
+	struct plat_dma *dma;
+	struct plat_umt *umt;
+
+	/*Reset CBM port */
+	cbm_port_quick_reset(g_plat_priv->cbm_pid, CBM_PORT_F_DEQUEUE_PORT);
+
+	dma = &g_plat_priv->dma[id];
+	ltq_dma_chan_on(dma->dma_chan);
+
+	umt = &g_plat_priv->umt[id];
+	ltq_umt_enable(umt->id, g_plat_priv->port_id, UMT_ENABLE);
+}
+
+static int plat_dma_init(u32 id)
+{
+	struct plat_dma *dma;
+	struct plat_priv *priv;
+	int ret;
+
+	priv = g_plat_priv;
+	dma = &priv->dma[id];
+	dma->ds_dnum = DS_DEF_DESC_NUM;
+
+	ret = ltq_request_dma(dma->dma_chan, priv->owner->name);
+	if (ret < 0) {
+		tc_err(priv->tc_priv, MSG_INIT, "request DMA fail!\n");
+		return ret;
+	}
+
+	ret = ltq_dma_chan_desc_alloc(dma->dma_chan, dma->ds_dnum);
+	if (ret < 0) {
+		tc_err(priv->tc_priv, MSG_INIT,
+			"Alloc dma desc (%d)fail!\n", dma->ds_dnum);
+		goto err1;
+	}
+	ltq_dma_chan_off(dma->dma_chan);
+
+	return 0;
+err1:
+	ltq_free_dma(dma->dma_chan);
+	return ret;
+}
+
+/* init UMT but not started */
+static int plat_umt_init(u32 id, u32 period, u32 dst_addr)
+{
+	struct plat_priv *priv;
+	struct plat_umt *umt;
+	u32 dma_ctrlid;
+	u32 dma_cid;
+	u32 cbm_id;
+	int ret;
+
+	if (WARN_ON(id >= EP_MAX_NUM))
+		return -EINVAL;
+
+	priv = g_plat_priv;
+	umt = &priv->umt[id];
+
+	ret = cbm_get_wlan_umt_pid(priv->port_id, &cbm_id);
+	if (ret < 0) {
+		tc_err(priv->tc_priv, MSG_INIT, "Get CBM pid fail!\n");
+		goto err1;
+	}
+
+	umt->cbm_id = cbm_id + id;
+	ret = ltq_umt_request(priv->port_id, umt->cbm_id,
+		&dma_ctrlid, &dma_cid, &umt->id);
+	if (ret < 0) {
+		tc_err(priv->tc_priv, MSG_INIT, "Requst UMT port fail!\n");
+		goto err1;
+	}
+	/* FIXME: UMT driver should directly return dma_chan,
+	 * wave500 dp change required as well
+	 */
+	tc_info(priv->tc_priv, MSG_INIT,
+		"id: %d, CBM ID: %d, UMT ID: %d, DMA CTRLID: %d, DMA CID: %d\n",
+		id, umt->cbm_id, umt->id, dma_ctrlid, dma_cid);
+	priv->dma[id].dma_chan = _DMA_C(dma_ctrlid, DMA1TX_PORT, dma_cid);
+	priv->dma[id].chan = dma_cid;
+	umt->period = period;
+	umt->dst = dst_addr;
+	plat_dma_init(id);
+
+	ltq_umt_set_mode(umt->id, priv->port_id, UMT_SELFCNT_MODE,
+		UMT_MSG0_MSG1, umt->dst, umt->period, UMT_DISABLE);
+	if (ret < 0) {
+		tc_err(priv->tc_priv, MSG_INIT, "UMT mode set fail!\n");
+		goto err2;
+	}
+
+	return 0;
+err2:
+	ltq_umt_release(umt->id, priv->port_id);
+err1:
+	return -ENODEV;
+}
+
+static void plat_dma_exit(u32 id)
+{
+	struct plat_dma *dma;
+
+	dma = &g_plat_priv->dma[id];
+
+	ltq_dma_chan_off(dma->dma_chan);
+	ltq_dma_chan_reset(dma->dma_chan);
+	ltq_dma_chan_desc_free(dma->dma_chan);
+	ltq_free_dma(dma->dma_chan);
+	memset(dma, 0, sizeof(*dma));
+}
+
+static void plat_umt_exit(u32 id)
+{
+	struct plat_umt *umt;
+	struct plat_priv *priv;
+
+	if (WARN_ON(id >= EP_MAX_NUM))
+		return;
+
+	priv = g_plat_priv;
+	plat_dma_exit(id);
+	umt = &priv->umt[id];
+	udelay(umt->period * 2);
+	ltq_umt_release(umt->id, priv->port_id);
+	memset(umt, 0, sizeof(*umt));
+}
+
+static int plat_soc_cfg_get(struct soc_cfg *cfg, u32 id)
+{
+	struct cbm_dq_port_res cbm_res;
+	struct plat_priv *priv;
+	int ret;
+
+	priv = g_plat_priv;
+	ret = cbm_dequeue_port_resources_get(priv->port_id, &cbm_res, 0);
+	if (ret < 0) {
+		tc_err(priv->tc_priv, MSG_INIT, "Get CBM DQ port res fail!\n");
+		return -ENODEV;
+	}
+	if (cbm_res.num_deq_ports < id + 1) {
+		tc_err(priv->tc_priv, MSG_INIT,
+			"CBM port(%d) less than required(%d)\n",
+			cbm_res.num_deq_ports, id + 1);
+		kfree(cbm_res.deq_info);
+		return -ENODEV;
+	}
+	pr_info("free base: 0x%x, free num: %d, port num: %d\n",
+		(u32)cbm_res.cbm_buf_free_base,
+		cbm_res.num_free_entries, cbm_res.num_deq_ports);
+	pr_info("port_no: %d, deq dbase: 0x%x, dnum: %d, free base: 0x%x, free num: %d\n",
+		cbm_res.deq_info[0].port_no,
+		(u32)cbm_res.deq_info[0].cbm_dq_port_base,
+		cbm_res.deq_info[0].num_desc,
+		(u32)cbm_res.cbm_buf_free_base,
+		cbm_res.num_free_entries);
+	priv->cbm_pid = cbm_res.deq_info[0].port_no;
+	cfg->txin_dbase = (u32 __force)cbm_res.deq_info[0].cbm_dq_port_base;
+	cfg->txin_dbase = RPHYSADDR(cfg->txin_dbase);
+	cfg->txin_dnum = cbm_res.deq_info[0].num_desc;
+	cfg->txout_dbase = (u32 __force)cbm_res.cbm_buf_free_base;
+	cfg->txout_dbase = RPHYSADDR(cfg->txout_dbase);
+	cfg->txout_dnum = cbm_res.num_free_entries;
+	cfg->rxout_dbase
+		= ltq_dma_chan_get_desc_phys_base(priv->dma[id].dma_chan);
+	cfg->rxout_dnum = priv->dma[id].ds_dnum;
+	cfg->desc_dw_sz = 4;
+
+	tc_info(priv->tc_priv, MSG_INIT,
+		"id: %d, txin(0x%x: %d), txout(0x%x: %d), rxin(0x%x: %d), rxout(0x%x: %d), dma ch: %d\n",
+		id, cfg->txin_dbase, cfg->txin_dnum,
+		cfg->txout_dbase, cfg->txout_dnum,
+		cfg->rxin_dbase, cfg->rxout_dnum,
+		cfg->rxout_dbase, cfg->rxout_dnum, priv->dma[id].chan);
+
+	kfree(cbm_res.deq_info);
+	return 0;
+}
+
+static int plat_open(struct net_device *pdev, char *dev_name,
+		int *subif, int flag)
+{
+	struct plat_priv *priv;
+	dp_subif_t subif_id;
+	int ret;
+
+	if (WARN_ON(pdev == NULL && dev_name == NULL))
+		return -ENODEV;
+
+	priv = g_plat_priv;
+	subif_id.port_id = priv->port_id;
+	subif_id.subif = -1;
+
+	ret = dp_register_subif(priv->owner, pdev, dev_name, &subif_id, 0);
+	if (ret < 0) {
+		tc_err(priv->tc_priv, MSG_INIT, "Register subif fail!\n");
+		return ret;
+	}
+	*subif = subif_id.subif;
+
+	return 0;
+}
+
+static void plat_close(struct net_device *pdev, char *dev_name,
+		int subif, int flag)
+{
+	struct plat_priv *priv;
+	dp_subif_t subif_id;
+	int ret;
+
+	if (WARN_ON(pdev == NULL && dev_name == NULL))
+		return;
+
+	/* cbm_dp_q_enable(priv->port_id, -1,
+			priv->cbm_pid, -1, 0, 0, CBM_Q_F_DISABLE | CBM_Q_F_FLUSH); */
+
+	priv = g_plat_priv;
+	subif_id.port_id = priv->port_id;
+	subif_id.subif = subif;
+
+	ret = dp_register_subif(priv->owner, pdev, dev_name,
+		&subif_id, DP_F_DEREGISTER);
+	if (ret < 0) {
+		tc_err(priv->tc_priv, MSG_INIT,
+			"Unregister pid(%d) subif(%d) fail!\n",
+			priv->port_id, subif);
+	}
+
+	return;
+}
+
+static void plat_disable_us(int en)
+{
+	struct plat_priv *priv;
+	u32 flags;
+
+	priv = g_plat_priv;
+	flags = DP_F_FAST_WLAN | DP_F_FAST_DSL;
+
+	if (en)
+		cbm_dp_enable(priv->owner, priv->port_id,
+				CBM_PORT_F_DISABLE, flags);
+	else
+		cbm_dp_enable(priv->owner, priv->port_id, 0, flags);
+}
+
+static int plat_get_mib(struct net_device *pdev,
+			struct rtnl_link_stats64 *stat)
+{
+#if IS_ENABLED(CONFIG_LTQ_DATAPATH_MIB)
+	dp_get_netif_stats(pdev, NULL, stat, 0);
+	return 0;
+#else
+	return -ENOTSUPP;
+#endif
+}
+
+static void plat_tc_ops_setup(struct tc_priv *priv)
+{
+	priv->tc_ops.send = plat_send;
+	priv->tc_ops.alloc = plat_mem_alloc;
+	priv->tc_ops.free = plat_mem_free;
+	priv->tc_ops.dev_reg = plat_open;
+	priv->tc_ops.dev_unreg = plat_close;
+	priv->tc_ops.umt_init = plat_umt_init;
+	priv->tc_ops.umt_exit = plat_umt_exit;
+	priv->tc_ops.umt_start = plat_umt_start;
+	priv->tc_ops.soc_cfg_get = plat_soc_cfg_get;
+	priv->tc_ops.coc_req = plat_coc_req;
+	priv->tc_ops.disable_us = plat_disable_us;
+	priv->tc_ops.get_mib = plat_get_mib;
+}
+
+static int showtime_enter(const unsigned char idx,
+		struct port_cell_info *cell_info, void *data)
+{
+	struct tc_priv *priv;
+
+	if (WARN_ON(idx >= EP_MAX_NUM || cell_info == NULL))
+		return -EINVAL;
+
+	priv = g_plat_priv->tc_priv;
+	if (priv->showtime[idx] == 1)
+		return 0;
+
+	priv->showtime[idx] = 1;
+
+	spin_lock_bh(&priv->tc_lock);
+	if (priv->tc_stat == TC_RUN && priv->tc_ops.showtime_enter != NULL)
+		priv->tc_ops.showtime_enter(idx, cell_info, data);
+	spin_unlock_bh(&priv->tc_lock);
+
+	return 0;
+}
+
+static int showtime_exit(const unsigned char idx)
+{
+	struct tc_priv *priv;
+
+	if (WARN_ON(idx >= EP_MAX_NUM))
+		return -EINVAL;
+
+	priv = g_plat_priv->tc_priv;
+
+	if (!priv->showtime[idx])
+		return 0;
+
+	priv->showtime[idx] = 0;
+
+	spin_lock_bh(&priv->tc_lock);
+	if (priv->tc_stat == TC_RUN && priv->tc_ops.showtime_exit != NULL)
+		priv->tc_ops.showtime_exit(idx);
+	spin_unlock_bh(&priv->tc_lock);
+
+	return 0;
+}
+
+static int plat_erb_addr_get(const unsigned char idx,
+	unsigned int *data_addr, unsigned int *desc_addr)
+{
+	struct tc_priv *priv;
+
+	if (WARN_ON(idx >= EP_MAX_NUM || !data_addr || !desc_addr))
+		return -EINVAL;
+
+	priv = g_plat_priv->tc_priv;
+
+	if (priv->tc_stat == TC_RUN && priv->tc_ops.erb_addr_get != NULL)
+		return priv->tc_ops.erb_addr_get(idx, data_addr, desc_addr);
+	else {
+		/* MEI driver request both values has */
+		/* to be set to zero in error condition */
+		*data_addr = *desc_addr = 0;
+		tc_err(priv, MSG_EVENT,
+			"erb_addr_get not supported or timing not correct!, tc stat: %u\n",
+			(u32)priv->tc_stat);
+		return -1;
+	}
+
+	return -1;
+}
+
+static void plat_tc_req_workqueue(struct work_struct *work)
+{
+	struct tc_req *req_work;
+
+	req_work = container_of(work, struct tc_req, work);
+	tc_request(req_work->id, req_work->tc_mode);
+	pmac_cfg_set(g_plat_priv->port_id, req_work->tc_mode);
+}
+
+static int plat_tc_request(const unsigned char id,
+		mei_tc_request_type tc_type, int is_bonding)
+{
+	enum dsl_tc_mode mode;
+	struct tc_priv *priv;
+	int i;
+
+	if (WARN_ON(id >= EP_MAX_NUM))
+		return -EINVAL;
+
+	priv = g_plat_priv->tc_priv;
+
+	switch (tc_type) {
+	case MEI_TC_REQUEST_OFF:
+		mode = TC_NONE_MODE;
+		for (i = 0; i < priv->ep_num; i++) {
+			if (priv->showtime[i] == 1)
+				showtime_exit(i);
+		}
+		break;
+	case MEI_TC_REQUEST_ATM:
+		mode = TC_ATM_SL_MODE;
+		break;
+	case MEI_TC_REQUEST_PTM:
+		if (is_bonding)
+			mode = TC_PTM_BND_MODE;
+		else
+			mode = TC_PTM_SL_MODE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tc_dbg(priv, MSG_EVENT,
+		"%s: dsl id: %d, mode: %d, tc_mode: %d, tc_idx: %d\n",
+		__func__, id, mode, priv->tc_mode, priv->tc_idx);
+
+	if (mode == priv->tc_mode) {
+		if (((((mode == TC_PTM_SL_MODE) || (mode == TC_ATM_SL_MODE))
+			&& (id == priv->tc_idx)) || (mode == TC_PTM_BND_MODE))
+			&& (priv->tc_ops.framer_request_en != NULL)) {
+			if (!priv->tc_ops.framer_request_en(id))
+				return 0;
+		}
+	}
+
+	spin_lock(&priv->tc_lock);
+	if (priv->tc_stat != TC_RUN && priv->tc_stat != NO_TC) {
+		tc_err(priv, MSG_SWITCH,
+			"TC status(%d) not allowed to switch\n", priv->tc_stat);
+		spin_unlock(&priv->tc_lock);
+		return -1;
+	}
+	priv->tc_stat = TC_SWITCHING;
+	spin_unlock(&priv->tc_lock);
+
+	g_plat_priv->req_work.id = id;
+	g_plat_priv->req_work.tc_mode = mode;
+	queue_work(system_wq, &g_plat_priv->req_work.work);
+
+	return 0;
+}
+
+void simu_tc_request(const u8 id, int type)
+{
+	switch (type) {
+	case TC_NONE_MODE:
+		plat_tc_request(id, MEI_TC_REQUEST_OFF, 0);
+		break;
+	case TC_ATM_SL_MODE:
+		plat_tc_request(id, MEI_TC_REQUEST_ATM, 0);
+		break;
+	case TC_PTM_SL_MODE:
+		plat_tc_request(id, MEI_TC_REQUEST_PTM, 0);
+		break;
+	case TC_PTM_BND_MODE:
+		plat_tc_request(id, MEI_TC_REQUEST_PTM, 1);
+		break;
+	}
+}
+
+static inline void plat_dsl_ops_setup(void)
+{
+	ppa_callback_set(LTQ_MEI_SHOWTIME_ENTER, showtime_enter);
+	ppa_callback_set(LTQ_MEI_SHOWTIME_EXIT, showtime_exit);
+	ppa_callback_set(LTQ_MEI_TC_REQUEST, plat_tc_request);
+	ppa_callback_set(LTQ_MEI_ERB_ADDR_GET, plat_erb_addr_get);
+}
+
+static inline void plat_dsl_ops_exit(void)
+{
+	ppa_callback_set(LTQ_MEI_SHOWTIME_ENTER, NULL);
+	ppa_callback_set(LTQ_MEI_SHOWTIME_EXIT, NULL);
+	ppa_callback_set(LTQ_MEI_TC_REQUEST, NULL);
+	ppa_callback_set(LTQ_MEI_ERB_ADDR_GET, NULL);
+}
+
+int platform_init(struct tc_priv *tc_priv, const char *drv_name)
+{
+	struct plat_priv *priv;
+	int ret;
+
+	priv = (struct plat_priv *)tc_plat_priv(tc_priv);
+	priv->tc_priv = tc_priv;
+	g_plat_priv = priv;
+
+	ret = plat_dp_init(priv, drv_name);
+	if (ret < 0)
+		goto err1;
+
+	INIT_WORK(&priv->req_work.work, plat_tc_req_workqueue);
+	tasklet_init(&priv->coc.coc_task, plat_coc_tasklet, 0);
+	plat_tc_ops_setup(tc_priv);
+	plat_dsl_ops_setup();
+
+	return 0;
+
+err1:
+	g_plat_priv = NULL;
+	return ret;
+}
+
+void platform_dsl_exit(void)
+{
+	plat_dsl_ops_exit();
+	cancel_work_sync(&g_plat_priv->req_work.work);
+}
+
+void platform_exit(void)
+{
+	tasklet_kill(&g_plat_priv->coc.coc_task);
+	plat_dp_exit(g_plat_priv);
+	g_plat_priv = NULL;
+}
diff --git a/drivers/net/ethernet/intel/vrx518/tc/ptm_tc.c b/drivers/net/ethernet/intel/vrx518/tc/ptm_tc.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/ptm_tc.c
@@ -0,0 +1,3042 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#define DEBUG
+#define pr_fmt(fmt) KBUILD_MODNAME ":%s: " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/atomic.h>
+#include <linux/uaccess.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/wait.h>
+#include <linux/seq_file.h>
+#include <linux/printk.h>
+#include <linux/etherdevice.h>
+#include <net/dsl_tc.h>
+#include <net/datapath_proc_api.h>
+
+#include "inc/tc_main.h"
+#include "inc/reg_addr.h"
+#include "inc/tc_common.h"
+#include "inc/tc_api.h"
+#include "inc/ptm_tc.h"
+#include "inc/tc_proc.h"
+
+#include "inc/fw/unified_qos_ds_base_vrx518_be.h"
+#include "inc/fw/vrx518_addr_def.h"
+#include "inc/fw/vrx518_ds_be.h"
+#include "inc/fw/vrx518_ppe_fw.h"
+#include "inc/fw/vr9_bonding_fw_data_structure_base_vrx518_be.h"
+
+
+static struct ptm_priv *g_ptm_priv;
+static struct ptm_ep_priv g_ep_priv[BOND_MAX];
+
+static const u32 tx_kvec[] = {
+	0x90111293, 0x14959617, 0x18999A1B, 0x9C1D1E9F,
+	0xA02122A3, 0x24A5A627, 0x28A9AA2B, 0xAC2D2EAF,
+	0x30B1B233, 0xB43536B7, 0xB8393ABB, 0x3CBDBE3F,
+	0xC04142C3, 0x44C5C647, 0x48C9CA4B, 0xCC4D4ECF
+};
+static const u32 def_outq_map[OUTQ_PNUM] = {0x1, 0xFE};
+static const char ptm_drv_name[] = "PTM SL";
+static const char ptm_bond_name[][IFNAMSIZ] = {"PTM US BOND", "PTM DS BOND"};
+
+/*Function Declaration */
+static int ptm_erb_addr_get(const unsigned char idx,
+	unsigned int *data_addr, unsigned int *desc_addr);
+
+
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	*(u32 *)dst = *(const u32 *)src;
+	*(u16 *)(dst + 4) = *(const u16 *)(src + 4);
+#else
+	u16 *a = (u16 *)dst;
+	const u16 *b = (const u16 *)src;
+
+	a[0] = b[0];
+	a[1] = b[1];
+	a[2] = b[2];
+#endif
+}
+
+static inline int is_ptm_sl(struct ptm_ep_priv *priv)
+{
+	if (priv->tc_priv->tc_mode == TC_PTM_SL_MODE)
+		return 1;
+
+	return 0;
+}
+
+static inline u32 ptm_id(struct ptm_ep_priv *priv)
+{
+	if (priv->tc_priv->tc_mode == TC_PTM_SL_MODE)
+		return 0;
+	else
+		return priv->ep_id;
+}
+
+static inline int is_us_bond(struct ptm_ep_priv *priv)
+{
+	if (priv->ep_id == US_BOND)
+		return 1;
+	else
+		return 0;
+}
+
+static inline struct ptm_ep_priv *tc_ep_priv(u32 ep_id)
+{
+	WARN_ON(ep_id >= BOND_MAX);
+
+	return &g_ep_priv[ep_id];
+}
+
+static int ptm_open(struct net_device *dev)
+{
+	struct ptm_priv *ptm_tc = netdev_priv(dev);
+
+	tc_info(ptm_tc->tc_priv, MSG_EVENT, "ptm open\n");
+
+	netif_tx_start_all_queues(dev);
+
+	return 0;
+}
+
+static int ptm_stop(struct net_device *dev)
+{
+	struct ptm_priv *ptm_tc = netdev_priv(dev);
+
+	tc_info(ptm_tc->tc_priv, MSG_EVENT, "ptm stop\n");
+
+	netif_tx_stop_all_queues(dev);
+	return 0;
+}
+
+static int ptm_get_qid(struct net_device *dev, struct sk_buff *skb,
+		void *vcc, uint32_t flags)
+{
+	struct ptm_priv *ptm_tc = netdev_priv(dev);
+	int qid, prio;
+
+	if (skb)
+		prio = skb->priority < PTM_PRIO_Q_NUM ?
+			skb->priority : PTM_PRIO_Q_NUM - 1;
+	else
+			prio = 0;
+	qid = ptm_tc->prio_q_map[prio];
+	qid = ptm_tc->subif_id | PTM_DESC_QID(qid);
+
+	return qid;
+}
+
+static struct rtnl_link_stats64 *ptm_get_stats(struct net_device *dev,
+					struct rtnl_link_stats64 *storage)
+{
+	struct ptm_priv *ptm_tc = netdev_priv(dev);
+
+	if (ptm_tc->tc_priv->tc_ops.get_mib(dev, storage) < 0)
+		memcpy(storage, &ptm_tc->stats64, sizeof(ptm_tc->stats64));
+	else
+		storage->tx_errors += ptm_tc->stats64.tx_errors;
+
+	return storage;
+}
+
+static int ptm_set_mac_address(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = (struct sockaddr *)p;
+	struct ptm_priv *ptm_tc = netdev_priv(dev);
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	tc_info(ptm_tc->tc_priv, MSG_EVENT, "ptm mac address update!\n");
+	ether_addr_copy(dev->dev_addr, addr->sa_data);
+
+	return 0;
+}
+
+static void ptm_tx_timeout(struct net_device *dev)
+{
+	struct ptm_priv *ptm_tc = netdev_priv(dev);
+
+	tc_info(ptm_tc->tc_priv, MSG_TX, "PTM tx timeout\n");
+	dev->trans_start = jiffies;
+	ptm_tc->stats64.tx_errors++;
+
+	netif_tx_wake_all_queues(dev);
+}
+
+static int ptm_tc_bond_get_stats(struct ptm_ep_priv *priv,
+	struct intel_tc_ptm_bonding_stats *ptm_bonding_stats)
+{
+	ds_bond_gif_mib_t ds_gif_mib;
+	struct intel_tc_ptm_bonding_ds_mib *ds_mib;
+	struct intel_tc_ptm_bonding_ds_bg_mib *bg_mib;
+	ds_bg_mib_t ds_bg_mib;
+	int idx = 0;
+	/* Get US information */
+	for (idx = 0; idx < BOND_GIF_NUM; idx++) {
+		ptm_bonding_stats->us_gif_mib[idx] =
+			tc_r32(US_BOND_GIF_MIB(idx));
+	}
+
+	/* Get DS information */
+	for (idx = 0; idx < BOND_GIF_NUM; idx++) {
+		ds_mib = &(ptm_bonding_stats->ds_gif_mib[idx]);
+		tc_mem_read(priv, &ds_gif_mib,
+			DS_BOND_GIF_MIB(idx),
+			sizeof(ds_gif_mib)
+		);
+		ds_mib->rx_frag_byte_cnt =
+			ds_gif_mib.total_rx_frag_cnt;
+		ds_mib->rx_byte_cnt =
+			ds_gif_mib.total_rx_byte_cnt;
+		ds_mib->rx_of_frag_byte_cnt =
+			ds_gif_mib.overflow_frag_cnt;
+		ds_mib->rx_of_byte_cnt =
+			ds_gif_mib.overflow_byte_cnt;
+		ds_mib->rx_oor_frag_byte_cnt =
+			ds_gif_mib.out_of_range_frag_cnt;
+		ds_mib->rx_miss_frag_byte_cnt =
+			ds_gif_mib.missing_frag_cnt;
+		ds_mib->rx_to_frag_byte_cnt =
+			ds_gif_mib.timeout_frag_cnt;
+	}
+
+	for (idx = 0; idx < DS_BG_NUM; idx++) {
+		bg_mib = &(ptm_bonding_stats->ds_bg_mib[idx]);
+		tc_mem_read(priv, &ds_bg_mib, DS_BG_MIB(idx), sizeof(ds_bg_mib));
+		bg_mib->conform_pkt_cnt = ds_bg_mib.conform_pkt_cnt;
+		bg_mib->conform_frag_cnt = ds_bg_mib.conform_frag_cnt;
+		bg_mib->conform_byte_cnt = ds_bg_mib.conform_byte_cnt;
+		bg_mib->no_sop_pkt_cnt = ds_bg_mib.no_sop_pkt_cnt;
+		bg_mib->no_sop_frag_cnt = ds_bg_mib.no_sop_frag_cnt;
+		bg_mib->no_sop_byte_cnt = ds_bg_mib.no_sop_byte_cnt;
+		bg_mib->no_eop_pkt_cnt = ds_bg_mib.no_eop_pkt_cnt;
+		bg_mib->no_eop_frag_cnt = ds_bg_mib.no_eop_frag_cnt;
+		bg_mib->no_eop_byte_cnt = ds_bg_mib.no_eop_byte_cnt;
+		bg_mib->oversize_pkt_cnt = ds_bg_mib.oversize_pkt_cnt;
+		bg_mib->oversize_frag_cnt = ds_bg_mib.oversize_frag_cnt;
+		bg_mib->oversize_pkt_cnt = ds_bg_mib.oversize_pkt_cnt;
+		bg_mib->oversize_byte_cnt = ds_bg_mib.oversize_byte_cnt;
+		bg_mib->noncosec_pkt_cnt = ds_bg_mib.noncosec_pkt_cnt;
+		bg_mib->noncosec_frag_cnt = ds_bg_mib.noncosec_frag_cnt;
+		bg_mib->noncosec_byte_cnt = ds_bg_mib.noncosec_byte_cnt;
+	}
+	return 0;
+}
+
+static int ptm_tc_get_stats(struct ptm_priv *ptm_tc,
+	struct intel_tc_stats *stats,
+	int bonding
+)
+{
+	struct rtnl_link_stats64 *stat;
+	struct wan_rx_mib_table rx_mib;
+	unsigned int cur_cnt, last_cnt;
+	struct tc_priv *priv_tc;
+	struct ptm_ep_priv *priv;
+	struct intel_tc_ptm_sl_stats *ptm_sl_stats;
+	if (!ptm_tc || !stats)
+		return -EFAULT;
+	priv_tc = ptm_tc->tc_priv;
+	if (!priv_tc)
+		return -EFAULT;
+	priv = tc_ep_priv(ptm_tc->ep_id);
+	if (!priv)
+		return -EFAULT;
+	if (bonding)
+		stats->tc_info = TC_PTM_BND_MODE;
+	else
+		stats->tc_info = TC_PTM_SL_MODE;
+	/* get generic MIB */
+	stat = &ptm_tc->stats64;
+	ptm_sl_stats = &(stats->stats.ptm_tc_stats.ptm_sl_stats);
+	ptm_sl_stats->rx_pkts = stat->rx_packets;
+	ptm_sl_stats->rx_bytes = stat->rx_bytes;
+	ptm_sl_stats->rx_errs = stat->rx_errors;
+	ptm_sl_stats->rx_drops = stat->rx_dropped;
+	ptm_sl_stats->tx_pkts = stat->tx_packets;
+	ptm_sl_stats->tx_bytes = stat->tx_bytes;
+	ptm_sl_stats->tx_errs = stat->tx_errors;
+	ptm_sl_stats->tx_drops = stat->tx_dropped;
+	/* get bearer channel information, only need the first bearer */
+	cur_cnt = tc_r32(B0_OVERDROP_CNT);
+	last_cnt = priv->ptm_mib.rx_bc_overdrop_cnt[0];
+	ptm_sl_stats->wrx_bc_overdrop = cur_cnt >= last_cnt
+		? cur_cnt - last_cnt
+		: cur_cnt + ((unsigned int)(-1) - last_cnt);
+
+	ptm_sl_stats->wrx_bc_user_cw = sb_r32(__RECEIVE_NON_IDLE_CELL_CNT_0);
+	ptm_sl_stats->wrx_bc_idle_cw = sb_r32(__RECEIVE_IDLE_CELL_CNT_0);
+	ptm_sl_stats->wtx_bc_cw = sb_r32(__TRANSMIT_CELL_CNT_0);
+
+	/* gamma interface information, only the first interface */;
+	cur_cnt = tc_r32(DREG_AR_AIIDLE_CNT0);
+	last_cnt = priv->ptm_mib.rx_total_pdu[0];
+	ptm_sl_stats->wrx_gif_total_pdu = cur_cnt >= last_cnt
+		? cur_cnt - last_cnt
+		: cur_cnt + ((unsigned int)(-1) - last_cnt);
+
+	tc_mem_read(priv, &rx_mib,
+		fpi_addr(__RX_GIF_MIB_BASE),
+		sizeof(rx_mib)
+	);
+	ptm_sl_stats->wrx_gif_drop_pdu = rx_mib.wrx_dropdes_pdu;
+
+	cur_cnt = tc_r32(GIF0_RX_CRC_ERR_CNT);
+	last_cnt = priv->ptm_mib.rx_crc_err_pdu[0];
+	ptm_sl_stats->wrx_gif_crc_err_pdu = cur_cnt >= last_cnt
+		? cur_cnt - last_cnt
+		: cur_cnt + ((unsigned int)(-1) - last_cnt);
+
+	cur_cnt = tc_r32(GIF0_RX_CV_CNT);
+	last_cnt = priv->ptm_mib.rx_cv_cw_cnt[0];
+	ptm_sl_stats->wrx_gif_violated_cw = cur_cnt >= last_cnt
+		? cur_cnt - last_cnt
+		: cur_cnt + ((unsigned int)(-1) - last_cnt);
+
+	ptm_sl_stats->wrx_gif_total_bytes = rx_mib.wrx_total_bytes;
+	cur_cnt = sb_r32(__US_TC_LOCAL_Q_CFG_CTXT_BASE +
+		offsetof(desq_cfg_ctxt_t, deq_pkt_cnt) / 4);
+	last_cnt = priv->ptm_mib.tx_total_pdu[0];
+	ptm_sl_stats->wtx_gif_total_pdu = cur_cnt >= last_cnt
+		? cur_cnt - last_cnt
+		: cur_cnt + ((unsigned int)(-1) - last_cnt);
+
+	cur_cnt = sb_r32(__US_TC_LOCAL_Q_CFG_CTXT_BASE +
+			offsetof(desq_cfg_ctxt_t, deq_byte_cnt) / 4);
+	last_cnt = priv->ptm_mib.tx_total_bytes[0];
+	ptm_sl_stats->wtx_gif_total_bytes = cur_cnt >= last_cnt
+		? cur_cnt - last_cnt
+		: cur_cnt + ((unsigned int)(-1) - last_cnt);
+
+	/* For bonding information */
+	if (bonding) {
+		int i;
+		struct intel_tc_ptm_bonding_stats ptm_ds;
+		struct intel_tc_ptm_bonding_stats ptm_us;
+		struct intel_tc_ptm_bonding_stats *ptm_bonding_stats;
+		priv = tc_ep_priv(0);
+		ptm_tc_bond_get_stats(priv, &ptm_ds);
+		priv = tc_ep_priv(1);
+		ptm_tc_bond_get_stats(priv, &ptm_us);
+		ptm_bonding_stats =
+			&(stats->stats.ptm_tc_stats.pmt_bonding_stats);
+		for (i = 0; i < 8; i++)
+			ptm_bonding_stats->us_gif_mib[i] =
+				ptm_ds.us_gif_mib[i] + ptm_us.us_gif_mib[i];
+		for (i = 0; i < 8; i++) {
+			ptm_bonding_stats->ds_gif_mib[i].rx_frag_byte_cnt =
+				ptm_ds.ds_gif_mib[i].rx_frag_byte_cnt
+				+ ptm_us.ds_gif_mib[i].rx_frag_byte_cnt;
+			ptm_bonding_stats->ds_gif_mib[i].rx_byte_cnt =
+				ptm_ds.ds_gif_mib[i].rx_byte_cnt
+				+ ptm_us.ds_gif_mib[i].rx_byte_cnt;
+			ptm_bonding_stats->ds_gif_mib[i].rx_of_frag_byte_cnt =
+				ptm_ds.ds_gif_mib[i].rx_of_frag_byte_cnt
+				+ ptm_us.ds_gif_mib[i].rx_of_frag_byte_cnt;
+			ptm_bonding_stats->ds_gif_mib[i].rx_of_byte_cnt =
+				ptm_ds.ds_gif_mib[i].rx_of_byte_cnt
+				+ ptm_us.ds_gif_mib[i].rx_of_byte_cnt;
+			ptm_bonding_stats->ds_gif_mib[i].rx_oor_frag_byte_cnt =
+				ptm_ds.ds_gif_mib[i].rx_oor_frag_byte_cnt
+				+ ptm_us.ds_gif_mib[i].rx_oor_frag_byte_cnt;
+			ptm_bonding_stats->ds_gif_mib[i].rx_miss_frag_byte_cnt =
+				ptm_ds.ds_gif_mib[i].rx_miss_frag_byte_cnt
+				+ ptm_us.ds_gif_mib[i].rx_miss_frag_byte_cnt;
+			ptm_bonding_stats->ds_gif_mib[i].rx_to_frag_byte_cnt =
+				ptm_ds.ds_gif_mib[i].rx_to_frag_byte_cnt
+				+ ptm_us.ds_gif_mib[i].rx_to_frag_byte_cnt;
+		}
+		for (i = 0; i < 4; i++) {
+			ptm_bonding_stats->ds_bg_mib[i].conform_pkt_cnt =
+				ptm_ds.ds_bg_mib[i].conform_pkt_cnt
+				+ ptm_us.ds_bg_mib[i].conform_pkt_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].conform_frag_cnt =
+				ptm_ds.ds_bg_mib[i].conform_frag_cnt
+				+ ptm_us.ds_bg_mib[i].conform_frag_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].conform_byte_cnt =
+				ptm_ds.ds_bg_mib[i].conform_byte_cnt
+				+ ptm_us.ds_bg_mib[i].conform_byte_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].no_sop_pkt_cnt =
+				ptm_ds.ds_bg_mib[i].no_sop_pkt_cnt
+				+ ptm_us.ds_bg_mib[i].no_sop_pkt_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].no_sop_frag_cnt =
+				ptm_ds.ds_bg_mib[i].no_sop_frag_cnt
+				+ ptm_us.ds_bg_mib[i].no_sop_frag_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].no_sop_byte_cnt =
+				ptm_ds.ds_bg_mib[i].no_sop_byte_cnt
+				+ ptm_us.ds_bg_mib[i].no_sop_byte_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].no_eop_pkt_cnt =
+				ptm_ds.ds_bg_mib[i].no_eop_pkt_cnt
+				+ ptm_us.ds_bg_mib[i].no_eop_pkt_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].no_eop_frag_cnt =
+				ptm_ds.ds_bg_mib[i].no_eop_frag_cnt
+				+ ptm_us.ds_bg_mib[i].no_eop_frag_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].no_eop_byte_cnt =
+				ptm_ds.ds_bg_mib[i].no_eop_byte_cnt
+				+ ptm_us.ds_bg_mib[i].no_eop_byte_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].oversize_pkt_cnt =
+				ptm_ds.ds_bg_mib[i].oversize_pkt_cnt
+				+ ptm_us.ds_bg_mib[i].oversize_pkt_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].oversize_frag_cnt =
+				ptm_ds.ds_bg_mib[i].oversize_frag_cnt
+				+ ptm_us.ds_bg_mib[i].oversize_frag_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].oversize_byte_cnt =
+				ptm_ds.ds_bg_mib[i].oversize_byte_cnt
+				+ ptm_us.ds_bg_mib[i].oversize_byte_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].noncosec_pkt_cnt =
+				ptm_ds.ds_bg_mib[i].noncosec_pkt_cnt
+				+ ptm_us.ds_bg_mib[i].noncosec_pkt_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].noncosec_frag_cnt =
+				ptm_ds.ds_bg_mib[i].noncosec_frag_cnt
+				+ ptm_us.ds_bg_mib[i].noncosec_frag_cnt;
+			ptm_bonding_stats->ds_bg_mib[i].noncosec_byte_cnt =
+				ptm_ds.ds_bg_mib[i].noncosec_byte_cnt
+				+ ptm_us.ds_bg_mib[i].noncosec_byte_cnt;
+		}
+	}
+	return 0;
+}
+static int ptm_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	int ret;
+	int bonding;
+	struct intel_tc_stats tc_stats;
+	struct ptm_priv *ptm_tc = netdev_priv(dev);
+	bonding = ptm_tc->tc_priv->tc_mode == TC_PTM_BND_MODE;
+	/* sanity check */
+	if (!ifr->ifr_data) {
+		return EFAULT;
+
+	}
+	ret = EFAULT;
+	switch (cmd) {
+	case INTEL_PTM_TC_IOCTL_STATS:
+		if (!ptm_tc_get_stats(ptm_tc, &tc_stats, bonding))
+			ret = copy_to_user(ifr->ifr_data,
+					(void *)&tc_stats,
+					sizeof(tc_stats));
+		break;
+	default:
+		ret = -ENOIOCTLCMD;
+		break;
+	}
+	return ret;
+}
+
+/* Change the MTU value of the netwrok device interfaces */
+static int ptm_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct ptm_priv *ptm_tc = netdev_priv(dev);
+
+	if (new_mtu < ETH_ZLEN || new_mtu > MAX_MTU)
+		return -EINVAL;
+
+	tc_info(ptm_tc->tc_priv, MSG_EVENT, "PTM MTU update: %d\n", new_mtu);
+	dev->mtu = new_mtu;
+
+	return 0;
+}
+
+static int ptm_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ptm_priv *ptm_tc = netdev_priv(dev);
+	int qid;
+	enum tc_pkt_type type;
+
+	if (!showtime_stat(ptm_tc->tc_priv))
+		goto PTM_XMIT_DROP;
+
+	if (skb_padto(skb, ETH_ZLEN))
+		goto PTM_XMIT_DROP;
+
+	dump_skb_info(ptm_tc->tc_priv, skb, (MSG_TX | MSG_TXDATA));
+
+	qid = ptm_get_qid(dev, skb, NULL, 0);
+	type = ptm_tc->tc_priv->tc_mode == TC_PTM_BND_MODE
+		? PTM_BOND_PKT : PTM_SL_PKT;
+
+	if (ptm_tc->tc_priv->tc_ops.send(dev, skb, qid, type) < 0)
+		ptm_tc->stats64.tx_dropped++;
+	else {
+		ptm_tc->stats64.tx_packets++;
+		ptm_tc->stats64.tx_bytes += skb->len;
+	}
+
+	return 0;
+
+PTM_XMIT_DROP:
+	dev_kfree_skb_any(skb);
+	ptm_tc->stats64.tx_dropped++;
+	return 0;
+}
+
+static void ptm_rx(struct net_device *dev, struct sk_buff *skb)
+{
+	struct ptm_priv *ptm_tc;
+
+	ptm_tc = netdev_priv(dev);
+	if (skb->len < ETH_ZLEN || skb->len > MAX_MTU) {
+		tc_dbg(ptm_tc->tc_priv, MSG_RX,
+			"illegal packet len: %d\n", skb->len);
+		ptm_tc->stats64.rx_length_errors++;
+		goto rx_err_exit;
+	}
+
+	dump_skb_info(ptm_tc->tc_priv, skb, (MSG_RX | MSG_RXDATA));
+	skb->protocol = eth_type_trans(skb, dev);
+
+	ptm_tc->stats64.rx_packets++;
+	ptm_tc->stats64.rx_bytes += skb->len;
+
+	if (netif_rx(skb) == NET_RX_DROP)
+		ptm_tc->stats64.rx_dropped++;
+
+	return;
+
+rx_err_exit:
+	dev_kfree_skb_any(skb);
+	ptm_tc->stats64.rx_errors++;
+
+	return;
+}
+
+static struct net_device_ops g_ptm_netdev_ops = {
+	.ndo_open		= ptm_open,
+	.ndo_stop		= ptm_stop,
+	.ndo_get_stats64	= ptm_get_stats,
+	.ndo_set_mac_address	= ptm_set_mac_address,
+	.ndo_start_xmit		= ptm_xmit,
+	.ndo_tx_timeout		= ptm_tx_timeout,
+	.ndo_do_ioctl		= ptm_ioctl,
+	.ndo_change_mtu		= ptm_change_mtu,
+};
+
+/* onoff: 0 -- off, 1 -- on */
+static void irq_set(struct ptm_priv *ptm_tc, struct ptm_ep_priv *priv,
+				u32 irq_id, int onoff)
+{
+	u32 irq_ier;
+
+	spin_lock_irq(&ptm_tc->ptm_lock);
+	irq_ier = tc_r32(MBOX_IGU_IER(MBOX_IGU1));
+	if (!onoff)
+		irq_ier &= ~irq_id;
+	else
+		irq_ier |= irq_id;
+	mbox_set_ier(priv, MBOX_IGU1, irq_ier);
+	mbox_clr_isr(priv, MBOX_IGU1, irq_id);
+	spin_unlock_irq(&ptm_tc->ptm_lock);
+}
+
+static void ptm_irq_set(u32 irq_id, int onoff)
+{
+	int i;
+	struct ptm_priv *ptm_tc = g_ptm_priv;
+	struct ptm_ep_priv *priv;
+
+	if (ptm_tc->tc_priv->tc_mode == TC_PTM_BND_MODE) {
+		for (i = 0; i < BOND_MAX; i++) {
+			priv = tc_ep_priv(i);
+			irq_set(ptm_tc, priv, irq_id, onoff);
+		}
+	} else {
+		priv = tc_ep_priv(ptm_tc->ep_id);
+		irq_set(ptm_tc, priv, irq_id, onoff);
+	}
+}
+
+static void ptm_irq_on(u32 irq_id)
+{
+	ptm_irq_set(irq_id, 1);
+}
+
+static void ptm_irq_off(u32 irq_id)
+{
+	ptm_irq_set(irq_id, 0);
+}
+
+static void ptm_setup(struct net_device *dev)
+{
+	ether_setup(dev);
+	dev->watchdog_timeo = 10 * HZ;
+	dev->netdev_ops = &g_ptm_netdev_ops;
+}
+
+static int ptm_dev_init(struct tc_priv *tc_priv, u32 id,
+		enum dsl_tc_mode tc_mode)
+{
+	int err, i;
+	struct net_device *dev;
+	struct ptm_priv *ptm_tc;
+	const char macaddr[ETH_ALEN]
+		= {0xAC, 0x9A, 0x96, 0x11, 0x22, 0x33};
+
+	dev = alloc_netdev_mq(sizeof(*ptm_tc), "ptm%d", ptm_setup, 4);
+	if (!dev) {
+		tc_dbg(tc_priv, MSG_INIT, "Cannot alloc net device\n");
+		return -ENOMEM;
+	}
+	ptm_tc = netdev_priv(dev);
+	ptm_tc->dev = dev;
+	ptm_tc->tc_priv = tc_priv;
+	ether_addr_copy(dev->dev_addr, macaddr);
+	spin_lock_init(&ptm_tc->ptm_lock);
+	/*init_completion(&ptm_tc->comp);*/
+	memcpy(ptm_tc->outq_map, def_outq_map, sizeof(def_outq_map));
+	SET_NETDEV_DEV(ptm_tc->dev, tc_priv->ep_dev[id].dev);
+
+	err = register_netdev(ptm_tc->dev);
+	if (err)
+		goto err1;
+
+	netif_carrier_off(ptm_tc->dev);
+	g_ptm_priv = ptm_tc;
+
+	for (i = 0; i < tc_priv->ep_num; i++) {
+		memset(&g_ep_priv[i], 0, sizeof(g_ep_priv[i]));
+		g_ep_priv[i].ep = &tc_priv->ep_dev[i];
+		g_ep_priv[i].tc_priv = tc_priv;
+		g_ep_priv[i].ep_id = i;
+		g_ep_priv[i].ptm_tc = ptm_tc;
+	}
+
+	return 0;
+err1:
+	free_netdev(ptm_tc->dev);
+	return err;
+}
+
+static void ppe_stop(struct ptm_ep_priv *priv)
+{
+	int i;
+
+	for (i = PP32_TX; i < PP32_MAX; i++)
+		pp32_stop(priv, i);
+}
+
+static void ppe_start(struct ptm_ep_priv *priv)
+{
+	int i;
+
+	for (i = PP32_TX; i < PP32_MAX; i++)
+		pp32_start(priv, i);
+}
+
+static void ptm_reg_init(struct ptm_ep_priv *priv)
+{
+	u32 val;
+	struct ffsm_cfg ffsmcfg;
+	struct sfsm_cfg sfsmcfg;
+	int i;
+
+	/* TODO: convert to meaningful configuration */
+	tc_w32(0x00000000, PPE_CDM);
+	tc_w32(0x00020000, SFSM_PGCNT(0));
+	tc_w32(0x00000160, DREG_AT_CFG(0));
+	tc_w32(0x00000000, DREG_AT_IDLE(0));
+	tc_w32(0x000001F0, DREG_AR_CFG(0));
+	tc_w32(0x00000000, DREG_AR_IDLE(0));
+	tc_w32(0x00000000, DREG_AR_IDLE(0));
+	tc_w32(0x00001FFF, DREG_B_LADR(0));
+	val = (((SFSM_PNUM * CW_PAGE_SZ) << 16) |
+		(FFSM_PNUM * CW_PAGE_SZ));
+	tc_w32(val, PPE_BC0_CW_SIZE);
+
+	memset(&ffsmcfg, 0, sizeof(ffsmcfg));
+	ffsmcfg.endian = 1;
+	ffsmcfg.fidle = 1;
+	ffsmcfg.pnum = FFSM_PNUM;
+	tc_mem_write(priv, FFSM_CFG(0),
+		&ffsmcfg, sizeof(ffsmcfg));
+
+	tc_w32(SFSM_DBACE, SFSM_DBA(0));
+	tc_w32(SFSM_CBACE, SFSM_CBA(0));
+	tc_w32(0xF0D10000, FFSM_IDLE_HEAD_BC0);
+	tc_w32(0xF0D10000, FFSM_IDLE_HEAD_BC1);
+
+	memset(&sfsmcfg, 0, sizeof(sfsmcfg));
+	sfsmcfg.endian = 1;
+	sfsmcfg.idlekeep = 1;
+	sfsmcfg.sen = 1;
+	sfsmcfg.pnum = SFSM_PNUM;
+	for (i = 0; i < 2; i++) {
+		tc_mem_write(priv, SFSM_CFG(i),
+			&sfsmcfg, sizeof(sfsmcfg));
+	}
+
+	/* Enable TTHA BC0 & BC1*/
+	/**
+	* Note: Although BC1 is not used in VRX518,
+	* But if not enabled BC1, it will cause DSL FW
+	* leave showtime soon after it reach showtime
+	*/
+	ttha_enable(priv);
+
+	return;
+}
+
+static void pdma_init(struct ptm_ep_priv *priv)
+{
+	/* TODO: convert to meaningful configuration */
+	tc_w32(0x00000001, PDMA_CFG);
+	tc_w32(0x00082C00, PDMA_RX_CTX_CFG);
+	tc_w32(0x00081B00, PDMA_TX_CTX_CFG);
+	tc_w32(0x02040800, PDMA_RX_MAX_LEN_REG);
+
+	tc_w32(0x000F003F, PDMA_RX_DELAY_CFG);
+
+	tc_w32(0x00000011, SAR_MODE_CFG);
+	tc_w32(0x00081200, SAR_RX_CTX_CFG);
+	tc_w32(0x00082E00, SAR_TX_CTX_CFG);
+	tc_w32(0x00001021, SAR_POLY_CFG_SET0);
+	tc_w32(0x1EDC6F41, SAR_POLY_CFG_SET1);
+	tc_w32(0x04C11DB7, SAR_POLY_CFG_SET2);
+	tc_w32(0x00000F3E, SAR_CRC_SIZE_CFG);
+
+	tc_w32(0x00FE1900, SAR_PDMA_RX_CMDBUF_CFG);
+	tc_w32(0x00FE1A00, SAR_PDMA_TX_CMDBUF_CFG);
+
+	tc_w32(0x00203FC0, SAR_PDMA_RX_FW_CMDBUF_CFG);
+	tc_w32(0x00203FE0, SAR_PDMA_TX_FW_CMDBUF_CFG);
+
+	tc_w32(0x00000007, PDMA_IER);
+
+	return;
+}
+
+static void ptm_hw_init(struct ptm_ep_priv *priv)
+{
+	ptm_reg_init(priv);
+	pdma_init(priv);
+}
+
+static void ptm_fw_init(struct ptm_ep_priv *priv, int is_bonding)
+{
+	std_des_cfg_t std_des_cfg;
+	qos_cfg_t qos_cfg;
+	qosq_flow_ctrl_cfg_t flow_ctrl;
+	struct psave_cfg ps_cfg;
+	struct rx_bc_cfg rx_bc_cfg;
+	struct tx_bc_cfg tx_bc_cfg;
+	struct rx_gamma_itf_cfg rx_gitf_cfg;
+	struct tx_gamma_itf_cfg tx_gitf_cfg;
+
+	u32 dst_addr;
+	int i;
+
+	sb_w32(0x3C30, __VRX218_FLOW_CTRL_CFG);
+
+	memset(&std_des_cfg, 0, sizeof(std_des_cfg));
+	/* this field replaces byte_off in rx descriptor of VDSL ingress */
+	std_des_cfg.byte_off = is_bonding ? 2 : 0;
+	std_des_cfg.data_len = DMA_PACKET_SZ;
+	tc_mem_write(priv, fpi_addr(__STD_DES_CFG),
+		&std_des_cfg, sizeof(std_des_cfg));
+
+	memset(&qos_cfg, 0, sizeof(qos_cfg));
+	/* 16 * (cgu_get_pp32_clock() / 1000000) */
+	qos_cfg.time_tick = tc_ppe_clkget(priv->ep) / 62500;
+	qos_cfg.qosq_num = QOSQ_NUM;
+	qos_cfg.qos_en = 0;
+	tc_mem_write(priv, fpi_addr(__QOS_CFG), &qos_cfg, sizeof(qos_cfg));
+
+	for (i = PP32_TX; i < PP32_MAX; i++) {
+		memset(&ps_cfg, 0, sizeof(ps_cfg));
+		ps_cfg.start_state = 0;
+		ps_cfg.sleep_en = priv->tc_priv->param.ps;
+		tc_mem_write(priv, fpi_addr(PSAVE_CFG(i)),
+			&ps_cfg, sizeof(ps_cfg));
+	}
+
+	memset(&flow_ctrl, 0, sizeof(flow_ctrl));
+	flow_ctrl.large_frame_size = 128;
+	flow_ctrl.large_frame_drop_th = 0xFE;
+	tc_mem_write(priv, fpi_addr(__QOSQ_FLOW_CTRL_CFG),
+		&flow_ctrl, sizeof(flow_ctrl));
+
+	tc_w32(DMA_PACKET_SZ, fpi_addr(__MAX_PKT_SIZE_CFG));
+
+	memset(&rx_bc_cfg, 0, sizeof(rx_bc_cfg));
+	rx_bc_cfg.local_state   = 0;
+	rx_bc_cfg.remote_state  = 0;
+	rx_bc_cfg.to_false_th   = 7;
+	rx_bc_cfg.to_looking_th = 3;
+	for (i = 0; i < 2; i++) {
+		dst_addr = __RX_BC0_CFG_STATS_CFG + (i * DW_SZ(rx_bc_cfg));
+		tc_mem_write(priv, fpi_addr(dst_addr),
+			&rx_bc_cfg, sizeof(rx_bc_cfg));
+	}
+
+	memset(&tx_bc_cfg, 0, sizeof(tx_bc_cfg));
+	tx_bc_cfg.fill_wm = 16;
+	tx_bc_cfg.uflw_wm = 2;
+	for (i = 0; i < 2; i++) {
+		dst_addr = __TX_BC0_CFG_STATS_CFG + (i * DW_SZ(tx_bc_cfg));
+		tc_mem_write(priv, fpi_addr(dst_addr),
+			&tx_bc_cfg, sizeof(tx_bc_cfg));
+	}
+
+	memset(&rx_gitf_cfg, 0, sizeof(rx_gitf_cfg));
+	rx_gitf_cfg.receive_state	= 0;
+	rx_gitf_cfg.rx_min_len		= 64;
+	rx_gitf_cfg.rx_pad_en		= 1;
+	/* disable Ethernet FCS verification during bonding */
+	rx_gitf_cfg.rx_eth_fcs_ver_dis	= is_bonding ? 1 : 0;
+	rx_gitf_cfg.rx_rm_eth_fcs	= is_bonding ? 0 : 1;
+	rx_gitf_cfg.rx_tc_crc_ver_dis	= 0;
+	rx_gitf_cfg.rx_tc_crc_size	= 1;
+	rx_gitf_cfg.rx_eth_fcs_result	= 0xC704DD7B;
+	rx_gitf_cfg.rx_tc_crc_result	= 0x1D0F1D0F;
+	rx_gitf_cfg.rx_crc_cfg		= 0x2500;
+	rx_gitf_cfg.rx_eth_fcs_init_value = 0xFFFFFFFF;
+	rx_gitf_cfg.rx_tc_crc_init_value = 0x0000FFFF;
+	rx_gitf_cfg.rx_max_len_sel	= 0;
+	rx_gitf_cfg.rx_edit_num2	= 0;
+	rx_gitf_cfg.rx_edit_pos2	= 0;
+	rx_gitf_cfg.rx_edit_type2	= 0;
+	rx_gitf_cfg.rx_edit_en2		= 0;
+	/* no PMAC header insertion during bonding or grx350 platform*/
+	rx_gitf_cfg.rx_edit_num1	= 0;
+	rx_gitf_cfg.rx_edit_pos1	= 0;
+	/* no PMAC header insertion during bonding or grx350 platform*/
+	rx_gitf_cfg.rx_edit_type1	= 0;
+	rx_gitf_cfg.rx_edit_en1		= 0;
+	/*  E5: byte swap of value 0x07000000 */
+	rx_gitf_cfg.rx_inserted_bytes_1l = 0x00000007;
+	rx_gitf_cfg.rx_inserted_bytes_1h = 0;
+	rx_gitf_cfg.rx_inserted_bytes_2l = 0;
+	rx_gitf_cfg.rx_inserted_bytes_2h = 0;
+	rx_gitf_cfg.rx_len_adj		= -2;
+	for (i = 0; i < 4; i++) {
+		dst_addr = __RX_GIF0_CFG_STATS_CFG +
+			(i * DW_SZ(rx_gitf_cfg));
+		tc_mem_write(priv, fpi_addr(dst_addr),
+			&rx_gitf_cfg, sizeof(rx_gitf_cfg));
+	}
+
+	memset(&tx_gitf_cfg, 0, sizeof(tx_gitf_cfg));
+	tx_gitf_cfg.tx_len_adj		= is_bonding ? 2 : 6;
+	tx_gitf_cfg.tx_crc_off_adj	= 6;
+	tx_gitf_cfg.tx_min_len		= 0;
+	tx_gitf_cfg.tx_eth_fcs_gen_dis	= is_bonding ? 1 : 0;
+	tx_gitf_cfg.tx_tc_crc_size	= 1;
+	tx_gitf_cfg.tx_crc_cfg		= is_bonding ? 0x2F02 : 0x2F00;
+	tx_gitf_cfg.tx_eth_fcs_init_value = 0xFFFFFFFF;
+	tx_gitf_cfg.tx_tc_crc_init_value = 0x0000FFFF;
+	for (i = 0; i < 4; i++) {
+		/**
+		* tx_gitf_cfg.queue_mapping = g_queue_gamma_map[i];
+		*/
+		dst_addr = __TX_GIF0_CFG_STATS_CFG +
+			(i * DW_SZ(tx_gitf_cfg));
+		tc_mem_write(priv, fpi_addr(dst_addr),
+			&tx_gitf_cfg, sizeof(tx_gitf_cfg));
+	}
+
+	/* Initialize TX Ctrl K Table */
+	for (i = 0; i < ARRAY_SIZE(tx_kvec); i++)
+		tc_w32(tx_kvec[i], TX_CTRL_K_TABLE(i));
+
+	return;
+}
+
+/**
+* Initialize PPE FW General Configuration
+*/
+static void ptm_gen_cfg_init(struct ptm_ep_priv *priv, int bonding)
+{
+	int i;
+	u32 us_bond, ds_bond;
+	task_cfg_t task_cfg[PP32_MAX];
+	bond_conf_t bond_conf;
+	const u32 sb_addr[] = {
+		__PP32_0_TASK_CFG, __PP32_1_TASK_CFG, __PP32_2_TASK_CFG};
+	u32 peer_sb_addr;
+
+	memset(&task_cfg, 0, sizeof(task_cfg));
+	/* Default Task Configuration */
+	for (i = 0; i < PP32_MAX; i++) {
+		us_bond = (bonding && is_us_bond(priv) && (i == PP32_BOND));
+		ds_bond = (bonding && !is_us_bond(priv) && (i == PP32_BOND));
+		task_cfg[i].pp32_core_id	= i;
+		task_cfg[i].us_bonding_master	= bonding && is_us_bond(priv);
+		task_cfg[i].us_segment_en	= us_bond;
+		task_cfg[i].us_buf_release_en	= us_bond;
+
+		task_cfg[i].ds_bonding_master	= bonding && !is_us_bond(priv);
+		task_cfg[i].ds_pkt_dispatch_en	= ds_bond;
+		task_cfg[i].ds_pkt_reconstruct_en = ds_bond;
+		task_cfg[i].ds_pkt_flush_en	= ds_bond;
+
+		task_cfg[i].tc_us_en		= (i == PP32_TX);
+		task_cfg[i].tc_ds_en		= (i == PP32_RX);
+		task_cfg[i].des_sync_en		= 0;
+		task_cfg[i].edma_write_lle_gen_en = 0;
+		task_cfg[i].edma_read_lle_gen_en = 0;
+		task_cfg[i].edma_post_proc_en	= 0;
+		task_cfg[i].qos_wfq_shaping_en	= (i == PP32_BOND);
+		task_cfg[i].qos_dispatch_en	= (i == PP32_BOND);
+		task_cfg[i].qos_replenish_en	= (i == PP32_BOND);
+	}
+
+	for (i = 0; i < PP32_MAX; i++) {
+		tc_mem_write(priv, fpi_addr(sb_addr[i]),
+				&task_cfg[i], sizeof(task_cfg));
+	}
+
+	if (bonding) {
+		memset(&bond_conf, 0, sizeof(bond_conf));
+		bond_conf.dplus_fp_fcs_en   = 0x1;
+		bond_conf.max_frag_size     = DEF_BOND_FRAG_SIZE;
+		/* 0x4 if two bearer channels are enabled */
+		bond_conf.bg_num            = 0x2;
+		bond_conf.bond_mode         = 0x0;
+		bond_conf.e1_bond_en        = 0x1;
+		bond_conf.d5_acc_dis        = 0x1;
+		bond_conf.d5_b1_en          = 0x1;
+
+		tc_mem_write(priv, fpi_addr(__BOND_CONF),
+			&bond_conf, sizeof(bond_conf));
+		/**
+		 * Set Peer SB base address
+		 * FW guarantee it will only write to SB Segment 1
+		 * Driver provide address to FW
+		 * address = PPE BASE (0x300000) + (FPI_SB_SEG1_BASE(0x8000)
+		 *		- PPE_SB_SEG1_BASE (0x8000)) * 4
+		 * FW will add SB address when it use
+		 * FW usage: (address + SB_ADDR * 4)
+		 */
+		peer_sb_addr = priv->ep->peer_phy_membase[0] + PPE_BASE
+			+ ((FPI_SB_SEG_BASE(1) - SB_SEG1_BASE) << 2);
+		sb_w32(peer_sb_addr, __BOND_PEER_SB_BASE);
+		sb_w32(0x07800000, __DS_PKT_PMAC_HEADER);
+		sb_w32(priv->tc_priv->switch_exist, __PCIE_SWITCH_PRESENT);
+	}
+
+	/**
+	 * Forever loops for each CDMA post processing code to be run
+	 * set to 1 to accelerate processing
+	 */
+	sb_w32(1, __MAINLOOP_CFG_ADDR);
+	sb_w32(1, __SOC_FAMILY);
+}
+
+/**
+ *  Initialize Fastpath descriptor queue config contxt
+ *  Initialize dest list of the desq_cfg_ctxt
+ */
+static void us_fp_desq_cfg_ctxt_init(struct ptm_ep_priv *priv)
+{
+	desq_cfg_ctxt_t desq_cfg;
+	int i;
+	u32 desc_addr;
+	rx_descriptor_t desc;
+
+	memset(&desq_cfg, 0, sizeof(desq_cfg));
+	/* Initialize US Fast-Path Descriptor Queue Config/Context */
+	desq_cfg.des_in_own_val	= US_FP_DES_OWN;
+	desq_cfg.fast_path	= 1;
+	desq_cfg.mbox_int_en	= 0;
+	desq_cfg.des_sync_needed = 0;
+	desq_cfg.des_num	= __US_FAST_PATH_DES_LIST_NUM;
+	desq_cfg.des_base_addr	= __US_FAST_PATH_DES_LIST_BASE;
+
+	tc_mem_write(priv, fpi_addr(__US_FP_INQ_DES_CFG_CTXT),
+		&desq_cfg, sizeof(desq_cfg));
+
+	/* Initialize Descriptors in Shadow Fast Path Descriptor List */
+	/* Shadow descriptor list of SoC, only own bit is required for init */
+	memset(&desc, 0, sizeof(desc));
+	desc.own = !desq_cfg.des_in_own_val;
+	desc_addr = desq_cfg.des_base_addr;
+	for (i = 0; i < desq_cfg.des_num; i++) {
+		tc_mem_write(priv, fpi_addr(desc_addr),
+				&desc, sizeof(desc));
+		desc_addr += DW_SZ(desc);
+	}
+}
+
+static void us_qos_desq_cfg_ctxt_init(struct ptm_ep_priv *priv)
+{
+	qosq_cfg_ctxt_t qosq_cfg_ctxt;
+	int offset, i;
+	rx_descriptor_t desc;
+	dma_addr_t phy_addr;
+
+	/* Setup QoSQ_CFG_CTXT */
+	memset(&qosq_cfg_ctxt, 0, sizeof(qosq_cfg_ctxt));
+
+	qosq_cfg_ctxt.threshold = 8;
+	qosq_cfg_ctxt.des_num	= QOS_DES_NUM / QOSQ_NUM;
+
+	offset = 0;
+	for (i = 0; i < QOSQ_NUM; i++) {
+		qosq_cfg_ctxt.des_base_addr = __US_QOSQ_DES_LIST_BASE + offset;
+		tc_mem_write(priv,
+			fpi_addr((__QOSQ_CFG_CTXT_BASE +
+					(i * __QOSQ_CFG_CTXT_SIZE))),
+			&qosq_cfg_ctxt, sizeof(qosq_cfg_ctxt));
+		offset += qosq_cfg_ctxt.des_num * DW_SZ(qosq_cfg_ctxt);
+	}
+
+	memset(&desc, 0, sizeof(desc));
+	desc.own = QOS_DISPATCH_OWN;
+	desc.data_len = DMA_PACKET_SZ;
+
+	/* Initialize QoSQ Descriptors */
+	for (i = 0; i < QOS_DES_NUM; i++) {
+		if (tc_buf_alloc(priv, DMA_PACKET_SZ,
+			&phy_addr, US_DIR, priv->ep->dev) == NULL) {
+			set_tc_status(priv->tc_priv, TC_ERR);
+			return;
+		}
+		desc.data_ptr = phy_addr;
+		tc_mem_write(priv,
+			fpi_addr(__US_QOSQ_DES_LIST_BASE + (i * DW_SZ(desc))),
+			&desc, sizeof(desc));
+	}
+}
+
+static void us_outq_desq_cfg_ctxt_init(struct ptm_ep_priv *priv)
+{
+	outq_qos_cfg_ctxt_t outq_cfg;
+	desq_cfg_ctxt_t desq_cfg;
+	u32 addr;
+	rx_descriptor_t rx_desc;
+	dma_addr_t phy_addr;
+	int i;
+	u32 offset;
+
+	/* Setup OUTQ_QoS_CFG_CTXT */
+	/* NOTE: By default, Shaping & WFQ both are DISABLED!! */
+	memset(&outq_cfg, 0, sizeof(outq_cfg));
+	/* outq_cfg.overhd_bytes  = bonding ? 20 : 24;*/
+
+	/* outq_cfg 0/desc_cfg 1 -> pre-emption queue */
+	/* outq_cfg 1/desc_cfg 0 -> none pre-emption queue */
+	for (i = 0; i < OUTQ_PNUM; i++) {
+		outq_cfg.qmap			= g_ptm_priv->outq_map[i];
+		outq_cfg.l2_shaping_cfg_ptr	= 0;
+		outq_cfg.l2_shaping_cfg_idx	= QOSQ_PORT_SSID + i;
+		outq_cfg.l3_shaping_cfg_ptr	= 0;
+		outq_cfg.l3_shaping_cfg_idx	= QOSQ_L3_SHAPER_ID;
+		outq_cfg.desq_cfg_ctxt
+			= __US_QOS_OUTQ_DES_CFG_CTXT_BASE +
+				i * DW_SZ(desq_cfg_ctxt_t);
+
+		addr = __OUTQ_QOS_CFG_CTXT_BASE + i * DW_SZ(outq_cfg);
+		tc_mem_write(priv, fpi_addr(addr), &outq_cfg, sizeof(outq_cfg));
+	}
+
+	/* Setup DESQ_CFG_CTXT for Output Queues */
+	memset(&desq_cfg, 0, sizeof(desq_cfg));
+
+	desq_cfg.des_in_own_val	= US_OUTQ_DES_OWN;
+	desq_cfg.mbox_int_en	= 0;
+	desq_cfg.des_sync_needed = 0;
+	desq_cfg.des_num	= 32;
+	/**
+	* Only BC0 is used in VRX518
+	*/
+	offset = 0;
+	addr = __US_QOS_OUTQ_DES_CFG_CTXT_BASE;
+	for (i = 0; i < OUTQ_PNUM; i++) {
+		desq_cfg.des_base_addr = __US_OUTQ_DES_LIST_BASE + offset;
+		tc_mem_write(priv, fpi_addr(addr), &desq_cfg, sizeof(desq_cfg));
+		offset += desq_cfg.des_num * 2;
+		addr += DW_SZ(desq_cfg_ctxt_t);
+	}
+
+	/* Initialize the outq descriptor list */
+	memset(&rx_desc, 0, sizeof(rx_desc));
+	rx_desc.own = !desq_cfg.des_in_own_val;
+	rx_desc.data_len = DMA_PACKET_SZ;
+
+	/* Initialize QoSQ Descriptors */
+	for (i = 0; i < OUTQ_DESC_NUM; i++) {
+		if (tc_buf_alloc(priv, DMA_PACKET_SZ,
+			&phy_addr, US_DIR, priv->ep->dev) == NULL) {
+			set_tc_status(priv->tc_priv, TC_ERR);
+			return;
+		}
+
+		rx_desc.data_ptr = phy_addr;
+		addr = fpi_addr(__US_OUTQ_DES_LIST_BASE + (i * DW_SZ(rx_desc)));
+		tc_mem_write(priv, addr, &rx_desc, sizeof(rx_desc));
+	}
+
+	return;
+}
+
+/**
+* Initialize QoS related configuration for VRX518
+* Initializes the below PPE FW Data Structures
+* 1. INQ_QoS_CFG
+* 2. QoSQ_CFG_CTXT
+* 3. OUTQ_QoS_CFG_CTXT
+* 4. SHAPING_WFQ_CFG
+* 5. QOSQ_MIB
+* 6. QOSQ_FLOW_CTRL_CFG
+* 7. STD_DES_CFG
+*/
+static void us_qos_cfg_init(struct ptm_ep_priv *priv)
+{
+	inq_qos_cfg_t fp_qos_cfg;
+
+	/* Setup INQ_QoS_CFG for Fast-Path & CPU-Path */
+	memset(&fp_qos_cfg, 0, sizeof(fp_qos_cfg));
+
+	fp_qos_cfg.qos_en         = 1;
+	fp_qos_cfg.qid_mask       = QOSQ_ID_MASK;
+	fp_qos_cfg.qosq_base_qid  = 0;
+	fp_qos_cfg.desq_cfg_ctxt  = __US_FP_INQ_DES_CFG_CTXT;
+	tc_mem_write(priv, INQ_QOS_CFG_BASE(0),
+		&fp_qos_cfg, sizeof(fp_qos_cfg));
+
+	us_fp_desq_cfg_ctxt_init(priv);
+	us_qos_desq_cfg_ctxt_init(priv);
+	us_outq_desq_cfg_ctxt_init(priv);
+
+	/* Set QoS NO DROP */
+	sb_w32(1, __QOSQ_NO_DROP);
+	/* Enable Preemption function/Disable QoS by default */
+	sb_w32(1, _CHK_PREEMP_MAP);
+	/* By default, all qid mappint to non-preemption queue */
+	sb_w32(0x0, _QID2PREEMP_MAP);
+
+	return;
+}
+
+/**
+ * PDBRAM LAYOUT
+ * 1. US Local data
+ * 2. DS Local data
+ * 3. ACA shadow descriptors
+ * 4. ERB descriptors
+ * Summary for current PDBRAM usage
+ * Total PDBRAM for PPE: 0x218000 - 0x237FFF (128KB)
+ * US local data base: 0x218000 size: 0x9000 bytes
+ * DS local data base: 0x221000 size: 0xF000 bytes
+ * ACA TXOUT desc base:0x230000 size: 0x200 bytes
+ * ACA RXOUT desc base:0x230200 size: 0x7F8 bytes
+ * ERB desc base:      0x2309F8 size: 0x2520 bytes
+ * Left space:         0x232F18 - 0x237FFF (around 20KB)
+ * Bonding parameter is reserved for future usage.
+ * return request layout base physical address
+ * return 0 as invalid address
+ */
+static u32 ptm_pdbram_mem_layout(struct ptm_ep_priv *priv, u32 req, int bonding)
+{
+	u32 addr, num;
+
+	addr = PDBRAM_PPE_BASE;
+	if (req == PDBRAM_US)
+		return addr;
+
+	/* Total US local des counter */
+	num = __US_TC_LOCAL_Q0_DES_LIST_NUM + __US_TC_LOCAL_Q1_DES_LIST_NUM;
+	addr += num * DMA_PACKET_SZ;
+	if (req == PDBRAM_DS)
+		return addr;
+
+	num = __DS_TC_LOCAL_Q_DES_LIST_NUM;
+	addr += num * DMA_PACKET_SZ;
+	if (req == PDBRAM_ACA_TXOUT)
+		return addr;
+
+	num = __ACA_TX_OUT_PD_LIST_NUM;
+	addr += num * DESC_SZ;
+	if (req == PDBRAM_ACA_RXOUT)
+		return addr;
+
+	num = __ACA_RX_OUT_PD_LIST_NUM;
+	addr += num * DESC_SZ;
+	if (req == PDBRAM_ERB)
+		return addr;
+
+	return 0;
+}
+
+/**
+ * Initialize ERB (Total 9 ERB buffer)
+ */
+static void ptm_erb_init(struct ptm_ep_priv *priv, int bonding)
+{
+	desq_cfg_ctxt_t des_cfg, frag_des_cfg;
+	bg_erb_cfg_ctxt_t erb_bg;
+	u32 erb_pdbram_base, addr;
+	rx_descriptor_t desc;
+	int i, reg_val;
+
+	/* Init ERB desq_cfg_ctxt */
+	if (is_ptm_sl(priv) || (bonding && is_us_bond(priv))) {
+		memset(&des_cfg, 0, sizeof(des_cfg));
+		des_cfg.des_in_own_val = ERB_DES_PPE_OWN;
+		des_cfg.des_base_addr = __OUTQ_ERB0_BASE;
+		des_cfg.des_num = __OUTQ_ERB0_NUM;
+		tc_mem_write(priv, fpi_addr(__OUTQ_ERB0_CFG_CTXT_BASE),
+			&des_cfg, sizeof(des_cfg));
+
+		/* Init ERB descriptor in PDBRAM */
+		erb_pdbram_base
+			= ptm_pdbram_mem_layout(priv, PDBRAM_ERB, bonding);
+		erb_pdbram_base |= priv->ep->phy_membase;
+
+		for (i = 0; i < __OUTQ_ERB0_NUM; i++) {
+			memset(&desc, 0, sizeof(desc));
+			desc.own = !ERB_DES_PPE_OWN;
+			desc.data_len = ERB_PKT_SIZE;
+			desc.data_ptr = erb_pdbram_base + i * ERB_PKT_SIZE;
+			tc_mem_write(priv,
+				fpi_addr(des_cfg.des_base_addr + i * DESC_DWSZ),
+				&desc, sizeof(desc));
+		}
+	}
+
+	if (bonding) {
+		/* Init OUTQ_ERB_PEER_CFG_CTXT */
+		memset(&des_cfg, 0, sizeof(des_cfg));
+		des_cfg.des_in_own_val = ERB_DES_PPE_OWN;
+		des_cfg.des_base_addr = __OUTQ_ERB_PEER_BASE;
+		des_cfg.des_num = __OUTQ_ERB_PEER_NUM;
+		tc_mem_write(priv, fpi_addr(__OUTQ_ERB_PEER_CFG_CTXT_BASE),
+			&des_cfg, sizeof(des_cfg));
+
+		/* Init ERB descriptor in DS_BOND */
+		/* US_Bond doesn't need init descriptor list */
+		if (!is_us_bond(priv)) {
+			erb_pdbram_base
+				= ptm_pdbram_mem_layout(priv,
+					PDBRAM_ERB, bonding);
+			erb_pdbram_base |= priv->ep->phy_membase;
+
+			for (i = 0; i < __OUTQ_ERB_PEER_NUM; i++) {
+				memset(&desc, 0, sizeof(desc));
+				desc.own = !ERB_DES_PPE_OWN;
+				desc.data_len = ERB_PKT_SIZE;
+				desc.data_ptr = erb_pdbram_base
+							+ i * ERB_PKT_SIZE;
+				tc_mem_write(priv,
+					fpi_addr(des_cfg.des_base_addr
+						+ i * DESC_DWSZ),
+					&desc, sizeof(desc));
+			}
+		}
+
+		/* Initialize FRAGQ_ERB0_CFG_CTXT */
+		if (is_us_bond(priv)) {
+			memset(&frag_des_cfg, 0, sizeof(frag_des_cfg));
+			frag_des_cfg.des_in_own_val = ERB_FRAG_DES_OWN;
+			frag_des_cfg.des_base_addr = __FRAGQ_ERB0_BASE;
+			frag_des_cfg.bp_des_base_addr = __FRAGQ_ERB0_BP_BASE;
+			frag_des_cfg.des_num = __FRAGQ_ERB0_NUM;
+			tc_mem_write(priv, fpi_addr(__FRAGQ_ERB0_CFG_CTXT_BASE),
+				&frag_des_cfg, sizeof(frag_des_cfg));
+		}
+
+		/* Initialize FRAGQ_ERB_PEER_CFG_CTXT */
+		memset(&frag_des_cfg, 0, sizeof(frag_des_cfg));
+		frag_des_cfg.des_in_own_val = ERB_FRAG_DES_OWN;
+		frag_des_cfg.des_base_addr = __FRAGQ_ERB_PEER_BASE;
+		frag_des_cfg.bp_des_base_addr
+			= __FRAGQ_ERB_PEER_BP_BASE;
+		frag_des_cfg.des_num = __FRAGQ_ERB_PEER_NUM;
+		tc_mem_write(priv,
+			fpi_addr(__FRAGQ_ERB_PEER_CFG_CTXT_BASE),
+			&frag_des_cfg, sizeof(frag_des_cfg));
+
+		/* Initialize FRAGQ_ERB descriptor list Only in US_BOND */
+		/* PPE FW Sync __FRAGQ_ERB_PEER descriptor list from US_BOND to DS_BOND */
+		if (is_us_bond(priv)) {
+			addr = __FRAGQ_ERB0_BASE;
+			for (i = 0; i < __FRAGQ_ERB0_NUM; i++) {
+				memset(&desc, 0, sizeof(desc));
+				desc.own = !ERB_DES_PPE_OWN;
+				tc_mem_write(priv,
+					fpi_addr(addr + i * DESC_DWSZ),
+					&desc, sizeof(desc));
+			}
+
+			addr = __FRAGQ_ERB_PEER_BASE;
+			for (i = 0; i < __FRAGQ_ERB_PEER_NUM; i++) {
+				memset(&desc, 0, sizeof(desc));
+				desc.own = !ERB_DES_PPE_OWN;
+				tc_mem_write(priv,
+					fpi_addr(addr + i * DESC_DWSZ),
+					&desc, sizeof(desc));
+			}
+
+			memset(&erb_bg, 0, sizeof(erb_bg));
+			erb_bg.outq_erb_cfg_ctxt = __OUTQ_ERB0_CFG_CTXT_BASE;
+			erb_bg.outq_erb_peer_cfg_ctxt
+				= __OUTQ_ERB_PEER_CFG_CTXT_BASE;
+			/* erb only work for non-preemption queue */
+			addr = __BG_ERB_CFG_CTXT_BASE + DW_SZ(erb_bg);
+			tc_mem_write(priv, fpi_addr(addr),
+				&erb_bg, sizeof(erb_bg));
+		}
+	}
+
+	/* Init DSL TC register, DSL FW can only access 64KB range */
+	if (is_ptm_sl(priv) || (bonding && is_us_bond(priv)))
+		addr = __OUTQ_ERB0_BASE;
+	else
+		addr = __OUTQ_ERB_PEER_BASE;
+	reg_val = fpi_addr(addr) & 0xFFFF;
+	sb_w32(reg_val, ERB_DESC_BASE);
+	sb_w32(des_cfg.des_num, ERB_DESC_NUM);
+	sb_w32(ERB_PKT_SIZE, __ERB_STD_DATA_LEN);
+}
+
+/**
+ * Initialize VRX318 TC Local Descriptor List
+ * Performs below actions
+ *      (1) Allocate and Initialize TC UpStream Local Descriptors
+ *      (2) Allocate and Initialize TC DownStream Local Descriptors
+ */
+static void ptm_local_desq_cfg_ctxt_init(struct ptm_ep_priv *priv, int bonding)
+{
+	int i;
+	rx_descriptor_t desc;
+	desq_cfg_ctxt_t desq_cfg;
+	u32 dcnt, addr, pdbram_base;
+	unsigned int us_des_alloc[] = {
+		__US_TC_LOCAL_Q0_DES_LIST_NUM, __US_TC_LOCAL_Q1_DES_LIST_NUM};
+
+	/* Setup the Local DESQ Configuration/Context for UpStream Queues */
+	memset(&desq_cfg, 0, sizeof(desq_cfg));
+	desq_cfg.des_in_own_val = US_LOCALQ_DES_OWN;
+	for (i = 0, dcnt = 0; i < ARRAY_SIZE(us_des_alloc); i++) {
+		desq_cfg.des_num = us_des_alloc[i];
+		desq_cfg.des_base_addr
+			= __US_TC_LOCAL_Q_DES_LIST_BASE + (dcnt * DW_SZ(desc));
+		if (bonding)
+			desq_cfg.bp_des_base_addr
+				= __US_TC_LOCAL_Q_DES_LIST_BP_BASE +
+							dcnt * BOND_DESC_SZ;
+		addr = fpi_addr(__US_TC_LOCAL_Q_CFG_CTXT_BASE
+				+ (i * DW_SZ(desq_cfg)));
+		tc_mem_write(priv, addr, &desq_cfg, sizeof(desq_cfg));
+		dcnt += us_des_alloc[i];
+	}
+
+	/* Initialize UpStream Descriptors */
+	memset(&desc, 0, sizeof(desc));
+	desc.own = !US_LOCALQ_DES_OWN;
+	desc.data_len = DMA_PACKET_SZ;
+
+	/* Initialize UpStream Descriptors */
+	dcnt = __US_TC_LOCAL_Q0_DES_LIST_NUM + __US_TC_LOCAL_Q1_DES_LIST_NUM;
+	pdbram_base = ptm_pdbram_mem_layout(priv, PDBRAM_US, bonding);
+	for (i = 0; i < dcnt; i++) {
+		desc.data_ptr = priv->ep->phy_membase +
+				(pdbram_base + (i * DMA_PACKET_SZ));
+		addr = fpi_addr(__US_TC_LOCAL_Q_DES_LIST_BASE
+			+ (i * DW_SZ(desc)));
+		tc_mem_write(priv, addr, &desc, sizeof(desc));
+	}
+
+	/* Setup the Local DESQ Configuration/Context for DownStream Queues */
+	memset(&desq_cfg, 0, sizeof(desq_cfg));
+	desq_cfg.des_in_own_val = DS_LOCALQ_DES_OWN;
+	desq_cfg.des_num = __DS_TC_LOCAL_Q_DES_LIST_NUM;
+	desq_cfg.des_base_addr = __DS_TC_LOCAL_Q_DES_LIST_BASE;
+	if (bonding)
+		desq_cfg.bp_des_base_addr = __DS_TC_LOCAL_Q_DES_LIST_BP_BASE;
+	tc_mem_write(priv, fpi_addr(__DS_TC_LOCAL_Q_CFG_CTXT),
+		&desq_cfg, sizeof(desq_cfg));
+
+	/* Initialize DownStream Descriptors */
+	memset(&desc, 0, sizeof(desc));
+	/* CDMA: own: 0--->CPU, 1--->DMA */
+	desc.own = !DS_LOCALQ_DES_OWN;
+	desc.data_len = DMA_PACKET_SZ;
+
+	pdbram_base = ptm_pdbram_mem_layout(priv, PDBRAM_DS, bonding);
+	for (i = 0; i < __DS_TC_LOCAL_Q_DES_LIST_NUM; i++) {
+		desc.data_ptr = priv->ep->phy_membase
+				+ (pdbram_base + (i * DMA_PACKET_SZ));
+		addr = fpi_addr(__DS_TC_LOCAL_Q_DES_LIST_BASE
+				+ (i * DW_SZ(desc)));
+		tc_mem_write(priv, addr, &desc, sizeof(desc));
+	}
+
+	return;
+}
+
+/**
+ * SL/US Bond/DS Bond
+ * OutQ0/US_fragQ1/5 ---->US LocalQ1 (pre-emption)
+ * OutQ1/US_fragQ0/4 ---->US LocalQ0 (none pre-emption)
+ * DS LocalQ0 ---->DS PKT Q0/DS FragQ0/DS FragQ1
+ */
+static void cdma_copy_ch_init(struct ptm_ep_priv *priv, int ep_id, int bonding)
+{
+	cdma_copy_ch_cfg_t ch_cfg;
+	u32 addr, size, dbase;
+	int i, id;
+
+	size = DW_SZ(desq_cfg_ctxt_t);
+	for (i = 0; i < 2; i++) {
+		addr = fpi_addr(__US_CDMA_COPY_CH_CFG + i);
+		if (bonding) {
+			if (is_us_bond(priv))
+				id = 0;
+			else
+				id = 4;
+			dbase = __US_FRAGQ_CFG_CTXT_BASE + id * size;
+		} else
+			dbase = __US_QOS_OUTQ_DES_CFG_CTXT_BASE;
+
+		if (!bonding)
+			ch_cfg.srcq_ctxt_ptr = dbase + ((1 - i) * size);
+		else
+			ch_cfg.srcq_ctxt_ptr = dbase + (i * size);
+		ch_cfg.dstq_ctxt_ptr
+			= __US_TC_LOCAL_Q_CFG_CTXT_BASE + (i * size);
+		tc_mem_write(priv, addr, &ch_cfg, sizeof(ch_cfg));
+	}
+
+	addr = fpi_addr(__DS_CDMA_COPY_CH_CFG);
+	if (bonding) {
+		if (is_us_bond(priv))
+			id = 0;
+		else
+			id = 1;
+		dbase = __DS_FRAGQ_CFG_CTXT_BASE + id * size;
+	} else
+		dbase = __DS_PKT_DESQ_CFG_CTXT;
+	ch_cfg.srcq_ctxt_ptr = __DS_TC_LOCAL_Q_CFG_CTXT;
+	ch_cfg.dstq_ctxt_ptr = dbase;
+	tc_mem_write(priv, addr, &ch_cfg, sizeof(ch_cfg));
+	return;
+}
+
+static void ptm_cdma_ch_setup(struct ptm_ep_priv *priv, u32 cpch_sb_addr,
+					int rx_cid, int tx_cid)
+{
+	u32 rxbase, txbase;
+	u32 rxnum, txnum, addr;
+	const u32 phybase = priv->ep->phy_membase;
+	cdma_copy_ch_cfg_t ch_cfg;
+	desq_cfg_ctxt_t des_cfg;
+
+	addr = fpi_addr(cpch_sb_addr);
+	tc_mem_read(priv, &ch_cfg, addr, sizeof(ch_cfg));
+
+	addr = fpi_addr(ch_cfg.srcq_ctxt_ptr);
+	tc_mem_read(priv, &des_cfg, addr, sizeof(des_cfg));
+	if (priv->tc_priv->param.cdma_desc_loc == LOC_IN_SRAM)
+		txbase = phybase + SB_XBAR_ADDR(des_cfg.des_base_addr);
+	else
+		txbase = phybase + fpi_addr(des_cfg.des_base_addr);
+	txnum = des_cfg.des_num;
+
+	addr = fpi_addr(ch_cfg.dstq_ctxt_ptr);
+	tc_mem_read(priv, &des_cfg, addr, sizeof(des_cfg));
+	if (priv->tc_priv->param.cdma_desc_loc == LOC_IN_SRAM)
+		rxbase = phybase + SB_XBAR_ADDR(des_cfg.des_base_addr);
+	else
+		rxbase = phybase + fpi_addr(des_cfg.des_base_addr);
+	rxnum = des_cfg.des_num;
+
+	cdma_ch_cfg(priv, rx_cid, tx_cid,
+		rxbase, rxnum, txbase, txnum);
+
+	return;
+}
+
+static void ptm_cdma_init(struct ptm_ep_priv *priv)
+{
+	int i;
+	u32 addr;
+
+	tc_cdma_init(priv);
+
+	/* US CDMA channel init */
+	for (i = 0; i < 2; i++) {
+		addr = __US_CDMA_COPY_CH_CFG + i * DW_SZ(cdma_copy_ch_cfg_t);
+		ptm_cdma_ch_setup(priv, addr, (i << 1), (i << 1) + 1);
+	}
+
+	/* DS CDMA channel init */
+	addr = __DS_CDMA_COPY_CH_CFG;
+	ptm_cdma_ch_setup(priv, addr, DS_DMA_RXCH, DS_DMA_TXCH);
+
+	for (i = US_DMA_PRE_RXCH; i <= DS_DMA_TXCH; i += 2)
+		cdma_ch_on(priv, i, i + 1);
+
+	return;
+}
+
+static void ptm_ds_pkt_desq_cfg_ctxt_init(struct ptm_ep_priv *priv)
+{
+	desq_cfg_ctxt_t desq_cfg;
+	int i;
+	rx_descriptor_t desc;
+	dma_addr_t phyaddr;
+	u32 addr;
+
+	memset(&desq_cfg, 0, sizeof(desq_cfg));
+	/* Initialize DS PKT Descriptor Queue Config/Context */
+	desq_cfg.des_in_own_val	= DS_PKT_DES_OWN;
+	desq_cfg.fast_path	= 0;
+	desq_cfg.mbox_int_en	= 0;
+	desq_cfg.des_sync_needed = 0;
+	desq_cfg.des_num	= __DS_PKT_DES_LIST_NUM;
+	desq_cfg.des_base_addr	= __DS_PKT_DES_LIST_BASE;
+
+	tc_mem_write(priv, fpi_addr(__DS_PKT_DESQ_CFG_CTXT),
+		&desq_cfg, sizeof(desq_cfg));
+
+	/* Initialize Descriptors in Shadow DS Path Descriptor List */
+	/**
+	* Shadow descriptor list of SoC, in GRX350, the descriptor pointer
+	* should be synced from SoC. in GRX330, it should be allocated by
+	* VRX318 itself.
+	*/
+	memset(&desc, 0, sizeof(desc));
+	desc.own = !desq_cfg.des_in_own_val;
+	desc.sop = 1;
+	desc.eop = 1;
+	desc.data_len = DMA_PACKET_SZ;
+	addr = desq_cfg.des_base_addr;
+
+	for (i = 0; i < desq_cfg.des_num; i++) {
+		if (tc_buf_alloc(priv, desc.data_len, &phyaddr,
+				DS_DIR, priv->ep->dev) == NULL) {
+			set_tc_status(priv->tc_priv, TC_ERR);
+			return;
+		}
+		desc.data_ptr = phyaddr;
+		tc_mem_write(priv, fpi_addr(addr), &desc, sizeof(desc));
+		addr += DW_SZ(desc);
+	}
+
+	return;
+}
+
+/*TODO: Need calulate PDBRAM ERB size when ERB feature is available */
+static void sram_workaround(struct ptm_ep_priv *priv)
+{
+	u32 pdbram_txout_dbase;
+	u32 pdbram_rxout_dbase;
+	u32 phybase;
+	int bonding;
+
+	sb_w32(1, __PD_SHADOW_PRESENT);
+
+	phybase = priv->ep->phy_membase;
+	bonding = !is_ptm_sl(priv);
+
+	pdbram_txout_dbase
+		= ptm_pdbram_mem_layout(priv, PDBRAM_ACA_TXOUT, bonding);
+	pdbram_rxout_dbase
+		= ptm_pdbram_mem_layout(priv, PDBRAM_ACA_RXOUT, bonding);
+	sb_w32(pdbram_txout_dbase | phybase, __TX_OUT_SHADOW_PTR);
+	sb_w32(pdbram_rxout_dbase | phybase, __RX_OUT_SHADOW_PTR);
+}
+
+static void ppe_aca_cfg(struct ptm_ep_priv *priv)
+{
+	us_aca_cfg_ctxt_t us_ctxt;
+	ds_aca_cfg_ctxt_t ds_ctxt;
+	struct aca_event_reg_addr aca;
+	u32 phybase;
+
+	/* 0 means belong to PPE FW, otherwise belong to ACA FW */
+	sb_w32(1, __TX_IN_ACA_ACCUM_STATUS);
+	sb_w32(1, __TX_OUT_ACA_ACCUM_STATUS);
+	sb_w32(1, __RX_IN_ACA_ACCUM_STATUS);
+	sb_w32(1, __RX_OUT_ACA_ACCUM_STATUS);
+
+	memset(&us_ctxt, 0, sizeof(us_ctxt));
+	memset(&ds_ctxt, 0, sizeof(ds_ctxt));
+
+	phybase = priv->ep->phy_membase;
+	priv->ep->hw_ops->aca_event_addr_get(priv->ep, &aca);
+	us_ctxt.tx_in_aca_msg_ptr = aca.txin_acc_sub | phybase;
+	us_ctxt.tx_out_aca_msg_ptr = aca.txout_acc_add | phybase;
+	us_ctxt.tx_out_aca_status_ptr
+		= SB_XBAR_ADDR(__TX_OUT_ACA_ACCUM_STATUS) | phybase;
+	ds_ctxt.rx_in_aca_msg_ptr = aca.rxin_acc_sub | phybase;
+	ds_ctxt.rx_out_aca_msg_ptr = aca.rxout_acc_add | phybase;
+	ds_ctxt.rx_in_aca_status_ptr
+		= SB_XBAR_ADDR(__RX_IN_ACA_ACCUM_STATUS) | phybase;
+	ds_ctxt.rx_out_aca_status_ptr
+		= SB_XBAR_ADDR(__RX_OUT_ACA_ACCUM_STATUS) | phybase;
+	tc_mem_write(priv, fpi_addr(__US_ACA_CFG_CTXT_BASE),
+		&us_ctxt, sizeof(us_ctxt));
+	tc_mem_write(priv, fpi_addr(__DS_ACA_CFG_CTXT_BASE),
+		&ds_ctxt, sizeof(ds_ctxt));
+
+	sb_w32(phybase, __EP_ADDR_BAR);
+	if (priv->tc_priv->param.cdma_desc_loc == LOC_IN_FPI)
+		sram_workaround(priv);
+}
+
+/**
+ * Pre-emption queue(Bonding Group 0) ---> GIF 1 and GIF 5
+ * Non-preemption queue(Bonding Group 1) ---> GIF 0 and GIF 4
+ */
+static void ptm_us_bg_ctxt_init(struct ptm_ep_priv *priv, int ep_id)
+{
+	int i;
+	us_bg_ctxt_t us_bg_ctxt;
+	us_bg_gmap_t us_bg_gmap;
+	u32 addr;
+
+	if (!is_us_bond(priv))
+		return;
+
+	memset(&us_bg_ctxt, 0, sizeof(us_bg_ctxt));
+	memset(&us_bg_gmap, 0, sizeof(us_bg_gmap));
+
+	for (i = 0; i < US_BG_NUM; i++) {
+		us_bg_ctxt.desq_cfg_ctxt_ptr = __US_QOS_OUTQ_DES_CFG_CTXT_BASE
+			+ (i * (DW_SZ(desq_cfg_ctxt_t)));
+		addr = fpi_addr(__US_BG_CTXT_BASE + (i * DW_SZ(us_bg_ctxt_t)));
+		tc_mem_write(priv, addr, &us_bg_ctxt, sizeof(us_bg_ctxt_t));
+	}
+
+	/* bonding group 0 mapping to GIF 1 and GIF 5 */
+	us_bg_gmap.gif_map0 = BIT(1) | BIT(5);
+	/* bonding group 1 mapping to GIF 0 and GIF 4 */
+	us_bg_gmap.gif_map1 = BIT(0) | BIT(4);
+	tc_mem_write(priv, fpi_addr(__US_BG_GMAP),
+			&us_bg_gmap, sizeof(us_bg_gmap));
+
+	return;
+}
+
+static void ptm_ds_bg_ctxt_init(struct ptm_ep_priv *priv, int ep_id)
+{
+	int i;
+	u32 addr;
+	ds_bg_ctxt_t ds_bg_ctxt;
+	ds_bg_gmap_t ds_bg_gmap;
+
+	if (ep_id != DS_BOND)
+		return;
+
+	memset(&ds_bg_ctxt, 0, sizeof(ds_bg_ctxt_t));
+	ds_bg_ctxt.last_eop = 1;
+
+	for (i = 0; i < 4; i++) {
+		addr = fpi_addr(__DS_BG_CTXT_BASE + (i * DW_SZ(ds_bg_ctxt_t)));
+		tc_mem_write(priv, addr, &ds_bg_ctxt, sizeof(ds_bg_ctxt_t));
+	}
+
+	/* bonding group 0 mapping to GIF 0 and GIF 4*/
+	memset(&ds_bg_gmap, 0, sizeof(ds_bg_gmap));
+	ds_bg_gmap.gif_map0 = BIT(0) | BIT(4);
+	tc_mem_write(priv, fpi_addr(__DS_BG_GMAP),
+			&ds_bg_gmap, sizeof(ds_bg_gmap));
+
+	return;
+}
+
+/**
+ * Bonding descriptor format:
+ * 16 DMA descriptrs followd by 16 Bonding descriptors
+ */
+static void us_fragq_des_cfg_ctxt_init(struct ptm_ep_priv *priv, int ep_id)
+{
+	int i, j;
+	u32 size;
+	desq_cfg_ctxt_t des_cfg;
+	rx_descriptor_t desc;
+	unsigned int addr;
+
+	memset(&des_cfg, 0, sizeof(des_cfg));
+
+	if (ep_id == DS_BOND)
+		i = 4;
+	else
+		i = 0;
+
+	size = DW_SZ(rx_descriptor_t) + BOND_DESC_SZ;
+	for (; i < __US_FRAGQ_DES_LIST_NUM_Q; i++) {
+		/* Initialize Upstream Descriptor Queue Config/Context */
+		des_cfg.des_in_own_val  = US_FRAGQ_DES_OWN;
+		des_cfg.fast_path       = 0;
+		des_cfg.mbox_int_en     = 0;
+		des_cfg.des_sync_needed = 0;
+		des_cfg.gif_id          = i;
+		des_cfg.des_num         = __US_FRAGQ_DES_LIST_PERQ_NUM;
+		des_cfg.des_base_addr = __US_FRAGQ_DES_LIST_BASE
+					+ (i * size * des_cfg.des_num);
+		des_cfg.bp_des_base_addr = des_cfg.des_base_addr
+					+ (DW_SZ(desc) * des_cfg.des_num);
+		addr = fpi_addr(__US_FRAGQ_CFG_CTXT_BASE + i * DW_SZ(des_cfg));
+		tc_mem_write(priv, addr, &des_cfg, sizeof(des_cfg));
+
+		/* Only OWN bit init is required in FragmentQ Desc List */
+		memset(&desc, 0, sizeof(desc));
+		desc.own = !US_FRAGQ_DES_OWN;
+
+		for (j = 0; j < des_cfg.des_num; j++) {
+			addr = __US_FRAGQ_DES_LIST_BASE
+				+ i * size * des_cfg.des_num + j * DW_SZ(desc);
+			tc_mem_write(priv, fpi_addr(addr), &desc, sizeof(desc));
+		}
+	}
+
+	return;
+}
+
+static void ds_fragq_des_cfg_ctxt_init(struct ptm_ep_priv *priv, int ep_id)
+{
+	int i;
+	u32 addr, size, id;
+	desq_cfg_ctxt_t des_cfg;
+	rx_descriptor_t desc;
+	dma_addr_t phy_addr;
+
+	memset(&des_cfg, 0, sizeof(des_cfg));
+
+	if (ep_id == DS_BOND)
+		id = 2;
+	else if (ep_id == US_BOND)
+		id = 1;
+	else {
+		tc_err(priv->tc_priv, MSG_INIT, "ep id wrong: %d\n", ep_id);
+		return;
+	}
+
+	size = DW_SZ(desc) + BOND_DESC_SZ;
+	for (i = 0; i < id; i++) {
+		/* Initialize Downstream Descriptor Queue Config/Context */
+		des_cfg.des_in_own_val  = DS_FRAGQ_DES_OWN;
+		des_cfg.fast_path       = 0;
+		des_cfg.mbox_int_en     = 0;
+		des_cfg.des_sync_needed = 0;
+		des_cfg.gif_id          = (i == 1) ? 4 : 0;
+		des_cfg.des_num         = __DS_FRAGQ_DES_LIST_PERQ_NUM;
+		des_cfg.des_base_addr   = __DS_FRAGQ_DES_LIST_BASE +
+				(i * size * des_cfg.des_num);
+		des_cfg.bp_des_base_addr = des_cfg.des_base_addr
+				+ (DW_SZ(desc) * des_cfg.des_num);
+
+		addr = fpi_addr(__DS_FRAGQ_CFG_CTXT_BASE
+				+ (i * DW_SZ(des_cfg)));
+		tc_mem_write(priv, addr, &des_cfg, sizeof(des_cfg));
+	}
+	/* Initialize OWN bit of desc in FragmentQ Descriptor List */
+	memset(&desc, 0, sizeof(desc));
+	desc.own = !DS_FRAGQ_DES_OWN;
+	desc.data_len = DMA_PACKET_SZ;
+
+	for (i = 0; i < des_cfg.des_num; i++) {
+		addr = fpi_addr(des_cfg.des_base_addr + i * DW_SZ(desc));
+		if (tc_buf_alloc(priv, DMA_PACKET_SZ,
+				&phy_addr, DS_DIR, priv->ep->dev) == NULL) {
+			set_tc_status(priv->tc_priv, TC_ERR);
+			return;
+		}
+
+		desc.data_ptr = (unsigned int)phy_addr;
+		tc_mem_write(priv, addr, &desc, sizeof(desc));
+	}
+
+	/**
+	 * DS bonding master need init shadow descriptor list
+	 * for US bonding master to sync
+	 * Only ownbit init is required
+	 */
+	if (ep_id == DS_BOND) {
+		memset(&desc, 0, sizeof(desc));
+		desc.own = !DS_FRAGQ_DES_OWN;
+		for (i = 0; i < __DS_FRAGQ_DES_LIST_PERQ_NUM; i++) {
+			addr = fpi_addr(__DS_FRAGQ_DES_LIST_BASE
+				+ i * DW_SZ(desc));
+			tc_mem_write(priv, addr, &desc, sizeof(desc));
+		}
+	}
+
+	return;
+}
+
+/**
+ * Total 256 free descriptor, 9(1 free frag link list, 8 (2(BC) * 4(GIF)) frag link list
+ * 256 free desciptor in free frag link list on initialization.
+ */
+static void ds_ll_ctxt_init(struct ptm_ep_priv *priv, int ep_id)
+{
+	int i;
+	u32 addr;
+	ds_bond_gif_ll_ctxt_t ll_ctxt;
+	ds_bond_gif_ll_des_t ll_desc;
+	dma_addr_t phy_addr;
+
+	if (ep_id != DS_BOND)
+		return;
+
+	memset(&ll_ctxt, 0, sizeof(ll_ctxt));
+
+	ll_ctxt.max_des_num = ((BOND_LL_DES_NUM / 8) < 0xFF) ?
+				(BOND_LL_DES_NUM / 8) : 0xFF;
+	/* if free_des_num <= 16, timeout any frag */
+	ll_ctxt.to_buff_thres = 16;
+	ll_ctxt.max_delay = 0xFFFF; /*  TODO: fix the number */
+
+	addr = __DS_BOND_LL_CTXT_BASE;
+	for (i = 0; i < BOND_LL_NUM; i++) {
+		addr = fpi_addr(__DS_BOND_LL_CTXT_BASE + i * DW_SZ(ll_ctxt));
+		tc_mem_write(priv, addr, &ll_ctxt, sizeof(ll_ctxt));
+	}
+
+	ll_ctxt.head_ptr = __DS_BOND_GIF_LL_DES_BA;
+	ll_ctxt.tail_ptr = __DS_BOND_GIF_LL_DES_BA +
+				((BOND_LL_DES_NUM - 1) * 2);
+	ll_ctxt.des_num = BOND_LL_DES_NUM;
+	tc_mem_write(priv, fpi_addr(__DS_BOND_LL_CTXT_BASE),
+		&ll_ctxt, sizeof(ll_ctxt));
+
+	/* Initialize DS GIF LL Descriptors */
+	/* link list, last one pointer back to the first one */
+	for (i = 0; i < BOND_LL_DES_NUM; i++) {
+		ll_desc.next_des_ptr
+			= __DS_BOND_GIF_LL_DES_BA +
+			(((i + 1) % BOND_LL_DES_NUM) * DW_SZ(ll_desc));
+		ll_desc.data_len = DMA_PACKET_SZ;
+		if (tc_buf_alloc(priv, ll_desc.data_len,
+			&phy_addr, DS_DIR, priv->ep->dev) == NULL) {
+			set_tc_status(priv->tc_priv, TC_ERR);
+			return;
+		}
+		ll_desc.data_ptr = phy_addr;
+		tc_mem_write(priv, DS_BOND_GIF_LL_DES_BA(i),
+			&ll_desc, sizeof(ll_desc));
+	}
+
+	return;
+}
+
+static void ptm_fw_bonding_init(struct ptm_ep_priv *priv,
+						u32 ep_id, int bonding)
+{
+	if (!bonding)
+		return;
+
+	ptm_us_bg_ctxt_init(priv, ep_id);
+	ptm_ds_bg_ctxt_init(priv, ep_id);
+	us_fragq_des_cfg_ctxt_init(priv, ep_id);
+	ds_fragq_des_cfg_ctxt_init(priv, ep_id);
+	ds_ll_ctxt_init(priv, ep_id);
+}
+
+/**
+ *  PTM TC HW and FW Initialization
+ */
+static void ppe_ptm_fw_hw_init(struct ptm_ep_priv *priv,
+				u32 ep_id, int bonding)
+{
+	/* Clear PPE SB */
+	ppe_sb_clear(priv);
+	/* Clear PDBRAM */
+	pdbram_clear(priv);
+
+	ptm_hw_init(priv);
+	ptm_fw_init(priv, bonding);
+
+	ptm_gen_cfg_init(priv, bonding);
+	us_qos_cfg_init(priv);
+	ptm_local_desq_cfg_ctxt_init(priv, bonding);
+	ptm_erb_init(priv, bonding);
+	ptm_ds_pkt_desq_cfg_ctxt_init(priv);
+	ptm_fw_bonding_init(priv, ep_id, bonding);
+
+	cdma_copy_ch_init(priv, ep_id, bonding);
+	ptm_cdma_init(priv);
+	ppe_aca_cfg(priv);
+}
+
+/**
+ * Disable Powersaving
+ * Enable MBOX1 Interrupt (MBOX_FW_UNLOAD)
+ * Send MBOX5 Interrupt to wake up PPE FW
+ */
+static void ptm_ppe_wakeup(struct ptm_ep_priv *priv)
+{
+	u32 mbox_ier;
+
+	if (priv->tc_priv->param.ps) {
+		ptm_power_saving(priv, 0, 1);
+		priv->tc_priv->param.ps = 1;
+	}
+
+	mbox_ier = tc_r32(MBOX_IGU_IER(MBOX_IGU1));
+	mbox_ier |= MBOX_FRAME_STOP;
+	mbox_set_ier(priv, MBOX_IGU1, mbox_ier);
+
+	if (priv->tc_priv->param.ps)
+		mbox_set_isr(priv, PPE_FW_MBOX0, MBOX_FW_WAKEUP);
+}
+
+/**
+ * Restore Powersaving setting.
+ */
+static void ptm_ppe_ps_restore(struct ptm_ep_priv *priv)
+{
+	u32 mbox_ier;
+
+	mbox_ier = tc_r32(MBOX_IGU_IER(MBOX_IGU1));
+	mbox_ier &= ~MBOX_FRAME_STOP;
+	mbox_set_ier(priv, MBOX_IGU1, mbox_ier);
+
+	if (priv->tc_priv->param.ps)
+		ptm_power_saving(priv, 1, 1);
+}
+
+/**
+ * Driver lift ACA TXIN after enter showtime
+ * Default DFE rate is 1500, which mapping to max value 0x1FFF.
+ */
+static int ptm_showtime_enter(const unsigned char idx,
+		struct port_cell_info *port_cell, void *xdata_addr)
+{
+	struct ptm_priv *ptm_tc = g_ptm_priv;
+	struct ptm_ep_priv *priv = tc_ep_priv(idx);
+	struct ptm_ep_priv *uspriv;
+	struct dc_ep_dev *ep;
+	u32 rate;
+
+	tc_info(priv->tc_priv, MSG_EVENT, "Line[%d]: show time enter!!\n", idx);
+	netif_carrier_on(ptm_tc->dev);
+	ptm_ppe_ps_restore(priv);
+
+	if (is_ptm_sl(priv)) {
+		ep = priv->ep;
+		ep->hw_ops->aca_start(priv->ep, ACA_TXIN_EN, 0);
+	} else { /* in bonding mode, must enable us_bonding master */
+		uspriv = tc_ep_priv(US_BOND);
+		ep = priv->ep;
+		ep->hw_ops->aca_start(priv->ep, ACA_TXIN_EN, 0);
+	}
+
+	if (ptm_tc->tc_priv->param.dfe_loopback == 1) {
+		priv->dfe_rate = port_cell->tx_link_rate[0];
+		rate = (priv->dfe_rate * 0x2000) / 1500;
+		if (rate >= 0x1FFF)
+			rate = 0x1FFF;
+		tc_w32(rate, DREG_B_LADR(0));
+	}
+
+	return 0;
+}
+
+/**
+ * Driver Halt ACA TXIN after leave showtime
+ * TTHA reset is required if showtime exit.
+ */
+static int ptm_showtime_exit(const unsigned char idx)
+{
+	struct ptm_priv *ptm_tc = g_ptm_priv;
+	struct ptm_ep_priv *priv = tc_ep_priv(idx);
+	u32 stop = ACA_TXIN_EN;
+	struct dc_ep_dev *ep;
+
+	tc_info(priv->tc_priv, MSG_EVENT, "Line[%d]: show time exit!\n", idx);
+
+	if (!showtime_stat(ptm_tc->tc_priv)) {
+		ep = priv->ep;
+		ep->hw_ops->aca_stop(ep, &stop, 0);
+		netif_carrier_off(ptm_tc->dev);
+	}
+	ptm_ppe_wakeup(priv);
+
+	return 0;
+}
+
+static int ptm_erb_addr_get(const unsigned char idx,
+	unsigned int *data_addr, unsigned int *desc_addr)
+{
+	struct ptm_ep_priv *priv = tc_ep_priv(idx);
+	unsigned int addr;
+	int bonding;
+
+	bonding = !is_ptm_sl(priv);
+
+	addr = ptm_pdbram_mem_layout(priv, PDBRAM_ERB, bonding);
+	*data_addr  = (priv->ep->phy_membase | addr) & 0xFFFF0000;
+	if (!bonding || is_us_bond(priv))
+		addr = __OUTQ_ERB0_BASE;
+	else
+		addr = __OUTQ_ERB_PEER_BASE;
+
+	addr = fpi_addr(addr);
+	*desc_addr = (priv->ep->phy_membase | addr) & 0xFFFF0000;
+
+	tc_dbg(priv->tc_priv, MSG_EVENT,
+		"idx: %d, data addr: 0x%x,  desc_addr: 0x%x\n",
+		idx, *data_addr, *desc_addr);
+
+	return 0;
+}
+
+static int ptm_framer_requst_en(const unsigned char idx)
+{
+	struct ptm_ep_priv *priv = tc_ep_priv(idx);
+
+	ttha_enable(priv);
+
+	return 0;
+}
+
+static void ptm_cb_setup(struct ptm_priv *ptm_tc, int flag)
+{
+	spin_lock_bh(&ptm_tc->ptm_lock);
+
+	if (!flag) {
+		ptm_tc->tc_priv->tc_ops.recv = NULL;
+		ptm_tc->tc_priv->tc_ops.get_qid = NULL;
+		ptm_tc->tc_priv->tc_ops.irq_on = NULL;
+		ptm_tc->tc_priv->tc_ops.irq_off = NULL;
+		ptm_tc->tc_priv->tc_ops.showtime_enter = NULL;
+		ptm_tc->tc_priv->tc_ops.showtime_exit = NULL;
+		ptm_tc->tc_priv->tc_ops.erb_addr_get = NULL;
+		ptm_tc->tc_priv->tc_ops.framer_request_en = NULL;
+	} else {
+		ptm_tc->tc_priv->tc_ops.recv = ptm_rx;
+		ptm_tc->tc_priv->tc_ops.get_qid = ptm_get_qid;
+		ptm_tc->tc_priv->tc_ops.irq_on = ptm_irq_on;
+		ptm_tc->tc_priv->tc_ops.irq_off = ptm_irq_off;
+		ptm_tc->tc_priv->tc_ops.showtime_enter = ptm_showtime_enter;
+		ptm_tc->tc_priv->tc_ops.showtime_exit = ptm_showtime_exit;
+		ptm_tc->tc_priv->tc_ops.erb_addr_get = ptm_erb_addr_get;
+		ptm_tc->tc_priv->tc_ops.framer_request_en
+			= ptm_framer_requst_en;
+	}
+	spin_unlock_bh(&ptm_tc->ptm_lock);
+}
+
+static irqreturn_t ptm_irq_handler(int irq, void *dev_id)
+{
+	u32 mbox1_isr, mbox1_ier, mbox1_isrc;
+	/*u32 peer_state, peer_base;*/
+	struct ptm_ep_priv *priv = dev_id;
+
+	mbox1_ier = tc_r32(MBOX_IGU_IER(MBOX_IGU1));
+	mbox1_isrc = tc_r32(MBOX_IGU_ISR(MBOX_IGU1));
+
+	mbox1_isr = mbox1_isrc & mbox1_ier;
+
+	if (mbox1_isr & MBOX_PKT_RX) {
+		mbox1_ier &= ~MBOX_PKT_RX;
+		mbox_set_ier(priv, MBOX_IGU1, mbox1_ier);
+		if (priv->tc_priv->tc_ops.coc_req != NULL)
+			priv->tc_priv->tc_ops.coc_req();
+	}
+
+	if (mbox1_isr & MBOX_FRAME_STOP)
+		ttha_disable(priv, 0);
+
+	mbox_clr_isr(priv, MBOX_IGU1, mbox1_isrc);
+
+	return IRQ_HANDLED;
+}
+
+static void ptm_datapath_init(struct ptm_ep_priv *priv, const char *dev_name)
+{
+	int ret;
+
+	ret = devm_request_irq(priv->ep->dev, priv->ep->irq,
+			ptm_irq_handler, 0, dev_name, priv);
+
+	if (ret) {
+		tc_err(priv->tc_priv, MSG_INIT, "PTM Register Interrupt Fail!\n");
+		return;
+	}
+
+	return;
+}
+
+static void ptm_fw_load(struct ptm_priv *ptm_tc)
+{
+	int i;
+	u32 size;
+	struct ppe_fw *fw = &ptm_tc->fw;
+	struct fw_bin *binfw = &ptm_tc->tc_priv->fw;
+
+	memcpy(&fw->atm_ver, &binfw->fw_hdr.atm_ver, sizeof(fw->atm_ver));
+	memcpy(&fw->ptm_ver, &binfw->fw_hdr.ptm_ver, sizeof(fw->ptm_ver));
+	for (i = 0; i < PP32_MAX; i++) {
+		size = binfw->fw_hdr.fw_info[i].fw_size;
+		fw->ptm_fw.size[i] = binfw->fw_hdr.fw_info[i].fw_size;
+		fw->ptm_fw.data[i] = (const u32 *)binfw->fw_ptr[i];
+	}
+}
+
+/**
+ * 1. Powerup PPE component
+ * 2. Init PPE, enable Idle cell, Enable TTHA
+ * 3. Powerup and configure CDMA
+ * 4. Enable loopback if required
+ * 5. PPE start
+ */
+static void ptm_tc_hw_fw_init(struct ptm_ep_priv *priv,
+				u32 ep_id, int bonding)
+{
+	int i;
+	const char *drv_name;
+	struct ptm_priv *ptm_tc;
+
+	tc_dbg(priv->tc_priv, MSG_SWITCH, "id(Line)\t\t= %d\n", ep_id);
+	tc_dbg(priv->tc_priv, MSG_SWITCH, "irq\t\t\t= %u\n", priv->ep->irq);
+	tc_dbg(priv->tc_priv, MSG_SWITCH, "membase\t\t= 0x%08x\n",
+		(unsigned int __force)priv->ep->membase);
+	tc_dbg(priv->tc_priv, MSG_SWITCH,
+		"phy_membase\t\t= 0x%08x\n", priv->ep->phy_membase);
+	tc_dbg(priv->tc_priv, MSG_SWITCH,
+		"peer_num\t\t= %u\n", priv->ep->peer_num);
+	tc_dbg(priv->tc_priv, MSG_SWITCH, "tc_mode\t\t= %s\n",
+		bonding ? "PTM Bonding" : "PTM Single Line");
+
+	ptm_tc = g_ptm_priv;
+	/* Power on Modem component */
+	tc_clkon(priv->ep, PMU_PTM);
+	/* Reset PPE HW */
+	tc_ppe_rst(priv->ep);
+	/* Set VRX318 PPE clock 576MHz */
+	tc_ppe_clkset(priv->ep, PPE_CLK_576MHZ);
+	/* Clear and disable mailbox */
+	for (i = MBOX_IGU0; i <= MBOX_IGU2; i++) {
+		mbox_set_ier(priv, i, 0);
+		mbox_clr_isr(priv, i, MBOX_MASK(i));
+	}
+
+	/* Freeze PP32 */
+	ppe_stop(priv);
+	ppe_ptm_fw_hw_init(priv, ep_id, bonding);
+	ptm_fw_load(ptm_tc);
+	pp32_load(priv, &ptm_tc->fw, 0);
+
+	/* init datapath */
+	if (bonding)
+		drv_name = ptm_bond_name[ep_id];
+	else
+		drv_name = ptm_drv_name;
+	ptm_datapath_init(priv, drv_name);
+
+	/* start hardware */
+	setup_dfe_loopback(priv, priv->dfe_rate);
+	ppe_start(priv);
+	dfe_loopback_linkup(priv);
+
+	/* Indicate DSL FW all configuration is ready */
+	/* PPE FW is ready to receive/send packets */
+	tc_stat_indicate(priv, priv->tc_priv->tc_mode, 1);
+
+	/* enable mailbox */
+	mbox_set_ier(priv, MBOX_IGU1, MBOX_PKT_RX | MBOX_FRAME_STOP);
+
+	tc_info(priv->tc_priv, MSG_SWITCH, "PTM TC init successfully\n");
+	return;
+}
+
+static void ptm_aca_init(struct ptm_ep_priv *priv)
+{
+	struct aca_param param;
+	struct aca_modem_param mdm;
+	struct aca_cfg_param *txin;
+	struct aca_cfg_param *txout;
+	struct aca_cfg_param *rxout;
+	struct soc_cfg *cfg;
+	u32 phybase = priv->ep->phy_membase;
+	u32 start;
+	u32 type;
+
+	priv->tc_priv->tc_ops.soc_cfg_get(&priv->tc_priv->cfg, ptm_id(priv));
+	memset(&param, 0, sizeof(param));
+	cfg = &priv->tc_priv->cfg;
+
+	txin = &param.aca_txin;
+	txin->byteswap = 1;
+	txin->hd_size_in_dw = cfg->desc_dw_sz;
+	txin->pd_desc_base = SB_XBAR_ADDR(__ACA_TX_IN_PD_LIST_BASE);
+	txin->pd_desc_num = __ACA_TX_IN_PD_LIST_NUM;
+	txin->pd_size_in_dw = DESC_DWSZ;
+	txin->soc_desc_base = cfg->txin_dbase;
+	txin->soc_desc_num = cfg->txin_dnum;
+	txin->pp_buf_desc_num = ACA_TXIN_HD_DESC_NUM;
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"txin: bswp: %d, hdsz:%d, pd: dbase(0x%x), dnum(%d), sz_indw(%d), soc_dbase:0x%x, soc_dnum:0x%x\n",
+		txin->byteswap, txin->hd_size_in_dw, txin->pd_desc_base,
+		txin->pd_desc_num, txin->pd_size_in_dw,
+		txin->soc_desc_base, txin->soc_desc_num);
+
+	txout = &param.aca_txout;
+	txout->byteswap = 1;
+	txout->hd_size_in_dw = 1;
+	if (priv->tc_priv->param.cdma_desc_loc == LOC_IN_FPI)
+		txout->pd_desc_base = sb_r32(__TX_OUT_SHADOW_PTR);
+	else
+		txout->pd_desc_base = SB_XBAR_ADDR(__ACA_TX_OUT_PD_LIST_BASE);
+	txout->pd_desc_num = __ACA_TX_OUT_PD_LIST_NUM;
+	txout->pd_size_in_dw = DESC_DWSZ;
+	txout->soc_desc_base = cfg->txout_dbase;
+	txout->soc_desc_num = cfg->txout_dnum;
+	txout->pp_buf_desc_num = ACA_TXOUT_HD_DESC_NUM;
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"txout: bswp: %d, hdsz:%d, pd: dbase(0x%x), dnum(%d), sz_indw(%d), soc_dbase:0x%x, soc_dnum:0x%x\n",
+		txout->byteswap, txout->hd_size_in_dw, txout->pd_desc_base,
+		txout->pd_desc_num, txout->pd_size_in_dw,
+		txout->soc_desc_base, txout->soc_desc_num);
+
+	rxout = &param.aca_rxout;
+	rxout->byteswap = 1;
+	rxout->hd_size_in_dw = cfg->desc_dw_sz;
+	if (priv->tc_priv->param.cdma_desc_loc == LOC_IN_FPI)
+		rxout->pd_desc_base = sb_r32(__RX_OUT_SHADOW_PTR);
+	else
+		rxout->pd_desc_base = SB_XBAR_ADDR(__ACA_RX_OUT_PD_LIST_BASE);
+	rxout->pd_desc_num = __ACA_RX_OUT_PD_LIST_NUM;
+	rxout->pd_size_in_dw = DESC_DWSZ;
+	rxout->soc_desc_base = cfg->rxout_dbase;
+	rxout->soc_desc_num = cfg->rxout_dnum;
+	rxout->pp_buf_desc_num = ACA_RXOUT_HD_DESC_NUM;
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"rxout: bswp: %d, hdsz:%d, pd: dbase(0x%x), dnum(%d), sz_indw(%d), soc_dbase:0x%x, soc_dnum:0x%x\n",
+		rxout->byteswap, rxout->hd_size_in_dw, rxout->pd_desc_base,
+		rxout->pd_desc_num, rxout->pd_size_in_dw,
+		rxout->soc_desc_base, rxout->soc_desc_num);
+
+	if (priv->tc_priv->param.cdma_desc_loc == LOC_IN_SRAM)
+		type = TC_SRAM_ADDR;
+	else
+		type = TC_FPI_ADDR;
+	mdm.mdm_txout.stat
+		= tc_addr(__TX_OUT_ACA_ACCUM_STATUS, type, phybase);
+	mdm.mdm_txout.pd
+		= tc_addr(__TX_OUT_QUEUE_PD_BASE_ADDR_OFFSET, type, phybase);
+	mdm.mdm_txout.acc_cnt
+		= tc_addr(__TX_OUT_ACA_ACCUM_COUNT, type , phybase);
+
+	mdm.mdm_rxout.stat
+		= tc_addr(__RX_OUT_ACA_ACCUM_STATUS, type, phybase);
+	mdm.mdm_rxout.pd
+		= tc_addr(__RX_OUT_QUEUE_PD_BASE_ADDR_OFFSET, type, phybase);
+	mdm.mdm_rxout.acc_cnt
+		= tc_addr(__RX_OUT_ACA_ACCUM_COUNT, type, phybase);
+
+	mdm.mdm_rxin.stat
+		= tc_addr(__RX_IN_ACA_ACCUM_STATUS, type, phybase);
+	mdm.mdm_rxin.pd
+		= tc_addr(__RX_IN_QUEUE_PD_BASE_ADDR_OFFSET, type, phybase);
+	mdm.mdm_rxin.acc_cnt
+		= tc_addr(__RX_IN_ACA_ACCUM_COUNT, type, phybase);
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"txout: (stat:0x%x, pd: 0x%x, cnt: 0x%x)\n",
+		mdm.mdm_txout.stat, mdm.mdm_txout.pd, mdm.mdm_txout.acc_cnt);
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"rxout: (stat:0x%x, pd: 0x%x, cnt: 0x%x)\n",
+		mdm.mdm_rxout.stat, mdm.mdm_rxout.pd, mdm.mdm_rxout.acc_cnt);
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"rxin: (stat:0x%x, pd: 0x%x, cnt: 0x%x)\n",
+		mdm.mdm_rxin.stat, mdm.mdm_rxin.pd, mdm.mdm_rxin.acc_cnt);
+
+	priv->ep->hw_ops->aca_init(priv->ep, &param, &mdm);
+
+	start = ACA_ALL_EN;
+	priv->ep->hw_ops->aca_stop(priv->ep, &start, 0);
+
+	if (is_ptm_sl(priv))
+		start = ACA_TXOUT_EN | ACA_RXIN_EN | ACA_RXOUT_EN;
+	else {
+		if (is_us_bond(priv))
+			start = ACA_TXOUT_EN;
+		else
+			start = ACA_RXIN_EN | ACA_RXOUT_EN;
+	}
+
+	priv->ep->hw_ops->aca_start(priv->ep, start, 1);
+}
+
+static void ptm_umt_init(struct ptm_ep_priv *priv)
+{
+	struct tc_priv *tcpriv;
+	u32 dst;
+	u32 period;
+
+	tcpriv = priv->tc_priv;
+	dst = priv->ep->hw_ops->umt_msg_addr(priv->ep);
+	dst |= priv->ep->phy_membase;
+	period = tcpriv->param.umt_period;
+
+	tcpriv->tc_ops.umt_init(ptm_id(priv), period, dst);
+}
+
+static void ptm_umt_start(struct ptm_ep_priv *priv)
+{
+	priv->tc_priv->tc_ops.umt_start(ptm_id(priv));
+}
+
+/**
+ * 1. Powerup PPE component
+ * 2. Init PPE, enable Idle cell, Enable TTHA
+ * 3. Powerup and configure CDMA
+ * 4. Enable DFE loopback if required
+ * 5. PPE start
+ * 6. Init UMT and SoC DMA
+ * 7. Init and start ACA
+ * 8. Start UMT and SoC DMA
+ */
+void ptm_tc_load(struct tc_priv *tc_priv,
+			u32 id, enum dsl_tc_mode tc_mode)
+{
+	struct ptm_priv *ptm_tc;
+	struct ptm_ep_priv *priv;
+	int bonding, i;
+
+	if (!g_ptm_priv)
+		ptm_dev_init(tc_priv, id, tc_mode);
+
+	ptm_tc = g_ptm_priv;
+
+	/**
+	 * Sequence must be guaranteed
+	 * 1. umt init
+	 * 2. soc cfg get
+	 * 3. aca init
+	 * 4. umt start
+	 */
+	bonding = (tc_mode == TC_PTM_BND_MODE);
+	if (!bonding) {
+		priv = tc_ep_priv(id);
+		ptm_tc_hw_fw_init(priv, id, bonding);
+		ptm_umt_init(priv);
+		ptm_aca_init(priv);
+		ptm_umt_start(priv);
+		ptm_tc_proc_init(priv);
+		ptm_tc->ep_id = id;
+	} else {
+		for (i = 0; i < BOND_MAX; i++) {
+			priv = tc_ep_priv(i);
+			ptm_tc_hw_fw_init(priv, i, bonding);
+			ptm_umt_init(priv);
+			ptm_aca_init(priv);
+			ptm_umt_start(priv);
+			ptm_tc_proc_init(priv);
+		}
+	}
+	tc_priv->priv = ptm_tc;
+	ptm_cb_setup(ptm_tc, 1);
+	if (priv->tc_priv->tc_ops.dev_reg != NULL)
+		priv->tc_priv->tc_ops.dev_reg(ptm_tc->dev,
+			ptm_tc->dev->name, &ptm_tc->subif_id, 0);
+	if (priv->tc_priv->tc_ops.disable_us != NULL)
+		priv->tc_priv->tc_ops.disable_us(0);
+
+	/* Send userspace TC UP message */
+	tc_ntlk_msg_send(tc_priv, 0, PTM_TC, TC_LOADED,
+		(tc_mode == TC_PTM_BND_MODE) ? BONDING_MODE : NON_BONDING_MODE,
+		id);
+
+	tc_info(tc_priv, MSG_SWITCH, "PTM TC is successfully loaded\n");
+
+	return;
+}
+
+static void ptm_datapath_exit(struct ptm_ep_priv *priv)
+{
+	devm_free_irq(priv->ep->dev, priv->ep->irq, priv);
+}
+
+static inline void aca_txin_wait(struct ptm_ep_priv *priv)
+{
+	msleep(ACA_TXIN_POLL_INTVAL);
+}
+
+static void ptm_aca_txin_poll(struct ptm_ep_priv *priv,
+			u32 dbase, u32 *idx, u32 dnum, u32 *pkt_num)
+{
+	rx_descriptor_t desc;
+	u32 off, cnt, dst, wrp_rd;
+
+	off = *idx;
+	cnt = 0;
+	wrp_rd = dnum * DW_SZ(desc);
+
+	tc_dbg(priv->tc_priv, MSG_SWITCH,
+		"dbase: 0x%x, idx: %u, pending num: %u, wrap_round: %u\n",
+		dbase, off, *pkt_num, wrp_rd);
+
+	while (1) {
+		dst = fpi_addr(dbase + off);
+		tc_mem_read(priv, &desc, dst, sizeof(desc));
+		if (desc.own == US_FP_DES_OWN) {
+			tc_dbg(priv->tc_priv, MSG_SWITCH,
+				"addr: 0x%x, desc ptr: 0x%x\n",
+				dbase + off, desc.data_ptr);
+			priv->tc_priv->tc_ops.free(desc.data_ptr, US_DIR);
+			desc.own = !desc.own;
+			tc_mem_write(priv, dst, &desc, sizeof(desc));
+			cnt++;
+			off = (off + 2) % wrp_rd;
+		} else
+			break;
+	}
+
+	if (cnt != 0) {
+		*idx = off;
+		priv->ep->hw_ops->aca_txin_ack_sub(priv->ep, cnt);
+		sb_w32(1, __TX_IN_ACA_ACCUM_STATUS);
+		*pkt_num -= cnt;
+	} else {
+		tc_err(priv->tc_priv, MSG_SWITCH,
+			"No ACA TXIN PENDING packets!!!\n");
+	}
+
+	tc_dbg(priv->tc_priv, MSG_SWITCH,
+		"ACA TXIN POLL free %d packets\n", cnt);
+}
+
+static int clear_aca_txin(struct ptm_ep_priv *priv,
+			u32 dbase, u32 *idx, u32 dnum, u32 pkt_num)
+{
+	if (!sb_r32(__RX_IN_ACA_ACCUM_STATUS)) {
+		tc_err(priv->tc_priv, MSG_SWITCH,
+			"ACA RXIN not clean\n");
+		return -EBUSY;
+	}
+
+	while (pkt_num > 0) {
+		tc_dbg(priv->tc_priv, MSG_SWITCH,
+			"pending pkt num: %d\n", pkt_num);
+		aca_txin_wait(priv);
+		ptm_aca_txin_poll(priv, dbase, idx, dnum, &pkt_num);
+	}
+	return 0;
+}
+
+/**
+ * Polling all pendinng packets in CBM/ACAs
+ */
+static void ptm_aca_exit(struct ptm_ep_priv *priv, u32 pkt_num)
+{
+	struct dc_ep_dev *ep;
+	u32 stop, idx;
+	desq_cfg_ctxt_t desq_cfg;
+
+	if (!is_ptm_sl(priv) && priv->ep_id == DS_BOND)
+		return;
+
+	stop = ACA_TXIN_EN | ACA_TXOUT_EN | ACA_RXIN_EN | ACA_RXOUT_EN;
+	ep = priv->ep;
+
+	tc_mem_read(priv, &desq_cfg,
+		fpi_addr(__US_FP_INQ_DES_CFG_CTXT), sizeof(desq_cfg));
+	idx = desq_cfg.deq_idx;
+
+	clear_aca_txin(priv, desq_cfg.des_base_addr,
+			&idx, desq_cfg.des_num, pkt_num);
+	if (ep->hw_ops->aca_stop(ep, &stop, 1) < 0)
+		tc_err(priv->tc_priv, MSG_SWITCH, "ACA is busy: %u!\n", stop);
+}
+
+static void ptm_umt_exit(struct ptm_ep_priv *priv)
+{
+	struct tc_priv *tcpriv;
+
+	tcpriv = priv->tc_priv;
+	tcpriv->tc_ops.umt_exit(ptm_id(priv));
+}
+
+static void ptm_cdma_exit(struct ptm_ep_priv *priv, enum dsl_tc_mode mode)
+{
+	cdma_ch_off(priv, US_DMA_PRE_RXCH, US_DMA_PRE_TXCH);
+	cdma_ch_off(priv, US_DMA_NOPRE_RXCH, US_DMA_NOPRE_TXCH);
+	cdma_ch_off(priv, DS_DMA_RXCH, DS_DMA_TXCH);
+}
+
+static void ptm_free_mem(struct ptm_ep_priv *priv, enum dsl_tc_mode mode)
+{
+	int i;
+	u32 phy_addr, phy_src;
+	ds_bond_gif_ll_des_t ll_desc;
+
+	/* Free QoS buffers */
+	for (i = 0; i < QOS_DES_NUM; i++) {
+		phy_addr = sb_r32(__US_QOSQ_DES_LIST_BASE + (i << 1));
+		priv->tc_priv->tc_ops.free(phy_addr, US_DIR);
+	}
+
+	/* Free OUTQ queue buffers */
+	for (i = 0; i < OUTQ_DESC_NUM; i++) {
+		phy_addr = sb_r32(__US_OUTQ_DES_LIST_BASE + (i << 1));
+		priv->tc_priv->tc_ops.free(phy_addr, US_DIR);
+	}
+
+	/* Free DS PKT queue buffers */
+	for (i = 0; i < __DS_PKT_DES_LIST_NUM; i++) {
+		phy_addr = sb_r32(__DS_PKT_DES_LIST_BASE + (i << 1));
+		priv->tc_priv->tc_ops.free(phy_addr, DS_DIR);
+	}
+
+	/* Free DS FRAGQ dest buffers */
+	if (mode == TC_PTM_BND_MODE) {
+		if (priv->ep_id == US_BOND)
+			phy_src = __DS_FRAGQ_DES_LIST_BASE;
+		else
+			phy_src = __DS_FRAGQ_DES_LIST_BASE
+				+ (__DS_FRAGQ_DES_LIST_PERQ_NUM *
+					(DESC_DWSZ + BOND_DESC_SZ));
+		for (i = 0; i < __DS_FRAGQ_DES_LIST_PERQ_NUM; i++) {
+			phy_addr = sb_r32(phy_src + (i << 1));
+			priv->tc_priv->tc_ops.free(phy_addr, DS_DIR);
+		}
+
+		if (priv->ep_id == DS_BOND)
+			for (i = 0; i < BOND_LL_DES_NUM; i++) {
+				phy_src = fpi_addr(__DS_BOND_GIF_LL_DES_BA +
+						i * DW_SZ(ll_desc));
+				tc_mem_read(priv, &ll_desc,
+					phy_src, sizeof(ll_desc));
+				priv->tc_priv->tc_ops.free(ll_desc.data_ptr,
+							DS_DIR);
+			}
+	}
+
+	return;
+}
+
+/**
+ * 1. CDMA channel off
+ * 2. Clear and disable interrupt
+ * 3. Free pre-allocated SoC memory
+ * 4. Indicate DSL FW/PPE FW unload
+ */
+static void ptm_ppe_exit(struct ptm_ep_priv *priv, enum dsl_tc_mode mode)
+{
+	int i;
+	struct ptm_priv *ptm_tc;
+
+	ptm_tc = g_ptm_priv;
+
+	/* Disable Idle cell for RX */
+	rtha_idle_keep_disable(priv);
+
+	/* Indicate PPE FW TC switch */
+	sb_w32(1, __MODE_SW_CFG);
+
+	/* Test only, without CBM flush, using PPE FW flush */
+        priv->ep->hw_ops->aca_start(priv->ep, ACA_TXIN_EN, 0);
+
+        /* Delay some time to allow PPE FW complete its task */
+        msleep(1);
+
+	/* Stop PPE FW */
+	ppe_stop(priv);
+
+	/* STOP DMA */
+	ptm_cdma_exit(priv, mode);
+
+	/* Disable and Clear all Interrupts */
+	for (i = MBOX_IGU0; i < MBOX_IGU2; i++) {
+		mbox_set_ier(priv, i, 0);
+		mbox_clr_isr(priv, i, MBOX_MASK(i));
+	}
+
+	/* unregister irq handler */
+	ptm_datapath_exit(priv);
+
+	/* free ptm pre-allocated memory */
+	ptm_free_mem(priv, mode);
+
+	/* Indicate DSL FW TC Clear */
+	tc_stat_indicate(priv, mode, 0);
+
+	return;
+}
+
+/**
+ * Unload Sequence
+ * 1. Stop US traffic by drop incoming traffic in CBM.
+ * 2. Stop PPE
+ * 3. SoC DMA exit, UMT exit
+ * 4. Power down PPE component including CDMA
+ * 5. Remove proc
+ * 6  unregister sub interface
+ * 7. Reset soc port to start from base address
+ * 8. send netlink message to Userspace
+ */
+void ptm_tc_unload(enum dsl_tc_mode tc_mode)
+{
+	struct ptm_priv *ptm_tc = g_ptm_priv;
+	struct ptm_ep_priv *priv;
+	int i;
+	u32 pending_num;
+
+	/* Disable US traffic */
+	ptm_tc->tc_priv->tc_ops.disable_us(1);
+
+	for (i = 0; i < ptm_tc->tc_priv->ep_num; i++) {
+		if (tc_mode == TC_PTM_SL_MODE && ptm_tc->ep_id != i)
+			continue;
+
+		priv = tc_ep_priv(i);
+		tc_dbg(priv->tc_priv, MSG_SWITCH,
+				"Unload on id: %d\n", priv->ep_id);
+
+		/* stop PPE */
+		ptm_ppe_exit(priv, tc_mode);
+		/* Get pending ACA TXIN PKT num */
+		/* pending_num = priv->ep->hw_ops->aca_txin_hd_cnt(priv->ep); */
+		/* Enable ACA TXIN */
+		/* priv->ep->hw_ops->aca_start(priv->ep, ACA_TXIN_EN, 0); */
+		/* stop UMT */
+		ptm_umt_exit(priv);
+		/* stop ACA */
+		ptm_aca_exit(priv, pending_num);
+		/* modem module power off */
+		tc_clkoff(priv->ep, PMU_PTM);
+		/* remove proc */
+		ptm_tc_proc_exit(priv);
+	}
+
+	/* unregister sub interface */
+	if (ptm_tc->tc_priv->tc_ops.dev_unreg != NULL)
+		ptm_tc->tc_priv->tc_ops.dev_unreg(ptm_tc->dev,
+			ptm_tc->dev->name, ptm_tc->subif_id, 0);
+
+	/* remove PTM callback function */
+	ptm_cb_setup(ptm_tc, 0);
+	/* message for TC DOWN */
+	tc_ntlk_msg_send(ptm_tc->tc_priv, 0, PTM_TC, TC_UNLOADED,
+		(tc_mode == TC_PTM_BND_MODE) ? BONDING_MODE : NON_BONDING_MODE,
+		ptm_tc->ep_id);
+
+	tc_info(ptm_tc->tc_priv, MSG_SWITCH, "Unload PTM TC successfully!!!\n");
+}
+
+void ptm_exit(void)
+{
+	struct ptm_priv *priv = g_ptm_priv;
+
+	if (!priv)
+		return;
+	unregister_netdev(priv->dev);
+	free_netdev(priv->dev);
+
+	g_ptm_priv = NULL;
+	memset(g_ep_priv, 0, sizeof(g_ep_priv));
+
+	pr_info("PTM TC exit!\n");
+}
+
+/**
+ * PROC functions
+ */
+static void print_ptm_drv_mib(struct seq_file *seq,
+	struct intel_tc_ptm_sl_stats *stat)
+{
+	seq_puts(seq, "Driver MIB:\n");
+
+	seq_printf(seq, "RX PKTs:\t %lu\n", (unsigned long)stat->rx_pkts);
+	seq_printf(seq, "RX Bytes:\t %lu\n", (unsigned long)stat->rx_bytes);
+	seq_printf(seq, "RX Errs:\t %lu\n", (unsigned long)stat->rx_errs);
+	seq_printf(seq, "RX Drops:\t %lu\n\n", (unsigned long)stat->rx_drops);
+	seq_printf(seq, "TX PKTs:\t %lu\n", (unsigned long)stat->tx_pkts);
+	seq_printf(seq, "TX Bytes:\t %lu\n", (unsigned long)stat->tx_bytes);
+	seq_printf(seq, "TX Errs:\t %lu\n", (unsigned long)stat->tx_errs);
+	seq_printf(seq, "TX Drops:\t %lu\n", (unsigned long)stat->tx_drops);
+}
+
+int proc_read_ptm_wanmib(struct seq_file *seq, void *v)
+{
+	struct ptm_ep_priv *priv;
+	struct ptm_priv *ptm_tc;
+	struct intel_tc_stats ptm_tc_stats;
+	struct intel_tc_ptm_sl_stats *ptm_sl_stats;
+	int ret;
+	__u32 default_mib;
+	priv = (struct ptm_ep_priv *)seq->private;
+	ptm_tc = priv->ptm_tc;
+	ret = ptm_tc_get_stats(ptm_tc, &ptm_tc_stats, 0);
+	ptm_sl_stats = &(ptm_tc_stats.stats.ptm_tc_stats.ptm_sl_stats);
+	default_mib = 0;
+	seq_puts(seq, "FW MIB:\n");
+	seq_puts(seq, "RX (Bearer Channels[0-1]):\n");
+	seq_puts(seq, "   wrx_bc_overdrop:");
+	seq_printf(seq, "%10llu %10u\n", ptm_sl_stats->wrx_bc_overdrop,
+		default_mib);
+
+	seq_puts(seq, "   wrx_bc_user_cw: ");
+	seq_printf(seq, "%10llu %10u\n", ptm_sl_stats->wrx_bc_user_cw,
+		default_mib);
+
+	seq_puts(seq, "   wrx_bc_idle_cw: ");
+	seq_printf(seq, "%10llu %10u\n",
+		ptm_sl_stats->wrx_bc_idle_cw, default_mib);
+
+	seq_puts(seq, "RX (Gamma Interfaces[0-3]):\n");
+	seq_puts(seq, "  wrx_total_pdu:   ");
+	seq_printf(seq, "%10llu %10u %10u %10u\n",
+		ptm_sl_stats->wrx_gif_total_pdu,
+		default_mib, default_mib, default_mib);
+
+	seq_puts(seq, "  wrx_dropdes_pdu: ");
+	seq_printf(seq, "%10llu %10u %10u %10u\n",
+		ptm_sl_stats->wrx_gif_drop_pdu,
+		default_mib, default_mib, default_mib);
+
+	seq_puts(seq, "  wrx_crc_err_pdu: ");
+	seq_printf(seq, "%10llu %10u %10u %10u\n",
+		ptm_sl_stats->wrx_gif_crc_err_pdu,
+		default_mib, default_mib, default_mib);
+
+	seq_puts(seq, "  wrx_violated_cw: ");
+	seq_printf(seq, "%10llu %10u %10u %10u\n",
+		ptm_sl_stats->wrx_gif_violated_cw,
+		default_mib, default_mib, default_mib);
+
+	seq_puts(seq, "  wrx_total_bytes: ");
+	seq_printf(seq, "%10llu %10u %10u %10u\n",
+		ptm_sl_stats->wrx_gif_total_bytes,
+		default_mib, default_mib, default_mib);
+
+	seq_puts(seq, "TX (Bearer Channels[0-1]):\n");
+	seq_printf(seq, "  total_tx_cw:     %10llu %10u\n",
+		ptm_sl_stats->wtx_bc_cw, default_mib);
+
+	seq_puts(seq, "TX (Gamma Interfaces[0-3]):\n");
+	seq_puts(seq, "  tx_total_pdu:    ");
+	seq_printf(seq, "%10llu %10u %10u %10u\n",
+		ptm_sl_stats->wtx_gif_total_pdu,
+		default_mib, default_mib, default_mib);
+
+	seq_puts(seq, "  tx_total_bytes:  ");
+	seq_printf(seq, "%10llu %10u %10u %10u\n",
+		ptm_sl_stats->wtx_gif_total_bytes,
+		default_mib, default_mib, default_mib);
+	print_ptm_drv_mib(seq, ptm_sl_stats);
+
+	return 0;
+}
+
+ssize_t proc_write_ptm_wanmib(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+	char str[32];
+	int len, rlen;
+	int num;
+	int i;
+	u32 size, off;
+	char *param_list[20];
+	struct ptm_ep_priv *priv;
+
+	unsigned int wrx_total_pdu[4] = {
+		DREG_AR_AIIDLE_CNT0, DREG_AR_HEC_CNT0,
+		DREG_AR_AIIDLE_CNT1, DREG_AR_HEC_CNT1};
+	unsigned int wrx_crc_err_pdu[4] = {
+		GIF0_RX_CRC_ERR_CNT, GIF1_RX_CRC_ERR_CNT,
+		GIF2_RX_CRC_ERR_CNT, GIF3_RX_CRC_ERR_CNT};
+	unsigned int wrx_cv_cw_cnt[4] = {
+		GIF0_RX_CV_CNT, GIF1_RX_CV_CNT,
+		GIF2_RX_CV_CNT, GIF3_RX_CV_CNT};
+	unsigned int wrx_bc_overdrop_cnt[2] = {
+		B0_OVERDROP_CNT, B1_OVERDROP_CNT};
+
+	priv = (struct ptm_ep_priv *)PDE_DATA(file_inode(file));
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+
+	num = vrx_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+	if ((vrx_strcmpi(param_list[0], "clear") == 0)
+		|| (vrx_strcmpi(param_list[0], "clean") == 0)
+		|| (vrx_strcmpi(param_list[0], "c") == 0)) {
+		for (i = 0; i < 4; i++) {
+			priv->ptm_mib.rx_total_pdu[i]
+				= tc_r32(wrx_total_pdu[i]);
+			priv->ptm_mib.rx_crc_err_pdu[i]
+				= tc_r32(wrx_crc_err_pdu[i]);
+			priv->ptm_mib.rx_cv_cw_cnt[i]
+				= tc_r32(wrx_cv_cw_cnt[i]);
+			off = i * DW_SZ(desq_cfg_ctxt_t) +
+				offsetof(desq_cfg_ctxt_t, deq_pkt_cnt) / 4;
+			priv->ptm_mib.tx_total_pdu[i]
+				= sb_r32(__US_TC_LOCAL_Q_CFG_CTXT_BASE + off);
+			priv->ptm_mib.tx_total_bytes[i]
+				= sb_r32(__US_TC_LOCAL_Q_CFG_CTXT_BASE
+					+ off + 1);
+
+			if (i < 2) {
+				priv->ptm_mib.rx_bc_overdrop_cnt[i]
+					= tc_r32(wrx_bc_overdrop_cnt[i]);
+				sb_w32(0, __RECEIVE_NON_IDLE_CELL_CNT_0 + i);
+				sb_w32(0, __RECEIVE_IDLE_CELL_CNT_0 + i);
+				sb_w32(0, __TRANSMIT_CELL_CNT_0 + i);
+			}
+			size = sizeof(struct wan_rx_mib_table);
+			off = i * DW_SZ(struct wan_rx_mib_table);
+			tc_memset(priv,
+				fpi_addr(__RX_GIF_MIB_BASE + off), 0, size);
+		}
+
+		size = sizeof(qosq_mib_t);
+		off = i * DW_SZ(qosq_mib_t);
+		for (i = 0; i < QOSQ_NUM; i++) {
+			tc_memset(priv,
+				fpi_addr(__QOSQ_MIB_BASE + off), 0, size);
+		}
+
+		memset(&g_ptm_priv->stats64, 0, sizeof(g_ptm_priv->stats64));
+	} else
+		pr_info("echo clear/clean/c > wanmib\n");
+
+	return count;
+}
+
+/**
+ *  ps_en:  1 - Enable powersaving, 0 -Disable Powersaving
+ *  flag:   0 - Get the powersaving cfg, 1 - Set the powersaving
+ */
+int ptm_power_saving(struct ptm_ep_priv *priv, int ps_en, int flag)
+{
+	struct psave_cfg ps_cfg;
+	int i;
+
+	memset(&ps_cfg, 0, sizeof(ps_cfg));
+
+	if (!flag) {
+		tc_mem_read(priv, &ps_cfg,
+			fpi_addr(PSAVE_CFG(0)), sizeof(ps_cfg));
+		return ps_cfg.sleep_en;
+	} else {
+		for (i = PP32_TX; i < PP32_MAX; i++) {
+			tc_mem_read(priv, &ps_cfg,
+				fpi_addr(PSAVE_CFG(i)), sizeof(ps_cfg));
+			ps_cfg.sleep_en = !!(ps_en);
+			tc_mem_write(priv, fpi_addr(PSAVE_CFG(i)),
+				&ps_cfg, sizeof(ps_cfg));
+		}
+		priv->tc_priv->param.ps = ps_en;
+	}
+
+	return 0;
+}
+
+int proc_ptm_read_bond(struct seq_file *seq, void *v)
+{
+	struct ptm_ep_priv *priv = (struct ptm_ep_priv *)seq->private;
+	bond_conf_t bconf;
+	us_bg_qmap_t us_qmap;
+	us_bg_gmap_t us_gmap;
+	ds_bg_gmap_t ds_gmap;
+
+	tc_mem_read(priv, &bconf, fpi_addr(__BOND_CONF), sizeof(bconf));
+	seq_puts(seq, "Bonding Configuration:\n");
+	seq_printf(seq, "  BOND_CONF[0x%x]:\n", __BOND_CONF);
+	seq_printf(seq, "\t max_frag_size=%u, dplus_fp_fcs_en=%u\n",
+		bconf.max_frag_size, bconf.dplus_fp_fcs_en);
+	seq_printf(seq, "\t bg_num=%u, bond_mode=%u (%s)\n",
+		bconf.bg_num, bconf.bond_mode,
+		bconf.bond_mode ? "L2 Trunking" : "L1 Bonding");
+	seq_printf(seq, "\t e1_bond_en=%u, d5_acc_dis=%u, d5_b1_en=%u\n",
+		bconf.e1_bond_en, bconf.d5_acc_dis, bconf.d5_b1_en);
+
+	tc_mem_read(priv, &us_qmap, fpi_addr(__US_BG_QMAP), sizeof(us_qmap));
+	seq_printf(seq, "  US_BG_QMAP[0x%x]:\n", __US_BG_QMAP);
+	seq_printf(seq, "\t qmap0=0x%02x, qmap1=0x%02x, qmap2=0x%02x, qmap3=0x%02x\n",
+		us_qmap.queue_map0, us_qmap.queue_map1,
+		us_qmap.queue_map2, us_qmap.queue_map3);
+
+	tc_mem_read(priv, &us_gmap, fpi_addr(__US_BG_GMAP), sizeof(us_gmap));
+	seq_printf(seq, "  US_BG_GMAP[0x%x]:\n", __US_BG_GMAP);
+	seq_printf(seq, "\t gmap0=0x%02x, gmap1=0x%02x, gmap2=0x%02x, gmap3=0x%02x\n",
+		us_gmap.gif_map0, us_gmap.gif_map1,
+		us_gmap.gif_map2, us_gmap.gif_map3);
+
+	tc_mem_read(priv, &ds_gmap, fpi_addr(__DS_BG_GMAP), sizeof(ds_gmap));
+	seq_printf(seq, "  DS_BG_GMAP[0x%x]:\n", __DS_BG_GMAP);
+	seq_printf(seq, "\t gmap0=0x%02x, gmap1=0x%02x, gmap2=0x%02x, gmap3=0x%02x\n",
+		ds_gmap.gif_map0, ds_gmap.gif_map1,
+		ds_gmap.gif_map2, ds_gmap.gif_map3);
+
+	seq_puts(seq, "Cross Pci Debug Info:    Read \t\t Write\n");
+	seq_printf(seq, "    Min clock cycles:  0x%08x, \t 0x%08x\n",
+		sb_r32(__READ_MIN_CYCLES), sb_r32(__WRITE_MIN_CYCLES));
+	seq_printf(seq, "    Max clock cycles:  0x%08x, \t 0x%08x\n",
+		sb_r32(__READ_MAX_CYCLES), sb_r32(__WRITE_MAX_CYCLES));
+	seq_printf(seq, "    Total access num:  0x%08x, \t 0x%08x\n",
+		sb_r32(__READ_NUM), sb_r32(__WRITE_NUM));
+	seq_printf(seq, "    Total cycle Lo:    0x%08x, \t 0x%08x\n",
+		sb_r32(__TOTAL_READ_CYCLES_LO),
+		sb_r32(__TOTAL_WRITE_CYCLES_LO));
+	seq_printf(seq, "    Total cycle Hi:    0x%08x, \t 0x%08x\n",
+		sb_r32(__TOTAL_READ_CYCLES_HI),
+		sb_r32(__TOTAL_WRITE_CYCLES_HI));
+
+	return 0;
+}
+int proc_ptm_read_bondmib(struct seq_file *seq, void *v)
+{
+	int i, ret;
+	struct ptm_ep_priv *priv = (struct ptm_ep_priv *)seq->private;
+	struct ptm_priv *ptm_tc;
+	struct intel_tc_stats ptm_tc_stats;
+	struct intel_tc_ptm_bonding_stats *stats;
+	ptm_tc = priv->ptm_tc;
+	ret = ptm_tc_get_stats(ptm_tc, &ptm_tc_stats, 1);
+	stats = &(ptm_tc_stats.stats.ptm_tc_stats.pmt_bonding_stats);
+
+
+	seq_puts(seq, "US_BONDING_GIF_MIB:\n");
+	for (i = 0; i < BOND_GIF_NUM; i++)
+		seq_printf(seq, "    GIF[%d]:  0x%08x\n",
+			i, stats->us_gif_mib[i]);
+
+	for (i = 0; i < BOND_GIF_NUM; i++) {
+		seq_printf(seq, "DS_BONDING_GIF_MIB[%d]:\n", i);
+		seq_printf(seq, "\t\t Total RX FRAG CNT: 0x%08x, Total RX BYTE CNT: 0x%08x\n",
+			stats->ds_gif_mib[i].rx_frag_byte_cnt,
+			stats->ds_gif_mib[i].rx_byte_cnt);
+		seq_printf(seq, "\t\t Overflow FRAG CNT: 0x%08x, Overflow BYTE CNT: 0x%08x\n",
+			stats->ds_gif_mib[i].rx_of_frag_byte_cnt,
+			stats->ds_gif_mib[i].rx_of_byte_cnt);
+		seq_printf(seq, "\t\t OOR FRAG CNT: 0x%08x, Missing FRAG CNT: 0x%08x, TO FRAG CNT:0x%08x\n",
+			stats->ds_gif_mib[i].rx_oor_frag_byte_cnt,
+			stats->ds_gif_mib[i].rx_miss_frag_byte_cnt,
+			stats->ds_gif_mib[i].rx_to_frag_byte_cnt);
+	}
+
+	for (i = 0; i < DS_BG_NUM; i++) {
+		seq_printf(seq, "DS_BG_MIB[%d]:\n", i);
+		seq_printf(seq, "    Confirm PKT CNT: 0x%08x, Confirm FRAG CNT: 0x%08x, Confirm Byte CNT: 0x%08x\n",
+			stats->ds_bg_mib[i].conform_pkt_cnt,
+			stats->ds_bg_mib[i].conform_frag_cnt,
+			stats->ds_bg_mib[i].conform_byte_cnt);
+		seq_printf(seq, "    NO SOP PKT CNT: 0x%08x, NO SOP FRAG CNT: 0x%08x, NO SOP Byte CNT: 0x%08x\n",
+			stats->ds_bg_mib[i].no_sop_pkt_cnt,
+			stats->ds_bg_mib[i].no_sop_frag_cnt,
+			stats->ds_bg_mib[i].no_sop_byte_cnt);
+		seq_printf(seq, "    NO EOP PKT CNT: 0x%08x, NO EOP FRAG CNT: 0x%08x, NO EOP Byte CNT: 0x%08x\n",
+			stats->ds_bg_mib[i].no_eop_pkt_cnt,
+			stats->ds_bg_mib[i].no_eop_frag_cnt,
+			stats->ds_bg_mib[i].no_eop_byte_cnt);
+		seq_printf(seq, "    Oversize PKT CNT: 0x%08x, Oversize FRAG CNT: 0x%08x, Oversize Byte CNT: 0x%08x\n",
+			stats->ds_bg_mib[i].oversize_pkt_cnt,
+			stats->ds_bg_mib[i].oversize_frag_cnt,
+			stats->ds_bg_mib[i].oversize_byte_cnt);
+		seq_printf(seq, "    Noncosec PKT CNT: 0x%08x, Noncosec FRAG CNT: 0x%08x, Noncosec Byte CNT: 0x%08x\n",
+			stats->ds_bg_mib[i].noncosec_pkt_cnt,
+			stats->ds_bg_mib[i].noncosec_frag_cnt,
+			stats->ds_bg_mib[i].noncosec_byte_cnt);
+	}
+
+	return ret;
+}
+
+ssize_t proc_ptm_write_bondmib(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+	struct ptm_ep_priv *priv;
+	char local_buf[128];
+	int len;
+	int num;
+	int i;
+	char *param_list[8];
+
+	len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+	len = len - copy_from_user(local_buf, buf, len);
+	local_buf[len] = 0;
+
+	num = vrx_split_buffer(local_buf, param_list, ARRAY_SIZE(param_list));
+	priv = (struct ptm_ep_priv *)PDE_DATA(file_inode(file));
+	if (priv == NULL) {
+		pr_err("%s: Invalid private data\n", __func__);
+		return -EINVAL;
+	}
+
+	if (vrx_strcmpi(param_list[0], "clear") == 0
+		|| vrx_strcmpi(param_list[0], "clean") == 0
+		|| vrx_strcmpi(param_list[0], "c") == 0) {
+		for (i = 0; i < BOND_GIF_NUM; i++) {
+			tc_memset(priv, US_BOND_GIF_MIB(i), 0, 4);
+			tc_memset(priv, DS_BOND_GIF_MIB(i), 0,
+					sizeof(ds_bond_gif_mib_t));
+		}
+
+		for (i = 0; i < DS_BG_NUM; i++)
+			tc_memset(priv, DS_BG_MIB(i), 0, sizeof(ds_bg_mib_t));
+	} else
+		pr_info("echo clear/clean/c > bondmib\n");
+
+	return count;
+}
+
+void ptm_set_q_preempt(struct ptm_ep_priv *priv, u32 qid, u32 preempt)
+{
+	u32 val;
+
+	if (!is_ptm_sl(priv) && !is_us_bond(priv)) {
+		pr_err("set queue preemption only supported in PTM Single line mode or Bonding US Master!\n");
+		return;
+	}
+
+	val = sb_r32(_QID2PREEMP_MAP);
+	if (preempt)
+		val |= BIT(qid);
+	else
+		val &= ~(BIT(qid));
+
+	sb_w32(val, _QID2PREEMP_MAP);
+
+	return;
+}
+
+/**
+ * Q0 ---> preemption queue---->OUTQ 0
+ * Q1----> non preemption queue---->OUTQ 1
+ */
+u32 ptm_get_q_preempt(struct ptm_ep_priv *priv, u32 qid)
+{
+	u32 val;
+
+	val = sb_r32(_QID2PREEMP_MAP);
+
+	return !!(BIT(qid) & val);
+}
+
+
diff --git a/drivers/net/ethernet/intel/vrx518/tc/tc_api.c b/drivers/net/ethernet/intel/vrx518/tc/tc_api.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/tc_api.c
@@ -0,0 +1,1066 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#define DEBUG
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/atomic.h>
+#include <linux/uaccess.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/wait.h>
+#include <linux/seq_file.h>
+#include <linux/printk.h>
+#include <linux/etherdevice.h>
+#include <linux/firmware.h>
+#include <linux/crypto.h>
+#include <net/dc_ep.h>
+
+#include "inc/tc_main.h"
+#include "inc/reg_addr.h"
+#include "inc/dfe.h"
+#include "inc/tc_common.h"
+#include "inc/tc_api.h"
+#include "inc/fw/vrx518_ppe_fw.h"
+
+static const char ppe_fw_name[] = "ppe_fw.bin";
+#define VRX518_PPE_FW_ID		0xB
+#define MD5_LEN				16
+
+/* TC message genelink family */
+static struct genl_family tc_gnl_family = {
+	.id = GENL_ID_GENERATE,	/* To generate an id for the family*/
+	.hdrsize = 0,
+	.name = TC_FAMILY_NAME,	/*family name, used by userspace application*/
+	.version = 1,		/*version number  */
+	.maxattr = TC_A_MAX - 1,
+};
+
+/* TC message multicast group */
+static struct genl_multicast_group tc_ml_grp = {
+	.name = TC_MCAST_GRP_NAME,
+};
+
+/**
+ * API to copy DWORD data from SoC DDR to VRX518
+ * Input:
+ *	priv: ATM/PTM/Bonding priv structure
+ *	src: SoC DDR address
+ *	dst: VRX518 FPI address
+ *	len: byte len (should be mutiple of 4)
+ */
+void tc_mem_write(void *priv, u32 dst, const void *src, size_t len)
+{
+	int i;
+	const u32 *src_addr = src;
+
+	if (WARN_ON((len & 0x3) != 0))
+		return;
+
+	len = TO_DWSZ(len);
+	for (i = 0; i < len; i++)
+		tc_w32(src_addr[i], (dst + (i << 2)));
+}
+
+/**
+ *API to copy DWORD data from VRX518 to SoC DDR
+ *Input:
+ *	priv: ATM/PTM/Bonding priv structure
+ *	src:  VRX518 FPI address
+ *	dst:  SoC DDR address
+ *	len:  byte len  (should be mutiple of 4)
+ *
+ * This API assume src/dst is DWORD aligned address.
+ */
+void tc_mem_read(void *priv, void *dst, u32 src, size_t len)
+{
+	int i;
+	u32 *dst_addr = (u32 *)dst;
+
+	if (WARN_ON((len & 0x3) != 0))
+		return;
+
+	len = TO_DWSZ(len);
+	for (i = 0; i < len; i++)
+		dst_addr[i] = tc_r32(src + (i << 2));
+}
+
+
+/**
+ * API to set write given content to vrx518 address
+ * Input:
+ *	priv: ATM/PTM/Bonding priv structure
+ *	dst:  VRX518 FPI address
+ *	val:  data to write
+ *	len:  byte len  (should be mutiple of 4)
+ */
+
+void tc_memset(void *priv, u32 dst, int val, size_t len)
+{
+	int i;
+
+	if (WARN_ON((len & 0x3) != 0))
+		return;
+
+	len = TO_DWSZ(len);
+	for (i = 0; i < len; i++)
+		tc_w32(val, (dst + (i << 2)));
+}
+
+/**
+ * API to start pp32
+ * Input:
+ *	priv: ATM/PTM/Bonding priv structure
+ *	pp32: PP32 CPU ID: 0 - 2
+ */
+void pp32_start(void *priv, int pp32)
+{
+	u32 val;
+
+	if (WARN_ON(pp32 < 0 || pp32 >= PP32_MAX))
+		return;
+
+	val = tc_r32(PPE_FREEZE) & (~(FREEZE_PP32(pp32)));
+	tc_w32(val, PPE_FREEZE);
+
+	/*  idle for a while to let PP32 init itself */
+	udelay(50);
+
+	if (tc_r32(PPE_FREEZE) & FREEZE_PP32(pp32)) {
+		tc_err(to_tcpriv(priv), MSG_INIT,
+			"Restart PP32(%d) failed: 0x%x,\n",
+			pp32, tc_r32(PPE_FREEZE));
+		return;
+	}
+}
+
+/**
+ * API to convert SB address to request address
+ */
+u32 tc_addr(u32 sb_addr, u32 target_addr_type, u32 base)
+{
+	if (target_addr_type == TC_SRAM_ADDR)
+		return SB_XBAR_ADDR(sb_addr) | base;
+	else if (target_addr_type == TC_FPI_ADDR)
+		return fpi_addr(sb_addr) | base;
+	else
+		pr_err("Address type is not correct: %d\n", target_addr_type);
+
+	return 0;
+}
+
+/* API to stop(freeze) pp32 */
+void pp32_stop(void *priv, int pp32)
+{
+	u32 val;
+
+	if (WARN_ON(pp32 < 0 || pp32 >= PP32_MAX))
+		return;
+
+	val = tc_r32(PPE_FREEZE);
+	tc_w32(val | FREEZE_PP32(pp32), PPE_FREEZE);
+}
+
+
+/* API to clear all SB */
+void ppe_sb_clear(void *priv)
+{
+	tc_memset(priv, fpi_addr(SB_SEG0_BASE), 0, SB_SEG0_SIZE);
+	tc_memset(priv, fpi_addr(SB_SEG1_BASE), 0, SB_SEG1_SIZE);
+}
+
+/* API to clear PDBRAM */
+void pdbram_clear(void *priv)
+{
+	tc_memset(priv, PDBRAM_PPE_BASE, 0, PDBRAM_PPE_SIZE);
+}
+
+/* API to reset PP32 internal modules, zero to reset */
+void pp32_reset(void *priv, u32 reset_set)
+{
+	u32 pp32_rst;
+
+	pp32_rst = tc_r32(PP32_RST) & (~reset_set);
+	tc_w32(PP32_RST, pp32_rst);
+	udelay(100);
+
+	pp32_rst |= reset_set;
+	tc_w32(PP32_RST, pp32_rst);
+
+	pp32_rst = tc_r32(PP32_RST);
+	if ((pp32_rst & reset_set) != reset_set) {
+		tc_err(to_tcpriv(priv), MSG_INIT,
+			"reset PPE fail, reset set: 0x%x, after reset: 0x%x\n",
+			reset_set, pp32_rst);
+		return;
+	}
+}
+
+static void fw_cmp(void *priv, int pp32,
+	const u32 *fw_code, u32 fw_addr, size_t size)
+{
+	int i;
+
+	size = TO_DWSZ(size);
+	for (i = 0; i < size; i++) {
+		if (fw_code[i] != tc_r32(fw_addr + TO_BYSZ(i))) {
+			tc_err(to_tcpriv(priv), MSG_INIT,
+				"PP32(%d): fw mem data: 0x%x != original 0x%x @0x%x\n",
+				pp32, tc_r32(fw_addr + TO_BYSZ(i)),
+				fw_code[i], fw_addr + TO_BYSZ(i));
+			return;
+		}
+	}
+}
+
+/**
+ * API to download PPE FW code
+ * Input:
+ *	priv: ATM/PTM/Bonding priv structure
+ *	pp32:  PPM index (0 -2)
+ *	code_src: FW code array
+ *	code_len: FW code array length
+ */
+static int pp32_fw_download(void *priv, int pp32,
+		const u32 *fw_code, size_t size)
+{
+	u32 code_base;
+	size_t code_ram_sz = 0;
+
+	if (size <= 0)
+		return 0;
+
+	switch (pp32) {
+	case 0:
+		code_ram_sz = CDM_SZ(0) + CDM_SZ(1);
+		break;
+
+	case 1:
+		code_ram_sz = CDM_SZ(2) + CDM_SZ(3);
+		break;
+
+	case 2:
+		code_ram_sz = CDM_SZ(4) + CDM_SZ(5);
+		break;
+
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	if (code_ram_sz < size) {
+		tc_err(to_tcpriv(priv), MSG_INIT,
+			"Download Fail!, ram size: 0x%x less than code size: 0x%x\n",
+			code_ram_sz, size);
+		WARN_ON(1);
+		return -ENOMEM;
+	}
+
+	code_base = PPM_CODE_MEM_BASE(pp32);
+
+	/* Clear code and data mem */
+	tc_memset(priv, code_base, 0, code_ram_sz);
+
+	/* Download FW code and data */
+	tc_mem_write(priv, code_base, fw_code, size);
+
+	tc_r32(code_base);
+	fw_cmp(priv, pp32, fw_code, code_base, size);
+
+	return 0;
+}
+
+void pp32_load(void *priv, struct ppe_fw *fw, int is_atm)
+{
+	int i;
+	struct tc_priv *tcpriv = to_tcpriv(priv);
+
+	if (is_atm) {
+		tc_info(tcpriv, MSG_SWITCH,
+			"Loading ATM FW ver: %d.%d.%d\n",
+			fw->atm_ver.major, fw->atm_ver.mid, fw->atm_ver.minor);
+		for (i = 0; i < PP32_MAX; i++) {
+			if (TO_BYSZ(fw->atm_fw.size[i])) {
+				tc_dbg(tcpriv, MSG_INIT,
+				"%s: ATM load data [%p][%d]\n", __func__,
+					fw->atm_fw.data[i],
+					fw->atm_fw.size[i]);
+				pp32_fw_download(priv, i, fw->atm_fw.data[i],
+						TO_BYSZ(fw->atm_fw.size[i]));
+			} else
+				tc_dbg(tcpriv, MSG_INIT,
+					"%s: invalid data\n", __func__);
+		}
+	} else {
+		tc_info(tcpriv, MSG_SWITCH,
+			"Loading PTM FW ver: %d.%d.%d\n",
+			fw->ptm_ver.major, fw->ptm_ver.mid, fw->ptm_ver.minor);
+		for (i = 0; i < PP32_MAX; i++)
+			pp32_fw_download(priv, i, fw->ptm_fw.data[i],
+				TO_BYSZ(fw->ptm_fw.size[i]));
+	}
+}
+
+static void cdma_ctrl_init(void *priv)
+{
+	u32 val;
+	struct dc_ep_dev *ep_dev = to_epdev(priv);
+	struct tc_priv *tcpriv = to_tcpriv(priv);
+
+	/* power up CDMA */
+	ep_dev->hw_ops->clk_on(ep_dev, PMU_CDMA);
+
+	/* Global software reset CDMA */
+	rw32_mask(priv, 1, 1, CTRL_RST_S, CDMA_CTRL);
+	while (tc_r32(CDMA_CTRL) & BIT(CTRL_RST_S))
+		;
+
+	val = tc_r32(CDMA_ID);
+	tcpriv->dma.chans = MS(val, ID_CHNR);
+
+	val = tc_r32(CDMA_CTRL);
+
+	/**
+	* Enable:
+	* Packet Arbitration, Meta data copy, Dyanamic Data burst read
+	* Byte Enable, Dedicated Descriptor Access port
+	*/
+	set_mask_bit(val, 1, 1, CTRL_PKTARB_S);
+	set_mask_bit(val, 1, 1, CTRL_MDC_S);
+	set_mask_bit(val, 1, 1, CTRL_DSRAM_S);
+	set_mask_bit(val, 1, 1, CTRL_ENBE_S);
+	set_mask_bit(val, 1, 1, CTRL_DCNF_S);  /* 2DW descriptor format */
+	set_mask_bit(val, 1, 1, CTRL_DDBR_S);
+	tc_w32(val, CDMA_CTRL);
+
+	/* Enable DMA polling */
+	val = tc_r32(CDMA_CPOLL);
+	val = SM(1, POLL_EN) | SM(POLL_DEF_CNT, POLL_CNT);
+	tc_w32(val, CDMA_CPOLL);
+}
+
+static void cdma_port_init(void *priv)
+{
+	u32 val;
+
+	/* Only one port /port 0 */
+	tc_w32(0, CDMA_PS);
+	val = tc_r32(CDMA_PCTRL);
+
+	/* Set burst size to 16DWs */
+	set_mask_bit(val, 1, 1, PCTRL_RXBL16_S);
+	set_mask_bit(val, 1, 1, PCTRL_TXBL16_S);
+	set_mask_bit(val, 0, 3, PCTRL_RXBL_S);
+	set_mask_bit(val, 0, 3, PCTRL_TXBL_S);
+
+	/* Set DMA tx/rx endian */
+	set_mask_bit(val, NO_SWAP, 3, PCTRL_TXENDI_S);
+	set_mask_bit(val, BYTE_SWAP, 3, PCTRL_RXENDI_S);
+	tc_w32(val, CDMA_PCTRL);
+}
+
+void tc_cdma_init(void *priv)
+{
+	cdma_ctrl_init(priv);
+	cdma_port_init(priv);
+}
+
+static void cdma_ch_set(void *priv, int cid, u32 dbase, u32 dnum)
+{
+	/* Channel select */
+	tc_w32(cid, CDMA_CS);
+
+	/* Channel Reset */
+	rw32_mask(priv, 1, 1, CCTRL_RST_S, CDMA_CCTRL);
+	while (tc_r32(CDMA_CCTRL) & BIT(CCTRL_RST_S))
+		;
+
+	tc_w32(dbase, CDMA_CDBA);
+	tc_w32(dnum, CDMA_CDLEN);
+
+	/* Clear All interrupts */
+	tc_w32(CDMA_CI_ALL, CDMA_CIS);
+	/* Disable all interrupts */
+	tc_w32(0, CDMA_CIE);
+}
+
+void cdma_ch_cfg(void *priv, int rxid, int txid, u32 rx_base,
+	u32 rx_num, u32 tx_base, u32 tx_num)
+{
+	struct tc_priv *tc_priv;
+
+	tc_priv = to_tcpriv(priv);
+
+	WARN_ON(rxid >= tc_priv->dma.chans);
+	WARN_ON(txid >= tc_priv->dma.chans);
+
+	cdma_ch_set(priv, rxid, rx_base, rx_num);
+	cdma_ch_set(priv, txid, tx_base, tx_num);
+}
+
+static inline void cdma_ch_onoff(void *priv, int cid, enum cdma_onoff onoff)
+{
+	/* Channel select */
+	tc_w32(cid, CDMA_CS);
+
+	/* Channel on/off */
+	rw32_mask(priv, onoff, 1, CCTRL_ONOFF_S, CDMA_CCTRL);
+}
+
+void cdma_ch_on(void *priv, int rxid, int txid)
+{
+	struct tc_priv *tc_priv;
+
+	tc_priv = to_tcpriv(priv);
+	WARN_ON(rxid >= tc_priv->dma.chans);
+	WARN_ON(txid >= tc_priv->dma.chans);
+
+	cdma_ch_onoff(priv, rxid, DMA_CH_ON);
+	cdma_ch_onoff(priv, txid, DMA_CH_ON);
+}
+
+void cdma_ch_off(void *priv, int rxid, int txid)
+{
+	struct tc_priv *tc_priv;
+
+	tc_priv = to_tcpriv(priv);
+	WARN_ON(rxid >= tc_priv->dma.chans);
+	WARN_ON(txid >= tc_priv->dma.chans);
+
+	cdma_ch_onoff(priv, txid, DMA_CH_OFF);
+	cdma_ch_onoff(priv, rxid, DMA_CH_OFF);
+}
+
+static void halt_ttha(struct tc_comm *priv)
+{
+	int i;
+	u32 val;
+
+	/* Disable idle cell */
+	for (i = 0; i < 2; i++) {
+		val = tc_r32(FFSM_CFG(i)) & (~(BIT(17)));
+		tc_w32_flush(val, FFSM_CFG(i));
+	}
+
+	/* DSL FW should stop frame request, Reset DFE if in looback mode */
+	if (priv->tc_priv->param.dfe_loopback == 1)
+		priv->ep->hw_ops->reset_device(priv->ep, RST_DFE);
+
+	/* Halt TC DMA */
+	val = tc_r32(DREG_AT_CFG(0)) | BIT(30);
+	tc_w32_flush(val, DREG_AT_CFG(0));
+
+	/* Disable TTHA */
+	val = tc_r32(FFSM_CFG(0)) & (~(BIT(31)));
+	tc_w32_flush(val, FFSM_CFG(0));
+
+	/* Flush TC DMA */
+	val = tc_r32(DREG_AT_CFG(0)) | BIT(31) | BIT(30);
+	tc_w32_flush(val, DREG_AT_CFG(0));
+
+	/**
+	* After Flush TCDMA, HW page index will automatically reset to 0
+	* FW need reset its pointer(0x3EC5) to zero before trigger ttha flush
+	*/
+}
+
+void ttha_disable(void *priv, int reset)
+{
+	halt_ttha(priv);
+	/* Reset TC DMA */
+	if (reset)
+		pp32_reset(priv, TCDMA0_RST);
+}
+
+void ttha_enable(void *priv)
+{
+	u32 val;
+	int i;
+
+	/* Enable TTHA */
+	for (i = 0; i < 2; i++) {
+		val = tc_r32(FFSM_CFG(i)) | BIT(31);
+		tc_w32(val, FFSM_CFG(i));
+	}
+
+	/* Indicate DSL FW Frame request is OK */
+	tc_w32(1, DSL_FRAMER_REQ_START);
+}
+
+void rtha_idle_keep_disable(void *priv)
+{
+	u32 val;
+	int i;
+
+	/* Disable the Idle keep for RX */
+	for (i = 0; i < 2; i++) {
+		val = tc_r32(SFSM_CFG(i)) & (~(BIT(15)));
+		tc_w32(val, SFSM_CFG(i));
+	}
+}
+
+/**
+ * API defintion for the driver to send TC notify messages to user application
+ * using genetlink method.
+ * priv: ATM/PTM/BONDING priv structure
+ * pid: process id
+ * tc_mode: ATM_TC/PTM_TC
+ * tc_action: TC_LOADED/TC_UNLOADED
+ * bnd_mode: BONDING_MODE/NON_BONDING_MODE
+ * ln_no: line id
+ */
+int tc_ntlk_msg_send(struct tc_priv *priv, int pid, int tc_mode, int tc_action,
+			int bnd_mode, int ln_no)
+{
+	struct sk_buff *skb;
+	int ret;
+	void *msg_head;
+
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	/* create the message headers */
+	msg_head = genlmsg_put(skb, 0, 0, &tc_gnl_family, 0, TC_C_NOTIFY);
+	if (msg_head == NULL) {
+		ret = -ENOMEM;
+		tc_err(priv, MSG_EVENT, "Create TC message header fail!\n");
+		goto err1;
+	}
+
+	nla_put_u32(skb, TC_A_TC_MODE, tc_mode);
+	nla_put_u32(skb, TC_A_TC_ACTION, tc_action);
+	nla_put_u32(skb, TC_A_BOND, bnd_mode);
+	nla_put_u32(skb, TC_A_LINENO, ln_no);
+
+	genlmsg_end(skb, msg_head);
+	ret = genlmsg_multicast(skb, pid, tc_ml_grp.id, GFP_KERNEL);
+	if (ret) {
+		tc_err(priv, MSG_EVENT, "Sent TC multicast message Fail!\n");
+		goto err1;
+	}
+	return 0;
+err1:
+	return ret;
+}
+
+int tc_gentlk_init(struct tc_priv *priv)
+{
+	int ret;
+
+	/*register new family*/
+	ret = genl_register_family(&tc_gnl_family);
+	if (ret) {
+		tc_err(priv, MSG_EVENT, "Family registeration fail:%s\n",
+			tc_gnl_family.name);
+		return ret;
+	}
+
+	ret = genl_register_mc_group(&tc_gnl_family, &tc_ml_grp);
+	if (ret) {
+		tc_err(priv, MSG_EVENT, "register mc group fail: %i, grp name: %s\n",
+			ret, tc_ml_grp.name);
+		genl_unregister_family(&tc_gnl_family);
+		return ret;
+	}
+
+	return 0;
+}
+
+void tc_gentlk_exit(void)
+{
+	/* unregister mc groups */
+	genl_unregister_mc_group(&tc_gnl_family, &tc_ml_grp);
+	/*unregister the family*/
+	genl_unregister_family(&tc_gnl_family);
+}
+
+
+int showtime_stat(struct tc_priv *priv)
+{
+	int i;
+
+	if (priv->param.dfe_loopback)
+		return 1;
+
+	for (i = 0; i < priv->ep_num; i++) {
+		if (priv->showtime[i] == 1)
+			return 1;
+	}
+
+	return 0;
+}
+
+static void dump_skb_data(struct tc_priv *priv,
+		struct sk_buff *skb, size_t size, u32 msg_type)
+{
+	int i;
+
+	if (skb->len < size)
+		size = skb->len;
+	if (skb->data_len != 0 && skb->data_len < size)
+		size = skb->data_len;
+
+	if (!(priv->msg_enable & msg_type))
+		return;
+
+	printk("Data dump:");
+	for (i = 0; i < size; i++) {
+		if (i % 32 == 0)
+			printk("\n[%4d]: ", i);
+		else if (i % 16 == 0)
+			printk("   ");
+		printk("%02x ", skb->data[i]);
+	}
+	printk("\n");
+}
+
+void dump_skb_info(struct tc_priv *tcpriv, struct sk_buff *skb, u32 msg_type)
+{
+	u32 type;
+
+	type = msg_type & (MSG_TX | MSG_RX);
+	tc_dbg(tcpriv, type,
+		"skb: head: 0x%x, data: 0x%x, tail: 0x%x, end: 0x%x, len: %d\n",
+		(u32)skb->head, (u32)skb->data, (u32)skb->tail,
+		(u32)skb->end, skb->len);
+	tc_dbg(tcpriv, type,
+		"skb: clone: %d, users: %d\n",
+		skb->cloned, atomic_read(&skb->users));
+	tc_dbg(tcpriv, type,
+		"skb: nfrag: %d\n", skb_shinfo(skb)->nr_frags);
+
+	type = msg_type & (MSG_TXDATA | MSG_RXDATA);
+	dump_skb_data(tcpriv, skb, skb->len, type);
+}
+
+/* This function may sleep */
+void *tc_buf_alloc(void *priv, size_t size,
+		dma_addr_t *phy_addr, enum tc_dir dir, struct device *pdev)
+{
+	void *buf;
+	struct tc_priv *tcpriv;
+	dma_addr_t dma_addr;
+
+	tcpriv = to_tcpriv(priv);
+	buf = tcpriv->tc_ops.alloc(size, dir);
+
+	if (!buf) {
+		tc_err(tcpriv, MSG_INIT,
+			"TC Alloc buffer fail!, dir=%d\n", dir);
+		WARN_ONCE(1, "VRX518 allocate buffer fail!\n");
+		return NULL;
+	}
+
+	dma_addr = dma_map_single(pdev, buf, size, DMA_FROM_DEVICE);
+	if (unlikely(dma_mapping_error(pdev, dma_addr))) {
+		tc_err(tcpriv, MSG_INIT,
+			"DMA address mapping error: buf: 0x%x, size: %d, dir: %d\n",
+			(u32)buf, size, DMA_FROM_DEVICE);
+		WARN_ONCE(1, "DMA address mapping fail!\n");
+	}
+	dma_unmap_single(pdev, dma_addr, size, DMA_FROM_DEVICE);
+	*phy_addr = dma_addr;
+
+	return buf;
+}
+
+static u32 mei_rd(void *priv, u32 addr)
+{
+	tc_w32(addr, MEIAD(ME_DBG_RD_AD));
+	while (!(tc_r32(MEIAD(ME_ARC2ME_STAT)) & 0x10))
+		;
+	tc_w32_flush(0x10, MEIAD(ME_ARC2ME_STAT));
+
+	return tc_r32(MEIAD(ME_DBG_DATA));
+}
+
+static void mei_wr(void *priv, u32 addr, u32 val)
+{
+	tc_w32(addr, MEIAD(ME_DBG_WR_AD));
+	tc_w32(val, MEIAD(ME_DBG_DATA));
+	while (!(tc_r32(MEIAD(ME_ARC2ME_STAT)) & 0x10))
+		;
+	tc_w32(0x10, MEIAD(ME_ARC2ME_STAT));
+}
+
+static void setup_zephyr(void *priv)
+{
+
+	u32 i, data;
+	u32 addr;
+
+	for (i = 0; i < ARRAY_SIZE(dfe_cfg_seq); i++) {
+		addr = dfe_cfg_seq[i].addr + MEI_OFFSET;
+		switch (dfe_cfg_seq[i].type) {
+		case ME_DBG_RD:
+			data = tc_r32(addr);
+			break;
+		case ME_DBG_WR:
+			tc_w32(dfe_cfg_seq[i].data, addr);
+			break;
+		}
+	}
+
+	/* Read back to make sure Zephry started */
+	data = mei_rd(priv, 0x00020c40c);
+	tc_dbg(to_tcpriv(priv), MSG_LOOPBACK, "CRI_TSC_CTRL: 0x%08x\n", data);
+
+	data = mei_rd(priv, 0x00020c4dc);
+	tc_dbg(to_tcpriv(priv), MSG_LOOPBACK,
+		"CRI_RXFFT_STALL_CTRL: 0x%08x\n", data);
+
+	data = mei_rd(priv, 0x00020c4d8);
+	tc_dbg(to_tcpriv(priv), MSG_LOOPBACK,
+		"CRI_RXQT_STALL_CTRL: 0x%08x\n", data);
+
+	data = mei_rd(priv, 0x00020c4d0);
+	tc_dbg(to_tcpriv(priv), MSG_LOOPBACK, "CRI_RXPMS_CTRL: 0x%08x\n", data);
+
+	data = mei_rd(priv, 0x00020c4b4);
+	tc_dbg(to_tcpriv(priv), MSG_LOOPBACK, "CRI_TXPMS_CTRL: 0x%08x\n", data);
+
+	return;
+}
+
+static void dfe_reset(void *priv)
+{
+	struct dc_ep_dev *ep = to_epdev(priv);
+	ep->hw_ops->reset_device(ep, RST_DFE);
+}
+
+static void dfe_zephyr_lb_init(void *priv)
+{
+	dfe_reset(priv);
+	setup_zephyr(priv);
+}
+
+static void set_dfe_data_rate(void *priv, u32 nbc_switches, u32 nbc0bytes,
+				u32 nbc1bytes, u32 numtimeslots)
+{
+
+	/* Num of BC switches for Tx to load into register ZT_R0 */
+	mei_wr(priv, 0x000542F4, nbc_switches);
+
+	/* Num of BC switches for Rx to load into register ZR_R0 */
+	mei_wr(priv, 0x0005B94C, nbc_switches);
+
+	/* Num of BC0 and BC1 bytes for Tx to load into register ZT_VBC_SIZE */
+	mei_wr(priv, 0x00054308, (nbc1bytes << 16) + nbc0bytes);
+
+	/* Num of BC0 and BC1 bytes for Rx to load into register ZR_VBC_SIZE */
+	mei_wr(priv, 0x0005B960, (nbc1bytes << 16) + nbc0bytes);
+
+	/* Num of BC0 and BC1 error bytes for Tx to load into register ZT_R12 */
+	/* me_dbg_wr(0x00054300, (nBC1ErrBytes << 16) + nBC0ErrBytes); */
+	mei_wr(priv, 0x00054300, 0);
+
+	/* Num of BC0 and BC1 error bytes for Rx to load into REG ZR_R12 */
+	/* me_dbg_wr(0x0005B958, (nBC1ErrBytes << 16) + nBC0ErrBytes); */
+	mei_wr(priv, 0x0005B958, 0);
+
+	/* kick of by writing to CRI registers */
+	/* me_dbg_wr(0x0020c40c, 0x8007ffe1); */
+	mei_wr(priv, 0x0020c40c, 0x8007ffe0 | numtimeslots);
+	mei_wr(priv, 0x0020c49c, 0x00000078);
+
+	return;
+}
+
+
+void setup_dfe_loopback(void *priv, u32 rate)
+{
+	struct tc_priv *tcpriv = to_tcpriv(priv);
+	if (!tcpriv->param.dfe_loopback)
+		return;
+
+	tc_dbg(tcpriv, MSG_LOOPBACK, "enable DFE loopback\n");
+
+	/* Set DFE to Zephyr loopback mode */
+	/* 0 - ARC core disable ; 1 - ARC core enable */
+	dfe_zephyr_lb_init(priv);
+
+	/* Function to change DFE data rate
+	 * Bit_rate (MBps) = num_bc_switch *
+	 *	(bc0_payld + bc1_payld)  / ((num_time_slot + 1) * 28 us);
+	 * Bit_rate (Mbps) = 8 * num_bc_switch *
+	 *	(bc0_payld + bc1_payld)  / ((num_time_slot + 1) * 28 us);
+	 * set_dfe_data_rate(u8 pcie_port, UINT32 num_bc_switch,
+	 *	UINT32 bc0_payld, UINT32 bc1_payld, UINT32 num_time_slot)
+	 * rate default for vrx518: 1500
+	 */
+	if (!rate)
+		rate = 1500;
+
+	tc_dbg(tcpriv, MSG_LOOPBACK, "loopback rate: %d\n", rate);
+	set_dfe_data_rate(priv, 4, rate, 0, 1);
+}
+
+static inline int in_sync(void *priv)
+{
+	return  tc_r32(SFSM_STATE0) & 0x1;
+}
+
+void dfe_loopback_linkup(void *priv)
+{
+	u32 val;
+	int i = 0;
+	struct tc_priv *tcpriv = to_tcpriv(priv);
+
+	if (!tcpriv->param.dfe_loopback)
+		return;
+
+	tc_w32_flush(0x07, BC0_LINK_STATUS);
+
+	while (!in_sync(priv) && (i++) < 100)
+		;
+	tc_dbg(tcpriv, MSG_LOOPBACK, "BC0 is %s in sync\n",
+		in_sync(priv) ? "" : "NOT");
+
+	tc_info(tcpriv, MSG_EVENT, "disable idle keep only in emulation\n");
+	/* Don't keep idle for emulation, but must keep idle for real case. */
+	for (i = 0; i < 2; i++) {
+		val = tc_r32(SFSM_CFG(i)) & (~(BIT(15)));
+		tc_w32_flush(val, SFSM_CFG(i));
+		val = tc_r32(FFSM_CFG(i)) & (~(BIT(17)));
+		tc_w32_flush(val, FFSM_CFG(i));
+	}
+}
+
+static void fw_print_header_info(struct tc_priv *priv,
+			struct fw_bin *fw_bin)
+{
+	int i = 0;
+	struct fw_hdr *hdr;
+
+	hdr = &fw_bin->fw_hdr;
+	tc_dbg(priv, MSG_INIT, "VRX518 PPE Firmware header info\n");
+	tc_dbg(priv, MSG_INIT, "\tPTM Version: %d.%d.%d\n",
+		hdr->ptm_ver.major,
+		hdr->ptm_ver.mid,
+		hdr->ptm_ver.minor);
+	tc_dbg(priv, MSG_INIT, "\tPTM Feature: %08X\n", hdr->ptm_ver.features);
+	tc_dbg(priv, MSG_INIT, "\tATM Version: %d.%d.%d\n",
+		hdr->atm_ver.major,
+		hdr->atm_ver.mid,
+		hdr->atm_ver.minor);
+	tc_dbg(priv, MSG_INIT, "\tATM Feature: %08X\n", hdr->atm_ver.features);
+	tc_dbg(priv, MSG_INIT, "\tCompability ID: %08X\n", hdr->comp_id);
+	tc_dbg(priv, MSG_INIT, "\tSize: %08X\n", hdr->hdr_sz);
+	tc_dbg(priv, MSG_INIT, "\tFW built Date: %d-%d-%d\n",
+			((hdr->date >> 24) & 0xff),
+			((hdr->date >> 16) & 0xff),
+			((hdr->date) & 0xffff));
+	tc_dbg(priv, MSG_INIT, "\tNumber of firmware: %d\n", hdr->fw_num);
+	for (i = 0; i < hdr->fw_num; i++) {
+		tc_dbg(priv, MSG_INIT,
+			"\t\tFirmware[%d]: ID[%X] size[%d] at[0x%p]\n",
+			i,
+			hdr->fw_info[i].fw_id,
+			hdr->fw_info[i].fw_size,
+			fw_bin->fw_ptr[hdr->fw_info[i].fw_id]);
+	}
+}
+
+static int fw_md5_check(struct tc_priv *priv, const struct firmware *fw)
+{
+	struct scatterlist sg;
+	struct crypto_hash *tfm;
+	struct hash_desc desc;
+	u8 output[MD5_LEN];
+	const u8 *org_md5;
+	int i;
+	u32 data_len;
+
+	memset(output, 0, sizeof(output));
+
+	tfm = crypto_alloc_hash("md5", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(tfm)) {
+		tc_err(priv, MSG_INIT,
+			"Failed to allocate MD5 ALG HASH!\n");
+		return PTR_ERR(tfm);
+	}
+
+	desc.tfm = tfm;
+	desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;
+	data_len = fw->size - MD5_LEN;
+
+	sg_init_one(&sg, fw->data, data_len);
+	crypto_hash_init(&desc);
+	crypto_hash_update(&desc, &sg, data_len);
+	crypto_hash_final(&desc, output);
+
+	/* MD5 compare */
+	org_md5 = fw->data + data_len;
+
+	for (i = 0; i < MD5_LEN; i++) {
+		if (output[i] != org_md5[i]) {
+			tc_err(priv, MSG_INIT,
+				"MD5 check failed: @[%d], calculated MD5 val: 0x%02x, original MD5 val: 0x%02x\n",
+				i, output[i], org_md5[i]);
+			WARN_ON_ONCE(1);
+			return -EFAULT;
+		}
+	}
+
+	tc_dbg(priv, MSG_INIT, "MD5 checksum pass!!!\n");
+	crypto_free_hash(tfm);
+
+	return 0;
+}
+
+static int fw_check_validity(struct tc_priv *priv, struct fw_bin *fw)
+{
+	u32 fw_id;
+	struct fw_hdr *hdr = &fw->fw_hdr;
+
+	if (hdr->comp_id != PPE_FW_COMPATIBILITY_ID) {
+		tc_err(priv, MSG_INIT,
+			"Compat ID not match! Driver: %d, FW: %d\n",
+			PPE_FW_COMPATIBILITY_ID, hdr->comp_id);
+		goto fw_check_fail;
+	}
+
+	fw_id = hdr->ptm_ver.family;
+	if (fw_id != VRX518_PPE_FW_ID) {
+		tc_err(priv, MSG_INIT,
+			"PTM FW ID not match PPE Family ID: Driver: %d, FW %d\n",
+			VRX518_PPE_FW_ID, fw_id);
+		goto fw_check_fail;
+	}
+
+	fw_id = hdr->atm_ver.family;
+	if (fw_id != VRX518_PPE_FW_ID) {
+		tc_err(priv, MSG_INIT,
+			"ATM FW ID not match PPE Family ID: Driver: %d, FW %d\n",
+			VRX518_PPE_FW_ID, fw_id);
+		goto fw_check_fail;
+	}
+
+	/* MD5 check */
+	fw_md5_check(priv, fw->fw);
+	return 0;
+
+fw_check_fail:
+	return -1;
+}
+
+int ppe_fw_load(struct tc_priv *priv)
+{
+	u32 i, id, off, size;
+	struct fw_hdr *fw_hdr;
+	struct fw_bin *fw_bin;
+	const u32 *src;
+	u32 *dst;
+
+	if (request_firmware(&priv->fw.fw, ppe_fw_name, priv->ep_dev[0].dev)) {
+		tc_err(priv, MSG_INIT,
+			"load PPE Firmware fail (%s)\n", ppe_fw_name);
+		return -ENODEV;
+	}
+
+	fw_bin = &priv->fw;
+	fw_hdr = &fw_bin->fw_hdr;
+
+	/* get fw information */
+	src = (const u32 *)fw_bin->fw->data;
+	dst = (u32 *)fw_hdr;
+	/* Header convert to CPU Endian */
+	for (i = 0; i < DW_SZ(*fw_hdr); i++)
+		dst[i] = be32_to_cpu(src[i]);
+
+	/* check for valid id */
+	fw_check_validity(priv, fw_bin);
+	off = sizeof(struct fw_hdr);
+	/* alloc memory for firmware */
+	for (i = 0; i < fw_hdr->fw_num; i++) {
+		id = fw_hdr->fw_info[i].fw_id;
+		size = TO_BYSZ(fw_hdr->fw_info[i].fw_size);
+		if (id < FW_MAX) {
+			fw_bin->fw_ptr[id] = fw_bin->fw->data + off;
+			tc_dbg(priv, MSG_INIT, "Firmware pointer id(%d):size(%d), fw addr(%p), off(%d)\n",
+				id, size, fw_bin->fw_ptr[id], off);
+			off += size;
+		} else {
+			tc_err(priv, MSG_INIT, "FW ID not correct!(%d)\n", id);
+			return -1;
+		}
+	}
+
+	fw_print_header_info(priv, fw_bin);
+
+	return 0;
+}
+
+int fw_version_info(struct tc_priv *priv, char *buffer)
+{
+	int i = 0;
+	struct fw_hdr *hdr;
+	if (priv == NULL) {
+		pr_err("<%s>: Invalid private data\n", __func__);
+		return -EINVAL;
+	}
+	if (buffer == NULL) {
+		tc_err(priv, MSG_INIT, "Invalid buffer\n");
+		return -EINVAL;
+	}
+	hdr = &(priv->fw.fw_hdr);
+	sprintf(buffer, "VRX518 PPE Firmware header info\n");
+	sprintf(buffer, "\tPTM Version: %d:%d:%d\n",
+		hdr->ptm_ver.major,
+		hdr->ptm_ver.mid,
+		hdr->ptm_ver.minor);
+	sprintf(buffer, "\tPTM Feature: %08X\n", hdr->ptm_ver.features);
+	sprintf(buffer, "\tATM Version: %d:%d:%d\n",
+		hdr->atm_ver.major,
+		hdr->atm_ver.mid,
+		hdr->atm_ver.minor);
+	sprintf(buffer, "\tATM Feature: %08X\n", hdr->atm_ver.features);
+	sprintf(buffer, "\tCompability ID: %08X\n", hdr->comp_id);
+	sprintf(buffer, "\tSize: %08X\n", hdr->hdr_sz);
+	sprintf(buffer, "\tFW built Date: %d-%d-%d\n",
+			((hdr->date >> 24) & 0xff),
+			((hdr->date >> 16) & 0xff),
+			((hdr->date) & 0xffff));
+	sprintf(buffer, "\tNumber of firmware: %d\n", hdr->fw_num);
+	for (i = 0; i < hdr->fw_num; i++) {
+		sprintf(buffer,
+			"\t\tFirmware[%d]: ID[%X] size[%d] at[0x%p]\n",
+			i,
+			hdr->fw_info[i].fw_id,
+			hdr->fw_info[i].fw_size,
+			priv->fw.fw_ptr[hdr->fw_info[i].fw_id]);
+	}
+	return 0;
+}
+
+void ppe_fw_unload(struct tc_priv *priv)
+{
+	if (priv->fw.fw)
+		release_firmware(priv->fw.fw);
+}
+
diff --git a/drivers/net/ethernet/intel/vrx518/tc/tc_main.c b/drivers/net/ethernet/intel/vrx518/tc/tc_main.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/tc_main.c
@@ -0,0 +1,317 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#define DEBUG
+#define pr_fmt(fmt) KBUILD_MODNAME ":%s: " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/atomic.h>
+#include <linux/uaccess.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/wait.h>
+#include <linux/seq_file.h>
+#include <linux/printk.h>
+#include <linux/etherdevice.h>
+
+#include "inc/tc_main.h"
+#include "inc/platform.h"
+#include "inc/reg_addr.h"
+#include "inc/tc_common.h"
+#include "inc/tc_api.h"
+#include "inc/tc_proc.h"
+
+
+#define DRV_VERSION	"1.3.3"
+
+static const char tc_drv_name[] = "vrx518_tc";
+static const char tc_drv_ver[] = DRV_VERSION;
+static const char tc_drv_string[] =
+			"Intel(R) SmartPHY DSL(VRX518) PCIe TC Driver";
+static const char tc_drv_copyright[] =
+			"Copyright (c) 2016 Intel Corporation.";
+static struct tc_priv *g_tc_priv;
+static int p2p_en = 1;
+static int loopback_en;
+static int sharing_cdma_en = 1;
+static u32 umt_period = UMT_DEF_PERIOD;
+static u32 cdma_desc_loc = 1;
+static u32 powersaving;
+
+module_param(p2p_en, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(p2p_en, "PTM Bonding directly access Peer Enable flag.");
+module_param(loopback_en, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(loopback_en, "Enable-1/Disable-0 the DFE loopback mode.");
+module_param(sharing_cdma_en, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(sharing_cdma_en, "Enable-1/Disable-0 the sharing CDMA mode.");
+module_param(umt_period, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(umt_period, "Adjust the frequency of the UMT message, default: 200us");
+module_param(cdma_desc_loc, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(cdma_desc_loc, "CDMA descriptor address: 0 - SRAM/1 - FPI");
+module_param(powersaving, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(powersaving, "Powersaving configuration: 0 - Disable/1-Enable");
+
+static int pcie_ep_probe(struct tc_priv *priv)
+{
+	int dev_num;
+	int i;
+
+	if (dc_ep_dev_num_get(&dev_num)) {
+		tc_err(priv, MSG_INIT, "Failed to get total PCIe device number\n");
+		return -EIO;
+	}
+	tc_dbg(priv, MSG_INIT, "Total %d VRX518 EP detected\n", dev_num);
+
+	for (i = 0; i < dev_num; i++) {
+		if (dc_ep_dev_info_req(i, DC_EP_INT_PPE, &priv->ep_dev[i])) {
+			tc_err(priv, MSG_INIT, "failed to get pcie ep %d\n", i);
+			goto err1;
+		}
+	}
+
+	priv->ep_num = i;
+	priv->switch_exist = priv->ep_dev[0].switch_attached;
+
+	return 0;
+err1:
+	for (i = i - 1; i >= 0; i--)
+		dc_ep_dev_info_release(i);
+
+	return -EIO;
+}
+
+static void pcie_ep_release(struct tc_priv *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->ep_num; i++)
+		dc_ep_dev_info_release(i);
+}
+
+static void tc_def_recv(struct net_device *pdev, struct sk_buff *skb)
+{
+	tc_dbg(g_tc_priv, MSG_RX, "TC is not loaded\n");
+	dev_kfree_skb_any(skb);
+}
+
+static void tc_def_irq_on(u32 irq_no)
+{
+	return;
+}
+
+static void tc_def_irq_off(u32 irq_no)
+{
+	return;
+}
+
+static int tc_def_getqid(struct net_device *pdev, struct sk_buff *skb,
+		void *vcc, uint32_t flags)
+{
+	return -1;
+}
+
+static inline void tc_def_ops_setup(struct tc_priv *priv)
+{
+	spin_lock_bh(&priv->tc_lock);
+	priv->tc_ops.recv = tc_def_recv;
+	priv->tc_ops.irq_on = tc_def_irq_on;
+	priv->tc_ops.irq_off = tc_def_irq_off;
+	priv->tc_ops.get_qid = tc_def_getqid;
+	priv->tc_ops.showtime_enter = NULL;
+	priv->tc_ops.showtime_exit = NULL;
+	/*priv->tc_ops.tc_reset = NULL;*/
+	spin_unlock_bh(&priv->tc_lock);
+}
+
+static inline void init_local_param(struct tc_priv *priv)
+{
+	if (priv->ep_num > 1)
+		priv->param.bonding_en = 1;
+	priv->param.dfe_loopback = loopback_en;
+	priv->param.p2p = p2p_en;
+	priv->param.umt_period = umt_period;
+	priv->param.sharing_cdma_en = sharing_cdma_en;
+	priv->param.cdma_desc_loc = cdma_desc_loc;
+	priv->param.ps = powersaving;
+	priv->tc_mode = TC_NONE_MODE;
+	priv->tc_stat = NO_TC;
+	priv->tc_idx = -1;
+	spin_lock_init(&priv->tc_lock);
+	tc_def_ops_setup(priv);
+}
+
+void tc_unload(struct tc_priv *priv)
+{
+	if (priv->tc_mode == TC_NONE_MODE)
+		return;
+	tc_def_ops_setup(priv);
+	if (priv->tc_mode == TC_PTM_SL_MODE ||
+		priv->tc_mode == TC_PTM_BND_MODE)
+		ptm_tc_unload(priv->tc_mode);
+	else if (priv->tc_mode == TC_ATM_SL_MODE)
+		atm_tc_unload();
+
+	spin_lock_bh(&priv->tc_lock);
+	priv->tc_mode = TC_NONE_MODE;
+	priv->tc_stat = NO_TC;
+	priv->priv = NULL;
+	spin_unlock_bh(&priv->tc_lock);
+}
+
+void tc_load(struct tc_priv *priv, u32 id, enum dsl_tc_mode mode)
+{
+	if (mode == TC_NONE_MODE)
+		return;
+
+	spin_lock_bh(&priv->tc_lock);
+	priv->tc_mode = mode;
+	spin_unlock_bh(&priv->tc_lock);
+	if (mode == TC_PTM_SL_MODE || mode == TC_PTM_BND_MODE)
+		ptm_tc_load(priv, id, mode);
+	else if (mode == TC_ATM_SL_MODE)
+		atm_tc_load(priv, id, mode);
+
+	spin_lock_bh(&priv->tc_lock);
+	priv->tc_stat = TC_RUN;
+	priv->tc_idx = id;
+	spin_unlock_bh(&priv->tc_lock);
+}
+
+void tc_request(u32 id, enum dsl_tc_mode tc_mode)
+{
+	struct tc_priv *priv = g_tc_priv;
+
+	tc_unload(priv);
+	tc_load(priv, id, tc_mode);
+}
+
+void tc_get_drv_version(const char **drv_name, const char **drv_ver)
+{
+	*drv_name = tc_drv_name;
+	*drv_ver = tc_drv_ver;
+}
+
+static int __init tc_drv_init(void)
+{
+	struct tc_priv *priv;
+	int ret;
+	size_t size;
+
+	size = ALIGN(sizeof(struct tc_priv), TCPRIV_ALIGN) + plat_priv_sz();
+	priv = kzalloc(size, GFP_KERNEL);
+	if (!priv) {
+		pr_err("Alloc tc priv fail!\n");
+		return -ENOMEM;
+	}
+	g_tc_priv = priv;
+
+	priv->msg_enable = TC_DEF_DBG;
+	ret = pcie_ep_probe(priv);
+	if (ret < 0) {
+		tc_err(priv, MSG_INIT, "ep probe fail!\n");
+		goto err1;
+	}
+
+	init_local_param(priv);
+
+	ret = platform_init(priv, tc_drv_name);
+	if (ret < 0) {
+		tc_err(priv, MSG_INIT, "soc platform init fail!\n");
+		goto err2;
+	}
+	ret = ppe_fw_load(priv);
+	if (ret < 0)
+		goto err3;
+
+	tc_gentlk_init(priv);
+	tc_proc_init(priv);
+
+	tc_info(priv, MSG_INIT, "%s - version %s\n",
+		tc_drv_string, tc_drv_ver);
+	tc_info(priv, MSG_INIT, "%s\n", tc_drv_copyright);
+
+	return 0;
+err3:
+	platform_exit();
+err2:
+	pcie_ep_release(priv);
+err1:
+	kfree(priv);
+	g_tc_priv = NULL;
+	return ret;
+}
+module_init(tc_drv_init);
+
+/**
+ * 1. Unregister DSL callback function
+ * 2. Unload TC
+ * 3. free ATM/PTM/Bonding driver resources
+ * 4. free SoC resource
+ * 5. free proc
+ * 6. free tc_priv
+ * 7. free netlink resource
+ */
+static void __exit tc_drv_exit(void)
+{
+	struct tc_priv *priv;
+
+	priv = g_tc_priv;
+	platform_dsl_exit();
+	spin_lock_bh(&priv->tc_lock);
+	if (priv->tc_stat == TC_INIT || priv->tc_stat == TC_SWITCHING)
+		goto err1;
+	spin_unlock_bh(&priv->tc_lock);
+	if (priv->tc_stat == TC_RUN)
+		tc_unload(priv);
+
+	ptm_exit();
+	atm_exit();
+	ppe_fw_unload(priv);
+	tc_proc_exit(priv);
+	platform_exit();
+	pcie_ep_release(priv);
+	kfree(priv);
+	tc_gentlk_exit();
+
+	pr_info("%s driver unloaded\n", tc_drv_name);
+	return;
+
+err1:
+	spin_unlock_bh(&priv->tc_lock);
+	tc_dbg(priv, MSG_SWITCH,
+		"TC is not ready to exit: %d\n", priv->tc_stat);
+
+	return;
+}
+module_exit(tc_drv_exit);
+
+
+MODULE_AUTHOR("Intel Corporation, <yixin.zhu@intel.com>");
+MODULE_DESCRIPTION("Intel(R) SmartPHY PCIe EP/ACA Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff --git a/drivers/net/ethernet/intel/vrx518/tc/tc_proc.c b/drivers/net/ethernet/intel/vrx518/tc/tc_proc.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/ethernet/intel/vrx518/tc/tc_proc.c
@@ -0,0 +1,2503 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <net/datapath_api.h>
+#include <net/dsl_tc.h>
+#include <net/genetlink.h>
+#include <linux/time.h>
+#include "inc/tc_main.h"
+#include "inc/reg_addr.h"
+#include "inc/tc_common.h"
+#include "inc/tc_api.h"
+#include "inc/atm_tc.h"
+#include "inc/ptm_tc.h"
+#include "inc/tc_proc.h"
+#include "inc/platform.h"
+
+#define ATM_HEADER_SIZE (ATM_CELL_SIZE - ATM_CELL_PAYLOAD)
+static char *dbg_flag_str[] = {
+	"rx",
+	"tx",
+	"event",
+	"rx_data",
+	"tx_data",
+	"init",
+	"oam_rx",
+	"oam_tx",
+	"oam_rx_data",
+	"oam_tx_data",
+	"qos",
+	"switch",
+	"loopback",
+	"coc",
+	"mib"
+};
+
+static inline int lower_ch(int ch)
+{
+	if (ch >= 'A' && ch <= 'Z')
+		return ch + 'a' - 'A';
+	return ch;
+}
+
+static void vrx_replace_ch(char *p, int len, char orig_ch, char new_ch)
+{
+	int i;
+
+	if (p)
+		for (i = 0; i < len; i++) {
+			if (p[i] == orig_ch)
+				p[i] = new_ch;
+		}
+}
+
+static void vrx_remove_leading_whitespace(char **p, int *len)
+{
+	while (*len && ((**p == ' ') || (**p == '\r') || (**p == '\r'))) {
+		(*p)++;
+		(*len)--;
+	}
+}
+static unsigned int vrx_btoi(char *str)
+{
+	unsigned int sum = 0;
+	signed len = 0, i = 0;
+
+	len = strlen(str);
+	len = len - 1;
+	while (len >= 0) {
+		if (*(str + len) == '1')
+			sum = (sum | (1 << i));
+		i++;
+		len--;
+	}
+	return sum;
+}
+static int vrx_atoi(unsigned char *str)
+{
+	unsigned int n = 0;
+	int i = 0;
+	int nega_sign = 0;
+
+	if (!str)
+		return 0;
+	vrx_replace_ch(str, strlen(str), '.', 0);
+	vrx_replace_ch(str, strlen(str), ' ', 0);
+	vrx_replace_ch(str, strlen(str), '\r', 0);
+	vrx_replace_ch(str, strlen(str), '\n', 0);
+	if (str[0] == 0)
+		return 0;
+
+	if (str[0] == 'b' || str[0] == 'B') {	/*binary format */
+		n = vrx_btoi(str + 1);
+	} else if ((str[0] == '0') && ((str[1] == 'x') || (str[1] == 'X'))) {
+		/*hex format */
+		str += 2;
+
+		while (str[i]) {
+			n = n * 16;
+			if (('0' <= str[i] && str[i] <= '9')) {
+				n += str[i] - '0';
+			} else if (('A' <= str[i] && str[i] <= 'F')) {
+				n += str[i] - 'A' + 10;
+				;
+			} else if (('a' <= str[i] && str[i] <= 'f')) {
+				n += str[i] - 'a' + 10;
+				;
+			} else
+				pr_err("Wrong value:%u\n", str[i]);
+
+			i++;
+		}
+
+	} else {
+		if (str[i] == '-') {	/*negative sign */
+			nega_sign = 1;
+			i++;
+		}
+		while (str[i]) {
+			n *= 10;
+			n += str[i] - '0';
+			i++;
+		}
+	}
+	if (nega_sign)
+		n = -(int)n;
+	return n;
+}
+
+int vrx_strcmpi(char const *s1, char const *s2)
+{
+	int c1, c2;
+
+	if (!s1 || !s2)
+		return 1;
+	while (*s1 && *s2) {	/*same length */
+		c1 = lower_ch(*s1);
+		c2 = lower_ch(*s2);
+		s1++;
+		s2++;
+
+		if (c1 != c2)
+			return c1 - c2;
+	}
+	return *s1 - *s2;
+}
+
+static int get_num_from_str(char **p, int *len, int is_hex)
+{
+	int ret = 0;
+	int n = 0;
+
+	if ((*p)[0] == '0' && (*p)[1] == 'x') {
+		is_hex = 1;
+		(*p) += 2;
+		(*len) -= 2;
+	}
+
+	if (is_hex) {
+		while (*len && ((**p >= '0' && **p <= '9')
+			|| (**p >= 'a' && **p <= 'f')
+			|| (**p >= 'A' && **p <= 'F'))) {
+
+			if (**p >= '0' && **p <= '9')
+				n = **p - '0';
+			else if (**p >= 'a' && **p <= 'f')
+				n = **p - 'a' + 10;
+			else if (**p >= 'A' && **p <= 'F')
+				n = **p - 'A' + 10;
+			ret = (ret << 4) | n;
+			(*p)++;
+			(*len)--;
+		}
+	} else {
+		while (*len && **p >= '0' && **p <= '9') {
+			n = **p - '0';
+			ret = ret * 10 + n;
+			(*p)++;
+			(*len)--;
+		}
+	}
+
+	return ret;
+}
+
+/*Split buffer to multiple segment with seperator space.
+And put pointer to array[].
+By the way, original buffer will be overwritten with '\0' at some place.
+*/
+int vrx_split_buffer(char *buffer, char *array[], int max_param_num)
+{
+	int i, set_copy = 0;
+	int res = 0;
+	int len;
+
+	for (i = 0; i < max_param_num; i++)
+		array[i] = NULL;
+	if (!buffer)
+		return 0;
+	len = strlen(buffer);
+	for (i = 0; i < max_param_num;) {
+		if (len <= 0)
+			break;
+		vrx_remove_leading_whitespace(&buffer, &len);
+		for (;
+		     *buffer != ' ' && *buffer != '\0' && *buffer != '\r'
+		     && *buffer != '\n' && *buffer != '\t' && len >= 0;
+		     buffer++, len--) {
+			/*Find first valid charactor */
+			set_copy = 1;
+			if (!array[i])
+				array[i] = buffer;
+		}
+
+		if (set_copy == 1) {
+			i++;
+			if (*buffer == '\0' || *buffer == '\r'
+			    || *buffer == '\n') {
+				*buffer = 0;
+				break;
+			}
+			*buffer = 0;
+			buffer++;
+			len--;
+			set_copy = 0;
+
+		} else {
+			if (*buffer == '\0' || *buffer == '\r'
+			    || *buffer == '\n')
+				break;
+			buffer++;
+			len--;
+		}
+	}
+	res = i;
+
+	return res;
+}
+
+static void print_ppe_clk(struct seq_file *seq, struct dc_ep_dev *ep_dev)
+{
+	u32 sys_clk, ppe_clk;
+	char *str_ppe_clk[] = {"36MHZ", "576MHZ", "494MHZ", "432MHZ", "288MHZ"};
+
+	ep_dev->hw_ops->clk_get(ep_dev, &sys_clk, &ppe_clk);
+	WARN_ON(ppe_clk >= PPE_CLK_MAX);
+	seq_printf(seq, "PPE CLK: %s\n", str_ppe_clk[ppe_clk]);
+
+	return;
+}
+
+static ssize_t mem_proc_write(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+	int c, i;
+	int action;
+	u32 addr, set_val, repeat_cnt, rdaddr;
+	struct tc_comm *priv;
+	struct tc_priv *tcpriv;
+	u32 soc_flag, prt_num;
+	int num, len, rlen, idx, buflen;
+	char *param_list[32], *p;
+	char str[128], bufstr[128];
+
+	priv = ((struct tc_comm *)PDE_DATA(file_inode(file)));
+	if (priv == NULL) {
+		pr_err("%s: Invalid priv data\n", __func__);
+		return -EFAULT;
+	}
+	tcpriv = priv->tc_priv;
+	if (tcpriv == NULL) {
+		pr_err("%s: framework pointer is NULL!!!\n", __func__);
+		return -EINVAL;
+	}
+	addr = set_val = repeat_cnt = 0;
+
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = vrx_split_buffer(str, param_list, ARRAY_SIZE(param_list)) - 1;
+
+	idx = 0;
+	soc_flag = 0;
+	action = 0;
+	prt_num = 4;
+
+	if (vrx_strcmpi(param_list[idx], "s") == 0) {
+		idx++;
+		soc_flag = 1;
+	}
+	if (vrx_strcmpi(param_list[idx], "r") == 0) {
+		idx++;
+		action = PPE_PROC_READ;
+	} else if (vrx_strcmpi(param_list[idx], "w") == 0) {
+		idx++;
+		action = PPE_PROC_WRITE;
+	} else if (vrx_strcmpi(param_list[idx], "d") == 0) {
+		idx++;
+		action = PPE_PROC_READ;
+		prt_num = 1;
+	}
+
+	if (!action)
+		goto proc_mem_help;
+
+	num = num - idx + 1;
+	if (num < 2)
+		goto proc_mem_help;
+
+	p = param_list[idx++];
+	addr = get_num_from_str(&p, &len, 1);
+	num --;
+	/* addr = SB_BUFFER(addr); need to specify this is SB or FPI address */
+
+	if (action == PPE_PROC_READ) {
+		repeat_cnt = vrx_atoi(param_list[idx]);
+		for (i = 0; i < repeat_cnt; i += prt_num) {
+			memset(bufstr, 0 , 128);
+			buflen = 0;
+			if (soc_flag)
+				sprintf(bufstr, "0x%08x: ", addr + TO_BYSZ(i));
+			else
+				sprintf(bufstr, "0x%08x: ",
+					((fpi_addr(addr) + TO_BYSZ(i))));
+			for (c = 0; c < prt_num && (i + c) < repeat_cnt; c++) {
+				buflen = strlen(bufstr);
+				if (soc_flag) {
+					rdaddr = addr + TO_BYSZ(i + c);
+					sprintf(bufstr + buflen, "%08x  ",
+						readl((void __iomem *)rdaddr));
+				} else {
+					rdaddr = fpi_addr(addr)
+							+ TO_BYSZ(i + c);
+					sprintf(bufstr + buflen, "%08x  ",
+						tc_r32(rdaddr));
+				}
+			}
+			pr_info("%s\n", bufstr);
+		}
+	} else if (action == PPE_PROC_WRITE) {
+		if (vrx_strcmpi(param_list[idx + 1], "r") == 0 ||
+			vrx_strcmpi(param_list[idx + 1], "rpt") == 0) {
+			repeat_cnt = vrx_atoi(param_list[idx + 2]);
+			set_val = vrx_atoi(param_list[idx]);
+			for (i = 0; i < repeat_cnt; i++) {
+				if (soc_flag)
+					writel(set_val,
+					(void __iomem *)(addr + TO_BYSZ(i)));
+				else
+					tc_w32(set_val,
+						fpi_addr(addr) + TO_BYSZ(i));
+			}
+		} else {
+			for (i = 0; i < num; i++) {
+				set_val = vrx_atoi(param_list[idx + i]);
+				if (soc_flag)
+					writel(set_val,
+					(void __iomem *)(addr + TO_BYSZ(i)));
+				else
+					tc_w32(set_val,
+						fpi_addr(addr) + TO_BYSZ(i));
+			}
+		}
+	}
+
+	return count;
+
+proc_mem_help:
+	pr_info("echo <s> r [soc_addr] [count] > mem\n");
+	pr_info("echo <s> w [addr] [value] [val0] <val1> ... > mem\n");
+	pr_info("echo <s> w [addr] <value> r [repeat_count] > mem\n");
+	return count;
+}
+
+static int proc_read_mem(struct seq_file *seq, void *v)
+{
+	return 0;
+}
+
+static int proc_read_mem_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_mem, NULL);
+}
+
+static const struct file_operations mem_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_mem_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= mem_proc_write,
+};
+
+static ssize_t pp32_proc_write(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+	struct tc_comm *priv;
+	u32 reg_val;
+	char str[128];
+	u32 addr;
+	int len, rlen, pc;
+	int pp32 = 0;
+
+	int num;
+	char *param_list[20];
+
+	priv = ((struct tc_comm *)PDE_DATA(file_inode(file)));
+	if (priv == NULL) {
+		pr_err("%s: priv pointer is NULL!!!\n", __func__);
+		return -EINVAL;
+	}
+
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = vrx_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+	pp32 = vrx_atoi(param_list[1]);
+	if (vrx_strcmpi(param_list[0], "pp32") == 0) {
+		if (vrx_strcmpi(param_list[2], "restart") == 0) {
+			reg_val = tc_r32(PPE_FREEZE) & (~(1 << (pp32 << 4)));
+			tc_w32(reg_val, PPE_FREEZE);
+		} else if (vrx_strcmpi(param_list[2], "freeze") == 0) {
+			reg_val = tc_r32(PPE_FREEZE) | (1 << (pp32 << 4));
+			tc_w32(reg_val, PPE_FREEZE);
+		} else if (vrx_strcmpi(param_list[2], "start") == 0) {
+			tc_w32(CTRL_CMD_RESTART, PP32_CTRL_CMD(pp32));
+		} else if (vrx_strcmpi(param_list[2], "stop") == 0) {
+			tc_w32(CTRL_CMD_STOP, PP32_CTRL_CMD(pp32));
+		} else if (vrx_strcmpi(param_list[2], "step") == 0) {
+			tc_w32(0, PP32_CTRL_CMD(pp32));
+			tc_w32(CTRL_CMD_STEP, PP32_CTRL_CMD(pp32));
+		} else if ((vrx_strcmpi(param_list[2], "pc0") == 0)
+				|| (vrx_strcmpi(param_list[2], "pc1") == 0)) {
+			if (vrx_strcmpi(param_list[2], "pc0") == 0)
+				pc = 0;
+			else
+				pc = 1;
+
+			if (vrx_strcmpi(param_list[3], "off") == 0) {
+				tc_w32(BRK_GRP_PC_OFF(pc, pc), BRK_TRIG(pp32));
+				tc_w32(BRK_CONTEXT_MASK_EN,
+					BRK_PC_MASK(pp32, pc));
+				tc_w32(0, BRK_PC(pp32, pc));
+			} else {
+				addr = vrx_atoi(param_list[3]);
+				tc_w32(addr, BRK_PC(pp32, pc));
+				tc_w32(BRK_CONTEXT_MASK_EN | BRK_CONTEXT_MASK,
+					BRK_PC_MASK(pp32, pc));
+				tc_w32(BRK_GRP_PC_ON(pc, pc), BRK_TRIG(pp32));
+			}
+		} else if ((vrx_strcmpi(param_list[2], "daddr0") == 0)
+			|| (vrx_strcmpi(param_list[2], "daddr1") == 0)) {
+			if (vrx_strcmpi(param_list[2], "daddr0") == 0)
+					pc = 0;
+			else
+					pc = 1;
+
+			if (vrx_strcmpi(param_list[3], "off") == 0) {
+				tc_w32(BRK_GRP_DATA_ADDR_OFF(pc, pc),
+					BRK_TRIG(pp32));
+				tc_w32(BRK_CONTEXT_MASK_EN,
+					BRK_DATA_ADDR_MASK(pp32, pc));
+				tc_w32(0, BRK_DATA_ADDR(pp32, pc));
+
+			} else {
+				addr = vrx_atoi(param_list[3]);
+				tc_w32(addr, BRK_DATA_ADDR(pp32, pc));
+				tc_w32(BRK_CONTEXT_MASK_EN | BRK_CONTEXT_MASK,
+					BRK_DATA_ADDR_MASK(pp32, pc));
+				tc_w32(BRK_GRP_DATA_ADDR_ON(pc, pc),
+					BRK_TRIG(pp32));
+			}
+		}
+	} else {
+		goto proc_pp32_help;
+	}
+	if (tc_r32(BRK_TRIG(pp32)))
+		tc_w32(STOP_ON_BREAKPOINT_ON,
+			PP32_CTRL_OPT(pp32));
+	else
+		tc_w32(STOP_ON_BREAKPOINT_OFF,
+			PP32_CTRL_OPT(pp32));
+	return count;
+
+proc_pp32_help:
+	pr_info("echo pp32 <id> freeze/start/stop/step/restart > pp32\n");
+	pr_info("echo pp32 <id> pc0 off/[addr] > pp32\n");
+	pr_info("echo pp32 <id> daddr0 off/[addr] > pp32\n");
+	return count;
+}
+static int proc_read_pp32(struct seq_file *seq, void *v)
+{
+	struct tc_comm *priv = ((struct tc_comm *)seq->private);
+	static const char *stron = " on";
+	static const char *stroff = "off";
+
+	int cur_context;
+	int f_stopped;
+	char strlength;
+	int i, j;
+
+	int pp32;
+
+	if (!priv) {
+		pr_err("priv pointer is NULL!!!\n");
+		return -EINVAL;
+	}
+
+	for (pp32 = 0; pp32 < PP32_MAX; pp32++) {
+		f_stopped = 0;
+		seq_printf(seq, "===== pp32 core %d =====\n", pp32);
+
+		cur_context = BRK_CUR_CONTEXT(pp32);
+		seq_printf(seq, "Context: %d, PC: 0x%04x ",
+			cur_context, CUR_PC(pp32));
+		if ((tc_r32(PPE_FREEZE) & (1 << (pp32 << 4))) != 0) {
+			seq_puts(seq, "freezed");
+			f_stopped = 1;
+		} else if (USER_STOPPED(pp32) || USER_BREAKIN_RCV(pp32)
+			|| USER_BREAKPOINT_MET(pp32)) {
+			strlength = 0;
+			f_stopped = 1;
+			if (USER_STOPPED(pp32)) {
+				seq_puts(seq, "stopped");
+				strlength = 1;
+			}
+			if (USER_BREAKPOINT_MET(pp32)) {
+				seq_printf(seq, "%s", strlength ?
+					" | breakpoint" : "breakpoint");
+				strlength = 1;
+			}
+			if (USER_BREAKIN_RCV(pp32))
+				seq_printf(seq, "%s", strlength ?
+					" | breakin" : "breakin");
+
+		} else if (CUR_PC(pp32) == CUR_PC(pp32)) {
+			unsigned int pc_val[64] = {0};
+			f_stopped = 1;
+			for (i = 0; f_stopped && i < ARRAY_SIZE(pc_val); i++) {
+				pc_val[i] = CUR_PC(pp32);
+				for (j = 0; j < i; j++)
+					if (pc_val[j] != pc_val[i]) {
+						f_stopped = 0;
+						break;
+					}
+				}
+				if (f_stopped)
+					seq_puts(seq, "hang");
+		}
+		if (!f_stopped)
+			seq_puts(seq, "running");
+
+		seq_puts(seq, "\n");
+
+		strlength = 0;
+		if (USER_BREAKPOINT_MET(pp32)) {
+			seq_puts(seq, "break reason: ");
+			if (BRK_PC_MET(pp32, 0)) {
+				seq_puts(seq, "pc0");
+				strlength = 1;
+			}
+			if (BRK_PC_MET(pp32, 1)) {
+				seq_printf(seq, "%s", strlength ?
+					" | pc1" : "pc1");
+				strlength = 1;
+			}
+			if (BRK_DATA_ADDR_MET(pp32, 0)) {
+				seq_printf(seq, "%s", strlength ?
+					" | daddr0" : "daddr0");
+				strlength = 1;
+			}
+			if (BRK_DATA_ADDR_MET(pp32, 1)) {
+				seq_printf(seq, "%s", strlength ?
+					" | daddr1" : "daddr1");
+				strlength = 1;
+			}
+			if (BRK_DATA_VAL_RD_MET(pp32, 0)) {
+				seq_printf(seq, "%s", strlength ?
+					" | rdval0" : "rdval0");
+				strlength = 1;
+				if (BRK_DATA_VAL_RD_LO_EQ(pp32, 0)) {
+					if (BRK_DATA_VAL_RD_GT_EQ(pp32, 0))
+						seq_puts(seq, " ==");
+					else
+						seq_puts(seq, " <=");
+				} else if (BRK_DATA_VAL_RD_GT_EQ(pp32, 0))
+					seq_puts(seq, " >=");
+			}
+			if (BRK_DATA_VAL_RD_MET(pp32, 1)) {
+				seq_printf(seq, "%s", strlength ?
+					" | rdval1" : "rdval1");
+				strlength = 1;
+				if (BRK_DATA_VAL_RD_LO_EQ(pp32, 1)) {
+					if (BRK_DATA_VAL_RD_GT_EQ(pp32, 1))
+						seq_puts(seq, " ==");
+					else
+						seq_puts(seq, " <=");
+				} else if (BRK_DATA_VAL_RD_GT_EQ(pp32, 1))
+					seq_puts(seq, " >=");
+			}
+			if (BRK_DATA_VAL_WR_MET(pp32, 0)) {
+				seq_printf(seq, "%s", strlength ?
+					" | wtval0" : "wtval0");
+				strlength = 1;
+				if (BRK_DATA_VAL_WR_LO_EQ(pp32, 0)) {
+					if (BRK_DATA_VAL_WR_GT_EQ(pp32, 0))
+						seq_puts(seq, " ==");
+					else
+						seq_puts(seq, " <=");
+				} else if (BRK_DATA_VAL_WR_GT_EQ(pp32, 0))
+					seq_puts(seq, " >=");
+			}
+			if (BRK_DATA_VAL_WR_MET(pp32, 1)) {
+				seq_printf(seq, "%s", strlength ?
+					" | wtval1" : "wtval1");
+				strlength = 1;
+				if (BRK_DATA_VAL_WR_LO_EQ(pp32, 1)) {
+					if (BRK_DATA_VAL_WR_GT_EQ(pp32, 1))
+						seq_puts(seq, " ==");
+					else
+						seq_puts(seq, " <=");
+				} else if (BRK_DATA_VAL_WR_GT_EQ(pp32, 1))
+					seq_puts(seq, " >=");
+			}
+			seq_puts(seq, "\n");
+		}
+
+		if (f_stopped) {
+			seq_puts(seq, "General Purpose Register (Context ");
+			seq_printf(seq, "%d):\n", cur_context);
+			for (i = 0; i < 4; i++) {
+				for (j = 0; j < 4; j++)
+					seq_printf(seq, "   %2d: %08x",
+						i + j * 4,
+						GP_CONTEXT_REG(pp32,
+							cur_context,
+							i + j * 4));
+				seq_puts(seq, "\n");
+			}
+		}
+
+		seq_printf(seq, "break out on: break in - %s, stop - %s\n",
+			BREAKOUT_ON_BREAKIN(pp32) ? stron : stroff,
+			BREAKOUT_ON_STOP(pp32) ? stron : stroff);
+		seq_printf(seq, "\tstop on: break in - %s, break point - %s\n",
+			STOP_ON_BREAKIN(pp32) ? stron : stroff,
+			STOP_ON_BREAKPOINT(pp32) ? stron : stroff);
+		seq_puts(seq, "breakpoint:\n");
+		seq_printf(seq, "     pc0: 0x%08x, %s\n",
+			tc_r32(BRK_PC(pp32, 0)),
+			BRK_GRP_PC(pp32, 0, 0) ? "group 0" : "off");
+		seq_printf(seq, "     pc1: 0x%08x, %s\n",
+			tc_r32(BRK_PC(pp32, 1)),
+			BRK_GRP_PC(pp32, 1, 1) ? "group 1" : "off");
+		seq_printf(seq, "  daddr0: 0x%08x, %s\n",
+			tc_r32(BRK_DATA_ADDR(pp32, 0)),
+			BRK_GRP_DATA_ADDR(pp32, 0, 0) ? "group 0" : "off");
+		seq_printf(seq, "  daddr1: 0x%08x, %s\n",
+			tc_r32(BRK_DATA_ADDR(pp32, 1)),
+			BRK_GRP_DATA_ADDR(pp32, 1, 1) ? "group 1" : "off");
+		seq_printf(seq, "  rdval0: 0x%08x\n",
+			tc_r32(BRK_DATA_VAL_RD(pp32, 0)));
+		seq_printf(seq, "  rdval1: 0x%08x\n",
+			tc_r32(BRK_DATA_VAL_RD(pp32, 1)));
+		seq_printf(seq, "  wrval0: 0x%08x\n",
+			tc_r32(BRK_DATA_VAL_WR(pp32, 0)));
+		seq_printf(seq, "  wrval1: 0x%08x\n",
+			tc_r32(BRK_DATA_VAL_WR(pp32, 1)));
+	}
+
+	return 0;
+}
+
+static int proc_read_pp32_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_pp32, PDE_DATA(inode));
+}
+
+static const struct file_operations pp32_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_pp32_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= pp32_proc_write,
+};
+
+static int proc_read_tc_cfg(struct seq_file *seq, void *v)
+{
+	struct tc_priv *priv = (struct tc_priv *)seq->private;
+	const char *tc_mode_str[] = {
+		"VRX518 Running",
+		"VRX518 Init",
+		"VRX518 NO_TC_Loaded",
+		"VRX518 Switching",
+		"VRX518 Exit",
+		"VRX518 Error",
+		NULL,
+	};
+	seq_printf(seq, "VRX518 TC mode: %s\n",
+		tc_mode_str[priv->tc_stat]);
+	seq_printf(seq, "DFE loopback: %s\n",
+		priv->param.dfe_loopback ? "Enable" : "Disable");
+	seq_printf(seq, "P2P: %s\n",
+		priv->param.p2p ? "Enable" : "Disable");
+	seq_printf(seq, "EP num: %d\n", priv->ep_num);
+	seq_printf(seq, "ShowTime: %s\n", showtime_stat(priv) ? "Yes" : "No");
+	seq_printf(seq, "PCIe Switch present: %s\n",
+		!!(priv->switch_exist) ? "Yes" : "No");
+
+	return 0;
+}
+
+static int proc_read_tc_cfg_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_tc_cfg, PDE_DATA(inode));
+}
+
+static const struct file_operations tc_cfg_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_tc_cfg_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static ssize_t proc_write_dbg(struct file *file, const char __user *buf,
+			size_t count, loff_t *data)
+{
+	struct tc_priv *priv;
+	char str[32];
+	int len, rlen, i, j;
+	int num, enable = 0;
+	char *param_list[20];
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	priv = (struct tc_priv *)PDE_DATA(file_inode(file));
+	if (priv == NULL)
+		return count;
+
+	num = vrx_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+
+	if ((vrx_strcmpi(param_list[0], "enable") == 0)
+		|| (vrx_strcmpi(param_list[0], "en") == 0)) {
+		enable = 1;
+	} else if (vrx_strcmpi(param_list[0], "disable") == 0
+		|| (vrx_strcmpi(param_list[0], "dis") == 0)) {
+		enable = -1;
+	} else {
+		goto proc_dbg_help;
+	}
+	if (!param_list[1]) {
+		set_vrx_dbg_flag(priv->msg_enable, enable, -1);
+		return count;
+	}
+	for (i = 1; i < num; i++) {
+		for (j = 0; j < ARRAY_SIZE(dbg_flag_str); j++) {
+			if (vrx_strcmpi(param_list[i], dbg_flag_str[j]) == 0) {
+				set_vrx_dbg_flag(priv->msg_enable,
+					enable, BIT(j));
+				break;
+			}
+		}
+	}
+	pr_info("dbg write:%d\n", priv->msg_enable);
+
+	return count;
+
+proc_dbg_help:
+	pr_info("echo [enable| disable] <dbg> > dbg \n");
+	for (i = 0; i < ARRAY_SIZE(dbg_flag_str); i++)
+		pr_info("%s ", dbg_flag_str[i]);
+	pr_info("\n");
+
+	return count;
+}
+
+static int proc_read_dbg(struct seq_file *seq, void *v)
+{
+	int i;
+	struct tc_priv *priv;
+	priv = (struct tc_priv *)seq->private;
+	if (priv == NULL)
+		return -1;
+	seq_printf(seq, "Dbg Enable:0x%08x\n", priv->msg_enable);
+	for (i = 0; i < ARRAY_SIZE(dbg_flag_str); i++) {
+		if ((priv->msg_enable & BIT(i)) == BIT(i))
+			seq_printf(seq, "%s ", dbg_flag_str[i]);
+	}
+	seq_puts(seq, "\n");
+	return 0;
+}
+
+static int proc_read_dbg_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_dbg, PDE_DATA(inode));
+}
+
+static const struct file_operations tc_dbg_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_dbg_seq_open,
+	.read		= seq_read,
+	.write		= proc_write_dbg,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static ssize_t proc_write_tc_switch(struct file *file, const char __user *buf,
+			size_t count, loff_t *data)
+{
+	char str[32];
+	int len, rlen;
+	int num, epid;
+	char *param_list[20];
+	struct tc_priv *priv;
+
+	priv = (struct tc_priv *)PDE_DATA(file_inode(file));
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = vrx_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+	if (vrx_strcmpi(param_list[0], "unload") == 0) {
+		epid = vrx_atoi(param_list[1]);
+		if (epid < priv->ep_num) {
+			simu_tc_request(epid, TC_NONE_MODE);
+			/* tc_unload(priv, epid); */
+		} else {
+			pr_err("epid is not correct\n");
+			return count;
+		}
+	} else if (vrx_strcmpi(param_list[0], "load") == 0) {
+		if (priv->tc_stat != NO_TC) {
+			pr_err("TC Status is not correct\n");
+			return count;
+		}
+		epid = vrx_atoi(param_list[2]);
+		if (epid > priv->ep_num - 1) {
+			pr_err("id is not correct\n");
+			return count;
+		}
+		if (vrx_strcmpi(param_list[1], "atm") == 0)
+			simu_tc_request(epid, TC_ATM_SL_MODE);
+		else if (vrx_strcmpi(param_list[1], "ptm") == 0)
+			simu_tc_request(epid, TC_PTM_SL_MODE);
+		else if (vrx_strcmpi(param_list[1], "bond") == 0)
+			simu_tc_request(epid, TC_PTM_BND_MODE);
+		else {
+			pr_err("mode is not correct\n");
+			goto proc_tc_switch_help;
+		}
+	} else
+		goto proc_tc_switch_help;
+
+	return count;
+
+proc_tc_switch_help:
+	pr_info("echo load atm/ptm/bond [epid] > tc_switch\n");
+	pr_info("echo unload [epid] > tc_switch\n");
+	return count;
+}
+
+static const struct file_operations tc_switch_proc_fops = {
+	.owner      = THIS_MODULE,
+	.write      = proc_write_tc_switch,
+	.llseek     = noop_llseek,
+};
+static ssize_t proc_write_show_time(struct file *file, const char __user *buf,
+			size_t count, loff_t *data)
+{
+	char str[32];
+	int len, rlen;
+	int num, epid;
+	char *param_list[20];
+	struct tc_priv *priv;
+
+	priv = (struct tc_priv *)PDE_DATA(file_inode(file));
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = vrx_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+	if (vrx_strcmpi(param_list[1], "yes") == 0) {
+		epid = vrx_atoi(param_list[0]);
+		if (epid >= ARRAY_SIZE(priv->showtime)) {
+			pr_err("epid is not correct\n");
+			return count;
+		}
+		priv->showtime[epid] = 1;
+		if (num > 2) {
+			struct port_cell_info cell_info;
+			unsigned int atm_rate;
+			atm_rate = vrx_atoi(param_list[2]);
+			cell_info.port_num = 1; /* only one ATM port */
+			cell_info.tx_link_rate[0] = atm_rate;
+			cell_info.tx_link_rate[1] = atm_rate;
+			priv->tc_ops.showtime_enter(epid, &cell_info, NULL);
+		} else
+			priv->tc_ops.showtime_enter(epid, NULL, NULL);
+	} else if (vrx_strcmpi(param_list[1], "no") == 0) {
+		epid = vrx_atoi(param_list[0]);
+		if (epid > 1) {
+			pr_err("epid is not correct\n");
+			return count;
+		}
+		priv->showtime[epid] = 0;
+		priv->tc_ops.showtime_exit(epid);
+	} else {
+		goto proc_show_time_help;
+	}
+
+	return count;
+
+proc_show_time_help:
+	pr_info("echo [epid] yes/no > showtime\n");
+	return count;
+}
+
+static const struct file_operations tc_show_time_proc_fops = {
+	.owner      = THIS_MODULE,
+	.write      = proc_write_show_time,
+	.llseek     = noop_llseek,
+};
+
+static int proc_read_ver(struct seq_file *seq, void *v)
+{
+	const char *drv_name, *drv_ver;
+	struct tc_priv *tcpriv;
+	u32 date;
+
+	tcpriv = (struct tc_priv *)seq->private;
+	tc_get_drv_version(&drv_name, &drv_ver);
+	seq_printf(seq, "%s: Version: %s\n", drv_name, drv_ver);
+
+	seq_printf(seq, "PTM FW ver: %d.%d.%d(0x%02x%02x%02x)\n",
+		tcpriv->fw.fw_hdr.ptm_ver.major,
+		tcpriv->fw.fw_hdr.ptm_ver.mid,
+		tcpriv->fw.fw_hdr.ptm_ver.minor,
+		tcpriv->fw.fw_hdr.ptm_ver.major,
+		tcpriv->fw.fw_hdr.ptm_ver.mid,
+		tcpriv->fw.fw_hdr.ptm_ver.minor);
+
+	seq_printf(seq, "ATM FW ver: %d.%d.%d(0x%02x%02x%02x)\n",
+		tcpriv->fw.fw_hdr.atm_ver.major,
+		tcpriv->fw.fw_hdr.atm_ver.mid,
+		tcpriv->fw.fw_hdr.atm_ver.minor,
+		tcpriv->fw.fw_hdr.atm_ver.major,
+		tcpriv->fw.fw_hdr.atm_ver.mid,
+		tcpriv->fw.fw_hdr.atm_ver.minor);
+
+	date = tcpriv->fw.fw_hdr.date;
+	seq_printf(seq, "compatible id: %d\n",
+		tcpriv->fw.fw_hdr.comp_id);
+	seq_printf(seq, "FW buit date(MM/DD/YYYY): %d/%d/%d\n",
+		(date >> 24) & 0xff,
+		(date >> 16) & 0xff,
+		(date & 0xffff));
+
+	return 0;
+}
+
+static int proc_read_ver_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_ver, PDE_DATA(inode));
+}
+
+static const struct file_operations tc_ver_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_ver_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int proc_read_soc(struct seq_file *seq, void *v)
+{
+	struct tc_priv *tcpriv;
+
+	tcpriv = (struct tc_priv *)seq->private;
+
+	seq_printf(seq, "TXIN Base: 0x%08x, TXIN num: %d\n",
+			tcpriv->cfg.txin_dbase,
+			tcpriv->cfg.txin_dnum);
+	seq_printf(seq, "TXOUT Base: 0x%08x, TXOUT num: %d\n",
+			tcpriv->cfg.txout_dbase,
+			tcpriv->cfg.txout_dnum);
+	seq_printf(seq, "RXIN Base: 0x%08x, RXIN num: %d\n",
+			tcpriv->cfg.rxin_dbase,
+			tcpriv->cfg.rxin_dnum);
+	seq_printf(seq, "RXOUT Base: 0x%08x, RXOUT num: %d\n",
+			tcpriv->cfg.rxout_dbase,
+			tcpriv->cfg.rxout_dnum);
+
+	return 0;
+}
+
+static int proc_read_soc_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_soc, PDE_DATA(inode));
+}
+
+static const struct file_operations tc_soc_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_soc_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+
+static struct tc_proc_list tc_procs[] = {
+	{TC_PROC_DIR,	0,	NULL,			1},
+	{"cfg",		0644, &tc_cfg_proc_fops,	0},
+	{"dbg",		0644, &tc_dbg_proc_fops,	0},
+	{"tc_switch",	0200, &tc_switch_proc_fops,	0},
+	{"showtime",	0200, &tc_show_time_proc_fops,	0},
+	{"ver",		0644, &tc_ver_proc_fops,	0},
+	{"soc",		0644, &tc_soc_proc_fops,	0},
+};
+
+int tc_proc_init(struct tc_priv *priv)
+{
+	int i;
+	struct proc_dir_entry *entry = NULL;
+	struct proc_dir_entry *tc_dir = NULL;
+	struct tc_proc_list *p;
+
+	for (i = 0; i < ARRAY_SIZE(tc_procs); i++) {
+		p = &tc_procs[i];
+		if (p->is_folder) {
+			tc_dir = proc_mkdir(p->proc_name, NULL);
+			if (!tc_dir)
+				return -ENOMEM;
+		} else {
+			entry = proc_create_data(p->proc_name, p->mode,
+					tc_dir, p->fops, (void *)priv);
+			if (!entry)
+				goto err;
+		}
+	}
+	priv->proc_dir = tc_dir;
+
+	return 0;
+
+err:
+	for (i = i - 1; i >= 0; i--) {
+		p = &tc_procs[i];
+		if (!p->is_folder)
+			remove_proc_entry(p->proc_name, tc_dir);
+		else
+			remove_proc_entry(p->proc_name, NULL);
+	}
+
+	return -ENOMEM;
+}
+
+void tc_proc_exit(struct tc_priv *priv)
+{
+	int i;
+	struct tc_proc_list *p;
+
+	for (i = ARRAY_SIZE(tc_procs) - 1; i >= 0; i--) {
+		p = &tc_procs[i];
+		if (!p->is_folder)
+			remove_proc_entry(p->proc_name, priv->proc_dir);
+		else
+			remove_proc_entry(p->proc_name, NULL);
+	}
+}
+
+static int proc_read_ptm_wanmib_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_ptm_wanmib, PDE_DATA(inode));
+}
+
+static const struct file_operations ptm_wanmib_proc_fops = {
+	.owner      = THIS_MODULE,
+	.open       = proc_read_ptm_wanmib_seq_open,
+	.read       = seq_read,
+	.write      = proc_write_ptm_wanmib,
+	.llseek     = seq_lseek,
+	.release    = single_release,
+};
+
+static int proc_ptm_read_cfg(struct seq_file *seq, void *v)
+{
+	struct ptm_ep_priv *priv = (struct ptm_ep_priv *)seq->private;
+	struct ptm_priv *ptm_tc = (struct ptm_priv *)priv->tc_priv->priv;
+
+	if (!priv || !ptm_tc) {
+		pr_err("%s: Invalid private data\n", __func__);
+		return -EINVAL;
+	}
+
+	seq_printf(seq, "PTM mode: %s\n",
+		(ptm_tc->tc_priv->tc_mode == TC_PTM_BND_MODE) ?
+		"PTM Bonding mode" : "PTM Single Line mode");
+	if (priv->tc_priv->tc_mode != TC_PTM_BND_MODE)
+		seq_printf(seq, "VRX518 on line: %d\n", priv->ep_id);
+
+	seq_printf(seq, "Showtime: %d\n", priv->tc_priv->showtime[priv->ep_id]);
+	seq_printf(seq, "Power Saving: %s\n",
+		ptm_power_saving(priv, 0, 0) == 1 ? "Enable" : "Disable");
+	seq_printf(seq, "irq: %d\n", priv->ep->irq);
+	seq_printf(seq, "membase: 0x%x\n", (u32)priv->ep->membase);
+	print_ppe_clk(seq, priv->ep);
+
+	return 0;
+}
+
+static int proc_read_cfg_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_ptm_read_cfg, PDE_DATA(inode));
+}
+
+static ssize_t ptm_cfg_proc_write(struct file *file,
+			const char __user *buf, size_t count, loff_t *data)
+{
+	struct ptm_ep_priv *priv;
+	u32 en, clk;
+	int num, len, rlen, i;
+	char *param_list[32];
+	char str[128];
+	const int clk_list[] = {36, 576, 494, 432, 288};
+
+	priv = (struct ptm_ep_priv *)PDE_DATA(file_inode(file));
+	if (priv == NULL) {
+		pr_err("%s: Invalid private data\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = vrx_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+
+	en = clk = 0;
+	if (vrx_strcmpi(param_list[0], "en") == 0
+		|| vrx_strcmpi(param_list[0], "enable") == 0) {
+		en = 1;
+	} else if (vrx_strcmpi(param_list[0], "dis") == 0
+		|| vrx_strcmpi(param_list[0], "disable") == 0) {
+		en = 0;
+	} else if (vrx_strcmpi(param_list[0], "clk") == 0
+		|| vrx_strcmpi(param_list[0], "clock") == 0) {
+		clk = 1;
+	} else
+		goto proc_ptm_cfg_help;
+
+	if (vrx_strcmpi(param_list[1], "ps") == 0
+		|| vrx_strcmpi(param_list[1], "powersaving") == 0) {
+		ptm_power_saving(priv, en, 1);
+	} else if (clk == 1) {
+		clk = vrx_atoi(param_list[1]);
+		for (i = 1; i < ARRAY_SIZE(clk_list); i++)
+			if (clk == clk_list[i])
+				break;
+		if (i >= ARRAY_SIZE(clk_list))
+			goto proc_ptm_cfg_help;
+		tc_ppe_clkset(priv->ep, i);
+	}
+
+	return count;
+
+proc_ptm_cfg_help:
+	pr_info("echo [enable | disable] powersaving > cfg\n");
+	pr_info("echo clk <576 | 494 | 432 | 288> > cfg\n");
+	return count;
+}
+
+
+static const struct file_operations ptm_cfg_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = proc_read_cfg_seq_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.write = ptm_cfg_proc_write,
+	.release = single_release,
+};
+
+static ssize_t proc_ptm_write_prio(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+	struct ptm_ep_priv *priv;
+	struct ptm_priv *ptm_tc;
+	char local_buf[256];
+	int len;
+	char *p1;
+	int prio = -1;
+	int queue = -1;
+	int preempt = -1;
+	int num;
+	int i;
+	char *param_list[20];
+
+	len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+	len = len - copy_from_user(local_buf, buf, len);
+	local_buf[len] = 0;
+	p1 = local_buf;
+
+	num = vrx_split_buffer(local_buf, param_list, ARRAY_SIZE(param_list));
+	priv = (struct ptm_ep_priv *)PDE_DATA(file_inode(file));
+
+	if (priv == NULL) {
+		pr_err("%s: Invalid private data\n", __func__);
+		return -EINVAL;
+	}
+	ptm_tc = (struct ptm_priv *)priv->ptm_tc;
+
+	if (vrx_strcmpi(param_list[0], "help") == 0)
+		goto proc_ptm_prio_help;
+	else {
+		for (i = 0; i < num; i += 6) {
+			if ((vrx_strcmpi(param_list[i], "prio") == 0)
+				|| (vrx_strcmpi(param_list[i], "p") == 0))
+				prio = vrx_atoi(param_list[i+1]);
+			else
+				pr_err("Error: expecting prio\n");
+
+			if ((vrx_strcmpi(param_list[i+2], "queue") == 0) ||
+				(vrx_strcmpi(param_list[i+2], "q") == 0))
+				queue = vrx_atoi(param_list[i+3]);
+			else
+				pr_err("Error: expecting queue\n");
+
+			if ((vrx_strcmpi(param_list[i+4], "pre") == 0) ||
+				(vrx_strcmpi(param_list[i+4], "r") == 0))
+				preempt = vrx_atoi(param_list[i+5]);
+			else
+				pr_err("Error: expecting preemption\n");
+			if (queue < 0 || queue >= PTM_PRIO_Q_NUM
+				|| prio < 0 || prio >= PTM_PRIO_Q_NUM
+				|| preempt < 0 || preempt >= OUTQ_PNUM) {
+				pr_err("%s: invalid parameter: prio: %d, queue: %d, preemption: %d\n",
+					__func__, prio, queue, preempt);
+				goto proc_ptm_prio_help;
+			} else {
+				pr_info("prio: %d, queue: %d, preemption:%d\n",
+					prio, queue, preempt);
+				ptm_tc->prio_q_map[prio] = queue;
+				ptm_set_q_preempt(priv, queue, preempt);
+			}
+		}
+	}
+	return count;
+
+proc_ptm_prio_help:
+	pr_info("echo prio xx queue xx pre xx [prio xx queue xx pre xx] > prio\n");
+	return count;
+}
+
+static int proc_ptm_read_prio(struct seq_file *seq, void *v)
+{
+	int i;
+	struct ptm_ep_priv *priv = (struct ptm_ep_priv *)seq->private;
+	struct ptm_priv *ptm_tc = priv->ptm_tc;
+
+	seq_puts(seq, "Prio:\t\t");
+	for (i = 0; i < PTM_PRIO_Q_NUM; i++)
+		seq_printf(seq, "%d ", i);
+	seq_puts(seq, "\nQid:\t\t");
+	for (i = 0; i < PTM_PRIO_Q_NUM; i++)
+		seq_printf(seq, "%d ",
+			ptm_tc->prio_q_map[i]);
+	seq_puts(seq, "\n");
+
+	seq_puts(seq, "VRX518: 1:Preemption / 0: Non-Preemption\n");
+	seq_puts(seq, "Preemption:\t");
+	for (i = 0; i < PTM_PRIO_Q_NUM; i++)
+		seq_printf(seq, "%d ", ptm_get_q_preempt(priv, i));
+	seq_puts(seq, "\n");
+
+	return 0;
+}
+
+static int proc_ptm_read_prio_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_ptm_read_prio, PDE_DATA(inode));
+}
+
+static const struct file_operations ptm_prio_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_ptm_read_prio_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.write		= proc_ptm_write_prio,
+	.release	= single_release,
+};
+
+static int proc_ptm_read_bond_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_ptm_read_bond, PDE_DATA(inode));
+}
+
+static const struct file_operations ptm_bond_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_ptm_read_bond_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int proc_ptm_read_bondmib_seq_open(struct inode *inode,
+							struct file *file)
+{
+	return single_open(file, proc_ptm_read_bondmib, PDE_DATA(inode));
+}
+
+static const struct file_operations ptm_bondmib_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_ptm_read_bondmib_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.write		= proc_ptm_write_bondmib,
+	.release	= single_release,
+};
+
+struct fwdbg_t {
+	char *cmd;
+	void (*pfunc)(struct tc_comm *priv,
+			char *tokens[], int token_num, char *result);
+	void (*pfunc_help)(char *result);
+};
+
+static void fwdbg_print_codeword(struct tc_comm *priv,
+	char *result,
+	unsigned int sb_addr,
+	unsigned int len)
+{
+	int i = 0;
+	for (i = 0; i < len; i++) {
+		if (i % 4 == 0) {
+			sprintf(result + strlen(result),
+				"\n\t");
+		}
+		sprintf(result + strlen(result),
+			" %08x",
+			sb_r32(sb_addr + i));
+	}
+	sprintf(result + strlen(result),
+					"\n");
+}
+static void fwdbg_read_tx_cb(struct tc_comm *priv,
+	char *tokens[], int token_num, char *result)
+{
+	unsigned int start_pg;
+	unsigned int print_pg_num;
+	unsigned int num;
+	int codeword = 0;
+	struct tc_priv *tcpriv;
+
+	codeword = vrx_atoi(tokens[1]);
+	tcpriv = priv->tc_priv;
+	if (codeword >= 0 && codeword < 2) {
+		unsigned int dbase0;
+		unsigned int pnum0, i;
+		unsigned int cw;
+		struct ffsm_dba dba;
+		struct ffsm_cfg cfg;
+
+		tc_mem_read(priv, &dba,
+			FFSM_DBA(codeword), sizeof(struct ffsm_dba));
+		dbase0 = dba.dbase + 0x2000;
+		tc_mem_read(priv, &cfg,
+			FFSM_CFG(codeword), sizeof(struct ffsm_cfg));
+		pnum0 = cfg.pnum;
+
+
+		start_pg = 0;
+		print_pg_num = pnum0;
+		if (token_num >= 2)
+			start_pg =  vrx_atoi(tokens[2]);
+		if (token_num >= 3)
+			print_pg_num =  vrx_atoi(tokens[3]);
+
+		start_pg = start_pg % pnum0;
+		if (print_pg_num > pnum0)
+			print_pg_num = pnum0;
+		sprintf(result + strlen(result),
+			"%s TX BC 0 CELL data/ctrl buffer:\n",
+			tcpriv->tc_mode == TC_ATM_SL_MODE ? "ATM" : "PTM"
+			);
+
+		for (i = start_pg, num = 0;
+			num < print_pg_num;
+			num ++, i = (i + 1) % pnum0) {
+			cw = dbase0 + i * CW_PAGE_SIZE;
+			fwdbg_print_codeword(priv,
+				result,
+				cw,
+				17);
+			pr_info("%s", result);
+			memset(result, 0, strlen(result) + 1);
+		}
+	}
+}
+static void fwdbg_read_tx_cb_help(char *result)
+{
+	sprintf(result + strlen(result),
+		"echo read_tx_cb [0|1] [start_pg] [print_pg_num]\n");
+	sprintf(result + strlen(result),
+		"\tread tx bare channel 0 & 1\n");
+	sprintf(result + strlen(result),
+		"\tcell/codeword buffer for bc0 or bc1\n");
+}
+
+static void fwdbg_read_rx_cb(struct tc_comm *priv,
+		char *tokens[], int token_num, char *result)
+{
+	unsigned int start_pg;
+	unsigned int print_pg_num;
+	unsigned int num;
+	int codeword = 0;
+	struct tc_priv *tcpriv;
+	codeword = vrx_atoi(tokens[1]);
+	tcpriv = priv->tc_priv;
+	if (codeword >= 0 && codeword < 2) {
+		unsigned int dbase0, cbase0;
+		unsigned int pnum0, i;
+		unsigned int cw;
+		struct sfsm_dba dba;
+		struct sfsm_cba cba;
+		struct sfsm_cfg cfg;
+
+		tc_mem_read(priv, &dba,
+			SFSM_DBA(codeword), sizeof(struct sfsm_dba));
+		dbase0 = dba.dbase + 0x2000;
+		tc_mem_read(priv, &cba,
+			SFSM_CBA(codeword), sizeof(struct sfsm_cba));
+		cbase0 = cba.cbase + 0x2000;
+		tc_mem_read(priv, &cfg,
+			SFSM_CFG(codeword), sizeof(struct sfsm_cfg));
+		pnum0 = cfg.pnum;
+
+		start_pg = 0;
+		print_pg_num = pnum0;
+
+		if (token_num >= 2)
+			start_pg =  vrx_atoi(tokens[2]);
+		if (token_num >= 3)
+			print_pg_num =  vrx_atoi(tokens[3]);
+
+		start_pg = start_pg % pnum0;
+		if (print_pg_num > pnum0)
+			print_pg_num = pnum0;
+
+		sprintf(result + strlen(result),
+			"%s RX BC %d CELL data/ctrl buffer (pnum0 = %d):\n",
+			tcpriv->tc_mode == TC_ATM_SL_MODE ? "ATM" : "PTM",
+			codeword, pnum0);
+		for (i = start_pg, num = 0;
+				num < print_pg_num;
+				num ++, i = (i + 1) % pnum0) {
+			if (tcpriv->tc_mode == TC_ATM_SL_MODE) {
+				struct atm_cw_ctrl_t ctrl;
+				cw = dbase0 + i * CW_PAGE_SIZE;
+				tc_mem_read(priv, &ctrl,
+					fpi_addr(cbase0 + i),
+					sizeof(struct atm_cw_ctrl_t));
+
+				sprintf(result + strlen(result),
+					"cvm=%1x cvc=%03x bsm=%01x",
+					ctrl.cvm, ctrl.cvc, ctrl.bsm);
+				sprintf(result + strlen(result),
+					" csp=%03x idle=%01x drop=%01x",
+					ctrl.csp, ctrl.idle,
+					ctrl.drop);
+				sprintf(result + strlen(result),
+					"ber=%03x bad=%03x state=%01x",
+					ctrl.ber, ctrl.bad,
+					ctrl.state);
+				fwdbg_print_codeword(priv,
+					result, cw, 17);
+			} else {
+				struct ptm_cw_ctrl_t ctrl;
+				char *cwid_txt[8] = {
+				"All_data",
+				"End_of_frame",
+				"Start_while_tx",
+				"All_idle",
+				"Start_while_idle",
+				"All_idle_nosync",
+				"Error",
+				"Res"
+				};
+				cw = dbase0 + i * CW_PAGE_SIZE;
+				tc_mem_read(priv, &ctrl,
+					fpi_addr(cbase0 + i),
+					sizeof(struct ptm_cw_ctrl_t));
+				sprintf(result + strlen(result),
+					"cwid=%02x[%-16s] cwer=%02x",
+					ctrl.cwid, cwid_txt[ctrl.cwid],
+					ctrl.cwer);
+				sprintf(result + strlen(result),
+					"  preempt=%01x shrt=%01x ffbn=%03x",
+					ctrl.preempt, ctrl.shrt,
+					ctrl.ffbn);
+				sprintf(result + strlen(result),
+					" spos=%02x ber=%03x\n",
+					ctrl.spos,
+					ctrl.ber);
+				sprintf(result + strlen(result),
+					" bad=%03x state=%01x",
+					ctrl.bad, ctrl.state);
+				fwdbg_print_codeword(priv,
+					result, cw, 17);
+			}
+			pr_info("%s", result);
+			memset(result, 0, strlen(result) + 1);
+		}
+	}
+}
+static void fwdbg_read_rx_cb_help(char *result)
+{
+	sprintf(result + strlen(result),
+		"echo read_rx_cb [0|1] [start_pg] [print_pg_num]\n");
+	sprintf(result + strlen(result),
+		"\tread rx bare channel 0 & 1\n");
+	sprintf(result + strlen(result),
+		"\tcell/codeword buffer for bc0 or bc1\n");
+}
+
+static void fwdbg_clear_tx_cb(struct tc_comm *priv,
+	char *tokens[], int token_num, char *result)
+{
+	unsigned int start_pg;
+	unsigned int clear_pg_num;
+	int codeword;
+	codeword = vrx_atoi(tokens[1]);
+	if (codeword >= 0 && codeword < 2) {
+		unsigned int dbase0;
+		unsigned int pnum0;
+		struct ffsm_dba dba;
+		struct ffsm_cfg cfg;
+
+		tc_mem_read(priv, &dba,
+			FFSM_DBA(codeword), sizeof(struct ffsm_dba));
+		dbase0 = dba.dbase + 0x2000;
+		tc_mem_read(priv, &cfg,
+			FFSM_CFG(codeword), sizeof(struct ffsm_cfg));
+		pnum0 = cfg.pnum;
+
+		start_pg = 0;
+		clear_pg_num = pnum0;
+
+		if (token_num >= 2)
+			start_pg =  vrx_atoi(tokens[2]);
+		if (token_num >= 3)
+			clear_pg_num =  vrx_atoi(tokens[3]);
+
+		start_pg = start_pg % pnum0;
+		if (clear_pg_num > pnum0)
+			clear_pg_num = pnum0;
+
+		dbase0 = fpi_addr(dbase0 + start_pg * CW_PAGE_SIZE);
+		tc_memset(priv, dbase0, 0,
+			CW_PAGE_SIZE * sizeof(unsigned int) * clear_pg_num);
+	}
+}
+
+static void fwdbg_clear_tx_cb_help(char *result)
+{
+	sprintf(result + strlen(result),
+		"echo clear_tx_cb [0|1] [start_pg] [clear_pg_num]\n");
+	sprintf(result + strlen(result),
+		"\tclear tx bare channel 0 & 1\n");
+	sprintf(result + strlen(result),
+		"\tcell/codeword buffer for bc0 or bc1\n");
+}
+
+static void fwdbg_clear_rx_cb(struct tc_comm *priv,
+	char *tokens[], int token_num, char *result)
+{
+	unsigned int start_pg;
+	unsigned int clear_pg_num;
+	int codeword;
+	codeword = vrx_atoi(tokens[1]);
+	if (codeword >= 0 && codeword < 2) {
+		unsigned int dbase0, cbase0;
+		unsigned int pnum0;
+		struct sfsm_dba dba;
+		struct sfsm_cba cba;
+		struct sfsm_cfg cfg;
+
+		tc_mem_read(priv, &dba,
+			SFSM_DBA(codeword), sizeof(struct sfsm_dba));
+		dbase0 = dba.dbase + 0x2000;
+		tc_mem_read(priv, &cba,
+			SFSM_CBA(codeword), sizeof(struct sfsm_cba));
+		cbase0 = cba.cbase + 0x2000;
+		tc_mem_read(priv, &cfg,
+			SFSM_CFG(codeword), sizeof(struct sfsm_cfg));
+		pnum0 = cfg.pnum;
+		start_pg = 0;
+		clear_pg_num = pnum0;
+
+		if (token_num >= 2)
+			start_pg =  vrx_atoi(tokens[2]);
+		if (token_num >= 3)
+			clear_pg_num =  vrx_atoi(tokens[3]);
+
+		start_pg = start_pg % pnum0;
+		if (clear_pg_num > pnum0)
+			clear_pg_num = pnum0;
+
+		dbase0 = fpi_addr(dbase0 + start_pg * CW_PAGE_SIZE);
+		cbase0 = fpi_addr(cbase0 + start_pg);
+		tc_memset(priv, dbase0, 0,
+			CW_PAGE_SIZE * sizeof(unsigned int) * clear_pg_num);
+		tc_memset(priv, cbase0, 0,
+			sizeof(unsigned int) * clear_pg_num);
+	}
+}
+static void fwdbg_clear_rx_cb_help(char *result)
+{
+	sprintf(result + strlen(result),
+		"echo clear_rx_cb [0|1] [start_pg] [clear_pg_num]\n");
+	sprintf(result + strlen(result),
+		"\tclear rx bare channel 0 & 1\n");
+	sprintf(result + strlen(result),
+		"\tcell/codeword buffer for bc0 or bc1\n");
+}
+static void fwdbg_help(struct tc_comm *priv,
+		char *tokens[], int token_num, char *result);
+struct fwdbg_t cmds[] = {
+	{"help\0", fwdbg_help, NULL},
+	{"read_tx_cb\0", fwdbg_read_tx_cb, fwdbg_read_tx_cb_help},
+	{"read_rx_cb\0", fwdbg_read_rx_cb, fwdbg_read_rx_cb_help},
+	{"clear_tx_cb\0", fwdbg_clear_tx_cb, fwdbg_clear_tx_cb_help},
+	{"clear_rx_cb\0", fwdbg_clear_rx_cb, fwdbg_clear_rx_cb_help},
+	{NULL, NULL, NULL}
+};
+static void fwdbg_help(struct tc_comm *priv,
+	char *tokens[], int token_num, char *result)
+{
+	const char *proc_file = "fwdbg";
+	int i;
+
+	/* print commands only */
+	if (!token_num) {
+		for (i = 0; cmds[i].cmd != NULL; i++) {
+			sprintf(result + strlen(result)
+				, "%s\t", cmds[i].cmd);
+			if (i % 3 == 0)
+				sprintf(result + strlen(result),
+					"\n");
+		}
+
+		sprintf(result + strlen(result),
+			"\n\n");
+		sprintf(result + strlen(result),
+			"echo help [cmd] > %s for details\n",
+			proc_file);
+		return;
+	}
+	if (!tokens)
+		return;
+	for (i = 0; cmds[i].cmd != NULL; i++) {
+		if (vrx_strcmpi(tokens[1], cmds[i].cmd) == 0)
+			if (cmds[i].pfunc_help) {
+				cmds[i].pfunc_help(result);
+				break;
+			}
+	}
+	if (!cmds[i].cmd)
+		fwdbg_help(priv, NULL, 0, result);
+}
+int fw_dbg_start(struct tc_comm *priv,
+	char *commands[], int num, char *result)
+{
+	int i;
+
+	if (!priv || !commands || !result) {
+		pr_err("<%s>: Invalid arguments\n", __func__);
+		return -1;
+	}
+	for (i = 0; cmds[i].cmd != NULL; i++) {
+		if (vrx_strcmpi(commands[0], cmds[i].cmd) == 0) {
+			cmds[i].pfunc(priv, commands, num - 1, result);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+ssize_t proc_write_fwdbg_seq(
+	struct file *file,
+	const char __user *buf,
+	size_t count,
+	loff_t *data
+	)
+	{
+	char results[512];
+	char local_buf[128];
+	int len;
+	char *param_list[20];
+	int num;
+	struct tc_comm *priv;
+
+	len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+	len = len - copy_from_user(local_buf, buf, len);
+	local_buf[len] = 0;
+
+	num = vrx_split_buffer(local_buf, param_list,
+		ARRAY_SIZE(param_list));
+	priv =  (struct tc_comm *)PDE_DATA(file_inode(file));
+	if (priv == NULL) {
+		pr_err("<%s>: Invalid private data\n", __func__);
+		return count;
+	}
+	memset(results, 0, 512);
+	/* execute user's command */
+	if (fw_dbg_start(priv, param_list, num, results) != 0)
+		goto proc_fwdbg_help;
+	/* print out result */
+	pr_info("%s", results);
+	return count;
+proc_fwdbg_help:
+	pr_info("echo help > fwdbg\n");
+	return count;
+}
+
+static int proc_read_fwdbg(struct seq_file *seq, void *v)
+{
+	return 0;
+}
+
+static int proc_read_fwdbg_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_fwdbg, NULL);
+}
+static const struct file_operations fwdbg_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_fwdbg_seq_open,
+	.read		= seq_read,
+	.write		= proc_write_fwdbg_seq,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+static struct tc_proc_list ptm_sl_procs[] = {
+	{TC_PROC_PTM_DIR, 0,	NULL,			1},
+	{"mem",		0644,	&mem_proc_fops,		0},
+	{"pp32",	0644,	&pp32_proc_fops,	0},
+	{"wanmib",	0644,	&ptm_wanmib_proc_fops,	0},
+	{"cfg",		0644,	&ptm_cfg_proc_fops,	0},
+	{"prio",	0644,	&ptm_prio_proc_fops,	0},
+	{"fwdbg",	0644,	&fwdbg_proc_fops,	0},
+};
+
+static struct tc_proc_list ptm_bond_procs[] = {
+	{"bonding",	0644,	&ptm_bond_proc_fops,	0},
+	{"bondmib",	0644,	&ptm_bondmib_proc_fops,	0},
+};
+
+
+
+
+int ptm_tc_proc_init(void *ptm_priv)
+{
+	struct proc_dir_entry *entry;
+	struct proc_dir_entry *tc_dir = NULL;
+	struct ptm_ep_priv *priv;
+	struct tc_proc_list *p;
+	char proc_name[64];
+	int i, j;
+
+	priv = (struct ptm_ep_priv *)ptm_priv;
+	for (i = 0; i < ARRAY_SIZE(ptm_sl_procs); i++) {
+		p = &ptm_sl_procs[i];
+		if (p->is_folder) {
+			sprintf(proc_name, "%s%d", p->proc_name, priv->ep_id);
+			tc_dir = proc_mkdir(proc_name, priv->tc_priv->proc_dir);
+			if (!tc_dir)
+				return -ENOMEM;
+		} else {
+			entry = proc_create_data(p->proc_name, p->mode,
+					tc_dir, p->fops, (void *)priv);
+			if (!entry)
+				goto sl_proc_err;
+		}
+	}
+
+	if (priv->tc_priv->tc_mode == TC_PTM_BND_MODE)
+		for (j = 0; j < ARRAY_SIZE(ptm_bond_procs); j++) {
+			p = &ptm_bond_procs[j];
+			entry = proc_create_data(p->proc_name, p->mode,
+					tc_dir, p->fops, (void *)priv);
+			if (!entry)
+				goto bond_proc_err;
+		}
+
+	priv->proc_dir = tc_dir;
+
+	return 0;
+
+bond_proc_err:
+	for (j = j - 1; j >= 0; j--) {
+		p = &ptm_bond_procs[j];
+		if (!p->is_folder)
+			remove_proc_entry(p->proc_name, tc_dir);
+		else
+			remove_proc_entry(p->proc_name, NULL);
+	}
+sl_proc_err:
+	for (i = i - 1; i >= 0; i--) {
+		p = &ptm_sl_procs[i];
+		if (!p->is_folder)
+			remove_proc_entry(p->proc_name, tc_dir);
+		else {
+			sprintf(proc_name, "%s%d", p->proc_name, priv->ep_id);
+			remove_proc_entry(proc_name, priv->tc_priv->proc_dir);
+		}
+	}
+	return -ENOMEM;
+}
+
+void ptm_tc_proc_exit(void *ptm_priv)
+{
+	struct ptm_ep_priv *priv = (struct ptm_ep_priv *)ptm_priv;
+	struct tc_proc_list *p;
+	char proc_name[64];
+	int i;
+
+	if (priv == NULL) {
+		pr_err("%s: Invalid private data\n", __func__);
+		return;
+	}
+
+	if (priv->tc_priv->tc_mode == TC_PTM_BND_MODE) {
+		for (i = ARRAY_SIZE(ptm_bond_procs) - 1; i >= 0; i--) {
+			p = &ptm_bond_procs[i];
+			if (!p->is_folder)
+				remove_proc_entry(p->proc_name, priv->proc_dir);
+			else
+				remove_proc_entry(p->proc_name, NULL);
+		}
+	}
+
+	for (i = ARRAY_SIZE(ptm_sl_procs) - 1; i >= 0; i--) {
+		p = &ptm_sl_procs[i];
+		if (!p->is_folder)
+			remove_proc_entry(p->proc_name, priv->proc_dir);
+		else {
+			sprintf(proc_name, "%s%d", p->proc_name, priv->ep_id);
+			remove_proc_entry(proc_name, priv->tc_priv->proc_dir);
+		}
+	}
+}
+
+/* ATM Proc functions */
+static int proc_read_atm_cfg(struct seq_file *seq, void *v)
+{
+	int i;
+	struct atm_priv *priv = (struct atm_priv *)seq->private;
+	if (priv == NULL) {
+		pr_err("%s: invalid private data\n", __func__);
+		return -EINVAL;
+	}
+	spin_lock_bh(&priv->atm_lock);
+	/* ATM'PVC list*/
+	seq_puts(seq, "PVC List:\n");
+	seq_printf(seq, "PVC MAP: 0x%x\n", priv->pvc_tbl);
+	seq_printf(seq, "TX Queue Map: 0x%x\n", priv->sw_txq_tbl);
+
+	for (i = 0; i < ATM_PVC_NUMBER; i++) {
+		if ((priv->pvc_tbl & BIT(i)) == 0)
+			continue;
+		seq_printf(seq, "[%d]: VPI: %d, VCI: %d, dev: %s, MPoA type: %d, MPoA mode: %d, Subif_id: 0x%x, Tx Queue Table: 0x%x\n",
+			i, priv->conn[i].vcc->vpi, priv->conn[i].vcc->vci,
+			priv->conn[i].dev->name, priv->conn[i].mpoa_type,
+			priv->conn[i].mpoa_mode, priv->conn[i].subif_id,
+			priv->conn[i].sw_txq_tbl);
+	}
+	spin_unlock_bh(&priv->atm_lock);
+
+	return 0;
+}
+
+static int proc_read_atm_cfg_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_atm_cfg, PDE_DATA(inode));
+}
+
+static ssize_t atm_cfg_proc_write(struct file *file,
+		const char __user *buf,	size_t count, loff_t *data)
+{
+	struct atm_priv *priv;
+	u32 en;
+	int num, len, rlen;
+	char *param_list[32];
+	char str[128];
+
+	priv = (struct atm_priv *)PDE_DATA(file_inode(file));
+
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = vrx_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+
+	if (vrx_strcmpi(param_list[0], "en") == 0
+		|| vrx_strcmpi(param_list[0], "enble") == 0) {
+		en = 1;
+	} else if (vrx_strcmpi(param_list[0], "dis") == 0
+		|| vrx_strcmpi(param_list[0], "disable") == 0) {
+		en = 0;
+	} else
+		goto proc_atm_cfg_help;
+
+	if (vrx_strcmpi(param_list[1], "ps") == 0
+		|| vrx_strcmpi(param_list[1], "powersaving") == 0) {
+		atm_power_saving(priv, en, 1);
+	}
+
+	return count;
+
+proc_atm_cfg_help:
+	pr_info("echo [enable | disable] powersaving > cfg\n");
+	return count;
+}
+
+static const struct file_operations atm_cfg_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_atm_cfg_seq_open,
+	.read		= seq_read,
+	.write		= atm_cfg_proc_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static ssize_t proc_write_atm_wanmib(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+	struct atm_priv *priv;
+	char str[32];
+	int len, rlen;
+	int num;
+	char *param_list[20];
+
+	priv = (struct atm_priv *)PDE_DATA(file_inode(file));
+	if (priv == NULL) {
+		pr_err("%s: Invalid private data\n", __func__);
+		return -EINVAL;
+	}
+	len = count < sizeof(str) ? count : sizeof(str) - 1;
+	rlen = len - copy_from_user(str, buf, len);
+	str[rlen] = 0;
+	num = vrx_split_buffer(str, param_list, ARRAY_SIZE(param_list));
+	if ((vrx_strcmpi(param_list[0], "clear") == 0)
+		|| (vrx_strcmpi(param_list[0], "clean") == 0)
+		|| (vrx_strcmpi(param_list[0], "c") == 0)) {
+		proc_clear_atm_wanmib(priv);
+	} else {
+		goto proc_atm_wanmib_help;
+	}
+
+	return count;
+
+proc_atm_wanmib_help:
+	pr_info("echo clear/clean/c > wanmib\n");
+return count;
+
+}
+
+static int proc_read_atm_wanmib_seq_open(struct inode *inode,
+	struct file *file)
+{
+	return single_open(file, proc_read_atm_wanmib, PDE_DATA(inode));
+}
+
+
+
+static const struct file_operations atm_wanmib_proc_fops = {
+	.owner      = THIS_MODULE,
+	.open       = proc_read_atm_wanmib_seq_open,
+	.read       = seq_read,
+	.write      = proc_write_atm_wanmib,
+	.llseek     = seq_lseek,
+	.release    = single_release,
+};
+
+static int proc_read_htu_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_htu, PDE_DATA(inode));
+}
+
+static const struct file_operations htu_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_htu_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int proc_read_queue_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_queue, PDE_DATA(inode));
+}
+
+static const struct file_operations queue_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_queue_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void set_q_prio(struct atm_priv *priv,
+	int conn, int prio, int queue)
+{
+	if (priv == NULL) {
+		pr_err("<%s>: Invalid private data\n", __func__);
+		return;
+	}
+	if (conn < 0 || conn >= ATM_PVC_NUMBER
+		|| prio < 0 || prio >= ATM_PRIO_Q_NUM) {
+		tc_err(priv->tc_priv, MSG_INIT,
+			"invalid parameter: conn: %d, prio: %d\n",
+			conn, prio);
+		return;
+	}
+
+	tc_dbg(priv->tc_priv, MSG_INIT,
+		"conn: %d, prio: %d, queue: %d\n", conn, prio, queue);
+	spin_lock_bh(&priv->atm_lock);
+	if (priv->conn[conn].sw_txq_tbl & BIT(queue))
+		priv->conn[conn].prio_queue_map[prio] = queue;
+	spin_unlock_bh(&priv->atm_lock);
+}
+
+static ssize_t proc_atm_write_prio(struct file *file, const char __user *buf,
+				size_t count, loff_t *data)
+{
+	struct atm_priv *priv;
+	char local_buf[256];
+	int len;
+	char *p1;
+	int conn = -1;
+	unsigned int vpi, vci;
+	int prio = -1;
+	int queue = -1;
+	int ret, num;
+	int i;
+	char *param_list[20];
+
+	len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+	len = len - copy_from_user(local_buf, buf, len);
+	local_buf[len] = 0;
+	p1 = local_buf;
+
+	num = vrx_split_buffer(local_buf, param_list, ARRAY_SIZE(param_list));
+	priv =  (struct atm_priv *)PDE_DATA(file_inode(file));
+	if (vrx_strcmpi(param_list[0], "help") == 0)
+		goto proc_atm_prio_help;
+	else if (vrx_strcmpi(param_list[0], "pvc") == 0) {
+		char *p2;
+		p1 += 4;
+		len -= 4;
+		p2 = param_list[1];
+
+		vpi = get_num_from_str(&p2, &len, 0);
+		vci = get_num_from_str(&p2, &len, 0);
+		conn = find_vpivci(vpi, vci);
+		tc_dbg(priv->tc_priv, MSG_INIT, "VCI[%d]VCI[%d]", vpi, vci);
+		if (!conn_valid(conn)) {
+			tc_err(priv->tc_priv,
+				MSG_INIT, "PVC(%d:%d) is invalid\n", vpi, vci);
+			return count;
+		}
+		if (vrx_strcmpi(param_list[2], "add") == 0) {
+			ret = sw_tx_queue_add(priv, conn);
+			if (ret < 0)
+				tc_err(priv->tc_priv, MSG_INIT,
+				"Failed in adding queue for PVC(%d:%d)\n",
+				vpi, vci);
+			else
+				tc_info(priv->tc_priv, MSG_INIT,
+				"Add queue for PVC(%d:%d) successfully\n",
+				vpi, vci);
+		} else if (vrx_strcmpi(param_list[2], "del") == 0
+			|| vrx_strcmpi(param_list[2], "rem") == 0) {
+			ret = sw_tx_queue_del(priv, conn);
+			if (ret < 0)
+				tc_err(priv->tc_priv, MSG_INIT,
+				"Failed in deleting queue for PVC(%d:%d)\n",
+				vpi, vci);
+			else
+				tc_info(priv->tc_priv, MSG_INIT,
+				"Delete queue for PVC(%d:%d) successfully\n",
+				vpi, vci);
+		} else {
+			prio = queue = -1;
+			for (i = 2; i < num; i += 4) {
+				if ((vrx_strcmpi(
+					param_list[i], "prio") == 0)
+					|| (vrx_strcmpi(
+						param_list[i], "p") == 0))
+					prio = vrx_atoi(param_list[i+1]);
+				else
+					tc_err(priv->tc_priv, MSG_INIT,
+					"Error: expecting prio\n");
+
+				if ((vrx_strcmpi(
+					param_list[i+2], "queue") == 0) ||
+					(vrx_strcmpi(
+					param_list[i+2], "q") == 0))
+					queue = vrx_atoi(param_list[i+3]);
+				else
+					tc_err(priv->tc_priv, MSG_INIT,
+						"Error: expecting queue\n");
+
+				if (prio >= 0 && queue >= 0)
+					set_q_prio(priv, conn, prio, queue);
+			}
+		}
+	} else
+		pr_info("Wrong format!, Please try echo help > prio\n");
+
+	return count;
+
+proc_atm_prio_help:
+	pr_info("echo pvc vpi.vci prio xx queue xx [prio xx queue xx] > prio\n");
+	pr_info("echo pvc vpi.vci <add/del> > prio\n");
+	return count;
+}
+
+static int proc_atm_read_prio(struct seq_file *seq, void *v)
+{
+	int i, j;
+	struct atm_priv *priv = (struct atm_priv *)seq->private;
+	struct atm_pvc *conn;
+
+	for (i = 0; i < ATM_PVC_NUMBER; i++) {
+		if (priv->pvc_tbl & BIT(i)) {
+			conn = &priv->conn[i];
+			seq_printf(seq, "PVC(%d:%d): Phy_Qid: ",
+				conn->vcc->vpi,
+				conn->vcc->vci);
+			for (j = 0; j < ATM_PVC_NUMBER; j++) {
+				if (conn->sw_txq_tbl & BIT(j))
+					seq_printf(seq, "%d ", j);
+			}
+			seq_puts(seq, "\n   Prio: ");
+			for (j = 0; j < ATM_PRIO_Q_NUM; j++)
+				seq_printf(seq, "%d ", j);
+			seq_puts(seq, "\n   Qid:  ");
+			for (j = 0; j < ATM_PRIO_Q_NUM; j++)
+				seq_printf(seq, "%d ",
+					conn->prio_queue_map[j]);
+			seq_puts(seq, "\n");
+		}
+	}
+	return 0;
+}
+
+static int pvc_mib_seq_show(struct seq_file *seq, void *v)
+{
+	struct atm_pvc *pvc = (struct atm_pvc *)v;
+	int j;
+	struct atm_priv *priv = seq->private;
+
+	spin_lock_bh(&priv->atm_lock);
+	if (pvc == NULL || pvc->vcc == NULL || pvc->dev == NULL) {
+		spin_unlock_bh(&priv->atm_lock);
+		return 0;
+	}
+	seq_printf(seq, "PVC %u/%u, dev: %s, MIB:\n",
+		pvc->vcc->vpi, pvc->vcc->vci,
+		(pvc->dev) ? pvc->dev->name : "N.A");
+	spin_unlock_bh(&priv->atm_lock);
+
+	print_stat_mib(seq, &pvc->stats);
+
+	for (j = 0; j < ATM_PRIO_Q_NUM; j++) {
+		if (pvc->prio_tx_packets[j] != 0) {
+			seq_printf(seq, "Queue[%d]: TX PKTs:\t %u\n",
+				j, pvc->prio_tx_packets[j]);
+		}
+	}
+	seq_puts(seq, "\n");
+
+	return 0;
+}
+static void *pvc_mib_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct atm_priv *priv = seq->private;
+
+	if (!priv->pvc_tbl)
+		return NULL;
+
+	if (*pos >= ATM_PVC_NUMBER)
+		return NULL;
+
+	return &priv->conn[*pos];
+}
+
+static void *pvc_mib_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct atm_priv *priv = seq->private;
+
+	if (++*pos < ATM_PVC_NUMBER)
+		return &priv->conn[*pos];
+
+	return NULL;
+}
+
+static void pvc_mib_seq_stop(struct seq_file *seq, void *v)
+{
+	return;
+}
+
+static int proc_atm_read_prio_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_atm_read_prio, PDE_DATA(inode));
+}
+
+static const struct seq_operations pvc_mib_seq_ops = {
+	.start = pvc_mib_seq_start,
+	.next = pvc_mib_seq_next,
+	.stop = pvc_mib_seq_stop,
+	.show = pvc_mib_seq_show,
+};
+
+static const struct file_operations atm_prio_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_atm_read_prio_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.write		= proc_atm_write_prio,
+	.release	= single_release,
+};
+
+static int proc_read_pvc_mib_seq_open(struct inode *inode, struct file *file)
+{
+	int ret = seq_open(file, &pvc_mib_seq_ops);
+	if (ret == 0) {
+		struct seq_file *m = file->private_data;
+		m->private = PDE_DATA(inode);
+	}
+	return ret;
+}
+
+static const struct file_operations atm_pvc_mib_proc_fops = {
+	.owner	= THIS_MODULE,
+	.open	= proc_read_pvc_mib_seq_open,
+	.read	= seq_read,
+	.llseek	= seq_lseek,
+	.release = seq_release,
+};
+
+static ssize_t proc_write_cell(struct file *file,
+		const char __user *buf, size_t count, loff_t *data
+	)
+{
+	char local_buf[128];
+	int len;
+	char *p2;
+	int conn = -1;
+	unsigned int vpi = 0, vci = 0, gfc = 0, pti = 0, clp = 0;
+	unsigned char cell[CELL_SIZE] = {0};
+	struct uni_cell_header *header = (struct uni_cell_header *)cell;
+	unsigned int pos = sizeof(*header);
+	unsigned long sys_flag;
+	char *param_list[20];
+	int ret, num;
+	struct atm_priv *priv;
+	int i;
+
+	len = sizeof(local_buf) < count ? sizeof(local_buf) - 1 : count;
+	len = len - copy_from_user(local_buf, buf, len);
+	local_buf[len] = 0;
+
+	num = vrx_split_buffer(local_buf, param_list, ARRAY_SIZE(param_list));
+	priv =  (struct atm_priv *)PDE_DATA(file_inode(file));
+	if (priv == NULL) {
+		pr_err("<%s>: Invalid private data\n", __func__);
+		return count;
+	}
+	if (vrx_strcmpi(param_list[0], "help") == 0)
+		goto proc_atm_cell_help;
+	else {
+		if (vrx_strcmpi(param_list[0], "pvc") == 0) {
+			p2 = param_list[1];
+			vpi = get_num_from_str(&p2, &len, 0);
+			p2 += 1;
+			vci = get_num_from_str(&p2, &len, 0);
+			if (vci == 0x03 || vci == 0x04)
+				conn = find_vpi(vpi);
+			else
+				conn = find_vpivci(vpi, vci);
+			tc_dbg(priv->tc_priv,
+				MSG_INIT,
+				"vpi = %u, vci = %u, conn = %d",
+				vpi, vci, conn);
+		}
+		i = 0;
+		pos = 0;
+		while ((i + 2) < num) {
+			if (vrx_strcmpi(param_list[2 + i], "pti") == 0) {
+				if (vrx_strcmpi(param_list[3 + i],
+					"ATM_PTI_SEGF5") == 0)
+					pti = ATM_PTI_SEGF5;
+				else if (vrx_strcmpi(param_list[3 + i],
+					"SEGF5") == 0)
+					pti = ATM_PTI_SEGF5;
+				else if (vrx_strcmpi(param_list[3 + i],
+					"ATM_PTI_E2EF5") == 0)
+					pti = ATM_PTI_E2EF5;
+				else if (vrx_strcmpi(param_list[3 + i],
+					"E2EF5") == 0)
+					pti = ATM_PTI_E2EF5;
+				else
+					pti = get_num_from_str(
+						&param_list[3 + i],
+						&len,
+						1);
+				i++;
+			} else if (vrx_strcmpi(param_list[2 + i], "gfc") == 0) {
+				gfc = get_num_from_str(
+						&param_list[3 + i],
+						&len,
+						1);
+				i++;
+			} else if (vrx_strcmpi(param_list[2 + i], "clp") == 0) {
+				clp = get_num_from_str(
+					&param_list[3 + i],
+					&len,
+					1);
+				i++;
+			} else if (pos + ATM_HEADER_SIZE < ARRAY_SIZE(cell)) {
+				p2 = param_list[2 + i];
+				cell[pos + ATM_HEADER_SIZE] =
+					get_num_from_str(&p2,
+						&len,
+						1);
+				pos++;
+			}
+			i++;
+		}
+	}
+	if (conn_valid(conn)) {
+		header->gfc = gfc;
+		header->vpi = vpi;
+		header->vci = vci;
+		header->pti = pti;
+		header->clp = clp;
+
+		pr_info(
+			"Header gfc[%x] vpi[%x] vci[%x] pti[%x] clp[%x]\n",
+			header->gfc,
+			header->vpi,
+			header->vci,
+			header->pti,
+			header->clp);
+		ret = ppe_send_oam(priv->conn[conn].vcc, cell, 0);
+		local_irq_save(sys_flag);
+		for (i = 0; i < ARRAY_SIZE(cell); i++) {
+			if (i == 0)
+				pr_info("  cell");
+			if (i % 8 == 0 && i != 0)
+				pr_info("\n       ");
+			pr_info(" %02x",
+				(unsigned int)cell[i]);
+		}
+		if (i % 8 != 0)
+			pr_info("\n");
+		local_irq_restore(sys_flag);
+	}
+	return count;
+proc_atm_cell_help:
+	pr_info("echo <pvc vpi.vci> [pti] [gfc] [clp] <hex data> > cell\n");
+	return count;
+}
+
+static int proc_read_cell(struct seq_file *seq, void *v)
+{
+	return 0;
+}
+
+static int proc_read_cell_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_read_cell, NULL);
+}
+
+static const struct file_operations atm_cell_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_read_cell_seq_open,
+	.read		= seq_read,
+	.write		= proc_write_cell,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static struct tc_proc_list atm_procs[] = {
+	{TC_PROC_ATM_DIR, 0, NULL, 1},
+	{"cfg",		0644,	&atm_cfg_proc_fops,	0},
+	{"mem",		0644,	&mem_proc_fops,		0},
+	{"pp32",	0644,	&pp32_proc_fops,	0},
+	{"wanmib",	0644,	&atm_wanmib_proc_fops,	0},
+	{"htu",		0644,	&htu_proc_fops,		0},
+	{"queue",	0644,	&queue_proc_fops,	0},
+	{"prio",	0644,	&atm_prio_proc_fops,	0},
+	{"pvc_mib",	0644,	&atm_pvc_mib_proc_fops,	0},
+	{"cell",	0644,	&atm_cell_proc_fops,	0},
+	{"fwdbg",	0644,	&fwdbg_proc_fops,	0},
+};
+
+int atm_tc_proc_init(void *atm_priv)
+{
+	struct proc_dir_entry *entry;
+	struct atm_priv *priv = (struct atm_priv *)atm_priv;
+	struct proc_dir_entry *tc_dir = NULL;
+	struct tc_proc_list *p;
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(atm_procs); i++) {
+		p = &atm_procs[i];
+		if (p->is_folder) {
+			tc_dir = proc_mkdir(p->proc_name,
+				priv->tc_priv->proc_dir);
+			if (!tc_dir) {
+				tc_err(priv->tc_priv,
+					MSG_INIT,
+					"failed to create %s",
+					p->proc_name);
+				return -ENOMEM;
+			}
+		} else {
+			entry = proc_create_data(p->proc_name, p->mode,
+					tc_dir, p->fops, (void *)priv);
+			if (!entry) {
+				tc_err(priv->tc_priv,
+					MSG_INIT,
+					"failed to create %s",
+					p->proc_name);
+				goto atm_proc_err;
+			}
+		}
+	}
+
+	priv->proc_dir = tc_dir;
+
+	return 0;
+
+atm_proc_err:
+	for (j = i - 1; j >= 0; j--) {
+		p = &atm_procs[j];
+		if (!p->is_folder)
+			remove_proc_entry(p->proc_name, tc_dir);
+		else
+			remove_proc_entry(p->proc_name,
+				priv->tc_priv->proc_dir);
+	}
+	return -ENOMEM;
+}
+
+int atm_tc_proc_exit(void *atm_priv)
+{
+	struct atm_priv *priv = (struct atm_priv *)atm_priv;
+	struct tc_proc_list *p;
+	int i;
+	for (i = (ARRAY_SIZE(atm_procs) - 1); i >= 0; i--) {
+		p = &atm_procs[i];
+		if (!p->is_folder)
+			remove_proc_entry(p->proc_name, priv->proc_dir);
+		else
+			remove_proc_entry(p->proc_name,
+				priv->tc_priv->proc_dir);
+	}
+	return 0;
+}
+
diff --git a/include/net/dsl_tc.h b/include/net/dsl_tc.h
new file mode 100644
--- /dev/null
+++ b/include/net/dsl_tc.h
@@ -0,0 +1,241 @@
+/*******************************************************************************
+
+  Intel SmartPHY DSL PCIe TC Linux driver
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify it
+  under the terms and conditions of the GNU General Public License,
+  version 2, as published by the Free Software Foundation.
+
+  This program is distributed in the hope it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+  more details.
+
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+
+  The full GNU General Public License is included in this distribution in
+  the file called "COPYING".
+
+*******************************************************************************/
+#ifndef __DSL_TC_H__
+#define __DSL_TC_H__
+
+#include <lantiq_atm.h>
+
+typedef enum {
+	LTQ_MEI_UNKNOWN = 0,
+	/** To register function for getting showtime status. */
+	LTQ_MEI_SHOWTIME_CHECK = 1,
+	/** To register function for showtime entry signalling. */
+	LTQ_MEI_SHOWTIME_ENTER = 2,
+	/** To register function for showtime exit signalling. */
+	LTQ_MEI_SHOWTIME_EXIT = 3,
+	/** To register function for TC-Layer selection.
+	For DSL/PP switchover concept (also refer to DSLCPE_SW-858)
+	*/
+	LTQ_MEI_TC_REQUEST = 4,
+	/** To register function for performing reset of TC-Layer.
+	(also refer to PPA_SYS-353)
+	*/
+	LTQ_MEI_TC_RESET = 5,
+	LTQ_MEI_ERB_ADDR_GET = 6,
+	/** To get ERB PDBRAM and PPE SB BAR base address */
+} e_ltq_mei_cb_type;
+
+/**
+ * This definition is used by the MEI Driver within TC request trigger to
+ * inform the PPA about the TC-Layer that has been negotiated during handshake
+ * and therefore needs to be loaded/configured on the PPA side.
+ */
+typedef enum {
+	/** Request to disable the TC */
+	MEI_TC_REQUEST_OFF = 0,
+	/** Request to load/configure the PTM (EFM) TC */
+	MEI_TC_REQUEST_PTM = 1,
+	/** Request to load/configure the ATM TC */
+	MEI_TC_REQUEST_ATM = 2,
+	/** Delimiter only! */
+	MEI_TC_REQUEST_LAST = 3
+} mei_tc_request_type;
+
+/**
+ * This bit-field definition is used by the MEI Driver to trigger reset
+ * handling(s) within TC-Layer of the PPA.
+ */
+typedef enum {
+	/** This value is defined for initialization purpose only.
+	 At least one of the defined bits of the bitmask shall be set.
+	 */
+	MEI_TC_RESET_CLEAN = 0x00000000,
+	/** Request to perform a reset of the TC codeword buffer */
+	MEI_TC_RESET_CW_BUFFER = 0x00000001
+} mei_tc_reset_type;
+
+struct ltq_mei_atm_showtime_info {
+	void *check_ptr;
+	void *enter_ptr;
+	void *exit_ptr;
+	void *req_tc_ptr;
+	void *tc_reset_ptr;
+	void *erb_addr_ptr;
+};
+
+/** Function pointer for new DSL/PP switchover concept
+ * (also refer to DSLCPE_SW-858)
+ * \param line            Line number
+ * \param tc_reqest_type  TC-Layer to be used/configured
+ * \param is_bonding      Defines whether bonding is used (>=1) or not (0)
+ * \return                0 if successful
+ */
+typedef int (*mei_tc_request_t)(
+	const unsigned char line,
+	mei_tc_request_type tc_reqest_type,
+	int is_bonding);
+
+/** Function pointer for triggering a reset of the TC
+ * (also refer to PPA_SYS-353)
+ * \param line            Line number
+ * \param tc_reset_type   TC Reset type to be performed
+ * \return                0 if successful
+ */
+typedef int (*mei_tc_reset_t)(
+	const unsigned char line,
+	mei_tc_reset_type tc_reset_type);
+
+/** Function pointer to get ERB data base address and
+ * descriptor base address
+ * \param line            Line number
+ * \param data_addr       ERB data base address
+ * \param desc_addr       ERB descriptor base address
+ * \return                0 if successful
+ * data_addr and desc_addr is 64KB aligned address
+ */
+typedef int (*mei_erb_addr_get_t) (const unsigned char line,
+	unsigned int *data_addr, unsigned int *desc_addr);
+
+extern void *ppa_callback_get(e_ltq_mei_cb_type);
+extern int ppa_callback_set(e_ltq_mei_cb_type, void *);
+typedef int (*ltq_mei_atm_showtime_check_t)(const unsigned char,
+		int *, struct port_cell_info *, void **);
+typedef int (*ltq_mei_atm_showtime_enter_t)(const unsigned char,
+		struct port_cell_info *, void *);
+typedef int (*ltq_mei_atm_showtime_exit_t)(const unsigned char);
+
+#define INTEL_PTM_TC_IOCTL_STATS (SIOCDEVPRIVATE + 1)
+#define INTEL_ATM_TC_IOCTL_STATS  _IOR('a', ATMIOC_PHYTYP, struct atmif_sioc)
+
+struct intel_tc_ptm_sl_stats {
+	__u64 wrx_bc_overdrop;
+	__u64 wrx_bc_user_cw;
+	__u64 wrx_bc_idle_cw;
+	__u64 wtx_bc_cw;
+	__u64 wrx_gif_total_pdu;
+	__u64 wrx_gif_drop_pdu;
+	__u64 wrx_gif_crc_err_pdu;
+	__u64 wrx_gif_violated_cw;
+	__u64 wrx_gif_total_bytes;
+	__u64 wtx_gif_total_pdu;
+	__u64 wtx_gif_total_bytes;
+	__u64 rx_pkts;
+	__u64 rx_bytes;
+	__u64 rx_errs;
+	__u64 rx_drops;
+	__u64 tx_pkts;
+	__u64 tx_bytes;
+	__u64 tx_errs;
+	__u64 tx_drops;
+};
+
+struct intel_tc_ptm_bonding_ds_mib {
+	__u32 rx_frag_byte_cnt;
+	__u32 rx_byte_cnt;
+	__u32 rx_of_frag_byte_cnt;
+	__u32 rx_of_byte_cnt;
+	__u32 rx_oor_frag_byte_cnt;
+	__u32 rx_miss_frag_byte_cnt;
+	__u32 rx_to_frag_byte_cnt;
+};
+struct intel_tc_ptm_bonding_ds_bg_mib {
+	__u32 conform_pkt_cnt;
+	__u32 conform_frag_cnt;
+	__u32 conform_byte_cnt;
+	__u32 no_sop_pkt_cnt;
+	__u32 no_sop_frag_cnt;
+	__u32 no_sop_byte_cnt;
+	__u32 no_eop_pkt_cnt;
+	__u32 no_eop_frag_cnt;
+	__u32 no_eop_byte_cnt;
+	__u32 oversize_pkt_cnt;
+	__u32 oversize_frag_cnt;
+	__u32 oversize_byte_cnt;
+	__u32 noncosec_pkt_cnt;
+	__u32 noncosec_frag_cnt;
+	__u32 noncosec_byte_cnt;
+};
+struct intel_tc_ptm_bonding_stats {
+	__u32 us_gif_mib[8];
+	struct intel_tc_ptm_bonding_ds_mib ds_gif_mib[8];
+	struct intel_tc_ptm_bonding_ds_bg_mib ds_bg_mib[4];
+};
+
+struct intel_tc_ptm_stats {
+	struct intel_tc_ptm_sl_stats ptm_sl_stats;
+	struct intel_tc_ptm_bonding_stats pmt_bonding_stats;
+};
+struct intel_tc_atm_queue_stats {
+	__u32 valid;
+	__u32 vpi;
+	__u32 vci;
+	__u32 idx;
+	__u32 pdu;
+	__u32 bytes;
+};
+struct intel_tc_atm_stats {
+	struct intel_tc_atm_queue_stats rx_mib[16];
+	struct intel_tc_atm_queue_stats tx_mib[16];
+	__u32 wrx_drophtu_cell;
+	__u32 wrx_dropdes_pdu;
+	__u32 wrx_correct_pdu;
+	__u32 wrx_err_pdu;
+	__u32 wrx_dropdes_cell;
+	__u32 wrx_correct_cell;
+	__u32 wrx_err_cell;
+	__u32 wrx_total_byte;
+	__u32 wtx_total_pdu;
+	__u32 wtx_total_cell;
+	__u32 wtx_total_byte;
+	__u32 aal5_rx_pkts;
+	__u32 aal5_rx_bytes;
+	__u32 aal5_rx_errors;
+	__u32 aal5_rx_dropped;
+
+	__u32 oam_rx_pkts;
+	__u32 oam_rx_bytes;
+	__u32 oam_rx_errors;
+	__u32 oam_rx_dropped;
+
+	__u32 aal5_tx_pkts;
+	__u32 aal5_tx_bytes;
+	__u32 aal5_tx_errors;
+	__u32 aal5_tx_dropped;
+
+	__u32 oam_tx_pkts;
+	__u32 oam_tx_bytes;
+	__u32 oam_tx_errors;
+	__u32 oam_tx_dropped;
+
+};
+
+struct intel_tc_stats {
+	__u32 tc_info:16;
+	__u32 res:16;
+	union {
+		struct intel_tc_ptm_stats ptm_tc_stats;
+		struct intel_tc_atm_stats atm_tc_stats;
+	} stats;
+};
+#endif /* __DSL_TC_H__ */
+
