Support for Lantiq internal USB 2 core Host mode

--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -56,3 +56,5 @@
 obj-$(CONFIG_USB_GADGET)	+= gadget/
 
 obj-$(CONFIG_USB_COMMON)	+= usb-common.o
+
+obj-$(CONFIG_USB_HOST_LTQ)     += host/
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -702,3 +702,62 @@
 	  for ehci and ohci.
 
 	  If unsure, say N.
+
+config USB_HOST_LTQ
+	tristate "Lantiq USB Host Controller Driver"
+	depends on USB
+	default n
+	help
+	Lantiq USB Host Controller
+
+config USB_HOST_LTQ_FORCE_USB11
+	boolean "Forced USB1.1"
+	depends on USB_HOST_LTQ
+	default n
+	help
+	force to be USB 1.1
+
+config USB_HOST_LTQ_WITH_HS_ELECT_TST
+	boolean "With HS_Electrical Test"
+	depends on USB_HOST_LTQ
+	default n
+	help
+	With USBIF HSET routines
+
+config USB_HOST_LTQ_WITH_ISO
+	boolean "With ISO transfer"
+	depends on USB_HOST_LTQ
+	default n
+	help
+	With USBIF ISO transfer
+
+config USB_HOST_LTQ_COC
+	boolean "CoC in USB Host"
+	depends on USB_HOST_LTQ
+	default n
+	help
+	With CoC on Host
+
+choice
+	prompt "Lantiq unaligned buffer policy"
+	depends on USB_HOST_LTQ
+	help
+	   Lantiq unaligned buffer policy
+
+config USB_HOST_LTQ_UNALIGNED_ADJ
+	boolean "Adjust"
+	help
+	USB_HOST_LTQ_UNALIGNED_ADJ
+
+config USB_HOST_LTQ_UNALIGNED_CHK
+	boolean "Check-only"
+	help
+	USB_HOST_LTQ_UNALIGNED_CHK
+
+config USB_HOST_LTQ_UNALIGNED_NONE
+	boolean "No process"
+	help
+	USB_HOST_LTQ_UNALIGNED_NONE
+
+endchoice
+
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -52,3 +52,58 @@
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
 obj-$(CONFIG_USB_HCD_BCMA)	+= bcma-hcd.o
 obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
+
+
+	ltqusb_host-objs    := ltqusb_driver.o
+	ltqusb_host-objs    += ltqusb_ctl.o
+	ltqusb_host-objs    += ltqusb_cif_h.o
+	ltqusb_host-objs    += ltqhcd.o
+	ltqusb_host-objs    += ltqhcd_es.o
+	ltqusb_host-objs    += ltqhcd_intr.o
+	ltqusb_host-objs    += ltqhcd_queue.o
+
+
+	EXTRA_CFLAGS  += -Dlinux -D__LINUX__
+	EXTRA_CFLAGS  += -D__KERNEL__
+	EXTRA_CFLAGS  += -D__DEBUG__
+	EXTRA_CFLAGS  += -D__ENABLE_DUMP__
+
+ifeq ($(CONFIG_USB_HOST_LTQ_FORCE_USB11),y)
+	EXTRA_CFLAGS  += -D__FORCE_USB11__
+endif
+ifeq ($(CONFIG_USB_HOST_LTQ_WITH_HS_ELECT_TST),y)
+	EXTRA_CFLAGS  += -D__WITH_HS_ELECT_TST__
+endif
+ifeq ($(CONFIG_USB_HOST_LTQ_WITH_ISO),y)
+	EXTRA_CFLAGS  += -D__EN_ISOC__
+endif
+ifeq ($(CONFIG_USB_HOST_LTQ_UNALIGNED_ADJ),y)
+	EXTRA_CFLAGS  += -D__UNALIGNED_BUF_ADJ__
+#	EXTRA_CFLAGS  += -D__UNALIGNED_BUF_BURST__
+endif
+ifeq ($(CONFIG_USB_HOST_LTQ_UNALIGNED_CHK),y)
+	EXTRA_CFLAGS  += -D__UNALIGNED_BUF_CHK__
+#	EXTRA_CFLAGS  += -D__UNALIGNED_BUF_BURST__
+endif
+ifeq ($(CONFIG_USB_HOST_LTQ_COC),y)
+#	EXTRA_CFLAGS  += -D__HOST_COC__
+endif
+
+	EXTRA_CFLAGS  += -D__NEW_COC__
+
+	EXTRA_CFLAGS  += -D__DYN_SOF_INTR__
+#	EXTRA_CFLAGS  += -D__EN_ISOC__
+#	EXTRA_CFLAGS  += -D__EN_ISOC_SPLIT__
+#	EXTRA_CFLAGS  += -D__EPQD_DESTROY_TIMEOUT__
+
+	EXTRA_CFLAGS  += -D__PHY_LONG_PREEMP__
+
+	EXTRA_CFLAGS  += -D__INTRNAKRETRY__
+	EXTRA_CFLAGS  += -D__INTRINCRETRY__
+
+	EXTRA_CFLAGS  += -D__BURST_XFER__
+#	EXTRA_CFLAGS  += -D__SINGLE_XACT__
+
+obj-$(CONFIG_USB_HOST_LTQ)	+= ltqusb_host.o
+
+
--- a/drivers/usb/host/ltqhcd.c
+++ b/drivers/usb/host/ltqhcd.c
@@ -0,0 +1,2208 @@
+/*****************************************************************************
+ **   FILE NAME       : ltqhcd.c
+ **   PROJECT         : Lantiq USB sub-system V3
+ **   MODULES         : Lantiq USB sub-system Host and Device driver
+ **   SRC VERSION     : 3.2
+ **   DATE            : 1/Jan/2011
+ **   AUTHOR          : Chen, Howard
+ **   DESCRIPTION     : This file contains the structures, constants, and
+ **                     interfaces for the Host Contoller Driver (HCD).
+ **
+ **                     The Host Controller Driver (HCD) is responsible for
+ **                     translating requests from the USB Driver into the
+ **                     appropriate actions on the LTQUSB controller.
+ **                     It isolates the USBD from the specifics of the
+ **                     controller by providing an API to the USBD.
+ **   FUNCTIONS       :
+ **   COMPILER        : gcc
+ **   REFERENCE       : Synopsys DWC-OTG Driver 2.7
+ **   COPYRIGHT       :  Copyright (c) 2010
+ **                      LANTIQ DEUTSCHLAND GMBH,
+ **                      Am Campeon 3, 85579 Neubiberg, Germany
+ **
+ **    This program is free software; you can redistribute it and/or modify
+ **    it under the terms of the GNU General Public License as published by
+ **    the Free Software Foundation; either version 2 of the License, or
+ **    (at your option) any later version.
+ **
+ **  Version Control Section  **
+ **   $Author$
+ **   $Date$
+ **   $Revisions$
+ **   $Log$       Revision history
+ *****************************************************************************/
+
+/*
+ * This file contains code fragments from Synopsys HS OTG Linux Software Driver.
+ * For this code the following notice is applicable:
+ *
+ * ==========================================================================
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/*!
+  \file ltqhcd.c
+  \ingroup LTQUSB_DRIVER_V3
+  \brief This file contains the implementation of the HCD. In Linux,
+   the HCD implements the hc_driver API.
+*/
+
+#include <linux/version.h>
+#include "ltqusb_version.h"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/device.h>
+
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+
+#include <linux/dma-mapping.h>
+
+
+#include "ltqusb_plat.h"
+#include "ltqusb_regs.h"
+#include "ltqusb_cif.h"
+#include "ltqhcd.h"
+
+#include <asm/irq.h>
+
+
+uint8_t ltqusb_chip_family=0      ;
+
+#ifdef __DEBUG__
+	static
+	void dump_urb_info(struct urb *_urb, char* _fn_name);
+#if 0
+	static
+	void dump_channel_info(ltqhcd_hcd_t *_ltqhcd,
+	                               ltqhcd_hc_t *_ltqhc);
+#endif
+#endif
+
+static
+void ltqhcd_complete_urb_sub(ltqhcd_urbd_t *_urbd)
+{
+	ltqhcd_hcd_t *ltqhcd;
+	struct urb *urb=NULL;
+	ltqhcd_epqh_t *epqh;
+
+	_urbd->hc = 0;
+	if(!_urbd->epqh)
+	{
+		LTQ_ERROR("%s: urb(%p) invalid epqh\n",
+		          __func__,_urbd);
+		return;
+	}
+	epqh=_urbd->epqh;
+
+	LOCK_URBD_RELEASE_LIST(epqh);
+	if (!list_empty(&_urbd->ql))
+	{
+		list_del_init(&_urbd->ql);
+		epqh->urbd_count--;
+	}
+	else
+	{
+		LTQ_ERROR("%s: urb(%p) not connect to any epqh\n",
+		          __func__,_urbd);
+	}
+	UNLOCK_URBD_RELEASE_LIST(epqh);
+
+	ltqhcd=epqh->ltqhcd;
+	urb   =_urbd->urb;
+	if(!urb)
+		LTQ_ERROR("%s: invalid urb\n",__func__);
+	else if(urb->hcpriv)
+	{
+		if(urb->hcpriv != _urbd)
+			LTQ_ERROR("%s: invalid"
+			          " urb(%p)->hcpriv(%p) != _urbd(%p)\n",
+			          __func__,
+			          urb,
+			          urb->hcpriv,
+			          _urbd);
+		#if   defined(__UNALIGNED_BUF_ADJ__)
+			if(_urbd->aligned_buf)
+			{
+				if(_urbd->is_in)
+					memcpy(_urbd->xfer_buff,
+					       _urbd->aligned_buf,
+					       urb->actual_length);
+				ltqusb_free_buf_h(_urbd->aligned_buf);
+				_urbd->aligned_buf=0;
+			}
+		#endif
+		urb->hcpriv = NULL;
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+			urb->status=_urbd->status;
+			usb_hcd_giveback_urb(ltqhcd_to_syshcd(ltqhcd), urb);
+		#else
+			usb_hcd_giveback_urb(ltqhcd_to_syshcd(ltqhcd), urb,
+			                     _urbd->status);
+		#endif
+	}
+	kfree(_urbd);
+	if(epqh->cancelling)
+		if (list_empty(&epqh->urbd_list))
+			ltqhcd_epqh_free(epqh);
+}
+
+static
+void ltqhcd_complete_urb_func(unsigned long data)
+{
+	unsigned long             flags;
+	ltqhcd_urbd_t *urbd;
+	ltqhcd_epqh_t *epqh;
+	struct list_head *item;
+
+	int count=10;
+
+	epqh=((ltqhcd_epqh_t *)data);
+
+#if 1
+	if(epqh->complete_inuse)
+		return;
+#endif
+	epqh->complete_inuse=1;
+
+	while (!list_empty(&epqh->release_list) && count)
+	{
+		item = epqh->release_list.next;
+		urbd = list_entry(item, ltqhcd_urbd_t, ql);
+		if (!urbd)
+			LTQ_ERROR("%s: invalid urbd\n",__func__);
+		else if (!urbd->epqh)
+			LTQ_ERROR("%s: invalid epqh\n",__func__);
+		else
+		{
+			local_irq_save(flags);
+			ltqhcd_complete_urb_sub(urbd);
+			local_irq_restore (flags);
+		}
+		count--;
+	}
+	if(!list_empty(&epqh->release_list))
+		tasklet_schedule(&epqh->complete_urb_sub);
+	epqh->complete_inuse=0;
+}
+
+/*!
+ \brief Sets the final status of an URB and returns it to the device
+  driver. Any required cleanup of the URB is performed.
+ */
+void ltqhcd_complete_urb(ltqhcd_hcd_t *_ltqhcd,
+                         ltqhcd_urbd_t *_urbd,
+                         int _status)
+{
+	unsigned long             flags;
+
+	if(!_urbd)
+	{
+		LTQ_ERROR("%s: invalid urbd\n",__func__);
+		return;
+	}
+	_urbd->hc=0;
+	if (!_urbd->epqh)
+	{
+		LTQ_ERROR("%s: invalid epqh\n",__func__);
+		return;
+	}
+
+	if(_urbd->cancelling && _urbd->cancelling_status)
+		_urbd->status = _urbd->cancelling_status;
+	else
+		_urbd->status = _status;
+
+	#ifdef __DEBUG__
+		if (CHK_DEBUG_LEVEL(DBG_HCDV)
+		     || (_urbd->epqh->ep_type == LTQUSB_EP_TYPE_CTRL && CHK_DEBUG_LEVEL(DBG_HCD_URB_CTRL))
+		     || (_urbd->epqh->ep_type == LTQUSB_EP_TYPE_ISOC &&  _urbd->is_in && CHK_DEBUG_LEVEL(DBG_HCD_URB_ISOC_IN))
+		     || (_urbd->epqh->ep_type == LTQUSB_EP_TYPE_ISOC && !_urbd->is_in && CHK_DEBUG_LEVEL(DBG_HCD_URB_ISOC_OUT))
+		     || (_urbd->epqh->ep_type == LTQUSB_EP_TYPE_BULK &&  _urbd->is_in && CHK_DEBUG_LEVEL(DBG_HCD_URB_BULK_IN))
+		     || (_urbd->epqh->ep_type == LTQUSB_EP_TYPE_BULK && !_urbd->is_in && CHK_DEBUG_LEVEL(DBG_HCD_URB_BULK_OUT))
+		     || (_urbd->epqh->ep_type == LTQUSB_EP_TYPE_INTR &&  _urbd->is_in && CHK_DEBUG_LEVEL(DBG_HCD_URB_INTR_IN))
+		     || (_urbd->epqh->ep_type == LTQUSB_EP_TYPE_INTR && !_urbd->is_in && CHK_DEBUG_LEVEL(DBG_HCD_URB_INTR_OUT))
+		    )
+		{
+			LTQ_PRINT("%s: ehqh %p _urbd %p, urb %p\n"
+			          "    device %d, ep %d %s/%s\n"
+			          "    actual_transfered=%d status=%d\n",
+				  __func__,_urbd->epqh,
+				  _urbd,_urbd->urb,
+				  (_urbd->urb)?usb_pipedevice(_urbd->urb->pipe):-1,
+				  (_urbd->urb)?usb_pipeendpoint(_urbd->urb->pipe):-1,
+				  (_urbd->urb)?(usb_pipein(_urbd->urb->pipe) ? "IN" : "OUT"):"--",
+				  (_urbd->is_in) ? "IN" : "OUT",
+				  (_urbd->urb)?_urbd->urb->actual_length:-1,
+				   _urbd->status);
+			if ((_urbd->urb)&& _urbd->epqh->ep_type == LTQUSB_EP_TYPE_ISOC)
+			{
+				int i;
+				for (i = 0; i < _urbd->urb->number_of_packets; i++)
+					LTQ_PRINT("  ISO Desc %d status: %d\n", i, _urbd->urb->iso_frame_desc[i].status);
+			}
+		}
+	#endif
+
+	local_irq_save(flags);
+	if(_urbd->phase!=URBD_FINISHING)
+	{
+		if(_urbd->phase!=URBD_DEQUEUEING && _urbd->phase!=URBD_COMPLETING)
+			printk(KERN_INFO "Warning: %s() Strange URBD PHASE %d\n",__func__,_urbd->phase);
+		if(_urbd->urb)
+		{
+			if((   _urbd->status == 0
+			    && _urbd->phase==URBD_COMPLETING
+			   )
+			   || in_irq())
+			{
+				_urbd->phase=URBD_FINISHING;
+				LOCK_URBD_LIST(_urbd->epqh);
+				list_del_init(&_urbd->ql);
+				UNLOCK_URBD_LIST(_urbd->epqh);
+				LOCK_URBD_RELEASE_LIST(_urbd->epqh);
+				list_add_tail(&_urbd->ql,&_urbd->epqh->release_list);
+				UNLOCK_URBD_RELEASE_LIST(_urbd->epqh);
+				if(!_urbd->epqh->complete_urb_sub.func)
+				{
+					_urbd->epqh->complete_urb_sub.next = NULL;
+					_urbd->epqh->complete_urb_sub.state = 0;
+					atomic_set( &_urbd->epqh->complete_urb_sub.count, 0);
+					_urbd->epqh->complete_urb_sub.func = ltqhcd_complete_urb_func;
+					_urbd->epqh->complete_urb_sub.data = (unsigned long)_urbd->epqh;
+				}
+				tasklet_schedule(&_urbd->epqh->complete_urb_sub);
+			}
+			else
+			{
+				_urbd->phase=URBD_FINISHING;
+				LOCK_URBD_LIST(_urbd->epqh);
+				list_del_init(&_urbd->ql);
+				UNLOCK_URBD_LIST(_urbd->epqh);
+				LOCK_URBD_RELEASE_LIST(_urbd->epqh);
+				list_add_tail(&_urbd->ql,&_urbd->epqh->release_list);
+				UNLOCK_URBD_RELEASE_LIST(_urbd->epqh);
+				ltqhcd_complete_urb_sub(_urbd);
+			}
+		}
+		else
+		{
+			kfree(_urbd);
+		}
+	}
+	else
+	{
+		printk(KERN_INFO "Warning: %s() Double Completing \n",__func__);
+	}
+
+	local_irq_restore (flags);
+}
+
+/*!
+ \brief Processes all the URBs in a single EPQHs. Completes them with
+        status and frees the URBD.
+ */
+static
+void kill_all_urbs_in_epqh(ltqhcd_hcd_t *_ltqhcd, ltqhcd_epqh_t *_epqh, int _status)
+{
+	struct list_head *item;
+	struct list_head *next;
+	ltqhcd_urbd_t    *urbd;
+
+	if(!_epqh)
+		return;
+
+	LTQ_DEBUGPL(DBG_HCDV, "%s %p\n",__func__,_epqh);
+	LOCK_URBD_LIST(_epqh);
+	_epqh->cancelling=1;
+#if 0
+	list_for_each(item, &_epqh->urbd_list)
+	{
+		urbd = list_entry(item, ltqhcd_urbd_t, ql);
+		if(   urbd->phase==URBD_IDLE
+		   || urbd->phase==URBD_ACTIVE
+		  )
+			urbd->phase=URBD_DEQUEUEING;
+	}
+	list_for_each_safe(item, next, &_epqh->urbd_list)
+	{
+		urbd = list_entry(item, ltqhcd_urbd_t, ql);
+		urbd->cancelling=1;
+		if(urbd->hc) urbd->hc->cancelling=1;
+		if(urbd->phase==URBD_DEQUEUEING)
+		{
+			urbd->urb->status = _status;
+			urbd->phase = URBD_FINISHING;
+			ltqhcd_complete_urb_sub(urbd);
+			ltqhcd_epqh_idle(_epqh);
+		}
+		else if(   urbd->phase==URBD_RUNNING )
+		{
+			if(ltqhcd_hc_halt(&_ltqhcd->core_if, urbd->hc, HC_XFER_URB_DEQUEUE))
+			{
+				urbd->urb->status = _status;
+				urbd->phase = URBD_FINISHING;
+				ltqhcd_complete_urb_sub(urbd);
+				ltqhcd_epqh_idle(_epqh);
+			}
+		}
+		else if(   urbd->phase==URBD_FINISHING )
+		{
+		}
+		else
+			LTQ_ERROR("%s: invalid urb phase:%d \n",__func__,urbd->phase);
+	}
+#else
+	list_for_each_safe(item, next, &_epqh->urbd_list)
+	{
+		urbd = list_entry(item, ltqhcd_urbd_t, ql);
+		urbd->cancelling=1;
+		if(urbd->hc) urbd->hc->cancelling=1;
+		if(   urbd->phase==URBD_IDLE
+		   || urbd->phase==URBD_ACTIVE
+		  )
+		{
+			urbd->urb->status = _status;
+			urbd->phase = URBD_DEQUEUEING;
+			UNLOCK_URBD_LIST(_epqh);
+			ltqhcd_complete_urb(_ltqhcd, urbd, _status);
+			ltqhcd_epqh_idle(_epqh);
+			LOCK_URBD_LIST(_epqh);
+		}
+		else if(   urbd->phase==URBD_RUNNING )
+		{
+			if(ltqhcd_hc_halt(&_ltqhcd->core_if, urbd->hc, HC_XFER_URB_DEQUEUE))
+			{
+				urbd->urb->status = _status;
+				urbd->phase = URBD_DEQUEUEING;
+				UNLOCK_URBD_LIST(_epqh);
+				ltqhcd_complete_urb(_ltqhcd, urbd, _status);
+				ltqhcd_epqh_idle(_epqh);
+				LOCK_URBD_LIST(_epqh);
+			}
+		}
+		else if(   urbd->phase==URBD_FINISHING )
+		{
+		}
+		else
+			LTQ_ERROR("%s: invalid urb phase:%d \n",__func__,urbd->phase);
+	}
+#endif
+	UNLOCK_URBD_LIST(_epqh);
+	LTQ_DEBUGPL(DBG_HCDV, "%s %p finish\n",__func__,_epqh);
+}
+
+
+/*!
+ \brief Free all EPS in one Processes all the URBs in a single list of EPQHs. Completes them with
+        -ETIMEDOUT and frees the URBD.
+ */
+static
+void epqh_list_free(ltqhcd_hcd_t *_ltqhcd, struct list_head *_epqh_list)
+{
+	ltqhcd_epqh_t    *epqh;
+	struct list_head *item;
+	if (!_ltqhcd)
+		return;
+	if (!_epqh_list)
+		return;
+
+	LTQ_DEBUGPL(DBG_HCDV, "%s %p\n",__func__,_epqh_list);
+
+	item = _epqh_list->next;
+	while(item != _epqh_list && item != item->next)
+	{
+		epqh = list_entry(item, ltqhcd_epqh_t, ql);
+		epqh->phase=EPQH_DISABLING;
+		item = item->next;
+#ifdef NEWRET
+		kill_all_urbs_in_epqh(_ltqhcd, epqh, -ESHUTDOWN);
+#else
+		kill_all_urbs_in_epqh(_ltqhcd, epqh, -ETIMEDOUT);
+#endif
+	}
+
+	item = _epqh_list->next;
+	while(item != _epqh_list && item != item->next)
+	{
+		epqh = list_entry(item, ltqhcd_epqh_t, ql);
+		epqh->phase=EPQH_DISABLING;
+		item = item->next;
+		if(list_empty(&epqh->urbd_list) && list_empty(&epqh->release_list))
+			ltqhcd_epqh_free(epqh);
+	}
+
+	LTQ_DEBUGPL(DBG_HCDV, "%s %p finish\n",__func__,_epqh_list);
+	/* Ensure there are no URBDs or URBs left. */
+}
+
+static
+void epqh_list_free_2(ltqhcd_hcd_t *_ltqhcd, struct list_head *_epqh_list)
+{
+	ltqhcd_epqh_t    *epqh;
+	struct list_head *item;
+	struct list_head *next;
+	if (!_ltqhcd)
+		return;
+	if (!_epqh_list)
+		return;
+
+	LTQ_DEBUGPL(DBG_HCDV, "%s %p\n",__func__,_epqh_list);
+	list_for_each_safe(item, next, _epqh_list)
+	{
+		epqh = list_entry(item, ltqhcd_epqh_t, ql);
+		if(item == item->next)
+		{
+			ltqhcd_epqh_free(epqh);
+		}
+		else
+		{
+			uint32_t count=0x80000;
+			for(;(!list_empty(&epqh->urbd_list) || !list_empty(&epqh->release_list))&& count> 0; count--) udelay(1);
+			if(!count)
+			{
+//				LTQ_ERROR("%s: unable to clear urbd in epqh \n",__func__);
+			}
+			else
+				ltqhcd_epqh_free(epqh);
+		}
+	}
+	LTQ_DEBUGPL(DBG_HCDV, "%s %p finish\n",__func__,_epqh_list);
+	/* Ensure there are no URBDs or URBs left. */
+}
+
+static
+void epqh_list_free_all_sub(unsigned long data)
+{
+	ltqhcd_hcd_t *ltqhcd;
+
+	ltqhcd=(ltqhcd_hcd_t *)data;
+	epqh_list_free(ltqhcd, &ltqhcd->epqh_list_ctrl);
+	epqh_list_free(ltqhcd, &ltqhcd->epqh_list_bulk);
+	epqh_list_free(ltqhcd, &ltqhcd->epqh_list_intr);
+	#ifdef __EN_ISOC__
+		epqh_list_free(ltqhcd, &ltqhcd->epqh_list_isoc);
+	#endif
+
+	epqh_list_free_2(ltqhcd, &ltqhcd->epqh_list_ctrl);
+	epqh_list_free_2(ltqhcd, &ltqhcd->epqh_list_bulk);
+	epqh_list_free_2(ltqhcd, &ltqhcd->epqh_list_intr);
+	#ifdef __EN_ISOC__
+		epqh_list_free_2(ltqhcd, &ltqhcd->epqh_list_isoc);
+	#endif
+}
+
+static
+void epqh_list_free_all(ltqhcd_hcd_t *_ltqhcd)
+{
+#if 1
+	_ltqhcd->tasklet_free_epqh_list.next = NULL;
+	_ltqhcd->tasklet_free_epqh_list.state = 0;
+	atomic_set( &_ltqhcd->tasklet_free_epqh_list.count, 0);
+	_ltqhcd->tasklet_free_epqh_list.func=epqh_list_free_all_sub;
+	_ltqhcd->tasklet_free_epqh_list.data = (unsigned long)_ltqhcd;
+	tasklet_schedule(&_ltqhcd->tasklet_free_epqh_list);
+#else
+	epqh_list_free_all_sub((unsigned long)_ltqhcd);
+#endif
+}
+
+
+/*!
+   \brief This function is called to handle the disconnection of host port.
+ */
+int32_t ltqhcd_disconnect(ltqhcd_hcd_t *_ltqhcd)
+{
+	LTQ_DEBUGPL(DBG_HCDV, "%s(%p)\n", __func__, _ltqhcd);
+
+	_ltqhcd->disconnecting=1;
+	/* Set status flags for the hub driver. */
+	_ltqhcd->flags.b.port_connect_status_change = 1;
+	_ltqhcd->flags.b.port_connect_status = 0;
+
+	/*
+	 * Shutdown any transfers in process by clearing the Tx FIFO Empty
+	 * interrupt mask and status bits and disabling subsequent host
+	 * channel interrupts.
+	 */
+	 {
+		gint_data_t intr = { .d32 = 0 };
+		intr.b.nptxfempty = 1;
+		intr.b.ptxfempty  = 1;
+		intr.b.hcintr     = 1;
+		ltqusb_mreg (&_ltqhcd->core_if.core_global_regs->gintmsk, intr.d32, 0);
+		ltqusb_mreg (&_ltqhcd->core_if.core_global_regs->gintsts, intr.d32, 0);
+	}
+
+	/* Respond with an error status to all URBs in the schedule. */
+	epqh_list_free_all(_ltqhcd);
+
+	/* Clean up any host channels that were in use. */
+	{
+		int               num_channels;
+		ltqhcd_hc_t      *channel;
+		ltqusb_hc_regs_t *hc_regs;
+		hcchar_data_t     hcchar;
+		int	              i;
+
+		num_channels = _ltqhcd->core_if.params.host_channels;
+
+		for (i = 0; i < num_channels; i++)
+		{
+			channel = &_ltqhcd->ltqhc[i];
+			hc_regs = _ltqhcd->core_if.hc_regs[i];
+			hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+			if (hcchar.b.chen)
+				printk(KERN_INFO "Warning: %s() HC still enabled\n",__func__);
+			ltqhcd_hc_cleanup(&_ltqhcd->core_if, channel);
+		}
+	}
+	//UNLOCK_ENQUEUE(_ltqhcd);
+	LTQ_DEBUGPL(DBG_HCDV, "%s(%p) finish\n", __func__, _ltqhcd);
+
+	usb_hcd_poll_rh_status(_ltqhcd->syshcd);
+
+	return 1;
+}
+
+
+/*!
+   \brief Frees secondary storage associated with the ltqhcd_hcd structure contained
+          in the struct usb_hcd field.
+ */
+static
+void ltqhcd_freeextra(struct usb_hcd *_syshcd)
+{
+	ltqhcd_hcd_t 	*ltqhcd = syshcd_to_ltqhcd(_syshcd);
+
+	LTQ_DEBUGPL(DBG_HCD, "LTQUSB HCD FREE\n");
+
+	/* Free memory for EPQH/URBD lists */
+	epqh_list_free_all(ltqhcd);
+
+	/* Free memory for the host channels. */
+	ltqusb_free_buf_h(ltqhcd->status_buf);
+	return;
+}
+
+/*!
+   \brief Initializes the HCD. This function allocates memory for and initializes the
+  static parts of the usb_hcd and ltqhcd_hcd structures. It also registers the
+  USB bus with the core and calls the hc_driver->start() function. It returns
+  a negative error on failure.
+ */
+extern enum hrtimer_restart xfer_stopper_timer_callback(struct hrtimer *pt);
+int ltqhcd_init(ltqhcd_hcd_t *_ltqhcd)
+{
+	int retval = 0;
+	struct usb_hcd *syshcd = NULL;
+
+	LTQ_DEBUGPL(DBG_HCD, "Lantiq USB HCD INIT\n");
+
+	INIT_EPQH_LIST_ALL(_ltqhcd);
+	INIT_EPQH_LIST(_ltqhcd);
+	INIT_INTR(_ltqhcd);
+	INIT_ENQUEUE(_ltqhcd);
+	INIT_SELECT(_ltqhcd);
+
+	init_timer(&_ltqhcd->autoprobe_timer);
+	init_timer(&_ltqhcd->host_probe_timer);
+	_ltqhcd->probe_sec = 5;
+	_ltqhcd->autoprobe_sec = 30;
+
+	_ltqhcd->hc_driver.description      = _ltqhcd->core_if.core_name;
+	_ltqhcd->hc_driver.product_desc     = "Lantiq USB Controller";
+	//_ltqhcd->hc_driver.hcd_priv_size    = sizeof(ltqhcd_hcd_t);
+	_ltqhcd->hc_driver.hcd_priv_size    = sizeof(unsigned long);
+	_ltqhcd->hc_driver.irq              = ltqhcd_irq;
+	_ltqhcd->hc_driver.flags            = HCD_MEMORY | HCD_USB2;
+	_ltqhcd->hc_driver.start            = ltqhcd_start;
+	_ltqhcd->hc_driver.stop             = ltqhcd_stop;
+	//_ltqhcd->hc_driver.reset          =
+	//_ltqhcd->hc_driver.suspend        =
+	//_ltqhcd->hc_driver.resume         =
+	_ltqhcd->hc_driver.urb_enqueue      = ltqhcd_urb_enqueue;
+	_ltqhcd->hc_driver.urb_dequeue      = ltqhcd_urb_dequeue;
+	_ltqhcd->hc_driver.endpoint_disable = ltqhcd_endpoint_disable;
+	_ltqhcd->hc_driver.get_frame_number = ltqhcd_get_frame_number;
+	_ltqhcd->hc_driver.hub_status_data  = ltqhcd_hub_status_data;
+	_ltqhcd->hc_driver.hub_control      = ltqhcd_hub_control;
+	//_ltqhcd->hc_driver.hub_suspend    =
+	//_ltqhcd->hc_driver.hub_resume     =
+
+	_ltqhcd->xfer_prot1_usec= XFER_PROT1_USEC;
+	_ltqhcd->xfer_prot2_usec= XFER_PROT2_USEC;
+	_ltqhcd->xfer_prot1_value= XFER_PROT1_CALC(_ltqhcd->xfer_prot1_usec);
+	_ltqhcd->xfer_prot2_value= XFER_PROT2_CALC(_ltqhcd->xfer_prot2_usec);
+
+	#ifdef __BURST_XFER__
+		_ltqhcd->burst =1;
+	#endif
+	#ifdef __SINGLE_XACT__
+		_ltqhcd->singlexact =1;
+	#endif
+
+	printk(KERN_INFO "hcd Prot1:%d %04x %u   Prot2:%d %lu SingleXact:%d\n",_ltqhcd->xfer_prot1_usec,_ltqhcd->xfer_prot1_value,_ltqhcd->xfer_prot1_value,_ltqhcd->xfer_prot2_usec,_ltqhcd->xfer_prot2_value,_ltqhcd->singlexact);
+
+	/* Allocate memory for and initialize the base HCD and  */
+	//syshcd = usb_create_hcd(&_ltqhcd->hc_driver, _ltqhcd->dev, _ltqhcd->dev->bus_id);
+	syshcd = usb_create_hcd(&_ltqhcd->hc_driver, _ltqhcd->dev, _ltqhcd->core_if.core_name);
+
+	if (syshcd == NULL)
+	{
+		retval = -ENOMEM;
+		goto error1;
+	}
+
+	syshcd->rsrc_start = (unsigned long)_ltqhcd->core_if.core_global_regs;
+	syshcd->regs       = (void *)_ltqhcd->core_if.core_global_regs;
+	syshcd->self.otg_port = 0;
+
+	//*((unsigned long *)(&(syshcd->hcd_priv)))=(unsigned long)_ltqhcd;
+	//*((unsigned long *)(&(syshcd->hcd_priv[0])))=(unsigned long)_ltqhcd;
+	syshcd->hcd_priv[0]=(unsigned long)_ltqhcd;
+	_ltqhcd->syshcd=syshcd;
+	INIT_LIST_HEAD(&_ltqhcd->epqh_list_all   );
+	INIT_LIST_HEAD(&_ltqhcd->epqh_list_ctrl  );
+	INIT_LIST_HEAD(&_ltqhcd->epqh_list_bulk  );
+	INIT_LIST_HEAD(&_ltqhcd->epqh_list_intr  );
+	#ifdef __EN_ISOC__
+		INIT_LIST_HEAD(&_ltqhcd->epqh_list_isoc);
+	#endif
+
+	/*
+	 * Create a host channel descriptor for each host channel implemented
+	 * in the controller. Initialize the channel descriptor array.
+	 */
+	{
+		int          num_channels = _ltqhcd->core_if.params.host_channels;
+		int i;
+		for (i = 0; i < num_channels; i++)
+		{
+			_ltqhcd->ltqhc[i].hc_num = i;
+			_ltqhcd->ltqhc[i].hc_regs = _ltqhcd->core_if.hc_regs[i];
+			LTQ_DEBUGPL(DBG_HCDV, "HCD Added channel #%d\n", i);
+		}
+	}
+	hrtimer_init(&(_ltqhcd->xfer_stopper_timer),XFER_PROT2_OPTIONS,HRTIMER_MODE_REL);
+	_ltqhcd->xfer_stopper_timer.function=xfer_stopper_timer_callback;
+
+	/* Set device flags indicating whether the HCD supports DMA. */
+	if(_ltqhcd->dev->dma_mask)
+		*(_ltqhcd->dev->dma_mask) = ~0;
+	_ltqhcd->dev->coherent_dma_mask = ~0;
+
+	/*
+	 * Finish generic HCD initialization and start the HCD. This function
+	 * allocates the DMA buffer pool, registers the USB bus, requests the
+	 * IRQ line, and calls ltqusb_hcd_start method.
+	 */
+	retval = usb_add_hcd(syshcd, _ltqhcd->core_if.irq, 0
+			                                   |IRQF_DISABLED
+			                                   |IRQF_SHARED
+							   );
+	if (retval < 0)
+		goto error2;
+
+	/*
+	 * Allocate space for storing data on status transactions. Normally no
+	 * data is sent, but this space acts as a bit bucket. This must be
+	 * done after usb_add_hcd since that function allocates the DMA buffer
+	 * pool.
+	 */
+	_ltqhcd->status_buf = ltqusb_alloc_buf_h(LTQHCD_STATUS_BUF_SIZE, 64);
+
+	if (_ltqhcd->status_buf)
+	{
+		LTQ_DEBUGPL(DBG_HCD, "Lantiq USB HCD Initialized, bus=%s, usbbus=%d\n", _ltqhcd->core_if.core_name, syshcd->self.busnum);
+		return 0;
+	}
+	LTQ_ERROR("%s: status_buf allocation failed\n", __func__);
+
+	/* Error conditions */
+	usb_remove_hcd(syshcd);
+error2:
+	ltqhcd_freeextra(syshcd);
+	usb_put_hcd(syshcd);
+error1:
+	return retval;
+}
+
+/*!
+   \brief Removes the HCD.
+  Frees memory and resources associated with the HCD and deregisters the bus.
+ */
+void ltqhcd_remove(ltqhcd_hcd_t *_ltqhcd)
+{
+	struct usb_hcd *syshcd = ltqhcd_to_syshcd(_ltqhcd);
+
+	LTQ_DEBUGPL(DBG_HCD, "Lantiq USB HCD REMOVE\n");
+
+	/* Turn off all interrupts */
+	ltqusb_wreg (&_ltqhcd->core_if.core_global_regs->gintmsk, 0);
+	ltqusb_mreg (&_ltqhcd->core_if.core_global_regs->gahbcfg, 1, 0);
+
+	ltqusb_phy_power_off_h  (&_ltqhcd->core_if); // Test
+	ltqusb_power_off_h (&_ltqhcd->core_if);
+
+	usb_remove_hcd(syshcd);
+	ltqhcd_freeextra(syshcd);
+	usb_put_hcd(syshcd);
+	return;
+}
+
+
+/* =========================================================================
+ *  Linux HC Driver Functions
+ * ========================================================================= */
+
+/*!
+   \brief Initializes the LTQUSB controller and its root hub and prepares it for host
+ mode operation. Activates the root port. Returns 0 on success and a negative
+ error code on failure.
+ Called by USB stack.
+ */
+int ltqhcd_start(struct usb_hcd *_syshcd)
+{
+	ltqhcd_hcd_t *ltqhcd = syshcd_to_ltqhcd (_syshcd);
+	ltqusb_core_if_t *core_if = &ltqhcd->core_if;
+	struct usb_bus *bus;
+
+	LTQ_DEBUGPL(DBG_HCD, "Lantiq USB HCD START\n");
+
+	bus = hcd_to_bus(_syshcd);
+
+	/* Initialize the bus state.  */
+	_syshcd->state = HC_STATE_RUNNING;
+
+	/* Initialize and connect root hub if one is not already attached */
+	if (bus->root_hub)
+	{
+		LTQ_DEBUGPL(DBG_HCD, "Lantiq USB HCD Has Root Hub\n");
+		/* Inform the HUB driver to resume. */
+		usb_hcd_resume_root_hub(_syshcd);
+	}
+
+	ltqhcd->flags.d32 = 0;
+
+	/* Put all channels in the free channel list and clean up channel states.*/
+	{
+		int num_channels = ltqhcd->core_if.params.host_channels;
+		int i;
+		for (i = 0; i < num_channels; i++)
+		{
+			ltqhcd_hc_t      *channel;
+			channel = &ltqhcd->ltqhc[i];
+			ltqhcd_hc_cleanup(&ltqhcd->core_if, channel);
+		}
+	}
+	/* Initialize the USB core for host mode operation. */
+
+	ltqusb_host_enable_interrupts(core_if);
+	ltqusb_enable_global_interrupts_h(core_if);
+	ltqusb_phy_power_on_h (core_if);
+
+	ltqusb_vbus_init(ltqhcd);
+
+	/* Turn on the vbus power. */
+	{
+		hprt0_data_t hprt0;
+		hprt0.d32 = ltqusb_read_hprt0(core_if);
+
+		LTQ_PRINT("Init: Power Port (%d)\n", hprt0.b.prtpwr);
+		if (hprt0.b.prtpwr == 0 )
+		{
+			hprt0.b.prtpwr = 1;
+			ltqusb_wreg(core_if->hprt0, hprt0.d32);
+			ltqusb_vbus_on(ltqhcd);
+		}
+	}
+	return 0;
+}
+
+/*!
+   \brief Halts the LTQUSB  host mode operations in a clean manner. USB transfers are
+ stopped.
+ */
+void		ltqusb_oc_int_free(int port);
+
+	extern struct timer_list oc1_retry_timer;
+	extern struct timer_list oc2_retry_timer;
+
+void ltqhcd_stop(struct usb_hcd *_syshcd)
+{
+	ltqhcd_hcd_t *ltqhcd = syshcd_to_ltqhcd(_syshcd);
+	hprt0_data_t  hprt0 = { .d32=0 };
+
+	LTQ_DEBUGPL(DBG_HCD, "Lantiq USB HCD STOP\n");
+	#ifdef __EPQD_DESTROY_TIMEOUT__
+		del_timer(&ltqhcd->destroy_timer);
+	#endif
+	del_timer(&ltqhcd->host_probe_timer);
+	del_timer(&ltqhcd->autoprobe_timer);
+
+
+	del_timer(&oc1_retry_timer);
+	del_timer(&oc2_retry_timer);
+
+	/* Turn off all interrupts. */
+	ltqusb_disable_global_interrupts_h(&ltqhcd->core_if );
+	ltqusb_host_disable_interrupts(&ltqhcd->core_if );
+
+	/*
+	 * The root hub should be disconnected before this function is called.
+	 * The disconnect will clear the URBD lists (via ..._hcd_urb_dequeue)
+	 * and the EPQH lists (via ..._hcd_endpoint_disable).
+	 */
+
+	/* Turn off the vbus power */
+	LTQ_PRINT("PortPower off\n");
+
+	ltqusb_vbus_off(ltqhcd);
+
+
+	ltqusb_oc_int_free(ltqhcd->core_if.core_no);
+
+
+	ltqusb_vbus_free(ltqhcd);
+	hprt0.b.prtpwr = 0;
+	ltqusb_wreg(ltqhcd->core_if.hprt0, hprt0.d32);
+	return;
+}
+
+/*!
+   \brief Returns the current frame number
+ */
+int ltqhcd_get_frame_number(struct usb_hcd *_syshcd)
+{
+	ltqhcd_hcd_t 	*ltqhcd = syshcd_to_ltqhcd(_syshcd);
+	hfnum_data_t hfnum;
+
+	hfnum.d32 = ltqusb_rreg(&ltqhcd->core_if.host_global_regs->hfnum);
+
+	return hfnum.b.frnum;
+}
+
+/*!
+   \brief Starts processing a USB transfer request specified by a USB Request Block
+  (URB). mem_flags indicates the type of memory allocation to use while
+  processing this URB.
+ */
+int ltqhcd_urb_enqueue( struct usb_hcd           *_syshcd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+                        struct usb_host_endpoint *_sysep,
+#endif
+                        struct urb               *_urb,
+                        gfp_t                     _mem_flags)
+{
+	ltqhcd_hcd_t *ltqhcd = syshcd_to_ltqhcd (_syshcd);
+	ltqhcd_epqh_t *epqh = NULL;
+
+	LOCK_ENQUEUE(ltqhcd);
+
+	#ifdef __DEBUG__
+		if (CHK_DEBUG_LEVEL(DBG_HCDV)
+		     || (usb_pipetype(_urb->pipe) == PIPE_CONTROL     && CHK_DEBUG_LEVEL(DBG_HCD_URB_CTRL))
+		     || (usb_pipetype(_urb->pipe) == PIPE_ISOCHRONOUS &&  usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_ISOC_IN))
+		     || (usb_pipetype(_urb->pipe) == PIPE_ISOCHRONOUS && !usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_ISOC_OUT))
+		     || (usb_pipetype(_urb->pipe) == PIPE_BULK        &&  usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_BULK_IN))
+		     || (usb_pipetype(_urb->pipe) == PIPE_BULK        && !usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_BULK_OUT))
+		     || (usb_pipetype(_urb->pipe) == PIPE_INTERRUPT   &&  usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_INTR_IN))
+		     || (usb_pipetype(_urb->pipe) == PIPE_INTERRUPT   && !usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_INTR_OUT))
+		    )
+			dump_urb_info(_urb, "ltqusb_hcd_urb_enqueue");
+	#endif //__DEBUG__
+	LTQ_DEBUGPL(DBG_HCD, "LTQUSB HCD URB Enqueue\n");
+
+	if (!ltqhcd->flags.b.port_connect_status)  /* No longer connected. */
+	{
+		UNLOCK_ENQUEUE(ltqhcd);
+		return -ENODEV;
+	}
+
+	#if !defined(__EN_ISOC__)
+		if(usb_pipetype(_urb->pipe) == PIPE_ISOCHRONOUS)
+		{
+			UNLOCK_ENQUEUE(ltqhcd);
+			LTQ_ERROR("ISOC transfer not supported!!!\n");
+#ifdef NEWRET
+			return -ENXIO;
+			//return -EINVAL;	//a) Invalid transfer type specified (or not supported)
+#else
+			return -ENODEV;
+#endif
+		}
+	#endif
+
+	if(_urb->hcpriv)
+	{
+		UNLOCK_ENQUEUE(ltqhcd);
+		LTQ_WARN("%s() Previous urb->hcpriv exist %p\n",__func__,_urb->hcpriv);
+	#if 1
+#ifdef NEWRET
+		return -EBUSY;//		The URB is already active.
+#else
+		return -ENOSPC;
+#endif
+	#endif
+	}
+
+	epqh=ltqhcd_urbd_create (ltqhcd,_urb);
+	UNLOCK_ENQUEUE(ltqhcd);
+	if (!epqh)
+	{
+		LTQ_ERROR("LTQUSB HCD URB Enqueue failed creating URBD\n");
+#ifdef NEWRET
+		return -ENOMEM;//		no memory for allocation of internal structures
+#else
+		return -ENOSPC;
+#endif
+	}
+	if(epqh->phase==EPQH_DISABLING )
+	{
+		LTQ_ERROR("Enqueue to a DISABLING EP!!!\n");
+#ifdef NEWRET
+		return -ENOENT	;//	specified interface or endpoint does not exist or is not enabled
+#else
+		return -ENODEV;
+#endif
+	}
+
+	_urb->status= -EINPROGRESS;
+	#ifdef __DYN_SOF_INTR__
+		ltqhcd->dyn_sof_count = DYN_SOF_COUNT_DEF;
+	#endif
+	//enable_sof(ltqhcd);
+	{
+		gint_data_t gintsts;
+		gintsts.d32=0;
+		gintsts.b.sofintr = 1;
+		ltqusb_mreg(&ltqhcd->core_if.core_global_regs->gintmsk, 0,gintsts.d32);
+	}
+
+	if(epqh->phase==EPQH_IDLE || epqh->phase==EPQH_STDBY )
+	{
+		epqh->phase=EPQH_READY;
+		#ifdef __EPQD_DESTROY_TIMEOUT__
+			del_timer(&epqh->destroy_timer);
+		#endif
+	}
+	select_eps(ltqhcd);
+	return 0;
+}
+
+/*!
+   \brief Aborts/cancels a USB transfer request. Always returns 0 to indicate
+  success.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+int ltqhcd_urb_dequeue(struct usb_hcd *_syshcd, struct urb *_urb)
+#else
+int ltqhcd_urb_dequeue(struct usb_hcd *_syshcd, struct urb *_urb, int status)
+#endif
+{
+	ltqhcd_hcd_t  *ltqhcd;
+	struct usb_host_endpoint *sysep;
+	ltqhcd_urbd_t *urbd;
+	ltqhcd_epqh_t *epqh;
+
+	#ifdef __DEBUG__
+		if (CHK_DEBUG_LEVEL(DBG_HCDV)
+		     || (usb_pipetype(_urb->pipe) == PIPE_CONTROL     && CHK_DEBUG_LEVEL(DBG_HCD_URB_CTRL))
+		     || (usb_pipetype(_urb->pipe) == PIPE_ISOCHRONOUS &&  usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_ISOC_IN))
+		     || (usb_pipetype(_urb->pipe) == PIPE_ISOCHRONOUS && !usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_ISOC_OUT))
+		     || (usb_pipetype(_urb->pipe) == PIPE_BULK        &&  usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_BULK_IN))
+		     || (usb_pipetype(_urb->pipe) == PIPE_BULK        && !usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_BULK_OUT))
+		     || (usb_pipetype(_urb->pipe) == PIPE_INTERRUPT   &&  usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_INTR_IN))
+		     || (usb_pipetype(_urb->pipe) == PIPE_INTERRUPT   && !usb_pipein(_urb->pipe) && CHK_DEBUG_LEVEL(DBG_HCD_URB_INTR_OUT))
+		    )
+			dump_urb_info(_urb, "ltqusb_hcd_urb_dequeue");
+	#endif //__DEBUG__
+	LTQ_DEBUGPL(DBG_HCD, "LTQUSB HCD URB Dequeue\n");
+	#if !defined(__EN_ISOC__)
+		if(usb_pipetype(_urb->pipe) == PIPE_ISOCHRONOUS)
+			return 0;
+	#endif
+
+	ltqhcd = syshcd_to_ltqhcd(_syshcd);
+
+	urbd = (ltqhcd_urbd_t *) _urb->hcpriv;
+	if(!urbd)
+	{
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+#ifdef NEWRET
+//			_urb->status=-ESHUTDOWN;//From xhci
+			_urb->status=-ECONNRESET;//From Linux URB doc
+#else
+			_urb->status=-ETIMEDOUT;
+#endif
+			usb_hcd_giveback_urb(_syshcd, _urb);
+		#else
+			usb_hcd_giveback_urb(_syshcd, _urb,status);
+		#endif
+		return 0;
+	}
+
+	urbd->cancelling=1;
+	sysep = ltqhcd_urb_to_endpoint(_urb);
+	if(sysep)
+	{
+		LOCK_EPQH_LIST_ALL(ltqhcd);
+		epqh = sysep_to_epqh(ltqhcd,sysep,0);
+		UNLOCK_EPQH_LIST_ALL(ltqhcd);
+		if(epqh!=urbd->epqh)
+		{
+			LTQ_ERROR("%s inconsistant epqh %p %p\n",__func__,epqh,urbd->epqh);
+			LTQ_ERROR("       sysep     : %p    %p\n",epqh->sysep, urbd->epqh->sysep);
+			LTQ_ERROR("       devno     : %8d    %8d\n",epqh->devno, urbd->epqh->devno);
+			LTQ_ERROR("       phase     : %8d    %8d\n",epqh->phase, urbd->epqh->phase);
+			LTQ_ERROR("       ep_type   : %8d    %8d\n",epqh->ep_type, urbd->epqh->ep_type);
+			LTQ_ERROR("       mps       : %8d    %8d\n",epqh->mps, urbd->epqh->mps);
+			LTQ_ERROR("       urbd_count: %8d    %8d\n",epqh->urbd_count, urbd->epqh->urbd_count);
+		}
+	}
+	else
+		epqh = (ltqhcd_epqh_t *) urbd->epqh;
+	if(!ltqhcd->flags.b.port_connect_status || !epqh)
+	{
+		urbd->phase=URBD_DEQUEUEING;
+		ltqhcd_complete_urb(ltqhcd, urbd, -ENODEV);
+	}
+	else if(  urbd->phase==URBD_IDLE
+		   || urbd->phase==URBD_ACTIVE
+		   )
+	{
+		urbd->phase=URBD_DEQUEUEING;
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+#ifdef NEWRET
+//				ltqhcd_complete_urb(ltqhcd, urbd, -ESHUTDOWN);//From xhci
+				ltqhcd_complete_urb(ltqhcd, urbd, -ECONNRESET);//From Linux URB doc
+#else
+				ltqhcd_complete_urb(ltqhcd, urbd, -ETIMEDOUT);
+#endif
+		#else
+			ltqhcd_complete_urb(ltqhcd, urbd, status);
+		#endif
+		ltqhcd_epqh_idle(epqh);
+	}
+	else if(   urbd->phase==URBD_RUNNING )
+	{
+		if(ltqhcd_hc_halt(&ltqhcd->core_if, urbd->hc, HC_XFER_URB_DEQUEUE))
+		{
+			urbd->phase=URBD_DEQUEUEING;
+			#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+#ifdef NEWRET
+//				ltqhcd_complete_urb(ltqhcd, urbd, -ESHUTDOWN);//From xhci
+				ltqhcd_complete_urb(ltqhcd, urbd, -ECONNRESET);//From Linux URB doc
+#else
+				ltqhcd_complete_urb(ltqhcd, urbd, -ETIMEDOUT);
+#endif
+			#else
+				ltqhcd_complete_urb(ltqhcd, urbd, status);
+			#endif
+			ltqhcd_epqh_idle(epqh);
+		}
+		else
+		{
+			#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+				urbd->cancelling_status=status;
+			#endif
+		}
+	}
+	return 0;
+}
+
+/*!
+   \brief Frees resources in the LTQUSB controller related to a given endpoint. Also
+  clears state in the HCD related to the endpoint. Any URBs for the endpoint
+  must already be dequeued.
+ */
+void ltqhcd_endpoint_disable( struct usb_hcd *_syshcd,
+                              struct usb_host_endpoint *_sysep)
+{
+	ltqhcd_hcd_t  *ltqhcd;
+	ltqhcd_epqh_t *epqh;
+
+	LTQ_DEBUGPL(DBG_HCD, "LTQUSB HCD EP DISABLE: _bEndpointAddress=0x%02x, "
+	    "endpoint=%d\n", _sysep->desc.bEndpointAddress,
+		    ltqhcd_ep_addr_to_endpoint(_sysep->desc.bEndpointAddress));
+
+	ltqhcd = syshcd_to_ltqhcd(_syshcd);
+
+	LOCK_EPQH_LIST_ALL(ltqhcd);
+	epqh = sysep_to_epqh(ltqhcd,_sysep,0);
+	UNLOCK_EPQH_LIST_ALL(ltqhcd);
+
+	if (!epqh)
+	{
+		return;
+	}
+	else
+	{
+		if (epqh->sysep!=_sysep)
+		{
+			LTQ_ERROR("%s inconsistant sysep %p %p %p\n",__func__,epqh,epqh->sysep,_sysep);
+			return;
+		}
+
+		epqh->phase=EPQH_DISABLING;
+#ifdef NEWRET
+//		kill_all_urbs_in_epqh(ltqhcd, epqh, -ESHUTDOWN);//From xhci
+		kill_all_urbs_in_epqh(ltqhcd, epqh, -ECONNRESET);//From Linux URB doc
+#else
+		kill_all_urbs_in_epqh(ltqhcd, epqh, -ETIMEDOUT);
+#endif
+		{
+			uint32_t count=0x80000;
+			for(;!list_empty(&epqh->urbd_list) && count> 0; count--) udelay(1);
+			if(!count)
+				LTQ_ERROR("%s: unable to clear urbd in epqh \n",__func__);
+		}
+		if(list_empty(&epqh->urbd_list) && list_empty(&epqh->release_list))
+			ltqhcd_epqh_free(epqh);
+	}
+	LTQ_DEBUGPL(DBG_HCD, "LTQUSB HCD EP DISABLE: done\n");
+}
+
+
+/*!
+  \brief Handles host mode interrupts for the LTQUSB controller. Returns IRQ_NONE if
+ there was no interrupt to handle. Returns IRQ_HANDLED if there was a valid
+ interrupt.
+
+ This function is called by the USB core when an interrupt occurs
+ */
+irqreturn_t ltqhcd_irq(struct usb_hcd *_syshcd)
+{
+	ltqhcd_hcd_t *ltqhcd = syshcd_to_ltqhcd (_syshcd);
+	int32_t retval=0;
+
+	//mask_and_ack_ltq_irq (ltqhcd->core_if.irq);
+	retval = ltqhcd_handle_intr(ltqhcd);
+	return  IRQ_HANDLED ;
+}
+
+
+
+/*!
+ \brief Creates Status Change bitmap for the root hub and root port. The bitmap is
+  returned in buf. Bit 0 is the status change indicator for the root hub. Bit 1
+  is the status change indicator for the single root port. Returns 1 if either
+  change indicator is 1, otherwise returns 0.
+ */
+int ltqhcd_hub_status_data(struct usb_hcd *_syshcd, char *_buf)
+{
+	ltqhcd_hcd_t *ltqhcd = syshcd_to_ltqhcd (_syshcd);
+
+	_buf[0] = 0;
+	_buf[0] |= (ltqhcd->flags.b.port_connect_status_change ||
+	            ltqhcd->flags.b.port_reset_change ||
+	            ltqhcd->flags.b.port_enable_change ||
+	            ltqhcd->flags.b.port_suspend_change ||
+	            ltqhcd->flags.b.port_over_current_change) << 1;
+
+	#ifdef __DEBUG__
+		if (_buf[0])
+		{
+			LTQ_DEBUGPL(DBG_HCD, "LTQUSB HCD HUB STATUS DATA:"
+				    " Root port status changed\n");
+			LTQ_DEBUGPL(DBG_HCDV, "  port_connect_status_change: %d\n",
+				    ltqhcd->flags.b.port_connect_status_change);
+			LTQ_DEBUGPL(DBG_HCDV, "  port_reset_change: %d\n",
+				    ltqhcd->flags.b.port_reset_change);
+			LTQ_DEBUGPL(DBG_HCDV, "  port_enable_change: %d\n",
+				    ltqhcd->flags.b.port_enable_change);
+			LTQ_DEBUGPL(DBG_HCDV, "  port_suspend_change: %d\n",
+				    ltqhcd->flags.b.port_suspend_change);
+			LTQ_DEBUGPL(DBG_HCDV, "  port_over_current_change: %d\n",
+				    ltqhcd->flags.b.port_over_current_change);
+			{
+				hprt0_data_t hprt0;
+				hprt0.d32 = ltqusb_rreg(ltqhcd->core_if.hprt0);
+				LTQ_DEBUGPL(DBG_HCDV, "  port reg :%08X\n",hprt0.d32);
+				LTQ_DEBUGPL(DBG_HCDV, "  port reg :connect: %d/%d\n",hprt0.b.prtconnsts,hprt0.b.prtconndet);
+				LTQ_DEBUGPL(DBG_HCDV, "  port reg :enable: %d/%d\n",hprt0.b.prtena,hprt0.b.prtenchng);
+				LTQ_DEBUGPL(DBG_HCDV, "  port reg :OC: %d/%d\n",hprt0.b.prtovrcurract,hprt0.b.prtovrcurrchng);
+				LTQ_DEBUGPL(DBG_HCDV, "  port reg :rsume/suspend(flag)/reset: %d/%d(%d)/%d\n",hprt0.b.prtres,hprt0.b.prtsusp,ltqhcd->core_if.issuspended,hprt0.b.prtrst);
+				LTQ_DEBUGPL(DBG_HCDV, "  port reg :port power: %d/\n",hprt0.b.prtpwr);
+				LTQ_DEBUGPL(DBG_HCDV, "  port reg :speed: %d/\n",hprt0.b.prtspd);
+			}
+		}
+	#endif //__DEBUG__
+	return (_buf[0] != 0);
+}
+
+#ifdef __WITH_HS_ELECT_TST__
+	extern void do_setup(ltqusb_core_if_t *_core_if) ;
+	extern void do_in_ack(ltqusb_core_if_t *_core_if);
+#endif //__WITH_HS_ELECT_TST__
+
+/*!
+ \brief Handles hub class-specific requests.
+ */
+int ltqhcd_hub_control( struct usb_hcd *_syshcd,
+                        u16             _typeReq,
+                        u16             _wValue,
+                        u16             _wIndex,
+                        char           *_buf,
+                        u16             _wLength)
+{
+	int retval = 0;
+
+	ltqhcd_hcd_t              *ltqhcd  = syshcd_to_ltqhcd (_syshcd);
+	ltqusb_core_if_t          *core_if = &ltqhcd->core_if;
+	struct usb_hub_descriptor *desc;
+	hprt0_data_t               hprt0 = {.d32 = 0};
+
+	uint32_t port_status;
+
+	switch (_typeReq)
+	{
+		case ClearHubFeature:
+			LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+			         "ClearHubFeature 0x%x\n", _wValue);
+			switch (_wValue)
+			{
+				case C_HUB_LOCAL_POWER:
+				case C_HUB_OVER_CURRENT:
+					/* Nothing required here */
+					break;
+				default:
+					retval = -EINVAL;
+					LTQ_ERROR ("LTQUSB HCD - "
+						   "ClearHubFeature request %xh unknown\n", _wValue);
+			}
+			break;
+		case ClearPortFeature:
+			if (!_wIndex || _wIndex > 1)
+				goto error;
+
+			switch (_wValue)
+			{
+				case USB_PORT_FEAT_ENABLE:
+					LTQ_DEBUGPL (DBG_ANY, "LTQUSB HCD HUB CONTROL - "
+						     "ClearPortFeature USB_PORT_FEAT_ENABLE\n");
+					hprt0.d32 = ltqusb_read_hprt0 (core_if);
+					hprt0.b.prtena = 1;
+					ltqusb_wreg(core_if->hprt0, hprt0.d32);
+					break;
+				case USB_PORT_FEAT_SUSPEND:
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+						     "ClearPortFeature USB_PORT_FEAT_SUSPEND\n");
+					hprt0.d32 = ltqusb_read_hprt0 (core_if);
+					hprt0.b.prtres = 1;
+					ltqusb_wreg(core_if->hprt0, hprt0.d32);
+					/* Clear Resume bit */
+					mdelay (100);
+					hprt0.b.prtres = 0;
+					ltqusb_wreg(core_if->hprt0, hprt0.d32);
+					core_if->issuspended=0;
+					break;
+				case USB_PORT_FEAT_POWER:
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+						     "ClearPortFeature USB_PORT_FEAT_POWER\n");
+					ltqusb_vbus_off(ltqhcd);
+					hprt0.d32 = ltqusb_read_hprt0 (core_if);
+					hprt0.b.prtpwr = 0;
+					ltqusb_wreg(core_if->hprt0, hprt0.d32);
+					break;
+				case USB_PORT_FEAT_INDICATOR:
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+						     "ClearPortFeature USB_PORT_FEAT_INDICATOR\n");
+					/* Port inidicator not supported */
+					break;
+				case USB_PORT_FEAT_C_CONNECTION:
+					/* Clears drivers internal connect status change
+					 * flag */
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+						     "ClearPortFeature USB_PORT_FEAT_C_CONNECTION\n");
+					ltqhcd->flags.b.port_connect_status_change = 0;
+					break;
+				case USB_PORT_FEAT_C_RESET:
+					/* Clears the driver's internal Port Reset Change
+					 * flag */
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+						     "ClearPortFeature USB_PORT_FEAT_C_RESET\n");
+					ltqhcd->flags.b.port_reset_change = 0;
+					break;
+				case USB_PORT_FEAT_C_ENABLE:
+					/* Clears the driver's internal Port
+					 * Enable/Disable Change flag */
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+						     "ClearPortFeature USB_PORT_FEAT_C_ENABLE\n");
+					ltqhcd->flags.b.port_enable_change = 0;
+					break;
+				case USB_PORT_FEAT_C_SUSPEND:
+					/* Clears the driver's internal Port Suspend
+					 * Change flag, which is set when resume signaling on
+					 * the host port is complete */
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+						     "ClearPortFeature USB_PORT_FEAT_C_SUSPEND\n");
+					ltqhcd->flags.b.port_suspend_change = 0;
+					break;
+				case USB_PORT_FEAT_C_OVER_CURRENT:
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+						     "ClearPortFeature USB_PORT_FEAT_C_OVER_CURRENT\n");
+					ltqhcd->flags.b.port_over_current_change = 0;
+					break;
+				default:
+					retval = -EINVAL;
+					LTQ_ERROR ("LTQUSB HCD - "
+					         "ClearPortFeature request %xh "
+					         "unknown or unsupported\n", _wValue);
+			}
+			break;
+		case GetHubDescriptor:
+			LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+			         "GetHubDescriptor\n");
+			desc = (struct usb_hub_descriptor *)_buf;
+			desc->bDescLength = 9;
+			desc->bDescriptorType = 0x29;
+			desc->bNbrPorts = 1;
+			desc->wHubCharacteristics = 0x08;
+			desc->bPwrOn2PwrGood = 1;
+			desc->bHubContrCurrent = 0;
+			desc->u.hs.DeviceRemovable[0] = 0;
+			desc->u.hs.DeviceRemovable[1] = 0xff;
+			break;
+		case GetHubStatus:
+			LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+			         "GetHubStatus\n");
+			memset (_buf, 0, 4);
+			break;
+		case GetPortStatus:
+			LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+			         "GetPortStatus\n");
+			if (!_wIndex || _wIndex > 1)
+				goto error;
+			port_status = 0;
+			if (ltqhcd->flags.b.port_connect_status_change)
+				port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
+			if (ltqhcd->flags.b.port_enable_change)
+				port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
+			if (ltqhcd->flags.b.port_suspend_change)
+				port_status |= (1 << USB_PORT_FEAT_C_SUSPEND);
+			if (ltqhcd->flags.b.port_reset_change)
+				port_status |= (1 << USB_PORT_FEAT_C_RESET);
+			if (ltqhcd->flags.b.port_over_current_change)
+			{
+				LTQ_ERROR("Device Not Supported\n");
+				port_status |= (1 << USB_PORT_FEAT_C_OVER_CURRENT);
+			}
+			if (!ltqhcd->flags.b.port_connect_status)
+			{
+				/*
+				 * The port is disconnected, which means the core is
+				 * either in device mode or it soon will be. Just
+				 * return 0's for the remainder of the port status
+				 * since the port register can't be read if the core
+				 * is in device mode.
+				 */
+				*((u32 *) _buf) = cpu_to_le32(port_status);
+				break;
+			}
+
+			hprt0.d32 = ltqusb_rreg(core_if->hprt0);
+			LTQ_DEBUGPL(DBG_HCDV, "  HPRT0: 0x%08x\n", hprt0.d32);
+			if (hprt0.b.prtconnsts)
+				port_status |= (1 << USB_PORT_FEAT_CONNECTION);
+			if (hprt0.b.prtena)
+			{
+				ltqhcd->disconnecting=0;
+				port_status |= (1 << USB_PORT_FEAT_ENABLE);
+			}
+//			if (hprt0.b.prtsusp)
+			if (core_if->issuspended)
+				port_status |= (1 << USB_PORT_FEAT_SUSPEND);
+			if (hprt0.b.prtovrcurract)
+				port_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);
+			if (hprt0.b.prtrst)
+				port_status |= (1 << USB_PORT_FEAT_RESET);
+			if (hprt0.b.prtpwr)
+				port_status |= (1 << USB_PORT_FEAT_POWER);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
+			if      (hprt0.b.prtspd == LTQUSB_HPRT0_PRTSPD_HIGH_SPEED)
+				port_status |= USB_PORT_STAT_HIGH_SPEED;
+			else if (hprt0.b.prtspd == LTQUSB_HPRT0_PRTSPD_LOW_SPEED)
+				port_status |= USB_PORT_STAT_LOW_SPEED;
+#else
+			if      (hprt0.b.prtspd == LTQUSB_HPRT0_PRTSPD_HIGH_SPEED)
+				port_status |= (1 << USB_PORT_FEAT_HIGHSPEED);
+			else if (hprt0.b.prtspd == LTQUSB_HPRT0_PRTSPD_LOW_SPEED)
+				port_status |= (1 << USB_PORT_FEAT_LOWSPEED);
+#endif
+			if (hprt0.b.prttstctl)
+				port_status |= (1 << USB_PORT_FEAT_TEST);
+			/* USB_PORT_FEAT_INDICATOR unsupported always 0 */
+			*((u32 *) _buf) = cpu_to_le32(port_status);
+			break;
+		case SetHubFeature:
+			LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+			         "SetHubFeature\n");
+			/* No HUB features supported */
+			break;
+		case SetPortFeature:
+			if (_wValue != USB_PORT_FEAT_TEST && (!_wIndex || _wIndex > 1))
+				goto error;
+			/*
+			 * The port is disconnected, which means the core is
+			 * either in device mode or it soon will be. Just
+			 * return without doing anything since the port
+			 * register can't be written if the core is in device
+			 * mode.
+			 */
+			 if(_wValue==USB_PORT_FEAT_POWER && !core_if->issuspended)
+			 {
+				LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+				     "SetPortFeature - USB_PORT_FEAT_POWER\n");
+				ltqusb_vbus_on (ltqhcd);
+				hprt0.d32 = ltqusb_read_hprt0 (core_if);
+				hprt0.b.prtpwr = 1;
+				ltqusb_wreg(core_if->hprt0, hprt0.d32);
+				break;
+			}
+			if (!ltqhcd->flags.b.port_connect_status)
+				break;
+			switch (_wValue)
+			{
+				case USB_PORT_FEAT_SUSPEND:
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+						     "SetPortFeature - USB_PORT_FEAT_SUSPEND\n");
+					hprt0.d32 = ltqusb_read_hprt0 (core_if);
+					hprt0.b.prtsusp = 1;
+					ltqusb_wreg(core_if->hprt0, hprt0.d32);
+					//LTQ_PRINT( "SUSPEND: HPRT0=%0x\n", hprt0.d32);
+					/* Suspend the Phy Clock */
+					{
+						pcgcctl_data_t pcgcctl = {.d32=0};
+						pcgcctl.b.stoppclk = 1;
+						ltqusb_wreg(core_if->pcgcctl, pcgcctl.d32);
+					}
+					core_if->issuspended=1;
+					break;
+#if 0
+				case USB_PORT_FEAT_POWER:
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+					     "SetPortFeature - USB_PORT_FEAT_POWER\n");
+					ltqusb_vbus_on (ltqhcd);
+					hprt0.d32 = ltqusb_read_hprt0 (core_if);
+					hprt0.b.prtpwr = 1;
+					ltqusb_wreg(core_if->hprt0, hprt0.d32);
+					break;
+#endif
+				case USB_PORT_FEAT_RESET:
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+						     "SetPortFeature - USB_PORT_FEAT_RESET\n");
+					hprt0.d32 = ltqusb_read_hprt0 (core_if);
+					hprt0.b.prtrst = 1;
+					ltqusb_wreg(core_if->hprt0, hprt0.d32);
+					/* Clear reset bit in 10ms (FS/LS) or 50ms (HS) */
+					MDELAY (60);
+					hprt0.b.prtrst = 0;
+					ltqusb_wreg(core_if->hprt0, hprt0.d32);
+					break;
+			#ifdef __WITH_HS_ELECT_TST__
+				case USB_PORT_FEAT_TEST:
+					{
+						uint32_t t;
+						gint_data_t gintmsk;
+						t = (_wIndex >> 8); /* MSB wIndex USB */
+						LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+							     "SetPortFeature - USB_PORT_FEAT_TEST %d\n", t);
+						warn("USB_PORT_FEAT_TEST\n");
+						if (t < 6)
+						{
+							hprt0.d32 = ltqusb_read_hprt0 (core_if);
+							hprt0.b.prttstctl = t;
+							ltqusb_wreg(core_if->hprt0, hprt0.d32);
+						}
+						else if (t == 6)  /* HS_HOST_PORT_SUSPEND_RESUME */
+						{
+							/* Save current interrupt mask */
+							gintmsk.d32 = ltqusb_rreg(&core_if->core_global_regs->gintmsk);
+
+							/* Disable all interrupts while we muck with
+							 * the hardware directly
+							 */
+							ltqusb_wreg(&core_if->core_global_regs->gintmsk, 0);
+
+							/* 15 second delay per the test spec */
+							mdelay(15000);
+
+							/* Drive suspend on the root port */
+							hprt0.d32 = ltqusb_read_hprt0 (core_if);
+							hprt0.b.prtsusp = 1;
+							hprt0.b.prtres = 0;
+							ltqusb_wreg(core_if->hprt0, hprt0.d32);
+
+							/* 15 second delay per the test spec */
+							mdelay(15000);
+
+							/* Drive resume on the root port */
+							hprt0.d32 = ltqusb_read_hprt0 (core_if);
+							hprt0.b.prtsusp = 0;
+							hprt0.b.prtres = 1;
+							ltqusb_wreg(core_if->hprt0, hprt0.d32);
+							mdelay(100);
+
+							/* Clear the resume bit */
+							hprt0.b.prtres = 0;
+							ltqusb_wreg(core_if->hprt0, hprt0.d32);
+
+							/* Restore interrupts */
+							ltqusb_wreg(&core_if->core_global_regs->gintmsk, gintmsk.d32);
+						}
+						else if (t == 7)  /* SINGLE_STEP_GET_DEVICE_DESCRIPTOR setup */
+						{
+							/* Save current interrupt mask */
+							gintmsk.d32 = ltqusb_rreg(&core_if->core_global_regs->gintmsk);
+
+							/* Disable all interrupts while we muck with
+							 * the hardware directly
+							 */
+							ltqusb_wreg(&core_if->core_global_regs->gintmsk, 0);
+
+							/* 15 second delay per the test spec */
+							mdelay(15000);
+
+							/* Send the Setup packet */
+							do_setup(core_if);
+
+							/* 15 second delay so nothing else happens for awhile */
+							mdelay(15000);
+
+							/* Restore interrupts */
+							ltqusb_wreg(&core_if->core_global_regs->gintmsk, gintmsk.d32);
+						}
+
+						else if (t == 8)  /* SINGLE_STEP_GET_DEVICE_DESCRIPTOR execute */
+						{
+							/* Save current interrupt mask */
+							gintmsk.d32 = ltqusb_rreg(&core_if->core_global_regs->gintmsk);
+
+							/* Disable all interrupts while we muck with
+							 * the hardware directly
+							 */
+							ltqusb_wreg(&core_if->core_global_regs->gintmsk, 0);
+
+							/* Send the Setup packet */
+							do_setup(core_if);
+
+							/* 15 second delay so nothing else happens for awhile */
+							mdelay(15000);
+
+							/* Send the In and Ack packets */
+							do_in_ack(core_if);
+
+							/* 15 second delay so nothing else happens for awhile */
+							mdelay(15000);
+
+							/* Restore interrupts */
+							ltqusb_wreg(&core_if->core_global_regs->gintmsk, gintmsk.d32);
+						}
+					}
+					break;
+			#endif //__WITH_HS_ELECT_TST__
+				case USB_PORT_FEAT_INDICATOR:
+					LTQ_DEBUGPL (DBG_HCD, "LTQUSB HCD HUB CONTROL - "
+						     "SetPortFeature - USB_PORT_FEAT_INDICATOR\n");
+					/* Not supported */
+					break;
+				default:
+					retval = -EINVAL;
+					LTQ_ERROR ("LTQUSB HCD - "
+						   "SetPortFeature request %xh "
+						   "unknown or unsupported\n", _wValue);
+			}
+			break;
+		default:
+		error:
+			retval = -EINVAL;
+			LTQ_WARN ("LTQUSB HCD - "
+			          "Unknown hub control request type or invalid typeReq: %xh wIndex: %xh wValue: %xh\n",
+			          _typeReq, _wIndex, _wValue);
+	}
+	return retval;
+}
+
+
+
+
+/*!
+   \brief This function trigger a data transfer for a host channel and
+  starts the transfer.
+
+  For a PING transfer in Slave mode, the Do Ping bit is set in the HCTSIZ
+  register along with a packet count of 1 and the channel is enabled. This
+  causes a single PING transaction to occur. Other fields in HCTSIZ are
+  simply set to 0 since no data transfer occurs in this case.
+
+  For a PING transfer in DMA mode, the HCTSIZ register is initialized with
+  all the information required to perform the subsequent data transfer. In
+  addition, the Do Ping bit is set in the HCTSIZ register. In this case, the
+  controller performs the entire PING protocol, then starts the data
+  transfer.
+  \param _core_if        Pointer of core_if structure
+  \param _ltqhc Information needed to initialize the host channel. The xfer_len
+  value may be reduced to accommodate the max widths of the XferSize and
+  PktCnt fields in the HCTSIZn register. The multi_count value may be changed
+  to reflect the final xfer_len value.
+ */
+void ltqhcd_hc_start(ltqhcd_hcd_t *_ltqhcd, ltqhcd_hc_t *_ltqhc, uint8_t do_now)
+{
+	ltqusb_core_if_t *core_if = &_ltqhcd->core_if;
+	uint32_t max_hc_xfer_size = core_if->params.max_transfer_size;
+	uint16_t max_hc_pkt_count = core_if->params.max_packet_count;
+	ltqusb_hc_regs_t *hc_regs = core_if->hc_regs[_ltqhc->hc_num];
+	hfnum_data_t hfnum;
+	int new_phase=HC_WAITING;
+
+	_ltqhc->phase=HC_WAITING2;
+	if(_ltqhc->cancelling || _ltqhc->urbd->cancelling || _ltqhc->urbd->phase==URBD_DEQUEUEING)
+	{
+		_ltqhc->phase=new_phase;
+		return;
+	}
+
+	_ltqhc->urbd->phase=URBD_RUNNING;
+
+	if(max_hc_pkt_count * _ltqhc->mps <  max_hc_xfer_size)
+		max_hc_xfer_size = max_hc_pkt_count * _ltqhc->mps;
+
+	if(_ltqhc->is_in || _ltqhc->speed != LTQUSB_EP_SPEED_HIGH || _ltqhc->xfer_len==0)
+		_ltqhc->epqh->do_ping=0;
+	if(_ltqhc->ep_type == LTQUSB_EP_TYPE_INTR || _ltqhc->ep_type == LTQUSB_EP_TYPE_ISOC)
+		_ltqhc->epqh->do_ping=0;
+	if(_ltqhc->ep_type == LTQUSB_EP_TYPE_CTRL && _ltqhc->control_phase != LTQHCD_CONTROL_DATA  )
+		_ltqhc->epqh->do_ping=0;
+
+#ifdef __NO_BULK_PING__
+	if(_ltqhc->ep_type == LTQUSB_EP_TYPE_BULK  )
+		_ltqhc->epqh->do_ping=0;
+#endif
+
+	if (_ltqhc->split > 0)
+	{
+		_ltqhc->start_pkt_count = 1;
+		if(!_ltqhc->is_in && _ltqhc->split>1) // OUT CSPLIT
+			_ltqhc->xfer_len = 0;
+		if (_ltqhc->xfer_len > _ltqhc->mps)
+			_ltqhc->xfer_len = _ltqhc->mps;
+		if (_ltqhc->xfer_len > 188)
+			_ltqhc->xfer_len = 188;
+	}
+	else if(_ltqhc->is_in)
+	{
+		_ltqhc->short_rw = 0;
+		if(_ltqhcd->singlexact)
+			_ltqhc->start_pkt_count = 1;
+		else if (_ltqhc->xfer_len > 0)
+		{
+			if (_ltqhc->xfer_len > max_hc_xfer_size)
+				_ltqhc->xfer_len = max_hc_xfer_size - _ltqhc->mps + 1;
+			_ltqhc->start_pkt_count = (_ltqhc->xfer_len + _ltqhc->mps - 1) / _ltqhc->mps;
+			if (_ltqhc->start_pkt_count > max_hc_pkt_count)
+				_ltqhc->start_pkt_count = max_hc_pkt_count;
+		}
+		else /* Need 1 packet for transfer length of 0. */
+			_ltqhc->start_pkt_count = 1;
+		_ltqhc->xfer_len = _ltqhc->start_pkt_count * _ltqhc->mps;
+	}
+	else //non-split out
+	{
+		if (_ltqhc->xfer_len == 0)
+		{
+			if(_ltqhc->short_rw==0)
+				printk(KERN_INFO "Info: %s() line %d: ZLP write without short_rw set! xfer_count:%d/%d \n",__func__,__LINE__,
+					_ltqhc->xfer_count,
+					_ltqhc->urbd->xfer_len);
+			_ltqhc->start_pkt_count = 1;
+		}
+		else
+		{
+			if(_ltqhcd->singlexact)
+			{
+				_ltqhc->start_pkt_count = 1;
+				if (_ltqhc->xfer_len > _ltqhc->mps)
+					_ltqhc->xfer_len = _ltqhc->mps;
+			}
+			else if (_ltqhc->xfer_len > max_hc_xfer_size)
+			{
+				_ltqhc->start_pkt_count = (max_hc_xfer_size / _ltqhc->mps);
+				_ltqhc->xfer_len = _ltqhc->start_pkt_count * _ltqhc->mps;
+			}
+			else
+			{
+				_ltqhc->start_pkt_count = (_ltqhc->xfer_len+_ltqhc->mps-1)  / _ltqhc->mps;
+//				if(_ltqhc->start_pkt_count * _ltqhc->mps == _ltqhc->xfer_len )
+//					_ltqhc->start_pkt_count += _ltqhc->short_rw;
+			}
+		}
+	}
+
+	#ifdef __EN_ISOC__
+		if (_ltqhc->ep_type == LTQUSB_EP_TYPE_ISOC)
+		{
+			/* Set up the initial PID for the transfer. */
+			#if 1
+				_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA0;
+			#else
+				if (_ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+				{
+					if (_ltqhc->is_in)
+					{
+						if      (_ltqhc->multi_count == 1)
+							_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA0;
+						else if (_ltqhc->multi_count == 2)
+							_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA1;
+						else
+							_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA2;
+					}
+					else
+					{
+						if (_ltqhc->multi_count == 1)
+							_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA0;
+						else
+							_ltqhc->data_pid_start = LTQUSB_HC_PID_MDATA;
+					}
+				}
+				else
+					_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA0;
+			#endif
+		}
+	#endif
+
+	LTQ_DEBUGPL(DBG_HCDV, "%s: Channel %d\n", __func__, _ltqhc->hc_num);
+	{
+		hctsiz_data_t hctsiz= { .d32=0 };
+
+		hctsiz.b.dopng = _ltqhc->epqh->do_ping;
+		_ltqhc->epqh->do_ping=0;
+
+		hctsiz.b.xfersize = _ltqhc->xfer_len;
+		hctsiz.b.pktcnt   = _ltqhc->start_pkt_count;
+		hctsiz.b.pid      = _ltqhc->data_pid_start;
+		ltqusb_wreg(&hc_regs->hctsiz, hctsiz.d32);
+
+		LTQ_DEBUGPL(DBG_HCDV, "  Xfer Size: %d\n", hctsiz.b.xfersize);
+		LTQ_DEBUGPL(DBG_HCDV, "  Num Pkts: %d\n" , hctsiz.b.pktcnt);
+		LTQ_DEBUGPL(DBG_HCDV, "  Start PID: %d\n", hctsiz.b.pid);
+
+		LTQ_DEBUGPL(DBG_HCDV, "  Start PID: %d\n", hctsiz.b.pid);
+	}
+	LTQ_DEBUGPL(DBG_HCDV, "  DMA: 0x%08x\n", (uint32_t)(CPHYSADDR( ((uint32_t)(_ltqhc->xfer_buff))+ _ltqhc->xfer_count )));
+	ltqusb_wreg(&hc_regs->hcdma, (uint32_t)(CPHYSADDR( ((uint32_t)(_ltqhc->xfer_buff))+ _ltqhc->xfer_count )));
+
+	/* Start the split */
+	if (_ltqhc->split>0)
+	{
+		hcsplt_data_t hcsplt;
+		hcsplt.d32 = ltqusb_rreg (&hc_regs->hcsplt);
+		hcsplt.b.spltena = 1;
+		if (_ltqhc->split>1)
+			hcsplt.b.compsplt = 1;
+		else
+			hcsplt.b.compsplt = 0;
+
+		#if defined(__EN_ISOC__) && defined(__EN_ISOC_SPLIT__)
+			if (_ltqhc->ep_type == LTQUSB_EP_TYPE_ISOC)
+				hcsplt.b.xactpos = _ltqhc->isoc_xact_pos;
+			else
+		#endif
+		hcsplt.b.xactpos = LTQUSB_HCSPLIT_XACTPOS_ALL;// if not ISO
+		ltqusb_wreg(&hc_regs->hcsplt, hcsplt.d32);
+		LTQ_DEBUGPL(DBG_HCDV, "  SPLIT: XACT_POS:0x%08x\n", hcsplt.d32);
+	}
+
+	{
+		hcchar_data_t hcchar;
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+//		hcchar.b.multicnt = _ltqhc->multi_count;
+		hcchar.b.multicnt = 1;
+
+		if (_ltqhc->ep_type == LTQUSB_EP_TYPE_INTR || _ltqhc->ep_type == LTQUSB_EP_TYPE_ISOC)
+		{
+			hfnum.d32 = ltqusb_rreg(&core_if->host_global_regs->hfnum);
+			/* 1 if _next_ frame is odd, 0 if it's even */
+			hcchar.b.oddfrm = (hfnum.b.frnum & 0x1) ? 0 : 1;
+		}
+
+		#ifdef __DEBUG__
+			_ltqhc->start_hcchar_val = hcchar.d32;
+			if (hcchar.b.chdis)
+				LTQ_WARN("%s: chdis set, channel %d, hcchar 0x%08x\n",
+					 __func__, _ltqhc->hc_num, hcchar.d32);
+		#endif
+
+		/* Set host channel enable after all other setup is complete. */
+		hcchar.b.chen  = 1;
+		hcchar.b.chdis = 0;
+		hcchar.b.epdir =  _ltqhc->is_in;
+		_ltqhc->hcchar=hcchar.d32;
+	}
+
+	LTQ_DEBUGPL(DBG_HCDV, "  HCCHART: 0x%08x\n", _ltqhc->hcchar);
+
+	if (_ltqhc->ep_type == LTQUSB_EP_TYPE_ISOC || _ltqhc->ep_type == LTQUSB_EP_TYPE_INTR )
+		new_phase=HC_STARTING_HIGH;
+	else
+		new_phase=HC_STARTING;
+
+	if(do_now)
+	{
+		hcint_data_t      hcint;
+		hfnum_data_t hfnum;
+		hfnum.d32 = ltqusb_rreg(&_ltqhcd->core_if.host_global_regs->hfnum);
+		if(hfnum.b.frrem>_ltqhcd->xfer_prot1_value)
+		{
+			_ltqhc->erron=0;
+			hcint.d32 =0xFFFFFFFF;
+			ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+			hcint.d32 =ltqusb_rreg(&hc_regs->hcintmsk);
+			hcint.b.nak =0;
+			hcint.b.ack =0;
+			hcint.b.nyet=0;
+			if(_ltqhc->erron)
+			{
+				hcint.b.ack  =1;
+				hcint.b.nak  =1;
+				hcint.b.nyet =1;
+			}
+			if(!_ltqhc->cancelling)
+			{
+				ltqusb_wreg(&hc_regs->hcintmsk, hcint.d32);
+				ltqusb_wreg(&hc_regs->hcchar, _ltqhc->hcchar);
+				_ltqhc->phase=HC_STARTED;
+				return;
+			}
+		}
+		else if(hrtimer_try_to_cancel(&_ltqhcd->xfer_stopper_timer)!=-1)
+			ltqhcd_xfer_stopper(_ltqhcd);
+	}
+	_ltqhc->phase=new_phase;
+}
+
+/*!
+   \brief Attempts to halt a host channel. This function should only be called
+  to abort a transfer in DMA mode. Under normal circumstances in DMA mode, the
+  controller halts the channel when the transfer is complete or a condition
+  occurs that requires application intervention.
+
+  In DMA mode, always sets the Channel Enable and Channel Disable bits of the
+  HCCHARn register. The controller ensures there is space in the request
+  queue before submitting the halt request.
+
+  Some time may elapse before the core flushes any posted requests for this
+  host channel and halts. The Channel Halted interrupt handler completes the
+  deactivation of the host channel.
+ */
+
+int ltqhcd_hc_halt(ltqusb_core_if_t *_core_if,
+                    ltqhcd_hc_t *_ltqhc,
+                    ltqhcd_halt_status_e _halt_status)
+{
+	hcchar_data_t   hcchar;
+	ltqusb_hc_regs_t           *hc_regs;
+	if(!_ltqhc)   return -1;
+	if(!_core_if) return -1;
+	hc_regs          = _core_if->hc_regs[_ltqhc->hc_num];
+
+	WARN_ON(_halt_status == HC_XFER_NO_HALT_STATUS);
+
+	_ltqhc->cancelling=1;
+	{
+		hprt0_data_t hprt0;
+		hprt0.d32 = ltqusb_rreg(_core_if->hprt0);
+		if(hprt0.b.prtena == 0)
+			return -1;
+	}
+
+	if (_halt_status == HC_XFER_URB_DEQUEUE ||
+	    _halt_status == HC_XFER_AHB_ERR)
+	{
+		/*
+		 * Disable all channel interrupts except Ch Halted. The URBD
+		 * and EPQH state associated with this transfer has been cleared
+		 * (in the case of URB_DEQUEUE), so the channel needs to be
+		 * shut down carefully to prevent crashes.
+		 */
+		hcint_data_t hcintmsk;
+		hcintmsk.d32 = 0;
+		hcintmsk.b.chhltd = 1;
+		ltqusb_wreg(&hc_regs->hcintmsk, hcintmsk.d32);
+
+		/*
+		 * Make sure no other interrupts besides halt are currently
+		 * pending. Handling another interrupt could cause a crash due
+		 * to the URBD and EPQH state.
+		 */
+		ltqusb_wreg(&hc_regs->hcint, ~hcintmsk.d32);
+
+		/*
+		 * Make sure the halt status is set to URB_DEQUEUE or AHB_ERR
+		 * even if the channel was already halted for some other
+		 * reason.
+		 */
+		_ltqhc->halt_status = _halt_status;
+	}
+	if (_ltqhc->phase==HC_STOPPING)
+	{
+		/*
+		 * A halt has already been issued for this channel. This might
+		 * happen when a transfer is aborted by a higher level in
+		 * the stack.
+		 */
+		#ifdef __DEBUG__
+			LTQ_PRINT("*** %s: Channel %d, double halt a channel***\n",
+				  __func__, _ltqhc->hc_num);
+		#endif
+		return 0;
+	}
+
+	hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+	if (hcchar.b.chen == 0)
+	{
+		_ltqhc->cancelling=0;
+		/*
+		 * The channel is either already halted or it hasn't
+		 * started yet. In DMA mode, the transfer may halt if
+		 * it finishes normally or a condition occurs that
+		 * requires driver intervention. Don't want to halt
+		 * the channel again. In either Slave or DMA mode,
+		 * it's possible that the transfer has been assigned
+		 * to a channel, but not started yet when an URB is
+		 * dequeued. Don't want to halt a channel that hasn't
+		 * started yet.
+		 */
+		if (_ltqhc->phase==HC_STARTED)
+			return 0;
+		if (_ltqhc->phase==HC_STOPPED)
+			return 0;
+		_ltqhc->phase=HC_IDLE;
+		return -1;
+	}
+	_ltqhc->phase=HC_STOPPING;
+
+//	hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+//	hcchar.b.chen = 1;
+	hcchar.b.chdis = 1;
+	ltqusb_wreg(&hc_regs->hcchar, hcchar.d32);
+
+	_ltqhc->halt_status = _halt_status;
+
+	LTQ_DEBUGPL(DBG_HCDV, "%s: Channel %d\n" , __func__, _ltqhc->hc_num);
+	LTQ_DEBUGPL(DBG_HCDV, "  hcchar: 0x%08x\n"   , hcchar.d32);
+	LTQ_DEBUGPL(DBG_HCDV, "  halt_status: %d\n"  , _ltqhc->halt_status);
+	return 0;
+}
+
+/*!
+   \brief Clears a host channel.
+ */
+void ltqhcd_hc_cleanup(ltqusb_core_if_t *_core_if, ltqhcd_hc_t *_ltqhc)
+{
+	ltqusb_hc_regs_t *hc_regs;
+
+	_ltqhc->phase=HC_IDLE;
+	_ltqhc->epqh=0;
+	_ltqhc->urbd=0;
+	_ltqhc->cancelling=0;
+	_ltqhc->stopping=0;
+
+	/*
+	 * Clear channel interrupt enables and any unhandled channel interrupt
+	 * conditions.
+	 */
+	hc_regs = _core_if->hc_regs[_ltqhc->hc_num];
+	ltqusb_wreg(&hc_regs->hcintmsk, 0);
+	ltqusb_wreg(&hc_regs->hcint, 0xFFFFFFFF);
+
+	#ifdef __DEBUG__
+		{
+			hcchar_data_t hcchar;
+			hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+			if (hcchar.b.chdis)
+				LTQ_WARN("%s: chdis set, channel %d, hcchar 0x%08x\n", __func__, _ltqhc->hc_num, hcchar.d32);
+		}
+	#endif
+}
+
+
+
+
+
+#ifdef __DEBUG__
+	static
+	void dump_urb_info(struct urb *_urb, char* _fn_name)
+	{
+		LTQ_PRINT("%s, urb %p\n"          , _fn_name, _urb);
+		LTQ_PRINT("  Device address: %d\n", usb_pipedevice(_urb->pipe));
+		LTQ_PRINT("  Endpoint: %d, %s\n"  , usb_pipeendpoint(_urb->pipe),
+		                                    (usb_pipein(_urb->pipe) ? "IN" : "OUT"));
+		LTQ_PRINT("  Endpoint type: %s\n",
+		    ({	char *pipetype;
+		    	switch (usb_pipetype(_urb->pipe)) {
+		    		case PIPE_CONTROL:     pipetype = "CONTROL"; break;
+		    		case PIPE_BULK:        pipetype = "BULK"; break;
+		    		case PIPE_INTERRUPT:   pipetype = "INTERRUPT"; break;
+		    		case PIPE_ISOCHRONOUS: pipetype = "ISOCHRONOUS"; break;
+		    		default:               pipetype = "UNKNOWN"; break;
+		    	};
+		    	pipetype;
+		    }));
+		LTQ_PRINT("  Speed: %s\n",
+		    ({	char *speed;
+		    	switch (_urb->dev->speed) {
+		    		case USB_SPEED_HIGH: speed = "HIGH"; break;
+		    		case USB_SPEED_FULL: speed = "FULL"; break;
+		    		case USB_SPEED_LOW:  speed = "LOW"; break;
+		    		default:             speed = "UNKNOWN"; break;
+		    	};
+		    	speed;
+		    }));
+		LTQ_PRINT("  Max packet size: %d\n",
+			  usb_maxpacket(_urb->dev, _urb->pipe, usb_pipeout(_urb->pipe)));
+		LTQ_PRINT("  Data buffer length: %d\n", _urb->transfer_buffer_length);
+		LTQ_PRINT("  Transfer buffer: %p, Transfer DMA: %p\n",
+			  _urb->transfer_buffer, (void *)_urb->transfer_dma);
+		LTQ_PRINT("  Setup buffer: %p, Setup DMA: %p\n",
+			  _urb->setup_packet, (void *)_urb->setup_dma);
+		LTQ_PRINT("  Interval: %d\n", _urb->interval);
+		if (usb_pipetype(_urb->pipe) == PIPE_ISOCHRONOUS)
+		{
+			int i;
+			for (i = 0; i < _urb->number_of_packets;  i++)
+			{
+				LTQ_PRINT("  ISO Desc %d:\n", i);
+				LTQ_PRINT("    offset: %d, length %d\n",
+				    _urb->iso_frame_desc[i].offset,
+				    _urb->iso_frame_desc[i].length);
+			}
+		}
+	}
+
+#if 0
+	static
+	void dump_channel_info(ltqhcd_hcd_t *_ltqhcd, ltqhcd_hc_t *_ltqhc)
+	{
+		if (_ltqhc != NULL)
+		{
+			ltqusb_hc_regs_t *hc_regs;
+
+			hcchar_data_t  hcchar;
+			hcsplt_data_t  hcsplt;
+			hctsiz_data_t  hctsiz;
+			uint32_t       hcdma;
+
+			hc_regs = _ltqhcd->core_if.hc_regs[_ltqhc->hc_num];
+			hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+			hcsplt.d32 = ltqusb_rreg(&hc_regs->hcsplt);
+			hctsiz.d32 = ltqusb_rreg(&hc_regs->hctsiz);
+			hcdma      = ltqusb_rreg(&hc_regs->hcdma);
+
+			LTQ_PRINT("  Assigned to channel %d:\n"       , _ltqhc->hc_num);
+			LTQ_PRINT("    hcchar 0x%08x, hcsplt 0x%08x\n", hcchar.d32, hcsplt.d32);
+			LTQ_PRINT("    hctsiz 0x%08x, hcdma 0x%08x\n" , hctsiz.d32, hcdma);
+			LTQ_PRINT("    dev_addr: %d, ep_num: %d, is_in: %d\n",
+			   _ltqhc->dev_addr, _ltqhc->ep_num, _ltqhc->is_in);
+			LTQ_PRINT("    ep_type: %d\n"        , _ltqhc->ep_type);
+			LTQ_PRINT("    max_packet_size: %d\n", _ltqhc->mps);
+			LTQ_PRINT("    data_pid_start: %d\n" , _ltqhc->data_pid_start);
+			LTQ_PRINT("    halt_status: %d\n"    , _ltqhc->halt_status);
+			LTQ_PRINT("    xfer_buff: %p\n"      , _ltqhc->xfer_buff);
+			LTQ_PRINT("    xfer_len: %d\n"       , _ltqhc->xfer_len);
+			LTQ_PRINT("    epqh: %p\n"           , _ltqhc->epqh);
+			LTQ_PRINT("    urbd: %p\n"           , _ltqhc->urbd);
+			LTQ_PRINT("  NP :\n");
+		}
+	}
+#endif
+#endif //__DEBUG__
+
+
+/*!
+   \brief This function writes a packet into the Tx FIFO associated with the Host
+  Channel. For a channel associated with a non-periodic EP, the non-periodic
+  Tx FIFO is written. For a channel associated with a periodic EP, the
+  periodic Tx FIFO is written. This function should only be called in Slave
+  mode.
+
+  Upon return the xfer_buff and xfer_count fields in _hc are incremented by
+  then number of bytes written to the Tx FIFO.
+ */
+
+#ifdef __ENABLE_DUMP__
+	void ltqhcd_dump_state(ltqhcd_hcd_t *_ltqhcd)
+	{
+		int num_channels;
+		int i;
+		num_channels = _ltqhcd->core_if.params.host_channels;
+		LTQ_PRINT("\n");
+		LTQ_PRINT("************************************************************\n");
+		LTQ_PRINT("HCD State:\n");
+		LTQ_PRINT("  Num channels: %d\n", num_channels);
+		for (i = 0; i < num_channels; i++) {
+			ltqhcd_hc_t *hc = &_ltqhcd->ltqhc[i];
+			LTQ_PRINT("  Channel %d:\n", hc->hc_num);
+			LTQ_PRINT("    dev_addr: %d, ep_num: %d, ep_is_in: %d\n",
+				  hc->dev_addr, hc->ep_num, hc->is_in);
+			LTQ_PRINT("    speed: %d\n"          , hc->speed);
+			LTQ_PRINT("    ep_type: %d\n"        , hc->ep_type);
+			LTQ_PRINT("    mps: %d\n", hc->mps);
+			LTQ_PRINT("    data_pid_start: %d\n" , hc->data_pid_start);
+			LTQ_PRINT("    xfer_buff: %p\n"      , hc->xfer_buff);
+			LTQ_PRINT("    xfer_len: %d\n"       , hc->xfer_len);
+			LTQ_PRINT("    xfer_count: %d\n"     , hc->xfer_count);
+			LTQ_PRINT("    halt_status: %d\n"    , hc->halt_status);
+			LTQ_PRINT("    split: %d\n"          , hc->split);
+			LTQ_PRINT("    hub_addr: %d\n"       , hc->hub_addr);
+			LTQ_PRINT("    port_addr: %d\n"      , hc->port_addr);
+			#if defined(__EN_ISOC__) && defined(__EN_ISOC_SPLIT__)
+				LTQ_PRINT("    isoc_xact_pos: %d\n"       , hc->isoc_xact_pos);
+			#endif
+
+			LTQ_PRINT("    epqh: %p\n"           , hc->epqh);
+			LTQ_PRINT("    short_rw: %d\n"       , hc->short_rw);
+			LTQ_PRINT("    control_phase: %d\n"  , hc->control_phase);
+			if(hc->epqh)
+			{
+				LTQ_PRINT("    do_ping: %d\n"        , hc->epqh->do_ping);
+			}
+			LTQ_PRINT("    start_pkt_count: %d\n"       , hc->start_pkt_count);
+		}
+		LTQ_PRINT("************************************************************\n");
+		LTQ_PRINT("\n");
+	}
+#endif //__ENABLE_DUMP__
+
--- a/drivers/usb/host/ltqhcd_es.c
+++ b/drivers/usb/host/ltqhcd_es.c
@@ -0,0 +1,599 @@
+/*****************************************************************************
+ **   FILE NAME       : ltqhcd_es.c
+ **   PROJECT         : Lantiq USB sub-system V3
+ **   MODULES         : Lantiq USB sub-system Host and Device driver
+ **   SRC VERSION     : 1.0
+ **   DATE            : 1/Jan/2009
+ **   AUTHOR          : Chen, Howard
+ **   DESCRIPTION     : The file contain function to enable host mode USB-IF Electrical Test function.
+ **   FUNCTIONS       :
+ **   COMPILER        : gcc
+ **   REFERENCE       : Synopsys DWC-OTG Driver 2.7
+ **   COPYRIGHT       :  Copyright (c) 2010
+ **                      LANTIQ DEUTSCHLAND GMBH,
+ **                      Am Campeon 3, 85579 Neubiberg, Germany
+ **
+ **    This program is free software; you can redistribute it and/or modify
+ **    it under the terms of the GNU General Public License as published by
+ **    the Free Software Foundation; either version 2 of the License, or
+ **    (at your option) any later version.
+ **
+ **  Version Control Section  **
+ **   $Author$
+ **   $Date$
+ **   $Revisions$
+ **   $Log$       Revision history
+ *****************************************************************************/
+
+/*
+ * This file contains code fragments from Synopsys HS OTG Linux Software Driver.
+ * For this code the following notice is applicable:
+ *
+ * ==========================================================================
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/*!
+ \file ltqhcd_es.c
+ \ingroup LTQUSB_DRIVER_V3
+ \brief The file contain function to enable host mode USB-IF Electrical Test function.
+*/
+
+#include <linux/version.h>
+#include "ltqusb_version.h"
+
+#include <linux/kernel.h>
+
+#include <linux/errno.h>
+
+#include <linux/dma-mapping.h>
+
+#include "ltqusb_plat.h"
+#include "ltqusb_regs.h"
+#include "ltqusb_cif.h"
+#include "ltqhcd.h"
+
+
+#ifdef __WITH_HS_ELECT_TST__
+	/*
+	 * Quick and dirty hack to implement the HS Electrical Test
+	 * SINGLE_STEP_GET_DEVICE_DESCRIPTOR feature.
+	 *
+	 * This code was copied from our userspace app "hset". It sends a
+	 * Get Device Descriptor control sequence in two parts, first the
+	 * Setup packet by itself, followed some time later by the In and
+	 * Ack packets. Rather than trying to figure out how to add this
+	 * functionality to the normal driver code, we just hijack the
+	 * hardware, using these two function to drive the hardware
+	 * directly.
+	 */
+
+
+	void do_setup(ltqusb_core_if_t *_core_if)
+	{
+
+		ltqusb_core_global_regs_t *global_regs    = _core_if->core_global_regs;
+		ltqusb_host_global_regs_t *hc_global_regs = _core_if->host_global_regs;
+		ltqusb_hc_regs_t          *hc_regs        = _core_if->hc_regs[0];
+		uint32_t                  *data_fifo      = _core_if->data_fifo[0];
+
+		gint_data_t    gintsts;
+		hctsiz_data_t  hctsiz;
+		hcchar_data_t  hcchar;
+		haint_data_t   haint;
+		hcint_data_t   hcint;
+
+
+		/* Enable HAINTs */
+		ltqusb_wreg(&hc_global_regs->haintmsk, 0x0001);
+
+		/* Enable HCINTs */
+		ltqusb_wreg(&hc_regs->hcintmsk, 0x04a3);
+
+		/* Read GINTSTS */
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+		/* Read HAINT */
+		haint.d32 = ltqusb_rreg(&hc_global_regs->haint);
+		//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+		/* Read HCINT */
+		hcint.d32 = ltqusb_rreg(&hc_regs->hcint);
+		//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+		/* Read HCCHAR */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+		/* Clear HCINT */
+		ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+
+		/* Clear HAINT */
+		ltqusb_wreg(&hc_global_regs->haint, haint.d32);
+
+		/* Clear GINTSTS */
+		ltqusb_wreg(&global_regs->gintsts, gintsts.d32);
+
+		/* Read GINTSTS */
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+		/*
+		 * Send Setup packet (Get Device Descriptor)
+		 */
+
+		/* Make sure channel is disabled */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		if (hcchar.b.chen) {
+			//fprintf(stderr, "Channel already enabled 1, HCCHAR = %08x\n", hcchar.d32);
+			hcchar.b.chdis = 1;
+	//		hcchar.b.chen = 1;
+			ltqusb_wreg(&hc_regs->hcchar, hcchar.d32);
+			//sleep(1);
+			mdelay(1000);
+
+			/* Read GINTSTS */
+			gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+			//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+			/* Read HAINT */
+			haint.d32 = ltqusb_rreg(&hc_global_regs->haint);
+			//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+			/* Read HCINT */
+			hcint.d32 = ltqusb_rreg(&hc_regs->hcint);
+			//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+			/* Read HCCHAR */
+			hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+			//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+			/* Clear HCINT */
+			ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+
+			/* Clear HAINT */
+			ltqusb_wreg(&hc_global_regs->haint, haint.d32);
+
+			/* Clear GINTSTS */
+			ltqusb_wreg(&global_regs->gintsts, gintsts.d32);
+
+			hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+			//if (hcchar.b.chen) {
+			//	fprintf(stderr, "** Channel _still_ enabled 1, HCCHAR = %08x **\n", hcchar.d32);
+			//}
+		}
+
+		/* Set HCTSIZ */
+		hctsiz.d32 = 0;
+		hctsiz.b.xfersize = 8;
+		hctsiz.b.pktcnt = 1;
+		hctsiz.b.pid = LTQUSB_HC_PID_SETUP;
+		ltqusb_wreg(&hc_regs->hctsiz, hctsiz.d32);
+
+		/* Set HCCHAR */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		hcchar.b.eptype = LTQUSB_EP_TYPE_CTRL;
+		hcchar.b.epdir = 0;
+		hcchar.b.epnum = 0;
+		hcchar.b.mps = 8;
+		hcchar.b.chen = 1;
+		ltqusb_wreg(&hc_regs->hcchar, hcchar.d32);
+
+		/* Fill FIFO with Setup data for Get Device Descriptor */
+		ltqusb_wreg(data_fifo++, 0x01000680);
+		ltqusb_wreg(data_fifo++, 0x00080000);
+
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "Waiting for HCINTR intr 1, GINTSTS = %08x\n", gintsts.d32);
+
+		/* Wait for host channel interrupt */
+		do {
+			gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		} while (gintsts.b.hcintr == 0);
+
+		//fprintf(stderr, "Got HCINTR intr 1, GINTSTS = %08x\n", gintsts.d32);
+
+		/* Disable HCINTs */
+		ltqusb_wreg(&hc_regs->hcintmsk, 0x0000);
+
+		/* Disable HAINTs */
+		ltqusb_wreg(&hc_global_regs->haintmsk, 0x0000);
+
+		/* Read HAINT */
+		haint.d32 = ltqusb_rreg(&hc_global_regs->haint);
+		//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+		/* Read HCINT */
+		hcint.d32 = ltqusb_rreg(&hc_regs->hcint);
+		//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+		/* Read HCCHAR */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+		/* Clear HCINT */
+		ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+
+		/* Clear HAINT */
+		ltqusb_wreg(&hc_global_regs->haint, haint.d32);
+
+		/* Clear GINTSTS */
+		ltqusb_wreg(&global_regs->gintsts, gintsts.d32);
+
+		/* Read GINTSTS */
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+	}
+
+	void do_in_ack(ltqusb_core_if_t *_core_if)
+	{
+
+		ltqusb_core_global_regs_t *global_regs    = _core_if->core_global_regs;
+		ltqusb_host_global_regs_t *hc_global_regs = _core_if->host_global_regs;
+		ltqusb_hc_regs_t          *hc_regs        = _core_if->hc_regs[0];
+		uint32_t                  *data_fifo      = _core_if->data_fifo[0];
+
+		gint_data_t        gintsts;
+		hctsiz_data_t      hctsiz;
+		hcchar_data_t      hcchar;
+		haint_data_t       haint;
+		hcint_data_t       hcint;
+		grxsts_data_t      grxsts;
+
+		/* Enable HAINTs */
+		ltqusb_wreg(&hc_global_regs->haintmsk, 0x0001);
+
+		/* Enable HCINTs */
+		ltqusb_wreg(&hc_regs->hcintmsk, 0x04a3);
+
+		/* Read GINTSTS */
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+		/* Read HAINT */
+		haint.d32 = ltqusb_rreg(&hc_global_regs->haint);
+		//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+		/* Read HCINT */
+		hcint.d32 = ltqusb_rreg(&hc_regs->hcint);
+		//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+		/* Read HCCHAR */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+		/* Clear HCINT */
+		ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+
+		/* Clear HAINT */
+		ltqusb_wreg(&hc_global_regs->haint, haint.d32);
+
+		/* Clear GINTSTS */
+		ltqusb_wreg(&global_regs->gintsts, gintsts.d32);
+
+		/* Read GINTSTS */
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+		/*
+		 * Receive Control In packet
+		 */
+
+		/* Make sure channel is disabled */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		if (hcchar.b.chen) {
+			//fprintf(stderr, "Channel already enabled 2, HCCHAR = %08x\n", hcchar.d32);
+			hcchar.b.chdis = 1;
+			hcchar.b.chen = 1;
+			ltqusb_wreg(&hc_regs->hcchar, hcchar.d32);
+			//sleep(1);
+			mdelay(1000);
+
+			/* Read GINTSTS */
+			gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+			//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+			/* Read HAINT */
+			haint.d32 = ltqusb_rreg(&hc_global_regs->haint);
+			//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+			/* Read HCINT */
+			hcint.d32 = ltqusb_rreg(&hc_regs->hcint);
+			//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+			/* Read HCCHAR */
+			hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+			//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+			/* Clear HCINT */
+			ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+
+			/* Clear HAINT */
+			ltqusb_wreg(&hc_global_regs->haint, haint.d32);
+
+			/* Clear GINTSTS */
+			ltqusb_wreg(&global_regs->gintsts, gintsts.d32);
+
+			hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+			//if (hcchar.b.chen) {
+			//	fprintf(stderr, "** Channel _still_ enabled 2, HCCHAR = %08x **\n", hcchar.d32);
+			//}
+		}
+
+		/* Set HCTSIZ */
+		hctsiz.d32 = 0;
+		hctsiz.b.xfersize = 8;
+		hctsiz.b.pktcnt = 1;
+		hctsiz.b.pid = LTQUSB_HC_PID_DATA1;
+		ltqusb_wreg(&hc_regs->hctsiz, hctsiz.d32);
+
+		/* Set HCCHAR */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		hcchar.b.eptype = LTQUSB_EP_TYPE_CTRL;
+		hcchar.b.epdir = 1;
+		hcchar.b.epnum = 0;
+		hcchar.b.mps = 8;
+		hcchar.b.chen = 1;
+		ltqusb_wreg(&hc_regs->hcchar, hcchar.d32);
+
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "Waiting for RXSTSQLVL intr 1, GINTSTS = %08x\n", gintsts.d32);
+
+		/* Wait for receive status queue interrupt */
+		do {
+			gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		} while (gintsts.b.rxstsqlvl == 0);
+
+		//fprintf(stderr, "Got RXSTSQLVL intr 1, GINTSTS = %08x\n", gintsts.d32);
+
+		/* Read RXSTS */
+		grxsts.d32 = ltqusb_rreg(&global_regs->grxstsp);
+		//fprintf(stderr, "GRXSTS: %08x\n", grxsts.d32);
+
+		/* Clear RXSTSQLVL in GINTSTS */
+		gintsts.d32 = 0;
+		gintsts.b.rxstsqlvl = 1;
+		ltqusb_wreg(&global_regs->gintsts, gintsts.d32);
+
+		switch (grxsts.hb.pktsts) {
+			case LTQUSB_HSTS_DATA_UPDT:
+				/* Read the data into the host buffer */
+				if (grxsts.hb.bcnt > 0) {
+					int i;
+					int word_count = (grxsts.hb.bcnt + 3) / 4;
+
+					for (i = 0; i < word_count; i++) {
+						(void)ltqusb_rreg(data_fifo++);
+					}
+				}
+
+				//fprintf(stderr, "Received %u bytes\n", (unsigned)grxsts.hb.bcnt);
+				break;
+
+			default:
+				//fprintf(stderr, "** Unexpected GRXSTS packet status 1 **\n");
+				break;
+		}
+
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "Waiting for RXSTSQLVL intr 2, GINTSTS = %08x\n", gintsts.d32);
+
+		/* Wait for receive status queue interrupt */
+		do {
+			gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		} while (gintsts.b.rxstsqlvl == 0);
+
+		//fprintf(stderr, "Got RXSTSQLVL intr 2, GINTSTS = %08x\n", gintsts.d32);
+
+		/* Read RXSTS */
+		grxsts.d32 = ltqusb_rreg(&global_regs->grxstsp);
+		//fprintf(stderr, "GRXSTS: %08x\n", grxsts.d32);
+
+		/* Clear RXSTSQLVL in GINTSTS */
+		gintsts.d32 = 0;
+		gintsts.b.rxstsqlvl = 1;
+		ltqusb_wreg(&global_regs->gintsts, gintsts.d32);
+
+		switch (grxsts.hb.pktsts) {
+			case LTQUSB_HSTS_XFER_COMP:
+				break;
+
+			default:
+				//fprintf(stderr, "** Unexpected GRXSTS packet status 2 **\n");
+				break;
+		}
+
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "Waiting for HCINTR intr 2, GINTSTS = %08x\n", gintsts.d32);
+
+		/* Wait for host channel interrupt */
+		do {
+			gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		} while (gintsts.b.hcintr == 0);
+
+		//fprintf(stderr, "Got HCINTR intr 2, GINTSTS = %08x\n", gintsts.d32);
+
+		/* Read HAINT */
+		haint.d32 = ltqusb_rreg(&hc_global_regs->haint);
+		//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+		/* Read HCINT */
+		hcint.d32 = ltqusb_rreg(&hc_regs->hcint);
+		//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+		/* Read HCCHAR */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+		/* Clear HCINT */
+		ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+
+		/* Clear HAINT */
+		ltqusb_wreg(&hc_global_regs->haint, haint.d32);
+
+		/* Clear GINTSTS */
+		ltqusb_wreg(&global_regs->gintsts, gintsts.d32);
+
+		/* Read GINTSTS */
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+	//	usleep(100000);
+	//	mdelay(100);
+		mdelay(1);
+
+		/*
+		 * Send handshake packet
+		 */
+
+		/* Read HAINT */
+		haint.d32 = ltqusb_rreg(&hc_global_regs->haint);
+		//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+		/* Read HCINT */
+		hcint.d32 = ltqusb_rreg(&hc_regs->hcint);
+		//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+		/* Read HCCHAR */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+		/* Clear HCINT */
+		ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+
+		/* Clear HAINT */
+		ltqusb_wreg(&hc_global_regs->haint, haint.d32);
+
+		/* Clear GINTSTS */
+		ltqusb_wreg(&global_regs->gintsts, gintsts.d32);
+
+		/* Read GINTSTS */
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+		/* Make sure channel is disabled */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		if (hcchar.b.chen) {
+			//fprintf(stderr, "Channel already enabled 3, HCCHAR = %08x\n", hcchar.d32);
+			hcchar.b.chdis = 1;
+			hcchar.b.chen = 1;
+			ltqusb_wreg(&hc_regs->hcchar, hcchar.d32);
+			//sleep(1);
+			mdelay(1000);
+
+			/* Read GINTSTS */
+			gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+			//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+
+			/* Read HAINT */
+			haint.d32 = ltqusb_rreg(&hc_global_regs->haint);
+			//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+			/* Read HCINT */
+			hcint.d32 = ltqusb_rreg(&hc_regs->hcint);
+			//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+			/* Read HCCHAR */
+			hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+			//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+			/* Clear HCINT */
+			ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+
+			/* Clear HAINT */
+			ltqusb_wreg(&hc_global_regs->haint, haint.d32);
+
+			/* Clear GINTSTS */
+			ltqusb_wreg(&global_regs->gintsts, gintsts.d32);
+
+			hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+			//if (hcchar.b.chen) {
+			//	fprintf(stderr, "** Channel _still_ enabled 3, HCCHAR = %08x **\n", hcchar.d32);
+			//}
+		}
+
+		/* Set HCTSIZ */
+		hctsiz.d32 = 0;
+		hctsiz.b.xfersize = 0;
+		hctsiz.b.pktcnt = 1;
+		hctsiz.b.pid = LTQUSB_HC_PID_DATA1;
+		ltqusb_wreg(&hc_regs->hctsiz, hctsiz.d32);
+
+		/* Set HCCHAR */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		hcchar.b.eptype = LTQUSB_EP_TYPE_CTRL;
+		hcchar.b.epdir = 0;
+		hcchar.b.epnum = 0;
+		hcchar.b.mps = 8;
+		hcchar.b.chen = 1;
+		ltqusb_wreg(&hc_regs->hcchar, hcchar.d32);
+
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "Waiting for HCINTR intr 3, GINTSTS = %08x\n", gintsts.d32);
+
+		/* Wait for host channel interrupt */
+		do {
+			gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		} while (gintsts.b.hcintr == 0);
+
+		//fprintf(stderr, "Got HCINTR intr 3, GINTSTS = %08x\n", gintsts.d32);
+
+		/* Disable HCINTs */
+		ltqusb_wreg(&hc_regs->hcintmsk, 0x0000);
+
+		/* Disable HAINTs */
+		ltqusb_wreg(&hc_global_regs->haintmsk, 0x0000);
+
+		/* Read HAINT */
+		haint.d32 = ltqusb_rreg(&hc_global_regs->haint);
+		//fprintf(stderr, "HAINT: %08x\n", haint.d32);
+
+		/* Read HCINT */
+		hcint.d32 = ltqusb_rreg(&hc_regs->hcint);
+		//fprintf(stderr, "HCINT: %08x\n", hcint.d32);
+
+		/* Read HCCHAR */
+		hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+		//fprintf(stderr, "HCCHAR: %08x\n", hcchar.d32);
+
+		/* Clear HCINT */
+		ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+
+		/* Clear HAINT */
+		ltqusb_wreg(&hc_global_regs->haint, haint.d32);
+
+		/* Clear GINTSTS */
+		ltqusb_wreg(&global_regs->gintsts, gintsts.d32);
+
+		/* Read GINTSTS */
+		gintsts.d32 = ltqusb_rreg(&global_regs->gintsts);
+		//fprintf(stderr, "GINTSTS: %08x\n", gintsts.d32);
+	}
+#endif //__WITH_HS_ELECT_TST__
+
--- a/drivers/usb/host/ltqhcd.h
+++ b/drivers/usb/host/ltqhcd.h
@@ -0,0 +1,875 @@
+/*****************************************************************************
+ **   FILE NAME       : ltqhcd.h
+ **   PROJECT         : Lantiq USB sub-system V3
+ **   MODULES         : Lantiq USB sub-system Host and Device driver
+ **   SRC VERSION     : 3.2
+ **   DATE            : 1/Jan/2011
+ **   AUTHOR          : Chen, Howard
+ **   DESCRIPTION     : This file contains the structures, constants, and interfaces for
+ **                     the Host Contoller Driver (HCD).
+ **
+ **                     The Host Controller Driver (HCD) is responsible for translating requests
+ **                     from the USB Driver into the appropriate actions on the LTQUSB controller.
+ **                     It isolates the USBD from the specifics of the controller by providing an
+ **                     API to the USBD.
+ **   FUNCTIONS       :
+ **   COMPILER        : gcc
+ **   REFERENCE       : Synopsys DWC-OTG Driver 2.7
+ **   COPYRIGHT       :  Copyright (c) 2010
+ **                      LANTIQ DEUTSCHLAND GMBH,
+ **                      Am Campeon 3, 85579 Neubiberg, Germany
+ **
+ **    This program is free software; you can redistribute it and/or modify
+ **    it under the terms of the GNU General Public License as published by
+ **    the Free Software Foundation; either version 2 of the License, or
+ **    (at your option) any later version.
+ **
+ **  Version Control Section  **
+ **   $Author$
+ **   $Date$
+ **   $Revisions$
+ **   $Log$       Revision history
+ *****************************************************************************/
+
+/*
+ * This file contains code fragments from Synopsys HS OTG Linux Software Driver.
+ * For this code the following notice is applicable:
+ *
+ * ==========================================================================
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/*!
+  \defgroup LTQUSB_HCD HCD Interface
+  \ingroup LTQUSB_DRIVER_V3
+  \brief  The Host Controller Driver (HCD) is responsible for translating requests
+ from the USB Driver into the appropriate actions on the LTQUSB controller.
+ It isolates the USBD from the specifics of the controller by providing an
+ API to the USBD.
+ */
+
+
+/*!
+  \file ltqhcd.h
+  \ingroup LTQUSB_DRIVER_V3
+  \brief This file contains the structures, constants, and interfaces for
+ the Host Contoller Driver (HCD).
+ */
+
+#if !defined(__LTQHCD_H__)
+#define __LTQHCD_H__
+
+#include <linux/list.h>
+#include <linux/usb.h>
+
+#include <linux/usb/hcd.h>
+
+#include "ltqusb_cif.h"
+#include "ltqusb_plat.h"
+
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#ifdef __SINGLE_XACT__
+	#define XFER_PROT1_USEC  80
+	#define XFER_PROT2_USEC  0
+#else
+	#define XFER_PROT1_USEC  60
+	#define XFER_PROT2_USEC  70
+#endif
+
+/* Phases for control transfers.*/
+typedef enum ltqhcd_epqh_phase {
+	EPQH_IDLE=0,
+	EPQH_DISABLING,
+//	EPQH_COMPLETING,
+	EPQH_STDBY,
+	EPQH_READY,
+	EPQH_ACTIVE
+} ltqhcd_epqh_phase_e;
+
+/* Phases for control transfers.*/
+typedef enum ltqhcd_urbd_phase {
+	URBD_IDLE=0,
+	URBD_ACTIVE,
+	URBD_RUNNING,
+	URBD_FINISHING,    //URB_Complete already scheduled
+	URBD_COMPLETING,   //To URB_Complete, it's normal finish
+	URBD_DEQUEUEING,   //To URB_Complete, it's abnormal finish
+} ltqhcd_urbd_phase_e;
+
+/* Phases for control transfers.*/
+typedef enum ltqhcd_hc_phase {
+	HC_IDLE=0,
+	HC_ASSIGNED,
+	HC_WAITING,
+	HC_WAITING2,
+	HC_STARTING,
+	HC_STARTING_HIGH,
+	HC_STARTED,
+	HC_STOPPING,
+	HC_STOPPED,
+} ltqhcd_hc_phase_e;
+
+/*!
+  \addtogroup LTQUSB_HCD
+ */
+/*@{*/
+
+/*! \typedef  ltqhcd_control_phase_e
+	\brief Phases for control transfers.
+*/
+
+typedef enum ltqhcd_control_phase {
+	LTQHCD_CONTROL_SETUP,
+	LTQHCD_CONTROL_DATA,
+	LTQHCD_CONTROL_STATUS
+} ltqhcd_control_phase_e;
+
+/*! \typedef  ltqhcd_halt_status_e
+	\brief Reasons for halting a host channel.
+*/
+typedef enum ltqhcd_halt_status
+{
+	HC_XFER_NO_HALT_STATUS,         // Initial
+	HC_XFER_COMPLETE,               // Xact complete without error, upward
+	HC_XFER_URB_COMPLETE,           // Xfer complete without error, short upward
+	HC_XFER_STALL,                  // HC stopped abnormally, upward/downward
+	HC_XFER_XACT_ERR,               // HC stopped abnormally, upward
+	HC_XFER_FRAME_OVERRUN,          // HC stopped abnormally, upward
+	HC_XFER_BABBLE_ERR,             // HC stopped abnormally, upward
+	HC_XFER_AHB_ERR,                // HC stopped abnormally, upward
+	HC_XFER_DATA_TOGGLE_ERR,
+	HC_XFER_URB_DEQUEUE,            // HC stopper manually, downward
+	HC_XFER_NO_URB,                 // HC stopper manually, downward
+	HC_XFER_NO_EPQH,                // HC stopper manually, downward
+	HC_XFER_STOPPED,                // HC stopped by monitor, downward
+	#if defined(__INTRNAKRETRY__) || defined(__INTRINCRETRY__)
+		HC_XFER_INTR_NAK_RETRY,     // HC stopped by nak monitor, downward
+	#endif
+} ltqhcd_halt_status_e;
+
+struct ltqhcd_urbd;
+struct ltqhcd_hc ;
+struct ltqhcd_epqh ;
+struct ltqhcd_hcd;
+
+/*! typedef ltqhcd_urbd_t
+ \brief A URB Descriptor (URBD) holds the state of a bulk, control,
+  interrupt, or isochronous transfer. A single URBD is created for each URB
+  (of one of these types) submitted to the HCD. The transfer associated with
+  a URBD may require one or multiple transactions.
+
+  A URBD is linked to a EP Queue Head, which is entered in either the
+  isoc, intr or non-periodic schedule for execution. When a URBD is chosen for
+  execution, some or all of its transactions may be executed. After
+  execution, the state of the URBD is updated. The URBD may be retired if all
+  its transactions are complete or if an error occurred. Otherwise, it
+  remains in the schedule so more transactions can be executed later.
+ */
+typedef struct ltqhcd_urbd {
+	ltqhcd_urbd_phase_e       phase;
+	struct list_head          ql;               // Hook for EPQH->urbd_list
+	struct urb               *urb;              /*!< URB for this transfer */
+	                                            //struct urb {
+	                                            //  struct list_head urb_list;
+	                                            //  struct list_head anchor_list;
+	                                            //  struct usb_anchor * anchor;
+	                                            //  struct usb_device * dev;
+	                                            //  struct usb_host_endpoint * ep;
+	                                            //  unsigned int pipe;
+	                                            //  int status;
+	                                            //  unsigned int transfer_flags;
+	                                            //  void * transfer_buffer;
+	                                            //  dma_addr_t transfer_dma;
+	                                            //  u32 transfer_buffer_length;
+	                                            //  u32 actual_length;
+	                                            //  unsigned char * setup_packet;
+	                                            //  dma_addr_t setup_dma;
+	                                            //  int start_frame;
+	                                            //  int number_of_packets;
+	                                            //  int interval;
+	                                            //  int error_count;
+	                                            //  void * context;
+	                                            //  usb_complete_t complete;
+	                                            //  struct usb_iso_packet_descriptor iso_frame_desc[0];
+	                                            //};
+	                                            //urb_list         For use by current owner of the URB.
+	                                            //anchor_list      membership in the list of an anchor
+	                                            //anchor           to anchor URBs to a common mooring
+	                                            //dev              Identifies the USB device to perform the request.
+	                                            //ep               Points to the endpoint's data structure. Will
+	                                            //                 eventually replace pipe.
+	                                            //pipe             Holds endpoint number, direction, type, and more.
+	                                            //                 Create these values with the eight macros available; u
+	                                            //                 sb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is
+	                                            //                  "ctrl", "bulk", "int" or "iso". For example
+	                                            //                 usb_sndbulkpipe or usb_rcvintpipe. Endpoint numbers
+	                                            //                 range from zero to fifteen. Note that "in" endpoint two
+	                                            //                 is a different endpoint (and pipe) from "out" endpoint
+	                                            //                 two. The current configuration controls the existence,
+	                                            //                 type, and maximum packet size of any given endpoint.
+	                                            //status           This is read in non-iso completion functions to get
+	                                            //                 the status of the particular request. ISO requests
+	                                            //                 only use it to tell whether the URB was unlinked;
+	                                            //                 detailed status for each frame is in the fields of
+	                                            //                 the iso_frame-desc.
+	                                            //transfer_flags   A variety of flags may be used to affect how URB
+	                                            //                 submission, unlinking, or operation are handled.
+	                                            //                 Different kinds of URB can use different flags.
+	                                            //                      URB_SHORT_NOT_OK
+	                                            //                      URB_ISO_ASAP
+	                                            //                      URB_NO_TRANSFER_DMA_MAP
+	                                            //                      URB_NO_SETUP_DMA_MAP
+	                                            //                      URB_NO_FSBR
+	                                            //                      URB_ZERO_PACKET
+	                                            //                      URB_NO_INTERRUPT
+	                                            //transfer_buffer  This identifies the buffer to (or from) which the I/O
+	                                            //                 request will be performed (unless URB_NO_TRANSFER_DMA_MAP
+	                                            //                 is set). This buffer must be suitable for DMA; allocate it
+	                                            //                 with kmalloc or equivalent. For transfers to "in"
+	                                            //                 endpoints, contents of this buffer will be modified. This
+	                                            //                 buffer is used for the data stage of control transfers.
+	                                            //transfer_dma     When transfer_flags includes URB_NO_TRANSFER_DMA_MAP, the
+	                                            //                 device driver is saying that it provided this DMA address,
+	                                            //                 which the host controller driver should use in preference
+	                                            //                 to the transfer_buffer.
+	                                            //transfer_buffer_length How big is transfer_buffer. The transfer may be broken
+	                                            //                 up into chunks according to the current maximum packet size
+	                                            //                 for the endpoint, which is a function of the configuration
+	                                            //                 and is encoded in the pipe. When the length is zero, neither
+	                                            //                 transfer_buffer nor transfer_dma is used.
+	                                            //actual_length    This is read in non-iso completion functions, and it tells
+	                                            //                 how many bytes (out of transfer_buffer_length) were transferred.
+	                                            //                 It will normally be the same as requested, unless either an error
+	                                            //                 was reported or a short read was performed. The URB_SHORT_NOT_OK
+	                                            //                 transfer flag may be used to make such short reads be reported
+	                                            //                 as errors.
+	                                            //setup_packet     Only used for control transfers, this points to eight bytes of
+	                                            //                 setup data. Control transfers always start by sending this data
+	                                            //                 to the device. Then transfer_buffer is read or written, if needed.
+	                                            //setup_dma        For control transfers with URB_NO_SETUP_DMA_MAP set, the device
+	                                            //                 driver has provided this DMA address for the setup packet. The
+	                                            //                 host controller driver should use this in preference to setup_packet.
+	                                            //start_frame      Returns the initial frame for isochronous transfers.
+	                                            //number_of_packets Lists the number of ISO transfer buffers.
+	                                            //interval         Specifies the polling interval for interrupt or isochronous transfers.
+	                                            //                 The units are frames (milliseconds) for for full and low speed devices,
+	                                            //                 and microframes (1/8 millisecond) for highspeed ones.
+	                                            //error_count      Returns the number of ISO transfers that reported errors.
+	                                            //context          For use in completion functions. This normally points to request-specific
+	                                            //                 driver context.
+	                                            //complete         Completion handler. This URB is passed as the parameter to the completion
+	                                            //                 function. The completion function may then do what it likes with the URB,
+	                                            //                 including resubmitting or freeing it.
+	                                            //iso_frame_desc[0] Used to provide arrays of ISO transfer buffers and to collect the transfer
+	                                            //                 status for each buffer.
+
+	struct ltqhcd_epqh       *epqh;
+	struct ltqhcd_hc         *hc;                /*!< Host channel currently processing transfers for this EPQH. */
+                                                // Actual data portion, not SETUP or STATUS in case of CTRL XFER
+                                                // DMA adjusted
+	uint8_t                  *setup_buff;       /*!< Pointer to the entire transfer buffer. (CPU accessable)*/
+	uint8_t                  *xfer_buff;        /*!< Pointer to the entire transfer buffer. (CPU accessable)*/
+	uint32_t                  xfer_len;         /*!< Total number of bytes to transfer in this xfer. */
+
+	#if   defined(__UNALIGNED_BUF_ADJ__)
+		uint8_t *aligned_setup;
+		uint8_t *aligned_buf;
+	#endif
+	#if   defined(__UNALIGNED_BUF_ADJ__) || defined(__UNALIGNED_BUF_CHK__)
+		unsigned aligned_checked :  1;
+	#endif
+	unsigned     is_in           :1;
+	unsigned     cancelling      :1;
+	int          cancelling_status;
+	                          // For ALL XFER
+	uint8_t                   error_count;    /*!< Holds the number of bus errors that have occurred for a transaction
+	                                               within this transfer.
+	                                           */
+	                          // For ISOC XFER only
+	#ifdef __EN_ISOC__
+		int                   isoc_frame_index; /*!< Index of the next frame descriptor for an isochronous transfer. A
+		                                             frame descriptor describes the buffer position and length of the
+		                                             data to be transferred in the next scheduled (micro)frame of an
+		                                             isochronous transfer. It also holds status for that transaction.
+		                                             The frame index starts at 0.
+		                                         */
+	#endif
+	int status;
+} ltqhcd_urbd_t;
+
+/*! typedef ltqhcd_epqh_t
+ \brief A EP Queue Head (EPQH) holds the static characteristics of an endpoint and
+ maintains a list of transfers (URBDs) for that endpoint. A EPQH structure may
+ be entered in either the isoc, intr or non-periodic schedule.
+ */
+
+typedef struct ltqhcd_epqh {
+	struct ltqhcd_hcd    *ltqhcd;
+	struct usb_host_endpoint *sysep;
+	uint8_t devno;
+
+	ltqhcd_epqh_phase_e  phase;
+	struct list_head     ql_all;
+	struct list_head     ql;                // Hook for EP Queues
+	struct list_head     urbd_list;         /*!< List of URBDs for this EPQH. */
+	struct list_head     release_list;
+	struct tasklet_struct  complete_urb_sub;
+	uint8_t              ep_type;           /*!< Endpoint type. One of the following values:
+	                                             - LTQUSB_EP_TYPE_CTRL
+	                                             - LTQUSB_EP_TYPE_ISOC
+	                                             - LTQUSB_EP_TYPE_BULK
+	                                             - LTQUSB_EP_TYPE_INTR
+	                                         */
+	uint16_t             mps;               /*!< wMaxPacketSize Field of Endpoint Descriptor. */
+	#ifdef __EPQD_DESTROY_TIMEOUT__
+		struct timer_list destroy_timer;
+	#endif
+
+	unsigned burst_on       : 1 ;
+	unsigned need_split     : 1 ;
+	unsigned do_ping        : 1 ; /*!< Set to 1 to indicate that a PING request should be issued on this
+	                                  channel. If 0, process normally.
+	                              */
+	unsigned period_do      : 1;
+	unsigned cancelling     : 1;
+	uint16_t             interval;          /*!< Interval between transfers in (micro)frames. (for INTR)*/
+	uint16_t             period_counter;    /*!< Interval between transfers in (micro)frames. */
+
+	#ifdef __EN_ISOC__
+		struct tasklet_struct  tasklet_next_isoc;
+		uint8_t               isoc_now;
+		uint32_t              isoc_start_frame;
+	                          // For SPLITed ISOC XFER only
+		#ifdef __EN_ISOC_SPLIT__
+			uint8_t           isoc_split_pos;   /*!< Position of the ISOC split on full/low speed */
+			uint16_t          isoc_split_offset;/*!< Position of the ISOC split in the buffer for the current frame */
+		#endif
+	#endif
+	spinlock_t	urbd_list_lock;
+	spinlock_t	urbd_release_list_lock;
+	int urbd_count;
+
+	uint8_t complete_inuse;
+} ltqhcd_epqh_t;
+
+
+/*! typedef ltqhcd_hc_t
+ \brief Host channel descriptor. This structure represents the state of a single
+ host channel when acting in host mode. It contains the data items needed to
+ transfer packets to an endpoint via a host channel.
+ */
+typedef struct ltqhcd_hc
+{
+	ltqusb_hc_regs_t *hc_regs;
+	struct ltqhcd_epqh *epqh        ; /*!< EP Queue Head for the transfer being processed by this channel. */
+	struct ltqhcd_urbd *urbd;              /*!< URBD currently assigned to a host channel for this EPQH. */
+	uint8_t  hc_num                 ; /*!< Host channel number used for register address lookup */
+	uint8_t *xfer_buff              ; /*!< Pointer to the entire transfer buffer. */
+	uint32_t xfer_count             ; /*!< Number of bytes transferred so far. The offset of the begin of the buf */
+	uint32_t xfer_len               ; /*!< Total number of bytes to transfer in this xfer. */
+	uint16_t start_pkt_count        ; /*!< Packet count at start of transfer. Used to calculate the actual xfer size*/
+	ltqhcd_halt_status_e halt_status; /*!< Reason for halting the host channel. */
+	ltqhcd_hc_phase_e  phase;
+
+	unsigned dev_addr       : 7; /*!< Device to access */
+	unsigned is_in          : 1; /*!< EP direction. 0: OUT, 1: IN */
+	unsigned ep_num         : 4; /*!< EP to access */
+	unsigned speed          : 2; /*!< EP speed. */
+	unsigned ep_type        : 2; /*!< Endpoint type. */
+	unsigned mps            :11; /*!< Max packet size in bytes */
+	unsigned data_pid_start : 2; /*!< PID for initial transaction. */
+	unsigned short_rw       : 1; /*!< When Tx, means termination needed.
+	                                  When Rx, indicate Short Read  */
+	/* Split settings for the host channel */
+	unsigned split          : 2; /*!< Split: 0-Non Split, 1-SSPLIT, 2&3 CSPLIT */
+
+	unsigned sof_delay      :16;
+	unsigned erron          : 1;
+	unsigned cancelling     : 1;
+	unsigned stopping       : 1;
+
+	ltqhcd_control_phase_e    control_phase;  /*!< Current phase for control transfers (Setup, Data, or Status). */
+	uint32_t ssplit_out_xfer_count; /*!< How many bytes transferred during SSPLIT OUT */
+	#ifdef __DEBUG__
+		uint32_t          start_hcchar_val;
+	#endif
+	uint32_t hcchar;
+
+	/* Split settings for the host channel */
+	uint8_t hub_addr;          /*!< Address of high speed hub */
+	uint8_t port_addr;         /*!< Port of the low/full speed device */
+	#if defined(__EN_ISOC__) && defined(__EN_ISOC_SPLIT__)
+		uint8_t isoc_xact_pos;          /*!< Split transaction position */
+	#endif
+} ltqhcd_hc_t;
+
+
+/*! typedef ltqhcd_hcd_t
+ \brief This structure holds the state of the HCD, including the non-periodic and
+ periodic schedules.
+ */
+typedef struct ltqhcd_hcd
+{
+	struct device *dev;
+	struct hc_driver hc_driver;
+	ltqusb_core_if_t core_if;   /*!< Pointer to the core interface structure. */
+	struct usb_hcd *syshcd;
+	int             vbusgpioid,vbusgpioinstalled,vbusgpiostatus;
+	int             ledgpioid ,ledgpioinstalled ,ledgpiostatus;
+
+	volatile union
+	{
+		uint32_t d32;
+		struct
+		{
+			unsigned port_connect_status_change : 1;
+			unsigned port_connect_status        : 1;
+			unsigned port_reset_change          : 1;
+			unsigned port_enable_change         : 1;
+			unsigned port_suspend_change        : 1;
+			unsigned port_over_current_change   : 1;
+			unsigned reserved                   : 27;
+		} b;
+	} flags; /*!< Internal HCD Flags */
+
+	struct ltqhcd_hc ltqhc[MAX_EPS_CHANNELS];         /*!< Array of pointers to the host channel descriptors. Allows accessing
+	                                                       a host channel descriptor given the host channel number. This is
+	                                                       useful in interrupt handlers.
+	                                                   */
+	uint8_t   *status_buf;                            /*!< Buffer to use for any data received during the status phase of a
+	                                                       control transfer. Normally no data is transferred during the status
+	                                                       phase. This buffer is used as a bit bucket.
+	                                                   */
+		#define LTQHCD_STATUS_BUF_SIZE 64             /*!< buffer size of status phase in CTRL xfer */
+
+	struct list_head epqh_list_all;
+	struct list_head epqh_list_ctrl;
+	struct list_head epqh_list_bulk;
+	struct list_head epqh_list_intr;
+	#ifdef __EN_ISOC__
+		struct list_head epqh_list_isoc;
+	#endif
+
+	uint32_t lastframe;
+
+	#ifdef __EN_ISOC__
+		uint8_t isoc_ep_count;
+	#endif
+
+	spinlock_t	epqh_list_lock;
+	spinlock_t	epqh_list_all_lock;
+	spinlock_t	enqueue_lock;
+	spinlock_t	intr_lock;
+	spinlock_t	select_lock;
+
+	struct timer_list host_probe_timer;
+	struct timer_list autoprobe_timer;
+
+	unsigned	power_status;
+	int		probe_sec;
+	int		autoprobe_sec;
+	#ifdef __DYN_SOF_INTR__
+		uint32_t dyn_sof_count;
+		#define DYN_SOF_COUNT_DEF 40000
+	#endif
+	struct tasklet_struct  tasklet_select_eps;        /*!<  Tasket to do a reset */
+	struct tasklet_struct  tasklet_free_epqh_list ;        /*!<  Tasket to do a reset */
+	unsigned disconnecting         : 1 ;
+	unsigned singlexact            : 1 ;
+	unsigned burst                 : 1 ;
+
+	unsigned use_hrtimer           : 1 ;
+	unsigned xfer_stopper_timer_on : 1 ;
+
+	struct  hrtimer xfer_stopper_timer;
+
+	int             xfer_prot1_usec;
+	int             xfer_prot2_usec;
+	uint16_t        xfer_prot1_value;
+	unsigned long   xfer_prot2_value;
+
+} ltqhcd_hcd_t;
+
+/* Gets the ltqhcd_hcd from a struct usb_hcd */
+static inline ltqhcd_hcd_t *syshcd_to_ltqhcd(struct usb_hcd *syshcd)
+{
+	return (ltqhcd_hcd_t *)(syshcd->hcd_priv[0]);
+}
+
+/* Gets the struct usb_hcd that contains a ltqhcd_hcd_t. */
+static inline struct usb_hcd *ltqhcd_to_syshcd(ltqhcd_hcd_t *ltqhcd)
+{
+	return (struct usb_hcd *)(ltqhcd->syshcd);
+}
+
+
+extern ltqhcd_epqh_t * sysep_to_epqh(ltqhcd_hcd_t *_ltqhcd, struct usb_host_endpoint *_sysep, int skipcancel);
+
+/* HCD Create/Destroy Functions */
+	extern int  ltqhcd_init  (ltqhcd_hcd_t *_ltqhcd);
+	extern void ltqhcd_remove(ltqhcd_hcd_t *_ltqhcd);
+
+/*Linux HC Driver API Functions */
+
+extern int  ltqhcd_start(struct usb_hcd *hcd);
+extern void ltqhcd_stop (struct usb_hcd *hcd);
+extern int  ltqhcd_get_frame_number(struct usb_hcd *hcd);
+
+
+/*!
+   \brief This function does the setup for a data transfer for a host channel and
+  starts the transfer. May be called in either Slave mode or DMA mode. In
+  Slave mode, the caller must ensure that there is sufficient space in the
+  request queue and Tx Data FIFO.
+
+  For an OUT transfer in Slave mode, it loads a data packet into the
+  appropriate FIFO. If necessary, additional data packets will be loaded in
+  the Host ISR.
+
+  For an IN transfer in Slave mode, a data packet is requested. The data
+  packets are unloaded from the Rx FIFO in the Host ISR. If necessary,
+  additional data packets are requested in the Host ISR.
+
+  For a PING transfer in Slave mode, the Do Ping bit is set in the HCTSIZ
+  register along with a packet count of 1 and the channel is enabled. This
+  causes a single PING transaction to occur. Other fields in HCTSIZ are
+  simply set to 0 since no data transfer occurs in this case.
+
+  For a PING transfer in DMA mode, the HCTSIZ register is initialized with
+  all the information required to perform the subsequent data transfer. In
+  addition, the Do Ping bit is set in the HCTSIZ register. In this case, the
+  controller performs the entire PING protocol, then starts the data
+  transfer.
+
+  @param _ltqhc Information needed to initialize the host channel. The xfer_len
+  value may be reduced to accommodate the max widths of the XferSize and
+  PktCnt fields in the HCTSIZn register. The multi_count value may be changed
+  to reflect the final xfer_len value.
+ */
+extern void ltqhcd_hc_start(ltqhcd_hcd_t *_ltqhcd, ltqhcd_hc_t *_ltqhc, uint8_t do_now);
+extern void ltqhcd_xfer_stopper(ltqhcd_hcd_t *_ltqhcd);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+extern int ltqhcd_urb_enqueue(struct usb_hcd *_syshcd, struct usb_host_endpoint *_sysep, struct urb *_urb, gfp_t mem_flags);
+extern int ltqhcd_urb_dequeue(struct usb_hcd *_syshcd, struct urb *_urb);
+#else
+extern int ltqhcd_urb_enqueue(struct usb_hcd *_syshcd, struct urb *_urb, gfp_t mem_flags);
+extern int ltqhcd_urb_dequeue(struct usb_hcd *_syshcd, struct urb *_urb, int status);
+#endif
+extern irqreturn_t ltqhcd_irq(struct usb_hcd *_syshcd);
+
+extern void ltqhcd_endpoint_disable(struct usb_hcd *_syshcd, struct usb_host_endpoint *_sysep);
+
+extern int ltqhcd_hub_status_data(struct usb_hcd *_syshcd, char *_buf);
+extern int ltqhcd_hub_control( struct usb_hcd *_syshcd,
+                               u16             _typeReq,
+                               u16             _wValue,
+                               u16             _wIndex,
+                               char           *_buf,
+                               u16             _wLength);
+
+/*@}*/
+
+/*! \brief Transaction Execution Functions */
+/*@{*/
+extern void                      ltqhcd_complete_urb       (ltqhcd_hcd_t *_ltqhcd, ltqhcd_urbd_t *_urbd,  int _status);
+
+/*!
+   \brief Clears the transfer state for a host channel. This function is normally
+  called after a transfer is done and the host channel is being released.
+ */
+extern void ltqhcd_hc_cleanup(ltqusb_core_if_t *_core_if, ltqhcd_hc_t *_ltqhc);
+
+/*!
+   \brief Attempts to halt a host channel. This function should only be called in
+  Slave mode or to abort a transfer in either Slave mode or DMA mode. Under
+  normal circumstances in DMA mode, the controller halts the channel when the
+  transfer is complete or a condition occurs that requires application
+  intervention.
+
+  In DMA mode, always sets the Channel Enable and Channel Disable bits of the
+  HCCHARn register. The controller ensures there is space in the request
+  queue before submitting the halt request.
+
+  Some time may elapse before the core flushes any posted requests for this
+  host channel and halts. The Channel Halted interrupt handler completes the
+  deactivation of the host channel.
+ */
+extern int ltqhcd_hc_halt(ltqusb_core_if_t *_core_if,
+                    ltqhcd_hc_t *_ltqhc,
+                    ltqhcd_halt_status_e _halt_status);
+
+/*!
+   \brief This function is called to handle the disconnection of host port.
+ */
+int32_t ltqhcd_disconnect(ltqhcd_hcd_t *_ltqhcd);
+/*@}*/
+
+/*!  \brief Interrupt Handler Functions */
+/*@{*/
+extern irqreturn_t ltqhcd_oc_irq(int _irq, void *_dev);
+
+extern int32_t ltqhcd_handle_oc_intr(ltqhcd_hcd_t *_ltqhcd);
+extern int32_t ltqhcd_handle_intr   (ltqhcd_hcd_t *_ltqhcd);
+/*@}*/
+
+
+/*! \brief Schedule Queue Functions */
+/*@{*/
+extern void           ltqhcd_epqh_free   (ltqhcd_epqh_t *_epqh);
+extern void           select_eps      (ltqhcd_hcd_t *_ltqhcd);
+extern void           ltqhcd_epqh_idle(ltqhcd_epqh_t *_epqh);
+extern void           ltqhcd_epqh_idle_periodic(ltqhcd_epqh_t *_epqh);
+extern ltqhcd_epqh_t *ltqhcd_urbd_create (ltqhcd_hcd_t *_ltqhcd,struct urb *_urb);
+/*@}*/
+
+/*! \brief Gets the usb_host_endpoint associated with an URB. */
+static inline struct usb_host_endpoint *ltqhcd_urb_to_endpoint(struct urb *_urb)
+{
+	struct usb_device *dev = _urb->dev;
+	int    ep_num = usb_pipeendpoint(_urb->pipe);
+
+	return (usb_pipein(_urb->pipe))?(dev->ep_in[ep_num]):(dev->ep_out[ep_num]);
+}
+
+/*!
+ * \brief Gets the endpoint number from a _bEndpointAddress argument. The endpoint is
+ * qualified with its direction (possible 32 endpoints per device).
+ */
+#define ltqhcd_ep_addr_to_endpoint(_bEndpointAddress_) ((_bEndpointAddress_ & USB_ENDPOINT_NUMBER_MASK) | \
+                                                       ((_bEndpointAddress_ & USB_DIR_IN) != 0) << 4)
+
+
+
+/*! Internal debug function */
+void         ltqhcd_dump_state(ltqhcd_hcd_t *_ltqhcd);
+
+/*@}*//*LTQUSB_HCD*/
+
+extern struct usb_device *usb_alloc_dev  (struct usb_device *parent, struct usb_bus *, unsigned port);
+extern int                usb_add_hcd    (struct usb_hcd *syshcd, unsigned int irqnum, unsigned long irqflags);
+extern void               usb_remove_hcd (struct usb_hcd *syshcd);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+extern struct usb_hcd    *usb_create_hcd (const struct hc_driver *driver, struct device *dev, char *bus_name);
+#else
+extern struct usb_hcd    *usb_create_hcd (const struct hc_driver *driver, struct device *dev, const char *bus_name);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+extern void               usb_hcd_giveback_urb (struct usb_hcd *syshcd, struct urb *urb);
+#else
+extern void               usb_hcd_giveback_urb (struct usb_hcd *syshcd, struct urb *urb,int status);
+#endif
+
+extern void               usb_put_hcd       (struct usb_hcd *syshcd);
+extern long               usb_calc_bus_time (int speed, int is_input, int isoc, int bytecount);
+extern char *syserr(int errno);
+
+extern void do_suspend_h(ltqhcd_hcd_t *_ltqhcd);
+extern void do_resume_h(ltqhcd_hcd_t *_ltqhcd);
+extern void do_bussuspend_h(ltqhcd_hcd_t *_ltqhcd);
+extern void do_busresume_h(ltqhcd_hcd_t *_ltqhcd);
+
+
+static inline void INIT_EPQH_LIST_ALL(ltqhcd_hcd_t   *_ltqhcd)
+{
+	spin_lock_init(&_ltqhcd->epqh_list_all_lock);
+}
+static inline void LOCK_EPQH_LIST_ALL(ltqhcd_hcd_t   *_ltqhcd)
+{
+	spin_lock(&_ltqhcd->epqh_list_all_lock);
+}
+static inline void UNLOCK_EPQH_LIST_ALL(ltqhcd_hcd_t *_ltqhcd)
+{
+	spin_unlock(&_ltqhcd->epqh_list_all_lock);
+}
+
+static inline void INIT_EPQH_LIST(ltqhcd_hcd_t   *_ltqhcd)
+{
+	spin_lock_init(&_ltqhcd->epqh_list_lock);
+}
+static inline void LOCK_EPQH_LIST(ltqhcd_hcd_t   *_ltqhcd)
+{
+	spin_lock(&_ltqhcd->epqh_list_lock);
+}
+static inline void UNLOCK_EPQH_LIST(ltqhcd_hcd_t *_ltqhcd)
+{
+	spin_unlock(&_ltqhcd->epqh_list_lock);
+}
+
+static inline void INIT_URBD_LIST(ltqhcd_epqh_t    *_epqh)
+{
+	spin_lock_init(&_epqh->urbd_list_lock);
+}
+static inline void LOCK_URBD_LIST(ltqhcd_epqh_t    *_epqh)
+{
+	spin_lock(&_epqh->urbd_list_lock);
+}
+static inline void UNLOCK_URBD_LIST(ltqhcd_epqh_t  *_epqh)
+{
+	spin_unlock(&_epqh->urbd_list_lock);
+}
+
+static inline void INIT_URBD_RELEASE_LIST(ltqhcd_epqh_t    *_epqh)
+{
+	spin_lock_init(&_epqh->urbd_release_list_lock);
+}
+static inline void LOCK_URBD_RELEASE_LIST(ltqhcd_epqh_t    *_epqh)
+{
+	spin_lock(&_epqh->urbd_release_list_lock);
+}
+static inline void UNLOCK_URBD_RELEASE_LIST(ltqhcd_epqh_t  *_epqh)
+{
+	spin_unlock(&_epqh->urbd_release_list_lock);
+}
+static inline void INIT_ENQUEUE(ltqhcd_hcd_t *_ltqhcd)
+{
+	spin_lock_init(&_ltqhcd->enqueue_lock);
+}
+static inline void LOCK_ENQUEUE(ltqhcd_hcd_t *_ltqhcd)
+{
+	spin_lock(&_ltqhcd->enqueue_lock);
+}
+static inline void UNLOCK_ENQUEUE(ltqhcd_hcd_t *_ltqhcd)
+{
+	spin_unlock(&_ltqhcd->enqueue_lock);
+}
+static inline void INIT_INTR(ltqhcd_hcd_t *_ltqhcd)
+{
+	spin_lock_init(&_ltqhcd->intr_lock);
+}
+static inline void LOCK_INTR(ltqhcd_hcd_t *_ltqhcd)
+{
+	spin_lock(&_ltqhcd->intr_lock);
+}
+static inline void UNLOCK_INTR(ltqhcd_hcd_t *_ltqhcd)
+{
+	spin_unlock(&_ltqhcd->intr_lock);
+}
+static inline void INIT_SELECT(ltqhcd_hcd_t *_ltqhcd)
+{
+	spin_lock_init(&_ltqhcd->select_lock);
+}
+static inline void LOCK_SELECT(ltqhcd_hcd_t *_ltqhcd)
+{
+	spin_lock(&_ltqhcd->select_lock);
+}
+static inline void UNLOCK_SELECT(ltqhcd_hcd_t *_ltqhcd)
+{
+	spin_unlock(&_ltqhcd->select_lock);
+}
+
+
+
+#define NEWRET 1
+
+#define XFER_PROT1_CALC(n)  (3750L/125L*(125L-(n)))
+#define XFER_PROT2_CALC(n)  ((n)*1000)
+#define XFER_PROT2_OPTIONS HIGH_RES_NSEC
+
+extern uint8_t ltqusb_chip_family        ;
+	#define LTQUSB_CHIP_DANUBE 1
+	#define LTQUSB_CHIP_ASE    2
+	#define LTQUSB_CHIP_AR9    3
+	#define LTQUSB_CHIP_VR9    4
+	#define LTQUSB_CHIP_AR10   5
+
+
+	/*!
+	 \fn    void ltqusb_vbus_init(ltqhcd_hcd_t *_ltqhcd)
+	 \brief This function init the VBUS control.
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+	extern void ltqusb_vbus_init(ltqhcd_hcd_t *_ltqhcd);
+
+	/*!
+	 \fn    void ltqusb_vbus_free(ltqhcd_hcd_t *_ltqhcd)
+	 \brief This function free the VBUS control.
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+	extern void ltqusb_vbus_free(ltqhcd_hcd_t *_ltqhcd);
+
+	/*!
+	 \fn    void ltqusb_vbus_on(ltqusb_core_if_t *_core_if)
+	 \brief Turn on the USB 5V VBus Power
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+	extern void ltqusb_vbus_on(ltqhcd_hcd_t *_ltqhcd);
+
+	/*!
+	 \fn    void ltqusb_vbus_off(ltqusb_core_if_t *_core_if)
+	 \brief Turn off the USB 5V VBus Power
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+	extern void ltqusb_vbus_off(ltqhcd_hcd_t *_ltqhcd);
+
+	/*!
+	 \fn    int ltqusb_vbus(ltqusb_core_if_t *_core_if)
+	 \brief Read Current VBus status
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+	extern int ltqusb_vbus(ltqhcd_hcd_t *_ltqhcd);
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+#if defined(__HOST_LED__)
+	/*!
+	 \fn    void ltqusb_led_init(ltqusb_core_if_t *_core_if)
+	 \brief This function init the LED control.
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+	extern void ltqusb_led_init(ltqhcd_hcd_t *_ltqhcd);
+
+	/*!
+	 \fn    void ltqusb_led_free(ltqusb_core_if_t *_core_if)
+	 \brief This function free the LED control.
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+	extern void ltqusb_led_free(ltqhcd_hcd_t *_ltqhcd);
+
+	/*!
+	 \fn    void ltqusb_led(ltqusb_core_if_t *_core_if)
+	 \brief This function trigger the LED access.
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+	extern void ltqusb_led(ltqhcd_hcd_t *_ltqhcd);
+#endif
+
+
+#endif // __LTQHCD_H__
+
--- a/drivers/usb/host/ltqhcd_intr.c
+++ b/drivers/usb/host/ltqhcd_intr.c
@@ -0,0 +1,5302 @@
+/*****************************************************************************
+ **   FILE NAME       : ltqhcd_intr.c
+ **   PROJECT         : Lantiq USB sub-system V3
+ **   MODULES         : Lantiq USB sub-system Host and Device driver
+ **   SRC VERSION     : 3.2
+ **   DATE            : 1/Jan/2011
+ **   AUTHOR          : Chen, Howard
+ **   DESCRIPTION     : This file contains the implementation of the HCD Interrupt handlers.
+ **   FUNCTIONS       :
+ **   COMPILER        : gcc
+ **   REFERENCE       : Synopsys DWC-OTG Driver 2.7
+ **   COPYRIGHT       :  Copyright (c) 2010
+ **                      LANTIQ DEUTSCHLAND GMBH,
+ **                      Am Campeon 3, 85579 Neubiberg, Germany
+ **
+ **    This program is free software; you can redistribute it and/or modify
+ **    it under the terms of the GNU General Public License as published by
+ **    the Free Software Foundation; either version 2 of the License, or
+ **    (at your option) any later version.
+ **
+ **  Version Control Section  **
+ **   $Author$
+ **   $Date$
+ **   $Revisions$
+ **   $Log$       Revision history
+ *****************************************************************************/
+
+/*
+ * This file contains code fragments from Synopsys HS OTG Linux Software Driver.
+ * For this code the following notice is applicable:
+ *
+ * ==========================================================================
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/*!
+ \file ltqhcd_intr.c
+ \ingroup LTQUSB_DRIVER_V3
+ \brief This file contains the implementation of the HCD Interrupt handlers.
+*/
+
+
+#include <linux/version.h>
+#include "ltqusb_version.h"
+#include "ltqusb_plat.h"
+#include "ltqusb_regs.h"
+#include "ltqusb_cif.h"
+
+#include "ltqhcd.h"
+
+
+#define ABORT_URBD
+#define ABORT_URBD_MAX 5
+
+#define USE_SAFE_URBD
+
+
+/* Macro used to clear one channel interrupt */
+#define clear_hc_int(_hc_regs_,_intr_) \
+	do { \
+		hcint_data_t hcint_clear = {.d32 = 0}; \
+		hcint_clear.b._intr_ = 1; \
+		ltqusb_wreg(&((_hc_regs_)->hcint), hcint_clear.d32); \
+	} while (0)
+
+/*
+ * Macro used to disable one channel interrupt. Channel interrupts are
+ * disabled when the channel is halted or released by the interrupt handler.
+ * There is no need to handle further interrupts of that type until the
+ * channel is re-assigned. In fact, subsequent handling may cause crashes
+ * because the channel structures are cleaned up when the channel is released.
+ */
+#define disable_hc_int(_hc_regs_,_intr_) \
+	do { \
+		hcint_data_t hcintmsk = {.d32 = 0}; \
+		hcintmsk.b._intr_ = 1; \
+		ltqusb_mreg(&((_hc_regs_)->hcintmsk), hcintmsk.d32, 0); \
+	} while (0)
+
+#define enable_hc_int(_hc_regs_,_intr_) \
+	do { \
+		hcint_data_t hcintmsk = {.d32 = 0}; \
+		hcintmsk.b._intr_ = 1; \
+		ltqusb_mreg(&((_hc_regs_)->hcintmsk),0, hcintmsk.d32); \
+	} while (0)
+
+/*
+ * Save the starting data toggle for the next transfer. The data toggle is
+ * saved in the QH for non-control transfers and it's saved in the QTD for
+ * control transfers.
+ */
+uint8_t read_data_toggle(ltqusb_hc_regs_t *_hc_regs)
+{
+	hctsiz_data_t hctsiz;
+	hctsiz.d32 = ltqusb_rreg(&_hc_regs->hctsiz);
+	return(hctsiz.b.pid);
+}
+
+
+static
+void release_channel_dump(ltqhcd_hc_t      *ltqhc,
+                               struct urb       *urb,
+                               ltqhcd_epqh_t    *epqh,
+                               ltqhcd_urbd_t    *urbd,
+                               ltqhcd_halt_status_e  halt_status)
+{
+	#ifdef __DEBUG__
+		printk(KERN_INFO);
+		switch (halt_status)
+		{
+			case HC_XFER_NO_HALT_STATUS:
+				printk("HC_XFER_NO_HALT_STATUS");break;
+			case HC_XFER_URB_COMPLETE:
+				printk("HC_XFER_URB_COMPLETE");break;
+			case HC_XFER_AHB_ERR:
+				printk("HC_XFER_AHB_ERR");break;
+			case HC_XFER_STALL:
+				printk("HC_XFER_STALL");break;
+			case HC_XFER_BABBLE_ERR:
+				printk("HC_XFER_BABBLE_ERR");break;
+			case HC_XFER_XACT_ERR:
+				printk("HC_XFER_XACT_ERR");break;
+			case HC_XFER_URB_DEQUEUE:
+				printk("HC_XFER_URB_DEQUEUE");break;
+			case HC_XFER_FRAME_OVERRUN:
+				printk("HC_XFER_FRAME_OVERRUN");break;
+			case HC_XFER_DATA_TOGGLE_ERR:
+				printk("HC_XFER_DATA_TOGGLE_ERR");break;
+			case HC_XFER_STOPPED:
+				printk("HC_XFER_STOPPED");break;
+			case HC_XFER_COMPLETE:
+				printk("HC_XFER_COMPLETE");break;
+			default:
+				printk("KNOWN");break;
+		}
+		if(ltqhc)
+			printk("Ch %d %s%s S%d " , ltqhc->hc_num
+				,(ltqhc->ep_type == LTQUSB_EP_TYPE_CTRL)?"CTRL-":
+				   ((ltqhc->ep_type == LTQUSB_EP_TYPE_BULK)?"BULK-":
+				     ((ltqhc->ep_type == LTQUSB_EP_TYPE_INTR)?"INTR-":
+				       ((ltqhc->ep_type == LTQUSB_EP_TYPE_ISOC)?"ISOC-":"????"
+				       )
+				     )
+				   )
+				,(ltqhc->is_in)?"IN":"OUT"
+				,(ltqhc->split)
+				);
+		else
+			printk(" [NULL HC] ");
+		printk("urb=%p epqh=%p urbd=%p\n",urb,epqh,urbd);
+
+		if(urb)
+		{
+			printk(KERN_INFO "  Device address: %d\n", usb_pipedevice(urb->pipe));
+			printk(KERN_INFO "  Endpoint: %d, %s\n", usb_pipeendpoint(urb->pipe),
+				    (usb_pipein(urb->pipe) ? "IN" : "OUT"));
+			printk(KERN_INFO "  Endpoint type: %s\n",
+				    ({char *pipetype;
+				    switch (usb_pipetype(urb->pipe)) {
+					    case PIPE_CONTROL: pipetype = "CTRL"; break;
+					    case PIPE_BULK: pipetype = "BULK"; break;
+					    case PIPE_INTERRUPT: pipetype = "INTR"; break;
+					    case PIPE_ISOCHRONOUS: pipetype = "ISOC"; break;
+					    default: pipetype = "????"; break;
+				    }; pipetype;}));
+			printk(KERN_INFO "  Speed: %s\n",
+				    ({char *speed;
+				    switch (urb->dev->speed) {
+					    case USB_SPEED_HIGH: speed = "HS"; break;
+					    case USB_SPEED_FULL: speed = "FS"; break;
+					    case USB_SPEED_LOW: speed = "LS"; break;
+				    	default: speed = "????"; break;
+				    }; speed;}));
+			printk(KERN_INFO "  Max packet size: %d\n",
+				    usb_maxpacket(urb->dev, urb->pipe, usb_pipeout(urb->pipe)));
+			printk(KERN_INFO "  Data buffer length: %d/%d\n",urb->actual_length, urb->transfer_buffer_length);
+			printk(KERN_INFO "  Transfer buffer: %p, Transfer DMA: %p\n",
+				    urb->transfer_buffer, (void *)urb->transfer_dma);
+			printk(KERN_INFO "  Setup buffer: %p, Setup DMA: %p\n",
+				    urb->setup_packet, (void *)urb->setup_dma);
+			printk(KERN_INFO "  Interval: %d\n", urb->interval);
+		}
+		if(urbd)
+		{
+			switch (urbd->status)
+			{
+				case HC_XFER_NO_HALT_STATUS:
+					printk(KERN_INFO "  STATUS:HC_XFER_NO_HALT_STATUS\n");break;
+				case HC_XFER_URB_COMPLETE:
+					printk(KERN_INFO "  STATUS:HC_XFER_URB_COMPLETE\n");break;
+				case HC_XFER_AHB_ERR:
+					printk(KERN_INFO "  STATUS:HC_XFER_AHB_ERR\n");break;
+				case HC_XFER_STALL:
+					printk(KERN_INFO "  STATUS:HC_XFER_STALL\n");break;
+				case HC_XFER_BABBLE_ERR:
+					printk(KERN_INFO "  STATUS:HC_XFER_BABBLE_ERR\n");break;
+				case HC_XFER_XACT_ERR:
+					printk(KERN_INFO "  STATUS:HC_XFER_XACT_ERR\n");break;
+				case HC_XFER_URB_DEQUEUE:
+					printk(KERN_INFO "  STATUS:HC_XFER_URB_DEQUEUE\n");break;
+				case HC_XFER_FRAME_OVERRUN:
+					printk(KERN_INFO "  STATUS:HC_XFER_FRAME_OVERRUN\n");break;
+				case HC_XFER_DATA_TOGGLE_ERR:
+					printk(KERN_INFO "  STATUS:HC_XFER_DATA_TOGGLE_ERR\n");break;
+				case HC_XFER_COMPLETE:
+					printk(KERN_INFO "  STATUS:HC_XFER_COMPLETE\n");break;
+				default:
+					printk(KERN_INFO "  STATUS:UNKKNOWN %d\n",urbd->status);break;
+			}
+		}
+	#endif
+}
+
+/*!
+	 \fn    static void release_channel(ltqhcd_hcd_t          *_ltqhcd,
+                            ltqhcd_hc_t           *_ltqhc,
+                            ltqhcd_halt_status_e  _halt_status)
+	 \brief Release the halted channel.
+	 \param _ltqhcd Pointer to the sate of HCD structure
+	 \param _ltqhc Pointer to host channel descriptor
+	 \param _halt_status Halt satus
+	 \return None
+	 \ingroup  LTQUSB_HCD
+ */
+static
+void release_channel(ltqhcd_hcd_t          *_ltqhcd,
+                            ltqhcd_hc_t           *_ltqhc,
+                            ltqhcd_halt_status_e  _halt_status)
+{
+	ltqusb_hc_regs_t *hc_regs = _ltqhcd->core_if.hc_regs[_ltqhc->hc_num];
+	struct urb       *urb     = NULL;
+	ltqhcd_epqh_t    *epqh    = NULL;
+	ltqhcd_urbd_t    *urbd    = NULL;
+
+	LTQ_DEBUGPL(DBG_HCDV, "  %s: channel %d, halt_status %d\n",
+		    __func__, _ltqhc->hc_num, _halt_status);
+
+	epqh=_ltqhc->epqh;
+	if(!epqh)
+	{
+		if(_halt_status!=HC_XFER_NO_EPQH)
+			LTQ_ERROR("%s epqh=null\n",__func__);
+	}
+	urbd=_ltqhc->urbd;
+	if(!urbd)
+	{
+		LTQ_ERROR("%s urbd =null\n",__func__);
+	}
+	else
+	{
+		urb=urbd->urb;
+		if(!urb)
+		{
+			if(_halt_status!=HC_XFER_NO_URB)
+				LTQ_ERROR("%s urb =null\n",__func__);
+		}
+		else
+		{
+			if      (read_data_toggle(hc_regs) == LTQUSB_HCTSIZ_DATA0)
+				usb_settoggle (urb->dev,usb_pipeendpoint (urb->pipe), (_ltqhc->is_in)?0:1,0);
+			else if (read_data_toggle(hc_regs) == LTQUSB_HCTSIZ_DATA1)
+				usb_settoggle (urb->dev,usb_pipeendpoint (urb->pipe), (_ltqhc->is_in)?0:1,1);
+		}
+	}
+
+	switch (_halt_status)
+	{
+		case HC_XFER_NO_HALT_STATUS:
+			LTQ_ERROR("%s: No halt_status, channel %d\n", __func__, _ltqhc->hc_num);
+//			return;
+			break;
+		case HC_XFER_COMPLETE:
+			LTQ_ERROR("%s: Inavalid halt_status HC_XFER_COMPLETE, channel %d\n", __func__, _ltqhc->hc_num);
+//			return;
+			break;
+		case HC_XFER_NO_URB:
+			break;
+		case HC_XFER_NO_EPQH:
+			break;
+		case HC_XFER_URB_DEQUEUE:
+			if(urbd && urb)
+			{
+				urbd->phase=URBD_DEQUEUEING;
+				ltqhcd_complete_urb(_ltqhcd, urbd, 0);
+			}
+			else
+			{
+				LTQ_WARN("WARNING %s():%d urbd=%p urb=%p\n",__func__,__LINE__,urbd,urb);
+				release_channel_dump(_ltqhc,urb,epqh,urbd,_halt_status);
+			}
+			break;
+		case HC_XFER_AHB_ERR:
+			if(urbd && urb)
+			{
+				urbd->phase=URBD_DEQUEUEING;
+#ifdef NEWRET
+//				ltqhcd_complete_urb(_ltqhcd, urbd, _halt_status);
+				ltqhcd_complete_urb(_ltqhcd, urbd, -ESHUTDOWN);
+#else
+				ltqhcd_complete_urb(_ltqhcd, urbd, -EREMOTEIO);
+#endif
+			}
+			else
+			{
+				LTQ_WARN("WARNING %s():%d urbd=%p urb=%p\n",__func__,__LINE__,urbd,urb);
+				release_channel_dump(_ltqhc,urb,epqh,urbd,_halt_status);
+			}
+			break;
+		case HC_XFER_XACT_ERR:
+			if(urbd && urb)
+			{
+				urbd->phase=URBD_DEQUEUEING;
+#ifdef NEWRET
+//				ltqhcd_complete_urb(_ltqhcd, urbd, _halt_status);
+				ltqhcd_complete_urb(_ltqhcd, urbd, -EPROTO);
+#else
+				ltqhcd_complete_urb(_ltqhcd, urbd, -EREMOTEIO);
+#endif
+			}
+			else
+			{
+				LTQ_WARN("WARNING %s():%d urbd=%p urb=%p\n",__func__,__LINE__,urbd,urb);
+				release_channel_dump(_ltqhc,urb,epqh,urbd,_halt_status);
+			}
+			break;
+		case HC_XFER_FRAME_OVERRUN:
+			if(urbd && urb)
+			{
+				urbd->phase=URBD_DEQUEUEING;
+#ifdef NEWRET
+//				ltqhcd_complete_urb(_ltqhcd, urbd, _halt_status);
+				ltqhcd_complete_urb(_ltqhcd, urbd, -EPROTO);
+#else
+				ltqhcd_complete_urb(_ltqhcd, urbd, -EREMOTEIO);
+#endif
+			}
+			else
+			{
+				LTQ_WARN("WARNING %s():%d urbd=%p urb=%p\n",__func__,__LINE__,urbd,urb);
+				release_channel_dump(_ltqhc,urb,epqh,urbd,_halt_status);
+			}
+			break;
+		case HC_XFER_URB_COMPLETE:
+			_ltqhc->cancelling=0;
+			if(urbd && urb)
+			{
+				urbd->phase=URBD_COMPLETING;
+				ltqhcd_complete_urb(_ltqhcd, urbd, urbd->status);
+			}
+			else
+			{
+				LTQ_WARN("WARNING %s():%d urbd=%p urb=%p\n",__func__,__LINE__,urbd,urb);
+				release_channel_dump(_ltqhc,urb,epqh,urbd,_halt_status);
+			}
+			break;
+		case HC_XFER_STALL:
+			if(urbd)
+			{
+				urbd->phase=URBD_DEQUEUEING;
+				ltqhcd_complete_urb(_ltqhcd, urbd, -EPIPE);
+			}
+			else
+			{
+				LTQ_WARN("WARNING %s():%d urbd=%p urb=%p\n",__func__,__LINE__,urbd,urb);
+				release_channel_dump(_ltqhc,urb,epqh,urbd,_halt_status);
+			}
+			if(epqh && urb && urb->dev && urb->pipe)
+				usb_settoggle(urb->dev, usb_pipeendpoint (urb->pipe), !usb_pipein(urb->pipe), LTQUSB_HC_PID_DATA0);
+			break;
+		case HC_XFER_BABBLE_ERR:
+			if(urbd)
+			{
+				urbd->phase=URBD_DEQUEUEING;
+				ltqhcd_complete_urb(_ltqhcd, urbd, -EOVERFLOW);
+			}
+			else
+			{
+				LTQ_WARN("WARNING %s():%d urbd=%p urb=%p\n",__func__,__LINE__,urbd,urb);
+				release_channel_dump(_ltqhc,urb,epqh,urbd,_halt_status);
+			}
+			break;
+		case HC_XFER_DATA_TOGGLE_ERR:
+			if(urbd)
+			{
+				urbd->phase=URBD_DEQUEUEING;
+				ltqhcd_complete_urb(_ltqhcd, urbd, -EOVERFLOW);
+			}
+			else
+			{
+				LTQ_WARN("WARNING %s():%d urbd=%p urb=%p\n",__func__,__LINE__,urbd,urb);
+				release_channel_dump(_ltqhc,urb,epqh,urbd,_halt_status);
+			}
+			break;
+		case HC_XFER_STOPPED:
+			_ltqhc->cancelling=0;
+			if (_ltqhc->is_in)
+			{
+				if(urbd && urb)
+				{
+					urbd->phase=URBD_COMPLETING;
+					ltqhcd_complete_urb(_ltqhcd, urbd, 0);
+				}
+				else
+				{
+					LTQ_WARN("WARNING %s():%d urbd=%p urb=%p\n",__func__,__LINE__,urbd,urb);
+					release_channel_dump(_ltqhc,urb,epqh,urbd,_halt_status);
+				}
+			}
+			else
+			{
+				LTQ_WARN("WARNING %s():%d urbd=%p urb=%p\n",__func__,__LINE__,urbd,urb);
+				release_channel_dump(_ltqhc,urb,epqh,urbd,_halt_status);
+			}
+			break;
+	#if defined(__INTRNAKRETRY__) || defined(__INTRINCRETRY__)
+		case HC_XFER_INTR_NAK_RETRY:
+			if(epqh)
+				epqh->phase=EPQH_READY;
+			if(urbd)
+				urbd->phase=URBD_IDLE;
+			_ltqhc->cancelling=0;
+			urbd->hc=0;
+			ltqhcd_hc_cleanup(&_ltqhcd->core_if, _ltqhc);
+			select_eps(_ltqhcd);
+			return;
+			break;
+
+	#endif
+	}
+	if(epqh)
+	{
+		ltqhcd_epqh_idle(epqh);
+	}
+	else if(_halt_status!=HC_XFER_NO_EPQH)
+	{
+		LTQ_WARN("WARNING %s():%d epqh=%p\n",__func__,__LINE__,epqh);
+		release_channel_dump(_ltqhc,urb,epqh,urbd,_halt_status);
+	}
+
+	if(_ltqhcd->burst)
+	if(epqh)
+	if(epqh->ep_type==LTQUSB_EP_TYPE_BULK)
+	if(epqh->burst_on && _halt_status== HC_XFER_URB_COMPLETE && !list_empty(&epqh->urbd_list))
+	{
+		struct list_head *urbd_ptr;
+		#ifdef USE_SAFE_URBD
+			struct list_head *urbd_ptr_next;
+		#endif
+
+		#ifdef __DYN_SOF_INTR__
+			_ltqhcd->dyn_sof_count = DYN_SOF_COUNT_DEF;
+		#endif
+
+		LOCK_EPQH_LIST(_ltqhcd);
+		LOCK_URBD_LIST(epqh);
+		#ifdef USE_SAFE_URBD
+		list_for_each_safe(urbd_ptr, urbd_ptr_next, &epqh->urbd_list)
+		#else //USE_SAFE_URBD
+		urbd_ptr       = epqh->urbd_list.next;
+		while (urbd_ptr != &epqh->urbd_list)
+		#endif //USE_SAFE_URBD
+		{
+			urbd = list_entry(urbd_ptr, ltqhcd_urbd_t, ql);
+			#ifndef USE_SAFE_URBD
+				urbd_ptr=urbd_ptr->next;
+			#endif //USE_SAFE_URBD
+
+			if(urbd->phase==URBD_ACTIVE || urbd->phase==URBD_RUNNING)
+				break;
+			if(urbd->phase==URBD_IDLE)
+			{
+				urbd->hc=_ltqhc;
+				_ltqhc->urbd=urbd;
+				#ifdef __EPQD_DESTROY_TIMEOUT__
+					del_timer(&epqh->destroy_timer);
+				#endif
+
+				_ltqhc->halt_status = HC_XFER_NO_HALT_STATUS;
+
+			#if defined(__UNALIGNED_BUF_ADJ__)
+				if(urbd->aligned_buf)
+					_ltqhc->xfer_buff = urbd->aligned_buf;
+				else
+			#endif
+					_ltqhc->xfer_buff = urbd->xfer_buff;
+				_ltqhc->xfer_len       = urbd->xfer_len;
+				_ltqhc->xfer_count     = 0;
+				_ltqhc->sof_delay      = 0;
+				if(urb)
+				{
+					if(usb_gettoggle (urb->dev,usb_pipeendpoint (urb->pipe), (_ltqhc->is_in)?0:1))
+						_ltqhc->data_pid_start = LTQUSB_HCTSIZ_DATA1;
+					else
+						_ltqhc->data_pid_start = LTQUSB_HCTSIZ_DATA0;
+				}
+				if(_ltqhc->is_in)
+					_ltqhc->short_rw       =0;
+				else if(urb)
+					_ltqhc->short_rw       =(urb->transfer_flags & URB_ZERO_PACKET)?1:0;
+//				epqh->do_ping=1;
+				{
+					hcint_data_t      hc_intr_mask;
+
+					/* Clear old interrupt conditions for this host channel. */
+					hc_intr_mask.d32 = 0xFFFFFFFF;
+					hc_intr_mask.b.reserved = 0;
+					ltqusb_wreg(&hc_regs->hcint, hc_intr_mask.d32);
+
+					/* Enable channel interrupts required for this transfer. */
+					hc_intr_mask.d32 = 0;
+					hc_intr_mask.b.chhltd = 1;
+					hc_intr_mask.b.ahberr = 1;
+
+					ltqusb_wreg(&hc_regs->hcintmsk, hc_intr_mask.d32);
+
+					/* Enable the top level host channel interrupt. */
+					{
+						uint32_t          intr_enable;
+						intr_enable = (1 << _ltqhc->hc_num);
+						ltqusb_mreg(&_ltqhcd->core_if.host_global_regs->haintmsk, 0, intr_enable);
+					}
+
+					/* Make sure host channel interrupts are enabled. */
+					{
+						gint_data_t       gintmsk ={.d32 = 0};
+						gintmsk.b.hcintr = 1;
+						ltqusb_mreg(&_ltqhcd->core_if.core_global_regs->gintmsk, 0, gintmsk.d32);
+					}
+				}
+
+				epqh->phase=EPQH_ACTIVE;
+//				urbd->phase=URBD_ACTIVE;
+				ltqhcd_hc_start(_ltqhcd, _ltqhc,1);
+				UNLOCK_URBD_LIST(epqh);
+				UNLOCK_EPQH_LIST(_ltqhcd);
+				select_eps(_ltqhcd);
+				return;
+			}
+		}
+		UNLOCK_URBD_LIST(epqh);
+		UNLOCK_EPQH_LIST(_ltqhcd);
+	}
+	urbd->hc=0;
+	ltqhcd_hc_cleanup(&_ltqhcd->core_if, _ltqhc);
+	select_eps(_ltqhcd);
+}
+
+/*
+ * Updates the state of the URB after a Transfer Complete interrupt on the
+ * host channel. Updates the actual_length field of the URB based on the
+ * number of bytes transferred via the host channel. Sets the URB status
+ * if the data transfer is finished.
+ *
+ * @return 1 if the data transfer specified by the URB is completely finished,
+ * 0 otherwise.
+ */
+static
+int update_urb_state_xfer_comp(ltqhcd_hc_t       *_ltqhc,
+                                      ltqusb_hc_regs_t  *_hc_regs,
+                                      struct urb        *_urb,
+                                      ltqhcd_urbd_t      *_urbd)
+{
+	int xfer_done  = 0;
+
+	#ifdef __EN_ISOC__
+	if(_urbd->epqh->ep_type==LTQUSB_EP_TYPE_ISOC)
+	{
+		struct usb_iso_packet_descriptor *frame_desc;
+		frame_desc            = &_urb->iso_frame_desc[_urbd->isoc_frame_index];
+		if (_ltqhc->is_in)
+		{
+			hctsiz_data_t hctsiz;
+			hctsiz.d32 = ltqusb_rreg(&_hc_regs->hctsiz);
+			frame_desc->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+			if ((hctsiz.b.xfersize != 0) || (frame_desc->actual_length >= _urbd->xfer_len))
+			{
+				xfer_done = 1;
+				frame_desc->status = 0;
+				#if 0
+					if (frame_desc->actual_length < frame_desc->length && _urb->transfer_flags & URB_SHORT_NOT_OK)
+						frame_desc->status = -EREMOTEIO;
+				#endif
+			}
+		}
+		else
+		{
+			if (_ltqhc->split)
+				frame_desc->actual_length +=  _ltqhc->ssplit_out_xfer_count;
+			else
+				frame_desc->actual_length +=  _ltqhc->xfer_len;
+			if (frame_desc->actual_length >= _urbd->xfer_len)
+			{
+				xfer_done = 1;
+				frame_desc->status = 0;
+			}
+		}
+	}
+	else
+	#endif
+	if (_ltqhc->is_in)
+	{
+		hctsiz_data_t hctsiz;
+		hctsiz.d32 = ltqusb_rreg(&_hc_regs->hctsiz);
+		_urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+#ifdef __INTRINCRETRY__
+		if(_urbd->epqh->ep_type==LTQUSB_EP_TYPE_INTR)
+		{
+			if(_ltqhc->xfer_len != hctsiz.b.xfersize)
+			{
+				xfer_done = 1;
+				_urbd->status = 0;
+			}
+		}
+		else
+#endif
+		if (((hctsiz.b.xfersize% _ltqhc->mps) != 0) || (_urb->actual_length >= _urb->transfer_buffer_length))
+		{
+			xfer_done = 1;
+			_urbd->status = 0;
+			if(_urb->transfer_flags & URB_SHORT_NOT_OK)
+			{
+				if (_urb->actual_length < _urb->transfer_buffer_length)
+					_urbd->status = -EREMOTEIO;
+			}
+		}
+		else if(_ltqhc->start_pkt_count>hctsiz.b.pktcnt) // hctsiz.b.xfersize% _ltqhc->mps) == 0
+		{
+			int pkt_xfer1,pkt_xfer2;
+			pkt_xfer1=_ltqhc->start_pkt_count-hctsiz.b.pktcnt;
+			pkt_xfer2=(_ltqhc->xfer_len - hctsiz.b.xfersize)/ _ltqhc->mps;
+			if(pkt_xfer1>pkt_xfer2)
+			{
+				xfer_done = 1;
+				_urbd->status = 0;
+				if(_urb->transfer_flags & URB_SHORT_NOT_OK)
+				{
+					if (_urb->actual_length < _urb->transfer_buffer_length)
+						_urbd->status = -EREMOTEIO;
+				}
+			}
+		}
+	}
+	else if(_urb->transfer_buffer_length%_ltqhc->mps) // OUT without ZLP
+	{
+		if (_ltqhc->split)
+			_urb->actual_length +=  _ltqhc->ssplit_out_xfer_count;
+		else
+			_urb->actual_length +=  _ltqhc->xfer_len;
+		if (_urb->actual_length >= _urb->transfer_buffer_length)
+		{
+			xfer_done = 1;
+			_urbd->status = 0;
+		}
+	}
+	else if (_urb->actual_length >= _urb->transfer_buffer_length) //OUT with ZLP
+	{
+		xfer_done = 1;
+		_urbd->status = 0;
+	}
+	else //OUT without ZLP, unfinished
+	{
+		if (_ltqhc->split)
+			_urb->actual_length +=  _ltqhc->ssplit_out_xfer_count;
+		else
+			_urb->actual_length +=  _ltqhc->xfer_len;
+		if (!_ltqhc->short_rw && _urb->actual_length >= _urb->transfer_buffer_length)
+		{
+			xfer_done = 1;
+			_urbd->status = 0;
+		}
+	}
+
+	#ifdef __DEBUG__
+		{
+			hctsiz_data_t 	hctsiz;
+			hctsiz.d32 = ltqusb_rreg(&_hc_regs->hctsiz);
+			LTQ_DEBUGPL(DBG_HCDV, "LTQUSB: %s: %s, channel %d\n",
+				    __func__, (_ltqhc->is_in ? "IN" : "OUT"), _ltqhc->hc_num);
+			LTQ_DEBUGPL(DBG_HCDV, "  hc->xfer_len %d\n", _ltqhc->xfer_len);
+			LTQ_DEBUGPL(DBG_HCDV, "  hctsiz.xfersize %d\n", hctsiz.b.xfersize);
+			#ifdef __EN_ISOC__
+			if(_urbd->epqh->ep_type==LTQUSB_EP_TYPE_ISOC)
+			{
+				LTQ_DEBUGPL(DBG_HCDV, "  descritor # %d\n", _urbd->isoc_frame_index);
+				LTQ_DEBUGPL(DBG_HCDV, "  buffer_length %d\n",
+					_urb->iso_frame_desc[_urbd->isoc_frame_index].length);
+				LTQ_DEBUGPL(DBG_HCDV, "  actual_length %d\n", _urb->iso_frame_desc[_urbd->isoc_frame_index].actual_length);
+			}
+			else
+			#endif
+			{
+				LTQ_DEBUGPL(DBG_HCDV, "  urb->transfer_buffer_length %d\n",
+					    _urb->transfer_buffer_length);
+				LTQ_DEBUGPL(DBG_HCDV, "  urb->actual_length %d\n", _urb->actual_length);
+			}
+		}
+	#endif
+
+	return xfer_done;
+}
+
+#ifdef __EN_ISOC__
+	static
+	void next_isoc_sub(unsigned long data)
+	{
+		ltqhcd_urbd_t *urbd;
+		ltqhcd_hcd_t *ltqhcd;
+
+		urbd=((ltqhcd_urbd_t *)data);
+		ltqhcd=urbd->epqh->ltqhcd;
+
+		if (!urbd->epqh)
+			LTQ_ERROR("%s: invalid epqd\n",__func__);
+		#if   defined(__UNALIGNED_BUF_ADJ__)
+		else
+		{
+			if( urbd->aligned_checked   &&
+			    urbd->xfer_buff &&
+			    urbd->is_in)
+			{
+				uint8_t *buf;
+
+				buf=urbd->xfer_buff;
+				buf+=urbd->urb->iso_frame_desc[urbd->isoc_frame_index].offset;
+				memcpy(buf,urbd->aligned_buf,urbd->urb->iso_frame_desc[urbd->isoc_frame_index].length);
+			}
+		}
+		#endif
+
+		urbd->isoc_frame_index++;
+		if(urbd->isoc_frame_index>=urbd->urb->number_of_packets)
+			release_channel(ltqhcd,urbd->hc,HC_XFER_URB_COMPLETE);
+		else
+			init_hc(urbd->epqh,urbd->hc);
+	}
+#endif
+
+/*!
+	 \fn    static void complete_channel(ltqhcd_hcd_t        *_ltqhcd,
+                            ltqhcd_hc_t          *_ltqhc,
+                            ltqhcd_urbd_t        *_urbd)
+	 \brief Complete the transaction on the channel.
+	 \param _ltqhcd Pointer to the sate of HCD structure
+	 \param _ltqhc Pointer to host channel descriptor
+	 \param _urbd Pointer to URB descriptor
+	 \return None
+	 \ingroup  LTQUSB_HCD
+ */
+static
+void complete_channel(ltqhcd_hcd_t        *_ltqhcd,
+                            ltqhcd_hc_t          *_ltqhc,
+                            ltqhcd_urbd_t        *_urbd)
+{
+	ltqusb_hc_regs_t *hc_regs = _ltqhcd->core_if.hc_regs[_ltqhc->hc_num];
+	struct urb    *urb  = NULL;
+	ltqhcd_epqh_t *epqh = NULL;
+	int urb_xfer_done;
+
+	LTQ_DEBUGPL(DBG_HCD, "--Complete Channel %d : \n", _ltqhc->hc_num);
+
+	if(!_urbd)
+	{
+		LTQ_ERROR("ERROR %s():%d urbd=%p\n",__func__,__LINE__,_urbd);
+		return;
+	}
+
+	urb  = _urbd->urb;
+	epqh = _urbd->epqh;
+
+	if(!epqh)
+	{
+		release_channel(_ltqhcd,_ltqhc,HC_XFER_NO_EPQH);
+		return;
+	}
+	if(!urb || (unsigned long)urb->hcpriv!=(unsigned long)_urbd)
+	{
+		release_channel(_ltqhcd,_ltqhc,HC_XFER_NO_URB);
+		return;
+	}
+
+	if (_ltqhc->split)
+		_ltqhc->split = 1;
+
+	switch (epqh->ep_type)
+	{
+		case LTQUSB_EP_TYPE_CTRL:
+			switch (_ltqhc->control_phase)
+			{
+				case LTQHCD_CONTROL_SETUP:
+					if (_urbd->xfer_len > 0)
+					{
+						_ltqhc->control_phase = LTQHCD_CONTROL_DATA;
+						LTQ_DEBUGPL(DBG_HCDV, "  Control setup transaction done Data Stage now\n");
+						_ltqhc->is_in         = _urbd->is_in;
+						_ltqhc->xfer_len      = _urbd->xfer_len;
+						#if   defined(__UNALIGNED_BUF_ADJ__)
+							if(_urbd->aligned_buf)
+								_ltqhc->xfer_buff      = _urbd->aligned_buf;
+							else
+						#endif
+								_ltqhc->xfer_buff      = _urbd->xfer_buff;
+					}
+					else
+					{
+						LTQ_DEBUGPL(DBG_HCDV, "  Control setup transaction done Status Stage now\n");
+						_ltqhc->control_phase = LTQHCD_CONTROL_STATUS;
+						_ltqhc->is_in          = 1;
+						_ltqhc->xfer_len       = 0;
+						_ltqhc->xfer_buff      = _ltqhcd->status_buf;
+					}
+					if(_ltqhc->is_in)
+						_ltqhc->short_rw       =0;
+					else
+						_ltqhc->short_rw       =(urb->transfer_flags & URB_ZERO_PACKET)?1:0;
+					_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA1;
+					_ltqhc->xfer_count     = 0;
+					_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+					ltqhcd_hc_start(_ltqhcd, _ltqhc, 1);
+					break;
+				case LTQHCD_CONTROL_DATA:
+					urb_xfer_done = update_urb_state_xfer_comp(_ltqhc, hc_regs, urb, _urbd);
+					if (urb_xfer_done)
+					{
+#if 1
+if(_ltqhc->is_in)
+if(_urbd->urb->actual_length==18)
+{
+	__le16 vid,pid;
+	vid=le16_to_cpup((__le16 *)(_urbd->xfer_buff+8 ));
+	pid=le16_to_cpup((__le16 *)(_urbd->xfer_buff+10));
+
+	switch(vid)
+	{
+		case 0X1C9E:
+			switch(pid)
+			{
+				case 0X9B03:
+				case 0X9B05:
+					_ltqhcd->singlexact=1;
+					_ltqhcd->xfer_prot1_usec= 100;
+					_ltqhcd->xfer_prot2_usec= 0;
+					_ltqhcd->xfer_prot1_value= XFER_PROT1_CALC(_ltqhcd->xfer_prot1_usec);
+					_ltqhcd->xfer_prot2_value= XFER_PROT2_CALC(_ltqhcd->xfer_prot2_usec);
+					printk(KERN_INFO "ID:%04x/%04x LC\n",vid,pid);
+					break;
+				default:
+					printk(KERN_INFO "ID:%04x/%04X\n",vid,pid);
+			}
+			break;
+		default:
+			printk(KERN_INFO "ID:%04x/%04X\n",vid,pid);
+	}
+}
+#endif
+						_ltqhc->control_phase  = LTQHCD_CONTROL_STATUS;
+						LTQ_DEBUGPL(DBG_HCDV, "  Control data transaction done Status Stage now\n");
+						_ltqhc->is_in          = (_urbd->is_in)?0:1;
+						_ltqhc->xfer_len       = 0;
+						_ltqhc->xfer_count     = 0;
+						_ltqhc->xfer_buff      = _ltqhcd->status_buf;
+						_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+						_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA1;
+						if(_ltqhc->is_in)
+							_ltqhc->short_rw       =0;
+						else
+							_ltqhc->short_rw       =1;
+					}
+					else // continue
+					{
+						LTQ_DEBUGPL(DBG_HCDV, "  Control data transaction continue\n");
+						_ltqhc->xfer_len       = _urbd->xfer_len - urb->actual_length;
+						_ltqhc->xfer_count     = urb->actual_length;
+						_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+						_ltqhc->data_pid_start = read_data_toggle(hc_regs);
+					}
+					ltqhcd_hc_start(_ltqhcd, _ltqhc, 1);
+					break;
+				case LTQHCD_CONTROL_STATUS:
+					LTQ_DEBUGPL(DBG_HCDV, "  Control status transaction done\n");
+					if (_urbd->status == -EINPROGRESS)
+						_urbd->status = 0;
+					release_channel(_ltqhcd,_ltqhc,HC_XFER_URB_COMPLETE);
+					break;
+			}
+			break;
+		case LTQUSB_EP_TYPE_BULK:
+			LTQ_DEBUGPL(DBG_HCDV, "  Bulk transfer complete\n");
+			urb_xfer_done = update_urb_state_xfer_comp(_ltqhc, hc_regs, urb, _urbd);
+			if (urb_xfer_done)
+			{
+				release_channel(_ltqhcd,_ltqhc,HC_XFER_URB_COMPLETE);
+			}
+			else
+			{
+				_ltqhc->xfer_len       = _urbd->xfer_len - urb->actual_length;
+				_ltqhc->xfer_count     = urb->actual_length;
+				_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+				_ltqhc->data_pid_start = read_data_toggle(hc_regs);
+				ltqhcd_hc_start(_ltqhcd, _ltqhc, 1);
+			}
+			break;
+		case LTQUSB_EP_TYPE_INTR:
+			urb_xfer_done = update_urb_state_xfer_comp(_ltqhc, hc_regs, urb, _urbd);
+
+			#ifdef __INTRINCRETRY__
+			if(!urb_xfer_done)
+			{
+				release_channel(_ltqhcd,_ltqhc,HC_XFER_INTR_NAK_RETRY);
+			}
+			else
+			#endif
+			{
+				release_channel(_ltqhcd,_ltqhc,HC_XFER_URB_COMPLETE);
+			}
+			break;
+		case LTQUSB_EP_TYPE_ISOC:
+			#ifdef __EN_ISOC__
+				urb_xfer_done = update_urb_state_xfer_comp(_ltqhc, hc_regs, urb, _urbd);
+				if (urb_xfer_done)
+				{
+					#if   defined(__UNALIGNED_BUF_ADJ__)
+					if(in_irq())
+					{
+						if(!epqh->tasklet_next_isoc.func)
+						{
+							epqh->tasklet_next_isoc.next = NULL;
+							epqh->tasklet_next_isoc.state = 0;
+							atomic_set( &epqh->tasklet_next_isoc.count, 0);
+							epqh->tasklet_next_isoc.func = next_isoc_sub;
+							epqh->tasklet_next_isoc.data = (unsigned long)_urbd;
+						}
+						tasklet_schedule(&epqh->tasklet_next_isoc);
+					}
+					else
+					#endif
+					{
+						next_isoc_sub((unsigned long)_urbd);
+					}
+				}
+				else
+				{
+					struct usb_iso_packet_descriptor *frame_desc;
+					frame_desc            = &urb->iso_frame_desc[_urbd->isoc_frame_index];
+					_ltqhc->xfer_len       = _urbd->xfer_len - frame_desc->actual_length;
+					_ltqhc->xfer_count     = frame_desc->actual_length;
+					_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+					_ltqhc->data_pid_start = read_data_toggle(hc_regs);
+					ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+				}
+			#endif
+			break;
+	}
+}
+
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_ctrl_rx_nonsplit(ltqhcd_hcd_t      *_ltqhcd,
+                                        ltqhcd_hc_t       *_ltqhc,
+                                        ltqusb_hc_regs_t  *_hc_regs,
+                                        ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if (_ltqhc->halt_status == HC_XFER_STOPPED)
+	{
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+		{
+			u32 actual_length;
+			actual_length = _urbd->urb->actual_length + (_ltqhc->xfer_len - hctsiz.b.xfersize);
+			if(
+			   (_urbd->xfer_len && actual_length>=_urbd->xfer_len)
+			   || (hctsiz.b.xfersize % _ltqhc->mps)>0
+			  )
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else if(_ltqhc->start_pkt_count>hctsiz.b.pktcnt) // hctsiz.b.xfersize% _ltqhc->mps) == 0
+			{
+				int pkt_xfer1,pkt_xfer2;
+				pkt_xfer1=_ltqhc->start_pkt_count-hctsiz.b.pktcnt;
+				pkt_xfer2=(_ltqhc->xfer_len - hctsiz.b.xfersize)/ _ltqhc->mps;
+				if(pkt_xfer1>pkt_xfer2)
+				{
+					_urbd->error_count     =0;
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				}
+				else
+				{
+					_ltqhc->xfer_count        =
+					_urbd->urb->actual_length = actual_length;
+					_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+					_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+					_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+					ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+				}
+			}
+			else
+			{
+				_ltqhc->xfer_count        =
+				_urbd->urb->actual_length = actual_length;
+				_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+				_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+				_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+				ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+			}
+		}
+		else if(_ltqhc->control_phase == LTQHCD_CONTROL_STATUS)
+		{
+			if(hctsiz.b.pktcnt==0)
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else
+			{
+				_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+				ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+			}
+		}
+		else
+		{
+			printk(KERN_INFO "Warning: %s() %d Invalid CTRL Phase:%d\n",__func__,__LINE__,_ltqhc->control_phase);
+			release_channel(_ltqhcd, _ltqhc, _ltqhc->halt_status);
+		}
+		return 1;
+	}
+
+	if (hcint.b.xfercomp || hcint.d32 == 0x02 || hcint.d32 == 0x22)
+	{
+		_urbd->error_count     =0;
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+	}
+	else if (hcint.b.stall)
+	{
+		_urbd->error_count     =0;
+		// ZLP shortcut
+		#if 0
+		if(hctsiz.b.pktcnt==0)
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		else
+		#endif
+		#if 0
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_STATUS)
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		else
+		#endif
+		{
+			if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+				_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+//			if( _urbd->urb->actual_length > _ltqhc->xfer_len) _urbd->urb->actual_length = _urbd->xfer_len;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		}
+		return 1;
+	}
+	else if (hcint.b.bblerr)
+	{
+		_urbd->error_count     =0;
+
+		// ZLP shortcut
+		#if 0
+		if(hctsiz.b.pktcnt==0)
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		else
+		#endif
+		#if 0
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_STATUS)
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		else
+		#endif
+		{
+			if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+				_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+//			if( _urbd->urb->actual_length > _ltqhc->xfer_len) _urbd->urb->actual_length = _urbd->xfer_len;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		}
+		return 1;
+	}
+	else if (hcint.b.xacterr)
+	{
+		// ZLP shortcut
+		#if 1
+		if(hctsiz.b.pktcnt==0)
+		{
+			_urbd->error_count     =0;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else
+		#endif
+		#if 1
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_STATUS)
+		{
+			_urbd->error_count     =0;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else
+		#endif
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+		{
+			#if 1
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			#else
+				u32 actual_length;
+				actual_length = _urbd->urb->actual_length + (_ltqhc->xfer_len - hctsiz.b.xfersize);
+				if(actual_length >= _urbd->xfer_len)
+				{
+					_urbd->error_count     =0;
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				}
+				else
+				{
+					_urbd->error_count++;
+					_ltqhc->xfer_count        =
+					_urbd->urb->actual_length = actual_length;
+					_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+					_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+					if (_urbd->error_count >= 3)
+					{
+						_urbd->error_count     =0;
+						release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+					}
+					else
+					{
+						_ltqhc->erron=1;
+						ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+					}
+				}
+			#endif
+		}
+		else
+		{
+			_urbd->error_count     =0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		#if 0
+			#if 1
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			#else
+				u32 actual_length;
+				actual_length = _urbd->urb->actual_length + (_ltqhc->xfer_len - hctsiz.b.xfersize);
+				if(actual_length>=_urbd->xfer_len)
+				{
+					_urbd->error_count     =0;
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				}
+				else
+				{
+					_urbd->urb->actual_length = actual_length;
+					_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+					_urbd->error_count     =0;
+					release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+				}
+			#endif
+		#else
+			if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+				_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+//			if( _urbd->urb->actual_length > _ltqhc->xfer_len) _urbd->urb->actual_length = _urbd->xfer_len;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+		#endif
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+			_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+//		if( _urbd->urb->actual_length > _ltqhc->xfer_len) _urbd->urb->actual_length = _urbd->xfer_len;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else
+	{
+		_urbd->error_count     =0;
+		LTQ_ERROR("ERROR %s():%d invalid chhlt condition %08X/%08X  %d\n",__func__,__LINE__,hcint.d32,hcintmsk.d32,_ltqhc->halt_status);
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		return 1;
+	}
+
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_ctrl_tx_nonsplit(ltqhcd_hcd_t      *_ltqhcd,
+                                        ltqhcd_hc_t       *_ltqhc,
+                                        ltqusb_hc_regs_t  *_hc_regs,
+                                        ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if (_ltqhc->halt_status == HC_XFER_STOPPED)
+	{
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+		{
+			u32 actual_length;
+			actual_length = _urbd->urb->actual_length + ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+
+			if(_urbd->xfer_len && actual_length >= _urbd->xfer_len)
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else
+			{
+				_ltqhc->xfer_count        =
+				_urbd->urb->actual_length = actual_length;
+				_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+				_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+				_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+				_ltqhc->epqh->do_ping=1;
+				ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+			}
+		}
+		else if(_ltqhc->control_phase == LTQHCD_CONTROL_STATUS)
+		{
+			if(hctsiz.b.pktcnt==0)
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else
+			{
+				_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+				ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+			}
+		}
+		else
+		{
+			printk(KERN_INFO "Warning: %s() %d Invalid CTRL Phase:%d\n",__func__,__LINE__,_ltqhc->control_phase);
+			release_channel(_ltqhcd, _ltqhc, _ltqhc->halt_status);
+		}
+		return 1;
+	}
+
+
+	if (hcint.b.xfercomp || hcint.d32 == 0x02 || hcint.d32 == 0x22)
+	{
+		_urbd->error_count     =0;
+		if(_ltqhc->xfer_len==0 && !hcint.b.ack && hcint.b.nak)
+		{
+			// Walkaround: When sending ZLP and receive NAK but also issue CMPT intr
+			// Solution:   NoSplit: Resend at next SOF
+			//             Split  : Resend at next SOF with SSPLIT
+			if(hcint.b.nyet)
+				_ltqhc->epqh->do_ping=1;
+
+			_ltqhc->xfer_len       = 0;
+			_ltqhc->xfer_count     = 0;
+			_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		else
+		{
+			if(hcint.b.nyet)
+				_ltqhc->epqh->do_ping=1;
+			#if 1
+			if(hctsiz.b.pktcnt==0)
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else
+			#endif
+			if(_ltqhc->control_phase == LTQHCD_CONTROL_STATUS)
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else if(_ltqhc->control_phase == LTQHCD_CONTROL_SETUP)
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+			{
+				#if 0
+					_ltqhc->epqh->do_ping=1;
+					_urbd->error_count     =0;
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				#else
+					u32 actual_length;
+					_ltqhc->epqh->do_ping=1;
+					actual_length = _urbd->urb->actual_length + ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+					if(actual_length>=_urbd->xfer_len)
+					{
+						_urbd->error_count     =0;
+						complete_channel(_ltqhcd, _ltqhc, _urbd);
+					}
+					else
+					{
+						_ltqhc->xfer_count        =
+						_urbd->urb->actual_length = actual_length;
+						_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+						_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+						_ltqhc->erron=1;
+						_ltqhc->epqh->do_ping=1;
+						ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+					}
+				#endif
+			}
+		}
+		return 1;
+	}
+	else if (hcint.b.stall)
+	{
+		_urbd->error_count     =0;
+
+		// ZLP shortcut
+		#if 1
+		if(hctsiz.b.pktcnt==0)
+		{
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else
+		#endif
+		{
+			if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+				_urbd->urb->actual_length += ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		}
+		return 1;
+	}
+	else if (hcint.b.xacterr)
+	{
+		// ZLP shortcut
+		#if 1
+		if(hctsiz.b.pktcnt==0)
+		{
+			_urbd->error_count     =0;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else
+		#endif
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_STATUS)
+		{
+			_urbd->error_count     =0;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else if(_ltqhc->control_phase == LTQHCD_CONTROL_SETUP)
+		{
+			_urbd->error_count     =0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+		{
+			#if 0
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			#else
+				u32 actual_length;
+				actual_length = _urbd->urb->actual_length + ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+				if(actual_length>=_urbd->xfer_len)
+				{
+					_urbd->error_count     =0;
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				}
+				else
+				{
+					_urbd->error_count++;
+					_ltqhc->xfer_count        =
+					_urbd->urb->actual_length = actual_length;
+					_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+					_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+					if (_urbd->error_count >= 3)
+					{
+						_urbd->error_count     =0;
+						release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+					}
+					else
+					{
+						_ltqhc->erron=1;
+						_ltqhc->epqh->do_ping=1;
+						ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+					}
+				}
+			#endif
+		}
+		else
+		{
+			_urbd->error_count     =0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+			_urbd->urb->actual_length += ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.nak || hcint.b.nyet)
+	{
+		#if 1
+			_urbd->error_count     =0;
+			LTQ_ERROR("ERROR %s():%d invalid chhlt condition\n",__func__,__LINE__);
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		#else
+			// ZLP shortcut
+			#if 1
+			if(hctsiz.b.pktcnt==0)
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else
+			#endif
+			if(_ltqhc->control_phase == LTQHCD_CONTROL_STATUS)
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else if(_ltqhc->control_phase == LTQHCD_CONTROL_SETUP)
+			{
+				_urbd->error_count     =0;
+				LTQ_ERROR("ERROR %s():%d invalid chhlt condition\n",__func__,__LINE__);
+				release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+			}
+			else if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+			{
+				#if 0
+					_ltqhc->epqh->do_ping=1;
+					_urbd->error_count     =0;
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				#else
+					u32 actual_length;
+					_ltqhc->epqh->do_ping=1;
+					actual_length = _urbd->urb->actual_length + ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+					if(actual_length>=_urbd->xfer_len)
+					{
+						_urbd->error_count     =0;
+						complete_channel(_ltqhcd, _ltqhc, _urbd);
+					}
+					else
+					{
+						_ltqhc->xfer_count        =
+						_urbd->urb->actual_length = actual_length;
+						_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+						_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+						_ltqhc->erron=1;
+						_ltqhc->epqh->do_ping=1;
+						ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+					}
+				#endif
+			}
+		#endif
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+		{
+			_urbd->urb->actual_length += ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+//			if( _urbd->urb->actual_length > _ltqhc->xfer_len) _urbd->urb->actual_length = _urbd->xfer_len;
+		}
+		_urbd->error_count     =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+		{
+			_urbd->urb->actual_length += ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+//			if( _urbd->urb->actual_length > _ltqhc->xfer_len) _urbd->urb->actual_length = _urbd->xfer_len;
+		}
+		_urbd->error_count     =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else
+	{
+		_urbd->error_count     =0;
+		LTQ_ERROR("ERROR %s():%d invalid chhlt condition %08X/%08X  %d\n",__func__,__LINE__,hcint.d32,hcintmsk.d32,_ltqhc->halt_status);
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		return 1;
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_bulk_rx_nonsplit(ltqhcd_hcd_t      *_ltqhcd,
+                                        ltqhcd_hc_t       *_ltqhc,
+                                        ltqusb_hc_regs_t  *_hc_regs,
+                                        ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if(_ltqhc->halt_status == HC_XFER_STOPPED)
+	{
+		u32 actual_length;
+		actual_length = _urbd->urb->actual_length + (_ltqhc->xfer_len - hctsiz.b.xfersize);
+
+		if(
+		   (_urbd->xfer_len && actual_length>=_urbd->xfer_len)
+		   || hctsiz.b.pktcnt==0
+		   || (hctsiz.b.xfersize % _ltqhc->mps)>0
+		  )
+		{
+			_urbd->error_count     =0;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else if(_ltqhc->start_pkt_count>hctsiz.b.pktcnt) // hctsiz.b.xfersize% _ltqhc->mps) == 0
+		{
+			int pkt_xfer1,pkt_xfer2;
+			pkt_xfer1=_ltqhc->start_pkt_count-hctsiz.b.pktcnt;
+			pkt_xfer2=(_ltqhc->xfer_len - hctsiz.b.xfersize)/ _ltqhc->mps;
+			if(pkt_xfer1>pkt_xfer2)
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else
+			{
+				_urbd->urb->actual_length = actual_length;
+				_ltqhc->xfer_len          = _urbd->xfer_len - _urbd->urb->actual_length;
+				_ltqhc->xfer_count        = _urbd->urb->actual_length;
+				_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+				_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+				ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+			}
+		}
+		else
+		{
+			_urbd->urb->actual_length = actual_length;
+			_ltqhc->xfer_len          = _urbd->xfer_len - _urbd->urb->actual_length;
+			_ltqhc->xfer_count        = _urbd->urb->actual_length;
+			_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+			_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+
+	hcint.b.ack=0;
+	hcint.b.nak=0;
+
+	if (hcint.b.xfercomp || hcint.d32 == 0x02 || hcint.d32 == 0x22)
+	{
+		_urbd->error_count     =0;
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+	}
+	else if (hcint.b.stall)
+	{
+		_urbd->error_count     =0;
+		// ZLP shortcut
+		#if 0
+		if(hctsiz.b.pktcnt==0)
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		else
+		#endif
+		{
+			_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		}
+		return 1;
+	}
+	else if (hcint.b.bblerr)
+	{
+		_urbd->error_count     =0;
+
+		// ZLP shortcut
+		#if 0
+		if(hctsiz.b.pktcnt==0)
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		else
+		#endif
+		{
+			_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		}
+		return 1;
+	}
+	else if (hcint.b.xacterr)
+	{
+		// ZLP shortcut
+		#if 1
+		if(hctsiz.b.pktcnt==0)
+		{
+			_urbd->error_count     =0;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else
+		#endif
+		{
+			#if 0
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			#else
+				u32 actual_length;
+				actual_length = _urbd->urb->actual_length + (_ltqhc->xfer_len - hctsiz.b.xfersize);
+				if(actual_length >= _urbd->xfer_len)
+				{
+					_urbd->error_count     =0;
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				}
+				else
+				{
+					_urbd->error_count++;
+					_ltqhc->xfer_count        =
+					_urbd->urb->actual_length = actual_length;
+					_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+					_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+					if (_urbd->error_count >= 3)
+					{
+						_urbd->error_count     =0;
+						release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+					}
+					else
+					{
+						_ltqhc->erron=1;
+						ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+					}
+				}
+			#endif
+		}
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		#if 0
+			#if 1
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			#else
+				u32 actual_length;
+				actual_length = _urbd->urb->actual_length + (_ltqhc->xfer_len - hctsiz.b.xfersize);
+				if(actual_length >= _urbd->xfer_len)
+				{
+					_urbd->error_count     =0;
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				}
+				else
+				{
+					_urbd->urb->actual_length = actual_length;
+					_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+					_urbd->error_count     =0;
+					release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+				}
+			#endif
+		#else
+			_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+//			if( _urbd->urb->actual_length > _ltqhc->xfer_len) _urbd->urb->actual_length = _urbd->xfer_len;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+		#endif
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+//		if( _urbd->urb->actual_length > _ltqhc->xfer_len) _urbd->urb->actual_length = _urbd->xfer_len;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else
+	{
+		_urbd->error_count     =0;
+		LTQ_ERROR("ERROR %s():%d invalid chhlt condition %08X/%08X %d sz:%d/%d/%d/%d\n",__func__,__LINE__,hcint.d32,hcintmsk.d32,_ltqhc->halt_status , hctsiz.b.xfersize, _ltqhc->xfer_len-_ltqhc->xfer_len,_ltqhc->xfer_len,_urbd->xfer_len);
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		return 1;
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_bulk_tx_nonsplit(ltqhcd_hcd_t      *_ltqhcd,
+                                        ltqhcd_hc_t       *_ltqhc,
+                                        ltqusb_hc_regs_t  *_hc_regs,
+                                        ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+	int out_nak_enh = 0;
+
+	if (_ltqhcd->core_if.snpsid >= 0x4f54271a && _ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+		out_nak_enh = 1;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if (_ltqhc->halt_status == HC_XFER_STOPPED)
+	{
+		u32 actual_length;
+		actual_length = _urbd->urb->actual_length + ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+
+		if(_urbd->xfer_len && actual_length >= _urbd->xfer_len)
+		{
+			_urbd->error_count     =0;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else
+		{
+			_ltqhc->xfer_count        =
+			_urbd->urb->actual_length = actual_length;
+			_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+			_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+			_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+			_ltqhc->epqh->do_ping=1;
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+
+	if (hcint.b.xfercomp || hcint.d32 == 0x02 || hcint.d32 == 0x22 )
+	{
+		_urbd->error_count     =0;
+		if(_ltqhc->xfer_len==0 && !hcint.b.ack && hcint.b.nak)
+		{
+			// Walkaround: When sending ZLP and receive NAK but also issue CMPT intr
+			// Solution:   NoSplit: Resend at next SOF
+			//             Split  : Resend at next SOF with SSPLIT
+			if(hcint.b.nyet)
+				_ltqhc->epqh->do_ping=1;
+
+			_ltqhc->xfer_len       = 0;
+			_ltqhc->xfer_count     = 0;
+			_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		else
+		{
+			if(hcint.b.nyet)
+				_ltqhc->epqh->do_ping=1;
+			#if 1
+			if(hctsiz.b.pktcnt==0)
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else
+			#endif
+			{
+				#if 0
+					_ltqhc->epqh->do_ping=1;
+					_urbd->error_count     =0;
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				#else
+					u32 actual_length;
+					_ltqhc->epqh->do_ping=1;
+					actual_length = _urbd->urb->actual_length + ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+					if(actual_length>=_urbd->xfer_len)
+					{
+						_urbd->error_count     =0;
+						complete_channel(_ltqhcd, _ltqhc, _urbd);
+					}
+					else
+					{
+						_ltqhc->xfer_count        =
+						_urbd->urb->actual_length = actual_length;
+						_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+						_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+						_ltqhc->erron=1;
+						_ltqhc->epqh->do_ping=1;
+						ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+					}
+				#endif
+			}
+		}
+		return 1;
+	}
+	else if (hcint.b.stall)
+	{
+		_urbd->error_count     =0;
+
+		// ZLP shortcut
+		#if 1
+		if(hctsiz.b.pktcnt==0)
+		{
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else
+		#endif
+		{
+			_urbd->urb->actual_length += ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+			if(_urbd->urb->actual_length>_urbd->xfer_len) _urbd->urb->actual_length=_urbd->xfer_len;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		}
+		return 1;
+	}
+	else if (hcint.b.xacterr)
+	{
+		// ZLP shortcut
+		#if 1
+		if(hctsiz.b.pktcnt==0)
+		{
+			_urbd->error_count     =0;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else
+		#endif
+		{
+			#if 0
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			#else
+				u32 actual_length;
+				actual_length = _urbd->urb->actual_length + ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+				if(actual_length >= _urbd->xfer_len)
+				{
+					_urbd->error_count     =0;
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				}
+				else
+				{
+					_urbd->error_count++;
+					_ltqhc->xfer_count        =
+					_urbd->urb->actual_length = actual_length;
+					_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+					_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+					if (_urbd->error_count >= 3)
+					{
+						_urbd->error_count     =0;
+						release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+					}
+					else
+					{
+						_ltqhc->erron=1;
+						_ltqhc->epqh->do_ping=1;
+						ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+					}
+				}
+			#endif
+		}
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		_urbd->urb->actual_length += ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+		if(_urbd->urb->actual_length>_urbd->xfer_len) _urbd->urb->actual_length=_urbd->xfer_len;
+		LTQ_ERROR("ERROR %s():%d invalid packet babble\n",__func__,__LINE__);
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.nak || hcint.b.nyet)
+	{
+		#if 1
+			_urbd->error_count     =0;
+			LTQ_ERROR("ERROR %s():%d invalid chhlt condition\n",__func__,__LINE__);
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		#else
+			// ZLP shortcut
+			#if 1
+			if(hctsiz.b.pktcnt==0)
+			{
+				_urbd->error_count     =0;
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			}
+			else
+			#endif
+			{
+				#if 0
+					_ltqhc->epqh->do_ping=1;
+					_urbd->error_count     =0;
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				#else
+					u32 actual_length;
+					_ltqhc->epqh->do_ping=1;
+					actual_length = _urbd->urb->actual_length + ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+					if(actual_length>=_urbd->xfer_len)
+					{
+						_urbd->error_count     =0;
+						complete_channel(_ltqhcd, _ltqhc, _urbd);
+					}
+					else
+					{
+						_ltqhc->xfer_count        =
+						_urbd->urb->actual_length = actual_length;
+						_ltqhc->xfer_len          = _urbd->xfer_len - actual_length;
+						_ltqhc->data_pid_start    = read_data_toggle(_hc_regs);
+						_ltqhc->erron=1;
+						_ltqhc->epqh->do_ping=1;
+						ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+					}
+				#endif
+			}
+		#endif
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		_urbd->urb->actual_length += ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+//		if( _urbd->urb->actual_length > _ltqhc->xfer_len) _urbd->urb->actual_length = _urbd->xfer_len;
+		_urbd->error_count     =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		_urbd->urb->actual_length += ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+//		if( _urbd->urb->actual_length > _ltqhc->xfer_len) _urbd->urb->actual_length = _urbd->xfer_len;
+		_urbd->error_count     =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else
+	{
+		_urbd->error_count     =0;
+		LTQ_ERROR("ERROR %s():%d invalid chhlt condition %08X/%08X  %d\n",__func__,__LINE__,hcint.d32,hcintmsk.d32,_ltqhc->halt_status);
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		return 1;
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_intr_rx_nonsplit(ltqhcd_hcd_t      *_ltqhcd,
+                                    ltqhcd_hc_t       *_ltqhc,
+                                    ltqusb_hc_regs_t  *_hc_regs,
+                                    ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if (hcint.b.xfercomp || hcint.d32 == 0x02 || hcint.d32 == 0x22)
+	{
+		_urbd->error_count   =0;
+		//restart INTR immediately
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+	}
+	else if (hcint.b.stall)
+	{
+		_urbd->error_count   =0;
+
+		// Don't care shortcut
+		#if 0
+		if(hctsiz.b.pktcnt==0)
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		else
+		#endif
+		{
+			_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		}
+		return 1;
+	}
+	else if (hcint.b.bblerr)
+	{
+		_urbd->error_count   =0;
+
+		// Don't care shortcut
+		#if 0
+		if(hctsiz.b.pktcnt==0)
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		else
+		#endif
+		{
+			_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		}
+		return 1;
+	}
+	else if (hcint.b.datatglerr)
+	{
+		_urbd->error_count   =0;
+		//restart INTR immediately
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+	}
+	else if (hcint.b.frmovrun)
+	{
+#if 0
+		_urbd->error_count   =0;
+		//restart INTR immediately
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+#else
+		#if 1
+		if(hctsiz.b.pktcnt==0)
+		{
+			_urbd->error_count     =0;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else
+		#endif
+		{
+			_urbd->error_count++;
+			if(_urbd->error_count>=3)
+			{
+				_urbd->error_count     =0;
+			}
+	//		complete_channel(_ltqhcd, _ltqhc, _urbd);
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+#endif
+	}
+	else if (hcint.b.xacterr)
+	{
+		// ZLP shortcut
+		#if 1
+		if(hctsiz.b.pktcnt==0)
+		{
+			_urbd->error_count     =0;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else
+		#endif
+		{
+			_urbd->error_count++;
+			if(_urbd->error_count>=3)
+			{
+				_urbd->error_count     =0;
+				release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+			}
+			else
+			{
+				ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+			}
+		}
+		return 1;
+	}
+	else if(hcint.b.nyet   )
+	{
+		return 1;
+	}
+	else if (hcint.b.nak)
+	{
+		#ifdef __INTRNAKRETRY__
+		if(hctsiz.b.pktcnt)
+		{
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_INTR_NAK_RETRY);
+			return 1;
+		}
+		#endif
+		_urbd->error_count   =0;
+		//restart INTR immediately
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+	}
+	else
+	{
+		_urbd->error_count   =0;
+		//restart INTR immediately
+		#if 0
+		if(hctsiz.b.pktcnt>0)
+		{
+			// TODO Re-initialize Channel (in next b_interval - 1 uF/F)
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		else
+		#endif
+		{
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		return 1;
+	}
+
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_intr_tx_nonsplit(ltqhcd_hcd_t      *_ltqhcd,
+                                    ltqhcd_hc_t       *_ltqhc,
+                                    ltqusb_hc_regs_t  *_hc_regs,
+                                    ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+	int out_nak_enh = 0;
+
+	if (_ltqhcd->core_if.snpsid >= 0x4f54271a && _ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+		out_nak_enh = 1;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+
+	if (hcint.b.xfercomp || hcint.d32 == 0x02 || hcint.d32 == 0x22)
+	{
+		disable_hc_int(_hc_regs,ack);
+		disable_hc_int(_hc_regs,nak);
+		disable_hc_int(_hc_regs,nyet);
+		_urbd->error_count   =0;
+		//restart INTR immediately
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+	}
+	else if (hcint.b.stall)
+	{
+		disable_hc_int(_hc_regs,ack);
+		disable_hc_int(_hc_regs,nyet);
+		disable_hc_int(_hc_regs,nak);
+		_urbd->error_count   =0;
+
+		// Don't care shortcut
+		#if 0
+		if(hctsiz.b.pktcnt==0)
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		else
+		#endif
+		{
+			if(_ltqhc->xfer_len!=0)// !_ltqhc->is_in
+				_urbd->urb->actual_length += ((_ltqhc->start_pkt_count - hctsiz.b.pktcnt ) * _ltqhc->mps);
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		}
+		return 1;
+	}
+	else if(hcint.b.nak || hcint.b.frmovrun )
+	{
+		disable_hc_int(_hc_regs,ack);
+		disable_hc_int(_hc_regs,nyet);
+		disable_hc_int(_hc_regs,nak);
+		_urbd->error_count   =0;
+		//restart INTR immediately
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+	}
+	else if(hcint.b.xacterr    )
+	{
+		// ZLP shortcut
+		#if 1
+		if(hctsiz.b.pktcnt==0)
+		{
+			_urbd->error_count     =0;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		else
+		#endif
+		{
+			_urbd->error_count++;
+			if(_urbd->error_count>=3)
+			{
+				_urbd->error_count     =0;
+				release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+			}
+			else
+			{
+				ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+			}
+		}
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		_urbd->error_count     =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		_urbd->error_count     =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+		return 1;
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_isoc_rx_nonsplit(ltqhcd_hcd_t      *_ltqhcd,
+                                    ltqhcd_hc_t       *_ltqhc,
+                                    ltqusb_hc_regs_t  *_hc_regs,
+                                    ltqhcd_urbd_t     *_urbd)
+{
+	#ifdef __EN_ISOC__
+		hcint_data_t  hcint;
+		hcint_data_t  hcintmsk;
+		hctsiz_data_t hctsiz;
+
+		hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+		hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+		hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+
+		if (hcint.b.xfercomp || hcint.b.frmovrun || hcint.d32 == 0x02)
+		{
+			_urbd->error_count=0;
+			disable_hc_int(_hc_regs,ack);
+			disable_hc_int(_hc_regs,nak);
+			disable_hc_int(_hc_regs,nyet);
+			if (hcint.b.xfercomp)
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+			else
+				release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		}
+		else if (hcint.b.xacterr || hcint.b.bblerr)
+		{
+			#ifndef VR9Skip
+				if(hctsiz.b.pktcnt==0)
+				{
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				}
+				else
+				{
+					_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+					_ltqhc->xfer_len           = _urbd->xfer_len - _urbd->urb->actual_length;
+					_ltqhc->xfer_count         = _urbd->urb->actual_length;
+					_ltqhc->data_pid_start = read_data_toggle(_hc_regs);
+					_urbd->error_count++;
+					if(_urbd->error_count>=3)
+					{
+						_urbd->error_count=0;
+						if (hcint.b.bblerr)
+							release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+						else if (hcint.b.xacterr)
+							release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+					}
+					else
+					{
+						enable_hc_int(_hc_regs,ack);
+						enable_hc_int(_hc_regs,nak);
+						enable_hc_int(_hc_regs,nyet);
+						ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+					}
+				}
+			#endif
+		}
+		else if(hcint.b.datatglerr )
+		{
+			return 1;
+		}
+		else if(hcint.b.stall      )
+		{
+			return 1;
+		}
+	#endif
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_isoc_tx_nonsplit(ltqhcd_hcd_t      *_ltqhcd,
+                                    ltqhcd_hc_t       *_ltqhc,
+                                    ltqusb_hc_regs_t  *_hc_regs,
+                                    ltqhcd_urbd_t     *_urbd)
+{
+	#ifdef __EN_ISOC__
+		hcint_data_t  hcint;
+		hcint_data_t  hcintmsk;
+		hctsiz_data_t hctsiz;
+		int out_nak_enh = 0;
+
+		if (_ltqhcd->core_if.snpsid >= 0x4f54271a && _ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+			out_nak_enh = 1;
+
+		hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+		hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+		hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+
+		if (hcint.b.xfercomp || hcint.d32 == 0x02)
+		{
+			_urbd->error_count=0;
+			disable_hc_int(_hc_regs,ack);
+			disable_hc_int(_hc_regs,nak);
+			disable_hc_int(_hc_regs,nyet);
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+			return 1;
+		}
+		else if (hcint.b.frmovrun)
+		{
+			#ifndef VR9Skip
+				_urbd->error_count=0;
+				disable_hc_int(_hc_regs,ack);
+				disable_hc_int(_hc_regs,nak);
+				disable_hc_int(_hc_regs,nyet);
+				release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+			#endif
+		}
+		else if(hcint.b.datatglerr )
+		{
+			return 1;
+		}
+		else if(hcint.b.bblerr     )
+		{
+			#ifndef VR9Skip
+				if(hctsiz.b.pktcnt==0)
+				{
+					complete_channel(_ltqhcd, _ltqhc, _urbd);
+				}
+				else
+				{
+					_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+					_ltqhc->xfer_len           = _urbd->xfer_len - _urbd->urb->actual_length;
+					_ltqhc->xfer_count         = _urbd->urb->actual_length;
+					_ltqhc->data_pid_start = read_data_toggle(_hc_regs);
+					_urbd->error_count++;
+					if(_urbd->error_count>=3)
+					{
+						_urbd->error_count=0;
+						release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+					}
+					else
+					{
+						enable_hc_int(_hc_regs,ack);
+						enable_hc_int(_hc_regs,nak);
+						enable_hc_int(_hc_regs,nyet);
+						ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+					}
+				}
+			#endif
+		}
+		else if(hcint.b.xacterr    )
+		{
+			if(hctsiz.b.pktcnt==0)
+			{
+				complete_channel(_ltqhcd, _ltqhc, _urbd);
+				return 1;
+			}
+			_urbd->error_count++;
+			if(_urbd->error_count>=3)
+			{
+				_urbd->error_count=0;
+				release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+			}
+			else
+			{
+				ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+			}
+			return 1;
+		}
+		else if(hcint.b.stall      )
+		{
+			return 1;
+		}
+	#endif
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_ctrl_rx_ssplit(ltqhcd_hcd_t      *_ltqhcd,
+                                      ltqhcd_hc_t       *_ltqhc,
+                                      ltqusb_hc_regs_t  *_hc_regs,
+                                      ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if (hcint.b.ack)
+	{
+		_urbd->error_count=0;
+		_ltqhc->split=2;
+		_ltqhc->data_pid_start = read_data_toggle(_hc_regs);
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if (hcint.b.nak)
+	{
+		_urbd->error_count     = 0;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if (hcint.b.xacterr)
+	{
+		_urbd->error_count++;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.stall      )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else if(hcint.b.nyet   )
+	{
+	}
+	else if(hcint.b.xfercomp   )
+	{
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_ctrl_tx_ssplit(ltqhcd_hcd_t      *_ltqhcd,
+                                      ltqhcd_hc_t       *_ltqhc,
+                                      ltqusb_hc_regs_t  *_hc_regs,
+                                      ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+	int out_nak_enh = 0;
+
+	if (_ltqhcd->core_if.snpsid >= 0x4f54271a && _ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+		out_nak_enh = 1;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if     (hcint.b.ack )
+	{
+		_urbd->error_count=0;
+		if (_ltqhc->control_phase != LTQHCD_CONTROL_SETUP)
+			_ltqhc->ssplit_out_xfer_count = _ltqhc->xfer_len;
+		_ltqhc->split=2;
+		_ltqhc->data_pid_start =read_data_toggle(_hc_regs);
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nyet)
+	{
+		_urbd->error_count=0;
+		if (_ltqhc->control_phase != LTQHCD_CONTROL_SETUP)
+			_ltqhc->ssplit_out_xfer_count = _ltqhc->xfer_len;
+		_ltqhc->split=2;
+		_ltqhc->data_pid_start =read_data_toggle(_hc_regs);
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nak        )
+	{
+		_urbd->error_count    =0;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.xacterr    )
+	{
+		_urbd->error_count++;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.stall      )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else if(hcint.b.xfercomp   )
+	{
+		printk(KERN_INFO "Warning: %s() %d CTRL OUT SPLIT1 COMPLETE\n",__func__,__LINE__);
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_bulk_rx_ssplit(ltqhcd_hcd_t              *_ltqhcd,
+                                      ltqhcd_hc_t       *_ltqhc,
+                                      ltqusb_hc_regs_t  *_hc_regs,
+                                      ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if (hcint.b.ack)
+	{
+		_urbd->error_count=0;
+		_ltqhc->split=2;
+		_ltqhc->data_pid_start = read_data_toggle(_hc_regs);
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if (hcint.b.nak)
+	{
+		_urbd->error_count     = 0;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if (hcint.b.xacterr)
+	{
+		_urbd->error_count++;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.stall      )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else if(hcint.b.nyet   )
+	{
+	}
+	else if(hcint.b.xfercomp   )
+	{
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_bulk_tx_ssplit(ltqhcd_hcd_t      *_ltqhcd,
+                                      ltqhcd_hc_t       *_ltqhc,
+                                      ltqusb_hc_regs_t  *_hc_regs,
+                                      ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+	int out_nak_enh = 0;
+
+	if (_ltqhcd->core_if.snpsid >= 0x4f54271a && _ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+		out_nak_enh = 1;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if     (hcint.b.ack )
+	{
+		_urbd->error_count=0;
+		_ltqhc->ssplit_out_xfer_count = _ltqhc->xfer_len;
+		_ltqhc->split=2;
+		_ltqhc->data_pid_start =read_data_toggle(_hc_regs);
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nyet)
+	{
+		_urbd->error_count=0;
+		_ltqhc->ssplit_out_xfer_count = _ltqhc->xfer_len;
+		_ltqhc->split=2;
+		_ltqhc->data_pid_start =read_data_toggle(_hc_regs);
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nak        )
+	{
+		_urbd->error_count    =0;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.xacterr    )
+	{
+		_urbd->error_count++;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.stall      )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else if(hcint.b.xfercomp   )
+	{
+		printk(KERN_INFO "Warning: %s() %d BULK OUT SPLIT1 COMPLETE\n",__func__,__LINE__);
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_intr_rx_ssplit(ltqhcd_hcd_t      *_ltqhcd,
+                                  ltqhcd_hc_t       *_ltqhc,
+                                  ltqusb_hc_regs_t  *_hc_regs,
+                                  ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if     (hcint.b.ack)
+	{
+		_urbd->error_count=0;
+		_ltqhc->split=2;
+		_ltqhc->data_pid_start = read_data_toggle(_hc_regs);
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nak)
+	{
+		_urbd->error_count=0;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.xacterr)
+	{
+		hcchar_data_t 	hcchar;
+		hcchar.d32 = ltqusb_rreg(&_hc_regs->hcchar);
+		_urbd->error_count=hcchar.b.multicnt;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.stall      )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.xfercomp   )
+	{
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_intr_tx_ssplit(ltqhcd_hcd_t      *_ltqhcd,
+                                  ltqhcd_hc_t       *_ltqhc,
+                                  ltqusb_hc_regs_t  *_hc_regs,
+                                  ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+	int out_nak_enh = 0;
+
+	if (_ltqhcd->core_if.snpsid >= 0x4f54271a && _ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+		out_nak_enh = 1;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if     (hcint.b.ack )
+	{
+		_urbd->error_count=0;
+		_ltqhc->ssplit_out_xfer_count = _ltqhc->xfer_len;
+		_ltqhc->split=2;
+		_ltqhc->data_pid_start = read_data_toggle(_hc_regs);
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nyet)
+	{
+		_urbd->error_count=0;
+		_ltqhc->ssplit_out_xfer_count = _ltqhc->xfer_len;
+		_ltqhc->split=2;
+		_ltqhc->data_pid_start = read_data_toggle(_hc_regs);
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nak        )
+	{
+		_urbd->error_count   =0;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		_urbd->error_count   =0;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.xacterr    )
+	{
+		hcchar_data_t 	hcchar;
+		hcchar.d32 = ltqusb_rreg(&_hc_regs->hcchar);
+		_urbd->error_count=hcchar.b.multicnt;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			enable_hc_int(_hc_regs,ack);
+			enable_hc_int(_hc_regs,nak);
+			enable_hc_int(_hc_regs,nyet);
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_DATA_TOGGLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.stall      )
+	{
+		_urbd->error_count   =0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		return 1;
+	}
+	else if(hcint.b.xfercomp   )
+	{
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_isoc_rx_ssplit(ltqhcd_hcd_t      *_ltqhcd,
+                                   ltqhcd_hc_t       *_ltqhc,
+                                   ltqusb_hc_regs_t  *_hc_regs,
+                                   ltqhcd_urbd_t     *_urbd)
+{
+	#if defined(__EN_ISOC__) && defined(__EN_ISOC_SPLIT__)
+		hcint_data_t  hcint;
+		hcint_data_t  hcintmsk;
+		hctsiz_data_t hctsiz;
+
+		hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+		hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+		hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+		if     (hcint.b.ack )
+		{
+			Do Complete Split
+		}
+		else if(hcint.b.frmovrun   )
+		{
+			Rewind Buffer Pointers
+			Retry Start Split (in next b_interval V 1 uF)
+		}
+		else if(hcint.b.datatglerr )
+		{
+			//warning
+		}
+		else if(hcint.b.bblerr     )
+		{
+			//warning
+		}
+		else if(hcint.b.xacterr    )
+		{
+			//warning
+		}
+		else if(hcint.b.stall      )
+		{
+			//warning
+		}
+		else if(hcint.b.nak        )
+		{
+			//warning
+		}
+		else if(hcint.b.xfercomp   )
+		{
+			//warning
+		}
+		else if(hcint.b.nyet)
+		{
+			//warning
+		}
+	#endif
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_isoc_tx_ssplit(ltqhcd_hcd_t      *_ltqhcd,
+                                   ltqhcd_hc_t       *_ltqhc,
+                                   ltqusb_hc_regs_t  *_hc_regs,
+                                   ltqhcd_urbd_t     *_urbd)
+{
+	#if defined(__EN_ISOC__) && defined(__EN_ISOC_SPLIT__)
+		hcint_data_t  hcint;
+		hcint_data_t  hcintmsk;
+		hctsiz_data_t hctsiz;
+		int out_nak_enh = 0;
+
+		if (_ltqhcd->core_if.snpsid >= 0x4f54271a && _ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+			out_nak_enh = 1;
+
+		hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+		hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+		hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+		if     (hcint.b.ack )
+		{
+			//Do Next Start Split (in next b_interval V 1 uF)
+		}
+		else if(hcint.b.frmovrun   )
+		{
+			//Do Next Transaction in next frame.
+		}
+		else if(hcint.b.datatglerr )
+		{
+			//warning
+		}
+		else if(hcint.b.bblerr     )
+		{
+			//warning
+		}
+		else if(hcint.b.xacterr    )
+		{
+			//warning
+		}
+		else if(hcint.b.stall      )
+		{
+			//warning
+		}
+		else if(hcint.b.nak        )
+		{
+			//warning
+		}
+		else if(hcint.b.xfercomp   )
+		{
+			//warning
+		}
+		else if(hcint.b.nyet)
+		{
+			//warning
+		}
+	#endif
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_ctrl_rx_csplit(ltqhcd_hcd_t      *_ltqhcd,
+                                      ltqhcd_hc_t       *_ltqhc,
+                                      ltqusb_hc_regs_t  *_hc_regs,
+                                      ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if (hcint.b.xfercomp)
+	{
+		_urbd->error_count   =0;
+		_ltqhc->split=1;
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+	}
+	else if (hcint.b.nak)
+	{
+		_ltqhc->split          = 1;
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+		{
+			_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+			_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		}
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nyet)
+	{
+		_urbd->error_count=0;
+		_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.stall || hcint.b.bblerr )
+	{
+		_urbd->error_count=0;
+		if     (hcint.b.stall)
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		else if(hcint.b.bblerr )
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.xacterr    )
+	{
+		_urbd->error_count++;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			_ltqhc->split=1;
+			if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+			{
+				_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+				_ltqhc->xfer_count     = _urbd->urb->actual_length;
+			}
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		if(_ltqhc->data_pid_start == LTQUSB_HC_PID_DATA0)
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA1;
+		else
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA0;
+		_ltqhc->split=1;
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+		{
+			_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+			_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		}
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		_urbd->error_count=0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_ctrl_tx_csplit(ltqhcd_hcd_t      *_ltqhcd,
+                                      ltqhcd_hc_t       *_ltqhc,
+                                      ltqusb_hc_regs_t  *_hc_regs,
+                                      ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+	int out_nak_enh = 0;
+
+	if (_ltqhcd->core_if.snpsid >= 0x4f54271a && _ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+		out_nak_enh = 1;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if(hcint.b.xfercomp   )
+	{
+		_urbd->error_count=0;
+		_ltqhc->split=1;
+		#if 0
+		if(_ltqhc->xfer_len==0 && !hcint.b.ack && (hcint.b.nak || hcint.b.nyet))
+		{
+			// Walkaround: When sending ZLP and receive NYEY or NAK but also issue CMPT intr
+			// Solution:   NoSplit: Resend at next SOF
+			//             Split  : Resend at next SOF with SSPLIT
+			_ltqhc->xfer_len       = 0;
+			_ltqhc->xfer_count     = 0;
+			_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		else
+		#endif
+		{
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		return 1;
+	}
+	else if(hcint.b.nak        )
+	{
+		_ltqhc->split          = 1;
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+		{
+			_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+			_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		}
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nyet)
+	{
+		//Retry Complete Split
+		// Issue Retry instantly on next SOF, without gothrough process_channels
+		_urbd->error_count=0;
+		_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.stall      )
+	{
+		_urbd->error_count=0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		return 1;
+	}
+	else if(hcint.b.xacterr    )
+	{
+		_urbd->error_count++;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			_ltqhc->split=1;
+			if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+			{
+				_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+				_ltqhc->xfer_count     = _urbd->urb->actual_length;
+			}
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		if(_ltqhc->data_pid_start == LTQUSB_HC_PID_DATA0)
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA1;
+		else
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA0;
+		_ltqhc->split=1;
+		if(_ltqhc->control_phase == LTQHCD_CONTROL_DATA)
+		{
+			_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+			_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		}
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		_urbd->error_count=0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		_urbd->error_count=0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_bulk_rx_csplit(ltqhcd_hcd_t      *_ltqhcd,
+                                      ltqhcd_hc_t       *_ltqhc,
+                                      ltqusb_hc_regs_t  *_hc_regs,
+                                      ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if (hcint.b.xfercomp)
+	{
+		_urbd->error_count   =0;
+		_ltqhc->split=1;
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+	}
+	else if (hcint.b.nak)
+	{
+		_ltqhc->split          = 1;
+		_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+		_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nyet)
+	{
+		_urbd->error_count=0;
+		_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.stall || hcint.b.bblerr )
+	{
+		_urbd->error_count=0;
+		if     (hcint.b.stall)
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		else if(hcint.b.bblerr )
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	else if(hcint.b.xacterr    )
+	{
+		_urbd->error_count++;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			_ltqhc->split=1;
+			_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+			_ltqhc->xfer_count     = _urbd->urb->actual_length;
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		if(_ltqhc->data_pid_start == LTQUSB_HC_PID_DATA0)
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA1;
+		else
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA0;
+		_ltqhc->split=1;
+		_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+		_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		_urbd->error_count=0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_bulk_tx_csplit(ltqhcd_hcd_t      *_ltqhcd,
+                                      ltqhcd_hc_t       *_ltqhc,
+                                      ltqusb_hc_regs_t  *_hc_regs,
+                                      ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+	int out_nak_enh = 0;
+
+	if (_ltqhcd->core_if.snpsid >= 0x4f54271a && _ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+		out_nak_enh = 1;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if(hcint.b.xfercomp   )
+	{
+		_urbd->error_count=0;
+		_ltqhc->split=1;
+		#if 0
+		if(_ltqhc->xfer_len==0 && !hcint.b.ack && (hcint.b.nak || hcint.b.nyet))
+		{
+			// Walkaround: When sending ZLP and receive NYEY or NAK but also issue CMPT intr
+			// Solution:   NoSplit: Resend at next SOF
+			//             Split  : Resend at next SOF with SSPLIT
+			_ltqhc->xfer_len       = 0;
+			_ltqhc->xfer_count     = 0;
+			_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		else
+		#endif
+		{
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+		}
+		return 1;
+	}
+	else if(hcint.b.nak        )
+	{
+		_ltqhc->split          = 1;
+		_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+		_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nyet)
+	{
+		//Retry Complete Split
+		// Issue Retry instantly on next SOF, without gothrough process_channels
+		_urbd->error_count=0;
+		_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.stall      )
+	{
+		_urbd->error_count=0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		return 1;
+	}
+	else if(hcint.b.xacterr    )
+	{
+		_urbd->error_count++;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			_ltqhc->split=1;
+			_ltqhc->epqh->do_ping=1;
+			_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+			_ltqhc->xfer_count     = _urbd->urb->actual_length;
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		if(_ltqhc->data_pid_start == LTQUSB_HC_PID_DATA0)
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA1;
+		else
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA0;
+		_ltqhc->split=1;
+		_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+		_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.frmovrun   )
+	{
+		_urbd->error_count=0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		_urbd->error_count=0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_intr_rx_csplit(ltqhcd_hcd_t      *_ltqhcd,
+                                  ltqhcd_hc_t       *_ltqhc,
+                                  ltqusb_hc_regs_t  *_hc_regs,
+                                  ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if (hcint.b.xfercomp   )
+	{
+		_urbd->error_count=0;
+		_ltqhc->split=1;
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+	}
+	else if(hcint.b.nak        )
+	{
+		_ltqhc->split          = 1;
+		_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+		_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nyet)
+	{
+		_urbd->error_count=0;
+		_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.frmovrun || hcint.b.bblerr || hcint.b.stall )
+	{
+		_urbd->error_count=0;
+		if     (hcint.b.stall)
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		else if(hcint.b.bblerr )
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		else if(hcint.b.frmovrun )
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else if(hcint.b.xacterr    )
+	{
+		hcchar_data_t 	hcchar;
+		hcchar.d32 = ltqusb_rreg(&_hc_regs->hcchar);
+		_urbd->error_count=hcchar.b.multicnt;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			_ltqhc->split=1;
+			_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+			_ltqhc->xfer_count     = _urbd->urb->actual_length;
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		if(_ltqhc->data_pid_start == LTQUSB_HC_PID_DATA0)
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA1;
+		else
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA0;
+		_ltqhc->split=1;
+		_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+		_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_intr_tx_csplit(ltqhcd_hcd_t      *_ltqhcd,
+                                  ltqhcd_hc_t       *_ltqhc,
+                                  ltqusb_hc_regs_t  *_hc_regs,
+                                  ltqhcd_urbd_t     *_urbd)
+{
+	hcint_data_t  hcint;
+	hcint_data_t  hcintmsk;
+	hctsiz_data_t hctsiz;
+	int out_nak_enh = 0;
+
+	if (_ltqhcd->core_if.snpsid >= 0x4f54271a && _ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+		out_nak_enh = 1;
+
+	hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+	hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+	hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+
+	if(hcint.b.xfercomp   )
+	{
+		_urbd->error_count=0;
+		_ltqhc->split=1;
+		complete_channel(_ltqhcd, _ltqhc, _urbd);
+		return 1;
+	}
+	else if(hcint.b.nak        )
+	{
+		_ltqhc->split          = 1;
+		_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+		_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.nyet)
+	{
+		_urbd->error_count=0;
+		_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.stall || hcint.b.frmovrun)
+	{
+		_urbd->error_count=0;
+		if     (hcint.b.stall)
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+		else if(hcint.b.frmovrun )
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_FRAME_OVERRUN);
+		return 1;
+	}
+	else if(hcint.b.xacterr    )
+	{
+		hcchar_data_t 	hcchar;
+		hcchar.d32 = ltqusb_rreg(&_hc_regs->hcchar);
+		_urbd->error_count=hcchar.b.multicnt;
+		if(_urbd->error_count>=3)
+		{
+			_urbd->error_count=0;
+			release_channel(_ltqhcd, _ltqhc, HC_XFER_XACT_ERR);
+		}
+		else
+		{
+			_ltqhc->split=1;
+			_ltqhc->epqh->do_ping=1;
+			_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+			_ltqhc->xfer_count     = _urbd->urb->actual_length;
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		}
+		return 1;
+	}
+	else if(hcint.b.datatglerr )
+	{
+		if(_ltqhc->data_pid_start == LTQUSB_HC_PID_DATA0)
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA1;
+		else
+			_ltqhc->data_pid_start = LTQUSB_HC_PID_DATA0;
+		_ltqhc->split=1;
+		_ltqhc->epqh->do_ping=1;
+		_ltqhc->xfer_len       = _urbd->xfer_len - _urbd->urb->actual_length;
+		_ltqhc->xfer_count     = _urbd->urb->actual_length;
+		ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+		return 1;
+	}
+	else if(hcint.b.bblerr     )
+	{
+		_urbd->error_count=0;
+		release_channel(_ltqhcd, _ltqhc, HC_XFER_BABBLE_ERR);
+		return 1;
+	}
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_isoc_rx_csplit(ltqhcd_hcd_t      *_ltqhcd,
+                                   ltqhcd_hc_t       *_ltqhc,
+                                   ltqusb_hc_regs_t  *_hc_regs,
+                                   ltqhcd_urbd_t     *_urbd)
+{
+	#if defined(__EN_ISOC__) && defined(__EN_ISOC_SPLIT__)
+		hcint_data_t  hcint;
+		hcint_data_t  hcintmsk;
+		hctsiz_data_t hctsiz;
+
+		hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+		hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+		hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+		if(hcint.b.xfercomp   )
+		{
+			disable_hc_int(_hc_regs,ack);
+			disable_hc_int(_hc_regs,nak);
+			disable_hc_int(_hc_regs,nyet);
+			_urbd->error_count=0;
+			_ltqhc->split=1;
+			complete_channel(_ltqhcd, _ltqhc, _urbd);
+			return 1;
+		}
+		else if(hcint.b.nak        )
+		{
+			Retry Start Split (in next b_interval V 1 uF)
+		}
+		else if(hcint.b.nyet)
+		{
+			//Do Next Complete Split
+			// Issue Retry instantly on next SOF, without gothrough process_channels
+			_urbd->error_count=0;
+			//disable_hc_int(_hc_regs,ack);
+			//disable_hc_int(_hc_regs,nak);
+			//disable_hc_int(_hc_regs,datatglerr);
+			_ltqhc->halt_status    = HC_XFER_NO_HALT_STATUS;
+			ltqhcd_hc_start(_ltqhcd, _ltqhc, 0);
+			return 1;
+		}
+		else if(hcint.b.frmovrun || hcint.b.stall || hcint.b.bblerr)
+		{
+			_urbd->error_count=0;
+			disable_hc_int(_hc_regs,ack);
+			disable_hc_int(_hc_regs,nyet);
+			disable_hc_int(_hc_regs,nak);
+			_ltqhc->wait_for_sof   = 0;
+
+			//if(hctsiz.b.pktcnt==0)
+			//{
+			//	complete_channel(_ltqhcd, _ltqhc, _urbd);
+			//	return 1;
+			//}
+			//else
+			//	_urbd->urb->actual_length += (_ltqhc->xfer_len - hctsiz.b.xfersize);
+			if     (hcint.b.stall)
+				release_channel(_ltqhcd, _ltqhc, HC_XFER_STALL);
+			else if(hcint.b.frmovrun )
+			else if(hcint.b.bblerr )
+			return 1;
+		}
+		else if(hcint.b.xacterr    )
+		{
+			Rewind Buffer Pointers
+			if (HCCHARn.EC = = 3) // ERR response received
+			{
+				Record ERR error
+				Do Next Start Split (in next frame)
+			}
+			else
+			{
+				De-allocate Channel
+			}
+		}
+		else if(hcint.b.datatglerr )
+		{
+			warning
+		}
+		else if(hcint.b.ack )
+		{
+			warning
+		}
+	#endif
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static
+int32_t chhltd_isoc_tx_csplit(ltqhcd_hcd_t      *_ltqhcd,
+                                   ltqhcd_hc_t       *_ltqhc,
+                                   ltqusb_hc_regs_t  *_hc_regs,
+                                   ltqhcd_urbd_t     *_urbd)
+{
+	#if defined(__EN_ISOC__) && defined(__EN_ISOC_SPLIT__)
+		hcint_data_t  hcint;
+		hcint_data_t  hcintmsk;
+		hctsiz_data_t hctsiz;
+		int out_nak_enh = 0;
+
+		if (_ltqhcd->core_if.snpsid >= 0x4f54271a && _ltqhc->speed == LTQUSB_EP_SPEED_HIGH)
+			out_nak_enh = 1;
+
+		hcint.d32    = ltqusb_rreg(&_hc_regs->hcint);
+		hcintmsk.d32 = ltqusb_rreg(&_hc_regs->hcintmsk);
+		hctsiz.d32   = ltqusb_rreg(&_hc_regs->hctsiz);
+		warning
+	#endif
+	return 0;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*!
+	 \fn    static int32_t handle_hc_chhltd_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                     ltqhcd_hc_t       *_ltqhc,
+                                     ltqusb_hc_regs_t  *_hc_regs,
+                                     ltqhcd_urbd_t      *_urbd)
+	 \brief This function handles halted interrupts of host channels.
+	 \param  _ltqhcd Pointer to the sate of HCD structure
+	 \param  _ltqhc Pointer to host channel descriptor
+	 \param  _hc_regs Pointer to host channel registers
+	 \param  _urbd Pointer to URB descriptor
+	 \return  0 OK
+	 \ingroup  LTQUSB_HCD
+ */
+static
+int32_t handle_hc_chhltd_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                     ltqhcd_hc_t       *_ltqhc,
+                                     ltqusb_hc_regs_t  *_hc_regs,
+                                     ltqhcd_urbd_t      *_urbd)
+{
+	LTQ_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: Channel Halted--\n", _ltqhc->hc_num);
+
+	_ltqhc->phase = HC_STOPPED;
+
+	if (_ltqhc->halt_status == HC_XFER_URB_DEQUEUE ||
+	    _ltqhc->halt_status == HC_XFER_AHB_ERR) {
+		/*
+		 * Just release the channel. A dequeue can happen on a
+		 * transfer timeout. In the case of an AHB Error, the channel
+		 * was forced to halt because there's no way to gracefully
+		 * recover.
+		 */
+		if(_ltqhc->urbd)
+			_ltqhc->urbd->phase=URBD_DEQUEUEING;
+		release_channel(_ltqhcd, _ltqhc, _ltqhc->halt_status);
+		return 1;
+	}
+
+	if(_ltqhc->urbd)
+		_ltqhc->urbd->phase=URBD_ACTIVE;
+
+	if     (_ltqhc->ep_type == LTQUSB_EP_TYPE_CTRL)
+	{
+		if     (_ltqhc->split==0)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_ctrl_rx_nonsplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_ctrl_tx_nonsplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+		else if(_ltqhc->split==1)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_ctrl_rx_ssplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_ctrl_tx_ssplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+		else if(_ltqhc->split==2)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_ctrl_rx_csplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_ctrl_tx_csplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+	}
+	else if(_ltqhc->ep_type == LTQUSB_EP_TYPE_BULK)
+	{
+		if     (_ltqhc->split==0)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_bulk_rx_nonsplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_bulk_tx_nonsplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+		else if(_ltqhc->split==1)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_bulk_rx_ssplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_bulk_tx_ssplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+		else if(_ltqhc->split==2)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_bulk_rx_csplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_bulk_tx_csplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+	}
+	else if(_ltqhc->ep_type == LTQUSB_EP_TYPE_INTR)
+	{
+		if     (_ltqhc->split==0)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_intr_rx_nonsplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_intr_tx_nonsplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+		else if(_ltqhc->split==1)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_intr_rx_ssplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_intr_tx_ssplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+		else if(_ltqhc->split==2)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_intr_rx_csplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_intr_tx_csplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+	}
+	else if(_ltqhc->ep_type == LTQUSB_EP_TYPE_ISOC)
+	{
+		if     (_ltqhc->split==0)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_isoc_rx_nonsplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_isoc_tx_nonsplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+		else if(_ltqhc->split==1)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_isoc_rx_ssplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_isoc_tx_ssplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+		else if(_ltqhc->split==2)
+		{
+			if(_ltqhc->is_in)
+				return (chhltd_isoc_rx_csplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+			else
+				return (chhltd_isoc_tx_csplit(_ltqhcd,_ltqhc,_hc_regs,_urbd));
+		}
+	}
+	return 0;
+}
+
+/*
+ * Handles a host channel AHB error interrupt. This handler is only called in
+ * DMA mode.
+ */
+static
+void hc_other_intr_dump(ltqhcd_hcd_t      *_ltqhcd,
+                               ltqhcd_hc_t       *_ltqhc,
+                               ltqusb_hc_regs_t  *_hc_regs,
+                               ltqhcd_urbd_t      *_urbd)
+{
+	#ifdef __DEBUG__
+		hcchar_data_t hcchar;
+		hcsplt_data_t hcsplt;
+		hctsiz_data_t hctsiz;
+		uint32_t      hcdma;
+		struct urb   *urb = _urbd->urb;
+		hcchar.d32 = ltqusb_rreg(&_hc_regs->hcchar);
+		hcsplt.d32 = ltqusb_rreg(&_hc_regs->hcsplt);
+		hctsiz.d32 = ltqusb_rreg(&_hc_regs->hctsiz);
+		hcdma = ltqusb_rreg(&_hc_regs->hcdma);
+
+		LTQ_ERROR("Channel %d\n", _ltqhc->hc_num);
+		LTQ_ERROR("  hcchar 0x%08x, hcsplt 0x%08x\n", hcchar.d32, hcsplt.d32);
+		LTQ_ERROR("  hctsiz 0x%08x, hcdma 0x%08x\n", hctsiz.d32, hcdma);
+		LTQ_ERROR("  Device address: %d\n", usb_pipedevice(urb->pipe));
+		LTQ_ERROR("  Endpoint: %d, %s\n", usb_pipeendpoint(urb->pipe),
+			    (usb_pipein(urb->pipe) ? "IN" : "OUT"));
+		LTQ_ERROR("  Endpoint type: %s\n",
+			    ({char *pipetype;
+			    switch (usb_pipetype(urb->pipe)) {
+				    case PIPE_CONTROL: pipetype = "CTRL"; break;
+				    case PIPE_BULK: pipetype = "BULK"; break;
+				    case PIPE_INTERRUPT: pipetype = "INTR"; break;
+				    case PIPE_ISOCHRONOUS: pipetype = "ISOC"; break;
+				    default: pipetype = "????"; break;
+			    }; pipetype;}));
+		LTQ_ERROR("  Speed: %s\n",
+			    ({char *speed;
+			    switch (urb->dev->speed) {
+				    case USB_SPEED_HIGH: speed = "HS"; break;
+				    case USB_SPEED_FULL: speed = "FS"; break;
+				    case USB_SPEED_LOW: speed = "LS"; break;
+			    	default: speed = "????"; break;
+			    }; speed;}));
+		LTQ_ERROR("  Max packet size: %d\n",
+			    usb_maxpacket(urb->dev, urb->pipe, usb_pipeout(urb->pipe)));
+		LTQ_ERROR("  Data buffer length: %d\n", urb->transfer_buffer_length);
+		LTQ_ERROR("  Transfer buffer: %p, Transfer DMA: %p\n",
+			    urb->transfer_buffer, (void *)urb->transfer_dma);
+		LTQ_ERROR("  Setup buffer: %p, Setup DMA: %p\n",
+			    urb->setup_packet, (void *)urb->setup_dma);
+		LTQ_ERROR("  Interval: %d\n", urb->interval);
+	#endif //__DEBUG__
+}
+
+/*
+ * Handles a host channel ACK interrupt. This interrupt is enabled when
+ *  errors occur, and during Start Split transactions.
+ */
+static
+int32_t handle_hc_ack_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                  ltqhcd_hc_t      *_ltqhc,
+                                  ltqusb_hc_regs_t *_hc_regs,
+                                  ltqhcd_urbd_t     *_urbd)
+{
+	_urbd->error_count=0;
+	_ltqhc->erron = 0;
+	clear_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+	return 1;
+}
+
+/*
+ * Handles a host channel ACK interrupt. This interrupt is enabled when
+ *  errors occur, and during Start Split transactions.
+ */
+static
+int32_t handle_hc_nak_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                  ltqhcd_hc_t      *_ltqhc,
+                                  ltqusb_hc_regs_t *_hc_regs,
+                                  ltqhcd_urbd_t     *_urbd)
+{
+	_urbd->error_count=0;
+	_ltqhc->erron=0;
+	disable_hc_int(_hc_regs,nyet);
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	clear_hc_int(_hc_regs,nak);
+	return 1;
+}
+
+static
+int32_t handle_hc_nyet_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                   ltqhcd_hc_t      *_ltqhc,
+                                   ltqusb_hc_regs_t *_hc_regs,
+                                   ltqhcd_urbd_t     *_urbd)
+{
+	_urbd->error_count=0;
+	_ltqhc->erron = 0;
+
+	disable_hc_int(_hc_regs,ack);
+	disable_hc_int(_hc_regs,nak);
+	disable_hc_int(_hc_regs,nyet);
+	clear_hc_int(_hc_regs,nyet);
+	return 1;
+}
+
+/*
+ * Handles a host channel AHB error interrupt. This handler is only called in
+ * DMA mode.
+ */
+static
+int32_t handle_hc_ahberr_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                     ltqhcd_hc_t       *_ltqhc,
+                                     ltqusb_hc_regs_t  *_hc_regs,
+                                     ltqhcd_urbd_t      *_urbd)
+{
+	LTQ_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
+		    "AHB Error--\n", _ltqhc->hc_num);
+	hc_other_intr_dump(_ltqhcd,_ltqhc,_hc_regs,_urbd);
+
+	ltqhcd_hc_halt(&_ltqhcd->core_if, _ltqhc, HC_XFER_AHB_ERR);
+	return 1;
+}
+
+/*
+ * Datatoggle
+ */
+static int32_t handle_hc_datatglerr_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                         ltqhcd_hc_t      *_ltqhc,
+                                         ltqusb_hc_regs_t *_hc_regs,
+                                         ltqhcd_urbd_t     *_urbd)
+{
+	LTQ_ERROR( "--Host Channel %d Interrupt: "
+		    "DATATOGGLE Error--\n", _ltqhc->hc_num);
+	hc_other_intr_dump(_ltqhcd,_ltqhc,_hc_regs,_urbd);
+	disable_hc_int(_hc_regs,datatglerr);
+	return 1;
+}
+
+
+/*
+ * Interrupts which should not been triggered
+ */
+static
+int32_t handle_hc_frmovrun_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                       ltqhcd_hc_t      *_ltqhc,
+                                       ltqusb_hc_regs_t *_hc_regs,
+                                       ltqhcd_urbd_t     *_urbd)
+{
+	LTQ_ERROR( "--Host Channel %d Interrupt: "
+		    "FrameOverRun Error--\n", _ltqhc->hc_num);
+	hc_other_intr_dump(_ltqhcd,_ltqhc,_hc_regs,_urbd);
+	disable_hc_int(_hc_regs,frmovrun);
+	return 1;
+}
+
+static
+int32_t handle_hc_bblerr_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                     ltqhcd_hc_t      *_ltqhc,
+                                     ltqusb_hc_regs_t *_hc_regs,
+                                     ltqhcd_urbd_t     *_urbd)
+{
+	LTQ_ERROR( "--Host Channel %d Interrupt: "
+		    "BBL Error--\n", _ltqhc->hc_num);
+	hc_other_intr_dump(_ltqhcd,_ltqhc,_hc_regs,_urbd);
+	disable_hc_int(_hc_regs,bblerr);
+	return 1;
+}
+
+static
+int32_t handle_hc_xacterr_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                      ltqhcd_hc_t      *_ltqhc,
+                                      ltqusb_hc_regs_t *_hc_regs,
+                                      ltqhcd_urbd_t     *_urbd)
+{
+	LTQ_ERROR( "--Host Channel %d Interrupt: "
+		    "XACT Error--\n", _ltqhc->hc_num);
+	hc_other_intr_dump(_ltqhcd,_ltqhc,_hc_regs,_urbd);
+	disable_hc_int(_hc_regs,xacterr);
+	return 1;
+}
+
+
+static
+int32_t handle_hc_stall_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                    ltqhcd_hc_t      *_ltqhc,
+                                    ltqusb_hc_regs_t *_hc_regs,
+                                    ltqhcd_urbd_t     *_urbd)
+{
+	LTQ_ERROR( "--Host Channel %d Interrupt: "
+		    "STALL--\n", _ltqhc->hc_num);
+	hc_other_intr_dump(_ltqhcd,_ltqhc,_hc_regs,_urbd);
+	disable_hc_int(_hc_regs,stall);
+	return 1;
+}
+
+static
+int32_t handle_hc_xfercomp_intr(ltqhcd_hcd_t      *_ltqhcd,
+                                       ltqhcd_hc_t      *_ltqhc,
+                                       ltqusb_hc_regs_t *_hc_regs,
+                                       ltqhcd_urbd_t     *_urbd)
+{
+	LTQ_ERROR( "--Host Channel %d Interrupt: "
+		    "XFERCOMP--\n", _ltqhc->hc_num);
+	hc_other_intr_dump(_ltqhcd,_ltqhc,_hc_regs,_urbd);
+	disable_hc_int(_hc_regs,xfercomp);
+	return 1;
+}
+
+/* This interrupt indicates that the specified host channels has a pending
+ * interrupt. There are multiple conditions that can cause each host channel
+ * interrupt. This function determines which conditions have occurred for this
+ * host channel interrupt and handles them appropriately. */
+static
+int32_t handle_hc_n_intr (ltqhcd_hcd_t *_ltqhcd, uint32_t _num)
+{
+	uint32_t          hcintval,hcintmsk;
+	hcint_data_t      hcint;
+	ltqhcd_hc_t      *ltqhc;
+	ltqusb_hc_regs_t *hc_regs;
+	ltqhcd_urbd_t     *urbd;
+
+	int retval = 0;
+
+	LTQ_DEBUGPL(DBG_HCDV, "--Host Channel Interrupt--, Channel %d\n", _num);
+
+	ltqhc = &_ltqhcd->ltqhc[_num];
+	hc_regs = _ltqhcd->core_if.hc_regs[_num];
+
+	ltqhc->stopping=0;
+
+	hcintval  = ltqusb_rreg(&hc_regs->hcint);
+	hcintmsk  = ltqusb_rreg(&hc_regs->hcintmsk);
+	hcint.d32 = hcintval & hcintmsk;
+	LTQ_DEBUGPL(DBG_HCDV, "  0x%08x & 0x%08x = 0x%08x\n",
+		    hcintval, hcintmsk, hcint.d32);
+
+	urbd = ltqhc->urbd;
+
+	if (hcint.b.ahberr)
+		retval |= handle_hc_ahberr_intr(_ltqhcd, ltqhc, hc_regs, urbd);
+	else if (hcint.b.chhltd)
+		retval |= handle_hc_chhltd_intr(_ltqhcd, ltqhc, hc_regs, urbd);
+	else
+	{
+		if (hcint.b.datatglerr)
+			retval |= handle_hc_datatglerr_intr(_ltqhcd, ltqhc, hc_regs, urbd);
+		if (hcint.b.frmovrun)
+			retval |= handle_hc_frmovrun_intr(_ltqhcd, ltqhc, hc_regs, urbd);
+		if (hcint.b.bblerr)
+			retval |= handle_hc_bblerr_intr(_ltqhcd, ltqhc, hc_regs, urbd);
+		if (hcint.b.xacterr)
+			retval |= handle_hc_xacterr_intr(_ltqhcd, ltqhc, hc_regs, urbd);
+		if (hcint.b.nyet)
+			retval |= handle_hc_nyet_intr(_ltqhcd, ltqhc, hc_regs, urbd);
+		if (hcint.b.ack)
+			retval |= handle_hc_ack_intr(_ltqhcd, ltqhc, hc_regs, urbd);
+		if (hcint.b.nak)
+			retval |= handle_hc_nak_intr(_ltqhcd, ltqhc, hc_regs, urbd);
+		if (hcint.b.stall)
+			retval |= handle_hc_stall_intr(_ltqhcd, ltqhc, hc_regs, urbd);
+		if (hcint.b.xfercomp)
+			retval |= handle_hc_xfercomp_intr(_ltqhcd, ltqhc, hc_regs, urbd);
+	}
+
+	ltqusb_wreg(&hc_regs->hcint,hcintval);
+
+	return retval;
+}
+
+static
+uint8_t update_interval_counter(ltqhcd_epqh_t *_epqh,uint32_t _diff)
+{
+	if(_diff>=_epqh->period_counter)
+	{
+		_epqh->period_do=1;
+		if(_diff>_epqh->interval)
+			_epqh->period_counter=1;
+		else
+			_epqh->period_counter=_epqh->period_counter+_epqh->interval-_diff;
+		return 1;
+	}
+	_epqh->period_counter=_epqh->period_counter-_diff;
+	return 0;
+}
+
+/*!
+ \brief Assigns transactions from a URBD to a free host channel and initializes the
+ host channel to perform the transactions. The host channel is removed from
+ the free list.
+ \param _ltqhcd The HCD state structure.
+ \param _epqh Transactions from the first URBD for this EPQH are selected and assigned to a free host channel.
+ */
+static
+int assign_hc(ltqhcd_hcd_t *_ltqhcd, ltqhcd_epqh_t *_epqh,ltqhcd_urbd_t *_urbd)
+{
+	ltqhcd_hc_t   *ltqhc;
+	struct urb    *urb;
+
+	LTQ_DEBUGPL(DBG_HCDV, "%s(%p,%p)\n", __func__, _ltqhcd, _epqh);
+
+	if(_ltqhcd->disconnecting)
+	{
+		printk(KERN_INFO "Warning: %s() Port is in discoonection\n",__func__);
+		return 0;
+	}
+
+	if(!_epqh)       return 0;
+	if(!_urbd)       return 0;
+	if(!_urbd->urb)  return 0;
+	if(_urbd->cancelling) return 0;
+
+	{
+		int i;
+		int num_channels = _ltqhcd->core_if.params.host_channels;
+		for(i=0;i<num_channels ; i++)
+		{
+			hcchar_data_t hcchar;
+			ltqusb_hc_regs_t *hc_regs;
+			hc_regs = _ltqhcd->core_if.hc_regs[i];
+			if(_ltqhcd->ltqhc[i].phase!=HC_IDLE)
+			{
+				continue;
+			}
+			hcchar.d32 = ltqusb_rreg(&hc_regs->hcchar);
+			if(hcchar.b.chen || hcchar.b.chdis)
+			{
+				continue;
+			}
+			break;
+		}
+
+		if(!_urbd->cancelling&&i<num_channels)
+		{
+			ltqhc=&_ltqhcd->ltqhc[i];
+			ltqhc->phase=HC_ASSIGNED;
+		}
+		else
+			return 0;
+	}
+	ltqhc->cancelling=0;
+
+	urb         = _urbd->urb;
+
+	ltqhc->epqh = _epqh;
+	ltqhc->urbd = _urbd;
+	_urbd->hc   = ltqhc;
+	_urbd->epqh = _epqh;
+
+	/*
+	 * Use usb_pipedevice to determine device address. This address is
+	 * 0 before the SET_ADDRESS command and the correct address afterward.
+	 */
+	ltqhc->dev_addr = usb_pipedevice(urb->pipe);
+	ltqhc->ep_num   = usb_pipeendpoint(urb->pipe);
+
+	if      (urb->dev->speed == USB_SPEED_LOW)  ltqhc->speed = LTQUSB_EP_SPEED_LOW;
+	else if (urb->dev->speed == USB_SPEED_FULL) ltqhc->speed = LTQUSB_EP_SPEED_FULL;
+	else                                        ltqhc->speed = LTQUSB_EP_SPEED_HIGH;
+
+	ltqhc->mps         = _epqh->mps;
+	ltqhc->halt_status = HC_XFER_NO_HALT_STATUS;
+	ltqhc->ep_type = _epqh->ep_type;
+
+	ltqhc->split = 0;
+	if (_epqh->need_split)
+	{
+		ltqhc->split = 1;
+		ltqhc->hub_addr       = urb->dev->tt->hub->devnum;
+		ltqhc->port_addr      = urb->dev->ttport;
+	}
+	return 1;
+}
+
+/*!
+ \brief Assigns transactions from a URBD to a free host channel and initializes the
+ host channel to perform the transactions. The host channel is removed from
+ the free list.
+ \param _ltqhcd The HCD state structure.
+ \param _epqh Transactions from the first URBD for this EPQH are selected and assigned to a free host channel.
+ */
+static
+void init_hc(ltqhcd_epqh_t *_epqh, ltqhcd_hc_t   *_ltqhc)
+{
+	ltqhcd_urbd_t *urbd;
+	struct urb    *urb;
+	ltqhcd_hcd_t  *ltqhcd;
+
+	LTQ_DEBUGPL(DBG_HCDV, "%s(%p)\n", __func__, _epqh);
+
+	if(_ltqhc->cancelling)
+		return;
+
+	urbd  =_ltqhc->urbd;
+	ltqhcd=_epqh->ltqhcd;
+	urb  = urbd->urb;
+
+	_ltqhc->halt_status = HC_XFER_NO_HALT_STATUS;
+
+	if(_epqh->ep_type==LTQUSB_EP_TYPE_CTRL)
+	{
+		_ltqhc->control_phase  =LTQHCD_CONTROL_SETUP;
+		_ltqhc->is_in          = 0;
+		_ltqhc->data_pid_start = LTQUSB_HC_PID_SETUP;
+		_ltqhc->xfer_buff      = urbd->setup_buff;
+		#if defined(__UNALIGNED_BUF_ADJ__)
+			if(urbd->aligned_setup)
+				_ltqhc->xfer_buff = urbd->aligned_setup;
+			else
+		#endif
+				_ltqhc->xfer_buff      = urbd->setup_buff;
+		_ltqhc->xfer_len       = 8;
+		_ltqhc->xfer_count     = 0;
+		_ltqhc->short_rw       =(urb->transfer_flags & URB_ZERO_PACKET)?1:0;
+		_ltqhc->sof_delay      = 0;
+		_epqh->do_ping=0;
+		if(!_ltqhc->is_in && _ltqhc->split==0)
+			_epqh->do_ping=1;
+	}
+	else if(_epqh->ep_type==LTQUSB_EP_TYPE_ISOC)
+	{
+		#ifdef __EN_ISOC__
+			struct usb_iso_packet_descriptor *frame_desc;
+			_ltqhc->is_in          = urbd->is_in;
+			frame_desc            = &urb->iso_frame_desc[urbd->isoc_frame_index];
+			urbd->xfer_len        = _ltqhc->xfer_len       = frame_desc->length;
+		#if defined(__UNALIGNED_BUF_ADJ__)
+			if(urbd->aligned_buf)
+				_ltqhc->xfer_buff = urbd->aligned_buf;
+			else
+		#endif
+				_ltqhc->xfer_buff      = urbd->xfer_buff;
+			_ltqhc->xfer_buff     += frame_desc->offset;
+			_ltqhc->xfer_count     = 0;
+			_ltqhc->sof_delay      = 0;
+			if(usb_gettoggle (urb->dev,usb_pipeendpoint (urb->pipe), (_ltqhc->is_in)?0:1))
+				_ltqhc->data_pid_start = LTQUSB_HCTSIZ_DATA1;
+			else
+				_ltqhc->data_pid_start = LTQUSB_HCTSIZ_DATA0;
+
+			if(_ltqhc->is_in)
+				_ltqhc->short_rw       =0;
+			else
+				_ltqhc->short_rw       =(urb->transfer_flags & URB_ZERO_PACKET)?1:0;
+			#ifdef __EN_ISOC_SPLIT__
+				_ltqhc->isoc_xact_pos = LTQUSB_HCSPLIT_XACTPOS_ALL;
+			#endif
+
+			_epqh->isoc_frame_index=0;
+			_epqh->isoc_now=0;
+			_epqh->isoc_start_frame=0;
+			if(_urb->transfer_flags && URB_ISO_ASAP)
+				_epqh->isoc_now=1;
+			else
+				_epqh->isoc_start_frame=_urb->start_frame;
+			#ifdef __EN_ISOC_SPLIT__
+				_epqh->isoc_split_pos   =0;
+				_epqh->isoc_split_offset=0;
+			#endif
+			_epqh->do_ping=0;
+		#endif
+	}
+	else
+	{
+		_ltqhc->is_in          = urbd->is_in;
+		#if defined(__UNALIGNED_BUF_ADJ__)
+			if(urbd->aligned_buf)
+				_ltqhc->xfer_buff = urbd->aligned_buf;
+			else
+		#endif
+				_ltqhc->xfer_buff      = urbd->xfer_buff;
+		_ltqhc->xfer_len       = urbd->xfer_len;
+		_ltqhc->xfer_count     = 0;
+		_ltqhc->sof_delay      = 0;
+//		if(_ltqhc->xfer_len==13 &&  _ltqhc->is_in && _epqh->ep_type==LTQUSB_EP_TYPE_BULK && _ltqhc->split==0)
+//			_ltqhc->sof_delay      = 8;
+		if(usb_gettoggle (urb->dev,usb_pipeendpoint (urb->pipe), (_ltqhc->is_in)?0:1))
+			_ltqhc->data_pid_start = LTQUSB_HCTSIZ_DATA1;
+		else
+			_ltqhc->data_pid_start = LTQUSB_HCTSIZ_DATA0;
+		if(_ltqhc->is_in)
+			_ltqhc->short_rw       =0;
+		else
+			_ltqhc->short_rw       =(urb->transfer_flags & URB_ZERO_PACKET)?1:0;
+		_epqh->do_ping=0;
+		if(!_ltqhc->is_in && _ltqhc->split==0)
+		{
+			if(_epqh->ep_type==LTQUSB_EP_TYPE_BULK) _epqh->do_ping=1;
+		}
+	}
+
+	{
+		hcint_data_t      hc_intr_mask;
+		uint8_t           hc_num = _ltqhc->hc_num;
+		ltqusb_hc_regs_t *hc_regs = ltqhcd->core_if.hc_regs[hc_num];
+
+		/* Clear old interrupt conditions for this host channel. */
+		hc_intr_mask.d32 = 0xFFFFFFFF;
+		hc_intr_mask.b.reserved = 0;
+		ltqusb_wreg(&hc_regs->hcint, hc_intr_mask.d32);
+
+		/* Enable channel interrupts required for this transfer. */
+		hc_intr_mask.d32 = 0;
+		hc_intr_mask.b.chhltd = 1;
+		hc_intr_mask.b.ahberr = 1;
+
+		ltqusb_wreg(&hc_regs->hcintmsk, hc_intr_mask.d32);
+
+		/* Enable the top level host channel interrupt. */
+		{
+			uint32_t          intr_enable;
+			intr_enable = (1 << hc_num);
+			ltqusb_mreg(&ltqhcd->core_if.host_global_regs->haintmsk, 0, intr_enable);
+		}
+
+		/* Make sure host channel interrupts are enabled. */
+		{
+			gint_data_t       gintmsk ={.d32 = 0};
+			gintmsk.b.hcintr = 1;
+			ltqusb_mreg(&ltqhcd->core_if.core_global_regs->gintmsk, 0, gintmsk.d32);
+		}
+
+		/*
+		 * Program the HCCHARn register with the endpoint characteristics for
+		 * the current transfer.
+		 */
+		{
+			hcchar_data_t     hcchar;
+
+			hcchar.d32 = 0;
+			hcchar.b.devaddr   =  _ltqhc->dev_addr;
+			hcchar.b.epnum     =  _ltqhc->ep_num;
+			hcchar.b.lspddev   = (_ltqhc->speed == LTQUSB_EP_SPEED_LOW);
+			hcchar.b.eptype    =  _ltqhc->ep_type;
+			hcchar.b.mps       =  _ltqhc->mps;
+			ltqusb_wreg(&hc_regs->hcchar, hcchar.d32);
+
+			LTQ_DEBUGPL(DBG_HCDV, "%s: Channel %d\n", __func__, _ltqhc->hc_num);
+			LTQ_DEBUGPL(DBG_HCDV, "  Dev Addr: %d\n"    , hcchar.b.devaddr);
+			LTQ_DEBUGPL(DBG_HCDV, "  Ep Num: %d\n"      , hcchar.b.epnum);
+			LTQ_DEBUGPL(DBG_HCDV, "  Is Low Speed: %d\n", hcchar.b.lspddev);
+			LTQ_DEBUGPL(DBG_HCDV, "  Ep Type: %d\n"     , hcchar.b.eptype);
+			LTQ_DEBUGPL(DBG_HCDV, "  Max Pkt: %d\n"     , hcchar.b.mps);
+			LTQ_DEBUGPL(DBG_HCDV, "  Multi Cnt: %d\n"   , hcchar.b.multicnt);
+		}
+		/* Program the HCSPLIT register for SPLITs */
+		{
+			hcsplt_data_t     hcsplt;
+
+			hcsplt.d32 = 0;
+			if (_ltqhc->split)
+			{
+				LTQ_DEBUGPL(DBG_HCDV, "Programming HC %d with split --> %s\n", _ltqhc->hc_num,
+					   (_ltqhc->split==2) ? "CSPLIT" : "SSPLIT");
+				hcsplt.b.spltena  = 1;
+				hcsplt.b.compsplt = (_ltqhc->split==2);
+				#if defined(__EN_ISOC__) && defined(__EN_ISOC_SPLIT__)
+					if(_epqh->ep_type==LTQUSB_EP_TYPE_ISOC)
+						hcsplt.b.xactpos  = _ltqhc->isoc_xact_pos;
+					else
+				#endif
+					hcsplt.b.xactpos  = LTQUSB_HCSPLIT_XACTPOS_ALL;
+				hcsplt.b.hubaddr  = _ltqhc->hub_addr;
+				hcsplt.b.prtaddr  = _ltqhc->port_addr;
+				LTQ_DEBUGPL(DBG_HCDV, "   comp split %d\n" , hcsplt.b.compsplt);
+				LTQ_DEBUGPL(DBG_HCDV, "   xact pos %d\n"   , hcsplt.b.xactpos);
+				LTQ_DEBUGPL(DBG_HCDV, "   hub addr %d\n"   , hcsplt.b.hubaddr);
+				LTQ_DEBUGPL(DBG_HCDV, "   port addr %d\n"  , hcsplt.b.prtaddr);
+				LTQ_DEBUGPL(DBG_HCDV, "   is_in %d\n"      , _ltqhc->is_in);
+				LTQ_DEBUGPL(DBG_HCDV, "   Max Pkt: %d\n"   , _ltqhc->mps);
+				LTQ_DEBUGPL(DBG_HCDV, "   xferlen: %d\n"   , _ltqhc->xfer_len);
+			}
+			ltqusb_wreg(&hc_regs->hcsplt, hcsplt.d32);
+		}
+	}
+}
+
+
+static
+void select_eps_func(unsigned long data);
+
+static
+void select_eps_sub(ltqhcd_hcd_t *_ltqhcd)
+{
+	struct list_head *epqh_ptr;
+	ltqhcd_epqh_t    *epqh;
+	struct list_head *urbd_ptr;
+#ifdef USE_SAFE_URBD
+	struct list_head *urbd_ptr_next;
+#endif
+	unsigned long     flags;
+	ltqhcd_urbd_t    *urbd;
+	struct list_head *urbd_ptr_ori;
+	unsigned int urbd_ptr_cnt;
+	hfnum_data_t hfnum;
+	uint32_t fndiff;
+
+	if(_ltqhcd->disconnecting)
+		return ;
+	LOCK_SELECT(_ltqhcd);
+
+	local_irq_save(flags);
+	LOCK_EPQH_LIST(_ltqhcd);
+
+	hfnum.d32 = ltqusb_rreg(&_ltqhcd->core_if.host_global_regs->hfnum);
+	fndiff = hfnum.b.frnum;
+	fndiff+= 0x00004000;
+	fndiff-= _ltqhcd->lastframe ;
+	fndiff&= 0x00003FFF;
+	if(!fndiff) fndiff =1;
+
+	#ifdef __EN_ISOC__
+		epqh_ptr       = _ltqhcd->epqh_list_isoc.next;
+		while (epqh_ptr != &_ltqhcd->epqh_list_isoc)
+		{
+			epqh = list_entry(epqh_ptr, ltqhcd_epqh_t, ql);
+			epqh_ptr = epqh_ptr->next;
+
+			#ifdef __DYN_SOF_INTR__
+			if (!list_empty(&epqh->urbd_list))
+				_ltqhcd->dyn_sof_count = DYN_SOF_COUNT_DEF;
+			#endif
+
+			if(epqh->phase==EPQH_READY)
+			{
+				if(update_interval_counter(epqh,fndiff) || epqh->isoc_now)
+				{
+					LOCK_URBD_LIST(epqh);
+					urbd_ptr_ori = epqh->urbd_list.next;
+					urbd_ptr_cnt = 0;
+				#ifdef USE_SAFE_URBD
+					list_for_each_safe(urbd_ptr, urbd_ptr_next, &epqh->urbd_list)
+				#else //USE_SAFE_URBD
+					urbd_ptr       = epqh->urbd_list.next;
+					while (urbd_ptr != &epqh->urbd_list)
+				#endif //USE_SAFE_URBD
+					{
+						urbd = list_entry(urbd_ptr, ltqhcd_urbd_t, ql);
+					#ifndef USE_SAFE_URBD
+						urbd_ptr=urbd_ptr->next;
+					#endif //USE_SAFE_URBD
+						if(urbd->cancelling) break;
+						if(urbd->phase==URBD_ACTIVE || urbd->phase==URBD_RUNNING)
+							break;
+						if(urbd->phase==URBD_IDLE)
+						{
+							if(assign_hc(_ltqhcd, epqh,urbd))
+							{
+								LTQ_DEBUGPL(DBG_HCD, "  select_eps ISOC\n");
+								#ifdef __EPQD_DESTROY_TIMEOUT__
+									del_timer(&epqh->destroy_timer);
+								#endif
+								epqh->isoc_now=0;
+								list_del_init (&epqh->ql);
+								list_add_tail(&epqh->ql, &_ltqhcd->epqh_list_isoc);
+								init_hc(epqh,urbd->hc);
+								epqh->phase=EPQH_ACTIVE;
+								urbd->phase=URBD_ACTIVE;
+								urbd->hc.phase=HC_WAITING;
+								ltqhcd_hc_start(_ltqhcd, urbd->hc,0);
+							}
+							break;
+						}
+						if(urbd_ptr_ori == urbd_ptr)
+						{
+							if(++urbd_ptr_cnt > ABORT_URBD_MAX)
+							{
+								printk(KERN_INFO "NEVER END URBD ISOC %d\n",urbd_ptr_cnt);
+								urbd_ptr_cnt = 0;
+							#ifdef ABORT_URBD
+								break;
+							#endif
+							}
+						}
+						else
+						{
+							urbd_ptr_ori = urbd_ptr;
+							urbd_ptr_cnt = 0;
+						}
+					}
+					UNLOCK_URBD_LIST(epqh);
+				}
+			}
+		}
+	#endif //__EN_ISOC__
+
+	epqh_ptr       = _ltqhcd->epqh_list_intr.next;
+	while (epqh_ptr != &_ltqhcd->epqh_list_intr)
+	{
+		epqh = list_entry(epqh_ptr, ltqhcd_epqh_t, ql);
+		epqh_ptr = epqh_ptr->next;
+		#ifdef __DYN_SOF_INTR__
+		if (!list_empty(&epqh->urbd_list))
+			_ltqhcd->dyn_sof_count = DYN_SOF_COUNT_DEF;
+		#endif
+		if(epqh->phase==EPQH_READY)
+		{
+			if(update_interval_counter(epqh,fndiff))
+			{
+				LOCK_URBD_LIST(epqh);
+
+				urbd_ptr_ori = epqh->urbd_list.next;
+				urbd_ptr_cnt = 0;
+			#ifdef USE_SAFE_URBD
+				list_for_each_safe(urbd_ptr, urbd_ptr_next, &epqh->urbd_list)
+			#else //USE_SAFE_URBD
+				urbd_ptr       = epqh->urbd_list.next;
+				while (urbd_ptr != &epqh->urbd_list)
+			#endif //USE_SAFE_URBD
+				{
+					urbd = list_entry(urbd_ptr, ltqhcd_urbd_t, ql);
+					#ifndef USE_SAFE_URBD
+						urbd_ptr=urbd_ptr->next;
+					#endif //USE_SAFE_URBD
+					if(urbd->cancelling) break;
+					if(urbd->phase==URBD_ACTIVE || urbd->phase==URBD_RUNNING)
+						break;
+					if(urbd->phase==URBD_IDLE)
+					{
+						if(assign_hc(_ltqhcd, epqh,urbd))
+						{
+							LTQ_DEBUGPL(DBG_HCD, "  select_eps INTR\n");
+							#ifdef __EPQD_DESTROY_TIMEOUT__
+								del_timer(&epqh->destroy_timer);
+							#endif
+							list_del_init (&epqh->ql);
+							list_add_tail(&epqh->ql, &_ltqhcd->epqh_list_intr);
+							init_hc(epqh,urbd->hc);
+							epqh->phase=EPQH_ACTIVE;
+							urbd->phase=URBD_ACTIVE;
+							urbd->hc->phase=HC_WAITING;
+							ltqhcd_hc_start(_ltqhcd, urbd->hc,0);
+						}
+						break;
+					}
+					if(urbd_ptr_ori == urbd_ptr)
+					{
+						if(++urbd_ptr_cnt > ABORT_URBD_MAX)
+						{
+							printk(KERN_INFO "NEVER END URBD INTR ep %02X\n",epqh->sysep->desc.bEndpointAddress);
+							urbd_ptr_cnt = 0;
+							#ifdef ABORT_URBD
+								break;
+							#endif
+						}
+					}
+					else
+					{
+						urbd_ptr_ori = urbd_ptr;
+						urbd_ptr_cnt = 0;
+					}
+				}
+				UNLOCK_URBD_LIST(epqh);
+			}
+		}
+		else if(epqh->phase==EPQH_STDBY)
+		{
+			if(epqh->period_counter > 0 )
+				epqh->period_counter --;
+			if(epqh->period_counter == 0)
+				ltqhcd_epqh_idle_periodic(epqh);
+			update_interval_counter(epqh,fndiff);
+		}
+		else
+			update_interval_counter(epqh,fndiff);
+	}
+
+	epqh_ptr       = _ltqhcd->epqh_list_ctrl.next;
+	while (epqh_ptr != &_ltqhcd->epqh_list_ctrl)  // may need to preserve at lease one for period
+	{
+		epqh = list_entry(epqh_ptr, ltqhcd_epqh_t, ql);
+		epqh_ptr = epqh_ptr->next;
+		#ifdef __DYN_SOF_INTR__
+		if (!list_empty(&epqh->urbd_list))
+			_ltqhcd->dyn_sof_count = DYN_SOF_COUNT_DEF;
+		#endif
+		if(epqh->phase==EPQH_READY)
+		{
+			LOCK_URBD_LIST(epqh);
+
+#ifdef USE_SAFE_URBD
+			list_for_each_safe(urbd_ptr, urbd_ptr_next, &epqh->urbd_list)
+#else //USE_SAFE_URBD
+			urbd_ptr       = epqh->urbd_list.next;
+			while (urbd_ptr != &epqh->urbd_list)
+#endif //USE_SAFE_URBD
+			{
+				urbd = list_entry(urbd_ptr, ltqhcd_urbd_t, ql);
+#ifndef USE_SAFE_URBD
+				urbd_ptr=urbd_ptr->next;
+#endif //USE_SAFE_URBD
+				if(urbd->cancelling)
+					break;
+				if(urbd->phase==URBD_ACTIVE || urbd->phase==URBD_RUNNING)
+					break;
+				if(urbd->phase==URBD_IDLE)
+				{
+					if(assign_hc(_ltqhcd, epqh,urbd))
+					{
+						LTQ_DEBUGPL(DBG_HCD, "  select_eps Non-Period\n");
+						#ifdef __EPQD_DESTROY_TIMEOUT__
+							del_timer(&epqh->destroy_timer);
+						#endif
+						list_del_init (&epqh->ql);
+						list_add_tail(&epqh->ql, &_ltqhcd->epqh_list_ctrl);
+						init_hc(epqh,urbd->hc);
+						epqh->phase=EPQH_ACTIVE;
+						urbd->phase=URBD_ACTIVE;
+						urbd->hc->phase=HC_WAITING;
+//						ltqhcd_hc_start(_ltqhcd, urbd->hc,epqh->burst_on);
+						ltqhcd_hc_start(_ltqhcd, urbd->hc,0);
+					}
+					break;
+				}
+			}
+			UNLOCK_URBD_LIST(epqh);
+		}
+	}
+
+	epqh_ptr       = _ltqhcd->epqh_list_bulk.next;
+	while (epqh_ptr != &_ltqhcd->epqh_list_bulk)  // may need to preserve at lease one for period
+	{
+		epqh = list_entry(epqh_ptr, ltqhcd_epqh_t, ql);
+		epqh_ptr = epqh_ptr->next;
+		#ifdef __DYN_SOF_INTR__
+		if (!list_empty(&epqh->urbd_list))
+			_ltqhcd->dyn_sof_count = DYN_SOF_COUNT_DEF;
+		#endif
+		if(epqh->phase==EPQH_READY)
+		{
+			LOCK_URBD_LIST(epqh);
+
+#ifdef USE_SAFE_URBD
+			list_for_each_safe(urbd_ptr, urbd_ptr_next, &epqh->urbd_list)
+#else //USE_SAFE_URBD
+			urbd_ptr       = epqh->urbd_list.next;
+			while (urbd_ptr != &epqh->urbd_list)
+#endif //USE_SAFE_URBD
+			{
+				urbd = list_entry(urbd_ptr, ltqhcd_urbd_t, ql);
+#ifndef USE_SAFE_URBD
+				urbd_ptr=urbd_ptr->next;
+#endif //USE_SAFE_URBD
+				if(urbd->cancelling)
+					break;
+				if(urbd->phase==URBD_ACTIVE || urbd->phase==URBD_RUNNING)
+					break;
+				if(urbd->phase==URBD_IDLE)
+				{
+					if(assign_hc(_ltqhcd, epqh,urbd))
+					{
+						LTQ_DEBUGPL(DBG_HCD, "  select_eps Non-Period\n");
+						#ifdef __EPQD_DESTROY_TIMEOUT__
+							del_timer(&epqh->destroy_timer);
+						#endif
+						list_del_init (&epqh->ql);
+						list_add_tail(&epqh->ql, &_ltqhcd->epqh_list_bulk);
+						init_hc(epqh,urbd->hc);
+						epqh->phase=EPQH_ACTIVE;
+						urbd->phase=URBD_ACTIVE;
+						urbd->hc->phase=HC_WAITING;
+//						ltqhcd_hc_start(_ltqhcd, urbd->hc,epqh->burst_on);
+						ltqhcd_hc_start(_ltqhcd, urbd->hc,0);
+					}
+					break;
+				}
+			}
+			UNLOCK_URBD_LIST(epqh);
+		}
+	}
+
+	_ltqhcd->lastframe=hfnum.b.frnum;
+
+	UNLOCK_EPQH_LIST(_ltqhcd);
+	local_irq_restore(flags);
+	UNLOCK_SELECT(_ltqhcd);
+}
+
+static
+void select_eps_func(unsigned long data)
+{
+	ltqhcd_hcd_t *ltqhcd;
+	ltqhcd=((ltqhcd_hcd_t *)data);
+
+	select_eps_sub(ltqhcd);
+}
+
+/*!
+	 \fn    void select_eps(ltqhcd_hcd_t *_ltqhcd)
+	 \brief This function selects transactions from the HCD transfer schedule and assigns them to available host channels.
+	 \param _ltqhcd Pointer to the sate of HCD structure
+	 \ingroup  LTQUSB_HCD
+ */
+void select_eps(ltqhcd_hcd_t *_ltqhcd)
+{
+	if(!_ltqhcd->tasklet_select_eps.func)
+	{
+		_ltqhcd->tasklet_select_eps.next = NULL;
+		_ltqhcd->tasklet_select_eps.state = 0;
+		atomic_set( &_ltqhcd->tasklet_select_eps.count, 0);
+		_ltqhcd->tasklet_select_eps.func = select_eps_func;
+		_ltqhcd->tasklet_select_eps.data = (unsigned long)_ltqhcd;
+	}
+	tasklet_schedule(&_ltqhcd->tasklet_select_eps);
+}
+
+
+void ltqhcd_xfer_stopper(ltqhcd_hcd_t *_ltqhcd)
+{
+	ltqhcd_hc_t      *ltqhc;
+	int               num_channels;
+	ltqusb_hc_regs_t *hc_regs;
+	int               i;
+
+	num_channels = _ltqhcd->core_if.params.host_channels;
+	for (i = 0; i < num_channels; i++)
+	{
+		ltqhc=&_ltqhcd->ltqhc[i];
+		if(ltqhc->stopping)
+			continue;
+		if(ltqhc->ep_type == LTQUSB_EP_TYPE_BULK ||
+		   (
+			ltqhc->ep_type == LTQUSB_EP_TYPE_CTRL && ltqhc->control_phase ==  LTQHCD_CONTROL_DATA
+		   )
+		)
+		{
+			hcchar_data_t 	hcchar;
+			hc_regs = _ltqhcd->core_if.hc_regs[i];
+			hcchar.d32=ltqusb_rreg(&hc_regs->hcchar);
+			if(hcchar.b.chen)
+			{
+				ltqhc->stopping=1;
+				hcchar.b.chdis = 1;
+				ltqhc->halt_status = HC_XFER_STOPPED;
+				ltqusb_wreg(&hc_regs->hcchar, hcchar.d32);
+			}
+		}
+	}
+}
+
+
+
+inline
+int ltqhcd_hc_kickstart_check(ltqhcd_hcd_t *_ltqhcd)
+{
+	if(_ltqhcd->xfer_prot1_value)
+	{
+		hfnum_data_t hfnum;
+		hfnum.d32 = ltqusb_rreg(&_ltqhcd->core_if.host_global_regs->hfnum);
+
+		if(hfnum.b.frrem < _ltqhcd->xfer_prot1_value)
+			return 1;
+	}
+	return 0;
+}
+
+static
+void ltqhcd_hc_kickstart(ltqhcd_hcd_t *_ltqhcd)
+{
+	int               num_channels;
+	ltqusb_hc_regs_t *hc_regs;
+	int               i;
+	ltqhcd_hc_t      *ltqhc;
+	num_channels = _ltqhcd->core_if.params.host_channels;
+
+	if(ltqhcd_hc_kickstart_check(_ltqhcd))
+	{
+		if(hrtimer_try_to_cancel(&_ltqhcd->xfer_stopper_timer)!=-1)
+			ltqhcd_xfer_stopper(_ltqhcd);
+	}
+	else
+	{
+		for (i = 0; i < num_channels; i++)
+		{
+			ltqhc=&_ltqhcd->ltqhc[i];
+
+			if(ltqhc->cancelling) continue;
+			if(ltqhc->stopping)   continue;
+			if(ltqhc->phase==HC_STARTING_HIGH)
+			{
+				if(ltqhc->sof_delay) ltqhc->sof_delay--;
+				if(!ltqhc->sof_delay)
+				{
+					hcint_data_t hcint;
+					hcchar_data_t 	hcchar;
+//					ltqhc->erron=0;
+					hc_regs = _ltqhcd->core_if.hc_regs[i];
+
+					hcchar.d32=ltqusb_rreg(&hc_regs->hcchar);
+					if(hcchar.b.chen || hcchar.b.chdis)
+					{
+						if(ltqhc->phase==HC_STARTING_HIGH)
+						{
+							printk(KERN_INFO "%s:%s() %d PERIOD CH STILL ENABLED %08x \n",__FILE__,__func__,__LINE__,hcchar.d32);
+							ltqhc->sof_delay=1;
+						}
+					}
+					else
+					{
+						hcint.d32 =0xFFFFFFFF;
+						ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+						hcint.d32 =ltqusb_rreg(&hc_regs->hcintmsk);
+						hcint.b.nak =0;
+						hcint.b.ack =0;
+						hcint.b.nyet=0;
+						if(ltqhc->erron)
+						{
+							hcint.b.ack  =1;
+							hcint.b.nak  =1;
+							hcint.b.nyet =1;
+						}
+//						if(!ltqhcd_hc_kickstart_check(_ltqhcd))
+//							break;
+						if(!ltqhc->cancelling)
+						{
+							ltqusb_wreg(&hc_regs->hcintmsk, hcint.d32);
+							ltqusb_wreg(&hc_regs->hcchar, ltqhc->hcchar);
+							ltqhc->phase=HC_STARTED;
+						}
+					}
+				}
+			}
+		}
+
+		for (i = 0; i < num_channels; i++)
+		{
+			ltqhc=&_ltqhcd->ltqhc[i];
+			if(ltqhc->cancelling) continue;
+			if(ltqhc->stopping)   continue;
+			if(ltqhc->phase==HC_STARTING)
+			{
+				if(ltqhc->sof_delay) ltqhc->sof_delay--;
+				if(!ltqhc->sof_delay)
+				{
+					hcint_data_t hcint;
+					hcchar_data_t 	hcchar;
+//					ltqhc->erron=0;
+					hc_regs = _ltqhcd->core_if.hc_regs[i];
+					hcchar.d32=ltqusb_rreg(&hc_regs->hcchar);
+					if(hcchar.b.chen || hcchar.b.chdis)
+					{
+						if(ltqhc->phase==HC_STARTING)
+						{
+							printk(KERN_INFO "%s:%s() %d NON-PERIOD CH %d STILL ENABLED %p %08x  \n",__FILE__,__func__,__LINE__,i,&hc_regs->hcchar,hcchar.d32);
+							ltqhc->sof_delay=1;
+							hcchar.b.chdis=1;
+							ltqusb_wreg(&hc_regs->hcchar,hcchar.d32);
+						}
+					}
+					else
+					{
+						hcint.d32 =0xFFFFFFFF;
+						ltqusb_wreg(&hc_regs->hcint, hcint.d32);
+						hcint.d32 =ltqusb_rreg(&hc_regs->hcintmsk);
+						hcint.b.nak =0;
+						hcint.b.ack =0;
+						hcint.b.nyet=0;
+						if(ltqhc->erron)
+						{
+							hcint.b.ack  =1;
+							hcint.b.nak  =1;
+							hcint.b.nyet =1;
+						}
+//						if(!ltqhcd_hc_kickstart_check(_ltqhcd))
+//							break;
+						if(!ltqhc->cancelling)
+						{
+							ltqusb_wreg(&hc_regs->hcintmsk, hcint.d32);
+							ltqusb_wreg(&hc_regs->hcchar, ltqhc->hcchar);
+							ltqhc->phase=HC_STARTED;
+						}
+					}
+				}
+			}
+		}
+		for (i = 0; i < num_channels; i++)
+		{
+			ltqhc=&_ltqhcd->ltqhc[i];
+			if(ltqhc->cancelling) continue;
+			if(ltqhc->phase==HC_WAITING &&
+			    (ltqhc->ep_type == LTQUSB_EP_TYPE_INTR || ltqhc->ep_type == LTQUSB_EP_TYPE_ISOC)
+			  )
+				ltqhcd_hc_start(_ltqhcd, ltqhc,0);
+		}
+		for (i = 0; i < num_channels; i++)
+		{
+			ltqhc=&_ltqhcd->ltqhc[i];
+			if(ltqhc->cancelling) continue;
+			if(ltqhc->phase==HC_WAITING)
+				ltqhcd_hc_start(_ltqhcd, ltqhc,0);
+		}
+	}
+}
+
+
+/*
+ * Handles the start-of-frame interrupt in host mode. Non-periodic
+ * transactions may be queued to the DWC_otg controller for the current
+ * (micro)frame. Periodic transactions may be queued to the controller for the
+ * next (micro)frame.
+ */
+enum hrtimer_restart xfer_stopper_timer_callback(struct hrtimer *pt)
+{
+	ltqhcd_hcd_t     *ltqhcd=container_of(pt,ltqhcd_hcd_t,xfer_stopper_timer);
+	ltqhcd->xfer_stopper_timer_on=0;
+	if(ltqhcd->use_hrtimer)
+		ltqhcd_xfer_stopper(ltqhcd);
+	return HRTIMER_NORESTART;
+}
+
+static
+int32_t handle_sof_intr (ltqhcd_hcd_t *_ltqhcd)
+{
+	if(_ltqhcd->use_hrtimer && _ltqhcd->xfer_prot2_value)
+	{
+		ktime_t ktime;
+		ktime=ktime_set(0,_ltqhcd->xfer_prot2_value);
+		hrtimer_start(&_ltqhcd->xfer_stopper_timer,ktime,HRTIMER_MODE_REL);
+		_ltqhcd->xfer_stopper_timer_on=1;
+	}
+
+	ltqhcd_hc_kickstart(_ltqhcd);
+	select_eps(_ltqhcd);
+
+	/* Clear interrupt */
+	{
+		gint_data_t gintsts;
+		gintsts.d32=0;
+		gintsts.b.sofintr = 1;
+		ltqusb_wreg(&_ltqhcd->core_if.core_global_regs->gintsts, gintsts.d32);
+
+		#ifdef __DYN_SOF_INTR__
+			if(_ltqhcd->dyn_sof_count)
+				_ltqhcd->dyn_sof_count--;
+			if(!_ltqhcd->dyn_sof_count)
+				ltqusb_mreg(&_ltqhcd->core_if.core_global_regs->gintmsk, gintsts.d32,0);
+		#endif
+	}
+	return 1;
+}
+
+
+
+/* There are multiple conditions that can cause a port interrupt. This function
+ * determines which interrupt conditions have occurred and handles them
+ * appropriately. */
+static
+int32_t handle_port_intr (ltqhcd_hcd_t *_ltqhcd)
+{
+	int retval = 0;
+	hprt0_data_t hprt0;
+	hprt0_data_t hprt0_modify;
+
+	hprt0.d32        =
+	hprt0_modify.d32 = ltqusb_rreg(_ltqhcd->core_if.hprt0);
+
+	/* Clear appropriate bits in HPRT0 to clear the interrupt bit in
+	 * GINTSTS */
+
+	hprt0_modify.b.prtena = 0;
+	hprt0_modify.b.prtconndet = 0;
+	hprt0_modify.b.prtenchng = 0;
+	hprt0_modify.b.prtovrcurrchng = 0;
+
+	/* Port Connect Detected
+	 * Set flag and clear if detected */
+	if (hprt0.b.prtconndet) {
+		LTQ_DEBUGPL(DBG_HCD, "--Port Interrupt HPRT0=0x%08x "
+			    "Port Connect Detected--\n", hprt0.d32);
+		_ltqhcd->flags.b.port_connect_status_change = 1;
+		_ltqhcd->flags.b.port_connect_status = 1;
+		hprt0_modify.b.prtconndet = 1;
+
+		/* The Hub driver asserts a reset when it sees port connect
+		 * status change flag */
+		retval |= 1;
+	}
+
+	/* Port Enable Changed
+	 * Clear if detected - Set internal flag if disabled */
+	if (hprt0.b.prtenchng) {
+		LTQ_DEBUGPL(DBG_HCD, "  --Port Interrupt HPRT0=0x%08x "
+			    "Port Enable Changed--\n", hprt0.d32);
+		hprt0_modify.b.prtenchng = 1;
+		if (hprt0.b.prtena == 1)
+		{
+			/* Port has been enabled set the reset change flag */
+			_ltqhcd->flags.b.port_reset_change = 1;
+		}
+		else
+			_ltqhcd->flags.b.port_enable_change = 1;
+		retval |= 1;
+	}
+
+	/* Overcurrent Change Interrupt */
+
+	if (hprt0.b.prtovrcurrchng) {
+#if 0 // OC is handled by AFE, not USB PHY
+		LTQ_DEBUGPL(DBG_HCD, "  --Port Interrupt HPRT0=0x%08x "
+			    "Port Overcurrent Changed--\n", hprt0.d32);
+		_ltqhcd->flags.b.port_over_current_change = 1;
+#else
+		LTQ_WARN("Core Overcurrent Change triggered : HPRT0=0x%08x  chg:%d sts:%d\n",hprt0.d32,hprt0.b.prtovrcurrchng,hprt0.b.prtovrcurract);
+#endif
+		hprt0_modify.b.prtovrcurrchng = 1;
+		retval |= 1;
+	}
+	/* Clear Port Interrupts */
+	ltqusb_wreg(_ltqhcd->core_if.hprt0, hprt0_modify.d32);
+
+	if(retval)
+		usb_hcd_poll_rh_status(_ltqhcd->syshcd);
+	return retval;
+}
+
+/*
+ * This interrupt indicates that SUSPEND state has been detected on
+ * the USB.
+ * No Functioning in Host Mode
+ */
+static
+int32_t handle_usb_suspend_intr(ltqhcd_hcd_t *_ltqhcd)
+{
+	gint_data_t gintsts;
+	LTQ_DEBUGP("USB SUSPEND RECEIVED!\n");
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.usbsuspend = 1;
+	ltqusb_wreg(&_ltqhcd->core_if.core_global_regs->gintsts, gintsts.d32);
+	return 1;
+}
+
+/*
+ * This interrupt indicates that the LTQUSB controller has detected a
+ * resume or remote wakeup sequence. If the LTQUSB controller is in
+ * low power mode, the handler must brings the controller out of low
+ * power mode. The controller automatically begins resume
+ * signaling. The handler schedules a time to stop resume signaling.
+ */
+static
+int32_t handle_wakeup_detected_intr(ltqhcd_hcd_t *_ltqhcd)
+{
+	gint_data_t gintsts;
+	hprt0_data_t hprt0 = {.d32=0};
+	pcgcctl_data_t pcgcctl = {.d32=0};
+	ltqusb_core_if_t *core_if = &_ltqhcd->core_if;
+
+	LTQ_DEBUGPL(DBG_ANY, "++Resume and Remote Wakeup Detected Interrupt++\n");
+
+	/*
+	 * Clear the Resume after 70ms. (Need 20 ms minimum. Use 70 ms
+	 * so that OPT tests pass with all PHYs).
+	 */
+	/* Restart the Phy Clock */
+	pcgcctl.b.stoppclk = 1;
+	ltqusb_mreg(core_if->pcgcctl, pcgcctl.d32, 0);
+	UDELAY(10);
+
+	/* Now wait for 70 ms. */
+	hprt0.d32 = ltqusb_read_hprt0( core_if );
+	LTQ_DEBUGPL(DBG_ANY,"Resume: HPRT0=%0x\n", hprt0.d32);
+	MDELAY(70);
+	hprt0.b.prtres = 0; /* Resume */
+	ltqusb_wreg(core_if->hprt0, hprt0.d32);
+	LTQ_DEBUGPL(DBG_ANY,"Clear Resume: HPRT0=%0x\n", ltqusb_rreg(core_if->hprt0));
+
+	/* Clear interrupt */
+	gintsts.d32 = 0;
+	gintsts.b.wkupintr = 1;
+	ltqusb_wreg(&core_if->core_global_regs->gintsts, gintsts.d32);
+	return 1;
+}
+
+/*
+ * This interrupt indicates that a device is initiating the Session
+ * Request Protocol to request the host to turn on bus power so a new
+ * session can begin. The handler responds by turning on bus power. If
+ * the DWC_otg controller is in low power mode, the handler brings the
+ * controller out of low power mode before turning on bus power.
+ */
+static
+int32_t handle_session_req_intr(ltqhcd_hcd_t *_ltqhcd)
+{
+	/* Clear interrupt */
+	gint_data_t gintsts = { .d32 = 0 };
+	gintsts.b.sessreqintr = 1;
+	ltqusb_wreg(&_ltqhcd->core_if.core_global_regs->gintsts, gintsts.d32);
+	return 1;
+}
+
+/*
+ * This interrupt indicates that a device has been disconnected from
+ * the root port.
+ */
+static
+int32_t handle_disconnect_intr(ltqhcd_hcd_t *_ltqhcd)
+{
+	gint_data_t gintsts;
+	ltqhcd_disconnect(_ltqhcd);
+
+	gintsts.d32 = 0;
+	gintsts.b.disconnect = 1;
+	ltqusb_wreg(&_ltqhcd->core_if.core_global_regs->gintsts, gintsts.d32);
+	return 1;
+}
+
+/*
+ * This function handles the Connector ID Status Change Interrupt.  It
+ * reads the OTG Interrupt Register (GOTCTL) to determine whether this
+ * is a Device to Host Mode transition or a Host Mode to Device
+ * Transition.
+ * This only occurs when the cable is connected/removed from the PHY
+ * connector.
+ */
+static
+int32_t handle_conn_id_status_change_intr(ltqhcd_hcd_t *_ltqhcd)
+{
+	gint_data_t gintsts;
+
+	LTQ_WARN("ID Status Change Interrupt: currently in %s mode\n",
+	     ltqusb_mode(&_ltqhcd->core_if) ? "Host" : "Device");
+
+	gintsts.d32 = 0;
+	gintsts.b.conidstschng = 1;
+	ltqusb_wreg(&_ltqhcd->core_if.core_global_regs->gintsts, gintsts.d32);
+	return 1;
+}
+
+static
+int32_t handle_otg_intr(ltqhcd_hcd_t *_ltqhcd)
+{
+	ltqusb_core_global_regs_t *global_regs = _ltqhcd->core_if.core_global_regs;
+	gotgint_data_t gotgint;
+	gotgint.d32 = ltqusb_rreg( &global_regs->gotgint);
+	/* Clear GOTGINT */
+	ltqusb_wreg (&global_regs->gotgint, gotgint.d32);
+	return 1;
+}
+
+/** This function will log a debug message */
+static
+int32_t handle_mode_mismatch_intr(ltqhcd_hcd_t *_ltqhcd)
+{
+	gint_data_t gintsts;
+
+	LTQ_WARN("Mode Mismatch Interrupt: currently in %s mode\n",
+	     ltqusb_mode(&_ltqhcd->core_if) ? "Host" : "Device");
+	gintsts.d32 = 0;
+	gintsts.b.modemismatch = 1;
+	ltqusb_wreg(&_ltqhcd->core_if.core_global_regs->gintsts, gintsts.d32);
+	return 1;
+}
+
+/** This function handles interrupts for the HCD. */
+int32_t ltqhcd_handle_intr (ltqhcd_hcd_t *_ltqhcd)
+{
+	int retval = 0;
+
+	ltqusb_core_if_t *core_if = &_ltqhcd->core_if;
+	gint_data_t gintsts;
+
+	/* Check if HOST Mode */
+	if (ltqusb_is_device_mode(core_if))
+	{
+		LTQ_ERROR("%s() CRITICAL!  IN DEVICE MODE\n", __func__);
+		return 0;
+	}
+
+	gintsts.d32 = ltqusb_read_core_intr(core_if);
+
+	if (!gintsts.d32)
+		return 0;
+
+	LOCK_INTR(_ltqhcd);
+
+	//Common INT
+	if (gintsts.b.modemismatch)
+	{
+		retval |= handle_mode_mismatch_intr(_ltqhcd);
+	}
+	if (gintsts.b.otgintr)
+	{
+		retval |= handle_otg_intr(_ltqhcd);
+	}
+	if (gintsts.b.conidstschng)
+	{
+		retval |= handle_conn_id_status_change_intr(_ltqhcd);
+	}
+	if (gintsts.b.disconnect)
+	{
+		retval |= handle_disconnect_intr(_ltqhcd);
+	}
+	if (gintsts.b.sessreqintr)
+	{
+		retval |= handle_session_req_intr(_ltqhcd);
+	}
+	if (gintsts.b.wkupintr)
+	{
+		retval |= handle_wakeup_detected_intr(_ltqhcd);
+	}
+	if (gintsts.b.usbsuspend)
+	{
+		retval |= handle_usb_suspend_intr(_ltqhcd);
+	}
+
+	//Host Int
+	if (gintsts.b.sofintr)
+	{
+		retval |= handle_sof_intr (_ltqhcd);
+	}
+	if (gintsts.b.portintr)
+	{
+		retval |= handle_port_intr (_ltqhcd);
+	}
+	if (gintsts.b.hcintr)
+	{
+		int i;
+		haint_data_t haint;
+		haint.d32 = ltqusb_read_host_all_channels_intr(core_if);
+		for (i=0; i<MAX_EPS_CHANNELS && i< core_if->params.host_channels; i++)
+			if (haint.b2.chint & (1 << i))
+				retval |= handle_hc_n_intr (_ltqhcd, i);
+	}
+	UNLOCK_INTR(_ltqhcd);
+	return retval;
+}
+
--- a/drivers/usb/host/ltqhcd_queue.c
+++ b/drivers/usb/host/ltqhcd_queue.c
@@ -0,0 +1,563 @@
+/*****************************************************************************
+ **   FILE NAME       : ltqhcd_queue.c
+ **   PROJECT         : Lantiq USB sub-system V3
+ **   MODULES         : Lantiq USB sub-system Host and Device driver
+ **   SRC VERSION     : 3.2
+ **   DATE            : 1/Jan/2011
+ **   AUTHOR          : Chen, Howard
+ **   DESCRIPTION     : This file contains the functions to manage Queue Heads and Queue
+ **                     Transfer Descriptors.
+ **   FUNCTIONS       :
+ **   COMPILER        : gcc
+ **   REFERENCE       : Synopsys DWC-OTG Driver 2.7
+ **   COPYRIGHT       :  Copyright (c) 2010
+ **                      LANTIQ DEUTSCHLAND GMBH,
+ **                      Am Campeon 3, 85579 Neubiberg, Germany
+ **
+ **    This program is free software; you can redistribute it and/or modify
+ **    it under the terms of the GNU General Public License as published by
+ **    the Free Software Foundation; either version 2 of the License, or
+ **    (at your option) any later version.
+ **
+ **  Version Control Section  **
+ **   $Author$
+ **   $Date$
+ **   $Revisions$
+ **   $Log$       Revision history
+ *****************************************************************************/
+
+/*
+ * This file contains code fragments from Synopsys HS OTG Linux Software Driver.
+ * For this code the following notice is applicable:
+ *
+ * ==========================================================================
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/*!
+ \file ltqhcd_queue.c
+ \ingroup LTQUSB_DRIVER_V3
+  \brief This file contains the functions to manage Queue Heads and Queue
+  Transfer Descriptors.
+*/
+#include <linux/version.h>
+#include "ltqusb_version.h"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+
+#include "ltqusb_plat.h"
+#include "ltqusb_regs.h"
+#include "ltqusb_cif.h"
+#include "ltqhcd.h"
+
+#ifdef __EPQD_DESTROY_TIMEOUT__
+	#define epqh_self_destroy_timeout 300
+	static
+	void eqph_destroy_func(unsigned long _ptr)
+	{
+		ltqhcd_epqh_t *epqh=(ltqhcd_epqh_t *)_ptr;
+		if(epqh)
+		{
+			if(epqh->sysep)
+			{
+				epqh->sysep->hcpriv=NULL;
+			}
+			ltqhcd_epqh_free (epqh);
+		}
+	}
+#endif
+
+/*!
+  \brief This function allocates and initializes a EPQH.
+
+  \param _ltqhcd The HCD state structure for the USB Host controller.
+  \param[in] _urb Holds the information about the device/endpoint that we need
+  to initialize the EPQH.
+
+  \return Returns pointer to the newly allocated EPQH, or NULL on error.
+ */
+static
+ltqhcd_epqh_t *ltqhcd_epqh_create (ltqhcd_hcd_t *_ltqhcd, struct urb *_urb)
+{
+	ltqhcd_epqh_t *epqh;
+
+	hprt0_data_t   hprt0;
+	struct usb_host_endpoint *sysep = ltqhcd_urb_to_endpoint(_urb);
+
+	/* Allocate memory */
+	epqh=(ltqhcd_epqh_t *) kmalloc (sizeof(ltqhcd_epqh_t), GFP_ATOMIC);
+
+	if(epqh == NULL)
+		return NULL;
+
+	memset (epqh, 0, sizeof (ltqhcd_epqh_t));
+
+	epqh->sysep=sysep;
+
+	epqh->devno=_urb->dev->devnum;
+
+	epqh->ltqhcd=_ltqhcd;
+	epqh->phase=EPQH_IDLE;
+
+	/* Initialize EPQH */
+	switch (usb_pipetype(_urb->pipe))
+	{
+		case PIPE_CONTROL    : epqh->ep_type = LTQUSB_EP_TYPE_CTRL; epqh->burst_on=0;break;
+		case PIPE_BULK       : epqh->ep_type = LTQUSB_EP_TYPE_BULK; epqh->burst_on=1;break;
+		case PIPE_ISOCHRONOUS: epqh->ep_type = LTQUSB_EP_TYPE_ISOC; epqh->burst_on=0;break;
+		case PIPE_INTERRUPT  : epqh->ep_type = LTQUSB_EP_TYPE_INTR; epqh->burst_on=0;break;
+	}
+
+	usb_settoggle(_urb->dev, usb_pipeendpoint (_urb->pipe), !usb_pipein(_urb->pipe), LTQUSB_HC_PID_DATA0);
+	epqh->mps = usb_maxpacket(_urb->dev, _urb->pipe, !(usb_pipein(_urb->pipe)));
+
+	INIT_LIST_HEAD(&epqh->urbd_list);
+	INIT_LIST_HEAD(&epqh->release_list);
+	INIT_LIST_HEAD(&epqh->ql);
+	INIT_LIST_HEAD(&epqh->ql_all);
+	INIT_URBD_LIST(epqh);
+	INIT_URBD_RELEASE_LIST(epqh);
+
+	/* FS/LS Enpoint on HS Hub
+	 * NOT virtual root hub */
+	epqh->need_split = 0;
+	hprt0.d32 = ltqusb_read_hprt0 (&_ltqhcd->core_if);
+	if (hprt0.b.prtspd == LTQUSB_HPRT0_PRTSPD_HIGH_SPEED)
+		_ltqhcd->use_hrtimer=1;
+	else
+		_ltqhcd->use_hrtimer=0;
+	if (hprt0.b.prtspd == LTQUSB_HPRT0_PRTSPD_HIGH_SPEED &&
+	    ((_urb->dev->speed == USB_SPEED_LOW) ||
+	     (_urb->dev->speed == USB_SPEED_FULL)) &&
+	     (_urb->dev->tt) && (_urb->dev->tt->hub->devnum != 1))
+	{
+		LTQ_DEBUGPL(DBG_HCD, "QH init: EP %d: TT found at hub addr %d, for port %d\n",
+		       usb_pipeendpoint(_urb->pipe), _urb->dev->tt->hub->devnum,
+		       _urb->dev->ttport);
+		epqh->need_split = 1;
+		epqh->burst_on=0;
+	}
+
+	if (epqh->ep_type == LTQUSB_EP_TYPE_INTR ||
+	    epqh->ep_type == LTQUSB_EP_TYPE_ISOC)
+	{
+		/* Compute scheduling parameters once and save them. */
+		epqh->interval    = _urb->interval+1;
+		if(epqh->need_split)
+			epqh->interval *= 8;
+	}
+
+	#ifdef __EN_ISOC__
+		if (epqh->ep_type == LTQUSB_EP_TYPE_ISOC)
+			_ltqhcd->isoc_ep_count++;
+	#endif
+
+	epqh->period_counter=0;
+
+	#ifdef __EPQD_DESTROY_TIMEOUT__
+		/* Start a timer for this transfer. */
+		init_timer(&epqh->destroy_timer);
+		epqh->destroy_timer.function = eqph_destroy_func;
+		epqh->destroy_timer.data = (unsigned long)(epqh);
+	#endif
+
+	#ifdef __DEBUG__
+		LTQ_DEBUGPL(DBG_HCD , "LTQUSB HCD EPQH Initialized\n");
+		LTQ_DEBUGPL(DBG_HCDV, "LTQUSB HCD EPQH  - epqh = %p\n", epqh);
+		LTQ_DEBUGPL(DBG_HCDV, "LTQUSB HCD EPQH  - Device Address = %d EP %d, %s\n",
+			    _urb->dev->devnum,
+			    usb_pipeendpoint(_urb->pipe),
+			    usb_pipein(_urb->pipe) == USB_DIR_IN ? "IN" : "OUT");
+		LTQ_DEBUGPL(DBG_HCDV, "LTQUSB HCD EPQH  - Speed = %s\n",
+			    ({ char *speed; switch (_urb->dev->speed) {
+			    case USB_SPEED_LOW: speed  = "low" ; break;
+			    case USB_SPEED_FULL: speed = "full"; break;
+			    case USB_SPEED_HIGH: speed = "high"; break;
+			    default: speed = "?";	break;
+			    }; speed;}));
+		LTQ_DEBUGPL(DBG_HCDV, "LTQUSB HCD EPQH  - Type = %s\n",
+			({
+				char *type; switch (epqh->ep_type)
+				{
+				    case LTQUSB_EP_TYPE_ISOC: type = "isochronous"; break;
+				    case LTQUSB_EP_TYPE_INTR: type = "interrupt"  ; break;
+				    case LTQUSB_EP_TYPE_CTRL: type = "control"    ; break;
+				    case LTQUSB_EP_TYPE_BULK: type = "bulk"       ; break;
+				    default: type = "?";	break;
+				};
+				type;
+			}));
+		if (epqh->ep_type == LTQUSB_EP_TYPE_INTR)
+			LTQ_DEBUGPL(DBG_HCDV, "LTQUSB HCD EPQH - interval = %d\n", epqh->interval);
+	#endif
+
+	list_add_tail(&epqh->ql_all, &_ltqhcd->epqh_list_all);
+
+	LOCK_EPQH_LIST(_ltqhcd);
+	switch (epqh->ep_type)
+	{
+		case LTQUSB_EP_TYPE_CTRL:
+			list_add_tail(&epqh->ql, &_ltqhcd->epqh_list_ctrl);
+			break;
+		case LTQUSB_EP_TYPE_BULK:
+			list_add_tail(&epqh->ql, &_ltqhcd->epqh_list_bulk);
+			break;
+		case LTQUSB_EP_TYPE_INTR:
+			list_add_tail(&epqh->ql, &_ltqhcd->epqh_list_intr);
+			break;
+	#ifdef __EN_ISOC__
+		case LTQUSB_EP_TYPE_ISOC:
+			list_add_tail(&epqh->ql, &_ltqhcd->epqh_list_isoc);
+			break;
+	#endif
+	}
+	UNLOCK_EPQH_LIST(_ltqhcd);
+	return epqh;
+}
+
+
+
+
+
+
+/*!
+  \brief Free the EPQH.  EPQH should already be removed from a list.
+  URBD list should already be empty if called from URB Dequeue.
+
+  \param[in] _epqh The EPQH to free.
+ */
+void ltqhcd_epqh_free (ltqhcd_epqh_t *_epqh)
+{
+	unsigned long     flags;
+	if(!_epqh)
+		return;
+
+	if(_epqh->sysep) _epqh->sysep->hcpriv=NULL;
+	_epqh->sysep=NULL;
+
+	local_irq_save (flags);
+	if(!list_empty(&_epqh->urbd_list) || !list_empty(&_epqh->release_list))
+		LTQ_WARN("%s() %p epqh not empty\n",__func__,_epqh);
+	else
+	{
+		LOCK_EPQH_LIST_ALL(_epqh->ltqhcd);
+		if (!list_empty(&_epqh->ql_all))
+			list_del_init (&_epqh->ql_all);
+		UNLOCK_EPQH_LIST_ALL(_epqh->ltqhcd);
+
+		LOCK_EPQH_LIST(_epqh->ltqhcd);
+		if (!list_empty(&_epqh->ql))
+			list_del_init (&_epqh->ql);
+		UNLOCK_EPQH_LIST(_epqh->ltqhcd);
+
+		#ifdef __EPQD_DESTROY_TIMEOUT__
+			del_timer(&_epqh->destroy_timer);
+		#endif
+		kfree (_epqh);
+	}
+	local_irq_restore (flags);
+}
+
+
+void ltqhcd_epqh_idle(ltqhcd_epqh_t *_epqh)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+	LOCK_URBD_LIST(_epqh);
+	if(_epqh->phase==EPQH_DISABLING ){
+	}else
+	if (list_empty(&_epqh->urbd_list))
+	{
+		if(_epqh->ep_type == LTQUSB_EP_TYPE_ISOC || _epqh->ep_type == LTQUSB_EP_TYPE_INTR)
+			_epqh->phase=EPQH_STDBY;
+		else
+		{
+			_epqh->phase=EPQH_IDLE;
+			#ifdef __EPQD_DESTROY_TIMEOUT__
+				del_timer(&_epqh->destroy_timer);
+				_epqh->destroy_timer.expires = jiffies + (HZ*epqh_self_destroy_timeout);
+				add_timer(&_epqh->destroy_timer );
+			#endif
+		}
+	}
+	else
+	{
+		_epqh->phase=EPQH_READY;
+		#ifdef __EPQD_DESTROY_TIMEOUT__
+			del_timer(&_epqh->destroy_timer);
+		#endif
+	}
+	UNLOCK_URBD_LIST(_epqh);
+	local_irq_restore(flags);
+}
+
+
+void ltqhcd_epqh_idle_periodic(ltqhcd_epqh_t *_epqh)
+{
+	unsigned long flags;
+	if(_epqh->ep_type != LTQUSB_EP_TYPE_ISOC && _epqh->ep_type != LTQUSB_EP_TYPE_INTR && _epqh->phase!=EPQH_STDBY)
+		return;
+
+	local_irq_save(flags);
+	LOCK_URBD_LIST(_epqh);
+	if (!list_empty(&_epqh->urbd_list))
+		LTQ_WARN("%s() invalid epqh state(not empty)\n",__func__);
+
+	if(_epqh->phase==EPQH_DISABLING ){
+	}else
+	{
+		_epqh->phase=EPQH_IDLE;
+
+		#ifdef __EPQD_DESTROY_TIMEOUT__
+			del_timer(&_epqh->destroy_timer);
+			_epqh->destroy_timer.expires = jiffies + (HZ*epqh_self_destroy_timeout);
+			add_timer(&_epqh->destroy_timer );
+		#endif
+
+		#ifdef __EN_ISOC__
+			if (_epqh->ep_type == LTQUSB_EP_TYPE_ISOC)
+				_epqh->ltqhcd->isoc_ep_count--;
+		#endif
+	}
+	UNLOCK_URBD_LIST(_epqh);
+	local_irq_restore(flags);
+}
+
+
+
+static
+void process_unaligned( ltqhcd_urbd_t *_urbd, ltqhcd_epqh_t *_epqh, ltqusb_core_if_t *_core_if)
+{
+	#if   defined(__UNALIGNED_BUF_ADJ__) || defined(__UNALIGNED_BUF_CHK__)
+	if(!_urbd->aligned_checked)
+	{
+		#if   defined(__UNALIGNED_BUF_ADJ__)
+			uint32_t xfer_len;
+
+			if(_urbd->aligned_buf)
+			{
+				ltqusb_free_buf_h(_urbd->aligned_buf);
+				_urbd->aligned_buf=NULL;
+			}
+			if(_urbd->aligned_setup)
+			{
+				ltqusb_free_buf_h(_urbd->aligned_setup);
+				_urbd->aligned_setup=NULL;
+			}
+
+			xfer_len=_urbd->xfer_len;
+			if(_urbd->is_in && xfer_len<_epqh->mps)
+				xfer_len = _epqh->mps;
+
+			if(xfer_len > 0 && ((unsigned long)_urbd->xfer_buff) & _core_if->unaligned_mask)
+			{
+				_urbd->aligned_buf = ltqusb_alloc_buf_h(xfer_len, _urbd->is_in);
+				if(!_urbd->aligned_buf)
+					LTQ_ERROR("Unaligned buf alloc error\n");
+				else if(!_urbd->is_in)
+					memcpy(_urbd->aligned_buf, _urbd->xfer_buff, xfer_len);
+			}
+			if(_epqh->ep_type==LTQUSB_EP_TYPE_CTRL)
+			{
+				if(((unsigned long)_urbd->setup_buff) & _core_if->unaligned_mask)
+				{
+					_urbd->aligned_setup = ltqusb_alloc_buf_h(8,0);
+					if(!_urbd->aligned_setup)
+						LTQ_ERROR("Unaligned setup buf alloc error\n");
+					else
+						memcpy(_urbd->aligned_setup, _urbd->setup_buff, 8);
+				}
+			}
+		#elif defined(__UNALIGNED_BUF_CHK__)
+			if(_urbd->is_in)
+			{
+				if(_urbd->xfer_len==0)
+					LTQ_WARN("%s():%d IN xfer while length is zero \n",__func__,__LINE__);
+				else{
+					if(((unsigned long)_urbd->xfer_buff) & _core_if->unaligned_mask)
+						LTQ_WARN("%s():%d IN xfer Buffer UNALIGNED\n",__func__,__LINE__);
+				}
+			}
+			else
+			{
+				if(_urbd->xfer_len > 0 && (((unsigned long)_urbd->xfer_buff) & _core_if->unaligned_mask))
+					LTQ_WARN("%s():%d OUT xfer Buffer UNALIGNED\n",__func__,__LINE__);
+			}
+			if(_epqh->ep_type==LTQUSB_EP_TYPE_CTRL)
+			{
+				if(((unsigned long)_urbd->setup_buff) & _core_if->unaligned_mask)
+					LTQ_WARN("%s():%d SETUP xfer Buffer UNALIGNED\n",__func__,__LINE__);
+			}
+		#endif
+	}
+	_urbd->aligned_checked=1;
+	#endif
+}
+
+
+ltqhcd_epqh_t *ltqhcd_urbd_create (ltqhcd_hcd_t *_ltqhcd,struct urb *_urb)
+{
+	ltqhcd_urbd_t            *urbd;
+	struct usb_host_endpoint *sysep;
+	ltqhcd_epqh_t            *epqh=NULL;
+	unsigned long             flags;
+
+	local_irq_save(flags);
+
+	sysep = ltqhcd_urb_to_endpoint(_urb);
+
+	LOCK_EPQH_LIST_ALL(_ltqhcd);
+	epqh = sysep_to_epqh(_ltqhcd, sysep,1);
+
+	if (!epqh)
+	{
+		sysep->hcpriv = NULL;
+		epqh = ltqhcd_epqh_create (_ltqhcd, _urb);
+	}
+	UNLOCK_EPQH_LIST_ALL(_ltqhcd);
+
+	if (!epqh)
+	{
+		LTQ_ERROR("EPQH Error alloc\n");
+		local_irq_restore (flags);
+		return (ltqhcd_epqh_t *)NULL;
+	}
+	if(epqh->phase==EPQH_DISABLING)
+	{
+		LTQ_ERROR("EPQH Error alloc while disabling\n");
+		local_irq_restore (flags);
+		return (ltqhcd_epqh_t *)NULL;
+	}
+	sysep->hcpriv = epqh;
+
+	if(_urb->hcpriv)
+	{
+		LTQ_WARN("%s() Previous urb->hcpriv exist %p\n",__func__,_urb->hcpriv);
+	#if 1
+		local_irq_restore (flags);
+		return (ltqhcd_epqh_t *)NULL;
+	#else
+		urbd = _urb->hcpriv;
+		if(urbd->epqh!=epqh)
+			LTQ_WARN("%s() Previous urb->hcpriv exist %p and epqh not the same %p %p\n",__func__,_urb->hcpriv,urbd->epqh,epqh);
+	#endif
+	}
+	else
+	{
+		urbd =  (ltqhcd_urbd_t *) kmalloc (sizeof(ltqhcd_urbd_t), GFP_ATOMIC);
+		if (!urbd)
+		{
+			local_irq_restore (flags);
+			return (ltqhcd_epqh_t *)NULL;
+		}
+		memset (urbd, 0, sizeof (ltqhcd_urbd_t));
+		INIT_LIST_HEAD(&urbd->ql);
+	}
+
+	_urb->hcpriv = urbd;
+	urbd->urb   = _urb;
+	urbd->epqh  =  epqh;
+	urbd->status= -EINPROGRESS;
+
+	urbd->is_in=usb_pipein(_urb->pipe) ? 1 : 0;
+
+	#ifdef __EN_ISOC__
+	if(epqh->ep_type == LTQUSB_EP_TYPE_ISOC)
+	{
+		if((_urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP) && _urb->transfer_dma && (_urb->transfer_dma &3)==0)
+			urbd->xfer_buff = (uint8_t *) (KSEG1ADDR((uint32_t *)_urb->transfer_dma));
+		else
+			urbd->xfer_buff = (uint8_t *) _urb->transfer_buffer;
+	}
+	else
+	#endif
+	{
+		urbd->xfer_len=_urb->transfer_buffer_length;
+		if(urbd->xfer_len>0)
+		{
+			if((_urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP) && _urb->transfer_dma && (_urb->transfer_dma &3)==0)
+				urbd->xfer_buff = (uint8_t *) (KSEG1ADDR((uint32_t *)_urb->transfer_dma));
+			else
+				urbd->xfer_buff = (uint8_t *) _urb->transfer_buffer;
+		}
+	}
+
+	#if 1 // cache write-back, so DMA engine can get correct content. Precaution
+		if(urbd->xfer_len)
+			dma_cache_wback_inv((unsigned long)urbd->xfer_buff, urbd->xfer_len);
+	#endif
+
+	if(epqh->ep_type == LTQUSB_EP_TYPE_CTRL)
+	{
+		if(_urb->setup_dma && (_urb->setup_dma &3)==0 )
+			urbd->setup_buff = (uint8_t *) (KSEG1ADDR((uint32_t *)_urb->setup_dma));
+		else
+			urbd->setup_buff = (uint8_t *) _urb->setup_packet;
+		#if 1 // cache write-back, so DMA engine can get correct content. Precaution
+			dma_cache_wback_inv((unsigned long)urbd->setup_buff, 16);
+		#endif
+	}
+
+	LOCK_URBD_LIST(epqh);
+	if (!list_empty(&urbd->ql))
+		list_del_init(&urbd->ql);
+	list_add_tail(&urbd->ql, &epqh->urbd_list);
+	epqh->urbd_count++;
+	UNLOCK_URBD_LIST(epqh);
+
+	process_unaligned( urbd, epqh, (&_ltqhcd->core_if));
+
+	local_irq_restore (flags);
+	return epqh;
+}
+
+
+
+ltqhcd_epqh_t * sysep_to_epqh(ltqhcd_hcd_t *_ltqhcd, struct usb_host_endpoint *_sysep, int _skipcancel)
+{
+	ltqhcd_epqh_t *epqh;
+
+	list_for_each_entry( epqh, &_ltqhcd->epqh_list_all, ql_all)
+	{
+		if(!(_skipcancel && epqh->cancelling))
+		{
+			if( epqh->sysep==_sysep)
+				return epqh;
+		}
+	}
+	return NULL;
+}
+
--- a/drivers/usb/host/ltqusb_cif.h
+++ b/drivers/usb/host/ltqusb_cif.h
@@ -0,0 +1,500 @@
+/*****************************************************************************
+ **   FILE NAME       : ltqusb_cif.h
+ **   PROJECT         : Lantiq USB sub-system V3
+ **   MODULES         : Lantiq USB sub-system Host and Device driver
+ **   SRC VERSION     : 3.2
+ **   DATE            : 1/Jan/2011
+ **   AUTHOR          : Chen, Howard
+ **   DESCRIPTION     : The Core Interface provides basic services for accessing and
+ **                     managing the Lantiq USB hardware. These services are used by both the
+ **                     Host Controller Driver and the Peripheral Controller Driver.
+ **   FUNCTIONS       :
+ **   COMPILER        : gcc
+ **   REFERENCE       : Synopsys DWC-OTG Driver 2.7
+ **   COPYRIGHT       :  Copyright (c) 2010
+ **                      LANTIQ DEUTSCHLAND GMBH,
+ **                      Am Campeon 3, 85579 Neubiberg, Germany
+ **
+ **    This program is free software; you can redistribute it and/or modify
+ **    it under the terms of the GNU General Public License as published by
+ **    the Free Software Foundation; either version 2 of the License, or
+ **    (at your option) any later version.
+ **
+ **  Version Control Section  **
+ **   $Author$
+ **   $Date$
+ **   $Revisions$
+ **   $Log$       Revision history
+ *****************************************************************************/
+
+/*
+ * This file contains code fragments from Synopsys HS OTG Linux Software Driver.
+ * For this code the following notice is applicable:
+ *
+ * ==========================================================================
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/*!
+ \defgroup LTQUSB_DRIVER_V3 Lantiq USB SS Project
+ \brief Lantiq USB subsystem V3.x
+ */
+
+/*!
+ \defgroup LTQUSB_CIF Core Interface APIs
+ \ingroup LTQUSB_DRIVER_V3
+ \brief The Core Interface provides basic services for accessing and
+        managing the LTQUSB hardware. These services are used by both the
+        Host Controller Driver and the Peripheral Controller Driver.
+ */
+
+
+/*!
+ \file ltqusb_cif.h
+ \ingroup LTQUSB_DRIVER_V3
+ \brief This file contains the interface to the Lantiq USB Core.
+ */
+
+#if !defined(__LTQUSB_CIF_H__)
+#define __LTQUSB_CIF_H__
+
+#include <linux/workqueue.h>
+
+#include <linux/version.h>
+#include <asm/param.h>
+
+#include "ltqusb_plat.h"
+#include "ltqusb_regs.h"
+
+#ifdef __DEBUG__
+	#include "linux/timer.h"
+#endif
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+#define LTQUSB_PARAM_SPEED_HIGH 0 /*!< Build stage parameter: High Speed */
+#define LTQUSB_PARAM_SPEED_FULL 1 /*!< Build stage parameter: Full Speed */
+
+#define LTQUSB_EP_SPEED_LOW     0 /*!< Run-Time Status: High Speed */
+#define LTQUSB_EP_SPEED_FULL    1 /*!< Run-Time Status: Full Speed */
+#define LTQUSB_EP_SPEED_HIGH    2 /*!< Run-Time Status: Low Speed */
+
+#define LTQUSB_EP_TYPE_CTRL     0 /*!< Run-Time Status: CTRL */
+#define LTQUSB_EP_TYPE_ISOC     1 /*!< Run-Time Status: ISOC */
+#define LTQUSB_EP_TYPE_BULK     2 /*!< Run-Time Status: BULK */
+#define LTQUSB_EP_TYPE_INTR     3 /*!< Run-Time Status: INTR */
+
+#define LTQUSB_HC_PID_DATA0     0     /*!< Run-Time Data Toggle: Data 0 */
+#define LTQUSB_HC_PID_DATA2     1     /*!< Run-Time Data Toggle: Data 2 */
+#define LTQUSB_HC_PID_DATA1     2     /*!< Run-Time Data Toggle: Data 1 */
+#define LTQUSB_HC_PID_MDATA     3     /*!< Run-Time Data Toggle: MData */
+#define LTQUSB_HC_PID_SETUP     3     /*!< Run-Time Data Toggle: Setup */
+
+
+/*!
+ \addtogroup LTQUSB_CIF
+ */
+/*@{*/
+
+/*! typedef ltqusb_params_t
+ \brief LTQUSB Parameters structure.
+       This structure is used for both importing from insmod stage and run-time storage.
+       These parameters define how the LTQUSB controller should be configured.
+ */
+typedef struct ltqusb_params
+{
+	int32_t dma_burst_size;     /*!< The DMA Burst size (applicable only for Internal DMA
+	                                  Mode). 0(for single), 1(incr), 4(incr4), 8(incr8) 16(incr16)
+	                             */
+	                            /* Translate this to GAHBCFG values */
+	int32_t speed;              /*!< Specifies the maximum speed of operation in host and device mode.
+	                               The actual speed depends on the speed of the attached device and
+	                               the value of phy_type. The actual speed depends on the speed of the
+	                               attached device.
+	                               0 - High Speed (default)
+	                               1 - Full Speed
+                                */
+
+	int32_t data_fifo_size;     /*!< Total number of dwords in the data FIFO memory. This
+	                               memory includes the Rx FIFO, non-periodic Tx FIFO, and periodic
+	                               Tx FIFOs.
+	                               32 to 32768
+	                            */
+	int32_t host_channels;      /*!< The number of host channel registers to use.
+	                                 1 to 16
+	                             */
+
+	int32_t rx_fifo_size;       /*!< Number of dwords in the Rx FIFO in host mode.
+	                                16 to 32768
+	                             */
+
+	int32_t nperio_tx_fifo_size;    /*!< Number of dwords in the non-periodic Tx FIFO in host mode.
+	                                     16 to 32768
+	                                 */
+
+	int32_t perio_tx_fifo_size;     /*!< Number of dwords in the host periodic Tx FIFO.
+	                                     16 to 32768
+	                                 */
+
+	int32_t max_transfer_size;      /*!< The maximum transfer size supported in bytes.
+	                                     2047 to 65,535
+	                                 */
+
+	int32_t max_packet_count;       /*!< The maximum number of packets in a transfer.
+	                                     15 to 511  (default 511)
+	                                 */
+	int32_t phy_utmi_width;         /*!< Specifies the UTMI+ Data Width.
+	                                     8 or 16 bits (default 16)
+	                                 */
+
+	int32_t timeout_cal;            /*!< Specifies the Timeout_Calibration*/
+
+	int32_t oc_hy;
+
+	int32_t ana_disconnect_threshold      ;
+	int32_t ana_squelch_threshold         ;
+	int32_t ana_transmitter_crossover     ;
+	int32_t ana_transmitter_impedance     ;
+	int32_t ana_transmitter_dc_voltage    ;
+	int32_t ana_transmitter_risefall_time ;
+	int32_t ana_transmitter_pre_emphasis  ;
+} ltqusb_params_t;
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/*! typedef ltqusb_core_if_t
+ \brief The ltq_core_if structure contains information needed to manage
+       the Lantiq USB controller acting in either host or device mode. It
+       represents the programming view of the controller as a whole.
+ */
+typedef struct ltqusb_core_if
+{
+	ltqusb_params_t      params;  /*!< Run-time Parameters */
+
+	uint8_t  core_no;             /*!< core number (used as id when multi-core case */
+	char    *core_name;           /*!< core name used for registration and informative purpose*/
+	int      irq;                 /*!< irq number this core is hooked */
+	int      ocirq;
+	uint32_t mem1,mem2,mem3;
+	/*****************************************************************
+	 * Structures and pointers to physical register interface.
+	 *****************************************************************/
+	/** Core Global registers starting at offset 000h. */
+	ltqusb_core_global_regs_t *core_global_regs;  /*!< pointer to Core Global Registers, offset at 000h */
+
+	/** Host-specific registers */
+		/** Host Global Registers starting at offset 400h.*/
+	ltqusb_host_global_regs_t *host_global_regs; /*!< pointer to Host Global Registers, offset at 400h */
+		#define LTQUSB_HOST_GLOBAL_REG_OFFSET 0x400
+	/** Host Port 0 Control and Status Register */
+	volatile uint32_t *hprt0;                    /*!< pointer to HPRT0 Registers, offset at 440h */
+		#define LTQUSB_HOST_PORT_REGS_OFFSET 0x440
+	/** Host Channel Specific Registers at offsets 500h-5FCh. */
+	ltqusb_hc_regs_t *hc_regs[MAX_EPS_CHANNELS]; /*!< pointer to Host-Channel n Registers, offset at 500h */
+		#define LTQUSB_HOST_CHAN_REGS_OFFSET 0x500
+		#define LTQUSB_CHAN_REGS_OFFSET 0x20
+
+	/** Power and Clock Gating Control Register */
+	volatile uint32_t *pcgcctl;                                    /*!< pointer to Power and Clock Gating Control Registers, offset at E00h */
+		#define LTQUSB_PCGCCTL_OFFSET 0xE00
+
+	/** Push/pop addresses for endpoints or host channels.*/
+	uint32_t *data_fifo[MAX_EPS_CHANNELS];    /*!< pointer to FIFO access windows, offset at 1000h */
+		#define LTQUSB_DATA_FIFO_OFFSET 0x1000
+		#define LTQUSB_DATA_FIFO_SIZE   0x1000
+
+	uint32_t *data_fifo_dbg;                 /*!< pointer to FIFO debug windows, offset at 1000h */
+
+	/** Hardware Configuration -- stored here for convenience.*/
+	hwcfg1_data_t hwcfg1;  /*!< preserved Hardware Configuration 1 */
+	hwcfg2_data_t hwcfg2;  /*!< preserved Hardware Configuration 2 */
+	hwcfg3_data_t hwcfg3;  /*!< preserved Hardware Configuration 3 */
+	hwcfg4_data_t hwcfg4;  /*!< preserved Hardware Configuration 3 */
+	uint32_t      snpsid;  /*!< preserved SNPSID */
+
+	/*****************************************************************
+	 * Run-time informations.
+	 *****************************************************************/
+	/* Set to 1 if the core PHY interface bits in USBCFG have been  initialized. */
+	unsigned phy_init_done     : 1 ;/*!< indicated PHY is initialized. */
+	unsigned issuspended       : 1 ;
+
+	uint8_t queuing_high_bandwidth; /*!< Host mode, Queueing High Bandwidth. */
+
+	#if defined(__UNALIGNED_BUF_ADJ__) || defined(__UNALIGNED_BUF_CHK__)
+		uint32_t unaligned_mask;
+	#endif
+} ltqusb_core_if_t;
+
+/*@}*//*LTQUSB_CIF*/
+
+
+/*!
+ \fn    void *ltqusb_alloc_buf(size_t size, int clear)
+ \brief This function is called to allocate buffer of specified size.
+        The allocated buffer is mapped into DMA accessable address.
+ \param    size Size in BYTE to be allocated
+ \param    clear 0: don't do clear after buffer allocated, other: do clear to zero
+ \return   0/NULL: Fail; uncached pointer of allocated buffer
+ \ingroup  LTQUSB_CIF
+ */
+extern void *ltqusb_alloc_buf_h(size_t size, int clear);
+
+
+/*!
+ \fn    void ltqusb_free_buf(void *vaddr)
+ \brief This function is called to free allocated buffer.
+ \param vaddr the uncached pointer of the buffer
+ \ingroup  LTQUSB_CIF
+ */
+extern void ltqusb_free_buf_h(void *vaddr);
+
+/*!
+ \fn    int ltqusb_core_if_init(ltqusb_core_if_t *_core_if,
+                        int               _irq,
+                        uint32_t          _reg_base_addr,
+                        uint32_t          _fifo_base_addr,
+                        uint32_t          _fifo_dbg_addr)
+ \brief This function is called to initialize the LTQUSB CSR data
+        structures.  The register addresses in the device and host
+        structures are initialized from the base address supplied by the
+        caller.  The calling function must make the OS calls to get the
+        base address of the LTQUSB controller registers.
+ \param _core_if        Pointer of core_if structure
+ \param _irq            irq number
+ \param _reg_base_addr  Base address of LTQUSB core registers
+ \param _fifo_base_addr Fifo base address
+ \param _fifo_dbg_addr  Fifo debug address
+ \return 0: success;
+ \ingroup  LTQUSB_CIF
+ */
+extern int ltqusb_core_if_init_h(ltqusb_core_if_t *_core_if,
+                        int               _irq,
+                        uint32_t          _reg_base_addr,
+                        uint32_t          _fifo_base_addr,
+                        uint32_t          _fifo_dbg_addr);
+
+
+/*!
+ \fn    void ltqusb_core_if_remove(ltqusb_core_if_t *_core_if)
+ \brief This function free the mapped address in the LTQUSB CSR data structures.
+ \param _core_if Pointer of core_if structure
+ \ingroup  LTQUSB_CIF
+ */
+extern void ltqusb_core_if_remove_h(ltqusb_core_if_t *_core_if);
+
+/*!
+ \fn    void ltqusb_enable_global_interrupts( ltqusb_core_if_t *_core_if )
+ \brief This function enbles the controller's Global Interrupt in the AHB Config register.
+ \param _core_if Pointer of core_if structure
+ */
+extern void ltqusb_enable_global_interrupts_h( ltqusb_core_if_t *_core_if );
+
+/*!
+ \fn    void ltqusb_disable_global_interrupts( ltqusb_core_if_t *_core_if )
+ \brief This function disables the controller's Global Interrupt in the AHB Config register.
+ \param _core_if Pointer of core_if structure
+ \ingroup  LTQUSB_CIF
+ */
+extern void ltqusb_disable_global_interrupts_h( ltqusb_core_if_t *_core_if );
+
+/*!
+ \fn    void ltqusb_flush_tx_fifo( ltqusb_core_if_t *_core_if, const int _num )
+ \brief Flush a Tx FIFO.
+ \param _core_if Pointer of core_if structure
+ \param _num Tx FIFO to flush. ( 0x10 for ALL TX FIFO )
+ \ingroup  LTQUSB_CIF
+ */
+extern void ltqusb_flush_tx_fifo_h( ltqusb_core_if_t *_core_if, const int _num );
+
+/*!
+ \fn    void ltqusb_flush_rx_fifo( ltqusb_core_if_t *_core_if )
+ \brief Flush Rx FIFO.
+ \param _core_if Pointer of core_if structure
+ \ingroup  LTQUSB_CIF
+ */
+extern void ltqusb_flush_rx_fifo_h( ltqusb_core_if_t *_core_if );
+
+/*!
+ \fn    void ltqusb_flush_both_fifo( ltqusb_core_if_t *_core_if )
+ \brief Flush ALL Rx and Tx FIFO.
+ \param _core_if Pointer of core_if structure
+ \ingroup  LTQUSB_CIF
+ */
+extern void ltqusb_flush_both_fifo_h( ltqusb_core_if_t *_core_if );
+
+
+/*!
+ \fn    int ltqusb_core_soft_reset(ltqusb_core_if_t *_core_if)
+ \brief Do core a soft reset of the core.  Be careful with this because it
+        resets all the internal state machines of the core.
+ \param    _core_if Pointer of core_if structure
+ \ingroup  LTQUSB_CIF
+ */
+extern int ltqusb_core_soft_reset_h(ltqusb_core_if_t *_core_if);
+
+
+/*!
+ \brief Turn on the USB Core Power
+ \param _core_if Pointer of core_if structure
+ \ingroup  LTQUSB_CIF
+*/
+extern void ltqusb_power_on_h (ltqusb_core_if_t *_core_if);
+
+/*!
+ \fn    void ltqusb_power_off (ltqusb_core_if_t *_core_if)
+ \brief Turn off the USB Core Power
+ \param _core_if Pointer of core_if structure
+ \ingroup  LTQUSB_CIF
+*/
+extern void ltqusb_power_off_h (ltqusb_core_if_t *_core_if);
+
+/*!
+ \fn    void ltqusb_phy_power_on (ltqusb_core_if_t *_core_if)
+ \brief Turn on the USB PHY Power
+ \param _core_if Pointer of core_if structure
+ \ingroup  LTQUSB_CIF
+*/
+extern void ltqusb_phy_power_on_h (ltqusb_core_if_t *_core_if);
+
+
+/*!
+ \fn    void ltqusb_phy_power_off (ltqusb_core_if_t *_core_if)
+ \brief Turn off the USB PHY Power
+ \param _core_if Pointer of core_if structure
+ \ingroup  LTQUSB_CIF
+*/
+extern void ltqusb_phy_power_off_h (ltqusb_core_if_t *_core_if);
+
+/*!
+ \fn    void ltqusb_hard_reset(ltqusb_core_if_t *_core_if)
+ \brief Reset on the USB Core RCU
+ \param _core_if Pointer of core_if structure
+ \ingroup  LTQUSB_CIF
+ */
+extern void ltqusb_hard_reset_h(ltqusb_core_if_t *_core_if);
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+	/*!
+	 \fn    void ltqusb_host_core_init(ltqusb_core_if_t *_core_if, ltqusb_params_t  *_params)
+	 \brief This function initializes the LTQUSB controller registers for  Host mode.
+	        This function flushes the Tx and Rx FIFOs and it flushes any entries in the
+	        request queues.
+	 \param _core_if        Pointer of core_if structure
+	 \param _params         parameters to be set
+	 \ingroup  LTQUSB_CIF
+	 */
+	extern void ltqusb_host_core_init(ltqusb_core_if_t *_core_if, ltqusb_params_t  *_params);
+
+	/*!
+	 \fn    void ltqusb_host_enable_interrupts(ltqusb_core_if_t *_core_if)
+	 \brief This function enables the Host mode interrupts.
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+	extern void ltqusb_host_enable_interrupts(ltqusb_core_if_t *_core_if);
+
+	/*!
+	 \fn    void ltqusb_host_disable_interrupts(ltqusb_core_if_t *_core_if)
+	 \brief This function disables the Host mode interrupts.
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+	extern void ltqusb_host_disable_interrupts(ltqusb_core_if_t *_core_if);
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/* internal routines for debugging */
+	extern void ltqusb_dump_msg_h(const u8 *buf, unsigned int length);
+	extern void ltqusb_dump_spram_h(ltqusb_core_if_t *_core_if);
+	extern void ltqusb_dump_registers_h(ltqusb_core_if_t *_core_if);
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+static inline uint32_t ltqusb_read_core_intr(ltqusb_core_if_t *_core_if)
+{
+	return (ltqusb_rreg(&_core_if->core_global_regs->gintsts) &
+	        ltqusb_rreg(&_core_if->core_global_regs->gintmsk));
+}
+
+static inline uint32_t ltqusb_read_otg_intr (ltqusb_core_if_t *_core_if)
+{
+	return (ltqusb_rreg (&_core_if->core_global_regs->gotgint));
+}
+
+static inline uint32_t ltqusb_mode(ltqusb_core_if_t *_core_if)
+{
+	return (ltqusb_rreg( &_core_if->core_global_regs->gintsts ) & 0x1);
+}
+static inline uint8_t ltqusb_is_device_mode(ltqusb_core_if_t *_core_if)
+{
+	return (ltqusb_mode(_core_if) != 1);
+}
+static inline uint8_t ltqusb_is_host_mode(ltqusb_core_if_t *_core_if)
+{
+	return (ltqusb_mode(_core_if) == 1);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+static inline uint32_t ltqusb_read_hprt0(ltqusb_core_if_t *_core_if)
+{
+	hprt0_data_t hprt0;
+	hprt0.d32 = ltqusb_rreg(_core_if->hprt0);
+	hprt0.b.prtena = 0;
+	hprt0.b.prtconndet = 0;
+	hprt0.b.prtenchng = 0;
+	hprt0.b.prtovrcurrchng = 0;
+	return hprt0.d32;
+}
+
+static inline uint32_t ltqusb_read_host_all_channels_intr (ltqusb_core_if_t *_core_if)
+{
+	return (ltqusb_rreg (&_core_if->host_global_regs->haint));
+}
+
+static inline uint32_t ltqusb_read_host_channel_intr (ltqusb_core_if_t *_core_if, int hc_num)
+{
+	return (ltqusb_rreg (&_core_if->hc_regs[hc_num]->hcint));
+}
+
+extern void ltqusb_attr_create_h (void *_dev);
+extern void ltqusb_attr_remove_h (void *_dev);
+
+extern uint32_t ltqusb_oc_get_hy(int port);
+extern void ltqusb_oc_set_hy(int port,uint32_t setting);
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+#endif // !defined(__LTQUSB_CIF_H__)
+
--- a/drivers/usb/host/ltqusb_cif_h.c
+++ b/drivers/usb/host/ltqusb_cif_h.c
@@ -0,0 +1,2506 @@
+/*****************************************************************************
+ **   FILE NAME       : ltqusb_cif_h.c
+ **   PROJECT         : Lantiq USB sub-system V3
+ **   MODULES         : Lantiq USB sub-system Host and Device driver
+ **   SRC VERSION     : 3.2
+ **   DATE            : 1/Jan/2011
+ **   AUTHOR          : Chen, Howard
+ **   DESCRIPTION     : The Core Interface provides basic services for accessing and
+ **                     managing the Lantiq USB hardware. These services are used by the
+ **                     Host Controller Driver only.
+ **   FUNCTIONS       :
+ **   COMPILER        : gcc
+ **   REFERENCE       : Synopsys DWC-OTG Driver 2.7
+ **   COPYRIGHT       :  Copyright (c) 2010
+ **                      LANTIQ DEUTSCHLAND GMBH,
+ **                      Am Campeon 3, 85579 Neubiberg, Germany
+ **
+ **    This program is free software; you can redistribute it and/or modify
+ **    it under the terms of the GNU General Public License as published by
+ **    the Free Software Foundation; either version 2 of the License, or
+ **    (at your option) any later version.
+ **
+ **  Version Control Section  **
+ **   $Author$
+ **   $Date$
+ **   $Revisions$
+ **   $Log$       Revision history
+ *****************************************************************************/
+
+/*
+ * This file contains code fragments from Synopsys HS OTG Linux Software Driver.
+ * For this code the following notice is applicable:
+ *
+ * ==========================================================================
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/*!
+ \file ltqusb_cif_h.c
+ \ingroup LTQUSB_DRIVER_V3
+ \brief This file contains the interface to the Lantiq USB Core.
+*/
+#include <linux/version.h>
+#include "ltqusb_version.h"
+
+#include <asm/byteorder.h>
+#include <asm/unaligned.h>
+
+#ifdef __DEBUG__
+	#include <linux/jiffies.h>
+#endif
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/gfp.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include "ltqusb_plat.h"
+#include "ltqusb_regs.h"
+#include "ltqusb_cif.h"
+
+#include "ltqhcd.h"
+
+extern ltqhcd_hcd_t ltqusb_hcd_1;
+extern ltqhcd_hcd_t ltqusb_hcd_2;
+extern int ltqusb_oc_shared;
+extern int ltqusb_vbus_shared;
+extern int ltqusb_led_shared;
+
+/*!
+ \brief This function is called to allocate buffer of specified size.
+        The allocated buffer is mapped into DMA accessable address.
+ \param size Size in BYTE to be allocated
+ \param clear 0: don't do clear after buffer allocated, other: do clear to zero
+ \return 0/NULL: Fail; uncached pointer of allocated buffer
+ */
+void *ltqusb_alloc_buf_h(size_t size, int clear)
+{
+	uint32_t *cached,*uncached;
+	uint32_t totalsize,page;
+
+	if(!size)
+		return 0;
+
+	size=(size+3)&0xFFFFFFFC;
+	totalsize=size + 12;
+	page=get_order(totalsize);
+
+	cached = (void *) __get_free_pages(( GFP_ATOMIC | GFP_DMA), page);
+
+	if(!cached)
+	{
+		LTQ_PRINT("%s Allocation Failed size:%d\n",__func__,size);
+		return NULL;
+	}
+
+	uncached = (uint32_t *)(KSEG1ADDR(cached));
+	if(clear)
+		memset(uncached, 0, totalsize);
+
+	*(uncached+0)=totalsize;
+	*(uncached+1)=page;
+	*(uncached+2)=(uint32_t)cached;
+	return (void *)(uncached+3);
+}
+
+
+/*!
+ \brief This function is called to free allocated buffer.
+ \param vaddr the uncached pointer of the buffer
+ */
+void ltqusb_free_buf_h(void *vaddr)
+{
+	uint32_t totalsize,page;
+	uint32_t *cached,*uncached;
+
+	if(vaddr != NULL)
+	{
+		uncached=vaddr;
+		uncached-=3;
+		totalsize=*(uncached+0);
+		page=*(uncached+1);
+		cached=(uint32_t *)(*(uncached+2));
+		if(totalsize && page==get_order(totalsize) && cached==(uint32_t *)(KSEG0ADDR(uncached)))
+		{
+			free_pages((unsigned long)cached, page);
+			return;
+		}
+		// the memory is not allocated by ltqusb_alloc_buf. Allowed but must be careful.
+		return;
+	}
+}
+
+
+
+/*!
+   \brief This function is called to initialize the LTQUSB CSR data
+ 	 structures.  The register addresses in the device and host
+ 	 structures are initialized from the base address supplied by the
+ 	 caller.  The calling function must make the OS calls to get the
+ 	 base address of the LTQUSB controller registers.
+
+   \param _core_if        Pointer of core_if structure
+   \param _irq            irq number
+   \param _reg_base_addr  Base address of LTQUSB core registers
+   \param _fifo_base_addr Fifo base address
+   \param _fifo_dbg_addr  Fifo debug address
+   \return 	0: success;
+ */
+int ltqusb_core_if_init_h(ltqusb_core_if_t *_core_if,
+                        int               _irq,
+                        uint32_t          _reg_base_addr,
+                        uint32_t          _fifo_base_addr,
+                        uint32_t          _fifo_dbg_addr)
+{
+	int retval = 0;
+	uint32_t *reg_base  =NULL;
+    uint32_t *fifo_base =NULL;
+    uint32_t *fifo_dbg  =NULL;
+
+    int i;
+
+	LTQ_DEBUGPL(DBG_CILV, "%s(%p,%d,0x%08X,0x%08X,0x%08X)\n", __func__,
+	                                             _core_if,
+	                                             _irq,
+	                                             _reg_base_addr,
+	                                             _fifo_base_addr,
+	                                             _fifo_dbg_addr);
+
+	if( _core_if == NULL)
+	{
+		LTQ_ERROR("%s() invalid _core_if\n", __func__);
+		retval = -ENOMEM;
+		goto fail;
+	}
+
+	//memset(_core_if, 0, sizeof(ltqusb_core_if_t));
+
+	_core_if->irq=_irq;
+
+	reg_base  =ioremap_nocache(_reg_base_addr , LTQUSB_IOMEM_SIZE  );
+	fifo_base =ioremap_nocache(_fifo_base_addr, LTQUSB_FIFOMEM_SIZE);
+	fifo_dbg  =ioremap_nocache(_fifo_dbg_addr , LTQUSB_FIFODBG_SIZE);
+	if( reg_base == NULL || fifo_base == NULL || fifo_dbg == NULL)
+	{
+		LTQ_ERROR("%s() usb ioremap() failed\n", __func__);
+		retval = -ENOMEM;
+		goto fail;
+	}
+
+	_core_if->core_global_regs = (ltqusb_core_global_regs_t *)reg_base;
+
+	/*
+	 * Attempt to ensure this device is really a LTQUSB Controller.
+	 * Read and verify the SNPSID register contents. The value should be
+	 * 0x45F42XXX
+	 */
+	{
+		int32_t snpsid;
+		snpsid = ltqusb_rreg(&_core_if->core_global_regs->gsnpsid);
+		if ((snpsid & 0xFFFFF000) != 0x4F542000)
+		{
+			LTQ_ERROR("%s() snpsid error(0x%08x) failed\n", __func__,snpsid);
+			retval = -EINVAL;
+			goto fail;
+		}
+		_core_if->snpsid=snpsid;
+	}
+
+	_core_if->host_global_regs = (ltqusb_host_global_regs_t *)
+	    ((uint32_t)reg_base + LTQUSB_HOST_GLOBAL_REG_OFFSET);
+	_core_if->hprt0 = (uint32_t*)((uint32_t)reg_base + LTQUSB_HOST_PORT_REGS_OFFSET);
+
+	for (i=0; i<MAX_EPS_CHANNELS; i++)
+	{
+		_core_if->hc_regs[i] = (ltqusb_hc_regs_t *)
+		    ((uint32_t)reg_base + LTQUSB_HOST_CHAN_REGS_OFFSET +
+		    (i * LTQUSB_CHAN_REGS_OFFSET));
+		LTQ_DEBUGPL(DBG_CILV, "hc_reg[%d]->hcchar=%p\n",
+		    i, &_core_if->hc_regs[i]->hcchar);
+	}
+
+	/* Setting the FIFO and other Address. */
+	for (i=0; i<MAX_EPS_CHANNELS; i++)
+	{
+		_core_if->data_fifo[i] = fifo_base + (i * LTQUSB_DATA_FIFO_SIZE);
+		LTQ_DEBUGPL(DBG_CILV, "data_fifo[%d]=0x%08x\n",
+		    i, (unsigned)_core_if->data_fifo[i]);
+	}
+
+	_core_if->data_fifo_dbg = fifo_dbg;
+	_core_if->pcgcctl = (uint32_t*)(((uint32_t)reg_base) + LTQUSB_PCGCCTL_OFFSET);
+
+	/*
+	 * Store the contents of the hardware configuration registers here for
+	 * easy access later.
+	 */
+	_core_if->hwcfg1.d32 = ltqusb_rreg(&_core_if->core_global_regs->ghwcfg1);
+	_core_if->hwcfg2.d32 = ltqusb_rreg(&_core_if->core_global_regs->ghwcfg2);
+	_core_if->hwcfg3.d32 = ltqusb_rreg(&_core_if->core_global_regs->ghwcfg3);
+	_core_if->hwcfg4.d32 = ltqusb_rreg(&_core_if->core_global_regs->ghwcfg4);
+
+	LTQ_DEBUGPL(DBG_CILV,"hwcfg1=%08x\n",_core_if->hwcfg1.d32);
+	LTQ_DEBUGPL(DBG_CILV,"hwcfg2=%08x\n",_core_if->hwcfg2.d32);
+	LTQ_DEBUGPL(DBG_CILV,"hwcfg3=%08x\n",_core_if->hwcfg3.d32);
+	LTQ_DEBUGPL(DBG_CILV,"hwcfg4=%08x\n",_core_if->hwcfg4.d32);
+
+
+	#ifdef __DED_FIFO__
+	{
+		unsigned int countdown=0xFFFF;
+		LTQ_PRINT("Waiting for PHY Clock Lock!\n");
+		while(--countdown && !( ltqusb_rreg(&_core_if->core_global_regs->grxfsiz) & (1<<9)))
+		{
+			UDELAY(1);
+		}
+		if(countdown)
+			LTQ_PRINT("PHY Clock Locked!\n");
+		else
+			LTQ_PRINT("PHY Clock Not Locked! %08X\n",ltqusb_rreg(&_core_if->core_global_regs->grxfsiz));
+	}
+	#endif
+
+	/* Create new workqueue and init works */
+#if 0
+	_core_if->wq_usb = create_singlethread_workqueue(_core_if->core_name);
+
+	if(_core_if->wq_usb == 0)
+	{
+		LTQ_DEBUGPL(DBG_CIL, "Creation of wq_usb failed\n");
+		retval = -EINVAL;
+		goto fail;
+	}
+
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+		INIT_WORK(&core_if->w_conn_id, w_conn_id_status_change, core_if);
+		INIT_WORK(&core_if->w_wkp, w_wakeup_detected, core_if);
+	#else
+		INIT_WORK(&core_if->w_conn_id, w_conn_id_status_change);
+		INIT_DELAYED_WORK(&core_if->w_wkp, w_wakeup_detected);
+	#endif
+#endif
+	return 0;
+
+fail:
+	if( reg_base  != NULL) iounmap(reg_base );
+	if( fifo_base != NULL) iounmap(fifo_base);
+	if( fifo_dbg  != NULL) iounmap(fifo_dbg );
+	return retval;
+}
+
+/*!
+ \brief This function free the mapped address in the LTQUSB CSR data structures.
+ \param _core_if Pointer of core_if structure
+ */
+void ltqusb_core_if_remove_h(ltqusb_core_if_t *_core_if)
+{
+	/* Disable all interrupts */
+	if( _core_if->core_global_regs  != NULL)
+	{
+		gusbcfg_data_t usbcfg   ={.d32 = 0};
+		usbcfg.d32 = ltqusb_rreg( &_core_if->core_global_regs->gusbcfg);
+		usbcfg.b.ForceDevMode=0;
+		usbcfg.b.ForceHstMode=0;
+		ltqusb_wreg( &_core_if->core_global_regs->gusbcfg,usbcfg.d32);
+		ltqusb_mreg( &_core_if->core_global_regs->gahbcfg, 1, 0);
+		ltqusb_wreg( &_core_if->core_global_regs->gintmsk, 0);
+	}
+
+	if( _core_if->core_global_regs  != NULL) iounmap(_core_if->core_global_regs );
+	if( _core_if->data_fifo[0]      != NULL) iounmap(_core_if->data_fifo[0]     );
+	if( _core_if->data_fifo_dbg     != NULL) iounmap(_core_if->data_fifo_dbg    );
+
+#if 0
+	if (_core_if->wq_usb)
+		destroy_workqueue(_core_if->wq_usb);
+#endif
+	memset(_core_if, 0, sizeof(ltqusb_core_if_t));
+}
+
+
+
+
+/*!
+ \brief This function enbles the controller's Global Interrupt in the AHB Config register.
+ \param _core_if Pointer of core_if structure
+ */
+void ltqusb_enable_global_interrupts_h( ltqusb_core_if_t *_core_if )
+{
+	gahbcfg_data_t ahbcfg ={ .d32 = 0};
+	ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
+	ltqusb_mreg(&_core_if->core_global_regs->gahbcfg, 0, ahbcfg.d32);
+}
+
+/*!
+ \brief This function disables the controller's Global Interrupt in the AHB Config register.
+ \param _core_if Pointer of core_if structure
+ */
+void ltqusb_disable_global_interrupts_h( ltqusb_core_if_t *_core_if )
+{
+	gahbcfg_data_t ahbcfg ={ .d32 = 0};
+	ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
+	ltqusb_mreg(&_core_if->core_global_regs->gahbcfg, ahbcfg.d32, 0);
+}
+
+
+
+
+/*!
+ \brief Flush Tx and Rx FIFO.
+ \param _core_if Pointer of core_if structure
+ */
+void ltqusb_flush_both_fifo_h( ltqusb_core_if_t *_core_if )
+{
+	ltqusb_core_global_regs_t *global_regs = _core_if->core_global_regs;
+	volatile grstctl_t greset ={ .d32 = 0};
+	int count = 0;
+
+	LTQ_DEBUGPL((DBG_CIL|DBG_PCDV), "%s\n", __func__);
+	greset.b.rxfflsh = 1;
+	greset.b.txfflsh = 1;
+	greset.b.txfnum = 0x10;
+	greset.b.intknqflsh=1;
+	greset.b.hstfrm=1;
+	ltqusb_wreg( &global_regs->grstctl, greset.d32 );
+
+	do
+	{
+		greset.d32 = ltqusb_rreg( &global_regs->grstctl);
+		if (++count > 10000)
+		{
+			LTQ_WARN("%s() HANG! GRSTCTL=%0x\n", __func__, greset.d32);
+			break;
+		}
+	} while (greset.b.rxfflsh == 1 || greset.b.txfflsh == 1);
+	/* Wait for 3 PHY Clocks*/
+	UDELAY(1);
+}
+
+/*!
+ \brief Flush a Tx FIFO.
+ \param _core_if Pointer of core_if structure
+ \param _num Tx FIFO to flush. ( 0x10 for ALL TX FIFO )
+ */
+void ltqusb_flush_tx_fifo_h( ltqusb_core_if_t *_core_if, const int _num )
+{
+	ltqusb_core_global_regs_t *global_regs = _core_if->core_global_regs;
+	volatile grstctl_t greset ={ .d32 = 0};
+	int count = 0;
+
+	LTQ_DEBUGPL((DBG_CIL|DBG_PCDV), "Flush Tx FIFO %d\n", _num);
+
+	greset.b.intknqflsh=1;
+	greset.b.txfflsh = 1;
+	greset.b.txfnum = _num;
+	ltqusb_wreg( &global_regs->grstctl, greset.d32 );
+
+	do
+	{
+		greset.d32 = ltqusb_rreg( &global_regs->grstctl);
+		if (++count > 10000&&(_num==0 ||_num==0x10))
+		{
+			LTQ_WARN("%s() HANG! GRSTCTL=%0x GNPTXSTS=0x%08x\n",
+			    __func__, greset.d32,
+			ltqusb_rreg( &global_regs->gnptxsts));
+			break;
+		}
+	} while (greset.b.txfflsh == 1);
+	/* Wait for 3 PHY Clocks*/
+	UDELAY(1);
+}
+
+
+/*!
+ \brief Flush Rx FIFO.
+ \param _core_if Pointer of core_if structure
+ */
+void ltqusb_flush_rx_fifo_h( ltqusb_core_if_t *_core_if )
+{
+	ltqusb_core_global_regs_t *global_regs = _core_if->core_global_regs;
+	volatile grstctl_t greset ={ .d32 = 0};
+	int count = 0;
+
+	LTQ_DEBUGPL((DBG_CIL|DBG_PCDV), "%s\n", __func__);
+	greset.b.rxfflsh = 1;
+	ltqusb_wreg( &global_regs->grstctl, greset.d32 );
+
+	do
+	{
+		greset.d32 = ltqusb_rreg( &global_regs->grstctl);
+		if (++count > 10000)
+		{
+			LTQ_WARN("%s() HANG! GRSTCTL=%0x\n", __func__, greset.d32);
+			break;
+		}
+	} while (greset.b.rxfflsh == 1);
+	/* Wait for 3 PHY Clocks*/
+	UDELAY(1);
+}
+
+
+#define SOFT_RESET_DELAY 100 /*!< Delay in msec of detection after soft-reset of usb core */
+
+/*!
+ \brief Do a soft reset of the core.  Be careful with this because it
+        resets all the internal state machines of the core.
+ \param _core_if Pointer of core_if structure
+ */
+int ltqusb_core_soft_reset_h(ltqusb_core_if_t *_core_if)
+{
+	ltqusb_core_global_regs_t *global_regs = _core_if->core_global_regs;
+	volatile grstctl_t greset ={ .d32 = 0};
+	int count = 0;
+
+	LTQ_DEBUGPL(DBG_CILV, "%s\n", __func__);
+	/* Wait for AHB master IDLE state. */
+	do
+	{
+		UDELAY(10);
+		greset.d32 = ltqusb_rreg( &global_regs->grstctl);
+		if (++count > 100000)
+		{
+			LTQ_WARN("%s() HANG! AHB Idle GRSTCTL=%0x %x\n", __func__,
+			greset.d32, greset.b.ahbidle);
+			break;
+		}
+	} while (greset.b.ahbidle == 0);
+
+	UDELAY(1);
+
+	/* Core Soft Reset */
+	count = 0;
+	greset.b.csftrst = 1;
+	ltqusb_wreg( &global_regs->grstctl, greset.d32 );
+
+	#ifdef SOFT_RESET_DELAY
+		MDELAY(SOFT_RESET_DELAY);
+	#endif
+
+	do
+	{
+		UDELAY(10);
+		greset.d32 = ltqusb_rreg( &global_regs->grstctl);
+		if (++count > 100000)
+		{
+			LTQ_WARN("%s() HANG! Soft Reset GRSTCTL=%0x\n", __func__, greset.d32);
+			return -1;
+		}
+	} while (greset.b.csftrst == 1);
+
+	#ifdef SOFT_RESET_DELAY
+		MDELAY(SOFT_RESET_DELAY);
+	#endif
+
+	// This is to reset the PHY of VR9
+	if(ltqusb_chip_family== LTQUSB_CHIP_VR9)
+	{
+		if(_core_if->core_no==0)
+		{
+			set_bit (4, VR9_RCU_USBRESET2);
+			MDELAY(50);
+			clear_bit (4, VR9_RCU_USBRESET2);
+		}
+		else
+		{
+			set_bit (5, VR9_RCU_USBRESET2);
+			MDELAY(50);
+			clear_bit (5, VR9_RCU_USBRESET2);
+		}
+		MDELAY(50);
+	}
+
+	LTQ_PRINT("USB core #%d soft-reset\n",_core_if->core_no);
+
+	return 0;
+}
+
+void USB_AHB_PMU_SETUP(int OnOff)
+{
+	struct clk *clk = NULL;
+	if     (ltqusb_chip_family== LTQUSB_CHIP_DANUBE)
+	{
+//		clk = clk_get_sys(NULL, "ahb");
+	}
+	else if(ltqusb_chip_family== LTQUSB_CHIP_ASE)
+	{
+//		clk = clk_get_sys(NULL, "ahb");
+	}
+	else if(ltqusb_chip_family== LTQUSB_CHIP_AR9)
+	{
+//		clk = clk_get_sys(NULL, "ahb");
+	}
+	else if(ltqusb_chip_family== LTQUSB_CHIP_VR9)
+	{
+		clk = clk_get_sys(NULL, "ahb");
+	}
+	else if(ltqusb_chip_family== LTQUSB_CHIP_AR10)
+	{
+//		clk = clk_get_sys(NULL, "ahb");
+	}
+	if (clk && !IS_ERR(clk))
+		clk_enable(clk);// Enable only
+}
+
+void USB_CTRL_PMU_SETUP(int core,int OnOff)
+{
+	struct clk *clk = NULL;
+	switch(ltqusb_chip_family)
+	{
+		case LTQUSB_CHIP_DANUBE:
+		case LTQUSB_CHIP_ASE:
+			clk = clk_get_sys("1e101000.usb", "ctl");
+			if (!clk || IS_ERR(clk))
+				clk = clk_get_sys("1e101000.ltqhcd", "ctl");
+			if (!clk || IS_ERR(clk))
+				clk = clk_get_sys("1e101000.ifxhcd", "ctl");
+			break;
+		case LTQUSB_CHIP_AR9:
+		case LTQUSB_CHIP_VR9:
+		case LTQUSB_CHIP_AR10:
+			if(core==0)
+			{
+				clk = clk_get_sys("1e101000.usb", "ctl");
+				if (!clk || IS_ERR(clk))
+					clk = clk_get_sys("1e101000.ltqhcd", "ctl");
+				if (!clk || IS_ERR(clk))
+					clk = clk_get_sys("1e101000.ifxhcd", "ctl");
+			}
+			else
+			{
+				clk = clk_get_sys("1e106000.usb", "ctl");
+				if (!clk || IS_ERR(clk))
+					clk = clk_get_sys("1e106000.ltqhcd", "ctl");
+				if (!clk || IS_ERR(clk))
+					clk = clk_get_sys("1e106000.ifxhcd1", "ctl");
+			}
+			break;
+		default:
+			clk=NULL;
+	}
+	if (clk && !IS_ERR(clk))
+	{
+		if(OnOff)
+			clk_enable(clk);
+		else
+			clk_disable(clk);
+	}
+}
+void USB_PHY_PMU_SETUP(int core,int OnOff)
+{
+	struct clk *clk = NULL;
+	switch(ltqusb_chip_family)
+	{
+		case LTQUSB_CHIP_DANUBE:
+		case LTQUSB_CHIP_ASE:
+			clk = clk_get_sys("1e101000.usb", "phy");
+			if (!clk || IS_ERR(clk))
+				clk = clk_get_sys("1e101000.ltqhcd", "phy");
+			if (!clk || IS_ERR(clk))
+				clk = clk_get_sys("1e101000.ifxhcd", "phy");
+			break;
+		case LTQUSB_CHIP_AR9:
+		case LTQUSB_CHIP_VR9:
+		case LTQUSB_CHIP_AR10:
+			if(core==0)
+			{
+				clk = clk_get_sys("1e101000.usb", "phy");
+				if (!clk || IS_ERR(clk))
+					clk = clk_get_sys("1e101000.ltqhcd", "phy");
+				if (!clk || IS_ERR(clk))
+					clk = clk_get_sys("1e101000.ifxhcd", "phy");
+			}
+			else
+			{
+				clk = clk_get_sys("1e106000.usb", "phy");
+				if (!clk || IS_ERR(clk))
+					clk = clk_get_sys("1e106000.ltqhcd", "phy");
+				if (!clk || IS_ERR(clk))
+					clk = clk_get_sys("1e106000.ifxhcd1", "phy");
+			}
+			break;
+		default:
+			clk=NULL;
+	}
+	if (clk && !IS_ERR(clk))
+	{
+		if(OnOff)
+			clk_enable(clk);
+		else
+			clk_disable(clk);
+	}
+}
+
+
+/*!
+ \brief Turn on the USB Core Power
+ \param _core_if Pointer of core_if structure
+*/
+void ltqusb_power_on_h (ltqusb_core_if_t *_core_if)
+{
+	LTQ_DEBUGPL(DBG_ENTRY, "%s() %d\n", __func__, __LINE__ );
+
+	// set clock gating
+	if(ltqusb_chip_family== LTQUSB_CHIP_AR9)
+	{
+		set_bit (0, (volatile unsigned long *)AR9_CGU_IFCCR);
+		set_bit (1, (volatile unsigned long *)AR9_CGU_IFCCR);
+	}
+
+	MDELAY(50);
+
+	// set power
+	USB_AHB_PMU_SETUP(1);
+	USB_CTRL_PMU_SETUP(_core_if->core_no,1);
+	MDELAY(50);
+
+	if(_core_if->pcgcctl)
+	{
+		pcgcctl_data_t pcgcctl = {.d32=0};
+		pcgcctl.b.gatehclk = 1;
+		ltqusb_mreg(_core_if->pcgcctl, pcgcctl.d32, 0);
+	}
+
+
+	if(_core_if->core_global_regs)
+	{
+		// PHY configurations.
+		if(ltqusb_chip_family== LTQUSB_CHIP_AR9)
+			ltqusb_wreg (&_core_if->core_global_regs->guid,0x14014);
+	}
+}
+
+/*!
+ \brief Turn off the USB Core Power
+ \param _core_if Pointer of core_if structure
+*/
+void ltqusb_power_off_h (ltqusb_core_if_t *_core_if)
+{
+	ltqusb_phy_power_off_h (_core_if);
+
+	// set power
+	if(_core_if->pcgcctl)
+	{
+		pcgcctl_data_t pcgcctl = {.d32=0};
+		pcgcctl.b.gatehclk = 1;
+		pcgcctl.b.stoppclk = 1;
+		ltqusb_mreg(_core_if->pcgcctl, 0, pcgcctl.d32);
+	}
+	USB_CTRL_PMU_SETUP(_core_if->core_no,0);
+}
+
+/*!
+ \brief Turn on the USB PHY Power
+ \param _core_if Pointer of core_if structure
+*/
+void ltqusb_phy_power_on_h (ltqusb_core_if_t *_core_if)
+{
+	if(_core_if->core_global_regs)
+	{
+		if(ltqusb_chip_family== LTQUSB_CHIP_AR9)
+			ltqusb_wreg (&_core_if->core_global_regs->guid,0x14014);
+
+		if     (ltqusb_chip_family== LTQUSB_CHIP_VR9
+		      ||ltqusb_chip_family== LTQUSB_CHIP_AR10
+		 )
+		{
+			volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+			if(ltqusb_chip_family== LTQUSB_CHIP_VR9)
+			{
+				if(_core_if->core_no==0)
+					rcu_ana_cfg1.d32=ltqusb_rreg(((volatile uint32_t *)VR9_RCU_USB_ANA_CFG1A));
+				else
+					rcu_ana_cfg1.d32=ltqusb_rreg(((volatile uint32_t *)VR9_RCU_USB_ANA_CFG1B));
+			}
+			if(ltqusb_chip_family== LTQUSB_CHIP_AR10)
+			{
+				if(_core_if->core_no==0)
+					rcu_ana_cfg1.d32=ltqusb_rreg(((volatile uint32_t *)AR10_RCU_USB_ANA_CFG1A));
+				else
+					rcu_ana_cfg1.d32=ltqusb_rreg(((volatile uint32_t *)AR10_RCU_USB_ANA_CFG1B));
+			}
+
+			if(_core_if->params.ana_disconnect_threshold >=0 && _core_if->params.ana_disconnect_threshold <=7)
+				rcu_ana_cfg1.b.dis_thr = _core_if->params.ana_disconnect_threshold ;
+			if(_core_if->params.ana_squelch_threshold >=0 && _core_if->params.ana_squelch_threshold <=7)
+				rcu_ana_cfg1.b.squs_thr = _core_if->params.ana_squelch_threshold ;
+			if(_core_if->params.ana_transmitter_crossover >=0 && _core_if->params.ana_transmitter_crossover <=3)
+				rcu_ana_cfg1.b.txhs_xv = _core_if->params.ana_transmitter_crossover ;
+			if(_core_if->params.ana_transmitter_impedance >=0 && _core_if->params.ana_transmitter_impedance <=15)
+				rcu_ana_cfg1.b.txsrci_xv = _core_if->params.ana_transmitter_impedance ;
+			if(_core_if->params.ana_transmitter_dc_voltage >=0 && _core_if->params.ana_transmitter_dc_voltage <=15)
+				rcu_ana_cfg1.b.txhs_dc = _core_if->params.ana_transmitter_dc_voltage ;
+			if(_core_if->params.ana_transmitter_risefall_time >=0 && _core_if->params.ana_transmitter_risefall_time <=1)
+				rcu_ana_cfg1.b.tx_edge = _core_if->params.ana_transmitter_risefall_time ;
+			if(_core_if->params.ana_transmitter_pre_emphasis >=0 && _core_if->params.ana_transmitter_pre_emphasis <=1)
+				rcu_ana_cfg1.b.tx_pee = _core_if->params.ana_transmitter_pre_emphasis ;
+
+			if(ltqusb_chip_family== LTQUSB_CHIP_VR9)
+			{
+				if(_core_if->core_no==0)
+					ltqusb_wreg(((volatile uint32_t *)VR9_RCU_USB_ANA_CFG1A),rcu_ana_cfg1.d32);
+				else
+					ltqusb_wreg(((volatile uint32_t *)VR9_RCU_USB_ANA_CFG1B),rcu_ana_cfg1.d32);
+			}
+			if(ltqusb_chip_family== LTQUSB_CHIP_AR10)
+			{
+				if(_core_if->core_no==0)
+					ltqusb_wreg(((volatile uint32_t *)AR10_RCU_USB_ANA_CFG1A),rcu_ana_cfg1.d32);
+				else
+					ltqusb_wreg(((volatile uint32_t *)AR10_RCU_USB_ANA_CFG1B),rcu_ana_cfg1.d32);
+			}
+		}
+
+		if(_core_if->pcgcctl)
+		{
+			pcgcctl_data_t pcgcctl = {.d32=0};
+			pcgcctl.b.stoppclk = 1;
+			ltqusb_mreg(_core_if->pcgcctl, pcgcctl.d32, 0);
+		}
+	}
+
+	USB_PHY_PMU_SETUP(_core_if->core_no,1);
+
+	if(ltqusb_chip_family== LTQUSB_CHIP_AR9)
+		if(_core_if->core_global_regs)
+			ltqusb_wreg (&_core_if->core_global_regs->guid,0x14014);
+}
+
+
+/*!
+ \brief Turn off the USB PHY Power
+ \param _core_if Pointer of core_if structure
+*/
+void ltqusb_phy_power_off_h (ltqusb_core_if_t *_core_if)
+{
+	if(_core_if->pcgcctl)
+	{
+		pcgcctl_data_t pcgcctl = {.d32=0};
+		pcgcctl.b.stoppclk = 1;
+		ltqusb_mreg(_core_if->pcgcctl, 0, pcgcctl.d32);
+	}
+	USB_PHY_PMU_SETUP(_core_if->core_no,0);
+}
+
+
+/*!
+ \brief Reset on the USB Core RCU
+ \param _core_if Pointer of core_if structure
+ */
+static int CheckAlready(void)
+{
+	gusbcfg_data_t usbcfg   ={.d32 = 0};
+
+	if     (ltqusb_chip_family== LTQUSB_CHIP_VR9
+	      ||ltqusb_chip_family== LTQUSB_CHIP_AR10
+	 )
+	{
+		usbcfg.d32 = ltqusb_rreg((volatile uint32_t *)0xBE10100C);
+		if(usbcfg.b.ForceDevMode)
+			return 1;
+		if(usbcfg.b.ForceHstMode)
+			return 1;
+		usbcfg.d32 = ltqusb_rreg((volatile uint32_t *)0xBE10600C);
+		if(usbcfg.b.ForceDevMode)
+			return 1;
+		if(usbcfg.b.ForceHstMode)
+			return 1;
+		return 0;
+	}
+	return 1;
+}
+
+void ltqusb_hard_reset_h(ltqusb_core_if_t *_core_if)
+{
+	if     (ltqusb_chip_family== LTQUSB_CHIP_AR9 )
+	{
+		if(_core_if->core_no==0)
+		{
+			clear_bit (AR9_USBCFG_HDSEL_BIT, (volatile unsigned long *)AR9_RCU_USB1CFG);
+		}
+		else
+		{
+			clear_bit (AR9_USBCFG_HDSEL_BIT, (volatile unsigned long *)AR9_RCU_USB2CFG);
+		}
+	}
+	else if(ltqusb_chip_family== LTQUSB_CHIP_VR9 )
+	{
+//		if(!CheckAlready())
+		{
+			if      (ltqusb_hcd_1.core_if.irq && ltqusb_hcd_2.core_if.irq)
+			{
+				clear_bit (VR9_USBCFG_HDSEL_BIT, (volatile unsigned long *)VR9_RCU_USB1CFG);
+				clear_bit (VR9_USBCFG_HDSEL_BIT, (volatile unsigned long *)VR9_RCU_USB2CFG);
+			}
+			else if(ltqusb_hcd_1.core_if.irq)
+			{
+				clear_bit (VR9_USBCFG_HDSEL_BIT, (volatile unsigned long *)VR9_RCU_USB1CFG);
+				set_bit (VR9_USBCFG_HDSEL_BIT, (volatile unsigned long *)VR9_RCU_USB2CFG);
+			}
+			else if(ltqusb_hcd_2.core_if.irq)
+			{
+				set_bit (VR9_USBCFG_HDSEL_BIT, (volatile unsigned long *)VR9_RCU_USB1CFG);
+				clear_bit (VR9_USBCFG_HDSEL_BIT, (volatile unsigned long *)VR9_RCU_USB2CFG);
+			}
+		}
+	}
+	else if(ltqusb_chip_family== LTQUSB_CHIP_AR10 )
+	{
+//		if(!CheckAlready())
+		{
+			if      (ltqusb_hcd_1.core_if.irq && ltqusb_hcd_2.core_if.irq)
+			{
+				clear_bit (AR10_USBCFG_HDSEL_BIT, (volatile unsigned long *)AR10_RCU_USB1CFG);
+				clear_bit (AR10_USBCFG_HDSEL_BIT, (volatile unsigned long *)AR10_RCU_USB2CFG);
+			}
+			else if(ltqusb_hcd_1.core_if.irq)
+			{
+				clear_bit (AR10_USBCFG_HDSEL_BIT, (volatile unsigned long *)AR10_RCU_USB1CFG);
+				set_bit (AR10_USBCFG_HDSEL_BIT, (volatile unsigned long *)AR10_RCU_USB2CFG);
+			}
+			else if(ltqusb_hcd_2.core_if.irq)
+			{
+				set_bit (AR10_USBCFG_HDSEL_BIT, (volatile unsigned long *)AR10_RCU_USB1CFG);
+				clear_bit (AR10_USBCFG_HDSEL_BIT, (volatile unsigned long *)AR10_RCU_USB2CFG);
+			}
+		}
+	}
+
+	// set the HC's byte-order to big-endian
+	if     (ltqusb_chip_family== LTQUSB_CHIP_AR9 )
+	{
+		if(_core_if->core_no==0)
+		{
+			set_bit   (AR9_USBCFG_HOST_END_BIT, (volatile unsigned long *)AR9_RCU_USB1CFG);
+			clear_bit (AR9_USBCFG_SLV_END_BIT, (volatile unsigned long *)AR9_RCU_USB1CFG);
+		}
+		else
+		{
+			set_bit   (AR9_USBCFG_HOST_END_BIT, (volatile unsigned long *)AR9_RCU_USB2CFG);
+			clear_bit (AR9_USBCFG_SLV_END_BIT, (volatile unsigned long *)AR9_RCU_USB2CFG);
+		}
+	}
+	else if(ltqusb_chip_family== LTQUSB_CHIP_VR9 )
+	{
+		if(_core_if->core_no==0)
+		{
+			set_bit   (VR9_USBCFG_HOST_END_BIT, (volatile unsigned long *)VR9_RCU_USB1CFG);
+			clear_bit (VR9_USBCFG_SLV_END_BIT, (volatile unsigned long *)VR9_RCU_USB1CFG);
+		}
+		else
+		{
+			set_bit   (VR9_USBCFG_HOST_END_BIT, (volatile unsigned long *)VR9_RCU_USB2CFG);
+			clear_bit (VR9_USBCFG_SLV_END_BIT, (volatile unsigned long *)VR9_RCU_USB2CFG);
+		}
+	}
+	else if(ltqusb_chip_family== LTQUSB_CHIP_AR10 )
+	{
+		if(_core_if->core_no==0)
+		{
+			set_bit   (AR10_USBCFG_HOST_END_BIT, (volatile unsigned long *)AR10_RCU_USB1CFG);
+			clear_bit (AR10_USBCFG_SLV_END_BIT, (volatile unsigned long *)AR10_RCU_USB1CFG);
+		}
+		else
+		{
+			set_bit   (AR10_USBCFG_HOST_END_BIT, (volatile unsigned long *)AR10_RCU_USB2CFG);
+			clear_bit (AR10_USBCFG_SLV_END_BIT, (volatile unsigned long *)AR10_RCU_USB2CFG);
+		}
+	}
+
+	if(ltqusb_chip_family== LTQUSB_CHIP_AR9 )
+	{
+		if(_core_if->core_no==0)
+		{
+			set_bit (4, AR9_RCU_USBRESET);
+			MDELAY(50);
+			clear_bit (4, AR9_RCU_USBRESET);
+		}
+		else
+		{
+			set_bit (28, AR9_RCU_USBRESET);
+			MDELAY(50);
+			clear_bit (28, AR9_RCU_USBRESET);
+		}
+		MDELAY(50);
+	}
+	else if(ltqusb_chip_family== LTQUSB_CHIP_VR9 )
+	{
+		if(!CheckAlready())
+		{
+			set_bit (4, VR9_RCU_USBRESET);
+			MDELAY(50);
+			clear_bit (4, VR9_RCU_USBRESET);
+			MDELAY(50);
+		}
+	}
+	else if(ltqusb_chip_family== LTQUSB_CHIP_AR10 )
+	{
+		if(!CheckAlready())
+		{
+			set_bit (4, AR10_RCU_USBRESET);
+			MDELAY(50);
+			clear_bit (4, AR10_RCU_USBRESET);
+			MDELAY(50);
+		}
+	}
+
+	if(_core_if->core_global_regs)
+	{
+		// PHY configurations.
+		if(ltqusb_chip_family== LTQUSB_CHIP_AR9 )
+			ltqusb_wreg (&_core_if->core_global_regs->guid,0x14014);
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////
+void ltqusb_led_init(ltqhcd_hcd_t *_ltqhcd)
+{
+	if(_ltqhcd->ledgpioid<0)
+		return;
+	if(ltqusb_led_shared)
+	{
+		if(ltqusb_hcd_1.ledgpioinstalled||ltqusb_hcd_2.ledgpioinstalled)
+		{
+			ltqusb_hcd_1.ledgpioinstalled=ltqusb_hcd_2.ledgpioinstalled=1;
+		}
+		else
+		{
+			if(devm_gpio_request(_ltqhcd->dev, _ltqhcd->ledgpioid,"USBLED")==0)
+			{
+				gpio_direction_output(_ltqhcd->ledgpioid,1);
+				ltqusb_hcd_1.ledgpioinstalled=ltqusb_hcd_2.ledgpioinstalled=1;
+			}
+		}
+	}
+	else if(_ltqhcd->core_if.core_no==0)
+	{
+		if(!_ltqhcd->ledgpioinstalled)
+		{
+			if(devm_gpio_request(_ltqhcd->dev, _ltqhcd->ledgpioid,"USBLED1")==0)
+			{
+				gpio_direction_output(_ltqhcd->ledgpioid,1);
+				_ltqhcd->ledgpioinstalled=1;
+			}
+		}
+	}
+	else
+	{
+		if(!_ltqhcd->ledgpioinstalled)
+		{
+			if(devm_gpio_request(_ltqhcd->dev, _ltqhcd->ledgpioid,"USBLED2")==0)
+			{
+				gpio_direction_output(_ltqhcd->ledgpioid,1);
+				_ltqhcd->ledgpioinstalled=1;
+			}
+		}
+	}
+}
+
+
+void ltqusb_led_free(ltqhcd_hcd_t *_ltqhcd)
+{
+	if(_ltqhcd->ledgpioid<0)
+		return;
+	if(ltqusb_led_shared)
+	{
+		if(ltqusb_hcd_1.ledgpioinstalled||ltqusb_hcd_2.ledgpioinstalled)
+		{
+			devm_gpio_free(_ltqhcd->dev, _ltqhcd->ledgpioid);
+			ltqusb_hcd_1.ledgpioinstalled=ltqusb_hcd_2.ledgpioinstalled=0;
+		}
+	}
+	else
+	{
+		if(_ltqhcd->ledgpioinstalled)
+		{
+			devm_gpio_free(_ltqhcd->dev, _ltqhcd->ledgpioid);
+			_ltqhcd->ledgpioinstalled=0;
+		}
+	}
+}
+
+/*!
+   \brief Turn off the USB LED
+   \param _core_if        Pointer of core_if structure
+ */
+void ltqusb_led(ltqhcd_hcd_t *_ltqhcd)
+{
+	if(_ltqhcd->ledgpioid<0)
+		return;
+	if(_ltqhcd->ledgpioinstalled)
+	{
+		if(_ltqhcd->ledgpiostatus)
+		{
+			__gpio_set_value(_ltqhcd->ledgpioid,1);
+			if(ltqusb_led_shared)
+				ltqusb_hcd_1.ledgpiostatus=ltqusb_hcd_2.ledgpiostatus=0;
+			else
+				_ltqhcd->ledgpiostatus=0;
+		}
+		else
+		{
+			__gpio_set_value(_ltqhcd->ledgpioid,0);
+			if(ltqusb_led_shared)
+				ltqusb_hcd_1.ledgpiostatus=ltqusb_hcd_2.ledgpiostatus=1;
+			else
+				_ltqhcd->ledgpiostatus=1;
+		}
+	}
+}
+/////////////////////////////////////////////////////////////////////////
+
+
+//#define __VERBOSE_DUMP__
+/*!
+ \brief internal routines for debugging
+ */
+void ltqusb_dump_msg_h(const u8 *buf, unsigned int length)
+{
+#ifdef __DEBUG__
+	unsigned int	start, num, i;
+	char		line[52], *p;
+
+	if (length >= 512)
+		return;
+	start = 0;
+	while (length > 0)
+	{
+		num = min(length, 16u);
+		p = line;
+		for (i = 0; i < num; ++i)
+		{
+			if (i == 8)
+				*p++ = ' ';
+			sprintf(p, " %02x", buf[i]);
+			p += 3;
+		}
+		*p = 0;
+		LTQ_PRINT( "%6x: %s\n", start, line);
+		buf += num;
+		start += num;
+		length -= num;
+	}
+#endif
+}
+
+/*!
+ \brief internal routines for debugging, reads the SPRAM and prints its content
+ */
+void ltqusb_dump_spram_h(ltqusb_core_if_t *_core_if)
+{
+#ifdef __ENABLE_DUMP__
+	volatile uint8_t *addr, *start_addr, *end_addr;
+	uint32_t size;
+	LTQ_PRINT("SPRAM Data:\n");
+	start_addr = (void*)_core_if->core_global_regs;
+	LTQ_PRINT("Base Address: 0x%8X\n", (uint32_t)start_addr);
+
+	start_addr = (void*)_core_if->data_fifo_dbg;
+	LTQ_PRINT("Starting Address: 0x%8X\n", (uint32_t)start_addr);
+
+	size=_core_if->hwcfg3.b.dfifo_depth;
+	size<<=2;
+	size+=0x200;
+	size&=0x0003FFFC;
+
+	end_addr = (void*)_core_if->data_fifo_dbg;
+	end_addr += size;
+
+	for(addr = start_addr; addr < end_addr; addr+=16)
+	{
+		LTQ_PRINT("0x%8X:  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X  %02X \n", (uint32_t)addr,
+			addr[ 0], addr[ 1], addr[ 2], addr[ 3],
+			addr[ 4], addr[ 5], addr[ 6], addr[ 7],
+			addr[ 8], addr[ 9], addr[10], addr[11],
+			addr[12], addr[13], addr[14], addr[15]
+			);
+	}
+	return;
+#endif //__ENABLE_DUMP__
+}
+
+
+/*!
+ \brief internal routines for debugging, reads the core global registers and prints them
+ */
+void ltqusb_dump_registers_h(ltqusb_core_if_t *_core_if)
+{
+#ifdef __ENABLE_DUMP__
+	int i;
+	volatile uint32_t *addr;
+
+	LTQ_PRINT("Core #%d\n",_core_if->core_no);
+	LTQ_PRINT("========================================\n");
+	LTQ_PRINT("Core Global Registers\n");
+	{
+		gotgctl_data_t gotgctl;
+		addr=&_core_if->core_global_regs->gotgctl;
+		gotgctl.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GOTGCTL   @0x%08X : 0x%08X\n",(uint32_t)addr,gotgctl.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            currmod       : %x\n",gotgctl.b.currmod);
+		LTQ_PRINT("            bsesvld       : %x\n",gotgctl.b.bsesvld);
+		LTQ_PRINT("            asesvld       : %x\n",gotgctl.b.asesvld);
+		LTQ_PRINT("            conidsts      : %x\n",gotgctl.b.conidsts);
+		LTQ_PRINT("            devhnpen      : %x\n",gotgctl.b.devhnpen);
+		LTQ_PRINT("            hstsethnpen   : %x\n",gotgctl.b.hstsethnpen);
+		LTQ_PRINT("            hnpreq        : %x\n",gotgctl.b.hnpreq);
+		LTQ_PRINT("            hstnegscs     : %x\n",gotgctl.b.hstnegscs);
+		LTQ_PRINT("            sesreq        : %x\n",gotgctl.b.sesreq);
+		LTQ_PRINT("            sesreqscs     : %x\n",gotgctl.b.sesreqscs);
+		#endif // __VERBOSE_DUMP__
+	}
+	{
+		gotgint_data_t gotgint;
+		addr=&_core_if->core_global_regs->gotgint;
+		gotgint.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GOTGINT   @0x%08X : 0x%08X\n",(uint32_t)addr,gotgint.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            debdone           : %x\n",gotgint.b.debdone);
+		LTQ_PRINT("            adevtoutchng      : %x\n",gotgint.b.adevtoutchng);
+		LTQ_PRINT("            hstnegdet         : %x\n",gotgint.b.hstnegdet);
+		LTQ_PRINT("            hstnegsucstschng  : %x\n",gotgint.b.hstnegsucstschng);
+		LTQ_PRINT("            sesreqsucstschng  : %x\n",gotgint.b.sesreqsucstschng);
+		LTQ_PRINT("            sesenddet         : %x\n",gotgint.b.sesenddet);
+		#endif // __VERBOSE_DUMP__
+	}
+	{
+		gahbcfg_data_t gahbcfg;
+		addr=&_core_if->core_global_regs->gahbcfg;
+		gahbcfg.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GAHBCFG   @0x%08X : 0x%08X\n",(uint32_t)addr,gahbcfg.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            ptxfemplvl        : %x\n",gahbcfg.b.ptxfemplvl);
+		LTQ_PRINT("            nptxfemplvl       : %x\n",gahbcfg.b.nptxfemplvl);
+		LTQ_PRINT("            dmaenable         : %x\n",gahbcfg.b.dmaenable);
+		LTQ_PRINT("            hburstlen         : %x\n",gahbcfg.b.hburstlen);
+		LTQ_PRINT("            glblintrmsk       : %x\n",gahbcfg.b.glblintrmsk);
+		#endif // __VERBOSE_DUMP__
+	}
+	{
+		gusbcfg_data_t gusbcfg;
+		addr=&_core_if->core_global_regs->gusbcfg;
+		gusbcfg.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GUSBCFG   @0x%08X : 0x%08X\n",(uint32_t)addr,gusbcfg.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            ForceDevMode            : %x\n",gusbcfg.b.ForceDevMode);
+		LTQ_PRINT("            ForceHstMode            : %x\n",gusbcfg.b.ForceHstMode);
+		LTQ_PRINT("            TxEndDelay              : %x\n",gusbcfg.b.TxEndDelay);
+		LTQ_PRINT("            term_sel_dl_pulse       : %x\n",gusbcfg.b.term_sel_dl_pulse);
+		LTQ_PRINT("            otgutmifssel            : %x\n",gusbcfg.b.otgutmifssel);
+		LTQ_PRINT("            phylpwrclksel           : %x\n",gusbcfg.b.phylpwrclksel);
+		LTQ_PRINT("            usbtrdtim               : %x\n",gusbcfg.b.usbtrdtim);
+		LTQ_PRINT("            hnpcap                  : %x\n",gusbcfg.b.hnpcap);
+		LTQ_PRINT("            srpcap                  : %x\n",gusbcfg.b.srpcap);
+		LTQ_PRINT("            physel                  : %x\n",gusbcfg.b.physel);
+		LTQ_PRINT("            fsintf                  : %x\n",gusbcfg.b.fsintf);
+		LTQ_PRINT("            ulpi_utmi_sel           : %x\n",gusbcfg.b.ulpi_utmi_sel);
+		LTQ_PRINT("            phyif                   : %x\n",gusbcfg.b.phyif);
+		LTQ_PRINT("            toutcal                 : %x\n",gusbcfg.b.toutcal);
+		#endif // __VERBOSE_DUMP__
+	}
+	{
+		grstctl_t grstctl;
+		addr=&_core_if->core_global_regs->grstctl;
+		grstctl.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GRSTCTL   @0x%08X : 0x%08X\n",(uint32_t)addr,grstctl.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            ahbidle         : %x\n",grstctl.b.ahbidle);
+		LTQ_PRINT("            dmareq          : %x\n",grstctl.b.dmareq);
+		LTQ_PRINT("            txfnum          : %x\n",grstctl.b.txfnum);
+		LTQ_PRINT("            txfflsh         : %x\n",grstctl.b.txfflsh);
+		LTQ_PRINT("            rxfflsh         : %x\n",grstctl.b.rxfflsh);
+		LTQ_PRINT("            intknqflsh      : %x\n",grstctl.b.intknqflsh);
+		LTQ_PRINT("            hstfrm          : %x\n",grstctl.b.hstfrm);
+		LTQ_PRINT("            hsftrst         : %x\n",grstctl.b.hsftrst);
+		LTQ_PRINT("            csftrst         : %x\n",grstctl.b.csftrst);
+		#endif // __VERBOSE_DUMP__
+	}
+	{
+		gint_data_t gint;
+		addr=&_core_if->core_global_regs->gintsts;
+		gint.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GINTSTS   @0x%08X : 0x%08X\n",(uint32_t)addr,gint.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            wkupintr      : %x\n",gint.b.wkupintr);
+		LTQ_PRINT("            sessreqintr   : %x\n",gint.b.sessreqintr);
+		LTQ_PRINT("            disconnect    : %x\n",gint.b.disconnect);
+		LTQ_PRINT("            conidstschng  : %x\n",gint.b.conidstschng);
+		LTQ_PRINT("            ptxfempty     : %x\n",gint.b.ptxfempty);
+		LTQ_PRINT("            hcintr        : %x\n",gint.b.hcintr);
+		LTQ_PRINT("            portintr      : %x\n",gint.b.portintr);
+		LTQ_PRINT("            fetsuspmsk    : %x\n",gint.b.fetsuspmsk);
+		LTQ_PRINT("            incomplisoout : %x\n",gint.b.incomplisoout);
+		LTQ_PRINT("            incomplisoin  : %x\n",gint.b.incomplisoin);
+		LTQ_PRINT("            outepintr     : %x\n",gint.b.outepintr);
+		LTQ_PRINT("            inepintr      : %x\n",gint.b.inepintr);
+		LTQ_PRINT("            epmismatch    : %x\n",gint.b.epmismatch);
+		LTQ_PRINT("            eopframe      : %x\n",gint.b.eopframe);
+		LTQ_PRINT("            isooutdrop    : %x\n",gint.b.isooutdrop);
+		LTQ_PRINT("            enumdone      : %x\n",gint.b.enumdone);
+		LTQ_PRINT("            usbreset      : %x\n",gint.b.usbreset);
+		LTQ_PRINT("            usbsuspend    : %x\n",gint.b.usbsuspend);
+		LTQ_PRINT("            erlysuspend   : %x\n",gint.b.erlysuspend);
+		LTQ_PRINT("            i2cintr       : %x\n",gint.b.i2cintr);
+		LTQ_PRINT("            goutnakeff    : %x\n",gint.b.goutnakeff);
+		LTQ_PRINT("            ginnakeff     : %x\n",gint.b.ginnakeff);
+		LTQ_PRINT("            nptxfempty    : %x\n",gint.b.nptxfempty);
+		LTQ_PRINT("            rxstsqlvl     : %x\n",gint.b.rxstsqlvl);
+		LTQ_PRINT("            sofintr       : %x\n",gint.b.sofintr);
+		LTQ_PRINT("            otgintr       : %x\n",gint.b.otgintr);
+		LTQ_PRINT("            modemismatch  : %x\n",gint.b.modemismatch);
+		#endif // __VERBOSE_DUMP__
+		addr=&_core_if->core_global_regs->gintmsk;
+		gint.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GINTMSK   @0x%08X : 0x%08X\n",(uint32_t)addr,gint.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            wkupintr      : %x\n",gint.b.wkupintr);
+		LTQ_PRINT("            sessreqintr   : %x\n",gint.b.sessreqintr);
+		LTQ_PRINT("            disconnect    : %x\n",gint.b.disconnect);
+		LTQ_PRINT("            conidstschng  : %x\n",gint.b.conidstschng);
+		LTQ_PRINT("            ptxfempty     : %x\n",gint.b.ptxfempty);
+		LTQ_PRINT("            hcintr        : %x\n",gint.b.hcintr);
+		LTQ_PRINT("            portintr      : %x\n",gint.b.portintr);
+		LTQ_PRINT("            fetsuspmsk    : %x\n",gint.b.fetsuspmsk);
+		LTQ_PRINT("            incomplisoout : %x\n",gint.b.incomplisoout);
+		LTQ_PRINT("            incomplisoin  : %x\n",gint.b.incomplisoin);
+		LTQ_PRINT("            outepintr     : %x\n",gint.b.outepintr);
+		LTQ_PRINT("            inepintr      : %x\n",gint.b.inepintr);
+		LTQ_PRINT("            epmismatch    : %x\n",gint.b.epmismatch);
+		LTQ_PRINT("            eopframe      : %x\n",gint.b.eopframe);
+		LTQ_PRINT("            isooutdrop    : %x\n",gint.b.isooutdrop);
+		LTQ_PRINT("            enumdone      : %x\n",gint.b.enumdone);
+		LTQ_PRINT("            usbreset      : %x\n",gint.b.usbreset);
+		LTQ_PRINT("            usbsuspend    : %x\n",gint.b.usbsuspend);
+		LTQ_PRINT("            erlysuspend   : %x\n",gint.b.erlysuspend);
+		LTQ_PRINT("            i2cintr       : %x\n",gint.b.i2cintr);
+		LTQ_PRINT("            goutnakeff    : %x\n",gint.b.goutnakeff);
+		LTQ_PRINT("            ginnakeff     : %x\n",gint.b.ginnakeff);
+		LTQ_PRINT("            nptxfempty    : %x\n",gint.b.nptxfempty);
+		LTQ_PRINT("            rxstsqlvl     : %x\n",gint.b.rxstsqlvl);
+		LTQ_PRINT("            sofintr       : %x\n",gint.b.sofintr);
+		LTQ_PRINT("            otgintr       : %x\n",gint.b.otgintr);
+		LTQ_PRINT("            modemismatch  : %x\n",gint.b.modemismatch);
+		#endif // __VERBOSE_DUMP__
+	}
+	{
+		gi2cctl_data_t gi2cctl;
+		addr=&_core_if->core_global_regs->gi2cctl;
+		gi2cctl.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GI2CCTL   @0x%08X : 0x%08X\n",(uint32_t)addr,gi2cctl.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            bsydne     : %x\n",gi2cctl.b.bsydne);
+		LTQ_PRINT("            rw         : %x\n",gi2cctl.b.rw);
+		LTQ_PRINT("            i2cdevaddr : %x\n",gi2cctl.b.i2cdevaddr);
+		LTQ_PRINT("            i2csuspctl : %x\n",gi2cctl.b.i2csuspctl);
+		LTQ_PRINT("            ack        : %x\n",gi2cctl.b.ack);
+		LTQ_PRINT("            i2cen      : %x\n",gi2cctl.b.i2cen);
+		LTQ_PRINT("            addr       : %x\n",gi2cctl.b.addr);
+		LTQ_PRINT("            regaddr    : %x\n",gi2cctl.b.regaddr);
+		LTQ_PRINT("            rwdata     : %x\n",gi2cctl.b.rwdata);
+		#endif // __VERBOSE_DUMP__
+	}
+	addr=&_core_if->core_global_regs->gpvndctl;
+	LTQ_PRINT("  GPVNDCTL  @0x%08X : 0x%08X\n",(uint32_t)addr,ltqusb_rreg(addr));
+	addr=&_core_if->core_global_regs->ggpio;
+	LTQ_PRINT("  GGPIO     @0x%08X : 0x%08X\n",(uint32_t)addr,ltqusb_rreg(addr));
+	addr=&_core_if->core_global_regs->guid;
+	LTQ_PRINT("  GUID      @0x%08X : 0x%08X\n",(uint32_t)addr,ltqusb_rreg(addr));
+	addr=&_core_if->core_global_regs->gsnpsid;
+	LTQ_PRINT("  GSNPSID   @0x%08X : 0x%08X\n",(uint32_t)addr,ltqusb_rreg(addr));
+	{
+		hwcfg1_data_t hwcfg1;
+		addr=&_core_if->core_global_regs->ghwcfg1;
+		hwcfg1.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GHWCFG1   @0x%08X : 0x%08X\n",(uint32_t)addr,hwcfg1.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            ep_dir15 : %x\n",hwcfg1.b.ep_dir15);
+		LTQ_PRINT("            ep_dir14 : %x\n",hwcfg1.b.ep_dir14);
+		LTQ_PRINT("            ep_dir13 : %x\n",hwcfg1.b.ep_dir13);
+		LTQ_PRINT("            ep_dir12 : %x\n",hwcfg1.b.ep_dir12);
+		LTQ_PRINT("            ep_dir11 : %x\n",hwcfg1.b.ep_dir11);
+		LTQ_PRINT("            ep_dir10 : %x\n",hwcfg1.b.ep_dir10);
+		LTQ_PRINT("            ep_dir09 : %x\n",hwcfg1.b.ep_dir09);
+		LTQ_PRINT("            ep_dir08 : %x\n",hwcfg1.b.ep_dir08);
+		LTQ_PRINT("            ep_dir07 : %x\n",hwcfg1.b.ep_dir07);
+		LTQ_PRINT("            ep_dir06 : %x\n",hwcfg1.b.ep_dir06);
+		LTQ_PRINT("            ep_dir05 : %x\n",hwcfg1.b.ep_dir05);
+		LTQ_PRINT("            ep_dir04 : %x\n",hwcfg1.b.ep_dir04);
+		LTQ_PRINT("            ep_dir03 : %x\n",hwcfg1.b.ep_dir03);
+		LTQ_PRINT("            ep_dir02 : %x\n",hwcfg1.b.ep_dir02);
+		LTQ_PRINT("            ep_dir01 : %x\n",hwcfg1.b.ep_dir01);
+		LTQ_PRINT("            ep_dir00 : %x\n",hwcfg1.b.ep_dir00);
+		#endif // __VERBOSE_DUMP__
+	}
+	{
+		hwcfg2_data_t hwcfg2;
+		addr=&_core_if->core_global_regs->ghwcfg2;
+		hwcfg2.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GHWCFG2   @0x%08X : 0x%08X\n",(uint32_t)addr,hwcfg2.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            dev_token_q_depth      : %x\n",hwcfg2.b.dev_token_q_depth);
+		LTQ_PRINT("            host_perio_tx_q_depth  : %x\n",hwcfg2.b.host_perio_tx_q_depth);
+		LTQ_PRINT("            nonperio_tx_q_depth    : %x\n",hwcfg2.b.nonperio_tx_q_depth);
+		LTQ_PRINT("            rx_status_q_depth      : %x\n",hwcfg2.b.rx_status_q_depth);
+		LTQ_PRINT("            dynamic_fifo           : %x\n",hwcfg2.b.dynamic_fifo);
+		LTQ_PRINT("            perio_ep_supported     : %x\n",hwcfg2.b.perio_ep_supported);
+		LTQ_PRINT("            num_host_chan          : %x\n",hwcfg2.b.num_host_chan);
+		LTQ_PRINT("            num_dev_ep             : %x\n",hwcfg2.b.num_dev_ep);
+		LTQ_PRINT("            fs_phy_type            : %x\n",hwcfg2.b.fs_phy_type);
+		LTQ_PRINT("            hs_phy_type            : %x\n",hwcfg2.b.hs_phy_type);
+		LTQ_PRINT("            point2point            : %x\n",hwcfg2.b.point2point);
+		LTQ_PRINT("            architecture           : %x\n",hwcfg2.b.architecture);
+		LTQ_PRINT("            op_mode                : %x\n",hwcfg2.b.op_mode);
+		#endif // __VERBOSE_DUMP__
+	}
+	{
+		hwcfg3_data_t hwcfg3;
+		addr=&_core_if->core_global_regs->ghwcfg3;
+		hwcfg3.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GHWCFG3   @0x%08X : 0x%08X\n",(uint32_t)addr,hwcfg3.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            dfifo_depth            : %x\n",hwcfg3.b.dfifo_depth);
+		LTQ_PRINT("            synch_reset_type       : %x\n",hwcfg3.b.synch_reset_type);
+		LTQ_PRINT("            optional_features      : %x\n",hwcfg3.b.optional_features);
+		LTQ_PRINT("            vendor_ctrl_if         : %x\n",hwcfg3.b.vendor_ctrl_if);
+		LTQ_PRINT("            i2c                    : %x\n",hwcfg3.b.otg_func);
+		LTQ_PRINT("            otg_func               : %x\n",hwcfg3.b.otg_func);
+		LTQ_PRINT("            packet_size_cntr_width : %x\n",hwcfg3.b.packet_size_cntr_width);
+		LTQ_PRINT("            xfer_size_cntr_width   : %x\n",hwcfg3.b.xfer_size_cntr_width);
+		#endif // __VERBOSE_DUMP__
+	}
+	{
+		hwcfg4_data_t hwcfg4;
+		addr=&_core_if->core_global_regs->ghwcfg4;
+		hwcfg4.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GHWCFG4   @0x%08X : 0x%08X\n",(uint32_t)addr,hwcfg4.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            desc_dma_dyn         : %x\n",hwcfg4.b.desc_dma_dyn);
+		LTQ_PRINT("            desc_dma             : %x\n",hwcfg4.b.desc_dma);
+		LTQ_PRINT("            num_in_eps           : %x\n",hwcfg4.b.num_in_eps);
+		LTQ_PRINT("            ded_fifo_en          : %x\n",hwcfg4.b.ded_fifo_en);
+		LTQ_PRINT("            session_end_filt_en  : %x\n",hwcfg4.b.session_end_filt_en);
+		LTQ_PRINT("            b_valid_filt_en      : %x\n",hwcfg4.b.b_valid_filt_en);
+		LTQ_PRINT("            a_valid_filt_en      : %x\n",hwcfg4.b.a_valid_filt_en);
+		LTQ_PRINT("            vbus_valid_filt_en   : %x\n",hwcfg4.b.vbus_valid_filt_en);
+		LTQ_PRINT("            iddig_filt_en        : %x\n",hwcfg4.b.iddig_filt_en);
+		LTQ_PRINT("            num_dev_mode_ctrl_ep : %x\n",hwcfg4.b.num_dev_mode_ctrl_ep);
+		LTQ_PRINT("            utmi_phy_data_width  : %x\n",hwcfg4.b.utmi_phy_data_width);
+		LTQ_PRINT("            min_ahb_freq         : %x\n",hwcfg4.b.min_ahb_freq);
+		LTQ_PRINT("            power_optimiz        : %x\n",hwcfg4.b.power_optimiz);
+		LTQ_PRINT("            num_dev_perio_in_ep  : %x\n",hwcfg4.b.num_dev_perio_in_ep);
+		#endif // __VERBOSE_DUMP__
+	}
+
+	{
+		pcgcctl_data_t pcgcctl;
+		addr=_core_if->pcgcctl;
+		pcgcctl.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  PCGCCTL   @0x%08X : 0x%08X\n",(uint32_t)addr,pcgcctl.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            physuspended  : %x\n",pcgcctl.b.physuspended);
+		LTQ_PRINT("            rstpdwnmodule : %x\n",pcgcctl.b.rstpdwnmodule);
+		LTQ_PRINT("            pwrclmp       : %x\n",pcgcctl.b.pwrclmp);
+		LTQ_PRINT("            gatehclk      : %x\n",pcgcctl.b.gatehclk);
+		LTQ_PRINT("            stoppclk      : %x\n",pcgcctl.b.stoppclk);
+		#endif // __VERBOSE_DUMP__
+	}
+
+	addr=&_core_if->core_global_regs->grxfsiz;
+	LTQ_PRINT("  GRXFSIZ   @0x%08X : 0x%08X\n",(uint32_t)addr,ltqusb_rreg(addr));
+	{
+		fifosize_data_t fifosize;
+		addr=&_core_if->core_global_regs->gnptxfsiz;
+		fifosize.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  GNPTXFSIZ @0x%08X : 0x%08X\n",(uint32_t)addr,fifosize.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            depth     : %x\n",fifosize.b.depth);
+		LTQ_PRINT("            startaddr : %x\n",fifosize.b.startaddr);
+		#endif // __VERBOSE_DUMP__
+		addr=&_core_if->core_global_regs->hptxfsiz;
+		fifosize.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("  HPTXFSIZ  @0x%08X : 0x%08X\n",(uint32_t)addr,fifosize.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            depth     : %x\n",fifosize.b.depth);
+		LTQ_PRINT("            startaddr : %x\n",fifosize.b.startaddr);
+		#endif // __VERBOSE_DUMP__
+	}
+
+	LTQ_PRINT("  Host Global Registers\n");
+	{
+		hcfg_data_t hcfg;
+		addr=&_core_if->host_global_regs->hcfg;
+		hcfg.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("    HCFG      @0x%08X : 0x%08X\n",(uint32_t)addr,hcfg.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            fslssupp      : %x\n",hcfg.b.fslssupp);
+		LTQ_PRINT("            fslspclksel   : %x\n",hcfg.b.fslspclksel);
+		#endif // __VERBOSE_DUMP__
+	}
+	addr=&_core_if->host_global_regs->hfir;
+	LTQ_PRINT("    HFIR      @0x%08X : 0x%08X\n",(uint32_t)addr,ltqusb_rreg(addr));
+	{
+		hfnum_data_t hfnum;
+		addr=&_core_if->host_global_regs->hfnum;
+		hfnum.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("    HFNUM     @0x%08X : 0x%08X\n",(uint32_t)addr,hfnum.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            frrem : %x\n",hfnum.b.frrem);
+		LTQ_PRINT("            frnum : %x\n",hfnum.b.frnum);
+		#endif // __VERBOSE_DUMP__
+	}
+	{
+		hptxsts_data_t hptxsts;
+		addr=&_core_if->host_global_regs->hptxsts;
+		hptxsts.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("    HPTXSTS   @0x%08X : 0x%08X\n",(uint32_t)addr,hptxsts.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            ptxqtop_odd       : %x\n",hptxsts.b.ptxqtop_odd);
+		LTQ_PRINT("            ptxqtop_chnum     : %x\n",hptxsts.b.ptxqtop_chnum);
+		LTQ_PRINT("            ptxqtop_token     : %x\n",hptxsts.b.ptxqtop_token);
+		LTQ_PRINT("            ptxqtop_terminate : %x\n",hptxsts.b.ptxqtop_terminate);
+		LTQ_PRINT("            ptxqspcavail      : %x\n",hptxsts.b.ptxqspcavail);
+		LTQ_PRINT("            ptxfspcavail      : %x\n",hptxsts.b.ptxfspcavail );
+		#endif // __VERBOSE_DUMP__
+	}
+	addr=&_core_if->host_global_regs->haint;
+	LTQ_PRINT("    HAINT     @0x%08X : 0x%08X\n",(uint32_t)addr,ltqusb_rreg(addr));
+	addr=&_core_if->host_global_regs->haintmsk;
+	LTQ_PRINT("    HAINTMSK  @0x%08X : 0x%08X\n",(uint32_t)addr,ltqusb_rreg(addr));
+	{
+		hprt0_data_t hprt0;
+		addr= _core_if->hprt0;
+		hprt0.d32=ltqusb_rreg(addr);
+		LTQ_PRINT("    HPRT0     @0x%08X : 0x%08X\n",(uint32_t)addr,hprt0.d32);
+		#ifdef __VERBOSE_DUMP__
+		LTQ_PRINT("            prtspd          : %x\n",hprt0.b.prtspd);
+		LTQ_PRINT("            prttstctl       : %x\n",hprt0.b.prttstctl);
+		LTQ_PRINT("            prtpwr          : %x\n",hprt0.b.prtpwr);
+		LTQ_PRINT("            prtlnsts        : %x\n",hprt0.b.prtlnsts);
+		LTQ_PRINT("            prtrst          : %x\n",hprt0.b.prtrst);
+		LTQ_PRINT("            prtsusp         : %x\n",hprt0.b.prtsusp);
+		LTQ_PRINT("            prtres          : %x\n",hprt0.b.prtres);
+		LTQ_PRINT("            prtovrcurrchng  : %x\n",hprt0.b.prtovrcurrchng);
+		LTQ_PRINT("            prtovrcurract   : %x\n",hprt0.b.prtovrcurract);
+		LTQ_PRINT("            prtenchng       : %x\n",hprt0.b.prtenchng);
+		LTQ_PRINT("            prtena          : %x\n",hprt0.b.prtena);
+		LTQ_PRINT("            prtconndet      : %x\n",hprt0.b.prtconndet );
+		LTQ_PRINT("            prtconnsts      : %x\n",hprt0.b.prtconnsts);
+		#endif // __VERBOSE_DUMP__
+	}
+
+	for (i=0; i<MAX_EPS_CHANNELS; i++)
+	{
+		LTQ_PRINT("  Host Channel %d Specific Registers\n", i);
+		{
+			hcchar_data_t hcchar;
+			addr=&_core_if->hc_regs[i]->hcchar;
+			hcchar.d32=ltqusb_rreg(addr);
+			LTQ_PRINT("    HCCHAR    @0x%08X : 0x%08X\n",(uint32_t)addr,hcchar.d32);
+			#ifdef __VERBOSE_DUMP__
+			LTQ_PRINT("            chen      : %x\n",hcchar.b.chen);
+			LTQ_PRINT("            chdis     : %x\n",hcchar.b.chdis);
+			LTQ_PRINT("            oddfrm    : %x\n",hcchar.b.oddfrm);
+			LTQ_PRINT("            devaddr   : %x\n",hcchar.b.devaddr);
+			LTQ_PRINT("            multicnt  : %x\n",hcchar.b.multicnt);
+			LTQ_PRINT("            eptype    : %x\n",hcchar.b.eptype);
+			LTQ_PRINT("            lspddev   : %x\n",hcchar.b.lspddev);
+			LTQ_PRINT("            epdir     : %x\n",hcchar.b.epdir);
+			LTQ_PRINT("            epnum     : %x\n",hcchar.b.epnum);
+			LTQ_PRINT("            mps       : %x\n",hcchar.b.mps);
+			#endif // __VERBOSE_DUMP__
+		}
+		{
+			hcsplt_data_t hcsplt;
+			addr=&_core_if->hc_regs[i]->hcsplt;
+			hcsplt.d32=ltqusb_rreg(addr);
+			LTQ_PRINT("    HCSPLT    @0x%08X : 0x%08X\n",(uint32_t)addr,hcsplt.d32);
+			#ifdef __VERBOSE_DUMP__
+			LTQ_PRINT("            spltena  : %x\n",hcsplt.b.spltena);
+			LTQ_PRINT("            compsplt : %x\n",hcsplt.b.compsplt);
+			LTQ_PRINT("            xactpos  : %x\n",hcsplt.b.xactpos);
+			LTQ_PRINT("            hubaddr  : %x\n",hcsplt.b.hubaddr);
+			LTQ_PRINT("            prtaddr  : %x\n",hcsplt.b.prtaddr);
+			#endif // __VERBOSE_DUMP__
+		}
+		{
+			hcint_data_t hcint;
+			addr=&_core_if->hc_regs[i]->hcint;
+			hcint.d32=ltqusb_rreg(addr);
+			LTQ_PRINT("    HCINT     @0x%08X : 0x%08X\n",(uint32_t)addr,hcint.d32);
+			#ifdef __VERBOSE_DUMP__
+			LTQ_PRINT("            datatglerr : %x\n",hcint.b.datatglerr);
+			LTQ_PRINT("            frmovrun   : %x\n",hcint.b.frmovrun);
+			LTQ_PRINT("            bblerr     : %x\n",hcint.b.bblerr);
+			LTQ_PRINT("            xacterr    : %x\n",hcint.b.xacterr);
+			LTQ_PRINT("            nyet       : %x\n",hcint.b.nyet);
+			LTQ_PRINT("            ack        : %x\n",hcint.b.ack);
+			LTQ_PRINT("            nak        : %x\n",hcint.b.nak);
+			LTQ_PRINT("            stall      : %x\n",hcint.b.stall);
+			LTQ_PRINT("            ahberr     : %x\n",hcint.b.ahberr);
+			LTQ_PRINT("            chhltd     : %x\n",hcint.b.chhltd);
+			LTQ_PRINT("            xfercomp   : %x\n",hcint.b.xfercomp);
+			#endif // __VERBOSE_DUMP__
+			addr=&_core_if->hc_regs[i]->hcintmsk;
+			hcint.d32=ltqusb_rreg(addr);
+			LTQ_PRINT("    HCINTMSK  @0x%08X : 0x%08X\n",(uint32_t)addr,hcint.d32);
+			#ifdef __VERBOSE_DUMP__
+			LTQ_PRINT("            datatglerr : %x\n",hcint.b.datatglerr);
+			LTQ_PRINT("            frmovrun   : %x\n",hcint.b.frmovrun);
+			LTQ_PRINT("            bblerr     : %x\n",hcint.b.bblerr);
+			LTQ_PRINT("            xacterr    : %x\n",hcint.b.xacterr);
+			LTQ_PRINT("            nyet       : %x\n",hcint.b.nyet);
+			LTQ_PRINT("            ack        : %x\n",hcint.b.ack);
+			LTQ_PRINT("            nak        : %x\n",hcint.b.nak);
+			LTQ_PRINT("            stall      : %x\n",hcint.b.stall);
+			LTQ_PRINT("            ahberr     : %x\n",hcint.b.ahberr);
+			LTQ_PRINT("            chhltd     : %x\n",hcint.b.chhltd);
+			LTQ_PRINT("            xfercomp   : %x\n",hcint.b.xfercomp);
+			#endif // __VERBOSE_DUMP__
+		}
+		{
+			hctsiz_data_t hctsiz;
+			addr=&_core_if->hc_regs[i]->hctsiz;
+			hctsiz.d32=ltqusb_rreg(addr);
+			LTQ_PRINT("    HCTSIZ    @0x%08X : 0x%08X\n",(uint32_t)addr,hctsiz.d32);
+			#ifdef __VERBOSE_DUMP__
+			LTQ_PRINT("            dopng     : %x\n",hctsiz.b.dopng);
+			LTQ_PRINT("            pid       : %x\n",hctsiz.b.pid);
+			LTQ_PRINT("            pktcnt    : %x\n",hctsiz.b.pktcnt);
+			LTQ_PRINT("            xfersize  : %x\n",hctsiz.b.xfersize);
+			#endif // __VERBOSE_DUMP__
+		}
+		addr=&_core_if->hc_regs[i]->hcdma;
+		LTQ_PRINT("    HCDMA     @0x%08X : 0x%08X\n",(uint32_t)addr,ltqusb_rreg(addr));
+	}
+#endif //__ENABLE_DUMP__
+}
+
+
+
+void do_suspend_h(ltqhcd_hcd_t *_ltqhcd)
+{
+	hprt0_data_t               hprt0 = {.d32 = 0};
+	ltqusb_core_if_t *core_if=&_ltqhcd->core_if;
+
+	core_if->issuspended=1;
+#if 1
+	hprt0.d32 = ltqusb_read_hprt0 (core_if);
+	hprt0.b.prtsusp = 1;
+	hprt0.b.prtres = 0;
+	hprt0.b.prtpwr = 0;
+	ltqusb_wreg(core_if->hprt0, hprt0.d32);
+	ltqusb_vbus_off(_ltqhcd);
+	mdelay(100);
+#endif
+	ltqusb_phy_power_off_h(core_if);
+	ltqusb_power_off_h(core_if);
+}
+void do_resume_h(ltqhcd_hcd_t *_ltqhcd)
+{
+	hprt0_data_t               hprt0 = {.d32 = 0};
+	ltqusb_core_if_t *core_if=&_ltqhcd->core_if;
+	ltqusb_vbus_on(_ltqhcd);
+	mdelay(100);
+	ltqusb_power_on_h(core_if);
+	ltqusb_phy_power_on_h(core_if);
+
+	hprt0.d32 = ltqusb_read_hprt0 (core_if);
+	hprt0.b.prtsusp = 0;
+#if 1
+	hprt0.b.prtres = 1;
+#endif
+	hprt0.b.prtpwr = 1;
+	ltqusb_wreg(core_if->hprt0, hprt0.d32);
+	mdelay(100);
+	hprt0.d32 = ltqusb_read_hprt0 (core_if);
+	hprt0.b.prtsusp = 0;
+	hprt0.b.prtres = 0;
+	ltqusb_wreg(core_if->hprt0, hprt0.d32);
+	core_if->issuspended=0;
+}
+void do_bussuspend_h(ltqhcd_hcd_t *_ltqhcd)
+{
+	hprt0_data_t               hprt0 = {.d32 = 0};
+	ltqusb_core_if_t *core_if=&_ltqhcd->core_if;
+
+	hprt0.d32 = ltqusb_read_hprt0 (core_if);
+	hprt0.b.prtsusp  =1;
+	hprt0.b.prtres   =0;
+	hprt0.b.prttstctl=0; //Test mode disabled
+	ltqusb_wreg(core_if->hprt0, hprt0.d32);
+}
+void do_busresume_h(ltqhcd_hcd_t *_ltqhcd)
+{
+	hprt0_data_t               hprt0 = {.d32 = 0};
+
+	ltqusb_core_if_t *core_if=&_ltqhcd->core_if;
+
+	hprt0.d32 = ltqusb_read_hprt0 (core_if);
+	hprt0.b.prtsusp  =0;
+	hprt0.b.prtres   =1;
+	hprt0.b.prttstctl=0; //Test mode disabled
+	ltqusb_wreg(core_if->hprt0, hprt0.d32);
+	mdelay(20);
+
+	hprt0.d32 = ltqusb_read_hprt0 (core_if);
+	hprt0.b.prtsusp  =0;
+	hprt0.b.prtres   =0;
+	hprt0.b.prttstctl=0; //Test mode disabled
+	ltqusb_wreg(core_if->hprt0, hprt0.d32);
+}
+
+
+/*!
+ \brief This function enables the Host mode interrupts.
+ \param _core_if        Pointer of core_if structure
+ */
+void ltqusb_host_enable_interrupts(ltqusb_core_if_t *_core_if)
+{
+	gint_data_t intr_mask ={ .d32 = 0};
+	ltqusb_core_global_regs_t *global_regs = _core_if->core_global_regs;
+
+	LTQ_DEBUGPL(DBG_CIL, "%s()\n", __func__);
+
+	/* Clear any pending OTG Interrupts */
+	ltqusb_wreg( &global_regs->gotgint, 0xFFFFFFFF);
+
+	/* Clear any pending interrupts */
+	ltqusb_wreg( &global_regs->gintsts, 0xFFFFFFFF);
+
+	/* Enable the interrupts in the GINTMSK.*/
+
+	/* Common interrupts */
+	intr_mask.b.modemismatch = 1;
+	intr_mask.b.conidstschng = 1;
+	intr_mask.b.wkupintr = 1;
+	intr_mask.b.disconnect = 1;
+	intr_mask.b.usbsuspend = 1;
+
+	/* Host interrupts */
+	intr_mask.b.sofintr = 1;
+	intr_mask.b.portintr = 1;
+	intr_mask.b.hcintr = 1;
+
+	ltqusb_mreg( &global_regs->gintmsk, intr_mask.d32, intr_mask.d32);
+	LTQ_DEBUGPL(DBG_CIL, "%s() gintmsk=%0x\n", __func__, ltqusb_rreg( &global_regs->gintmsk));
+}
+
+/*!
+ \brief This function disables the Host mode interrupts.
+ \param _core_if        Pointer of core_if structure
+ */
+void ltqusb_host_disable_interrupts(ltqusb_core_if_t *_core_if)
+{
+	ltqusb_core_global_regs_t *global_regs = _core_if->core_global_regs;
+
+	LTQ_DEBUGPL(DBG_CILV, "%s()\n", __func__);
+
+	#if 1
+		ltqusb_wreg( &global_regs->gintmsk, 0);
+	#else
+		/* Common interrupts */
+		{
+			gint_data_t intr_mask ={.d32 = 0};
+			intr_mask.b.modemismatch = 1;
+			intr_mask.b.rxstsqlvl = 1;
+			intr_mask.b.conidstschng = 1;
+			intr_mask.b.wkupintr = 1;
+			intr_mask.b.disconnect = 1;
+			intr_mask.b.usbsuspend = 1;
+
+			/* Host interrupts */
+			intr_mask.b.sofintr = 1;
+			intr_mask.b.portintr = 1;
+			intr_mask.b.hcintr = 1;
+			intr_mask.b.ptxfempty = 1;
+			intr_mask.b.nptxfempty = 1;
+			ltqusb_mreg(&global_regs->gintmsk, intr_mask.d32, 0);
+		}
+	#endif
+}
+
+/*!
+ \brief This function initializes the LTQUSB controller registers for  Host mode.
+        This function flushes the Tx and Rx FIFOs and it flushes any entries in the
+        request queues.
+ \param _core_if        Pointer of core_if structure
+ \param _params         parameters to be set
+ */
+void ltqusb_host_core_init(ltqusb_core_if_t *_core_if, ltqusb_params_t  *_params)
+{
+	ltqusb_core_global_regs_t *global_regs =  _core_if->core_global_regs;
+
+	gusbcfg_data_t usbcfg   ={.d32 = 0};
+	gahbcfg_data_t ahbcfg   ={.d32 = 0};
+	gotgctl_data_t gotgctl  ={.d32 = 0};
+
+	int i;
+
+	LTQ_DEBUGPL(DBG_CILV, "%s(%p)\n",__func__,_core_if);
+
+	/* Copy Params */
+
+	_core_if->params.dma_burst_size      =  _params->dma_burst_size;
+	_core_if->params.speed               =  _params->speed;
+	if(_params->max_transfer_size < 2048 || _params->max_transfer_size > ((1 << (_core_if->hwcfg3.b.xfer_size_cntr_width + 11)) - 1) )
+		_core_if->params.max_transfer_size = ((1 << (_core_if->hwcfg3.b.xfer_size_cntr_width + 11)) - 1);
+	else
+		_core_if->params.max_transfer_size = _params->max_transfer_size;
+
+	if(_params->max_packet_count < 16 || _params->max_packet_count > ((1 << (_core_if->hwcfg3.b.packet_size_cntr_width + 4)) - 1) )
+		_core_if->params.max_packet_count= ((1 << (_core_if->hwcfg3.b.packet_size_cntr_width + 4)) - 1);
+	else
+		_core_if->params.max_packet_count=  _params->max_packet_count;
+	_core_if->params.phy_utmi_width      =  _params->phy_utmi_width;
+	_core_if->params.timeout_cal         =  _params->timeout_cal;
+	#if defined(__WITH_OC_HY__)
+		_core_if->params.oc_hy           =  _params->oc_hy;
+	#endif
+
+	_core_if->params.ana_disconnect_threshold        =  _params->ana_disconnect_threshold;
+	_core_if->params.ana_squelch_threshold           =  _params->ana_squelch_threshold;
+	_core_if->params.ana_transmitter_crossover       =  _params->ana_transmitter_crossover;
+	_core_if->params.ana_transmitter_impedance       =  _params->ana_transmitter_impedance;
+	_core_if->params.ana_transmitter_dc_voltage      =  _params->ana_transmitter_dc_voltage;
+	_core_if->params.ana_transmitter_risefall_time   =  _params->ana_transmitter_risefall_time;
+	_core_if->params.ana_transmitter_pre_emphasis    =  _params->ana_transmitter_pre_emphasis;
+
+	usbcfg.d32 = ltqusb_rreg(&global_regs->gusbcfg);
+//	usbcfg.b.ulpi_ext_vbus_drv = 1;
+	usbcfg.b.term_sel_dl_pulse = 0;
+	usbcfg.b.ForceDevMode = 0;
+	usbcfg.b.ForceHstMode = 1;
+	usbcfg.b.toutcal      = _core_if->params.timeout_cal;
+	ltqusb_wreg (&global_regs->gusbcfg, usbcfg.d32);
+	/* Reset the Controller */
+	do
+	{
+		while(ltqusb_core_soft_reset_h( _core_if ))
+			ltqusb_hard_reset_h(_core_if);
+	} while (ltqusb_is_device_mode(_core_if));
+
+	usbcfg.d32 = ltqusb_rreg(&global_regs->gusbcfg);
+//	usbcfg.b.ulpi_ext_vbus_drv = 1;
+	usbcfg.b.term_sel_dl_pulse = 0;
+	usbcfg.b.toutcal           = _core_if->params.timeout_cal;
+	ltqusb_wreg (&global_regs->gusbcfg, usbcfg.d32);
+
+	/* This programming sequence needs to happen in FS mode before any other
+	 * programming occurs */
+	/* High speed PHY. */
+	if (!_core_if->phy_init_done)
+	{
+		_core_if->phy_init_done = 1;
+		/* HS PHY parameters.  These parameters are preserved
+		 * during soft reset so only program the first time.  Do
+		 * a soft reset immediately after setting phyif.  */
+		usbcfg.b.ulpi_utmi_sel = 0; //UTMI+
+		usbcfg.b.phyif = ( _core_if->params.phy_utmi_width == 16)?1:0;
+		ltqusb_wreg( &global_regs->gusbcfg, usbcfg.d32);
+		/* Reset after setting the PHY parameters */
+		ltqusb_core_soft_reset_h( _core_if );
+	}
+
+	usbcfg.d32 = ltqusb_rreg(&global_regs->gusbcfg);
+//	usbcfg.b.ulpi_fsls = 0;
+//	usbcfg.b.ulpi_clk_sus_m = 0;
+	usbcfg.b.term_sel_dl_pulse = 0;
+	usbcfg.b.ForceDevMode = 0;
+	usbcfg.b.ForceHstMode = 1;
+	ltqusb_wreg(&global_regs->gusbcfg, usbcfg.d32);
+
+	/* Program the GAHBCFG Register.*/
+	switch (_core_if->params.dma_burst_size)
+	{
+		case 0 :
+			ahbcfg.b.hburstlen = LTQUSB_GAHBCFG_INT_DMA_BURST_SINGLE;
+			break;
+		case 1 :
+			ahbcfg.b.hburstlen = LTQUSB_GAHBCFG_INT_DMA_BURST_INCR;
+			break;
+		case 4 :
+			ahbcfg.b.hburstlen = LTQUSB_GAHBCFG_INT_DMA_BURST_INCR4;
+			break;
+		case 8 :
+			ahbcfg.b.hburstlen = LTQUSB_GAHBCFG_INT_DMA_BURST_INCR8;
+			break;
+		case 16:
+			ahbcfg.b.hburstlen = LTQUSB_GAHBCFG_INT_DMA_BURST_INCR16;
+			break;
+	}
+	#if defined(__UNALIGNED_BUF_ADJ__) || defined(__UNALIGNED_BUF_CHK__)
+		_core_if->unaligned_mask=3;
+		#if defined(__UNALIGNED_BUF_BURST__)
+			switch(_core_if->params.dma_burst_size)
+			{
+				case 4 :
+					_core_if->unaligned_mask=15;
+					break;
+				case 8 :
+					_core_if->unaligned_mask=31;
+					break;
+				case 16:
+					_core_if->unaligned_mask=63;
+					break;
+				case 0 :
+				case 1 :
+					break;
+				default:
+					break;
+			}
+		#endif //defined(__UNALIGNED_BUF_BURST__)
+	#endif //defined(__UNALIGNED_BUF_ADJ__) || defined(__UNALIGNED_BUF_CHK__)
+	ahbcfg.b.dmaenable = 1;
+	ltqusb_wreg(&global_regs->gahbcfg, ahbcfg.d32);
+
+	/* Program the GUSBCFG register. */
+	usbcfg.d32 = ltqusb_rreg( &global_regs->gusbcfg );
+	usbcfg.b.hnpcap = 0;
+	usbcfg.b.srpcap = 0;
+	ltqusb_wreg( &global_regs->gusbcfg, usbcfg.d32);
+
+	/* Restart the Phy Clock */
+	ltqusb_wreg(_core_if->pcgcctl, 0);
+
+	/* Initialize Host Configuration Register */
+	{
+		hcfg_data_t 	hcfg;
+		hcfg.d32 = ltqusb_rreg(&_core_if->host_global_regs->hcfg);
+		hcfg.b.fslspclksel = LTQUSB_HCFG_30_60_MHZ;
+		if (_params->speed == LTQUSB_PARAM_SPEED_FULL)
+			hcfg.b.fslssupp = 1;
+		ltqusb_wreg(&_core_if->host_global_regs->hcfg, hcfg.d32);
+	}
+
+	_core_if->params.host_channels=(_core_if->hwcfg2.b.num_host_chan + 1);
+
+	if(_params->host_channels>0 && _params->host_channels < _core_if->params.host_channels)
+		_core_if->params.host_channels = _params->host_channels;
+
+	/* Configure data FIFO sizes */
+	_core_if->params.data_fifo_size     = _core_if->hwcfg3.b.dfifo_depth;
+	_core_if->params.rx_fifo_size       = ltqusb_rreg(&global_regs->grxfsiz);
+	_core_if->params.nperio_tx_fifo_size= ltqusb_rreg(&global_regs->gnptxfsiz) >> 16;
+	_core_if->params.perio_tx_fifo_size = ltqusb_rreg(&global_regs->hptxfsiz) >> 16;
+	LTQ_DEBUGPL(DBG_CIL, "Initial: FIFO Size=0x%06X\n"   , _core_if->params.data_fifo_size);
+	LTQ_DEBUGPL(DBG_CIL, "           Rx FIFO Size=0x%06X\n", _core_if->params.rx_fifo_size);
+	LTQ_DEBUGPL(DBG_CIL, "         NPTx FIFO Size=0x%06X\n", _core_if->params.nperio_tx_fifo_size);
+	LTQ_DEBUGPL(DBG_CIL, "          PTx FIFO Size=0x%06X\n", _core_if->params.perio_tx_fifo_size);
+
+	{
+		fifosize_data_t txfifosize;
+		if(_params->data_fifo_size >=0 && _params->data_fifo_size < _core_if->params.data_fifo_size)
+			_core_if->params.data_fifo_size = _params->data_fifo_size;
+
+		if( _params->rx_fifo_size >= 0 && _params->rx_fifo_size < _core_if->params.rx_fifo_size)
+			_core_if->params.rx_fifo_size = _params->rx_fifo_size;
+		if( _params->nperio_tx_fifo_size >=0 && _params->nperio_tx_fifo_size < _core_if->params.nperio_tx_fifo_size)
+			_core_if->params.nperio_tx_fifo_size = _params->nperio_tx_fifo_size;
+		if( _params->perio_tx_fifo_size >=0 && _params->perio_tx_fifo_size < _core_if->params.perio_tx_fifo_size)
+			_core_if->params.perio_tx_fifo_size = _params->perio_tx_fifo_size;
+
+		if(_core_if->params.data_fifo_size < _core_if->params.rx_fifo_size)
+			_core_if->params.rx_fifo_size = _core_if->params.data_fifo_size;
+		ltqusb_wreg( &global_regs->grxfsiz, _core_if->params.rx_fifo_size);
+		txfifosize.b.startaddr = _core_if->params.rx_fifo_size;
+
+		if(txfifosize.b.startaddr + _core_if->params.nperio_tx_fifo_size > _core_if->params.data_fifo_size)
+			_core_if->params.nperio_tx_fifo_size = _core_if->params.data_fifo_size - txfifosize.b.startaddr;
+		txfifosize.b.depth=_core_if->params.nperio_tx_fifo_size;
+		ltqusb_wreg( &global_regs->gnptxfsiz, txfifosize.d32);
+		txfifosize.b.startaddr += _core_if->params.nperio_tx_fifo_size;
+
+		if(txfifosize.b.startaddr + _core_if->params.perio_tx_fifo_size > _core_if->params.data_fifo_size)
+			_core_if->params.perio_tx_fifo_size = _core_if->params.data_fifo_size - txfifosize.b.startaddr;
+		txfifosize.b.depth=_core_if->params.perio_tx_fifo_size;
+		ltqusb_wreg( &global_regs->hptxfsiz, txfifosize.d32);
+		txfifosize.b.startaddr += _core_if->params.perio_tx_fifo_size;
+	}
+
+	#ifdef __DEBUG__
+	{
+		fifosize_data_t fifosize;
+		LTQ_DEBUGPL(DBG_CIL, "Result : FIFO Size=0x%06X\n"   , _core_if->params.data_fifo_size);
+
+		fifosize.d32=ltqusb_rreg(&global_regs->grxfsiz);
+		LTQ_DEBUGPL(DBG_CIL, "         Rx FIFO =0x%06X 0x%06X\n", fifosize.b.startaddr,fifosize.b.depth);
+		fifosize.d32=ltqusb_rreg(&global_regs->gnptxfsiz);
+		LTQ_DEBUGPL(DBG_CIL, "         NPTx FIFO =0x%06X 0x%06X\n", fifosize.b.startaddr,fifosize.b.depth);
+		fifosize.d32=ltqusb_rreg(&global_regs->hptxfsiz);
+		LTQ_DEBUGPL(DBG_CIL, "          PTx FIFO =0x%06X 0x%06X\n", fifosize.b.startaddr,fifosize.b.depth);
+	}
+	#endif
+
+	/* Clear Host Set HNP Enable in the OTG Control Register */
+	gotgctl.b.hstsethnpen = 1;
+	ltqusb_mreg( &global_regs->gotgctl, gotgctl.d32, 0);
+
+	/* Flush the FIFOs */
+	ltqusb_flush_tx_fifo_h(_core_if, 0x10);  /* all Tx FIFOs */
+	ltqusb_flush_rx_fifo_h(_core_if);
+
+	for (i = 0; i < _core_if->hwcfg2.b.num_host_chan + 1; i++)
+	{
+		hcchar_data_t    hcchar;
+		hcchar.d32 = ltqusb_rreg(&_core_if->hc_regs[i]->hcchar);
+		hcchar.b.chen  = 0;
+		hcchar.b.chdis = 1;
+		hcchar.b.epdir = 0;
+		ltqusb_wreg(&_core_if->hc_regs[i]->hcchar, hcchar.d32);
+	}
+	/* Halt all channels to put them into a known state. */
+	for (i = 0; i < _core_if->hwcfg2.b.num_host_chan + 1; i++)
+	{
+		hcchar_data_t    hcchar;
+		int count = 0;
+
+		hcchar.d32 = ltqusb_rreg(&_core_if->hc_regs[i]->hcchar);
+		hcchar.b.chen  = 1;
+		hcchar.b.chdis = 1;
+		hcchar.b.epdir = 0;
+		ltqusb_wreg(&_core_if->hc_regs[i]->hcchar, hcchar.d32);
+
+		LTQ_DEBUGPL(DBG_HCDV, "%s: Halt channel %d\n", __func__, i);
+		do{
+			hcchar.d32 = ltqusb_rreg(&_core_if->hc_regs[i]->hcchar);
+			if (++count > 1000)
+			{
+				LTQ_ERROR("%s: Unable to clear halt on channel %d\n", __func__, i);
+				break;
+			}
+		} while (hcchar.b.chen);
+	}
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////
+void ltqusb_oc_int_on(int port);
+void ltqusb_oc_int_off(int port);
+/*!
+	 \fn    void ltqusb_vbus_init(ltqusb_core_if_t *_core_if)
+	 \brief This function init the VBUS control.
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+void ltqusb_vbus_init(ltqhcd_hcd_t *_ltqhcd)
+{
+	if(_ltqhcd->vbusgpioid<0)
+		return;
+	if(ltqusb_vbus_shared)
+	{
+		if(ltqusb_hcd_1.vbusgpioinstalled||ltqusb_hcd_2.vbusgpioinstalled)
+		{
+			ltqusb_hcd_1.vbusgpioinstalled=ltqusb_hcd_2.vbusgpioinstalled=1;
+		}
+		else
+		{
+			if(devm_gpio_request(_ltqhcd->dev, _ltqhcd->vbusgpioid,"USBVBus")==0)
+			{
+				gpio_direction_output(_ltqhcd->vbusgpioid,1);
+				ltqusb_hcd_1.vbusgpioinstalled=ltqusb_hcd_2.vbusgpioinstalled=1;
+				LTQ_PRINT("VBus1 and VBus2 registered(Shared) IO#%d\n",_ltqhcd->vbusgpioid);
+			}
+		}
+	}
+	else if(_ltqhcd->core_if.core_no==0)
+	{
+		if(!_ltqhcd->vbusgpioinstalled)
+		{
+			if(devm_gpio_request(_ltqhcd->dev, _ltqhcd->vbusgpioid,"USBVBus1")==0)
+			{
+				gpio_direction_output(_ltqhcd->vbusgpioid,1);
+				_ltqhcd->vbusgpioinstalled=1;
+				LTQ_PRINT("VBus1 registered IO#%d\n",_ltqhcd->vbusgpioid);
+			}
+		}
+	}
+	else
+	{
+		if(!_ltqhcd->vbusgpioinstalled)
+		{
+			if(devm_gpio_request(_ltqhcd->dev, _ltqhcd->vbusgpioid,"USBVBus2")==0)
+			{
+				gpio_direction_output(_ltqhcd->vbusgpioid,1);
+				_ltqhcd->vbusgpioinstalled=1;
+				LTQ_PRINT("VBus2 registered IO#%d\n",_ltqhcd->vbusgpioid);
+			}
+		}
+	}
+}
+
+
+/*!
+	 \fn    void ltqusb_vbus_free(ltqusb_core_if_t *_core_if)
+	 \brief This function free the VBUS control.
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+void ltqusb_vbus_free(ltqhcd_hcd_t *_ltqhcd)
+{
+	if(_ltqhcd->vbusgpioid<0)
+		return;
+	if(ltqusb_vbus_shared)
+	{
+		if(ltqusb_hcd_1.vbusgpioinstalled||ltqusb_hcd_2.vbusgpioinstalled)
+		{
+			devm_gpio_free(_ltqhcd->dev, _ltqhcd->vbusgpioid);
+			ltqusb_hcd_1.vbusgpioinstalled=ltqusb_hcd_2.vbusgpioinstalled=0;
+		}
+	}
+	else
+	{
+		if(_ltqhcd->vbusgpioinstalled)
+		{
+			devm_gpio_free(_ltqhcd->dev, _ltqhcd->vbusgpioid);
+			_ltqhcd->vbusgpioinstalled=0;
+		}
+	}
+}
+
+/*!
+	 \fn    void ltqusb_vbus_on(ltqusb_core_if_t *_core_if)
+	 \brief Turn on the USB 5V VBus Power
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+ */
+void ltqusb_vbus_on(ltqhcd_hcd_t *_ltqhcd)
+{
+	if(_ltqhcd->vbusgpioid<0)
+		return;
+	if(_ltqhcd->vbusgpioinstalled)
+	{
+		__gpio_set_value(_ltqhcd->vbusgpioid,1);
+		if(ltqusb_vbus_shared)
+				ltqusb_hcd_1.vbusgpiostatus=ltqusb_hcd_2.vbusgpiostatus=1;
+		else
+			_ltqhcd->vbusgpiostatus=1;
+	}
+	if(_ltqhcd->core_if.core_no==0)
+		ltqusb_oc_int_on(1);
+	else
+		ltqusb_oc_int_on(2);
+}
+
+
+/*!
+	 \fn    void ltqusb_vbus_off(ltqusb_core_if_t *_core_if)
+	 \brief Turn off the USB 5V VBus Power
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+void ltqusb_vbus_off(ltqhcd_hcd_t *_ltqhcd)
+{
+	if(_ltqhcd->vbusgpioid<0)
+		return;
+	if(_ltqhcd->vbusgpioinstalled)
+	{
+		__gpio_set_value(_ltqhcd->vbusgpioid,0);
+		if(ltqusb_vbus_shared)
+				ltqusb_hcd_1.vbusgpiostatus=ltqusb_hcd_2.vbusgpiostatus=0;
+		else
+			_ltqhcd->vbusgpiostatus=0;
+	}
+	if(_ltqhcd->core_if.core_no==0)
+		ltqusb_oc_int_off(1);
+	else
+		ltqusb_oc_int_off(2);
+}
+
+
+/*!
+	 \fn    int ltqusb_vbus(ltqusb_core_if_t *_core_if)
+	 \brief Read Current VBus status
+	 \param _core_if        Pointer of core_if structure
+	 \ingroup  LTQUSB_CIF
+	 */
+int ltqusb_vbus(ltqhcd_hcd_t *_ltqhcd)
+{
+	if(_ltqhcd->vbusgpioid<0)
+		return -1;
+	if(_ltqhcd->vbusgpioinstalled)
+			return (_ltqhcd->vbusgpiostatus);
+		return -1;
+
+}
+
+
+/////////////////////////////////////////////////////////////////////////
+
+
+
+
+
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+#define OC_Timer_Stable 3
+#define OC_Timer_Sleep 200
+#define OC_Timer_Max 3
+
+extern ltqhcd_hcd_t *oc1_int_target;
+extern ltqhcd_hcd_t *oc2_int_target;
+unsigned int  oc1_int_installed=0;
+unsigned int  oc2_int_installed=0;
+unsigned int  oc1_int_count=0;
+unsigned int  oc2_int_count=0;
+struct timer_list oc1_retry_timer;
+struct timer_list oc2_retry_timer;
+unsigned int  oc1_int_no=0;
+unsigned int  oc2_int_no=0;
+
+void oc_retry_timer_func(unsigned long arg)
+{
+	if(arg==1)
+	{
+		if(oc1_int_installed==0) //not installed
+		{
+		}
+		else if(oc1_int_installed==1) //disabled
+		{
+		}
+		else if(oc1_int_installed==2) //stablizing
+		{
+			oc1_int_installed=4;
+			oc1_int_count=0;
+		}
+		else if(oc1_int_installed==3) // sleeping
+		{
+			mod_timer(&oc1_retry_timer,jiffies +  HZ*OC_Timer_Stable);
+			oc1_int_installed=2;
+			enable_irq(oc1_int_no);
+		}
+		else if(oc1_int_installed==4) //
+		{
+			oc1_int_count=0;
+		}
+		else if(oc1_int_installed==5) // Stable sleeping
+		{
+			mod_timer(&oc1_retry_timer,jiffies +  HZ*OC_Timer_Stable);
+			oc1_int_installed=4;
+			enable_irq(oc1_int_no);
+		}
+		else
+		{
+		}
+	}
+	else
+	{
+		if(oc2_int_installed==0) //not installed
+		{
+		}
+		else if(oc2_int_installed==1) //disabled
+		{
+		}
+		else if(oc2_int_installed==2) //stablizing
+		{
+			oc2_int_installed=4;
+			oc2_int_count=0;
+		}
+		else if(oc2_int_installed==3) // sleeping
+		{
+			mod_timer(&oc2_retry_timer,jiffies +  HZ*OC_Timer_Stable);
+			oc2_int_installed=2;
+			enable_irq(oc2_int_no);
+		}
+		else if(oc2_int_installed==4) //
+		{
+			oc2_int_count=0;
+		}
+		else if(oc2_int_installed==5) // Stable sleeping
+		{
+			mod_timer(&oc2_retry_timer,jiffies +  HZ*OC_Timer_Stable);
+			oc2_int_installed=4;
+			enable_irq(oc2_int_no);
+		}
+		else
+		{
+		}
+	}
+}
+
+irqreturn_t ltqhcd_oc_irq(int _irq , void *_dev)
+{
+	int32_t retval=1;
+	//ltqhcd_hcd_t *ltqhcd= _dev;
+	if(_irq==oc1_int_no)
+	{
+		disable_irq_nosync(oc1_int_no);
+		if(oc1_int_installed==0)      //not installed
+		{
+		}
+		else if(oc1_int_installed==1) //disabled
+		{
+		}
+		else if(oc1_int_installed==2) //stablizing
+		{
+			mod_timer(&oc1_retry_timer,jiffies +  HZ/OC_Timer_Sleep);
+			oc1_int_installed=3;
+		}
+		else if(oc1_int_installed==3) // sleeping
+		{
+		}
+		else if(oc1_int_installed==4) //
+		{
+			oc1_int_count++;
+			if(oc1_int_count>=OC_Timer_Max)
+			{
+				LTQ_DEBUGP("OC INTERRUPT port #1\n");
+				oc1_int_target->flags.b.port_over_current_change = 1;
+				if(ltqusb_oc_shared)
+					oc2_int_target->flags.b.port_over_current_change = 1;
+				ltqusb_vbus_off(oc1_int_target);
+				if(ltqusb_oc_shared)
+					ltqusb_vbus_off(oc2_int_target);
+				LTQ_DEBUGP("Turning off port #1\n");
+			}
+			else
+			{
+				mod_timer(&oc1_retry_timer,jiffies +  HZ/OC_Timer_Sleep);
+				oc1_int_installed=5;
+			}
+		}
+		else if(oc1_int_installed==5) // Stable sleeping
+		{
+		}
+	}
+	else
+	{
+		disable_irq_nosync(oc2_int_no);
+		if(oc2_int_installed==0)      //not installed
+		{
+		}
+		else if(oc2_int_installed==1) //disabled
+		{
+		}
+		else if(oc2_int_installed==2) //stablizing
+		{
+			mod_timer(&oc2_retry_timer,jiffies +  HZ/OC_Timer_Sleep);
+			oc2_int_installed=3;
+		}
+		else if(oc2_int_installed==3) // sleeping
+		{
+		}
+		else if(oc2_int_installed==4) //
+		{
+			oc2_int_count++;
+			if(oc2_int_count>=OC_Timer_Max)
+			{
+				LTQ_DEBUGP("OC INTERRUPT port #2\n");
+				oc2_int_target->flags.b.port_over_current_change = 1;
+				ltqusb_vbus_off(oc2_int_target);
+				LTQ_DEBUGP("Turning off port #2\n");
+			}
+			else
+			{
+				mod_timer(&oc2_retry_timer,jiffies +  HZ/OC_Timer_Sleep);
+				oc2_int_installed=5;
+			}
+		}
+		else if(oc2_int_installed==5) // Stable sleeping
+		{
+		}
+	}
+	return IRQ_RETVAL(retval);
+}
+
+void ltqusb_oc_int_on(int port)
+{
+	if     (ltqusb_oc_shared || (port==1&&oc1_int_target && oc1_int_no>0))
+	{
+		if(oc1_int_installed==0)
+		{
+			//LTQ_DEBUGPL( DBG_CIL, "registering (overcurrent) handler for port #1 irq#%d\n", oc1_int_no);
+			LTQ_PRINT("registering (overcurrent) handler for port #1 irq#%d\n", oc1_int_no);
+			oc1_int_installed=2;
+			init_timer(&oc1_retry_timer);
+			oc1_retry_timer.function = oc_retry_timer_func;
+			oc1_retry_timer.data=1;
+			if(request_irq(oc1_int_no, &ltqhcd_oc_irq,
+					       IRQF_TRIGGER_NONE
+//					     | IRQF_TRIGGER_RISING
+//					     | IRQF_TRIGGER_FALLING
+//					     | IRQF_TRIGGER_HIGH
+//					     | IRQF_TRIGGER_LOW
+//					     | IRQF_TRIGGER_PROBE
+					     | IRQF_DISABLED
+//					     | IRQF_SAMPLE_RANDOM
+//					     | IRQF_SHARED
+//					     | IRQF_PROBE_SHARED
+//					     | IRQF_TIMER
+//					     | IRQF_PERCPU
+//					     | IRQF_NOBALANCING
+//					     | IRQF_IRQPOLL
+//					     | IRQF_ONESHOT
+				    ,
+				     "ltqusb1_oc", (void *)oc1_int_target))
+				oc1_int_installed=0;
+			else
+				mod_timer(&oc1_retry_timer,jiffies +  HZ*OC_Timer_Stable);
+		}
+		else if(oc1_int_installed!=2 && oc1_int_installed!=4 )
+		{
+			oc1_int_installed=2;
+			enable_irq(oc1_int_no);
+			mod_timer(&oc1_retry_timer,jiffies +  HZ*OC_Timer_Stable);
+		}
+	}
+	else if((port==2&&oc2_int_target && oc2_int_no>0))
+	{
+		if(oc2_int_installed==0)
+		{
+			//LTQ_DEBUGPL( DBG_CIL, "registering (overcurrent) handler for port #2 irq#%d\n", oc2_int_no);
+			LTQ_PRINT("registering (overcurrent) handler for port #2 irq#%d\n", oc2_int_no);
+			oc2_int_installed=2;
+			init_timer(&oc2_retry_timer);
+			oc2_retry_timer.function = oc_retry_timer_func;
+			oc2_retry_timer.data=2;
+			if(request_irq(oc2_int_no, &ltqhcd_oc_irq,
+					       IRQF_TRIGGER_NONE
+//					     | IRQF_TRIGGER_RISING
+//					     | IRQF_TRIGGER_FALLING
+//					     | IRQF_TRIGGER_HIGH
+//					     | IRQF_TRIGGER_LOW
+//					     | IRQF_TRIGGER_PROBE
+				     | IRQF_DISABLED
+//					     | IRQF_SAMPLE_RANDOM
+//					     | IRQF_SHARED
+//					     | IRQF_PROBE_SHARED
+//					     | IRQF_TIMER
+//					     | IRQF_PERCPU
+//					     | IRQF_NOBALANCING
+//					     | IRQF_IRQPOLL
+//					     | IRQF_ONESHOT
+				    ,
+			     "ltqusb2_oc", (void *)oc2_int_target))
+				oc2_int_installed=0;
+			else
+				mod_timer(&oc2_retry_timer,jiffies +  HZ*OC_Timer_Stable);
+		}
+		else if(oc2_int_installed!=2 && oc2_int_installed!=4 )
+		{
+			oc2_int_installed=2;
+			enable_irq(oc2_int_no);
+			mod_timer(&oc2_retry_timer,jiffies +  HZ*OC_Timer_Stable);
+		}
+	}
+}
+
+
+void ltqusb_oc_int_off(int port)
+{
+	if(port==1)
+	{
+		disable_irq_nosync(oc1_int_no);
+		if(oc1_int_installed)
+			oc1_int_installed=1;
+	}
+	else
+	{
+		disable_irq_nosync(oc2_int_no);
+		if(oc2_int_installed)
+			oc2_int_installed=1;
+	}
+}
+
+uint32_t ltqusb_oc_get_hy(int port)
+{
+	uint32_t data=0;
+	if(ltqusb_chip_family== LTQUSB_CHIP_AR10)
+	{
+		if(port==1)
+			data = ltqusb_rreg((volatile uint32_t *)AR10_RCU_USB1CFG);
+		else
+			data = ltqusb_rreg((volatile uint32_t *)AR10_RCU_USB2CFG);
+		data = (data >> AR10_USBCFG_OC_HY_BIT ) & AR10_USBCFG_OC_HY_MASK;
+	}
+	return data;
+}
+
+void ltqusb_oc_set_hy(int port,uint32_t setting)
+{
+	if(ltqusb_chip_family== LTQUSB_CHIP_AR10)
+	{
+		uint32_t data;
+		if(port==1)
+			data = ltqusb_rreg((volatile uint32_t *)AR10_RCU_USB1CFG);
+		else
+			data = ltqusb_rreg((volatile uint32_t *)AR10_RCU_USB2CFG);
+
+		data &= (~(AR10_USBCFG_OC_HY_MASK << AR10_USBCFG_OC_HY_BIT));
+		data |= ((setting & AR10_USBCFG_OC_HY_MASK)<< AR10_USBCFG_OC_HY_BIT);
+
+		if(port==1)
+			ltqusb_wreg((volatile uint32_t *)AR10_RCU_USB1CFG,data);
+		else
+			ltqusb_wreg((volatile uint32_t *)AR10_RCU_USB2CFG, data);
+	}
+}
+
+void ltqusb_oc_int_free(int port)
+{
+	if(ltqusb_chip_family== LTQUSB_CHIP_AR10) // ar10
+	{
+		if(port==1)
+		{
+			del_timer(&oc1_retry_timer);
+			if(oc1_int_no>0)
+			{
+				disable_irq_nosync(oc1_int_no);
+				free_irq(oc1_int_no, (void *)oc1_int_target);
+			}
+			oc1_int_installed=0;
+		}
+		else
+		{
+			del_timer(&oc2_retry_timer);
+			if(oc2_int_no>0)
+			{
+				disable_irq_nosync(oc2_int_no);
+				free_irq(oc2_int_no, (void *)oc2_int_target);
+			}
+			oc2_int_installed=0;
+		}
+	}
+	else
+	{
+		del_timer(&oc1_retry_timer);
+		if(oc1_int_no>0)
+		{
+			disable_irq_nosync(oc1_int_no);
+			free_irq(oc1_int_no, (void *)oc1_int_target);
+		}
+		oc1_int_installed=0;
+	}
+}
+
+
--- a/drivers/usb/host/ltqusb_ctl.c
+++ b/drivers/usb/host/ltqusb_ctl.c
@@ -0,0 +1,3197 @@
+/*****************************************************************************
+ **   FILE NAME       : ltqusb_ctl.c
+ **   PROJECT         : Lantiq USB sub-system V3
+ **   MODULES         : Lantiq USB sub-system Host and Device driver
+ **   SRC VERSION     : 1.0
+ **   SRC VERSION     : 3.2
+ **   DATE            : 1/Jan/2011
+ **   DESCRIPTION     : Implementing the procfs and sysfs for Lantiq USB driver
+ **   FUNCTIONS       :
+ **   COMPILER        : gcc
+ **   REFERENCE       : Synopsys DWC-OTG Driver 2.7
+ **   COPYRIGHT       :  Copyright (c) 2010
+ **                      LANTIQ DEUTSCHLAND GMBH,
+ **                      Am Campeon 3, 85579 Neubiberg, Germany
+ **
+ **    This program is free software; you can redistribute it and/or modify
+ **    it under the terms of the GNU General Public License as published by
+ **    the Free Software Foundation; either version 2 of the License, or
+ **    (at your option) any later version.
+ **
+ **  Version Control Section  **
+ **   $Author$
+ **   $Date$
+ **   $Revisions$
+ **   $Log$       Revision history
+ *****************************************************************************/
+
+/*
+ * This file contains code fragments from Synopsys HS OTG Linux Software Driver.
+ * For this code the following notice is applicable:
+ *
+ * ==========================================================================
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/*! \file ltqusb_ctl.c
+  \ingroup LTQUSB_DRIVER_V3
+    \brief Implementing the procfs and sysfs for Lantiq USB driver
+*/
+
+#include <linux/version.h>
+#include "ltqusb_version.h"
+
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <asm/byteorder.h>
+#include <asm/unaligned.h>
+#include <asm/uaccess.h>
+
+#include "ltqusb_plat.h"
+#include "ltqusb_regs.h"
+#include "ltqusb_cif.h"
+
+#define __USE_PROCFS__ 1
+#define __USE_SYSFS__  1
+
+#include "ltqhcd.h"
+#ifdef __HOST_COC__
+	#ifdef __NEW_COC__
+		#include <ltq_lxfreq.h>
+		#include <linux/cpufreq.h>
+	#endif
+	LTQ_PMCU_REGISTER_t pmcuRegisterUSBHost_1;
+	LTQ_PMCU_REGISTER_t pmcuRegisterUSBHost_2;
+	unsigned char pmcuPowerFeatureUSBHost_1 = 1;
+	unsigned char pmcuPowerFeatureUSBHost_2 = 1;
+#endif
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/gfp.h>
+
+extern char ltqusb_hcd_driver_name[];
+
+extern ltqhcd_hcd_t ltqusb_hcd_1;
+extern ltqhcd_hcd_t ltqusb_hcd_2;
+extern char ltqusb_hcd_name_1[];
+extern char ltqusb_hcd_name_2[];
+
+#if defined(CONFIG_CPU_FREQ) && defined(__NEW_COC__)
+	/* Linux CPUFREQ support start */
+	#if defined(__HOST_COC__)
+		static LTQ_PMCU_RETURN_t ltq_usbhost_stateGet_1(LTQ_PMCU_STATE_t *pmcuModState);
+		static LTQ_PMCU_RETURN_t ltq_usbhost_pwrFeatureSwitch_1(LTQ_PMCU_PWR_STATE_ENA_t pmcuPwrStateEna);
+		static LTQ_PMCU_RETURN_t ltq_usbhost_preChange_1(LTQ_PMCU_MODULE_t pmcuModule, LTQ_PMCU_STATE_t newState, LTQ_PMCU_STATE_t oldState);
+		static LTQ_PMCU_RETURN_t ltq_usbhost_postChange_1(LTQ_PMCU_MODULE_t pmcuModule, LTQ_PMCU_STATE_t newState, LTQ_PMCU_STATE_t oldState);
+		static LTQ_PMCU_RETURN_t ltq_usbhost_stateChange_1(LTQ_PMCU_STATE_t newState);
+		static LTQ_PMCU_RETURN_t ltq_usbhost_stateGet_2(LTQ_PMCU_STATE_t *pmcuModState);
+		static LTQ_PMCU_RETURN_t ltq_usbhost_pwrFeatureSwitch_2(LTQ_PMCU_PWR_STATE_ENA_t pmcuPwrStateEna);
+		static LTQ_PMCU_RETURN_t ltq_usbhost_preChange_2(LTQ_PMCU_MODULE_t pmcuModule, LTQ_PMCU_STATE_t newState, LTQ_PMCU_STATE_t oldState);
+		static LTQ_PMCU_RETURN_t ltq_usbhost_postChange_2(LTQ_PMCU_MODULE_t pmcuModule, LTQ_PMCU_STATE_t newState, LTQ_PMCU_STATE_t oldState);
+		static LTQ_PMCU_RETURN_t ltq_usbhost_stateChange_2(LTQ_PMCU_STATE_t newState);
+		struct LTQ_LXFREQ_MODSTRUCT ltq_usbhost1_lxfreq_mod_g = {
+			.name							= "USB1 HOST power support",
+			.pmcuModule						= LTQ_PMCU_MODULE_USB,
+			.pmcuModuleNr					= 1,
+			.powerFeatureStat				= LTQ_PMCU_PWR_STATE_ON,
+			.ltq_lxfreq_state_get			= ltq_usbhost_stateGet_1,
+			.ltq_lxfreq_pwr_feature_switch	= ltq_usbhost_pwrFeatureSwitch_1,
+		};
+
+		struct LTQ_LXFREQ_MODSTRUCT ltq_usbhost2_lxfreq_mod_g = {
+			.name							= "USB2 HOST power support",
+			.pmcuModule						= LTQ_PMCU_MODULE_USB,
+			.pmcuModuleNr					= 2,
+			.powerFeatureStat				= LTQ_PMCU_PWR_STATE_ON,
+			.ltq_lxfreq_state_get			= ltq_usbhost_stateGet_2,
+			.ltq_lxfreq_pwr_feature_switch	= ltq_usbhost_pwrFeatureSwitch_2,
+		};
+	#endif //defined(__HOST_COC__)
+
+	extern struct list_head ltq_lxfreq_head_mod_list_g;
+
+#if 0 /*CPUFREQ*/
+	#if defined(__HOST_COC__)
+		static int
+		ltq_usbhost_1_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
+								 void *data);
+
+		static int ltq_usbhost_1_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
+										 void *data);
+		static struct notifier_block ltq_usbhost_1_cpufreq_notifier_block = {
+			.notifier_call  = ltq_usbhost_1_cpufreq_notifier
+		};
+
+		/* keep track of frequency transitions */
+		static int
+		ltq_usbhost_1_cpufreq_notifier(struct notifier_block *nb, unsigned long val, void *data)
+		{
+			struct cpufreq_freqs *freq = data;
+			LTQ_PMCU_STATE_t new_State,old_State;
+			LTQ_PMCU_RETURN_t ret = 0;
+			//u32 count_start;
+
+			new_State = ltq_lxfreq_get_ps_from_khz(freq->new);
+			if(new_State == LTQ_PMCU_STATE_INVALID) {
+				return NOTIFY_STOP_MASK | (LTQ_PMCU_MODULE_USB<<4);
+			}
+			old_State = ltq_lxfreq_get_ps_from_khz(freq->old);
+			if(old_State == LTQ_PMCU_STATE_INVALID) {
+				return NOTIFY_STOP_MASK | (LTQ_PMCU_MODULE_USB<<4);
+			}
+			if (val == CPUFREQ_PRECHANGE){
+				ret = ltq_usbhost_preChange_1(LTQ_PMCU_MODULE_USB, new_State, old_State);
+				if (ret == LTQ_PMCU_RETURN_DENIED) {
+					return NOTIFY_STOP_MASK | (LTQ_PMCU_MODULE_USB<<4);
+				}
+				//count_start = ltq_count0_read();
+				//ret = ltq_usbhost_stateChange_1(new_State);
+				//ltq_count0_diff(count_start, ltq_count0_read(),"USB_HOST_1_STATECHANGE");
+				if (ret == LTQ_PMCU_RETURN_DENIED) {
+					return NOTIFY_STOP_MASK | (LTQ_PMCU_MODULE_USB<<4);
+				}
+			} else if (val == CPUFREQ_POSTCHANGE){
+				ret = ltq_usbhost_postChange_1(LTQ_PMCU_MODULE_USB, new_State, old_State);
+				if (ret == LTQ_PMCU_RETURN_DENIED) {
+					return NOTIFY_STOP_MASK | (LTQ_PMCU_MODULE_USB<<4);
+				}
+			}else{
+				return NOTIFY_OK | (LTQ_PMCU_MODULE_USB<<4);
+			}
+			return NOTIFY_OK | (LTQ_PMCU_MODULE_USB<<4);
+		}
+
+		static int
+		ltq_usbhost_2_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
+								 void *data);
+
+		static int ltq_usbhost_2_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
+										 void *data);
+		static struct notifier_block ltq_usbhost_2_cpufreq_notifier_block = {
+			.notifier_call  = ltq_usbhost_2_cpufreq_notifier
+		};
+
+		/* keep track of frequency transitions */
+		static int
+		ltq_usbhost_2_cpufreq_notifier(struct notifier_block *nb, unsigned long val, void *data)
+		{
+			struct cpufreq_freqs *freq = data;
+			LTQ_PMCU_STATE_t new_State,old_State;
+			LTQ_PMCU_RETURN_t ret = 0;
+			//u32 count_start;
+
+			new_State = ltq_lxfreq_get_ps_from_khz(freq->new);
+			if(new_State == LTQ_PMCU_STATE_INVALID) {
+				return NOTIFY_STOP_MASK | (LTQ_PMCU_MODULE_USB<<4);
+			}
+			old_State = ltq_lxfreq_get_ps_from_khz(freq->old);
+			if(old_State == LTQ_PMCU_STATE_INVALID) {
+				return NOTIFY_STOP_MASK | (LTQ_PMCU_MODULE_USB<<4);
+			}
+			if (val == CPUFREQ_PRECHANGE){
+				ret = ltq_usbhost_preChange_2(LTQ_PMCU_MODULE_USB, new_State, old_State);
+				if (ret == LTQ_PMCU_RETURN_DENIED) {
+					return NOTIFY_STOP_MASK | (LTQ_PMCU_MODULE_USB<<4);
+				}
+				//count_start = ltq_count0_read();
+				//ret = ltq_usbhost_stateChange_2(new_State);
+				//ltq_count0_diff(count_start, ltq_count0_read(),"USB_HOST_2_STATECHANGE");
+				if (ret == LTQ_PMCU_RETURN_DENIED) {
+					return NOTIFY_STOP_MASK | (LTQ_PMCU_MODULE_USB<<4);
+				}
+			} else if (val == CPUFREQ_POSTCHANGE){
+				ret = ltq_usbhost_postChange_2(LTQ_PMCU_MODULE_USB, new_State, old_State);
+				if (ret == LTQ_PMCU_RETURN_DENIED) {
+					return NOTIFY_STOP_MASK | (LTQ_PMCU_MODULE_USB<<4);
+				}
+			}else{
+				return NOTIFY_OK | (LTQ_PMCU_MODULE_USB<<4);
+			}
+			return NOTIFY_OK | (LTQ_PMCU_MODULE_USB<<4);
+		}
+	#endif //defined(__HOST_COC__)
+#endif /*CPUFREQ*/
+/* Linux CPUFREQ support end */
+#endif //defined(CONFIG_CPU_FREQ) && defined(__NEW_COC__)
+
+
+
+#ifdef __USE_PROCFS__
+	static int procfs_rw_open(struct inode *inode, struct file *filp)
+	{
+//		try_module_get(THIS_MODULE);
+		return 0;
+	}
+#endif //__USE_PROCFS__
+
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// PROCSYSFS:  VERSION
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+#ifdef __USE_PROCFS__
+	static int procfs_version_show(struct seq_file *filp, void *offset){ seq_printf(filp, "%s\n",LTQUSB_VERSION );return 0;}
+	static int procfs_version_open(struct inode *inode, struct file *filp){ return single_open(filp, procfs_version_show, NULL);}
+	static const struct file_operations procfs_version_fops={
+	 	.open		= procfs_version_open,
+	 	.read		= seq_read,
+	 	.llseek		= seq_lseek,
+	};
+#endif //__USE_PROCFS__
+
+#ifdef __USE_SYSFS__
+	static ssize_t sysfs_version_show( struct device *_dev, struct device_attribute *attr,char *buf) { 	return sprintf( buf, "%s\n",LTQUSB_VERSION ); }
+	extern struct device_attribute dev_attr_version_h;
+	DEVICE_ATTR(version_h, S_IRUGO, sysfs_version_show, NULL);
+#endif //__USE_SYSFS__
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// e/PROCSYSFS:  VERSION
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// PROCSYSFS:  DBGLEVEL
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+#ifdef __USE_PROCFS__
+	static ssize_t procfs_dbglevel_show(struct file *filp, char *buf, size_t length, loff_t *offset)
+	{
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf( buf, "%08X\n",h_dbg_lvl );
+	}
+
+	static ssize_t procfs_dbglevel_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buffer, &buf[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 16);
+		h_dbg_lvl =value;
+		return length;
+	}
+
+	static const struct file_operations procfs_dbglevel_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_dbglevel_show,
+		.write 	= procfs_dbglevel_store,
+	};
+
+#endif //__USE_PROCFS__
+
+#ifdef __USE_SYSFS__
+	static ssize_t sysfs_dbglevel_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return sprintf( buf, "%08X\n",h_dbg_lvl );
+	}
+
+	static ssize_t sysfs_dbglevel_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 16);
+		h_dbg_lvl =value;
+		return count;
+	}
+	extern struct device_attribute dev_attr_dbglevel_h;
+	DEVICE_ATTR(dbglevel_h, S_IRUGO|S_IWUSR, sysfs_dbglevel_show, sysfs_dbglevel_store);
+#endif //__USE_SYSFS__
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// e/PROCSYSFS:  DBGLEVEL
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// PROCSYSFS:  DUMP_PARAMS MODE
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+static void ltqusb_dump_params(ltqusb_core_if_t *_core_if);
+
+static ssize_t dump_params_1(void)	{ ltqusb_dump_params(&ltqusb_hcd_1.core_if); return 0;}
+static ssize_t dump_params_2(void)	{ ltqusb_dump_params(&ltqusb_hcd_2.core_if); return 0;}
+
+#ifdef __USE_PROCFS__
+	static int procfs_dump_params_show_1(struct seq_file *filp, void *offset){ dump_params_1();return 0;}
+	static int procfs_dump_params_show_2(struct seq_file *filp, void *offset){ dump_params_2();return 0;}
+	static int procfs_dump_params_open_1(struct inode *inode, struct file *filp) { return single_open(filp, procfs_dump_params_show_1, NULL);}
+	static int procfs_dump_params_open_2(struct inode *inode, struct file *filp) { return single_open(filp, procfs_dump_params_show_2, NULL);}
+	static const struct file_operations procfs_dump_params_fops_1={
+	 	.open		= procfs_dump_params_open_1,
+	 	.read		= seq_read,
+	 	.llseek		= seq_lseek,
+	};
+	static const struct file_operations procfs_dump_params_fops_2={
+	 	.open		= procfs_dump_params_open_2,
+	 	.read		= seq_read,
+	 	.llseek		= seq_lseek,
+	};
+
+	static int procfs_mode_show_1(struct seq_file *filp, void *offset)
+	{
+		if((ltqusb_rreg(&ltqusb_hcd_1.core_if.core_global_regs->gintsts ) & 0x1) == 1)
+			seq_printf(filp, "HOST\n" );
+		else
+			seq_printf(filp, "DEVICE(INCORRECT!)\n" );
+		return 0;
+	}
+	static int procfs_mode_show_2(struct seq_file *filp, void *offset)
+	{
+		if((ltqusb_rreg(&ltqusb_hcd_2.core_if.core_global_regs->gintsts ) & 0x1) == 1)
+			seq_printf(filp, "HOST\n" );
+		else
+			seq_printf(filp, "DEVICE(INCORRECT!)\n" );
+		return 0;
+	}
+	static int procfs_mode_open_1(struct inode *inode, struct file *filp) { return single_open(filp, procfs_mode_show_1, NULL);}
+	static int procfs_mode_open_2(struct inode *inode, struct file *filp) { return single_open(filp, procfs_mode_show_2, NULL);}
+	static const struct file_operations procfs_mode_fops_1=
+	{
+	 	.open		= procfs_mode_open_1,
+	 	.read		= seq_read,
+	 	.llseek		= seq_lseek,
+	};
+	static const struct file_operations procfs_mode_fops_2=
+	{
+	 	.open		= procfs_mode_open_2,
+	 	.read		= seq_read,
+	 	.llseek		= seq_lseek,
+	};
+#endif //__USE_PROCFS__
+
+#ifdef __USE_SYSFS__
+	static ssize_t sysfs_dump_params_show_1( struct device *_dev, struct device_attribute *attr,char *buf) { return dump_params_1();}
+	static ssize_t sysfs_dump_params_show_2( struct device *_dev, struct device_attribute *attr,char *buf) { return dump_params_2();}
+
+	static ssize_t sysfs_mode_show_1( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		if((ltqusb_rreg(&ltqusb_hcd_1.core_if.core_global_regs->gintsts ) & 0x1) == 1)
+			return sprintf( buf, "HOST\n" );
+		else
+			return sprintf( buf, "DEVICE(INCORRECT!)\n" );
+	}
+	static ssize_t sysfs_mode_show_2( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		if((ltqusb_rreg(&ltqusb_hcd_2.core_if.core_global_regs->gintsts ) & 0x1) == 1)
+			return sprintf( buf, "HOST\n" );
+		else
+			return sprintf( buf, "DEVICE(INCORRECT!)\n" );
+	}
+
+	extern struct device_attribute dev_attr_dump_params_h_1;
+	extern struct device_attribute dev_attr_dump_params_h_2;
+	DEVICE_ATTR(dump_params_h_1, S_IRUGO, sysfs_dump_params_show_1, NULL);
+	DEVICE_ATTR(dump_params_h_2, S_IRUGO, sysfs_dump_params_show_2, NULL);
+
+	extern struct device_attribute dev_attr_mode_h_1;
+	extern struct device_attribute dev_attr_mode_h_2;
+	DEVICE_ATTR(mode_h_1, S_IRUGO, sysfs_mode_show_1, NULL);
+	DEVICE_ATTR(mode_h_2, S_IRUGO, sysfs_mode_show_2, NULL);
+#endif //__USE_SYSFS__
+////////////////////////////////////////////////////////////////////////////////////////////////////
+// e/PROCSYSFS:  DUMP_PARAMS MODE
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// PROCSYSFS:  HOST STATUS
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+#ifdef __USE_PROCFS__
+	static int procfs_host_port_status_show_1(struct seq_file *filp, void *offset)
+	{
+		hprt0_data_t val;
+		val.d32 = ltqusb_rreg(ltqusb_hcd_1.core_if.hprt0);
+		seq_printf(filp, "Suspended = 0x%x, Connected = 0x%x, Speed = %s(%d)\n"
+			, val.b.prtsusp
+			, val.b.prtconnsts
+			,(val.b.prtspd ==0)?"High":((val.b.prtspd ==1)?"Full":((val.b.prtspd ==2)?"Low":"Unknown"))
+			,val.b.prtspd
+			);
+		return 0;
+	}
+	static int procfs_host_port_status_show_2(struct seq_file *filp, void *offset)
+	{
+		hprt0_data_t val;
+		val.d32 = ltqusb_rreg(ltqusb_hcd_2.core_if.hprt0);
+		seq_printf(filp, "Suspended = 0x%x, Connected = 0x%x, Speed = %s(%d)\n"
+			, val.b.prtsusp
+			, val.b.prtconnsts
+			,(val.b.prtspd ==0)?"High":((val.b.prtspd ==1)?"Full":((val.b.prtspd ==2)?"Low":"Unknown"))
+			,val.b.prtspd
+			);
+		return 0;
+	}
+	static int procfs_host_port_status_open_1(struct inode *inode, struct file *filp) {	return single_open(filp, procfs_host_port_status_show_1, NULL); }
+	static int procfs_host_port_status_open_2(struct inode *inode, struct file *filp) {	return single_open(filp, procfs_host_port_status_show_2, NULL); }
+	static const struct file_operations procfs_host_port_status_fops_1= {
+ 		.open		= procfs_host_port_status_open_1,
+ 		.read		= seq_read,
+ 		.llseek		= seq_lseek,
+	};
+	static const struct file_operations procfs_host_port_status_fops_2= {
+ 		.open		= procfs_host_port_status_open_2,
+ 		.read		= seq_read,
+ 		.llseek		= seq_lseek,
+	};
+#endif //__USE_PROCFS__
+#ifdef __USE_SYSFS__
+	static ssize_t sysfs_host_port_status_show_1( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		hprt0_data_t val;
+		val.d32 = ltqusb_rreg(ltqusb_hcd_1.core_if.hprt0);
+		return sprintf (buf, "Suspended = 0x%x, Connected = 0x%x, Speed = %s(%d)\n"
+			, val.b.prtsusp
+			, val.b.prtconnsts
+			,(val.b.prtspd ==0)?"High":((val.b.prtspd ==1)?"Full":((val.b.prtspd ==2)?"Low":"Unknown"))
+			,val.b.prtspd
+			);
+	}
+	static ssize_t sysfs_host_port_status_show_2( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		hprt0_data_t val;
+		val.d32 = ltqusb_rreg(ltqusb_hcd_2.core_if.hprt0);
+		return sprintf (buf, "Suspended = 0x%x, Connected = 0x%x, Speed = %s(%d)\n"
+			, val.b.prtsusp
+			, val.b.prtconnsts
+			,(val.b.prtspd ==0)?"High":((val.b.prtspd ==1)?"Full":((val.b.prtspd ==2)?"Low":"Unknown"))
+			,val.b.prtspd
+			);
+	}
+	extern struct device_attribute dev_attr_host_port_status_1;
+	extern struct device_attribute dev_attr_host_port_status_2;
+	DEVICE_ATTR(host_port_status_1, S_IRUGO, sysfs_host_port_status_show_1, NULL);
+	DEVICE_ATTR(host_port_status_2, S_IRUGO, sysfs_host_port_status_show_2, NULL);
+#endif //__USE_SYSFS__
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// e/PROCSYSFS:  HOST STATUS
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// PROCSYSFS:  DUMP
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+#ifdef __ENABLE_DUMP__
+	static void dump_reg_1(void) { ltqusb_dump_registers_h(&ltqusb_hcd_1.core_if); }
+	static void dump_reg_2(void) { ltqusb_dump_registers_h(&ltqusb_hcd_2.core_if); }
+	static void dump_spram_1(void) { ltqusb_dump_spram_h(&ltqusb_hcd_1.core_if); }
+	static void dump_spram_2(void) { ltqusb_dump_spram_h(&ltqusb_hcd_2.core_if); }
+	static void dump_host_state_1(void) { ltqhcd_dump_state(&ltqusb_hcd_1); }
+	static void dump_host_state_2(void) { ltqhcd_dump_state(&ltqusb_hcd_2); }
+
+	#ifdef __USE_PROCFS__
+		static ssize_t procfs_dump_reg_h_show_1(struct seq_file *filp, void *offset){ dump_reg_1();return 0;}
+		static ssize_t procfs_dump_reg_h_show_2(struct seq_file *filp, void *offset){ dump_reg_2();return 0;}
+		static int procfs_dump_reg_h_open_1(struct inode *inode, struct file *filp) { return single_open(filp, procfs_dump_reg_h_show_1, NULL);}
+		static int procfs_dump_reg_h_open_2(struct inode *inode, struct file *filp) { return single_open(filp, procfs_dump_reg_h_show_2, NULL);}
+		static const struct file_operations procfs_dump_reg_h_fops_1= {
+	 		.open		= procfs_dump_reg_h_open_1,
+	 		.read		= seq_read,
+	 		.llseek		= seq_lseek,
+		};
+		static const struct file_operations procfs_dump_reg_h_fops_2= {
+	 		.open		= procfs_dump_reg_h_open_2,
+	 		.read		= seq_read,
+	 		.llseek		= seq_lseek,
+		};
+
+		static ssize_t procfs_dump_spram_h_show_1(struct seq_file *filp, void *offset){ dump_spram_1();return 0;}
+		static ssize_t procfs_dump_spram_h_show_2(struct seq_file *filp, void *offset){ dump_spram_2();return 0;}
+		static int procfs_dump_spram_h_open_1(struct inode *inode, struct file *filp) { return single_open(filp, procfs_dump_spram_h_show_1, NULL);}
+		static int procfs_dump_spram_h_open_2(struct inode *inode, struct file *filp) { return single_open(filp, procfs_dump_spram_h_show_2, NULL);}
+		static const struct file_operations procfs_dump_spram_h_fops_1= {
+	 		.open		= procfs_dump_spram_h_open_1,
+	 		.read		= seq_read,
+	 		.llseek		= seq_lseek,
+		};
+		static const struct file_operations procfs_dump_spram_h_fops_2= {
+	 		.open		= procfs_dump_spram_h_open_2,
+	 		.read		= seq_read,
+	 		.llseek		= seq_lseek,
+		};
+
+		static ssize_t procfs_dump_host_state_show_1(struct seq_file *filp, void *offset){ dump_host_state_1();return 0;}
+		static ssize_t procfs_dump_host_state_show_2(struct seq_file *filp, void *offset){ dump_host_state_2();return 0;}
+		static int procfs_dump_host_state_open_1(struct inode *inode, struct file *filp) { return single_open(filp, procfs_dump_host_state_show_1, NULL);}
+		static int procfs_dump_host_state_open_2(struct inode *inode, struct file *filp) { return single_open(filp, procfs_dump_host_state_show_2, NULL);}
+		static const struct file_operations procfs_dump_host_state_fops_1= {
+	 		.open		= procfs_dump_host_state_open_1,
+	 		.read		= seq_read,
+	 		.llseek		= seq_lseek,
+		};
+		static const struct file_operations procfs_dump_host_state_fops_2= {
+	 		.open		= procfs_dump_host_state_open_2,
+	 		.read		= seq_read,
+	 		.llseek		= seq_lseek,
+		};
+	#endif //__USE_PROCFS__
+	#ifdef __USE_SYSFS__
+		static ssize_t sysfs_dump_reg_h_show_1( struct device *_dev, struct device_attribute *attr,char *buf) { dump_reg_1();return 0;}
+		static ssize_t sysfs_dump_reg_h_show_2( struct device *_dev, struct device_attribute *attr,char *buf) { dump_reg_2();return 0;}
+		extern struct device_attribute dev_attr_dump_reg_h_1;
+		extern struct device_attribute dev_attr_dump_reg_h_2;
+		DEVICE_ATTR(dump_reg_h_1, S_IRUGO, sysfs_dump_reg_h_show_1, NULL);
+		DEVICE_ATTR(dump_reg_h_2, S_IRUGO, sysfs_dump_reg_h_show_2, NULL);
+		static ssize_t sysfs_dump_spram_h_show_1( struct device *_dev, struct device_attribute *attr,char *buf) { dump_spram_1();return 0;}
+		static ssize_t sysfs_dump_spram_h_show_2( struct device *_dev, struct device_attribute *attr,char *buf) { dump_spram_2();return 0;}
+		extern struct device_attribute dev_attr_dump_spram_h_1;
+		extern struct device_attribute dev_attr_dump_spram_h_2;
+		DEVICE_ATTR(dump_spram_h_1, S_IRUGO, sysfs_dump_spram_h_show_1, NULL);
+		DEVICE_ATTR(dump_spram_h_2, S_IRUGO, sysfs_dump_spram_h_show_2, NULL);
+
+		static ssize_t sysfs_dump_host_state_show_1( struct device *_dev, struct device_attribute *attr,char *buf) { dump_host_state_1();return 0;}
+		static ssize_t sysfs_dump_host_state_show_2( struct device *_dev, struct device_attribute *attr,char *buf) { dump_host_state_2();return 0;}
+		extern struct device_attribute dev_attr_dump_host_state_1;
+		extern struct device_attribute dev_attr_dump_host_state_2;
+		DEVICE_ATTR(dump_host_state_1, S_IRUGO, sysfs_dump_host_state_show_1, NULL);
+		DEVICE_ATTR(dump_host_state_2, S_IRUGO, sysfs_dump_host_state_show_2, NULL);
+	#endif //__USE_SYSFS__
+#endif //__ENABLE_DUMP__
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// e/PROCSYSFS:  DUMP
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// PROCSYSFS:  ANA
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+static uint32_t ana_read(ltqusb_core_if_t *_core_if)
+{
+	if(ltqusb_chip_family== LTQUSB_CHIP_VR9)
+	{
+		if(_core_if->core_no==0) return (ltqusb_rreg(((volatile uint32_t *)VR9_RCU_USB_ANA_CFG1A)));
+		else                     return (ltqusb_rreg(((volatile uint32_t *)VR9_RCU_USB_ANA_CFG1B)));
+	}
+	if(ltqusb_chip_family== LTQUSB_CHIP_AR10)
+	{
+		if(_core_if->core_no==0) return (ltqusb_rreg(((volatile uint32_t *)AR10_RCU_USB_ANA_CFG1A)));
+		else                     return (ltqusb_rreg(((volatile uint32_t *)AR10_RCU_USB_ANA_CFG1B)));
+	}
+	return 0xFFFFFFFF;
+}
+static void ana_write(ltqusb_core_if_t *_core_if,uint32_t data)
+{
+	if(ltqusb_chip_family== LTQUSB_CHIP_VR9)
+	{
+		if(_core_if->core_no==0) ltqusb_wreg(((volatile uint32_t *)VR9_RCU_USB_ANA_CFG1A),data);
+		else                     ltqusb_wreg(((volatile uint32_t *)VR9_RCU_USB_ANA_CFG1B),data);
+	}
+	if(ltqusb_chip_family== LTQUSB_CHIP_AR10)
+	{
+		if(_core_if->core_no==0) ltqusb_wreg(((volatile uint32_t *)AR10_RCU_USB_ANA_CFG1A),data);
+		else                     ltqusb_wreg(((volatile uint32_t *)AR10_RCU_USB_ANA_CFG1B),data);
+	}
+}
+static int ana_read_disconnect_threshold(ltqusb_core_if_t *_core_if)
+{
+	volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+	rcu_ana_cfg1.d32=ana_read(_core_if);
+	return (int)(rcu_ana_cfg1.b.dis_thr);
+}
+static void ana_write_disconnect_threshold(ltqusb_core_if_t *_core_if,int value)
+{
+	if( value>=0 && value <= 7 )
+	{
+		volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+		rcu_ana_cfg1.d32=ana_read(_core_if);
+		rcu_ana_cfg1.b.dis_thr=value;
+		ana_write(_core_if,rcu_ana_cfg1.d32);
+		_core_if->params.ana_disconnect_threshold=(int)value;
+	}
+}
+static int ana_read_squelch_threshold(ltqusb_core_if_t *_core_if)
+{
+	volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+	rcu_ana_cfg1.d32=ana_read(_core_if);
+	return (int)(rcu_ana_cfg1.b.squs_thr);
+}
+static void ana_write_squelch_threshold(ltqusb_core_if_t *_core_if,int value)
+{
+	if( value>=0 && value <= 7 )
+	{
+		volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+		rcu_ana_cfg1.d32=ana_read(_core_if);
+		rcu_ana_cfg1.b.squs_thr=value;
+		ana_write(_core_if,rcu_ana_cfg1.d32);
+		_core_if->params.ana_squelch_threshold=(int)value;
+	}
+}
+static int ana_read_transmitter_crossover(ltqusb_core_if_t *_core_if)
+{
+	volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+	rcu_ana_cfg1.d32=ana_read(_core_if);
+	return (int)(rcu_ana_cfg1.b.txhs_xv);
+}
+static void ana_write_transmitter_crossover(ltqusb_core_if_t *_core_if,int value)
+{
+	if( value>=0 && value <= 3 )
+	{
+		volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+		rcu_ana_cfg1.d32=ana_read(_core_if);
+		rcu_ana_cfg1.b.txhs_xv=value;
+		ana_write(_core_if,rcu_ana_cfg1.d32);
+		_core_if->params.ana_transmitter_crossover=(int)value;
+	}
+}
+static int ana_read_transmitter_impedance(ltqusb_core_if_t *_core_if)
+{
+	volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+	rcu_ana_cfg1.d32=ana_read(_core_if);
+	return (int)(rcu_ana_cfg1.b.txsrci_xv);
+}
+static void ana_write_transmitter_impedance(ltqusb_core_if_t *_core_if,int value)
+{
+	if( value>=0 && value <= 15 )
+	{
+		volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+		rcu_ana_cfg1.d32=ana_read(_core_if);
+		rcu_ana_cfg1.b.txsrci_xv=value;
+		ana_write(_core_if,rcu_ana_cfg1.d32);
+		_core_if->params.ana_transmitter_impedance=(int)value;
+	}
+}
+static int ana_read_transmitter_dc_voltage(ltqusb_core_if_t *_core_if)
+{
+	volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+	rcu_ana_cfg1.d32=ana_read(_core_if);
+	return (int)(rcu_ana_cfg1.b.txhs_dc);
+}
+static void ana_write_transmitter_dc_voltage(ltqusb_core_if_t *_core_if,int value)
+{
+	if( value>=0 && value <= 15 )
+	{
+		volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+		rcu_ana_cfg1.d32=ana_read(_core_if);
+		rcu_ana_cfg1.b.txhs_dc=value;
+		ana_write(_core_if,rcu_ana_cfg1.d32);
+		_core_if->params.ana_transmitter_dc_voltage=(int)value;
+	}
+}
+static int ana_read_transmitter_risefall_time(ltqusb_core_if_t *_core_if)
+{
+	volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+	rcu_ana_cfg1.d32=ana_read(_core_if);
+	return (int)(rcu_ana_cfg1.b.tx_edge);
+}
+static void ana_write_transmitter_risefall_time(ltqusb_core_if_t *_core_if,int value)
+{
+	if( value>=0 && value <= 1 )
+	{
+		volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+		rcu_ana_cfg1.d32=ana_read(_core_if);
+		rcu_ana_cfg1.b.tx_edge=value;
+		ana_write(_core_if,rcu_ana_cfg1.d32);
+		_core_if->params.ana_transmitter_risefall_time=(int)value;
+	}
+}
+static int ana_read_transmitter_pre_emphasis(ltqusb_core_if_t *_core_if)
+{
+	volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+	rcu_ana_cfg1.d32=ana_read(_core_if);
+	return (int)(rcu_ana_cfg1.b.tx_pee);
+}
+static void ana_write_transmitter_pre_emphasis(ltqusb_core_if_t *_core_if,int value)
+{
+	if( value>=0 && value <= 1 )
+	{
+		volatile rcu_ana_cfg1_data_t rcu_ana_cfg1 = {.d32=0};
+		rcu_ana_cfg1.d32=ana_read(_core_if);
+		rcu_ana_cfg1.b.tx_pee=value;
+		ana_write(_core_if,rcu_ana_cfg1.d32);
+		_core_if->params.ana_transmitter_pre_emphasis=(int)value;
+	}
+}
+#ifdef __USE_PROCFS__
+	static ssize_t procfs_ana_disconnect_threshold_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 1 Disconnect Threshold %d\n",ana_read_disconnect_threshold(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t procfs_ana_disconnect_threshold_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 2 Disconnect Threshold %d\n",ana_read_disconnect_threshold(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t procfs_ana_disconnect_threshold_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_disconnect_threshold(&ltqusb_hcd_1.core_if,value);
+		return length;
+	}
+	static ssize_t procfs_ana_disconnect_threshold_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_disconnect_threshold(&ltqusb_hcd_2.core_if,value);
+		return length;
+	}
+	static const struct file_operations procfs_ana_disconnect_threshold_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_disconnect_threshold_1_show,
+		.write 	= procfs_ana_disconnect_threshold_1_store,
+	};
+	static const struct file_operations procfs_ana_disconnect_threshold_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_disconnect_threshold_2_show,
+		.write 	= procfs_ana_disconnect_threshold_2_store,
+	};
+
+	static ssize_t procfs_ana_squelch_threshold_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 1 Squelch Threshold %d\n",ana_read_squelch_threshold(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t procfs_ana_squelch_threshold_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 2 Squelch Threshold %d\n",ana_read_squelch_threshold(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t procfs_ana_squelch_threshold_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_squelch_threshold(&ltqusb_hcd_1.core_if,value);
+		return length;
+	}
+	static ssize_t procfs_ana_squelch_threshold_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+				return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_squelch_threshold(&ltqusb_hcd_2.core_if,value);
+		return length;
+	}
+	static const struct file_operations procfs_ana_squelch_threshold_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_squelch_threshold_1_show,
+		.write 	= procfs_ana_squelch_threshold_1_store,
+	};
+	static const struct file_operations procfs_ana_squelch_threshold_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_squelch_threshold_2_show,
+		.write 	= procfs_ana_squelch_threshold_2_store,
+	};
+
+	static ssize_t procfs_ana_transmitter_crossover_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 1 Transmitter High Speed Crossover %d\n",ana_read_transmitter_crossover(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t procfs_ana_transmitter_crossover_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 2 Transmitter High Speed Crossover %d\n",ana_read_transmitter_crossover(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t procfs_ana_transmitter_crossover_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+				return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_transmitter_crossover(&ltqusb_hcd_1.core_if,value);
+		return length;
+	}
+	static ssize_t procfs_ana_transmitter_crossover_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_transmitter_crossover(&ltqusb_hcd_2.core_if,value);
+		return length;
+	}
+	static const struct file_operations procfs_ana_transmitter_crossover_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_transmitter_crossover_1_show,
+		.write 	= procfs_ana_transmitter_crossover_1_store,
+	};
+	static const struct file_operations procfs_ana_transmitter_crossover_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_transmitter_crossover_2_show,
+		.write 	= procfs_ana_transmitter_crossover_2_store,
+	};
+
+	static ssize_t procfs_ana_transmitter_impedance_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 1 Transmitter Source Impedance %d\n",ana_read_transmitter_impedance(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t procfs_ana_transmitter_impedance_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 2 Transmitter Source Impedance %d\n",ana_read_transmitter_impedance(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t procfs_ana_transmitter_impedance_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_transmitter_impedance(&ltqusb_hcd_1.core_if,value);
+		return length;
+	}
+	static ssize_t procfs_ana_transmitter_impedance_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+				return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_transmitter_impedance(&ltqusb_hcd_2.core_if,value);
+		return length;
+	}
+	static const struct file_operations procfs_ana_transmitter_impedance_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_transmitter_impedance_1_show,
+		.write 	= procfs_ana_transmitter_impedance_1_store,
+	};
+	static const struct file_operations procfs_ana_transmitter_impedance_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_transmitter_impedance_2_show,
+		.write 	= procfs_ana_transmitter_impedance_2_store,
+	};
+
+	static ssize_t procfs_ana_transmitter_dc_voltage_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 1 Transmitter HS DC Voltage Level %d\n",ana_read_transmitter_dc_voltage(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t procfs_ana_transmitter_dc_voltage_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 2 Transmitter HS DC Voltage Level %d\n",ana_read_transmitter_dc_voltage(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t procfs_ana_transmitter_dc_voltage_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_transmitter_dc_voltage(&ltqusb_hcd_1.core_if,value);
+		return length;
+	}
+	static ssize_t procfs_ana_transmitter_dc_voltage_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_transmitter_dc_voltage(&ltqusb_hcd_2.core_if,value);
+		return length;
+	}
+	static const struct file_operations procfs_ana_transmitter_dc_voltage_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_transmitter_dc_voltage_1_show,
+		.write 	= procfs_ana_transmitter_dc_voltage_1_store,
+	};
+	static const struct file_operations procfs_ana_transmitter_dc_voltage_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_transmitter_dc_voltage_2_show,
+		.write 	= procfs_ana_transmitter_dc_voltage_2_store,
+	};
+	static ssize_t procfs_ana_transmitter_risefall_time_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 1 Transmitter HS Rise/Fall Time %d\n",ana_read_transmitter_risefall_time(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t procfs_ana_transmitter_risefall_time_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 2 Transmitter HS Rise/Fall Time %d\n",ana_read_transmitter_risefall_time(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t procfs_ana_transmitter_risefall_time_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_transmitter_risefall_time(&ltqusb_hcd_1.core_if,value);
+		return length;
+	}
+	static ssize_t procfs_ana_transmitter_risefall_time_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_transmitter_risefall_time(&ltqusb_hcd_2.core_if,value);
+		return length;
+	}
+	static const struct file_operations procfs_ana_transmitter_risefall_time_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_transmitter_risefall_time_1_show,
+		.write 	= procfs_ana_transmitter_risefall_time_1_store,
+	};
+	static const struct file_operations procfs_ana_transmitter_risefall_time_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_transmitter_risefall_time_2_show,
+		.write 	= procfs_ana_transmitter_risefall_time_2_store,
+	};
+
+	static ssize_t procfs_ana_transmitter_pre_emphasis_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 1 Transmitter HS Pre-Emphasis %d\n",ana_read_transmitter_pre_emphasis(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t procfs_ana_transmitter_pre_emphasis_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 2 Transmitter HS Pre-Emphasis %d\n",ana_read_transmitter_pre_emphasis(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t procfs_ana_transmitter_pre_emphasis_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_transmitter_pre_emphasis(&ltqusb_hcd_1.core_if,value);
+		return length;
+	}
+	static ssize_t procfs_ana_transmitter_pre_emphasis_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int value;
+		if (copy_from_user(buffer, buf, 7))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		ana_write_transmitter_pre_emphasis(&ltqusb_hcd_2.core_if,value);
+		return length;
+	}
+	static const struct file_operations procfs_ana_transmitter_pre_emphasis_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_transmitter_pre_emphasis_1_show,
+		.write 	= procfs_ana_transmitter_pre_emphasis_1_store,
+	};
+	static const struct file_operations procfs_ana_transmitter_pre_emphasis_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_ana_transmitter_pre_emphasis_2_show,
+		.write 	= procfs_ana_transmitter_pre_emphasis_2_store,
+	};
+
+#endif //__USE_PROCFS__
+#ifdef __USE_SYSFS__
+	static ssize_t sysfs_ana_disconnect_threshold_1_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 1 Disconnect Threshold %d\n",ana_read_disconnect_threshold(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t sysfs_ana_disconnect_threshold_2_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 2 Disconnect Threshold %d\n",ana_read_disconnect_threshold(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t sysfs_ana_disconnect_threshold_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_disconnect_threshold(&ltqusb_hcd_1.core_if,value);
+		return count;
+	}
+	static ssize_t sysfs_ana_disconnect_threshold_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_disconnect_threshold(&ltqusb_hcd_2.core_if,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_ana_disconnect_threshold_1;
+	extern struct device_attribute dev_attr_ana_disconnect_threshold_2;
+	DEVICE_ATTR(ana_disconnect_threshold_1, S_IRUGO|S_IWUSR, sysfs_ana_disconnect_threshold_1_show, sysfs_ana_disconnect_threshold_1_store);
+	DEVICE_ATTR(ana_disconnect_threshold_2, S_IRUGO|S_IWUSR, sysfs_ana_disconnect_threshold_2_show, sysfs_ana_disconnect_threshold_2_store);
+
+	static ssize_t sysfs_ana_squelch_threshold_1_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 1 Squelch Threshold %d\n",ana_read_squelch_threshold(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t sysfs_ana_squelch_threshold_2_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 2 Squelch Threshold %d\n",ana_read_squelch_threshold(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t sysfs_ana_squelch_threshold_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+		return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_squelch_threshold(&ltqusb_hcd_1.core_if,value);
+		return count;
+	}
+	static ssize_t sysfs_ana_squelch_threshold_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_squelch_threshold(&ltqusb_hcd_2.core_if,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_ana_squelch_threshold_1;
+	extern struct device_attribute dev_attr_ana_squelch_threshold_2;
+	DEVICE_ATTR(ana_squelch_threshold_1, S_IRUGO|S_IWUSR, sysfs_ana_squelch_threshold_1_show, sysfs_ana_squelch_threshold_1_store);
+	DEVICE_ATTR(ana_squelch_threshold_2, S_IRUGO|S_IWUSR, sysfs_ana_squelch_threshold_2_show, sysfs_ana_squelch_threshold_2_store);
+
+	static ssize_t sysfs_ana_transmitter_crossover_1_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 1 Transmitter High Speed Crossover %d\n",ana_read_transmitter_crossover(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t sysfs_ana_transmitter_crossover_2_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 2 Transmitter High Speed Crossover %d\n",ana_read_transmitter_crossover(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t sysfs_ana_transmitter_crossover_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_transmitter_crossover(&ltqusb_hcd_1.core_if,value);
+		return count;
+	}
+	static ssize_t sysfs_ana_transmitter_crossover_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_transmitter_crossover(&ltqusb_hcd_2.core_if,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_ana_transmitter_crossover_1;
+	extern struct device_attribute dev_attr_ana_transmitter_crossover_2;
+	DEVICE_ATTR(ana_transmitter_crossover_1, S_IRUGO|S_IWUSR, sysfs_ana_transmitter_crossover_1_show, sysfs_ana_transmitter_crossover_1_store);
+	DEVICE_ATTR(ana_transmitter_crossover_2, S_IRUGO|S_IWUSR, sysfs_ana_transmitter_crossover_2_show, sysfs_ana_transmitter_crossover_2_store);
+
+	static ssize_t sysfs_ana_transmitter_impedance_1_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 1 Transmitter Source Impedance %d\n",ana_read_transmitter_impedance(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t sysfs_ana_transmitter_impedance_2_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 2 Transmitter Source Impedance %d\n",ana_read_transmitter_impedance(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t sysfs_ana_transmitter_impedance_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_transmitter_impedance(&ltqusb_hcd_1.core_if,value);
+		return count;
+	}
+	static ssize_t sysfs_ana_transmitter_impedance_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_transmitter_impedance(&ltqusb_hcd_2.core_if,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_ana_transmitter_impedance_1;
+	extern struct device_attribute dev_attr_ana_transmitter_impedance_2;
+	DEVICE_ATTR(ana_transmitter_impedance_1, S_IRUGO|S_IWUSR, sysfs_ana_transmitter_impedance_1_show, sysfs_ana_transmitter_impedance_1_store);
+	DEVICE_ATTR(ana_transmitter_impedance_2, S_IRUGO|S_IWUSR, sysfs_ana_transmitter_impedance_2_show, sysfs_ana_transmitter_impedance_2_store);
+
+	static ssize_t sysfs_ana_transmitter_dc_voltage_1_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 1 Transmitter HS DC Voltage Level %d\n",ana_read_transmitter_dc_voltage(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t sysfs_ana_transmitter_dc_voltage_2_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 2 Transmitter HS DC Voltage Level %d\n",ana_read_transmitter_dc_voltage(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t sysfs_ana_transmitter_dc_voltage_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_transmitter_dc_voltage(&ltqusb_hcd_1.core_if,value);
+		return count;
+	}
+	static ssize_t sysfs_ana_transmitter_dc_voltage_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_transmitter_dc_voltage(&ltqusb_hcd_2.core_if,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_ana_transmitter_dc_voltage_1;
+	extern struct device_attribute dev_attr_ana_transmitter_dc_voltage_2;
+	DEVICE_ATTR(ana_transmitter_dc_voltage_1, S_IRUGO|S_IWUSR, sysfs_ana_transmitter_dc_voltage_1_show, sysfs_ana_transmitter_dc_voltage_1_store);
+	DEVICE_ATTR(ana_transmitter_dc_voltage_2, S_IRUGO|S_IWUSR, sysfs_ana_transmitter_dc_voltage_2_show, sysfs_ana_transmitter_dc_voltage_2_store);
+
+	static ssize_t sysfs_ana_transmitter_risefall_time_1_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 1 Transmitter HS Rise/Fall Time %d\n",ana_read_transmitter_risefall_time(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t sysfs_ana_transmitter_risefall_time_2_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 2 Transmitter HS Rise/Fall Time %d\n",ana_read_transmitter_risefall_time(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t sysfs_ana_transmitter_risefall_time_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_transmitter_risefall_time(&ltqusb_hcd_1.core_if,value);
+		return count;
+	}
+	static ssize_t sysfs_ana_transmitter_risefall_time_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_transmitter_risefall_time(&ltqusb_hcd_2.core_if,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_ana_transmitter_risefall_time_1;
+	extern struct device_attribute dev_attr_ana_transmitter_risefall_time_2;
+	DEVICE_ATTR(ana_transmitter_risefall_time_1, S_IRUGO|S_IWUSR, sysfs_ana_transmitter_risefall_time_1_show, sysfs_ana_transmitter_risefall_time_1_store);
+	DEVICE_ATTR(ana_transmitter_risefall_time_2, S_IRUGO|S_IWUSR, sysfs_ana_transmitter_risefall_time_2_show, sysfs_ana_transmitter_risefall_time_2_store);
+
+	static ssize_t sysfs_ana_transmitter_pre_emphasis_1_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 1 Transmitter HS Pre-Emphasis %d\n",ana_read_transmitter_pre_emphasis(&ltqusb_hcd_1.core_if));
+	}
+	static ssize_t sysfs_ana_transmitter_pre_emphasis_2_show( struct device *_dev, struct device_attribute *attr,char *buf){
+		return sprintf (buf,"Host 2 Transmitter HS Pre-Emphasis %d\n",ana_read_transmitter_pre_emphasis(&ltqusb_hcd_2.core_if));
+	}
+	static ssize_t sysfs_ana_transmitter_pre_emphasis_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_transmitter_pre_emphasis(&ltqusb_hcd_1.core_if,value);
+		return count;
+	}
+	static ssize_t sysfs_ana_transmitter_pre_emphasis_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int value;
+		if (copy_from_user(buf, buffer, 7))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		ana_write_transmitter_pre_emphasis(&ltqusb_hcd_2.core_if,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_ana_transmitter_pre_emphasis_1;
+	extern struct device_attribute dev_attr_ana_transmitter_pre_emphasis_2;
+	DEVICE_ATTR(ana_transmitter_pre_emphasis_1, S_IRUGO|S_IWUSR, sysfs_ana_transmitter_pre_emphasis_1_show, sysfs_ana_transmitter_pre_emphasis_1_store);
+	DEVICE_ATTR(ana_transmitter_pre_emphasis_2, S_IRUGO|S_IWUSR, sysfs_ana_transmitter_pre_emphasis_2_show, sysfs_ana_transmitter_pre_emphasis_2_store);
+#endif //__USE_SYSFS__
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// e/PROCSYSFS:  ANA
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// PROCSYSFS:  HOST CTRL
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+static uint32_t buspower_show(ltqhcd_hcd_t *_ltqhcd,char *buf)
+{
+	if(ltqusb_vbus (_ltqhcd)==1) return sprintf( buf, "1\n" );
+	if(ltqusb_vbus (_ltqhcd)==0) return sprintf( buf, "0\n" );
+	return sprintf( buf, "unknown\n" );
+}
+static void buspower_store(ltqhcd_hcd_t *_ltqhcd,uint32_t value)
+{
+	if     (value==1)  ltqusb_vbus_on (_ltqhcd);
+	else if(value==0)  ltqusb_vbus_off(_ltqhcd);
+}
+
+static ssize_t protect1_show(ltqhcd_hcd_t *_ltqhcd, char *buf)
+{
+	return sprintf( buf, "%d %04x %d\n",_ltqhcd->xfer_prot1_usec,_ltqhcd->xfer_prot1_value,_ltqhcd->xfer_prot1_value);
+}
+
+static void protect1_store(ltqhcd_hcd_t *_ltqhcd, uint32_t value)
+{
+	if(value==0)
+	{
+		_ltqhcd->xfer_prot1_usec =0;
+		_ltqhcd->xfer_prot1_value= 0;
+	}
+	else if(value<120)
+	{
+		_ltqhcd->xfer_prot1_usec=value;
+		_ltqhcd->xfer_prot1_value= XFER_PROT1_CALC(_ltqhcd->xfer_prot1_usec);
+	}
+}
+static ssize_t protect2_show(ltqhcd_hcd_t *_ltqhcd, char *buf)
+{
+	return sprintf( buf, "%d %lu\n",_ltqhcd->xfer_prot2_usec,_ltqhcd->xfer_prot2_value);
+}
+static void protect2_store(ltqhcd_hcd_t *_ltqhcd, uint32_t value)
+{
+	if(value==0)
+	{
+		_ltqhcd->xfer_prot2_usec =0;
+		_ltqhcd->xfer_prot2_value= 0;
+	}
+	else if(value<120)
+	{
+		_ltqhcd->xfer_prot2_usec=value;
+		_ltqhcd->xfer_prot2_value= XFER_PROT2_CALC(_ltqhcd->xfer_prot2_usec);
+	}
+}
+static ssize_t singlexact_show(ltqhcd_hcd_t *_ltqhcd, char *buf)
+{
+	return sprintf( buf, "%d\n",_ltqhcd->singlexact);
+}
+static void singlexact_store(ltqhcd_hcd_t *_ltqhcd, uint32_t value)
+{
+	if(value==1) _ltqhcd->singlexact=1;
+	if(value==0) _ltqhcd->singlexact=0;
+}
+static ssize_t burst_show(ltqhcd_hcd_t *_ltqhcd, char *buf)
+{
+	return sprintf( buf, "%d\n",_ltqhcd->burst);
+}
+static void burst_store(ltqhcd_hcd_t *_ltqhcd, uint32_t value)
+{
+	if(value==1) _ltqhcd->burst=1;
+	if(value==0) _ltqhcd->burst=0;
+}
+
+#ifdef __USE_PROCFS__
+	static ssize_t procfs_buspower_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return buspower_show(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t procfs_buspower_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return buspower_show(&ltqusb_hcd_2,buf);
+	}
+	static ssize_t procfs_protect1_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return protect1_show(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t procfs_protect1_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return protect1_show(&ltqusb_hcd_2,buf);
+	}
+	static ssize_t procfs_protect2_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return protect2_show(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t procfs_protect2_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return protect2_show(&ltqusb_hcd_2,buf);
+	}
+	static ssize_t procfs_singlexact_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return singlexact_show(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t procfs_singlexact_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return singlexact_show(&ltqusb_hcd_2,buf);
+	}
+
+	static ssize_t procfs_burst_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return burst_show(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t procfs_burst_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return burst_show(&ltqusb_hcd_2,buf);
+	}
+
+	static ssize_t procfs_buspower_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buffer, &buf[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		buspower_store(&ltqusb_hcd_1,value);
+		return length;
+	}
+	static ssize_t procfs_buspower_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buffer, &buf[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		buspower_store(&ltqusb_hcd_2,value);
+		return length;
+	}
+	static ssize_t procfs_protect1_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buffer, &buf[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		protect1_store(&ltqusb_hcd_1,value);
+		return length;
+	}
+	static ssize_t procfs_protect1_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buffer, &buf[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		protect1_store(&ltqusb_hcd_2,value);
+		return length;
+	}
+	static ssize_t procfs_protect2_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buffer, &buf[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		protect2_store(&ltqusb_hcd_1,value);
+		return length;
+	}
+	static ssize_t procfs_protect2_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buffer, &buf[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		protect2_store(&ltqusb_hcd_2,value);
+		return length;
+	}
+	static ssize_t procfs_singlexact_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buffer, &buf[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		singlexact_store(&ltqusb_hcd_1,value);
+		return length;
+	}
+	static ssize_t procfs_singlexact_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buffer, &buf[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		singlexact_store(&ltqusb_hcd_2,value);
+		return length;
+	}
+	static ssize_t procfs_burst_1_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buffer, &buf[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		burst_store(&ltqusb_hcd_1,value);
+		return length;
+	}
+	static ssize_t procfs_burst_2_store(struct file *filp, const char *buf, size_t length, loff_t *offset)
+	{
+		char buffer[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buffer, &buf[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buffer, NULL, 10);
+		burst_store(&ltqusb_hcd_2,value);
+		return length;
+	}
+
+	static const struct file_operations procfs_buspower_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_buspower_1_show,
+		.write 	= procfs_buspower_1_store,
+	};
+	static const struct file_operations procfs_buspower_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_buspower_2_show,
+		.write 	= procfs_buspower_2_store,
+	};
+	static const struct file_operations procfs_protect1_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_protect1_1_show,
+		.write 	= procfs_protect1_1_store,
+	};
+	static const struct file_operations procfs_protect1_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_protect1_2_show,
+		.write 	= procfs_protect1_2_store,
+	};
+	static const struct file_operations procfs_protect2_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_protect2_1_show,
+		.write 	= procfs_protect2_1_store,
+	};
+	static const struct file_operations procfs_protect2_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_protect2_2_show,
+		.write 	= procfs_protect2_2_store,
+	};
+	static const struct file_operations procfs_singlexact_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_singlexact_1_show,
+		.write 	= procfs_singlexact_1_store,
+	};
+	static const struct file_operations procfs_singlexact_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_singlexact_2_show,
+		.write 	= procfs_singlexact_2_store,
+	};
+	static const struct file_operations procfs_burst_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_burst_1_show,
+		.write 	= procfs_burst_1_store,
+	};
+	static const struct file_operations procfs_burst_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_burst_2_show,
+		.write 	= procfs_burst_2_store,
+	};
+#endif //__USE_PROCFS__
+#ifdef __USE_SYSFS__
+	static ssize_t sysfs_buspower_1_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return buspower_show(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t sysfs_buspower_2_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return buspower_show(&ltqusb_hcd_2,buf);
+	}
+	static ssize_t sysfs_protect1_1_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return protect1_show(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t sysfs_protect1_2_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return protect1_show(&ltqusb_hcd_2,buf);
+	}
+	static ssize_t sysfs_protect2_1_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return protect2_show(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t sysfs_protect2_2_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return protect2_show(&ltqusb_hcd_2,buf);
+	}
+	static ssize_t sysfs_singlexact_1_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return singlexact_show(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t sysfs_singlexact_2_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return singlexact_show(&ltqusb_hcd_2,buf);
+	}
+	static ssize_t sysfs_burst_1_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return burst_show(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t sysfs_burst_2_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return burst_show(&ltqusb_hcd_2,buf);
+	}
+
+	static ssize_t sysfs_buspower_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		buspower_store(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t sysfs_buspower_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		buspower_store(&ltqusb_hcd_2,value);
+		return count;
+	}
+	static ssize_t sysfs_protect1_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		protect1_store(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t sysfs_protect1_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		protect1_store(&ltqusb_hcd_2,value);
+		return count;
+	}
+	static ssize_t sysfs_protect2_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		protect2_store(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t sysfs_protect2_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		protect2_store(&ltqusb_hcd_2,value);
+		return count;
+	}
+	static ssize_t sysfs_singlexact_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		singlexact_store(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t sysfs_singlexact_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		singlexact_store(&ltqusb_hcd_2,value);
+		return count;
+	}
+	static ssize_t sysfs_burst_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		burst_store(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t sysfs_burst_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		burst_store(&ltqusb_hcd_2,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_buspower_1;
+	DEVICE_ATTR(buspower_1, S_IRUGO|S_IWUSR, sysfs_buspower_1_show, sysfs_buspower_1_store);
+	extern struct device_attribute dev_attr_buspower_2;
+	DEVICE_ATTR(buspower_2, S_IRUGO|S_IWUSR, sysfs_buspower_2_show, sysfs_buspower_2_store);
+	extern struct device_attribute dev_attr_protect1_1;
+	DEVICE_ATTR(protect1_1, S_IRUGO|S_IWUSR, sysfs_protect1_1_show, sysfs_protect1_1_store);
+	extern struct device_attribute dev_attr_protect1_2;
+	DEVICE_ATTR(protect1_2, S_IRUGO|S_IWUSR, sysfs_protect1_2_show, sysfs_protect1_2_store);
+	extern struct device_attribute dev_attr_protect2_1;
+	DEVICE_ATTR(protect2_1, S_IRUGO|S_IWUSR, sysfs_protect2_1_show, sysfs_protect2_1_store);
+	extern struct device_attribute dev_attr_protect2_2;
+	DEVICE_ATTR(protect2_2, S_IRUGO|S_IWUSR, sysfs_protect2_2_show, sysfs_protect2_2_store);
+	extern struct device_attribute dev_attr_singlexact_1;
+	DEVICE_ATTR(singlexact_1, S_IRUGO|S_IWUSR, sysfs_singlexact_1_show, sysfs_singlexact_1_store);
+	extern struct device_attribute dev_attr_singlexact_2;
+	DEVICE_ATTR(singlexact_2, S_IRUGO|S_IWUSR, sysfs_singlexact_2_show, sysfs_singlexact_2_store);
+	extern struct device_attribute dev_attr_burst_1;
+	DEVICE_ATTR(burst_1, S_IRUGO|S_IWUSR, sysfs_burst_1_show, sysfs_burst_1_store);
+	extern struct device_attribute dev_attr_burst_2;
+	DEVICE_ATTR(burst_2, S_IRUGO|S_IWUSR, sysfs_burst_2_show, sysfs_burst_2_store);
+#endif //__USE_SYSFS__
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// e/PROCSYSFS:  HOST CTRL
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// PROCSYSFS:  HOST POWER CONTROL
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+static void host_probing(unsigned long _ptr)
+{
+	ltqhcd_hcd_t *ltqhcd = (ltqhcd_hcd_t *)_ptr;
+
+	if(ltqhcd->flags.b.port_connect_status)
+	{
+		del_timer(&ltqhcd->host_probe_timer);
+		del_timer(&ltqhcd->autoprobe_timer);
+		ltqhcd->power_status = 0;
+	}
+	else
+	{
+		del_timer(&ltqhcd->autoprobe_timer);
+		ltqhcd->autoprobe_timer.expires = jiffies + (HZ*ltqhcd->autoprobe_sec);
+		add_timer(&ltqhcd->autoprobe_timer);
+		ltqhcd->power_status = 2;
+		del_timer(&ltqhcd->host_probe_timer);
+		do_suspend_h(ltqhcd);
+	}
+}
+
+static void host_autoprobe(unsigned long _ptr)
+{
+	ltqhcd_hcd_t *ltqhcd = (ltqhcd_hcd_t *)_ptr;
+	del_timer(&ltqhcd->host_probe_timer);
+	ltqhcd->host_probe_timer.function = host_probing;
+	ltqhcd->host_probe_timer.expires = jiffies + (HZ*ltqhcd->probe_sec);
+	ltqhcd->host_probe_timer.data = (unsigned long)ltqhcd;
+	add_timer(&ltqhcd->host_probe_timer);
+	do_resume_h(ltqhcd);
+}
+
+static void host_single_probe(ltqhcd_hcd_t *ltqhcd, uint32_t value)
+{
+	if(ltqhcd->power_status == 1)
+		host_autoprobe((unsigned long)ltqhcd);
+}
+
+
+static void suspend_host_write(ltqhcd_hcd_t *ltqhcd , uint32_t value)
+{
+	if(value==2)
+	{
+		del_timer(&ltqhcd->autoprobe_timer);
+		ltqhcd->autoprobe_timer.function = host_autoprobe;
+		ltqhcd->autoprobe_timer.expires = jiffies + (HZ*ltqhcd->autoprobe_sec);
+		ltqhcd->autoprobe_timer.data = (unsigned long)ltqhcd;
+		add_timer(&ltqhcd->autoprobe_timer);
+		ltqhcd->power_status = 2;
+	}
+	else if(value==1)
+	{
+		do_suspend_h(ltqhcd);
+		ltqhcd->power_status = 1;
+		del_timer(&ltqhcd->host_probe_timer);
+		del_timer(&ltqhcd->autoprobe_timer);
+	}
+	else if(value==0)
+	{
+		do_resume_h(ltqhcd);
+		ltqhcd->power_status = 0;
+		del_timer(&ltqhcd->host_probe_timer);
+		del_timer(&ltqhcd->autoprobe_timer);
+	}
+}
+static ssize_t suspend_host_read(ltqhcd_hcd_t *ltqhcd , char *buf)
+{
+	if(ltqhcd->power_status == 0)
+		return sprintf (buf,"Host %d power status is ON\n",ltqhcd->core_if.core_no+1);
+	else if(ltqhcd->power_status == 1)
+		return sprintf (buf,"Host %d power status is Suspend\n",ltqhcd->core_if.core_no+1);
+	else
+		return sprintf (buf,"Host %d power status is Auto-probing\n",ltqhcd->core_if.core_no+1);
+}
+
+static void bussuspend_write(ltqhcd_hcd_t *ltqhcd , uint32_t value)
+{
+	if(value==1)
+		do_bussuspend_h(ltqhcd);
+	else if(value==0)
+		do_busresume_h(ltqhcd);
+}
+static ssize_t bussuspend_read(ltqhcd_hcd_t *ltqhcd , char *buf)
+{
+	hprt0_data_t val;
+	val.d32 = ltqusb_rreg(ltqhcd->core_if.hprt0);
+	return sprintf (buf,"Suspended = 0x%x\n", val.b.prtsusp);
+}
+
+static void host_probe_timer_write(ltqhcd_hcd_t *ltqhcd , uint32_t value)
+{
+	if(value>0 && value<=10) ltqhcd->probe_sec=value;
+}
+static void host_autoprobe_timer_write(ltqhcd_hcd_t *ltqhcd , uint32_t value)
+{
+	if(value>0 && value<=300) ltqhcd->autoprobe_sec=value;
+}
+static ssize_t host_probe_timer_read(ltqhcd_hcd_t *ltqhcd , char *buf)
+{
+	return sprintf (buf,"Host %d probing timer is %d seconds long , probe every %d seconds\n",ltqhcd->core_if.core_no+1,ltqhcd->probe_sec,ltqhcd->autoprobe_sec);
+}
+
+#ifdef __USE_PROCFS__
+	static ssize_t procfs_host_suspend_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return suspend_host_read(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t procfs_host_suspend_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return suspend_host_read(&ltqusb_hcd_2,buf);
+	}
+	static ssize_t procfs_host_suspend_1_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		suspend_host_write(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t procfs_host_suspend_2_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		suspend_host_write(&ltqusb_hcd_2,value);
+		return count;
+	}
+	static const struct file_operations procfs_host_suspend_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_host_suspend_1_show,
+		.write 	= procfs_host_suspend_1_store,
+	};
+	static const struct file_operations procfs_host_suspend_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_host_suspend_2_show,
+		.write 	= procfs_host_suspend_2_store,
+	};
+
+	static ssize_t procfs_bussuspend_1_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return bussuspend_read(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t procfs_bussuspend_2_show(struct file *filp, char *buf, size_t length, loff_t *offset){
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return bussuspend_read(&ltqusb_hcd_2,buf);
+	}
+	static ssize_t procfs_bussuspend_1_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		bussuspend_write(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t procfs_bussuspend_2_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		bussuspend_write(&ltqusb_hcd_2,value);
+		return count;
+	}
+	static const struct file_operations procfs_bussuspend_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_bussuspend_1_show,
+		.write 	= procfs_bussuspend_1_store,
+	};
+	static const struct file_operations procfs_bussuspend_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_bussuspend_2_show,
+		.write 	= procfs_bussuspend_2_store,
+	};
+
+
+	static ssize_t procfs_probe_host_1_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_single_probe(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t procfs_probe_host_2_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_single_probe(&ltqusb_hcd_2,value);
+		return count;
+	}
+	static const struct file_operations procfs_probe_host_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_host_suspend_1_show,
+		.write 	= procfs_probe_host_1_store,
+	};
+	static const struct file_operations procfs_probe_host_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_host_suspend_2_show,
+		.write 	= procfs_probe_host_2_store,
+	};
+
+	static ssize_t procfs_host_probe_timer_1_show(struct file *filp, char *buf, size_t length, loff_t *offset)
+	{
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return host_probe_timer_read(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t procfs_host_probe_timer_2_show(struct file *filp, char *buf, size_t length, loff_t *offset)
+	{
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+			return host_probe_timer_read(&ltqusb_hcd_2,buf);
+	}
+
+	static ssize_t procfs_host_probe_timer_1_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_probe_timer_write(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t procfs_host_probe_timer_2_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_probe_timer_write(&ltqusb_hcd_2,value);
+		return count;
+	}
+	static const struct file_operations procfs_host_probe_timer_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_host_probe_timer_1_show,
+		.write 	= procfs_host_probe_timer_1_store,
+	};
+	static const struct file_operations procfs_host_probe_timer_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_host_probe_timer_2_show,
+		.write 	= procfs_host_probe_timer_2_store,
+	};
+
+	static ssize_t procfs_host_autoprobe_timer_1_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_autoprobe_timer_write(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t procfs_host_autoprobe_timer_2_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_autoprobe_timer_write(&ltqusb_hcd_2,value);
+		return count;
+	}
+	static const struct file_operations procfs_host_autoprobe_timer_1_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_host_probe_timer_1_show,
+		.write 	= procfs_host_autoprobe_timer_1_store,
+	};
+	static const struct file_operations procfs_host_autoprobe_timer_2_fops = {
+	 	.open	= procfs_rw_open,
+		.read 	= procfs_host_probe_timer_2_show,
+		.write 	= procfs_host_autoprobe_timer_2_store,
+	};
+
+	static ssize_t procfs_oc_hy_1_show(struct file *filp, char *buf, size_t length, loff_t *offset)
+	{
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 1 Over-Current Hysteresis is %d\n",(int)(ltqusb_oc_get_hy(1)));
+	}
+	static ssize_t procfs_oc_hy_2_show(struct file *filp, char *buf, size_t length, loff_t *offset)
+	{
+		static int done=0;
+		if(done)
+		{
+			done=0;
+			return 0;
+		}
+		done=1;
+		return sprintf (buf,"Host 2 Over-Current Hysteresis is %d\n",(int)(ltqusb_oc_get_hy(1)));
+	}
+	static ssize_t procfs_oc_hy_1_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		if( value>=0 && value < 4 )
+		ltqusb_oc_set_hy(1,value);
+		return count;
+	}
+	static ssize_t procfs_oc_hy_2_store(struct file *filp, const char *buffer, size_t count, loff_t *offset)
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		if( value>=0 && value < 4 )
+			ltqusb_oc_set_hy(2,value);
+		return count;
+	}
+	static const struct file_operations procfs_oc_hy_1_fops = {
+		.open	= procfs_rw_open,
+		.read 	= procfs_oc_hy_1_show,
+		.write 	= procfs_oc_hy_1_store,
+	};
+	static const struct file_operations procfs_oc_hy_2_fops = {
+		.open	= procfs_rw_open,
+		.read 	= procfs_oc_hy_2_show,
+		.write 	= procfs_oc_hy_2_store,
+	};
+
+#endif //__USE_PROCFS__
+#ifdef __USE_SYSFS__
+	static ssize_t sysfs_host_suspend_1_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return suspend_host_read(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t sysfs_host_suspend_2_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return suspend_host_read(&ltqusb_hcd_2,buf);
+	}
+	static ssize_t sysfs_host_suspend_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		suspend_host_write(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t sysfs_host_suspend_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		suspend_host_write(&ltqusb_hcd_2,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_host_suspend_1;
+	DEVICE_ATTR(host_suspend_1, S_IRUGO|S_IWUSR, sysfs_host_suspend_1_show, sysfs_host_suspend_1_store);
+	extern struct device_attribute dev_attr_host_suspend_2;
+	DEVICE_ATTR(host_suspend_2, S_IRUGO|S_IWUSR, sysfs_host_suspend_2_show, sysfs_host_suspend_2_store);
+
+	static ssize_t sysfs_bussuspend_1_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return bussuspend_read(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t sysfs_bussuspend_2_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return bussuspend_read(&ltqusb_hcd_2,buf);
+	}
+	static ssize_t sysfs_bussuspend_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		bussuspend_write(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t sysfs_bussuspend_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		bussuspend_write(&ltqusb_hcd_2,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_bussuspend_1;
+	DEVICE_ATTR(bussuspend_1, S_IRUGO|S_IWUSR, sysfs_bussuspend_1_show, sysfs_bussuspend_1_store);
+	extern struct device_attribute dev_attr_bussuspend_2;
+	DEVICE_ATTR(bussuspend_2, S_IRUGO|S_IWUSR, sysfs_bussuspend_2_show, sysfs_bussuspend_2_store);
+
+	static ssize_t sysfs_probe_host_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_single_probe(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t sysfs_probe_host_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_single_probe(&ltqusb_hcd_2,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_probe_host_1;
+	DEVICE_ATTR(probe_host_1, S_IRUGO|S_IWUSR, sysfs_host_suspend_1_show, sysfs_probe_host_1_store);
+	extern struct device_attribute dev_attr_probe_host_2;
+	DEVICE_ATTR(probe_host_2, S_IRUGO|S_IWUSR, sysfs_host_suspend_2_show, sysfs_probe_host_2_store);
+
+	static ssize_t sysfs_host_probe_timer_1_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return host_probe_timer_read(&ltqusb_hcd_1,buf);
+	}
+	static ssize_t sysfs_host_probe_timer_2_show( struct device *_dev, struct device_attribute *attr,char *buf)
+	{
+		return host_probe_timer_read(&ltqusb_hcd_2,buf);
+	}
+
+	static ssize_t sysfs_host_probe_timer_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_probe_timer_write(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t sysfs_host_probe_timer_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_probe_timer_write(&ltqusb_hcd_2,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_host_probe_timer_1;
+	DEVICE_ATTR(host_probe_timer_1, S_IRUGO|S_IWUSR, sysfs_host_probe_timer_1_show, sysfs_host_probe_timer_1_store);
+	extern struct device_attribute dev_attr_host_probe_timer_2;
+	DEVICE_ATTR(host_probe_timer_2, S_IRUGO|S_IWUSR, sysfs_host_probe_timer_2_show, sysfs_host_probe_timer_2_store);
+
+	static ssize_t sysfs_host_autoprobe_timer_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_autoprobe_timer_write(&ltqusb_hcd_1,value);
+		return count;
+	}
+	static ssize_t sysfs_host_autoprobe_timer_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+	{
+		char buf[10];
+		int i = 0;
+		uint32_t value;
+		if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+			return -EFAULT;
+		value = simple_strtoul(buf, NULL, 10);
+		host_autoprobe_timer_write(&ltqusb_hcd_2,value);
+		return count;
+	}
+	extern struct device_attribute dev_attr_host_autoprobe_timer_1;
+	DEVICE_ATTR(host_autoprobe_timer_1, S_IRUGO|S_IWUSR, sysfs_host_probe_timer_1_show, sysfs_host_autoprobe_timer_1_store);
+	extern struct device_attribute dev_attr_host_autoprobe_timer_2;
+	DEVICE_ATTR(host_autoprobe_timer_2, S_IRUGO|S_IWUSR, sysfs_host_probe_timer_2_show, sysfs_host_autoprobe_timer_2_store);
+
+		static ssize_t sysfs_oc_hy_1_show( struct device *_dev, struct device_attribute *attr,char *buf)
+		{
+			return sprintf (buf,"Host 1 Over-Current Hysteresis is %d\n",(int)(ltqusb_oc_get_hy(1)));
+		}
+		static ssize_t sysfs_oc_hy_2_show( struct device *_dev, struct device_attribute *attr,char *buf)
+		{
+			return sprintf (buf,"Host 2 Over-Current Hysteresis is %d\n",(int)(ltqusb_oc_get_hy(1)));
+		}
+		static ssize_t sysfs_oc_hy_1_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+		{
+			char buf[10];
+			int i = 0;
+			uint32_t value;
+			if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+				return -EFAULT;
+			value = simple_strtoul(buf, NULL, 10);
+			if( value>=0 && value < 4 )
+				ltqusb_oc_set_hy(1,value);
+			return count;
+		}
+		static ssize_t sysfs_oc_hy_2_store( struct device *_dev, struct device_attribute *attr,const char *buffer, size_t count )
+		{
+			char buf[10];
+			int i = 0;
+			uint32_t value;
+			if (copy_from_user(buf, &buffer[i], sizeof("0xFFFFFFFF\n")+1))
+				return -EFAULT;
+			value = simple_strtoul(buf, NULL, 10);
+			if( value>=0 && value < 4 )
+				ltqusb_oc_set_hy(2,value);
+			return count;
+		}
+		extern struct device_attribute dev_attr_oc_hy_1;
+		DEVICE_ATTR(oc_hy_1, S_IRUGO|S_IWUSR, sysfs_oc_hy_1_show, sysfs_oc_hy_1_store);
+		extern struct device_attribute dev_attr_oc_hy_2;
+		DEVICE_ATTR(oc_hy_2, S_IRUGO|S_IWUSR, sysfs_oc_hy_2_show, sysfs_oc_hy_2_store);
+#endif //__USE_PROCFS__
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+// e/PROCSYSFS:  HOST POWER CONTROL
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+//////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////
+#ifdef __USE_PROCFS__
+	static struct proc_dir_entry * proc_ltq_root = NULL;
+	static void ltq_proc_init(void)
+	{
+		proc_ltq_root = proc_mkdir(ltqusb_hcd_driver_name, (void *)0);
+		if (!proc_ltq_root){
+			LTQ_PRINT("%s proc initialization failed! \n", ltqusb_hcd_driver_name);
+			return;
+		}
+	}
+	static int ltq_proc_addproc(const char *funcname, umode_t mode, const struct file_operations *proc_fops)
+	{
+		if (!proc_ltq_root)
+			ltq_proc_init();
+		if(!proc_create(funcname, mode, proc_ltq_root, proc_fops))
+		{
+			printk(KERN_INFO "PROCFS: Failed to create (%s) entry!!\n", funcname);
+			return -1;
+		}
+		return 0;
+	}
+
+	/* proc file system del function for removing module. */
+	static void ltq_proc_delproc(const char *funcname)
+	{
+		char pname[30];
+		sprintf(pname, "%s", funcname);
+		remove_proc_entry(pname, proc_ltq_root);
+	}
+#endif //__USE_PROCFS__
+//////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////
+
+
+#if defined(__HOST_COC__)
+	static LTQ_PMCU_MODULE_DEP_t depListUSBHost_1=
+	{
+	     1,
+	     {
+#ifdef __NEW_COC__
+	         {LTQ_PMCU_MODULE_CPU, 0, LTQ_PMCU_STATE_D0, LTQ_PMCU_STATE_D0D3, LTQ_PMCU_STATE_D0D3, LTQ_PMCU_STATE_D0D3}
+#else
+	         {LTQ_PMCU_MODULE_CPU, LTQ_PMCU_STATE_D0, LTQ_PMCU_STATE_D0D3, LTQ_PMCU_STATE_D0D3, LTQ_PMCU_STATE_D0D3}
+#endif
+	     }
+	};
+	static LTQ_PMCU_MODULE_DEP_t depListUSBHost_2=
+	{
+	     1,
+	     {
+#ifdef __NEW_COC__
+	         {LTQ_PMCU_MODULE_CPU, 0, LTQ_PMCU_STATE_D0, LTQ_PMCU_STATE_D0D3, LTQ_PMCU_STATE_D0D3, LTQ_PMCU_STATE_D0D3}
+#else
+	         {LTQ_PMCU_MODULE_CPU, LTQ_PMCU_STATE_D0, LTQ_PMCU_STATE_D0D3, LTQ_PMCU_STATE_D0D3, LTQ_PMCU_STATE_D0D3}
+#endif
+	     }
+	};
+	// This functions returns the current power state of the module
+	static LTQ_PMCU_RETURN_t
+	ltq_usbhost_stateGet_1(LTQ_PMCU_STATE_t *pmcuModState) {
+	    //printk(KERN_DEBUG "ltq_usbhost_stateGet_1 is called\n");
+	    if(ltqusb_hcd_1.power_status == 0){
+	        printk(KERN_DEBUG "current power state of USB Host #1 is D0\n");
+	        *pmcuModState = LTQ_PMCU_STATE_D0; // set here the right value
+	    }
+	    else if(ltqusb_hcd_1.power_status == 1){
+	        printk(KERN_DEBUG "current power state of USB Host #1 is D3 (Suspend)\n");
+	        *pmcuModState = LTQ_PMCU_STATE_D3; // set here the right value
+	    }
+	    else if(ltqusb_hcd_1.power_status == 2){
+	        printk(KERN_DEBUG "current power state of USB Host #1 is D3 (Auto-Probing)\n");
+	        *pmcuModState = LTQ_PMCU_STATE_D3; // set here the right value
+	    }
+	    else{
+	        printk(KERN_DEBUG "current power state of USB Host #1 is unknown (%d)\n",ltqusb_hcd_1.power_status);
+	        *pmcuModState = LTQ_PMCU_STATE_INVALID; // must be set to INVALID
+	    }
+	    return LTQ_PMCU_RETURN_SUCCESS;
+	}
+	static LTQ_PMCU_RETURN_t
+	ltq_usbhost_stateGet_2(LTQ_PMCU_STATE_t *pmcuModState) {
+	    //printk(KERN_DEBUG "ltq_usbhost_stateGet_2 is called\n");
+	    if(ltqusb_hcd_2.power_status == 0){
+	        printk(KERN_DEBUG "current power state of USB Host #2 is D0\n");
+	        *pmcuModState = LTQ_PMCU_STATE_D0; // set here the right value
+	    }
+	    else if(ltqusb_hcd_2.power_status == 1){
+	        printk(KERN_DEBUG "current power state of USB Host #2 is D3 (Suspend)\n");
+	        *pmcuModState = LTQ_PMCU_STATE_D3; // set here the right value
+	    }
+	    else if(ltqusb_hcd_2.power_status == 2){
+	        printk(KERN_DEBUG "current power state of USB Host #2 is D3 (Auto-Probing)\n");
+	        *pmcuModState = LTQ_PMCU_STATE_D3; // set here the right value
+	    }
+	    else{
+	        printk(KERN_DEBUG "current power state of USB Host #2 is unknown (%d)\n",ltqusb_hcd_2.power_status);
+	        *pmcuModState = LTQ_PMCU_STATE_INVALID; // must be set to INVALID
+	    }
+	    return LTQ_PMCU_RETURN_SUCCESS;
+	}
+
+	// The function should be used to enable/disable the module specific power saving methods
+	static LTQ_PMCU_RETURN_t
+	ltq_usbhost_pwrFeatureSwitch_1(LTQ_PMCU_PWR_STATE_ENA_t pmcuPwrStateEna)
+	{
+	    if (pmcuPwrStateEna == LTQ_PMCU_PWR_STATE_ON) {
+		    pmcuPowerFeatureUSBHost_1=1;
+	        return LTQ_PMCU_RETURN_SUCCESS;
+	    }
+	    if (pmcuPwrStateEna == LTQ_PMCU_PWR_STATE_OFF) {
+		    pmcuPowerFeatureUSBHost_1=0;
+		    suspend_host_write(&ltqusb_hcd_1, 0);
+	        return LTQ_PMCU_RETURN_SUCCESS;
+        }
+	    return LTQ_PMCU_RETURN_DENIED;
+	}
+	static LTQ_PMCU_RETURN_t
+	ltq_usbhost_pwrFeatureSwitch_2(LTQ_PMCU_PWR_STATE_ENA_t pmcuPwrStateEna)
+	{
+	    if (pmcuPwrStateEna == LTQ_PMCU_PWR_STATE_ON) {
+		    pmcuPowerFeatureUSBHost_2=1;
+	        return LTQ_PMCU_RETURN_SUCCESS;
+	    }
+	    if (pmcuPwrStateEna == LTQ_PMCU_PWR_STATE_OFF) {
+		    pmcuPowerFeatureUSBHost_2=0;
+		    suspend_host_write(&ltqusb_hcd_2, 0);
+	        return LTQ_PMCU_RETURN_SUCCESS;
+        }
+	    return LTQ_PMCU_RETURN_DENIED;
+	}
+
+	// This function should be used to do all the necessary clean-up's before a the real
+	// power state change is initiated; e.g. flush all serial buffers inside the UART  before
+	// the frequency will be changed.
+	static LTQ_PMCU_RETURN_t
+	ltq_usbhost_preChange_1(LTQ_PMCU_MODULE_t pmcuModule, LTQ_PMCU_STATE_t newState, LTQ_PMCU_STATE_t oldState)
+	{
+	    //printk(KERN_DEBUG "ltq_usbhost_preChange_1 is called\n");
+	    return LTQ_PMCU_RETURN_SUCCESS;
+	}
+	static LTQ_PMCU_RETURN_t
+	ltq_usbhost_preChange_2(LTQ_PMCU_MODULE_t pmcuModule, LTQ_PMCU_STATE_t newState, LTQ_PMCU_STATE_t oldState)
+	{
+	    //printk(KERN_DEBUG "ltq_usbhost_preChange_2 is called\n");
+	    return LTQ_PMCU_RETURN_SUCCESS;
+	}
+
+	// This function initiate the real power state change. The module should do all the necessary
+	//   adpations to the new state.
+	static LTQ_PMCU_RETURN_t
+	ltq_usbhost_stateChange_1(LTQ_PMCU_STATE_t newState)
+	{
+	    //printk(KERN_DEBUG "ltq_usbhost_stateChange_1 is called\n");
+	    if(pmcuPowerFeatureUSBHost_1)
+	    {
+		    if (newState == LTQ_PMCU_STATE_D0) {
+			    suspend_host_write(&ltqusb_hcd_1, 0);
+		        return LTQ_PMCU_RETURN_SUCCESS;
+		    }
+		    if (newState == LTQ_PMCU_STATE_D1) {
+			    suspend_host_write(&ltqusb_hcd_1, 1);
+		        return LTQ_PMCU_RETURN_SUCCESS;
+		    }
+		    if (newState == LTQ_PMCU_STATE_D2) {
+			    suspend_host_write(&ltqusb_hcd_1, 1);
+		        return LTQ_PMCU_RETURN_SUCCESS;
+		    }
+		    if (newState == LTQ_PMCU_STATE_D3) {
+			    suspend_host_write(&ltqusb_hcd_1, 1);
+		        return LTQ_PMCU_RETURN_SUCCESS;
+		    }
+		}
+	    return LTQ_PMCU_RETURN_DENIED;
+	}
+	static LTQ_PMCU_RETURN_t
+	ltq_usbhost_stateChange_2(LTQ_PMCU_STATE_t newState)
+	{
+	    //printk(KERN_DEBUG "ltq_usbhost_stateChange_2 is called\n");
+	    if(pmcuPowerFeatureUSBHost_2)
+	    {
+		    if (newState == LTQ_PMCU_STATE_D0) {
+			    suspend_host_write(&ltqusb_hcd_2, 0);
+		        return LTQ_PMCU_RETURN_SUCCESS;
+		    }
+		    if (newState == LTQ_PMCU_STATE_D1) {
+			    suspend_host_write(&ltqusb_hcd_2, 1);
+		        return LTQ_PMCU_RETURN_SUCCESS;
+		    }
+		    if (newState == LTQ_PMCU_STATE_D2) {
+			    suspend_host_write(&ltqusb_hcd_2, 1);
+		        return LTQ_PMCU_RETURN_SUCCESS;
+		    }
+		    if (newState == LTQ_PMCU_STATE_D3) {
+			    suspend_host_write(&ltqusb_hcd_2, 1);
+		        return LTQ_PMCU_RETURN_SUCCESS;
+		    }
+	    }
+	    return LTQ_PMCU_RETURN_DENIED;
+	}
+
+	// This function should be used to do all the necessary post processing after a the real
+	//   power state change was initiated.
+	static LTQ_PMCU_RETURN_t
+	ltq_usbhost_postChange_1(LTQ_PMCU_MODULE_t pmcuModule, LTQ_PMCU_STATE_t newState, LTQ_PMCU_STATE_t oldState)
+	{
+	    //printk(KERN_DEBUG "ltq_usbhost_postChange_1 is called\n");
+	    return LTQ_PMCU_RETURN_SUCCESS;
+	}
+	static LTQ_PMCU_RETURN_t
+	ltq_usbhost_postChange_2(LTQ_PMCU_MODULE_t pmcuModule, LTQ_PMCU_STATE_t newState, LTQ_PMCU_STATE_t oldState)
+	{
+	    //printk(KERN_DEBUG "ltq_usbhost_postChange_2 is called\n");
+	    return LTQ_PMCU_RETURN_SUCCESS;
+	}
+#endif //defined(__HOST_COC__)
+
+/*!
+  \brief This function create the sysfs and procfs entries
+  \param[in] _dev Pointer of device structure, if applied
+ */
+void ltqusb_attr_create_h (void *_dev)
+{
+	struct device *dev = (struct device *) _dev;
+
+	LTQ_DEBUGPL(DBG_ENTRY, "%s() %d\n", __func__, __LINE__ );
+
+#ifdef __USE_PROCFS__
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  VERSION
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	ltq_proc_addproc("version_h",0, &procfs_version_fops);
+	ltq_proc_addproc("dbglevel_h",0, &procfs_dbglevel_fops);
+
+
+	if(ltqusb_hcd_1.dev)
+	{
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  DUMP_PARAMS MODE
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		ltq_proc_addproc("dump_params_h_1",0, &procfs_dump_params_fops_1);
+		ltq_proc_addproc("mode_h_1",0, &procfs_mode_fops_1);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST STATUS
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		ltq_proc_addproc("host_port_status_1",0, &procfs_host_port_status_fops_1);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  DUMP
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		#ifdef __ENABLE_DUMP__
+			ltq_proc_addproc("dump_reg_h_1",0, &procfs_dump_reg_h_fops_1);
+			ltq_proc_addproc("dump_spram_h_1",0, &procfs_dump_spram_h_fops_1);
+			ltq_proc_addproc("dump_host_state_1",0, &procfs_dump_host_state_fops_1);
+		#endif //__ENABLE_DUMP__
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  ANA
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		ltq_proc_addproc("ana_disconnect_threshold_1",0, &procfs_ana_disconnect_threshold_1_fops);
+		ltq_proc_addproc("ana_squelch_threshold_1",0, &procfs_ana_squelch_threshold_1_fops);
+		ltq_proc_addproc("ana_transmitter_crossover_1",0, &procfs_ana_transmitter_crossover_1_fops);
+		ltq_proc_addproc("ana_transmitter_impedance_1",0, &procfs_ana_transmitter_impedance_1_fops);
+		ltq_proc_addproc("ana_transmitter_dc_voltage_1",0, &procfs_ana_transmitter_dc_voltage_1_fops);
+		ltq_proc_addproc("ana_transmitter_risefall_time_1",0, &procfs_ana_transmitter_risefall_time_1_fops);
+		ltq_proc_addproc("ana_transmitter_pre_emphasis_1",0, &procfs_ana_transmitter_pre_emphasis_1_fops);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST CTRL
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		ltq_proc_addproc("buspower_1",0, &procfs_buspower_1_fops);
+		ltq_proc_addproc("protect1_1",0, &procfs_protect1_1_fops);
+		ltq_proc_addproc("protect2_1",0, &procfs_protect2_1_fops);
+		ltq_proc_addproc("singlexact_1",0, &procfs_singlexact_1_fops);
+		ltq_proc_addproc("burst_1",0, &procfs_burst_1_fops);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST POWER CONTROL
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		ltq_proc_addproc("host_suspend_1",0, &procfs_host_suspend_1_fops);
+		ltq_proc_addproc("bussuspend_1",0, &procfs_bussuspend_1_fops);
+		ltq_proc_addproc("probe_host_1",0, &procfs_probe_host_1_fops);
+		ltq_proc_addproc("host_probe_timer_1",0, &procfs_host_probe_timer_1_fops);
+		ltq_proc_addproc("host_autoprobe_timer_1",0, &procfs_host_autoprobe_timer_1_fops);
+		ltq_proc_addproc("oc_hy_1",0, &procfs_oc_hy_1_fops);
+	}
+	if(ltqusb_hcd_2.dev)
+	{
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  DUMP_PARAMS MODE
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		ltq_proc_addproc("dump_params_h_2",0, &procfs_dump_params_fops_2);
+		ltq_proc_addproc("mode_h_2",0, &procfs_mode_fops_2);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST STATUS
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		ltq_proc_addproc("host_port_status_2",0, &procfs_host_port_status_fops_2);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  DUMP
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		#ifdef __ENABLE_DUMP__
+			ltq_proc_addproc("dump_reg_h_2",0, &procfs_dump_reg_h_fops_2);
+			ltq_proc_addproc("dump_spram_h_2",0, &procfs_dump_spram_h_fops_2);
+			ltq_proc_addproc("dump_host_state_2",0, &procfs_dump_host_state_fops_2);
+		#endif //__ENABLE_DUMP__
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  ANA
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		ltq_proc_addproc("ana_disconnect_threshold_2",0, &procfs_ana_disconnect_threshold_2_fops);
+		ltq_proc_addproc("ana_squelch_threshold_2",0, &procfs_ana_squelch_threshold_2_fops);
+		ltq_proc_addproc("ana_transmitter_crossover_2",0, &procfs_ana_transmitter_crossover_2_fops);
+		ltq_proc_addproc("ana_transmitter_impedance_2",0, &procfs_ana_transmitter_impedance_2_fops);
+		ltq_proc_addproc("ana_transmitter_dc_voltage_2",0, &procfs_ana_transmitter_dc_voltage_2_fops);
+		ltq_proc_addproc("ana_transmitter_risefall_time_2",0, &procfs_ana_transmitter_risefall_time_2_fops);
+		ltq_proc_addproc("ana_transmitter_pre_emphasis_2",0, &procfs_ana_transmitter_pre_emphasis_2_fops);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST CTRL
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		ltq_proc_addproc("buspower_2",0, &procfs_buspower_2_fops);
+		ltq_proc_addproc("protect1_2",0, &procfs_protect1_2_fops);
+		ltq_proc_addproc("protect2_2",0, &procfs_protect2_2_fops);
+		ltq_proc_addproc("singlexact_2",0, &procfs_singlexact_2_fops);
+		ltq_proc_addproc("burst_2",0, &procfs_burst_2_fops);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST POWER CONTROL
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		ltq_proc_addproc("host_suspend_2",0, &procfs_host_suspend_2_fops);
+		ltq_proc_addproc("bussuspend_2",0, &procfs_bussuspend_2_fops);
+		ltq_proc_addproc("probe_host_2",0, &procfs_probe_host_2_fops);
+		ltq_proc_addproc("host_probe_timer_2",0, &procfs_host_probe_timer_2_fops);
+		ltq_proc_addproc("host_autoprobe_timer_2",0, &procfs_host_autoprobe_timer_2_fops);
+		ltq_proc_addproc("oc_hy_2",0, &procfs_oc_hy_2_fops);
+	}
+
+#endif //__USE_PROCFS__
+
+#ifdef __USE_SYSFS__
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  VERSION
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	device_create_file(dev, &dev_attr_version_h);
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  DBGLEVEL
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	device_create_file(dev, &dev_attr_dbglevel_h);
+
+	if(ltqusb_hcd_1.dev)
+	{
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  DUMP_PARAMS MODE
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		device_create_file(dev, &dev_attr_dump_params_h_1);
+		device_create_file(dev, &dev_attr_mode_h_1);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST STATUS
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		device_create_file(dev, &dev_attr_host_port_status_1);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  DUMP
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		#ifdef __ENABLE_DUMP__
+			device_create_file(dev, &dev_attr_dump_reg_h_1);
+			device_create_file(dev, &dev_attr_dump_spram_h_1);
+			device_create_file(dev, &dev_attr_dump_host_state_1);
+		#endif //__ENABLE_DUMP__
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  ANA
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		device_create_file(dev, &dev_attr_ana_disconnect_threshold_1);
+		device_create_file(dev, &dev_attr_ana_squelch_threshold_1);
+		device_create_file(dev, &dev_attr_ana_transmitter_crossover_1);
+		device_create_file(dev, &dev_attr_ana_transmitter_impedance_1);
+		device_create_file(dev, &dev_attr_ana_transmitter_dc_voltage_1);
+		device_create_file(dev, &dev_attr_ana_transmitter_risefall_time_1);
+		device_create_file(dev, &dev_attr_ana_transmitter_pre_emphasis_1);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST CTRL
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		device_create_file(dev, &dev_attr_buspower_1);
+		device_create_file(dev, &dev_attr_protect1_1);
+		device_create_file(dev, &dev_attr_protect2_1);
+		device_create_file(dev, &dev_attr_singlexact_1);
+		device_create_file(dev, &dev_attr_burst_1);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST POWER CONTROL
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		device_create_file(dev, &dev_attr_host_suspend_1);
+		device_create_file(dev, &dev_attr_bussuspend_1);
+		device_create_file(dev, &dev_attr_probe_host_1);
+		device_create_file(dev, &dev_attr_host_probe_timer_1);
+		device_create_file(dev, &dev_attr_host_autoprobe_timer_1);
+
+		device_create_file(dev, &dev_attr_oc_hy_1);
+	}
+	if(ltqusb_hcd_2.dev)
+	{
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  DUMP_PARAMS MODE
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		device_create_file(dev, &dev_attr_dump_params_h_2);
+		device_create_file(dev, &dev_attr_mode_h_2);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST STATUS
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		device_create_file(dev, &dev_attr_host_port_status_2);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  DUMP
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		#ifdef __ENABLE_DUMP__
+			device_create_file(dev, &dev_attr_dump_reg_h_2);
+			device_create_file(dev, &dev_attr_dump_spram_h_2);
+			device_create_file(dev, &dev_attr_dump_host_state_2);
+		#endif //__ENABLE_DUMP__
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  ANA
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		device_create_file(dev, &dev_attr_ana_disconnect_threshold_2);
+		device_create_file(dev, &dev_attr_ana_squelch_threshold_2);
+		device_create_file(dev, &dev_attr_ana_transmitter_crossover_2);
+		device_create_file(dev, &dev_attr_ana_transmitter_impedance_2);
+		device_create_file(dev, &dev_attr_ana_transmitter_dc_voltage_2);
+		device_create_file(dev, &dev_attr_ana_transmitter_risefall_time_2);
+		device_create_file(dev, &dev_attr_ana_transmitter_pre_emphasis_2);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST CTRL
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		device_create_file(dev, &dev_attr_buspower_2);
+		device_create_file(dev, &dev_attr_protect1_2);
+		device_create_file(dev, &dev_attr_protect2_2);
+		device_create_file(dev, &dev_attr_singlexact_2);
+		device_create_file(dev, &dev_attr_burst_2);
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// PROCSYSFS:  HOST POWER CONTROL
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		device_create_file(dev, &dev_attr_host_suspend_2);
+		device_create_file(dev, &dev_attr_bussuspend_2);
+		device_create_file(dev, &dev_attr_probe_host_2);
+		device_create_file(dev, &dev_attr_host_probe_timer_2);
+		device_create_file(dev, &dev_attr_host_autoprobe_timer_2);
+
+		device_create_file(dev, &dev_attr_oc_hy_2);
+	}
+#endif //__USE_SYSFS__
+
+#if defined(__HOST_COC__)
+	if(ltqusb_hcd_1.dev)
+	{
+	   memset (&pmcuRegisterUSBHost_1, 0, sizeof(pmcuRegisterUSBHost_1));
+	   pmcuRegisterUSBHost_1.pmcuModule=LTQ_PMCU_MODULE_USB;
+	   pmcuRegisterUSBHost_1.pmcuModuleNr=1;
+	   pmcuRegisterUSBHost_1.pmcuModuleDep = &depListUSBHost_1;
+	   pmcuRegisterUSBHost_1.pre = ltq_usbhost_preChange_1;
+	   pmcuRegisterUSBHost_1.post = ltq_usbhost_postChange_1;
+	   pmcuRegisterUSBHost_1.ltq_pmcu_state_change = ltq_usbhost_stateChange_1;
+	   pmcuRegisterUSBHost_1.ltq_pmcu_state_get = ltq_usbhost_stateGet_1;
+	   pmcuRegisterUSBHost_1.ltq_pmcu_pwr_feature_switch = ltq_usbhost_pwrFeatureSwitch_1;
+	   #ifdef CONFIG_LTQ_PMCU
+		   ltq_pmcu_register ( &pmcuRegisterUSBHost_1 );
+	   #endif
+
+		#ifdef __NEW_COC__
+			   #ifdef CONFIG_CPU_FREQ
+			/*
+		       if ( cpufreq_register_notifier(&ltq_usbhost_1_cpufreq_notifier_block,CPUFREQ_TRANSITION_NOTIFIER) ) {
+		            printk(KERN_ERR "Fail in registering USB_HOST_1 to CPUFREQ\n");
+		            return;
+		       }
+		       if ( cpufreq_register_notifier(&ltq_usbhost_2_cpufreq_notifier_block,CPUFREQ_TRANSITION_NOTIFIER) ) {
+		            printk(KERN_ERR "Fail in registering USB_HOST_2 to CPUFREQ\n");
+		            return;
+		       }
+			*/
+			   /* add two entrys to the module status linked list */
+			   list_add_tail(&ltq_usbhost1_lxfreq_mod_g.list, &ltq_lxfreq_head_mod_list_g);
+			   #endif //CONFIG_CPU_FREQ
+		#endif //__NEW_COC__
+	}
+	if(ltqusb_hcd_2.dev)
+	{
+	   memset (&pmcuRegisterUSBHost_2, 0, sizeof(pmcuRegisterUSBHost_2));
+	   pmcuRegisterUSBHost_2.pmcuModule=LTQ_PMCU_MODULE_USB;
+	   pmcuRegisterUSBHost_2.pmcuModuleNr=2;
+	   pmcuRegisterUSBHost_2.pmcuModuleDep = &depListUSBHost_2;
+	   pmcuRegisterUSBHost_2.pre = ltq_usbhost_preChange_2;
+	   pmcuRegisterUSBHost_2.post = ltq_usbhost_postChange_2;
+	   pmcuRegisterUSBHost_2.ltq_pmcu_state_change = ltq_usbhost_stateChange_2;
+	   pmcuRegisterUSBHost_2.ltq_pmcu_state_get = ltq_usbhost_stateGet_2;
+	   pmcuRegisterUSBHost_2.ltq_pmcu_pwr_feature_switch = ltq_usbhost_pwrFeatureSwitch_2;
+	   #ifdef CONFIG_LTQ_PMCU
+		   ltq_pmcu_register ( &pmcuRegisterUSBHost_2 );
+	   #endif
+
+		#ifdef __NEW_COC__
+			   #ifdef CONFIG_CPU_FREQ
+			/*
+		       if ( cpufreq_register_notifier(&ltq_usbhost_1_cpufreq_notifier_block,CPUFREQ_TRANSITION_NOTIFIER) ) {
+		            printk(KERN_ERR "Fail in registering USB_HOST_1 to CPUFREQ\n");
+		            return;
+		       }
+		       if ( cpufreq_register_notifier(&ltq_usbhost_2_cpufreq_notifier_block,CPUFREQ_TRANSITION_NOTIFIER) ) {
+		            printk(KERN_ERR "Fail in registering USB_HOST_2 to CPUFREQ\n");
+		            return;
+		       }
+			*/
+			   /* add two entrys to the module status linked list */
+			   list_add_tail(&ltq_usbhost2_lxfreq_mod_g.list, &ltq_lxfreq_head_mod_list_g);
+			   #endif //CONFIG_CPU_FREQ
+		#endif //__NEW_COC__
+	}
+#endif //defined(__HOST_COC__)
+}
+
+/*!
+  \brief This function remove the sysfs and procfs entries
+  \param[in] _dev Pointer of device structure, if applied
+ */
+void ltqusb_attr_remove_h (void *_dev)
+{
+	struct device *dev = (struct device *) _dev;
+
+	LTQ_DEBUGPL(DBG_ENTRY, "%s() %d\n", __func__, __LINE__ );
+
+#ifdef __USE_PROCFS__
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  VERSION
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	ltq_proc_delproc("version_h");
+	ltq_proc_delproc("dbglevel_h");
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  DUMP_PARAMS MODE
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	ltq_proc_delproc("dump_params_h_1");
+	ltq_proc_delproc("dump_params_h_2");
+	ltq_proc_delproc("mode_h_1");
+	ltq_proc_delproc("mode_h_2");
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  HOST STATUS
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	ltq_proc_delproc("host_port_status_1");
+	ltq_proc_delproc("host_port_status_2");
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  DUMP
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	#ifdef __ENABLE_DUMP__
+		ltq_proc_delproc("dump_reg_h_1");
+		ltq_proc_delproc("dump_reg_h_2");
+		ltq_proc_delproc("dump_spram_h_1");
+		ltq_proc_delproc("dump_spram_h_2");
+		ltq_proc_delproc("dump_host_state_1");
+		ltq_proc_delproc("dump_host_state_2");
+	#endif //__ENABLE_DUMP__
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  ANA
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	ltq_proc_delproc("ana_disconnect_threshold_1");
+	ltq_proc_delproc("ana_disconnect_threshold_2");
+	ltq_proc_delproc("ana_squelch_threshold_1");
+	ltq_proc_delproc("ana_squelch_threshold_2");
+	ltq_proc_delproc("ana_transmitter_crossover_1");
+	ltq_proc_delproc("ana_transmitter_crossover_2");
+	ltq_proc_delproc("ana_transmitter_impedance_1");
+	ltq_proc_delproc("ana_transmitter_impedance_2");
+	ltq_proc_delproc("ana_transmitter_dc_voltage_1");
+	ltq_proc_delproc("ana_transmitter_dc_voltage_2");
+	ltq_proc_delproc("ana_transmitter_risefall_time_1");
+	ltq_proc_delproc("ana_transmitter_risefall_time_2");
+	ltq_proc_delproc("ana_transmitter_pre_emphasis_1");
+	ltq_proc_delproc("ana_transmitter_pre_emphasis_2");
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  HOST CTRL
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	ltq_proc_delproc("buspower_1");
+	ltq_proc_delproc("buspower_2");
+	ltq_proc_delproc("protect1_1");
+	ltq_proc_delproc("protect1_2");
+	ltq_proc_delproc("protect2_1");
+	ltq_proc_delproc("protect2_2");
+	ltq_proc_delproc("singlexact_1");
+	ltq_proc_delproc("singlexact_2");
+	ltq_proc_delproc("burst_1");
+	ltq_proc_delproc("burst_2");
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  HOST POWER CONTROL
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	ltq_proc_delproc("host_suspend_1");
+	ltq_proc_delproc("host_suspend_2");
+	ltq_proc_delproc("bussuspend_1");
+	ltq_proc_delproc("bussuspend_2");
+	ltq_proc_delproc("probe_host_1");
+	ltq_proc_delproc("probe_host_2");
+	ltq_proc_delproc("host_probe_timer_1");
+	ltq_proc_delproc("host_probe_timer_2");
+	ltq_proc_delproc("host_autoprobe_timer_1");
+	ltq_proc_delproc("host_autoprobe_timer_2");
+	ltq_proc_delproc("oc_hy_1");
+	ltq_proc_delproc("oc_hy_2");
+
+	remove_proc_entry(ltqusb_hcd_driver_name, (void *)0);
+#endif //__USE_PROCFS__
+
+#ifdef __USE_SYSFS__
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  VERSION
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	device_remove_file(dev, &dev_attr_version_h);
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  DBGLEVEL
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	device_remove_file(dev, &dev_attr_dbglevel_h);
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  DUMP_PARAMS MODE
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	device_remove_file(dev, &dev_attr_dump_params_h_1);
+	device_remove_file(dev, &dev_attr_dump_params_h_2);
+	device_remove_file(dev, &dev_attr_mode_h_1);
+	device_remove_file(dev, &dev_attr_mode_h_2);
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  HOST STATUS
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	device_remove_file(dev, &dev_attr_host_port_status_1);
+	device_remove_file(dev, &dev_attr_host_port_status_2);
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  DUMP
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	#ifdef __ENABLE_DUMP__
+		device_remove_file(dev, &dev_attr_dump_reg_h_1);
+		device_remove_file(dev, &dev_attr_dump_reg_h_2);
+		device_remove_file(dev, &dev_attr_dump_spram_h_1);
+		device_remove_file(dev, &dev_attr_dump_spram_h_2);
+		device_remove_file(dev, &dev_attr_dump_host_state_1);
+		device_remove_file(dev, &dev_attr_dump_host_state_2);
+	#endif //__ENABLE_DUMP__
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  ANA
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	device_remove_file(dev, &dev_attr_ana_disconnect_threshold_1);
+	device_remove_file(dev, &dev_attr_ana_disconnect_threshold_2);
+	device_remove_file(dev, &dev_attr_ana_squelch_threshold_1);
+	device_remove_file(dev, &dev_attr_ana_squelch_threshold_2);
+	device_remove_file(dev, &dev_attr_ana_transmitter_crossover_1);
+	device_remove_file(dev, &dev_attr_ana_transmitter_crossover_2);
+	device_remove_file(dev, &dev_attr_ana_transmitter_impedance_1);
+	device_remove_file(dev, &dev_attr_ana_transmitter_impedance_2);
+	device_remove_file(dev, &dev_attr_ana_transmitter_dc_voltage_1);
+	device_remove_file(dev, &dev_attr_ana_transmitter_dc_voltage_2);
+	device_remove_file(dev, &dev_attr_ana_transmitter_risefall_time_1);
+	device_remove_file(dev, &dev_attr_ana_transmitter_risefall_time_2);
+	device_remove_file(dev, &dev_attr_ana_transmitter_pre_emphasis_1);
+	device_remove_file(dev, &dev_attr_ana_transmitter_pre_emphasis_2);
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  HOST CTRL
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	device_remove_file(dev, &dev_attr_buspower_1);
+	device_remove_file(dev, &dev_attr_buspower_2);
+	device_remove_file(dev, &dev_attr_protect1_1);
+	device_remove_file(dev, &dev_attr_protect1_2);
+	device_remove_file(dev, &dev_attr_protect2_1);
+	device_remove_file(dev, &dev_attr_protect2_2);
+	device_remove_file(dev, &dev_attr_singlexact_1);
+	device_remove_file(dev, &dev_attr_singlexact_2);
+	device_remove_file(dev, &dev_attr_burst_1);
+	device_remove_file(dev, &dev_attr_burst_2);
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	// PROCSYSFS:  HOST POWER CONTROL
+	/////////////////////////////////////////////////////////////////////////////////////////////////////
+	device_remove_file(dev, &dev_attr_host_suspend_1);
+	device_remove_file(dev, &dev_attr_host_suspend_2);
+	device_remove_file(dev, &dev_attr_bussuspend_1);
+	device_remove_file(dev, &dev_attr_bussuspend_2);
+	device_remove_file(dev, &dev_attr_probe_host_1);
+	device_remove_file(dev, &dev_attr_probe_host_2);
+	device_remove_file(dev, &dev_attr_host_probe_timer_1);
+	device_remove_file(dev, &dev_attr_host_probe_timer_2);
+	device_remove_file(dev, &dev_attr_host_autoprobe_timer_1);
+	device_remove_file(dev, &dev_attr_host_autoprobe_timer_2);
+
+	device_remove_file(dev, &dev_attr_oc_hy_1);
+	device_remove_file(dev, &dev_attr_oc_hy_2);
+#endif //__USE_SYSFS__
+
+#if defined(__HOST_COC__)
+   ltq_pmcu_unregister ( &pmcuRegisterUSBHost_1 );
+   ltq_pmcu_unregister ( &pmcuRegisterUSBHost_2 );
+#endif
+}
+
+
+/* initialize the proc file system and make a dir named /proc/[name] */
+
+
+static void ltqusb_dump_params(ltqusb_core_if_t *_core_if)
+{
+	ltqusb_params_t *params=&_core_if->params;
+
+	LTQ_PRINT("LTQUSB Dump Parameters ( Host Mode) \n");
+	LTQ_PRINT("     Burst size: %d\n",params->dma_burst_size);
+
+	if     (params->speed==1)
+		LTQ_PRINT("Full Speed only\n");
+	else if(params->speed==0)
+		LTQ_PRINT("Full/Hign Speed\n");
+	else
+		LTQ_PRINT("Unkonwn setting (%d) for Speed\n",params->speed);
+
+	LTQ_PRINT("Total Data FIFO size: %d(0x%06X) DWord, %d(0x%06X) Bytes\n",
+		params->data_fifo_size,params->data_fifo_size,
+		params->data_fifo_size*4, params->data_fifo_size*4
+	);
+
+	LTQ_PRINT("Host Channels: %d\n",params->host_channels);
+
+	LTQ_PRINT("Rx FIFO size: %d(0x%06X) DWord, %d(0x%06X) Bytes\n",
+		params->data_fifo_size,params->data_fifo_size,
+		params->data_fifo_size*4, params->data_fifo_size*4
+	);
+
+	LTQ_PRINT("NP Tx FIFO size: %d(0x%06X) DWord, %d(0x%06X) Bytes\n",
+		params->nperio_tx_fifo_size,params->nperio_tx_fifo_size,
+		params->nperio_tx_fifo_size*4, params->nperio_tx_fifo_size*4
+	);
+
+	LTQ_PRINT(" P Tx FIFO size: %d(0x%06X) DWord, %d(0x%06X) Bytes\n",
+		params->perio_tx_fifo_size,params->perio_tx_fifo_size,
+		params->perio_tx_fifo_size*4, params->perio_tx_fifo_size*4
+	);
+
+	LTQ_PRINT("Max Transfer size: %d(0x%06X) Bytes\n",
+		params->max_transfer_size,params->max_transfer_size
+	);
+	LTQ_PRINT("Max Packet Count: %d(0x%06X)\n",
+		params->max_packet_count,params->max_packet_count
+	);
+
+	LTQ_PRINT("PHY UTMI Width: %d\n",params->phy_utmi_width);
+
+	LTQ_PRINT("Timeout Calibration: %d\n",params->timeout_cal);
+
+
+	LTQ_PRINT("==================================================\n");
+	LTQ_PRINT("End of Parameters Dump\n");
+	LTQ_PRINT("==================================================\n");
+}
+
--- a/drivers/usb/host/ltqusb_driver.c
+++ b/drivers/usb/host/ltqusb_driver.c
@@ -0,0 +1,674 @@
+/*****************************************************************************
+ **   FILE NAME       : ltqusb_driver.c
+ **   PROJECT         : Lantiq USB sub-system V3
+ **   MODULES         : Lantiq USB sub-system Host and Device driver
+ **   SRC VERSION     : 3.2
+ **   DATE            : 1/Jan/2011
+ **   AUTHOR          : Chen, Howard
+ **   DESCRIPTION     : The provides the initialization and cleanup entry
+ **                     points for the Lantiq USB driver. This module can be
+ **                     dynamically loaded with insmod command or built-in
+ **                     with kernel. When loaded or executed the ltqusb_driver_init
+ **                     function is called. When the module is removed (using rmmod),
+ **                     the ltqusb_driver_cleanup function is called.
+ **   FUNCTIONS       :
+ **   COMPILER        : gcc
+ **   REFERENCE       : Synopsys DWC-OTG Driver 2.7
+ **   COPYRIGHT       :  Copyright (c) 2010
+ **                      LANTIQ DEUTSCHLAND GMBH,
+ **                      Am Campeon 3, 85579 Neubiberg, Germany
+ **
+ **    This program is free software; you can redistribute it and/or modify
+ **    it under the terms of the GNU General Public License as published by
+ **    the Free Software Foundation; either version 2 of the License, or
+ **    (at your option) any later version.
+ **
+ **  Version Control Section  **
+ **   $Author$
+ **   $Date$
+ **   $Revisions$
+ **   $Log$       Revision history
+ *****************************************************************************/
+
+/*
+ * This file contains code fragments from Synopsys HS OTG Linux Software Driver.
+ * For this code the following notice is applicable:
+ *
+ * ==========================================================================
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+/*!
+ \file ltqusb_driver.c
+ \brief This file contains the loading/unloading interface to the Linux driver.
+*/
+
+#include <linux/version.h>
+#include "ltqusb_version.h"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/stat.h>  /* permission constants */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+	#include <linux/irq.h>
+#endif
+
+#include <asm/io.h>
+//#include <asm/mach-ltqcpe/ltq_regs.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+	#include <asm/irq.h>
+#endif
+
+#include "ltqusb_plat.h"
+
+#include "ltqusb_cif.h"
+
+#include "ltqhcd.h"
+
+#define    USB_DRIVER_DESC		"Lantiq USB HCD driver"
+const char ltqusb_hcd_driver_name[]    = "ltqusb_hcd";
+ltqhcd_hcd_t ltqusb_hcd_1;
+ltqhcd_hcd_t ltqusb_hcd_2;
+const char ltqusb_hcd_name_1[] = "ltqusb_hcd_1";
+const char ltqusb_hcd_name_2[] = "ltqusb_hcd_2";
+
+int ltqusb_oc_shared  =0;
+int ltqusb_vbus_shared=0;
+int ltqusb_led_shared =0;
+
+ltqhcd_hcd_t *oc1_int_target=NULL;
+ltqhcd_hcd_t *oc2_int_target=NULL;
+extern unsigned int  oc1_int_no;
+extern unsigned int  oc2_int_no;
+
+/* Global Debug Level Mask. */
+uint32_t h_dbg_lvl = 0x00;
+
+ltqusb_params_t ltqusb_module_params_h;
+
+static void parse_parms(void);
+
+/* Function to setup the structures to control one usb core running as host*/
+/*!
+   \brief inlined by ltqusb_driver_probe(), handling host mode probing. Run at each host core.
+*/
+static inline int ltqusb_driver_probe_h(ltqhcd_hcd_t *_hcd,
+                                        int           _irq,
+                                        uint32_t      _iobase,
+                                        uint32_t      _fifomem,
+                                        uint32_t      _fifodbg
+                                        )
+{
+	int retval = 0;
+	LTQ_DEBUGPL(DBG_ENTRY, "%s() %d\n", __func__, __LINE__ );
+
+	ltqusb_power_on_h (&_hcd->core_if);
+	mdelay(50);
+	ltqusb_phy_power_on_h  (&_hcd->core_if); // Test
+	mdelay(50);
+	ltqusb_hard_reset_h(&_hcd->core_if);
+
+	retval =ltqusb_core_if_init_h(&_hcd->core_if,
+	                             _irq,
+	                             _iobase,
+	                             _fifomem,
+	                             _fifodbg);
+	if(retval)
+		return retval;
+
+	ltqusb_host_core_init(&_hcd->core_if,&ltqusb_module_params_h);
+
+	ltqusb_disable_global_interrupts_h( &_hcd->core_if);
+
+	/* The driver is now initialized and need to be registered into Linux USB sub-system */
+
+	retval = ltqhcd_init(_hcd); // hook the hcd into usb ss
+
+	if (retval != 0)
+	{
+		LTQ_ERROR("_hcd_init failed\n");
+		return retval;
+	}
+
+	//ltqusb_enable_global_interrupts_h( _hcd->core_if ); // this should be done at hcd_start , including hcd_interrupt
+	return 0;
+}
+
+/*!
+   \brief This function is called when a driver is unregistered. This happens when
+  the rmmod command is executed. The device may or may not be electrically
+  present. If it is present, the driver stops device processing. Any resources
+  used on behalf of this device are freed.
+*/
+static int ltqusb_driver_remove(struct platform_device *_pdev)
+{
+	LTQ_DEBUGPL(DBG_ENTRY, "%s() %d\n", __func__, __LINE__ );
+	ltqhcd_remove(&ltqusb_hcd_1);
+	ltqusb_core_if_remove_h(&ltqusb_hcd_1.core_if );
+	ltqhcd_remove(&ltqusb_hcd_2);
+	ltqusb_core_if_remove_h(&ltqusb_hcd_2.core_if );
+	/* Remove the device attributes */
+	ltqusb_attr_remove_h(&_pdev->dev);
+	return 0;
+}
+
+
+
+
+/*!
+   \brief This function is called by module management in 2.6 kernel or by ltqusb_driver_init with 2.4 kernel
+  It is to probe and setup LTQUSB core(s).
+*/
+static int ltqusb_driver_probe(struct platform_device *_pdev)
+{
+	int retval = 0;
+	struct device_node *np;
+	uint32_t plt;
+	LTQ_DEBUGPL(DBG_ENTRY, "%s() %d\n", __func__, __LINE__ );
+	LTQ_PRINT("%s: version %s\n", ltqusb_hcd_driver_name, LTQUSB_VERSION);
+
+	#if 1
+		#ifdef __PHY_LONG_PREEMP__
+			LTQ_PRINT("   OPTION: __PHY_LONG_PREEMP__\n");
+		#endif
+		#ifdef __FORCE_USB11__
+			LTQ_PRINT("   OPTION: __FORCE_USB11__\n");
+		#endif
+		#ifdef __UNALIGNED_BUF_ADJ__
+			LTQ_PRINT("   OPTION: __UNALIGNED_BUF_ADJ__\n");
+		#endif
+		#ifdef __UNALIGNED_BUF_CHK__
+			LTQ_PRINT("   OPTION: __UNALIGNED_BUF_CHK__\n");
+		#endif
+		#ifdef __UNALIGNED_BUF_BURST__
+			LTQ_PRINT("   OPTION: __UNALIGNED_BUF_BURST__\n");
+		#endif
+		#ifdef __DEBUG__
+			LTQ_PRINT("   OPTION: __DEBUG__\n");
+		#endif
+		#ifdef __ENABLE_DUMP__
+			LTQ_PRINT("   OPTION: __ENABLE_DUMP__\n");
+		#endif
+		#ifdef __NEW_COC__
+			LTQ_PRINT("   OPTION: __NEW_COC__\n");
+		#endif
+		#ifdef __WITH_HS_ELECT_TST__
+			LTQ_PRINT("           __WITH_HS_ELECT_TST__\n");
+		#endif
+		#ifdef __EN_ISOC__
+			LTQ_PRINT("           __EN_ISOC__\n");
+		#endif
+		#ifdef __EN_ISOC_SPLIT__
+			LTQ_PRINT("           __EN_ISOC_SPLIT__\n");
+		#endif
+		#ifdef __EPQD_DESTROY_TIMEOUT__
+			LTQ_PRINT("           __EPQD_DESTROY_TIMEOUT__\n");
+		#endif
+		#ifdef __DYN_SOF_INTR__
+			LTQ_PRINT("           __DYN_SOF_INTR__\n");
+		#endif
+		#ifdef __HOST_COC__
+			LTQ_PRINT("           __HOST_COC__\n");
+		#endif
+		#ifdef __INTRNAKRETRY__
+			LTQ_PRINT("           __INTRNAKRETRY__\n");
+		#endif
+		#ifdef __INTRINCRETRY__
+			LTQ_PRINT("           __INTRINCRETRY__\n");
+		#endif
+	#endif
+
+	memset(&ltqusb_hcd_1, 0, sizeof(ltqhcd_hcd_t));
+	memset(&ltqusb_hcd_2, 0, sizeof(ltqhcd_hcd_t));
+	ltqusb_hcd_1.core_if.core_no=0;
+	ltqusb_hcd_2.core_if.core_no=1;
+	ltqusb_hcd_1.core_if.core_name=(char *)ltqusb_hcd_name_1;
+	ltqusb_hcd_2.core_if.core_name=(char *)ltqusb_hcd_name_2;
+
+	ltqusb_hcd_1.vbusgpioid=-1;
+	ltqusb_hcd_2.vbusgpioid=-1;
+	ltqusb_hcd_1.ledgpioid=-1;
+	ltqusb_hcd_2.ledgpioid=-1;
+
+	for_each_compatible_node(np,NULL,"lantiq,ltqusb")
+	{
+		if(of_property_match_string(np,"status","okay")>=0)
+			break;
+		if(of_property_match_string(np,"status","ok")>=0)
+			break;
+	}
+	if(!np)
+	{
+		LTQ_PRINT("No matching in DTS\n");
+		return -1;
+	}
+
+	ltqusb_chip_family=0;
+	if(of_machine_is_compatible("lantiq,danube")) ltqusb_chip_family= LTQUSB_CHIP_DANUBE;
+	if(of_machine_is_compatible("lantiq,ase")   ) ltqusb_chip_family= LTQUSB_CHIP_ASE;
+	if(of_machine_is_compatible("lantiq,ar9")   ) ltqusb_chip_family= LTQUSB_CHIP_AR9;
+	if(of_machine_is_compatible("lantiq,vr9")   ) ltqusb_chip_family= LTQUSB_CHIP_VR9;
+	if(of_machine_is_compatible("lantiq,ar10")  ) ltqusb_chip_family= LTQUSB_CHIP_AR10;
+	if(of_machine_is_compatible("lantiq,grx390")) ltqusb_chip_family= LTQUSB_CHIP_AR10;
+
+	if(!ltqusb_chip_family)
+	{
+		LTQ_PRINT("No matching in SoC\n");
+		return -1;
+	}
+
+	if(_pdev->num_resources >=8) //dual
+	{
+		ltqusb_hcd_1.core_if.mem1=_pdev->resource[ 0].start;
+		ltqusb_hcd_1.core_if.mem2=_pdev->resource[ 1].start;
+		ltqusb_hcd_1.core_if.mem3=_pdev->resource[ 2].start;
+		ltqusb_hcd_2.core_if.mem1=_pdev->resource[ 3].start;
+		ltqusb_hcd_2.core_if.mem2=_pdev->resource[ 4].start;
+		ltqusb_hcd_2.core_if.mem3=_pdev->resource[ 5].start;
+		ltqusb_hcd_1.core_if.irq =_pdev->resource[ 6].start;
+		ltqusb_hcd_2.core_if.irq =_pdev->resource[ 7].start;
+		if(_pdev->num_resources > 8)
+			ltqusb_hcd_1.core_if.ocirq=
+			ltqusb_hcd_2.core_if.ocirq=_pdev->resource[ 8].start;
+		if(_pdev->num_resources > 9)
+			ltqusb_hcd_2.core_if.ocirq=_pdev->resource[ 9].start;
+
+		ltqusb_hcd_1.vbusgpioid=of_get_named_gpio(np,"vbus",0);
+		ltqusb_hcd_2.vbusgpioid=of_get_named_gpio(np,"vbus",1);
+		ltqusb_hcd_1.ledgpioid =of_get_named_gpio(np,"led",0);
+		ltqusb_hcd_2.ledgpioid =of_get_named_gpio(np,"led",1);
+		if(!gpio_is_valid(ltqusb_hcd_1.vbusgpioid))
+			ltqusb_hcd_1.vbusgpioid=-1;
+		if(!gpio_is_valid(ltqusb_hcd_2.vbusgpioid))
+			ltqusb_hcd_2.vbusgpioid=-1;
+		if(!gpio_is_valid(ltqusb_hcd_1.ledgpioid))
+			ltqusb_hcd_1.ledgpioid=-1;
+		if(!gpio_is_valid(ltqusb_hcd_2.ledgpioid))
+			ltqusb_hcd_2.ledgpioid=-1;
+
+		plt=0;of_property_read_u32_index(np,"oc_off",0,&plt);
+		if(plt)
+			ltqusb_hcd_1.core_if.ocirq=0;
+		plt=0;of_property_read_u32_index(np,"oc_off",1,&plt);
+		if(plt)
+			ltqusb_hcd_2.core_if.ocirq=0;
+
+		plt=0;of_property_read_u32_index(np,"as_host",0,&plt);
+		if(!plt)
+			ltqusb_hcd_1.core_if.irq=0;
+		plt=0;of_property_read_u32_index(np,"as_host",1,&plt);
+		if(!plt)
+			ltqusb_hcd_2.core_if.irq=0;
+	}
+	else
+	{
+		ltqusb_hcd_1.core_if.mem1=_pdev->resource[ 0].start;
+		ltqusb_hcd_1.core_if.mem2=_pdev->resource[ 1].start;
+		ltqusb_hcd_1.core_if.mem3=_pdev->resource[ 2].start;
+		ltqusb_hcd_1.core_if.irq =_pdev->resource[ 3].start;
+		if(_pdev->num_resources > 4)
+			ltqusb_hcd_1.core_if.ocirq=_pdev->resource[ 4].start;
+		ltqusb_hcd_1.vbusgpioid=of_get_named_gpio(np,"vbus",0);
+		ltqusb_hcd_1.ledgpioid=of_get_named_gpio(np,"led",0);
+		plt=0;of_property_read_u32(np,"oc_off",&plt);
+		if(plt)
+			ltqusb_hcd_1.core_if.ocirq=0;
+		plt=0;of_property_read_u32(np,"as_host",&plt);
+		if(!plt)
+			ltqusb_hcd_1.core_if.irq=0;
+	}
+
+	if(!ltqusb_hcd_1.core_if.irq && !ltqusb_hcd_2.core_if.irq)
+	{
+		LTQ_PRINT( "None of the Host Port is enabled\n");
+		return -1;
+	}
+
+	if(!ltqusb_hcd_1.core_if.irq)
+	{
+		ltqusb_hcd_1.core_if.ocirq=0;
+		ltqusb_hcd_1.vbusgpioid=ltqusb_hcd_1.ledgpioid=-1;
+	}
+	if(!ltqusb_hcd_2.core_if.irq)
+	{
+		ltqusb_hcd_2.core_if.ocirq=0;
+		ltqusb_hcd_2.vbusgpioid=ltqusb_hcd_1.ledgpioid=-1;
+	}
+
+	ltqusb_oc_shared=0;
+	ltqusb_vbus_shared=0;
+	ltqusb_led_shared=0;
+
+	if(ltqusb_hcd_1.core_if.ocirq>0 && ltqusb_hcd_2.core_if.ocirq>0 && ltqusb_hcd_1.core_if.ocirq==ltqusb_hcd_2.core_if.ocirq)
+		ltqusb_oc_shared=1;
+	if(ltqusb_hcd_1.vbusgpioid>=0 && ltqusb_hcd_2.vbusgpioid>=0 && ltqusb_hcd_1.vbusgpioid==ltqusb_hcd_2.vbusgpioid)
+		ltqusb_vbus_shared=1;
+	if(ltqusb_hcd_1.ledgpioid>=0 && ltqusb_hcd_2.ledgpioid>=0 && ltqusb_hcd_1.ledgpioid==ltqusb_hcd_2.ledgpioid)
+		ltqusb_led_shared=1;
+	if(ltqusb_oc_shared && !ltqusb_vbus_shared)
+		LTQ_PRINT("Wanring:  OverCurrent Detection shared with both port, but VBus control is not!!\n");
+	if(!ltqusb_oc_shared && ltqusb_vbus_shared)
+		LTQ_PRINT("Wanring:  OverCurrent Detection is not shared with both port, but VBus control is!!\n");
+
+	oc1_int_no    = ltqusb_hcd_1.core_if.ocirq;
+	oc2_int_no    = ltqusb_hcd_2.core_if.ocirq;
+	oc1_int_target=&ltqusb_hcd_1;
+	oc2_int_target=&ltqusb_hcd_2;
+
+	// Parsing and store the parameters
+	LTQ_DEBUGPL(DBG_ENTRY, "%s() %d\n", __func__, __LINE__ );
+	parse_parms();
+
+	if(ltqusb_hcd_1.core_if.irq)
+	{
+		ltqusb_hcd_1.dev=&_pdev->dev;
+
+		retval = ltqusb_driver_probe_h(&ltqusb_hcd_1,
+								ltqusb_hcd_1.core_if.irq,
+								ltqusb_hcd_1.core_if.mem1,
+								ltqusb_hcd_1.core_if.mem2,
+								ltqusb_hcd_1.core_if.mem3);
+		if(retval)
+		{
+			LTQ_ERROR("%s() usb probe() failed\n", __func__);
+			ltqusb_hcd_1.dev=NULL;
+			return (-ENOMEM);
+		}
+	}
+
+	if(ltqusb_hcd_2.core_if.irq)
+	{
+		ltqusb_hcd_2.dev=&_pdev->dev;
+		retval = ltqusb_driver_probe_h(&ltqusb_hcd_2,
+								ltqusb_hcd_2.core_if.irq,
+								ltqusb_hcd_2.core_if.mem1,
+								ltqusb_hcd_2.core_if.mem2,
+								ltqusb_hcd_2.core_if.mem3);
+		if(retval)
+		{
+			LTQ_ERROR("%s() usb probe() failed\n", __func__);
+			ltqusb_hcd_2.dev=NULL;
+			if(ltqusb_hcd_1.dev)
+			{
+				ltqusb_hcd_1.dev=NULL;
+			}
+			return (-ENOMEM);
+		}
+	}
+	ltqusb_attr_create_h(&_pdev->dev);
+	return 0;
+}
+
+
+/*!
+   \brief This function is called when the driver is removed from the kernel
+  with the rmmod command. The driver unregisters itself with its bus
+  driver.
+*/
+static const struct of_device_id ltqhcd_match[] = {
+	{ .compatible = "lantiq,ltqusb"},
+	{},
+};
+
+static struct platform_driver ltqhcd_driver = {
+	.probe = ltqusb_driver_probe,
+	.remove = ltqusb_driver_remove,
+	.driver = {
+		.name = "lantiq,ltqusb",
+		.owner = THIS_MODULE,
+		.of_match_table = ltqhcd_match,
+	},
+};
+
+module_platform_driver(ltqhcd_driver);
+MODULE_DESCRIPTION(USB_DRIVER_DESC);
+MODULE_AUTHOR("Lantiq");
+MODULE_LICENSE("GPL");
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// Parameters set when loaded
+//static long  dbg_lvl =0xFFFFFFFF;
+static long  dbg_lvl =0;
+static short dma_burst_size =-1;
+static short speed =-1;
+static short  host_channels =-1;
+static long  data_fifo_size =-1;
+static long   rx_fifo_size =-1;
+static long   nperio_tx_fifo_size =-1;
+static long   perio_tx_fifo_size =-1;
+
+static long   max_transfer_size =-1;
+static long   max_packet_count =-1;
+static long   phy_utmi_width =-1;
+static long   timeout_cal  =-1;
+static long   oc_hy =-1;
+
+static long   ana_disconnect_threshold=-1;
+static long   ana_squelch_threshold=-1;
+static long   ana_transmitter_crossover=-1;
+static long   ana_transmitter_impedance=-1;
+static long   ana_transmitter_dc_voltage=-1;
+static long   ana_transmitter_risefall_time=-1;
+static long   ana_transmitter_pre_emphasis=-1;
+
+/*!
+   \brief Parsing the parameters taken when module load
+*/
+static void parse_parms(void)
+{
+	ltqusb_params_t *params;
+	LTQ_DEBUGPL(DBG_ENTRY, "%s() %d\n", __func__, __LINE__ );
+	h_dbg_lvl=dbg_lvl;
+	params=&ltqusb_module_params_h;
+
+	//Setting Default
+	params->speed=default_param_speed;
+	if(ltqusb_chip_family==LTQUSB_CHIP_DANUBE)
+	{
+	}
+	if(ltqusb_chip_family==LTQUSB_CHIP_ASE)
+	{
+	}
+	if(ltqusb_chip_family==LTQUSB_CHIP_AR9)
+	{
+		params->dma_burst_size     =AR9_param_dma_burst_size;
+		params->max_transfer_size  =AR9_param_max_transfer_size;
+		params->max_packet_count   =AR9_param_max_packet_count;
+		params->phy_utmi_width     =AR9_param_phy_utmi_width;
+		params->timeout_cal        =AR9_param_timeout_cal;
+		params->host_channels      =AR9_param_host_channels;
+		params->data_fifo_size     =AR9_param_data_fifo_size;
+		params->rx_fifo_size       =AR9_param_rx_fifo_size;
+		params->nperio_tx_fifo_size=AR9_param_nperio_tx_fifo_size;
+		params->perio_tx_fifo_size =AR9_param_perio_tx_fifo_size;
+		params->ana_disconnect_threshold=AR9_param_ana_disconnect_threshold;
+		params->ana_squelch_threshold   =AR9_param_ana_squelch_threshold;
+		params->ana_transmitter_crossover=AR9_param_ana_transmitter_crossover;
+		params->ana_transmitter_impedance=AR9_param_ana_transmitter_impedance;
+		params->ana_transmitter_dc_voltage=AR9_param_ana_transmitter_dc_voltage;
+		params->ana_transmitter_risefall_time=AR9_param_ana_transmitter_risefall_time;
+		params->ana_transmitter_pre_emphasis=AR9_param_ana_transmitter_pre_emphasis;
+	}
+	if(ltqusb_chip_family==LTQUSB_CHIP_VR9)
+	{
+		params->dma_burst_size     =VR9_param_dma_burst_size;
+		{
+			unsigned int chipid;
+			unsigned int partnum;
+			chipid=*((volatile uint32_t *)LTQ_MPS_CHIPID);
+			partnum=(chipid&0x0FFFF000)>>12;
+			switch(partnum)
+			{
+				case 0x000B: //VRX288_A2x
+				case 0x000E: //VRX282_A2x
+				case 0x000C: //VRX268_A2x
+				case 0x000D: //GRX288_A2x
+					params->dma_burst_size=VR9_param_dma_burst_size_n;
+					break;
+			}
+			printk(KERN_INFO "Chip Version :%04x BurstSize=%d\n",partnum,params->dma_burst_size);
+		}
+		params->max_transfer_size  =VR9_param_max_transfer_size;
+		params->max_packet_count   =VR9_param_max_packet_count;
+		params->phy_utmi_width     =VR9_param_phy_utmi_width;
+		params->timeout_cal        =VR9_param_timeout_cal;
+		params->host_channels      =VR9_param_host_channels;
+		params->data_fifo_size     =VR9_param_data_fifo_size;
+		params->rx_fifo_size       =VR9_param_rx_fifo_size;
+		params->nperio_tx_fifo_size=VR9_param_nperio_tx_fifo_size;
+		params->perio_tx_fifo_size =VR9_param_perio_tx_fifo_size;
+		params->ana_disconnect_threshold=VR9_param_ana_disconnect_threshold;
+		params->ana_squelch_threshold   =VR9_param_ana_squelch_threshold;
+		params->ana_transmitter_crossover=VR9_param_ana_transmitter_crossover;
+		params->ana_transmitter_impedance=VR9_param_ana_transmitter_impedance;
+		params->ana_transmitter_dc_voltage=VR9_param_ana_transmitter_dc_voltage;
+		params->ana_transmitter_risefall_time=VR9_param_ana_transmitter_risefall_time;
+		params->ana_transmitter_pre_emphasis=VR9_param_ana_transmitter_pre_emphasis;
+	}
+	if(ltqusb_chip_family==LTQUSB_CHIP_AR10)
+	{
+		params->dma_burst_size     =AR10_param_dma_burst_size;
+		params->max_transfer_size  =AR10_param_max_transfer_size;
+		params->max_packet_count   =AR10_param_max_packet_count;
+		params->phy_utmi_width     =AR10_param_phy_utmi_width;
+		params->oc_hy=AR10_param_oc_hy;
+		params->timeout_cal        =AR10_param_timeout_cal;
+		params->host_channels      =AR10_param_host_channels;
+		params->data_fifo_size     =AR10_param_data_fifo_size;
+		params->rx_fifo_size       =AR10_param_rx_fifo_size;
+		params->nperio_tx_fifo_size=AR10_param_nperio_tx_fifo_size;
+		params->perio_tx_fifo_size =AR10_param_perio_tx_fifo_size;
+		params->ana_disconnect_threshold=AR10_param_ana_disconnect_threshold;
+		params->ana_squelch_threshold   =AR10_param_ana_squelch_threshold;
+		params->ana_transmitter_crossover=AR10_param_ana_transmitter_crossover;
+		params->ana_transmitter_impedance=AR10_param_ana_transmitter_impedance;
+		params->ana_transmitter_dc_voltage=AR10_param_ana_transmitter_dc_voltage;
+		params->ana_transmitter_risefall_time=AR10_param_ana_transmitter_risefall_time;
+		params->ana_transmitter_pre_emphasis=AR10_param_ana_transmitter_pre_emphasis;
+	}
+
+//////////////////////////////////////////////////////////////////////////////
+	//Setting New
+	switch(dma_burst_size)
+	{
+		case 0:
+		case 1:
+		case 4:
+		case 8:
+		case 16:
+			params->dma_burst_size=dma_burst_size;
+			break;
+	}
+
+	if(speed==0 || speed==1)
+		params->speed=speed;
+	if(max_transfer_size>=2048 && max_transfer_size<=65535)
+		params->max_transfer_size=max_transfer_size;
+	if(max_packet_count>=15 && max_packet_count<=511)
+		params->max_packet_count=max_packet_count;
+	switch(phy_utmi_width)
+	{
+		case 8:
+		case 16:
+			params->phy_utmi_width=phy_utmi_width;
+			break;
+	}
+
+	if(ltqusb_chip_family==LTQUSB_CHIP_AR10)
+	{
+		if(oc_hy>=0 && oc_hy<=3)
+			params->oc_hy=oc_hy;
+		if(params->oc_hy>=0 && params->oc_hy<=3)
+		{
+			ltqusb_oc_set_hy(1,params->oc_hy);
+			ltqusb_oc_set_hy(2,params->oc_hy);
+		}
+	}
+
+	if(timeout_cal>=0 && timeout_cal<=7)
+		params->timeout_cal=timeout_cal;
+	if(host_channels>=1 && host_channels<=16)
+		params->host_channels=host_channels;
+	if(data_fifo_size>=32 && data_fifo_size<=32768)
+		params->data_fifo_size=data_fifo_size;
+	if(rx_fifo_size>=16 && rx_fifo_size<=32768)
+		params->rx_fifo_size=rx_fifo_size;
+	if(nperio_tx_fifo_size>=16 && nperio_tx_fifo_size<=32768)
+		params->nperio_tx_fifo_size=nperio_tx_fifo_size;
+	if(perio_tx_fifo_size>=16 && perio_tx_fifo_size<=32768)
+		params->perio_tx_fifo_size=perio_tx_fifo_size;
+	if(ana_disconnect_threshold>=0 && ana_disconnect_threshold<=7)
+		params->ana_disconnect_threshold=ana_disconnect_threshold;
+	if(ana_squelch_threshold>=0 && ana_squelch_threshold<=7)
+		params->ana_squelch_threshold=ana_squelch_threshold;
+	if(ana_transmitter_crossover>=0 && ana_transmitter_crossover<=3)
+		params->ana_transmitter_crossover=ana_transmitter_crossover;
+	if(ana_transmitter_impedance>=0 && ana_transmitter_impedance<=15)
+		params->ana_transmitter_impedance=ana_transmitter_impedance;
+	if(ana_transmitter_dc_voltage>=0 && ana_transmitter_dc_voltage<=15)
+		params->ana_transmitter_dc_voltage=ana_transmitter_dc_voltage;
+	if(ana_transmitter_risefall_time>=0 && ana_transmitter_risefall_time<=1)
+		params->ana_transmitter_risefall_time=ana_transmitter_risefall_time;
+	if(ana_transmitter_pre_emphasis>=0 && ana_transmitter_pre_emphasis<=1)
+		params->ana_transmitter_pre_emphasis=ana_transmitter_pre_emphasis;
+}
+
+
+
--- a/drivers/usb/host/ltqusb_plat.h
+++ b/drivers/usb/host/ltqusb_plat.h
@@ -0,0 +1,367 @@
+/*****************************************************************************
+ **   FILE NAME       : ltqusb_plat.h
+ **   PROJECT         : Lantiq USB sub-system V3
+ **   MODULES         : Lantiq USB sub-system Host and Device driver
+ **   SRC VERSION     : 3.2
+ **   DATE            : 1/Jan/2011
+ **   AUTHOR          : Chen, Howard
+ **   DESCRIPTION     : This file contains the Platform Specific constants, interfaces
+ **                     (functions and macros).
+ **   FUNCTIONS       :
+ **   COMPILER        : gcc
+ **   REFERENCE       : Synopsys DWC-OTG Driver 2.7
+ **   COPYRIGHT       :  Copyright (c) 2010
+ **                      LANTIQ DEUTSCHLAND GMBH,
+ **                      Am Campeon 3, 85579 Neubiberg, Germany
+ **
+ **    This program is free software; you can redistribute it and/or modify
+ **    it under the terms of the GNU General Public License as published by
+ **    the Free Software Foundation; either version 2 of the License, or
+ **    (at your option) any later version.
+ **
+ **  Version Control Section  **
+ **   $Author$
+ **   $Date$
+ **   $Revisions$
+ **   $Log$       Revision history
+ *****************************************************************************/
+
+/*
+ * This file contains code fragments from Synopsys HS OTG Linux Software Driver.
+ * For this code the following notice is applicable:
+ *
+ * ==========================================================================
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+
+/*!
+  \defgroup LTQUSB_PLATEFORM_DEFINITION Platform Specific constants, interfaces (functions and macros).
+  \ingroup LTQUSB_DRIVER_V3
+  \brief Maintain plateform specific definitions and macros in this file.
+         Each plateform has its own definition zone.
+ */
+
+/*!
+  \defgroup LTQUSB_PLATEFORM_MEM_ADDR Definition of memory address and size and default parameters
+  \ingroup LTQUSB_PLATEFORM_DEFINITION
+ */
+
+/*!
+  \defgroup LTQUSB_DBG_ROUTINE Routines for debug message
+  \ingroup LTQUSB_PLATEFORM_DEFINITION
+ */
+
+
+/*! \file ltqusb_plat.h
+    \ingroup LTQUSB_DRIVER_V3
+    \brief This file contains the Platform Specific constants, interfaces (functions and macros).
+*/
+
+#if !defined(__LTQUSB_PLAT_H__)
+#define __LTQUSB_PLAT_H__
+
+
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+
+
+#define LTQUSB_IOMEM_SIZE   0x00001000
+#define LTQUSB_FIFOMEM_SIZE 0x00010000
+#define LTQUSB_FIFODBG_SIZE 0x00020000
+
+
+
+/*!
+  \addtogroup LTQUSB_PLATEFORM_MEM_ADDR
+ */
+/*@{*/
+
+#ifndef LTQ_MPS
+	#define LTQ_MPS								(KSEG1+0x1F107000)
+#endif
+#ifndef LTQ_MPS_CHIPID
+	#define LTQ_MPS_CHIPID						((volatile unsigned long *)(LTQ_MPS + 0x0344))
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////////
+////AR9 Section
+//////////////////////////////////////////////////////////////////////////////
+#define AR9_RCU_BASE_ADDR                (0xBF203000)
+#define AR9_CGU                          (0xBF103000)
+#define AR9_CGU_IFCCR                    ((volatile unsigned long *)(AR9_CGU+ 0x0018))
+#define AR9_RCU_USB1CFG                  ((volatile unsigned long *)(AR9_RCU_BASE_ADDR + 0x18))
+#define AR9_RCU_USB2CFG                  ((volatile unsigned long *)(AR9_RCU_BASE_ADDR + 0x34))
+#define AR9_RCU_USBRESET                 ((volatile unsigned long *)(AR9_RCU_BASE_ADDR + 0x10))
+
+#define AR9_USBCFG_ARB          7	//
+#define AR9_USBCFG_HDSEL_BIT    11	// 0:host, 1:device
+#define AR9_USBCFG_HOST_END_BIT 10	// 0:little_end, 1:big_end
+#define AR9_USBCFG_SLV_END_BIT  17	// 0:little_end, 1:big_end
+
+#define AR9_param_dma_burst_size      4
+
+#define AR9_param_max_transfer_size   -1  //(Max, hwcfg)
+#define AR9_param_max_packet_count    -1  //(Max, hwcfg)
+#define AR9_param_phy_utmi_width      16
+
+#define AR9_param_timeout_cal         -1 //(NoChange)
+
+#define AR9_param_data_fifo_size      -1 //(Max, hwcfg)
+
+#define AR9_param_host_channels       -1 //(Max, hwcfg)
+#define AR9_param_rx_fifo_size        240
+#define AR9_param_nperio_tx_fifo_size 240
+#define AR9_param_perio_tx_fifo_size  32
+
+#define AR9_param_ana_disconnect_threshold      -1
+#define AR9_param_ana_squelch_threshold         -1
+#define AR9_param_ana_transmitter_crossover     -1
+#define AR9_param_ana_transmitter_impedance     -1
+#define AR9_param_ana_transmitter_dc_voltage    -1
+#define AR9_param_ana_transmitter_risefall_time -1
+#define AR9_param_ana_transmitter_pre_emphasis  -1
+//////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////////////
+////VR9 Section
+//////////////////////////////////////////////////////////////////////////////
+#define VR9_RCU_BASE_ADDR                    (0xBF203000)
+#define VR9_RCU_USB1CFG   ((volatile unsigned long *)(VR9_RCU_BASE_ADDR + 0x18))
+#define VR9_RCU_USB2CFG   ((volatile unsigned long *)(VR9_RCU_BASE_ADDR + 0x34))
+#define VR9_RCU_USB_ANA_CFG1A  ((volatile unsigned long *)(VR9_RCU_BASE_ADDR + 0x38))
+#define VR9_RCU_USB_ANA_CFG1B  ((volatile unsigned long *)(VR9_RCU_BASE_ADDR + 0x3C))
+#define VR9_RCU_USBRESET  ((volatile unsigned long *)(VR9_RCU_BASE_ADDR + 0x10))
+#define VR9_RCU_USBRESET2 ((volatile unsigned long *)(VR9_RCU_BASE_ADDR + 0x48))
+
+#define VR9_USBCFG_ARB          7	//
+#define VR9_USBCFG_HDSEL_BIT    11	// 0:host, 1:device
+#define VR9_USBCFG_HOST_END_BIT 10	// 0:little_end, 1:big_end
+#define VR9_USBCFG_SLV_END_BIT  9	// 0:little_end, 1:big_end
+
+#define VR9_param_dma_burst_size   0      //(ALL)
+#define VR9_param_dma_burst_size_n 4      //(ALL)
+
+#define VR9_param_max_transfer_size -1  //(Max, hwcfg)
+#define VR9_param_max_packet_count  -1  //(Max, hwcfg)
+#define VR9_param_phy_utmi_width    16
+
+#define VR9_param_timeout_cal         -1 //(NoChange)
+
+#define VR9_param_data_fifo_size      -1 //(Max, hwcfg)
+
+#define VR9_param_host_channels       -1 //(Max, hwcfg)
+#define VR9_param_rx_fifo_size        240
+#define VR9_param_nperio_tx_fifo_size 240
+#define VR9_param_perio_tx_fifo_size  32
+
+#define VR9_param_ana_disconnect_threshold      7
+#define VR9_param_ana_squelch_threshold         -1
+#define VR9_param_ana_transmitter_crossover     -1
+#define VR9_param_ana_transmitter_impedance     -1
+#define VR9_param_ana_transmitter_dc_voltage    -1
+#define VR9_param_ana_transmitter_risefall_time -1
+#if  defined(__PHY_LONG_PREEMP__)
+	#define VR9_param_ana_transmitter_pre_emphasis  1
+#else
+	#define VR9_param_ana_transmitter_pre_emphasis  -1
+#endif
+//////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////////////
+////AR10 Section
+//////////////////////////////////////////////////////////////////////////////
+#define AR10_RCU_BASE_ADDR            (0xBF203000)
+
+#define AR10_RCU_USB1CFG   ((volatile unsigned long *)(AR10_RCU_BASE_ADDR + 0x18))
+#define AR10_RCU_USB2CFG   ((volatile unsigned long *)(AR10_RCU_BASE_ADDR + 0x34))
+#define AR10_RCU_USB_ANA_CFG1A  ((volatile unsigned long *)(AR10_RCU_BASE_ADDR + 0x38))
+#define AR10_RCU_USB_ANA_CFG1B  ((volatile unsigned long *)(AR10_RCU_BASE_ADDR + 0x3C))
+#define AR10_RCU_USBRESET  ((volatile unsigned long *)(AR10_RCU_BASE_ADDR + 0x10))
+
+#define AR10_USBCFG_ARB          7	//
+#define AR10_USBCFG_HDSEL_BIT    11	// 0:host, 1:device
+#define AR10_USBCFG_HOST_END_BIT 10	// 0:little_end, 1:big_end
+#define AR10_USBCFG_SLV_END_BIT  9	// 0:little_end, 1:big_end
+#define AR10_USBCFG_OC_EN_BIT    0	//
+#define AR10_USBCFG_OC_HY_BIT    1	//
+#define AR10_USBCFG_OC_HY_MASK   0x3
+
+#define AR10_param_dma_burst_size 4      //(ALL)
+
+
+#define AR10_param_max_transfer_size -1  //(Max, hwcfg)
+#define AR10_param_max_packet_count  -1  //(Max, hwcfg)
+#define AR10_param_phy_utmi_width    16
+
+#define AR10_param_timeout_cal         -1 //(NoChange)
+
+#define AR10_param_oc_hy               -1 //(NoChange)
+
+#define AR10_param_data_fifo_size      -1 //(Max, hwcfg)
+
+#define AR10_param_host_channels       -1 //(Max, hwcfg)
+#define AR10_param_rx_fifo_size        240
+#define AR10_param_nperio_tx_fifo_size 240
+#define AR10_param_perio_tx_fifo_size  32
+
+#define AR10_param_ana_disconnect_threshold      7
+#define AR10_param_ana_squelch_threshold         -1
+#define AR10_param_ana_transmitter_crossover     -1
+#define AR10_param_ana_transmitter_impedance     -1
+#define AR10_param_ana_transmitter_dc_voltage    -1
+#define AR10_param_ana_transmitter_risefall_time -1
+#if  defined(__PHY_LONG_PREEMP__)
+	#define AR10_param_ana_transmitter_pre_emphasis  1
+#else
+	#define AR10_param_ana_transmitter_pre_emphasis  -1
+#endif
+//////////////////////////////////////////////////////////////////////////////
+
+/*@}*//*LTQUSB_PLATEFORM_MEM_ADDR*/
+
+/////////////////////////////////////////////////////////////////////////
+
+#if defined(CONFIG_USB_HOST_LTQ_FORCE_USB11) || defined(__FORCE_USB11__)
+	#define default_param_speed               LTQUSB_PARAM_SPEED_FULL
+#else
+	#define default_param_speed               LTQUSB_PARAM_SPEED_HIGH
+#endif
+
+
+/////////////////////////////////////////////////////////////////////////
+
+static __inline__ void UDELAY( const uint32_t _usecs )
+{
+	udelay( _usecs );
+}
+
+static __inline__ void MDELAY( const uint32_t _msecs )
+{
+	mdelay( _msecs );
+}
+
+static __inline__ void SPIN_LOCK( spinlock_t *_lock )
+{
+	spin_lock(_lock);
+}
+
+static __inline__ void SPIN_UNLOCK( spinlock_t *_lock )
+{
+	spin_unlock(_lock);
+}
+
+#define SPIN_LOCK_IRQSAVE( _l, _f )  \
+	{ \
+	spin_lock_irqsave(_l,_f); \
+	}
+
+#define SPIN_UNLOCK_IRQRESTORE( _l,_f ) \
+	{ \
+	spin_unlock_irqrestore(_l,_f); \
+	}
+
+/////////////////////////////////////////////////////////////////////////
+/*!
+  \addtogroup LTQUSB_DBG_ROUTINE
+ */
+/*@{*/
+extern uint32_t h_dbg_lvl;
+
+/*! \brief When debug level has the DBG_CIL bit set, display CIL Debug messages. */
+#define DBG_CIL		(0x2)
+/*! \brief When debug level has the DBG_CILV bit set, display CIL Verbose debug messages */
+#define DBG_CILV	(0x20)
+/*! \brief When debug level has the DBG_PCD bit set, display PCD (Device) debug messages */
+#define DBG_PCD		(0x4)
+/*! \brief When debug level has the DBG_PCDV set, display PCD (Device) Verbose debug messages */
+#define DBG_PCDV	(0x40)
+/*! \brief When debug level has the DBG_HCD bit set, display Host debug messages */
+#define DBG_HCD		(0x8)
+/*! \brief When debug level has the DBG_HCDV bit set, display Verbose Host debug messages */
+#define DBG_HCDV	(0x80)
+/*! \brief When debug level has the DBG_HCD_URB bit set, display enqueued URBs in host mode. */
+#define DBG_HCD_URB_CTRL     (0x0200)
+#define DBG_HCD_URB_BULK_IN  (0x0400)
+#define DBG_HCD_URB_BULK_OUT (0x0800)
+#define DBG_HCD_URB_INTR_IN  (0x1000)
+#define DBG_HCD_URB_INTR_OUT (0x2000)
+#define DBG_HCD_URB_ISOC_IN  (0x4000)
+#define DBG_HCD_URB_ISOC_OUT (0x8000)
+
+/*! \brief When debug level has any bit set, display debug messages */
+#define DBG_ANY		(0xFF)
+/*! \brief All debug messages off */
+#define DBG_OFF		0
+
+#define DBG_ENTRY	(0x0100)
+
+#define LTQUSB "LTQUSB: "
+
+/*!
+   \fn    inline uint32_t SET_DEBUG_LEVEL( const uint32_t _new )
+   \brief Set the Debug Level variable.
+   \param _new 32-bit mask of debug level.
+   \return previous debug level
+ */
+static inline uint32_t SET_DEBUG_LEVEL( const uint32_t _new )
+{
+	uint32_t old = h_dbg_lvl;
+	h_dbg_lvl = _new;
+	return old;
+}
+
+#ifdef __DEBUG__
+	# define LTQ_DEBUGPL(lvl, x...) do{ if ((lvl)&h_dbg_lvl)printk( KERN_DEBUG LTQUSB x ); }while(0)
+	# define CHK_DEBUG_LEVEL(level) ((level) & h_dbg_lvl)
+
+	# define LTQ_DEBUGP(x...)	LTQ_DEBUGPL(DBG_ANY, x )
+#else
+	# define LTQ_DEBUGPL(lvl, x...) do{}while(0)
+	# define LTQ_DEBUGP(x...)
+	# define CHK_DEBUG_LEVEL(level) (0)
+#endif //__DEBUG__
+
+/* Print an Error message. */
+#define LTQ_ERROR(x...) printk( KERN_ERR LTQUSB x )
+/* Print a Warning message. */
+#define LTQ_WARN(x...) printk( KERN_WARNING LTQUSB x )
+/* Print a notice (normal but significant message). */
+#define LTQ_NOTICE(x...) printk( KERN_NOTICE LTQUSB x )
+/*  Basic message printing. */
+#define LTQ_PRINT(x...) printk( KERN_INFO LTQUSB x )
+
+/*@}*//*LTQUSB_DBG_ROUTINE*/
+
+
+#endif //__LTQUSB_PLAT_H__
+
--- a/drivers/usb/host/ltqusb_regs.h
+++ b/drivers/usb/host/ltqusb_regs.h
@@ -0,0 +1,1499 @@
+/*****************************************************************************
+ **   FILE NAME       : ltqusb_regs.h
+ **   PROJECT         : Lantiq USB sub-system V3
+ **   MODULES         : Lantiq USB sub-system Host and Device driver
+ **   SRC VERSION     : 3.2
+ **   DATE            : 1/Jan/2011
+ **   AUTHOR          : Chen, Howard
+ **   DESCRIPTION     : This file contains the data structures for accessing the LTQUSB core
+ **                     registers.
+ **                     The application interfaces with the USB core by reading from and
+ **                     writing to the Control and Status Register (CSR) space through the
+ **                     AHB Slave interface. These registers are 32 bits wide, and the
+ **                     addresses are 32-bit-block aligned.
+ **                     CSRs are classified as follows:
+ **                     - Core Global Registers
+ **                     - Device Mode Registers
+ **                     - Device Global Registers
+ **                     - Device Endpoint Specific Registers
+ **                     - Host Mode Registers
+ **                     - Host Global Registers
+ **                     - Host Port CSRs
+ **                     - Host Channel Specific Registers
+ **
+ **                     Only the Core Global registers can be accessed in both Device and
+ **                     Host modes. When the USB core is operating in one mode, either
+ **                     Device or Host, the application must not access registers from the
+ **                     other mode. When the core switches from one mode to another, the
+ **                     registers in the new mode of operation must be reprogrammed as they
+ **                     would be after a power-on reset.
+ **   FUNCTIONS       :
+ **   COMPILER        : gcc
+ **   REFERENCE       : Synopsys DWC-OTG Driver 2.7
+ **   COPYRIGHT       :  Copyright (c) 2010
+ **                      LANTIQ DEUTSCHLAND GMBH,
+ **                      Am Campeon 3, 85579 Neubiberg, Germany
+ **
+ **    This program is free software; you can redistribute it and/or modify
+ **    it under the terms of the GNU General Public License as published by
+ **    the Free Software Foundation; either version 2 of the License, or
+ **    (at your option) any later version.
+ **
+ **  Version Control Section  **
+ **   $Author$
+ **   $Date$
+ **   $Revisions$
+ **   $Log$       Revision history
+*****************************************************************************/
+/******************************************************************************
+** COPYRIGHT    :   Copyright (c) 2006
+**      Lantiq Technologies AG
+**      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 10 NOV 2008  Wu Qi Ming      Initial Version, to comply with COC
+*******************************************************************************/
+
+
+/*
+ * This file contains code fragments from Synopsys HS OTG Linux Software Driver.
+ * For this code the following notice is applicable:
+ *
+ * ==========================================================================
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+
+/*!
+  \defgroup LTQUSB_CSR_DEFINITION Control and Status Register bit-map definition
+  \ingroup LTQUSB_DRIVER_V3
+   \brief Data structures for accessing the LTQUSB core registers.
+          The application interfaces with the USB core by reading from and
+          writing to the Control and Status Register (CSR) space through the
+          AHB Slave interface. These registers are 32 bits wide, and the
+          addresses are 32-bit-block aligned.
+          CSRs are classified as follows:
+           - Core Global Registers
+           - Device Mode Registers
+           - Device Global Registers
+           - Device Endpoint Specific Registers
+           - Host Mode Registers
+           - Host Global Registers
+           - Host Port CSRs
+           - Host Channel Specific Registers
+
+          Only the Core Global registers can be accessed in both Device andHost modes.
+          When the USB core is operating in one mode, either Device or Host, the
+          application must not access registers from the other mode. When the core
+          switches from one mode to another, the registers in the new mode of operation
+          must be reprogrammed as they would be after a power-on reset.
+ */
+
+/*!
+  \defgroup LTQUSB_CSR_DEVICE_GLOBAL_REG Device Mode Registers
+  \ingroup LTQUSB_CSR_DEFINITION
+  \brief Bit-mapped structure to access Device Mode Global Registers
+ */
+
+/*!
+  \defgroup LTQUSB_CSR_DEVICE_EP_REG Device Mode EP Registers
+  \ingroup LTQUSB_CSR_DEFINITION
+    \brief Bit-mapped structure to access Device Mode EP Registers
+     There will be one set of endpoint registers per logical endpoint
+     implemented.
+     These registers are visible only in Device mode and must not be
+     accessed in Host mode, as the results are unknown.
+ */
+
+/*!
+  \defgroup LTQUSB_CSR_DEVICE_DMA_DESC Device mode scatter dma descriptor strusture
+  \ingroup LTQUSB_CSR_DEFINITION
+  \brief Bit-mapped structure to DMA descriptor
+ */
+
+
+/*!
+  \defgroup LTQUSB_CSR_HOST_GLOBAL_REG Host Mode Registers
+  \ingroup LTQUSB_CSR_DEFINITION
+  \brief Bit-mapped structure to access Host Mode Global Registers
+ */
+
+/*!
+  \defgroup LTQUSB_CSR_HOST_HC_REG Host Mode HC Registers
+  \ingroup LTQUSB_CSR_DEFINITION
+    \brief Bit-mapped structure to access Host Mode Host Channel Registers
+     There will be one set of endpoint registers per host channel
+     implemented.
+     These registers are visible only in Host mode and must not be
+     accessed in Device mode, as the results are unknown.
+ */
+
+/*!
+  \defgroup LTQUSB_CSR_PWR_CLK_GATING_REG Power and Clock Gating Control Register
+  \ingroup LTQUSB_CSR_DEFINITION
+  \brief Bit-mapped structure to Power and Clock Gating Control Register
+ */
+
+/*!
+  \defgroup LTQUSB_CSR_CORE_GLOBAL_REG Core Global Registers
+  \ingroup LTQUSB_CSR_DEFINITION
+  \brief Bit-mapped structure to access Core Global Registers
+ */
+
+/*!
+  \defgroup LTQUSB_CSR_CORE_GLOBAL_REG Core Global Registers
+  \ingroup LTQUSB_CSR_DEFINITION
+  \brief Bit-mapped structure to access Core Global Registers
+ */
+
+
+
+/*!
+  \defgroup LTQUSB_CSR_ACCESS_MACROS Macros to manipulate CSRs
+  \ingroup LTQUSB_CSR_DEFINITION
+  \brief Macros to manipulate CSRs
+ */
+
+
+
+
+
+
+/*!
+  \file ltqusb_regs.h
+  \ingroup LTQUSB_DRIVER_V3
+  \brief This file contains the data structures for accessing the LTQUSB core registers.
+ */
+
+
+#ifndef __LTQUSB_REGS_H__
+#define __LTQUSB_REGS_H__
+
+/****************************************************************************/
+
+#define MAX_PERIO_FIFOS  15  /** Maximum number of Periodic FIFOs */
+#define MAX_TX_FIFOS     15  /** Maximum number of Periodic FIFOs */
+#define MAX_EPS_CHANNELS 16  /** Maximum number of Endpoints/HostChannels */
+
+/****************************************************************************/
+
+//#define __RecordRegRW__
+
+/*!
+   \fn    static __inline__ uint32_t ltqusb_rreg( volatile uint32_t *_reg)
+   \brief Reads the content of a register.
+   \param  _reg address of register to read.
+   \return contents of the register.
+   \ingroup LTQUSB_CSR_ACCESS_MACROS
+ */
+static __inline__ uint32_t ltqusb_rreg( volatile uint32_t *_reg)
+{
+	#ifdef __RecordRegRW__
+		uint32_t r;
+		r=*(_reg);
+		return (r);
+	#else
+		return (*(_reg));
+	#endif
+};
+
+
+/*!
+   \fn    static __inline__ void ltqusb_wreg( volatile uint32_t *_reg, const uint32_t _value)
+   \brief Writes a register with a 32 bit value.
+   \param _reg   address of register to write.
+   \param _value value to write to _reg.
+   \ingroup LTQUSB_CSR_ACCESS_MACROS
+ */
+static __inline__ void ltqusb_wreg( volatile uint32_t *_reg, const uint32_t _value)
+{
+	#ifdef __RecordRegRW__
+		printk(KERN_INFO "[W %p<-%08X]\n",_reg,_value);
+	#else
+		*(_reg)=_value;
+	#endif
+};
+
+/*!
+   \fn    static __inline__ void ltqusb_mreg( volatile uint32_t *_reg, const uint32_t _clear_mask, const uint32_t _set_mask)
+   \brief Modifies bit values in a register.  Using the
+          algorithm: (reg_contents & ~clear_mask) | set_mask.
+   \param _reg        address of register to modify.
+   \param _clear_mask bit mask to be cleared.
+   \param _set_mask   bit mask to be set.
+   \ingroup LTQUSB_CSR_ACCESS_MACROS
+ */
+static __inline__ void ltqusb_mreg( volatile uint32_t *_reg, const uint32_t _clear_mask, const uint32_t _set_mask)
+{
+	uint32_t v;
+	#ifdef __RecordRegRW__
+		uint32_t r;
+		v=  *(_reg);
+		r=v;
+		r&=(~_clear_mask);
+		r|= _set_mask;
+		*(_reg)=r ;
+		printk(KERN_INFO "[M %p->%08X+%08X/%08X<-%08X]\n",_reg,r,_clear_mask,_set_mask,r);
+	#else
+		v=  *(_reg);
+		v&=(~_clear_mask);
+		v|= _set_mask;
+		*(_reg)=v ;
+	#endif
+};
+
+/****************************************************************************/
+
+/*!
+  \addtogroup LTQUSB_CSR_CORE_GLOBAL_REG
+ */
+/*@{*/
+
+/*! typedef ltqusb_core_global_regs_t
+ \brief LTQUSB Core registers .
+         The ltqusb_core_global_regs structure defines the size
+         and relative field offsets for the Core Global registers.
+ */
+typedef struct ltqusb_core_global_regs
+{
+	volatile uint32_t gotgctl;             /*!< 000h OTG Control and Status Register. */
+	volatile uint32_t gotgint;             /*!< 004h OTG Interrupt Register. */
+	volatile uint32_t gahbcfg;             /*!< 008h Core AHB Configuration Register. */
+	volatile uint32_t gusbcfg;             /*!< 00Ch Core USB Configuration Register. */
+	volatile uint32_t grstctl;             /*!< 010h Core Reset Register. */
+	volatile uint32_t gintsts;             /*!< 014h Core Interrupt Register. */
+	volatile uint32_t gintmsk;             /*!< 018h Core Interrupt Mask Register. */
+	volatile uint32_t grxstsr;             /*!< 01Ch Receive Status Queue Read Register (Read Only). */
+	volatile uint32_t grxstsp;             /*!< 020h Receive Status Queue Read & POP Register (Read Only). */
+	volatile uint32_t grxfsiz;             /*!< 024h Receive FIFO Size Register. */
+	volatile uint32_t gnptxfsiz;           /*!< 028h Non Periodic Transmit FIFO Size Register. */
+	volatile uint32_t gnptxsts;            /*!< 02Ch Non Periodic Transmit FIFO/Queue Status Register (Read Only). */
+	volatile uint32_t gi2cctl;             /*!< 030h I2C Access Register. */
+	volatile uint32_t gpvndctl;            /*!< 034h PHY Vendor Control Register. */
+	volatile uint32_t ggpio;               /*!< 038h General Purpose Input/Output Register. */
+	volatile uint32_t guid;                /*!< 03Ch User ID Register. */
+	volatile uint32_t gsnpsid;             /*!< 040h Synopsys ID Register (Read Only). */
+	volatile uint32_t ghwcfg1;             /*!< 044h User HW Config1 Register (Read Only). */
+	volatile uint32_t ghwcfg2;             /*!< 048h User HW Config2 Register (Read Only). */
+	volatile uint32_t ghwcfg3;             /*!< 04Ch User HW Config3 Register (Read Only). */
+	volatile uint32_t ghwcfg4;             /*!< 050h User HW Config4 Register (Read Only). */
+	volatile uint32_t reserved[43];        /*!< 054h Reserved  054h-0FFh */
+	volatile uint32_t hptxfsiz;            /*!< 100h Host Periodic Transmit FIFO Size Register. */
+	volatile uint32_t dptxfsiz_dieptxf[15];/*!< 104h + (FIFO_Number-1)*04h, 1 <= FIFO Number <= 15.
+	                                           Device Periodic Transmit FIFO#n Register if dedicated
+	                                           fifos are disabled, otherwise Device Transmit FIFO#n
+	                                           Register.
+	                                         */
+} ltqusb_core_global_regs_t;
+
+/*!
+ \brief Bits of the Core OTG Control and Status Register (GOTGCTL).
+ */
+typedef union gotgctl_data
+{
+	uint32_t d32;
+	struct{
+		unsigned reserved21_31 : 11;
+		unsigned currmod       : 1 ; /*!< 20 */
+		unsigned bsesvld       : 1 ; /*!< 19 */
+		unsigned asesvld       : 1 ; /*!< 18 */
+		unsigned reserved17    : 1 ;
+		unsigned conidsts      : 1 ; /*!< 16 */
+		unsigned reserved12_15 : 4 ;
+		unsigned devhnpen      : 1 ; /*!< 11 */
+		unsigned hstsethnpen   : 1 ; /*!< 10 */
+		unsigned hnpreq        : 1 ; /*!< 09 */
+		unsigned hstnegscs     : 1 ; /*!< 08 */
+		unsigned reserved2_7   : 6 ;
+		unsigned sesreq        : 1 ; /*!< 01 */
+		unsigned sesreqscs     : 1 ; /*!< 00 */
+	} b;
+} gotgctl_data_t;
+
+/*!
+ \brief Bit fields of the Core OTG Interrupt Register (GOTGINT).
+ */
+typedef union gotgint_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved31_20     : 12;
+		unsigned debdone           : 1 ; /*!< 19 Debounce Done */
+		unsigned adevtoutchng      : 1 ; /*!< 18 A-Device Timeout Change */
+		unsigned hstnegdet         : 1 ; /*!< 17 Host Negotiation Detected */
+		unsigned reserver10_16     : 7 ;
+		unsigned hstnegsucstschng  : 1 ; /*!< 09 Host Negotiation Success Status Change */
+		unsigned sesreqsucstschng  : 1 ; /*!< 08 Session Request Success Status Change */
+		unsigned reserved3_7       : 5 ;
+		unsigned sesenddet         : 1 ; /*!< 02 Session End Detected */
+		unsigned reserved0_1       : 2 ;
+	} b;
+} gotgint_data_t;
+
+/*!
+ \brief Bit fields of the Core AHB Configuration Register (GAHBCFG).
+ */
+typedef union gahbcfg_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved9_31      : 23;
+		unsigned ptxfemplvl        : 1 ; /*!< 08    Periodic FIFO empty level trigger condition*/
+		unsigned nptxfemplvl       : 1 ; /*!< 07    Non-Periodic FIFO empty level trigger condition*/
+			#define LTQUSB_GAHBCFG_TXFEMPTYLVL_EMPTY     1
+			#define LTQUSB_GAHBCFG_TXFEMPTYLVL_HALFEMPTY 0
+		unsigned reserved          : 1 ;
+		unsigned dmaenable         : 1 ; /*!< 05    DMA enable*/
+			#define LTQUSB_GAHBCFG_DMAENABLE             1
+		unsigned hburstlen         : 4 ; /*!< 01-04 DMA Burst-length*/
+			#define LTQUSB_GAHBCFG_INT_DMA_BURST_SINGLE  0
+			#define LTQUSB_GAHBCFG_INT_DMA_BURST_INCR    1
+			#define LTQUSB_GAHBCFG_INT_DMA_BURST_INCR4   3
+			#define LTQUSB_GAHBCFG_INT_DMA_BURST_INCR8   5
+			#define LTQUSB_GAHBCFG_INT_DMA_BURST_INCR16  7
+		unsigned glblintrmsk       : 1 ;  /*!< 00    USB Global Interrupt Enable */
+			#define LTQUSB_GAHBCFG_GLBINT_ENABLE         1
+	} b;
+} gahbcfg_data_t;
+
+/*!
+ \brief Bit fields of the Core USB Configuration Register (GUSBCFG).
+*/
+typedef union gusbcfg_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved31              : 1;
+		unsigned ForceDevMode            : 1; /*!< 30 Force Device Mode */
+		unsigned ForceHstMode            : 1; /*!< 29 Force Host Mode */
+		unsigned TxEndDelay              : 1; /*!< 28 Tx End Delay */
+		unsigned reserved2723            : 5;
+		unsigned term_sel_dl_pulse       : 1; /*!< 22 TermSel DLine Pulsing Selection */
+		unsigned reserved2117            : 5;
+		unsigned otgutmifssel            : 1; /*!< 16 UTMIFS Select */
+		unsigned phylpwrclksel           : 1; /*!< 15 PHY Low-Power Clock Select */
+		unsigned reserved14              : 1;
+		unsigned usbtrdtim               : 4; /*!< 13-10 USB Turnaround Time */
+		unsigned hnpcap                  : 1; /*!< 09 HNP-Capable */
+		unsigned srpcap                  : 1; /*!< 08 SRP-Capable */
+		unsigned reserved07              : 1;
+		unsigned physel                  : 1; /*!< 06 USB 2.0 High-Speed PHY or
+		                                             USB 1.1 Full-Speed Serial
+		                                             Transceiver Select */
+		unsigned fsintf                  : 1; /*!< 05 Full-Speed Serial Interface Select */
+		unsigned ulpi_utmi_sel           : 1; /*!< 04 ULPI or UTMI+ Select */
+		unsigned phyif                   : 1; /*!< 03 PHY Interface */
+		unsigned toutcal                 : 3; /*!< 00-02 HS/FS Timeout Calibration */
+	}b;
+} gusbcfg_data_t;
+
+/*!
+ \brief Bit fields of the Core Reset Register (GRSTCTL).
+ */
+typedef union grstctl_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned ahbidle         : 1; /*!< 31 AHB Master Idle.  Indicates the AHB Master State
+		                                     Machine is in IDLE condition. */
+		unsigned dmareq          : 1; /*!< 30 DMA Request Signal.  Indicated DMA request is in
+		                                     probress.  Used for debug purpose. */
+		unsigned reserved11_29   :19;
+		unsigned txfnum          : 5; /*!< 10-06 TxFIFO Number (TxFNum) to be flushed.
+		                                  0x00: Non Periodic TxFIFO Flush or TxFIFO 0
+		                                  0x01-0x0F: Periodic TxFIFO Flush or TxFIFO n
+		                                  0x10: Flush all TxFIFO
+		                               */
+		unsigned txfflsh         : 1; /*!< 05 TxFIFO Flush */
+		unsigned rxfflsh         : 1; /*!< 04 RxFIFO Flush */
+		unsigned intknqflsh      : 1; /*!< 03 In Token Sequence Learning Queue Flush (Device Only) */
+		unsigned hstfrm          : 1; /*!< 02 Host Frame Counter Reset (Host Only) */
+		unsigned hsftrst         : 1; /*!< 01 Hclk Soft Reset */
+
+		unsigned csftrst         : 1; /*!< 00 Core Soft Reset
+		                                     The application can flush the control logic in the
+		                                     entire core using this bit. This bit resets the
+		                                     pipelines in the AHB Clock domain as well as the
+		                                     PHY Clock domain.
+		                                     The state machines are reset to an IDLE state, the
+		                                     control bits in the CSRs are cleared, all the
+		                                     transmit FIFOs and the receive FIFO are flushed.
+		                                     The status mask bits that control the generation of
+		                                     the interrupt, are cleared, to clear the
+		                                     interrupt. The interrupt status bits are not
+		                                     cleared, so the application can get the status of
+		                                     any events that occurred in the core after it has
+		                                     set this bit.
+		                                     Any transactions on the AHB are terminated as soon
+		                                     as possible following the protocol. Any
+		                                     transactions on the USB are terminated immediately.
+		                                     The configuration settings in the CSRs are
+		                                     unchanged, so the software doesn't have to
+		                                     reprogram these registers (Device
+		                                     Configuration/Host Configuration/Core System
+		                                     Configuration/Core PHY Configuration).
+		                                     The application can write to this bit, any time it
+		                                     wants to reset the core. This is a self clearing
+		                                     bit and the core clears this bit after all the
+		                                     necessary logic is reset in the core, which may
+		                                     take several clocks, depending on the current state
+		                                     of the core.
+		                               */
+	}b;
+} grstctl_t;
+
+/*!
+ \brief Bit fields of the Core Interrupt Mask Register (GINTMSK) and
+        Core Interrupt Register (GINTSTS).
+ */
+typedef union gint_data
+{
+	uint32_t d32;
+		#define LTQUSB_SOF_INTR_MASK 0x0008
+	struct
+	{
+		unsigned wkupintr      : 1; /*!< 31 Resume/Remote Wakeup Detected Interrupt */
+		unsigned sessreqintr   : 1; /*!< 30 Session Request/New Session Detected Interrupt */
+		unsigned disconnect    : 1; /*!< 29 Disconnect Detected Interrupt */
+		unsigned conidstschng  : 1; /*!< 28 Connector ID Status Change */
+		unsigned reserved27    : 1;
+		unsigned ptxfempty     : 1; /*!< 26 Periodic TxFIFO Empty */
+		unsigned hcintr        : 1; /*!< 25 Host Channels Interrupt */
+		unsigned portintr      : 1; /*!< 24 Host Port Interrupt */
+		unsigned reserved23    : 1;
+		unsigned fetsuspmsk    : 1; /*!< 22 Data Fetch Suspended */
+		unsigned incomplisoout : 1; /*!< 21 Incomplete IsochronousOUT/Period Transfer */
+		unsigned incomplisoin  : 1; /*!< 20 Incomplete Isochronous IN Transfer */
+		unsigned outepintr     : 1; /*!< 19 OUT Endpoints Interrupt */
+		unsigned inepintr      : 1; /*!< 18 IN Endpoints Interrupt */
+		unsigned epmismatch    : 1; /*!< 17 Endpoint Mismatch Interrupt */
+		unsigned reserved16    : 1;
+		unsigned eopframe      : 1; /*!< 15 End of Periodic Frame Interrupt */
+		unsigned isooutdrop    : 1; /*!< 14 Isochronous OUT Packet Dropped Interrupt */
+		unsigned enumdone      : 1; /*!< 13 Enumeration Done */
+		unsigned usbreset      : 1; /*!< 12 USB Reset */
+		unsigned usbsuspend    : 1; /*!< 11 USB Suspend */
+		unsigned erlysuspend   : 1; /*!< 10 Early Suspend */
+		unsigned i2cintr       : 1; /*!< 09 I2C Interrupt */
+		unsigned reserved8     : 1;
+		unsigned goutnakeff    : 1; /*!< 07 Global OUT NAK Effective */
+		unsigned ginnakeff     : 1; /*!< 06 Global Non-periodic IN NAK Effective */
+		unsigned nptxfempty    : 1; /*!< 05 Non-periodic TxFIFO Empty */
+		unsigned rxstsqlvl     : 1; /*!< 04 Receive FIFO Non-Empty */
+		unsigned sofintr       : 1; /*!< 03 Start of (u)Frame */
+		unsigned otgintr       : 1; /*!< 02 OTG Interrupt */
+		unsigned modemismatch  : 1; /*!< 01 Mode Mismatch Interrupt */
+		unsigned reserved0     : 1;
+	} b;
+} gint_data_t;
+
+/*!
+  \brief Bit fields in the Receive Status Read and Pop Registers (GRXSTSR, GRXSTSP)
+ */
+typedef union grxsts_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved : 7;
+		unsigned fn       : 4; /*!< 24-21 Frame Number */
+		unsigned pktsts   : 4; /*!< 20-17 Packet Status */
+			#define LTQUSB_DSTS_DATA_UPDT  	0x2               // OUT Data Packet
+			#define LTQUSB_DSTS_XFER_COMP  	0x3               // OUT Data Transfer Complete
+			#define LTQUSB_DSTS_GOUT_NAK   	0x1               // Global OUT NAK
+			#define LTQUSB_DSTS_SETUP_COMP 	0x4               // Setup Phase Complete
+			#define LTQUSB_DSTS_SETUP_UPDT	0x6               // SETUP Packet
+		unsigned dpid     : 2; /*!< 16-15 Data PID */
+		unsigned bcnt     :11; /*!< 14-04 Byte Count */
+		unsigned epnum    : 4; /*!< 03-00 Endpoint Number */
+	} db;
+	struct
+	{
+		unsigned reserved :11;
+		unsigned pktsts   : 4; /*!< 20-17 Packet Status */
+			#define LTQUSB_HSTS_DATA_UPDT        0x2 // OUT Data Packet
+			#define LTQUSB_HSTS_XFER_COMP        0x3 // OUT Data Transfer Complete
+			#define LTQUSB_HSTS_DATA_TOGGLE_ERR  0x5 // DATA TOGGLE Error
+			#define LTQUSB_HSTS_CH_HALTED        0x7 // Channel Halted
+		unsigned dpid     : 2; /*!< 16-15 Data PID */
+		unsigned bcnt     :11; /*!< 14-04 Byte Count */
+		unsigned chnum    : 4; /*!< 03-00 Channel Number */
+	} hb;
+} grxsts_data_t;
+
+/*!
+  \brief Bit fields in the FIFO Size Registers (HPTXFSIZ, GNPTXFSIZ, DPTXFSIZn).
+ */
+typedef union fifosize_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned depth     : 16; /*!< 31-16 TxFIFO Depth (in DWord)*/
+		unsigned startaddr : 16; /*!< 15-00 RAM Starting address */
+	} b;
+} fifosize_data_t;
+
+/*!
+  \brief Bit fields in the Non-Periodic Transmit FIFO/Queue Status Register (GNPTXSTS).
+ */
+
+typedef union gnptxsts_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved           : 1;
+		unsigned nptxqtop_chnep     : 4; /*!< 30-27 Channel/EP Number of top of the Non-Periodic
+		                                     Transmit Request Queue
+		                                  */
+		unsigned nptxqtop_token     : 2; /*!< 26-25 Token Type top of the Non-Periodic
+		                                     Transmit Request Queue
+	                                          0 - IN/OUT
+	                                          1 - Zero Length OUT
+	                                          2 - PING/Complete Split
+	                                          3 - Channel Halt
+		                                  */
+		unsigned nptxqtop_terminate : 1; /*!< 24    Terminate (Last entry for the selected
+		                                           channel/EP)*/
+		unsigned nptxqspcavail      : 8; /*!< 23-16 Transmit Request Queue Space Available */
+		unsigned nptxfspcavail      :16; /*!< 15-00 TxFIFO Space Avail (in DWord)*/
+	}b;
+} gnptxsts_data_t;
+
+
+/*!
+  \brief Bit fields in the Transmit FIFO Status Register (DTXFSTS).
+ */
+typedef union dtxfsts_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved    : 16;
+		unsigned txfspcavail : 16; /*!< 15-00 TxFIFO Space Avail (in DWord)*/
+	}b;
+} dtxfsts_data_t;
+
+
+/*!
+  \brief Bit fields in the I2C Control Register (I2CCTL).
+ */
+typedef union gi2cctl_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned bsydne     : 1; /*!< 31    I2C Busy/Done*/
+		unsigned rw         : 1; /*!< 30    Read/Write Indicator */
+		unsigned reserved   : 2;
+		unsigned i2cdevaddr : 2; /*!< 27-26 I2C Device Address */
+		unsigned i2csuspctl : 1; /*!< 25    I2C Suspend Control */
+		unsigned ack        : 1; /*!< 24    I2C ACK */
+		unsigned i2cen      : 1; /*!< 23    I2C Enable */
+		unsigned addr       : 7; /*!< 22-16 I2C Address */
+		unsigned regaddr    : 8; /*!< 15-08 I2C Register Addr */
+		unsigned rwdata     : 8; /*!< I2C Read/Write Data */
+	} b;
+} gi2cctl_data_t;
+
+
+/*!
+  \brief Bit fields in the User HW Config1 Register.
+ */
+typedef union hwcfg1_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned ep_dir15 : 2; /*!< Direction of each EP
+		                           0: BIDIR (IN and OUT) endpoint
+	                               1: IN endpoint
+	                               2: OUT endpoint
+	                               3: Reserved
+	                            */
+		unsigned ep_dir14 : 2;
+		unsigned ep_dir13 : 2;
+		unsigned ep_dir12 : 2;
+		unsigned ep_dir11 : 2;
+		unsigned ep_dir10 : 2;
+		unsigned ep_dir09 : 2;
+		unsigned ep_dir08 : 2;
+		unsigned ep_dir07 : 2;
+		unsigned ep_dir06 : 2;
+		unsigned ep_dir05 : 2;
+		unsigned ep_dir04 : 2;
+		unsigned ep_dir03 : 2;
+		unsigned ep_dir02 : 2;
+		unsigned ep_dir01 : 2;
+		unsigned ep_dir00 : 2;
+	}b;
+} hwcfg1_data_t;
+
+/*!
+  \brief Bit fields in the User HW Config2 Register.
+ */
+typedef union hwcfg2_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved31             : 1;
+		unsigned dev_token_q_depth      : 5; /*!< 30-26 Device Mode IN Token Sequence Learning Queue Depth */
+		unsigned host_perio_tx_q_depth  : 2; /*!< 25-24 Host Mode Periodic Request Queue Depth */
+		unsigned nonperio_tx_q_depth    : 2; /*!< 23-22 Non-periodic Request Queue Depth */
+		unsigned rx_status_q_depth      : 2; /*!< 21-20 Multi Processor Interrupt Enabled */
+		unsigned dynamic_fifo           : 1; /*!< 19    Dynamic FIFO Sizing Enabled */
+		unsigned perio_ep_supported     : 1; /*!< 18    Periodic OUT Channels Supported in Host Mode */
+		unsigned num_host_chan          : 4; /*!< 17-14 Number of Host Channels */
+		unsigned num_dev_ep             : 4; /*!< 13-10 Number of Device Endpoints */
+		unsigned fs_phy_type            : 2; /*!< 09-08 Full-Speed PHY Interface Type */
+			#define LTQUSB_HWCFG2_FS_PHY_TYPE_NOT_SUPPORTED 0
+			#define LTQUSB_HWCFG2_FS_PHY_TYPE_DEDICATE      1
+			#define LTQUSB_HWCFG2_FS_PHY_TYPE_UTMI          2
+			#define LTQUSB_HWCFG2_FS_PHY_TYPE_ULPI          3
+		unsigned hs_phy_type            : 2; /*!< 07-06 High-Speed PHY Interface Type */
+			#define LTQUSB_HWCFG2_HS_PHY_TYPE_NOT_SUPPORTED 0
+			#define LTQUSB_HWCFG2_HS_PHY_TYPE_UTMI          1
+			#define LTQUSB_HWCFG2_HS_PHY_TYPE_ULPI          2
+			#define LTQUSB_HWCFG2_HS_PHY_TYPE_UTMI_ULPI     3
+		unsigned point2point            : 1; /*!< 05    Point-to-Point */
+		unsigned architecture           : 2; /*!< 04-03 Architecture */
+			#define LTQUSB_HWCFG2_ARCH_SLAVE_ONLY  0
+			#define LTQUSB_HWCFG2_ARCH_EXT_DMA     1
+			#define LTQUSB_HWCFG2_ARCH_INT_DMA     2
+		unsigned op_mode                : 3; /*!< 02-00 Mode of Operation */
+			#define LTQUSB_HWCFG2_OP_MODE_HNP_SRP_CAPABLE_OTG    0
+			#define LTQUSB_HWCFG2_OP_MODE_SRP_ONLY_CAPABLE_OTG   1
+			#define LTQUSB_HWCFG2_OP_MODE_NO_HNP_SRP_CAPABLE_OTG 2
+			#define LTQUSB_HWCFG2_OP_MODE_SRP_CAPABLE_DEVICE     3
+			#define LTQUSB_HWCFG2_OP_MODE_NO_SRP_CAPABLE_DEVICE  4
+			#define LTQUSB_HWCFG2_OP_MODE_SRP_CAPABLE_HOST       5
+			#define LTQUSB_HWCFG2_OP_MODE_NO_SRP_CAPABLE_HOST    6
+	} b;
+} hwcfg2_data_t;
+
+/*!
+  \brief Bit fields in the User HW Config3 Register.
+ */
+typedef union hwcfg3_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned dfifo_depth            :16; /*!< 31-16 DFIFO Depth  */
+		unsigned reserved15_12          : 4;
+		unsigned synch_reset_type       : 1; /*!< 11    Reset Style for Clocked always Blocks in RTL */
+		unsigned optional_features      : 1; /*!< 10    Optional Features Removed */
+		unsigned vendor_ctrl_if         : 1; /*!< 09    Vendor Control Interface Support */
+		unsigned i2c                    : 1; /*!< 08    I2C Selection */
+		unsigned otg_func               : 1; /*!< 07    OTG Function Enabled */
+		unsigned packet_size_cntr_width : 3; /*!< 06-04 Width of Packet Size Counters */
+		unsigned xfer_size_cntr_width   : 4; /*!< 03-00 Width of Transfer Size Counters */
+	} b;
+} hwcfg3_data_t;
+
+/*!
+  \brief Bit fields in the User HW Config4
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg4_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned desc_dma_dyn         : 1; /*!< 31    Scatter/Gather DMA */
+		unsigned desc_dma             : 1; /*!< 30    Scatter/Gather DMA configuration */
+		unsigned num_in_eps           : 4; /*!< 29-26 Number of Device Mode IN Endpoints Including Control Endpoints */
+		unsigned ded_fifo_en          : 1; /*!< 25    Enable Dedicated Transmit FIFO for device IN Endpoints */
+		unsigned session_end_filt_en  : 1; /*!< 24    session_end Filter Enabled */
+		unsigned b_valid_filt_en      : 1; /*!< 23    b_valid Filter Enabled */
+		unsigned a_valid_filt_en      : 1; /*!< 22    a_valid Filter Enabled */
+		unsigned vbus_valid_filt_en   : 1; /*!< 21    vbus_valid Filter Enabled */
+		unsigned iddig_filt_en        : 1; /*!< 20    iddig Filter Enable */
+		unsigned num_dev_mode_ctrl_ep : 4; /*!< 19-16 Number of Device Mode Control Endpoints in Addition to Endpoint 0 */
+		unsigned utmi_phy_data_width  : 2; /*!< 15-14 UTMI+ PHY/ULPI-to-Internal UTMI+ Wrapper Data Width */
+		unsigned reserved13_06        : 8;
+		unsigned min_ahb_freq         : 1; /*!< 05    Minimum AHB Frequency Less Than 60 MHz */
+		unsigned power_optimiz        : 1; /*!< 04    Enable Power Optimization? */
+		unsigned num_dev_perio_in_ep  : 4; /*!< 03-00 Number of Device Mode Periodic IN Endpoints */
+	} b;
+} hwcfg4_data_t;
+
+/*@}*//*LTQUSB_CSR_CORE_GLOBAL_REG*/
+
+/****************************************************************************/
+/*!
+  \addtogroup LTQUSB_CSR_DEVICE_GLOBAL_REG
+ */
+/*@{*/
+
+/*! typedef ltqusb_dev_global_regs_t
+ \brief LTQUSB Device Mode Global registers. Offsets 800h-BFFh
+        The ltqusb_dev_global_regs structure defines the size
+        and relative field offsets for the Device Global registers.
+        These registers are visible only in Device mode and must not be
+        accessed in Host mode, as the results are unknown.
+ */
+typedef struct ltqusb_dev_global_regs
+{
+	volatile uint32_t dcfg;                 /*!< 800h Device Configuration Register. */
+	volatile uint32_t dctl;                 /*!< 804h Device Control Register. */
+	volatile uint32_t dsts;                 /*!< 808h Device Status Register (Read Only). */
+	uint32_t unused;
+	volatile uint32_t diepmsk;              /*!< 810h Device IN Endpoint Common Interrupt Mask Register. */
+	volatile uint32_t doepmsk;              /*!< 814h Device OUT Endpoint Common Interrupt Mask Register. */
+	volatile uint32_t daint;                /*!< 818h Device All Endpoints Interrupt Register. */
+	volatile uint32_t daintmsk;             /*!< 81Ch Device All Endpoints Interrupt Mask Register. */
+	volatile uint32_t dtknqr1;              /*!< 820h Device IN Token Queue Read Register-1 (Read Only). */
+	volatile uint32_t dtknqr2;              /*!< 824h Device IN Token Queue Read Register-2 (Read Only). */
+	volatile uint32_t dvbusdis;             /*!< 828h Device VBUS discharge Register.*/
+	volatile uint32_t dvbuspulse;           /*!< 82Ch Device VBUS Pulse Register. */
+	volatile uint32_t dtknqr3_dthrctl;      /*!< 830h Device IN Token Queue Read Register-3 (Read Only).
+	                                                 Device Thresholding control register (Read/Write)
+	                                         */
+	volatile uint32_t dtknqr4_fifoemptymsk; /*!< 834h Device IN Token Queue Read Register-4 (Read Only).
+	 	                                             Device IN EPs empty Inr. Mask Register (Read/Write)
+	                                         */
+} ltqusb_device_global_regs_t;
+
+/*!
+  \brief Bit fields in the Device Configuration Register.
+ */
+
+typedef union dcfg_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved31_26   : 6;
+		unsigned perschintvl     : 2; /*!< 25-24 Periodic Scheduling Interval */
+		unsigned descdma         : 1; /*!< 23    Enable Descriptor DMA in Device mode */
+		unsigned epmscnt         : 5; /*!< 22-18 In Endpoint Mis-match count */
+		unsigned reserved13_17   : 5;
+		unsigned perfrint        : 2; /*!< 12-11 Periodic Frame Interval */
+			#define LTQUSB_DCFG_FRAME_INTERVAL_80 0
+			#define LTQUSB_DCFG_FRAME_INTERVAL_85 1
+			#define LTQUSB_DCFG_FRAME_INTERVAL_90 2
+			#define LTQUSB_DCFG_FRAME_INTERVAL_95 3
+		unsigned devaddr         : 7; /*!< 10-04 Device Addresses */
+		unsigned reserved3       : 1;
+		unsigned nzstsouthshk    : 1; /*!< 02    Non Zero Length Status OUT Handshake */
+			#define LTQUSB_DCFG_SEND_STALL 1
+		unsigned devspd          : 2; /*!< 01-00 Device Speed */
+	} b;
+} dcfg_data_t;
+
+/*!
+  \brief Bit fields in the Device Control Register.
+ */
+typedef union dctl_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved16_31  :16;
+		unsigned ifrmnum        : 1; /*!< 15    Ignore Frame Number for ISOC EPs */
+		unsigned gmc            : 2; /*!< 14-13 Global Multi Count */
+		unsigned gcontbna       : 1; /*!< 12    Global Continue on BNA */
+		unsigned pwronprgdone   : 1; /*!< 11    Power-On Programming Done */
+		unsigned cgoutnak       : 1; /*!< 10    Clear Global OUT NAK */
+		unsigned sgoutnak       : 1; /*!< 09    Set Global OUT NAK */
+		unsigned cgnpinnak      : 1; /*!< 08    Clear Global Non-Periodic IN NAK */
+		unsigned sgnpinnak      : 1; /*!< 07    Set Global Non-Periodic IN NAK */
+		unsigned tstctl         : 3; /*!< 06-04 Test Control */
+		unsigned goutnaksts     : 1; /*!< 03    Global OUT NAK Status */
+		unsigned gnpinnaksts    : 1; /*!< 02    Global Non-Periodic IN NAK Status */
+		unsigned sftdiscon      : 1; /*!< 01    Soft Disconnect */
+		unsigned rmtwkupsig     : 1; /*!< 00    Remote Wakeup */
+	} b;
+} dctl_data_t;
+
+
+/*!
+  \brief Bit fields in the Device Status Register.
+ */
+typedef union dsts_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved22_31  :10;
+		unsigned soffn          :14; /*!< 21-08 Frame or Microframe Number of the received SOF */
+		unsigned reserved4_7    : 4;
+		unsigned errticerr      : 1; /*!< 03    Erratic Error */
+		unsigned enumspd        : 2; /*!< 02-01 Enumerated Speed */
+			#define LTQUSB_DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ 0
+			#define LTQUSB_DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ 1
+			#define LTQUSB_DSTS_ENUMSPD_LS_PHY_6MHZ           2
+			#define LTQUSB_DSTS_ENUMSPD_FS_PHY_48MHZ          3
+		unsigned suspsts        : 1; /*!< 00    Suspend Status */
+	} b;
+} dsts_data_t;
+
+/*!
+  \brief Bit fields in the Device IN EP Interrupt Register
+         and the Device IN EP Common Mask Register.
+ */
+typedef union diepint_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved14_31   :18;
+		unsigned nakmsk          : 1; /*!< 13 NAK interrupt Mask */
+		unsigned reserved10_12   : 3;
+		unsigned bna             : 1; /*!< 09 BNA Interrupt mask */
+		unsigned txfifoundrn     : 1; /*!< 08 Fifo Underrun Mask */
+		unsigned emptyintr       : 1; /*!< 07 IN Endpoint HAK Effective mask */
+		unsigned inepnakeff      : 1; /*!< 06 IN Endpoint HAK Effective mask */
+		unsigned intknepmis      : 1; /*!< 05 IN Token Received with EP mismatch mask */
+		unsigned intktxfemp      : 1; /*!< 04 IN Token received with TxF Empty mask */
+		unsigned timeout         : 1; /*!< 03 TimeOUT Handshake mask (non-ISOC EPs) */
+		unsigned ahberr          : 1; /*!< 02 AHB Error mask */
+		unsigned epdisabled      : 1; /*!< 01 Endpoint disable mask */
+		unsigned xfercompl       : 1; /*!< 00 Transfer complete mask */
+	} b;
+} diepint_data_t;
+
+
+/*!
+  \brief Bit fields in the Device OUT EP Interrupt Register and
+         Device OUT EP Common Interrupt Mask Register.
+  */
+typedef union doepint_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved15_31  :17;
+		unsigned nyetmsk        : 1; /*!< 14 NYET Interrupt */
+		unsigned nakmsk         : 1; /*!< 13 NAK Interrupt */
+		unsigned bbleerrmsk     : 1; /*!< 12 Babble Interrupt */
+		unsigned reserved10_11  : 2;
+		unsigned bna            : 1; /*!< 09 BNA Interrupt */
+		unsigned outpkterr      : 1; /*!< 08 OUT packet Error */
+		unsigned reserved07     : 1;
+		unsigned back2backsetup : 1; /*!< 06 Back-to-Back SETUP Packets Received */
+		unsigned stsphsercvd    : 1; /*!< 05 */
+		unsigned outtknepdis    : 1; /*!< 04 OUT Token Received when Endpoint Disabled */
+		unsigned setup          : 1; /*!< 03 Setup Phase Done (contorl EPs) */
+		unsigned ahberr         : 1; /*!< 02 AHB Error */
+		unsigned epdisabled     : 1; /*!< 01 Endpoint disable */
+		unsigned xfercompl      : 1; /*!< 00 Transfer complete */
+	} b;
+} doepint_data_t;
+
+
+/*!
+  \brief Bit fields in the Device All EP Interrupt Registers.
+ */
+typedef union daint_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned out : 16; /*!< 31-16 OUT Endpoint bits */
+		unsigned in  : 16; /*!< 15-00 IN Endpoint bits */
+	} eps;
+	struct
+	{
+		/** OUT Endpoint bits */
+		unsigned outep15 : 1;
+		unsigned outep14 : 1;
+		unsigned outep13 : 1;
+		unsigned outep12 : 1;
+		unsigned outep11 : 1;
+		unsigned outep10 : 1;
+		unsigned outep09 : 1;
+		unsigned outep08 : 1;
+		unsigned outep07 : 1;
+		unsigned outep06 : 1;
+		unsigned outep05 : 1;
+		unsigned outep04 : 1;
+		unsigned outep03 : 1;
+		unsigned outep02 : 1;
+		unsigned outep01 : 1;
+		unsigned outep00 : 1;
+		/** IN Endpoint bits */
+		unsigned inep15 : 1;
+		unsigned inep14 : 1;
+		unsigned inep13 : 1;
+		unsigned inep12 : 1;
+		unsigned inep11 : 1;
+		unsigned inep10 : 1;
+		unsigned inep09 : 1;
+		unsigned inep08 : 1;
+		unsigned inep07 : 1;
+		unsigned inep06 : 1;
+		unsigned inep05 : 1;
+		unsigned inep04 : 1;
+		unsigned inep03 : 1;
+		unsigned inep02 : 1;
+		unsigned inep01 : 1;
+		unsigned inep00 : 1;
+	} ep;
+} daint_data_t;
+
+
+/*!
+  \brief Bit fields in the Device IN Token Queue Read Registers.
+ */
+typedef union dtknq1_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned epnums0_5     :24; /*!< 31-08 EP Numbers of IN Tokens 0 ... 4 */
+		unsigned wrap_bit      : 1; /*!< 07    write pointer has wrapped */
+		unsigned reserved05_06 : 2;
+		unsigned intknwptr     : 5; /*!< 04-00 In Token Queue Write Pointer */
+	}b;
+} dtknq1_data_t;
+
+
+/*!
+  \brief Bit fields in Threshold control Register
+ */
+typedef union dthrctl_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved26_31  : 6;
+		unsigned rx_thr_len     : 9; /*!< 25-17 Rx Thr. Length */
+		unsigned rx_thr_en      : 1; /*!< 16    Rx Thr. Enable */
+		unsigned reserved11_15  : 5;
+		unsigned tx_thr_len     : 9; /*!< 10-02 Tx Thr. Length */
+		unsigned iso_thr_en     : 1; /*!< 01    ISO Tx Thr. Enable */
+		unsigned non_iso_thr_en : 1; /*!< 00    non ISO Tx Thr. Enable */
+	} b;
+} dthrctl_data_t;
+
+/*@}*//*LTQUSB_CSR_DEVICE_GLOBAL_REG*/
+
+/****************************************************************************/
+
+/*!
+  \addtogroup LTQUSB_CSR_DEVICE_EP_REG
+ */
+/*@{*/
+
+/*! typedef ltqusb_dev_in_ep_regs_t
+  \brief Device Logical IN Endpoint-Specific Registers.
+   There will be one set of endpoint registers per logical endpoint
+   implemented.
+   each EP's IN EP Register are offset at :
+	       900h + * (ep_num * 20h)
+ */
+
+typedef struct ltqusb_dev_in_ep_regs
+{
+	volatile uint32_t diepctl;    /*!< 00h: Endpoint Control Register */
+	uint32_t reserved04;          /*!< 04h: */
+	volatile uint32_t diepint;    /*!< 08h: Endpoint Interrupt Register */
+	uint32_t reserved0C;          /*!< 0Ch: */
+	volatile uint32_t dieptsiz;   /*!< 10h: Endpoint Transfer Size Register.*/
+	volatile uint32_t diepdma;    /*!< 14h: Endpoint DMA Address Register. */
+	volatile uint32_t dtxfsts;    /*!< 18h: Endpoint Transmit FIFO Status Register. */
+	volatile uint32_t diepdmab;   /*!< 1Ch: Endpoint DMA Buffer Register. */
+} ltqusb_dev_in_ep_regs_t;
+
+/*! typedef ltqusb_dev_out_ep_regs_t
+  \brief Device Logical OUT Endpoint-Specific Registers.
+   There will be one set of endpoint registers per logical endpoint
+   implemented.
+   each EP's OUT EP Register are offset at :
+	       B00h + * (ep_num * 20h) + 00h
+ */
+typedef struct ltqusb_dev_out_ep_regs
+{
+	volatile uint32_t doepctl;    /*!< 00h: Endpoint Control Register */
+	volatile uint32_t doepfn;     /*!< 04h: Endpoint Frame number Register */
+	volatile uint32_t doepint;    /*!< 08h: Endpoint Interrupt Register */
+	uint32_t reserved0C;          /*!< 0Ch: */
+	volatile uint32_t doeptsiz;   /*!< 10h: Endpoint Transfer Size Register.*/
+	volatile uint32_t doepdma;    /*!< 14h: Endpoint DMA Address Register. */
+	uint32_t reserved18;          /*!< 18h: */
+	volatile uint32_t doepdmab;   /*!< 1Ch: Endpoint DMA Buffer Register. */
+} ltqusb_dev_out_ep_regs_t;
+
+
+/*!
+  \brief Bit fields in the Device EP Control
+  Register.
+ */
+typedef union depctl_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned epena     : 1; /*!< 31    Endpoint Enable */
+		unsigned epdis     : 1; /*!< 30    Endpoint Disable */
+		unsigned setd1pid  : 1; /*!< 29    Set DATA1 PID (INTR/Bulk IN and OUT endpoints) */
+		unsigned setd0pid  : 1; /*!< 28    Set DATA0 PID (INTR/Bulk IN and OUT endpoints) */
+		unsigned snak      : 1; /*!< 27    Set NAK */
+		unsigned cnak      : 1; /*!< 26    Clear NAK */
+		unsigned txfnum    : 4; /*!< 25-22 Tx Fifo Number */
+		unsigned stall     : 1; /*!< 21    Stall Handshake */
+		unsigned snp       : 1; /*!< 20    Snoop Mode */
+		unsigned eptype    : 2; /*!< 19-18 Endpoint Type
+		                                  0: Control
+		                                  1: Isochronous
+		                                  2: Bulk
+		                                  3: Interrupt
+		                         */
+		unsigned naksts    : 1; /*!< 17    NAK Status */
+		unsigned dpid      : 1; /*!< 16    Endpoint DPID (INTR/Bulk IN and OUT endpoints) */
+		unsigned usbactep  : 1; /*!< 15    USB Active Endpoint */
+		unsigned nextep    : 4; /*!< 14-11 Next Endpoint */
+		unsigned mps       :11; /*!< 10-00 Maximum Packet Size */
+			#define LTQUSB_DEP0CTL_MPS_64   0
+			#define LTQUSB_DEP0CTL_MPS_32   1
+			#define LTQUSB_DEP0CTL_MPS_16   2
+			#define LTQUSB_DEP0CTL_MPS_8    3
+	} b;
+} depctl_data_t;
+
+
+/*!
+  \brief Bit fields in the Device EP Transfer Size Register. (EP0 and EPn)
+ */
+typedef union deptsiz_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved31    : 1;
+		unsigned supcnt        : 2; /*!< 30-29 Setup Packet Count */
+		#ifdef  __DED_FIFO__
+			unsigned reserved21_28 : 8;
+			unsigned pktcnt        : 2; /*!< 19-20 Packet Count */
+		#else
+			unsigned reserved20_28 : 9;
+			unsigned pktcnt        : 1; /*!< 19    Packet Count */
+		#endif
+		unsigned reserved7_18  :12;
+		unsigned xfersize      : 7; /*!< 06-00 Transfer size */
+	}b0;
+	struct
+	{
+		unsigned reserved      : 1;
+		unsigned mc            : 2; /*!< 30-29 Multi Count */
+		unsigned pktcnt        :10; /*!< 28-19 Packet Count */
+		unsigned xfersize      :19; /*!< 18-00 Transfer size */
+	} b;
+} deptsiz_data_t;
+
+/*@}*//*LTQUSB_CSR_DEVICE_EP_REG*/
+/****************************************************************************/
+
+/*!
+  \addtogroup LTQUSB_CSR_DEVICE_DMA_DESC
+ */
+/*@{*/
+/*!
+  \brief Bit fields in the DMA Descriptor status quadlet.
+ */
+typedef union desc_sts_data
+{
+	struct
+	{
+		unsigned bs            : 2; /*!< 31-30 Buffer Status */
+			#define BS_HOST_READY	0x0
+			#define BS_DMA_BUSY		0x1
+			#define BS_DMA_DONE		0x2
+			#define BS_HOST_BUSY	0x3
+		unsigned sts           : 2; /*!< 29-28 Receive/Trasmit Status */
+			#define RTS_SUCCESS		0x0
+			#define RTS_BUFFLUSH	0x1
+			#define RTS_RESERVED	0x2
+			#define RTS_BUFERR		0x3
+		unsigned l             : 1; /*!< 27    Last */
+		unsigned sp            : 1; /*!< 26    Short Packet */
+		unsigned ioc           : 1; /*!< 25    Interrupt On Complete */
+		unsigned sr            : 1; /*!< 24    Setup Packet received */
+		unsigned mtrf          : 1; /*!< 23    Multiple Transfer */
+		unsigned reserved16_22 : 7;
+		unsigned bytes         :16; /*!< 15-00 Transfer size in bytes */
+	} b;
+	uint32_t d32;    /*!< DMA Descriptor data buffer pointer */
+} desc_sts_data_t;
+
+/*@}*//*LTQUSB_CSR_DEVICE_DMA_DESC*/
+/****************************************************************************/
+
+/*!
+  \addtogroup LTQUSB_CSR_HOST_GLOBAL_REG
+ */
+/*@{*/
+/*! typedef ltqusb_host_global_regs_t
+ \brief LTQUSB Host Mode Global registers. Offsets 400h-7FFh
+        The ltqusb_host_global_regs structure defines the size
+        and relative field offsets for the Host Global registers.
+        These registers are visible only in Host mode and must not be
+        accessed in Device mode, as the results are unknown.
+ */
+typedef struct ltqusb_host_global_regs
+{
+	volatile uint32_t hcfg;      /*!< 400h Host Configuration Register. */
+	volatile uint32_t hfir;      /*!< 404h Host Frame Interval Register. */
+	volatile uint32_t hfnum;     /*!< 408h Host Frame Number / Frame Remaining Register. */
+	uint32_t reserved40C;
+	volatile uint32_t hptxsts;   /*!< 410h Host Periodic Transmit FIFO/ Queue Status Register. */
+	volatile uint32_t haint;     /*!< 414h Host All Channels Interrupt Register. */
+	volatile uint32_t haintmsk;  /*!< 418h Host All Channels Interrupt Mask Register. */
+} ltqusb_host_global_regs_t;
+
+/*!
+  \brief Bit fields in the Host Configuration Register.
+ */
+typedef union hcfg_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved31_03 :29;
+		unsigned fslssupp      : 1; /*!< 02    FS/LS Only Support */
+		unsigned fslspclksel   : 2; /*!< 01-00 FS/LS Phy Clock Select */
+			#define LTQUSB_HCFG_30_60_MHZ 0
+			#define LTQUSB_HCFG_48_MHZ    1
+			#define LTQUSB_HCFG_6_MHZ     2
+	} b;
+} hcfg_data_t;
+
+/*!
+  \brief Bit fields in the Host Frame Interval Register.
+ */
+typedef union hfir_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved : 16;
+		unsigned frint    : 16; /*!< 15-00 Frame Interval */
+	} b;
+} hfir_data_t;
+
+/*!
+ \brief Bit fields in the Host Frame Time Remaing/Number Register.
+ */
+typedef union hfnum_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned frrem : 16; /*!< 31-16 Frame Time Remaining */
+		unsigned frnum : 16; /*!< 15-00 Frame Number*/
+			#define LTQUSB_HFNUM_MAX_FRNUM 0x3FFF
+	} b;
+} hfnum_data_t;
+
+/*!
+  \brief Bit fields in the Host Periodic Transmit FIFO/Queue Status Register
+ */
+typedef union hptxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	struct
+	{
+		/** Top of the Periodic Transmit Request Queue
+		 *  - bit 24 - Terminate (last entry for the selected channel)
+		 */
+		unsigned ptxqtop_odd       : 1; /*!< 31    Top of the Periodic Transmit Request
+		                                          Queue Odd/even microframe*/
+		unsigned ptxqtop_chnum     : 4; /*!< 30-27 Top of the Periodic Transmit Request
+		                                          Channel Number */
+		unsigned ptxqtop_token     : 2; /*!< 26-25 Top of the Periodic Transmit Request
+		                                          Token Type
+		                                          0 - Zero length
+		                                          1 - Ping
+		                                          2 - Disable
+		                                 */
+		unsigned ptxqtop_terminate : 1; /*!< 24    Top of the Periodic Transmit Request
+		                                          Terminate (last entry for the selected channel)*/
+		unsigned ptxqspcavail      : 8; /*!< 23-16 Periodic Transmit Request Queue Space Available */
+		unsigned ptxfspcavail      :16; /*!< 15-00 Periodic Transmit Data FIFO Space Available */
+	} b;
+} hptxsts_data_t;
+
+/*!
+  \brief Bit fields in the Host Port Control and Status Register.
+ */
+typedef union hprt0_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved19_31   :13;
+		unsigned prtspd          : 2; /*!< 18-17 Port Speed */
+			#define LTQUSB_HPRT0_PRTSPD_HIGH_SPEED 0
+			#define LTQUSB_HPRT0_PRTSPD_FULL_SPEED 1
+			#define LTQUSB_HPRT0_PRTSPD_LOW_SPEED  2
+		unsigned prttstctl       : 4; /*!< 16-13 Port Test Control */
+		unsigned prtpwr          : 1; /*!< 12    Port Power */
+		unsigned prtlnsts        : 2; /*!< 11-10 Port Line Status */
+		unsigned reserved9       : 1;
+		unsigned prtrst          : 1; /*!< 08    Port Reset */
+		unsigned prtsusp         : 1; /*!< 07    Port Suspend */
+		unsigned prtres          : 1; /*!< 06    Port Resume */
+		unsigned prtovrcurrchng  : 1; /*!< 05    Port Overcurrent Change */
+		unsigned prtovrcurract   : 1; /*!< 04    Port Overcurrent Active */
+		unsigned prtenchng       : 1; /*!< 03    Port Enable/Disable Change */
+		unsigned prtena          : 1; /*!< 02    Port Enable */
+		unsigned prtconndet      : 1; /*!< 01    Port Connect Detected */
+		unsigned prtconnsts      : 1; /*!< 00    Port Connect Status */
+	}b;
+} hprt0_data_t;
+
+/*!
+  \brief Bit fields in the Host All Interrupt Register.
+ */
+typedef union haint_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved : 16;
+		unsigned ch15 : 1;
+		unsigned ch14 : 1;
+		unsigned ch13 : 1;
+		unsigned ch12 : 1;
+		unsigned ch11 : 1;
+		unsigned ch10 : 1;
+		unsigned ch09 : 1;
+		unsigned ch08 : 1;
+		unsigned ch07 : 1;
+		unsigned ch06 : 1;
+		unsigned ch05 : 1;
+		unsigned ch04 : 1;
+		unsigned ch03 : 1;
+		unsigned ch02 : 1;
+		unsigned ch01 : 1;
+		unsigned ch00 : 1;
+	} b;
+	struct
+	{
+		unsigned reserved : 16;
+		unsigned chint    : 16;
+	} b2;
+} haint_data_t;
+/*@}*//*LTQUSB_CSR_HOST_GLOBAL_REG*/
+/****************************************************************************/
+/*!
+  \addtogroup LTQUSB_CSR_HOST_HC_REG
+ */
+/*@{*/
+/*! typedef ltqusb_hc_regs_t
+  \brief Host Channel Specific Registers
+   There will be one set of hc registers per host channelimplemented.
+   each HC's Register are offset at :
+	       500h + * (hc_num * 20h)
+ */
+typedef struct ltqusb_hc_regs
+{
+	volatile uint32_t hcchar;   /*!< 00h Host Channel Characteristic Register.*/
+	volatile uint32_t hcsplt;   /*!< 04h Host Channel Split Control Register.*/
+	volatile uint32_t hcint;    /*!< 08h Host Channel Interrupt Register. */
+	volatile uint32_t hcintmsk; /*!< 0Ch Host Channel Interrupt Mask Register. */
+	volatile uint32_t hctsiz;   /*!< 10h Host Channel Transfer Size Register. */
+	volatile uint32_t hcdma;    /*!< 14h Host Channel DMA Address Register. */
+	uint32_t reserved[2];       /*!< 18h Reserved.   */
+} ltqusb_hc_regs_t;
+
+
+/*!
+  \brief Bit fields in the Host Channel Characteristics Register.
+ */
+typedef union hcchar_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned chen      : 1; /*!< 31    Channel enable */
+		unsigned chdis     : 1; /*!< 30    Channel disable */
+		unsigned oddfrm    : 1; /*!< 29    Frame to transmit periodic transaction */
+		unsigned devaddr   : 7; /*!< 28-22 Device address */
+		unsigned multicnt  : 2; /*!< 21-20 Packets per frame for periodic transfers */
+		unsigned eptype    : 2; /*!< 19-18 0: Control, 1: Isoc, 2: Bulk, 3: Intr */
+		unsigned lspddev   : 1; /*!< 17    0: Full/high speed device, 1: Low speed device */
+		unsigned reserved  : 1;
+		unsigned epdir     : 1; /*!< 15    0: OUT, 1: IN */
+		unsigned epnum     : 4; /*!< 14-11 Endpoint number */
+		unsigned mps       :11; /*!< 10-00 Maximum packet size in bytes */
+	} b;
+} hcchar_data_t;
+
+/*!
+  \brief Bit fields in the Host Channel Split Control Register
+ */
+typedef union hcsplt_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned spltena  : 1; /*!< 31    Split Enble */
+		unsigned reserved :14;
+		unsigned compsplt : 1; /*!< 16    Do Complete Split */
+		unsigned xactpos  : 2; /*!< 15-14 Transaction Position */
+			#define LTQUSB_HCSPLIT_XACTPOS_MID 0
+			#define LTQUSB_HCSPLIT_XACTPOS_END 1
+			#define LTQUSB_HCSPLIT_XACTPOS_BEGIN 2
+			#define LTQUSB_HCSPLIT_XACTPOS_ALL 3
+		unsigned hubaddr  : 7; /*!< 13-07 Hub Address */
+		unsigned prtaddr  : 7; /*!< 06-00 Port Address */
+	} b;
+} hcsplt_data_t;
+
+/*!
+  \brief Bit fields in the Host Interrupt Register.
+ */
+typedef union hcint_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved   :21;
+		unsigned datatglerr : 1; /*!< 10 Data Toggle Error */
+		unsigned frmovrun   : 1; /*!< 09 Frame Overrun */
+		unsigned bblerr     : 1; /*!< 08 Babble Error */
+		unsigned xacterr    : 1; /*!< 07 Transaction Err */
+		unsigned nyet       : 1; /*!< 06 NYET Response Received */
+		unsigned ack        : 1; /*!< 05 ACK Response Received */
+		unsigned nak        : 1; /*!< 04 NAK Response Received */
+		unsigned stall      : 1; /*!< 03 STALL Response Received */
+		unsigned ahberr     : 1; /*!< 02 AHB Error */
+		unsigned chhltd     : 1; /*!< 01 Channel Halted */
+		unsigned xfercomp   : 1; /*!< 00 Channel Halted */
+			#define LTQUSB_HCINT_MSK_DATATGLERR 0x00000400
+			#define LTQUSB_HCINT_MSK_FRMOVRUN   0x00000200
+			#define LTQUSB_HCINT_MSK_BBLERR     0x00000100
+			#define LTQUSB_HCINT_MSK_XACTERR    0x00000080
+			#define LTQUSB_HCINT_MSK_NYET       0x00000040
+			#define LTQUSB_HCINT_MSK_ACK        0x00000020
+			#define LTQUSB_HCINT_MSK_NAK        0x00000010
+			#define LTQUSB_HCINT_MSK_STALL      0x00000008
+			#define LTQUSB_HCINT_MSK_AHBERR     0x00000004
+			#define LTQUSB_HCINT_MSK_CHHLTD     0x00000002
+			#define LTQUSB_HCINT_MSK_XFERCOMP   0x00000001
+	}b;
+} hcint_data_t;
+
+
+/*!
+ \brief Bit fields in the Host Channel Transfer Size
+  Register.
+ */
+typedef union hctsiz_data
+{
+	uint32_t d32;
+	struct
+	{
+		/** */
+		unsigned dopng     : 1; /*!< 31    Do PING protocol when 1  */
+		/**
+		 * Packet ID for next data packet
+		 * 0: DATA0
+		 * 1: DATA2
+		 * 2: DATA1
+		 * 3: MDATA (non-Control), SETUP (Control)
+		 */
+		unsigned pid       : 2; /*!< 30-29 Packet ID for next data packet
+		                                  0: DATA0
+		                                  1: DATA2
+		                                  2: DATA1
+		                                  3: MDATA (non-Control), SETUP (Control)
+		                         */
+			#define LTQUSB_HCTSIZ_DATA0 0
+			#define LTQUSB_HCTSIZ_DATA1 2
+			#define LTQUSB_HCTSIZ_DATA2 1
+			#define LTQUSB_HCTSIZ_MDATA 3
+			#define LTQUSB_HCTSIZ_SETUP 3
+		unsigned pktcnt    :10; /*!< 28-19 Data packets to transfer */
+		unsigned xfersize  :19; /*!< 18-00 Total transfer size in bytes */
+	}b;
+} hctsiz_data_t;
+
+/*@}*//*LTQUSB_CSR_HOST_HC_REG*/
+
+/****************************************************************************/
+
+/*!
+  \addtogroup LTQUSB_CSR_PWR_CLK_GATING_REG
+ */
+/*@{*/
+/*!
+   \brief Bit fields in the Power and Clock Gating Control Register
+ */
+typedef union pcgcctl_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved      : 27;
+		unsigned physuspended  : 1; /*!< 04 PHY Suspended */
+		unsigned rstpdwnmodule : 1; /*!< 03 Reset Power Down Modules */
+		unsigned pwrclmp       : 1; /*!< 02 Power Clamp */
+		unsigned gatehclk      : 1; /*!< 01 Gate Hclk */
+		unsigned stoppclk      : 1; /*!< 00 Stop Pclk */
+	} b;
+} pcgcctl_data_t;
+/*@}*//*LTQUSB_CSR_PWR_CLK_GATING_REG*/
+
+/****************************************************************************/
+
+
+typedef union rcu_ana_cfg1_data
+{
+	uint32_t d32;
+	struct
+	{
+		unsigned reserved      : 14;
+		unsigned dis_thr       : 3; /*!< 17-15 Disconnect threshold adjustment */
+		unsigned squs_thr      : 3; /*!< 14-12 Squelch threshold adjustment */
+		unsigned txhs_xv       : 2; /*!< 11-10 Transmitter high speed crossover adjustment */
+		unsigned txsrci_xv     : 4; /*!< 09-06 Transmitter source impedance adjustment */
+		unsigned txhs_dc       : 4; /*!< 05-02 Transmitter high speed DC voltage level adjustment */
+		unsigned tx_edge       : 1; /*!< 01    Transmitter high speed rise/fall time adjustment */
+		unsigned tx_pee        : 1; /*!< 00    Transmitter high speed pre-emphasis enable */
+	} b;
+} rcu_ana_cfg1_data_t;
+
+#endif //__LTQUSB_REGS_H__
--- a/drivers/usb/host/ltqusb_version.h
+++ b/drivers/usb/host/ltqusb_version.h
@@ -0,0 +1,5 @@
+
+#ifndef LTQUSB_VERSION
+#define LTQUSB_VERSION "4.0 B140513"
+#endif
+
