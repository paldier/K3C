# HG changeset patch
# Parent 70308919500ad4b7d0701c11a248b25d34ede08e
added ubi, gphyfirmware, wlanm command in env variables
* * *
HN1 only: added support for GPHY Firmware in a separate partition.

diff --git a/arch/mips/include/asm/boot.h b/arch/mips/include/asm/boot.h
new file mode 100755
--- /dev/null
+++ b/arch/mips/include/asm/boot.h
@@ -0,0 +1,186 @@
+#ifndef _BOOT_H
+#define _BOOT_H
+
+#define USE_SP 2				// [valid 1,2,3] 	:1 dcachelock/4kec, ddr/interAptiv
+								//					:2 dcachelock/4kec, 1st ssb/interAptiv
+								//					:3 dcachelock/4kec, 4th ssb/interAptiv
+#define CORE_ON 2				// [valid 1,2]	 	:1 for only core0, 2 for both
+#define VPE_ON 2				// [valid 1,2]		:1 for only vpe0, 2 for additional vpe1
+#define GIC_ON   
+
+#define GIC_SH_WEDGE_REG  *((volatile unsigned int*) (0xb2320280))
+#define FIRST_IPI 19  			// GIC interrupts 56+ are used to signal interrupts between cores.
+
+#define IPCMAGIC			0x344B6563			/* ASCII: 4Kec */
+#define SRAMFLAG			0xbf807f00
+#define MPS_DDR_LOC			0xbf807f04
+#define MPS_SIZE_LOC		0xbf807f08
+#define MPS_LOAD_ADDR		0xbf807f0C
+#define CPUMSG				0xa000ff00		
+#define INTMSG				0xa000ff10
+#define JMPMSG				0xa000ff20
+#define ITCMSG				0xa000ff30
+
+#define STACK_BASE_ADDR	      0xa0008000  		/* InterAptiv uses ddr for stack */
+#define STACK_SIZE_LOG2  	  13          		/* 13(8Kbytes), 17(128Kbytes), 20(1Mbytes) */
+#define STACK_BASE_ADDR_4KEc  0x9fc02000  		/* 4KEc uses 8K dcache for stack */
+
+
+#define CFG_CACHE_LINES  32
+#define CFG_CACHELINE_SIZE  CFG_CACHE_LINES            
+
+#define MPS_SRAM_BASE_ADDRESS   0xbf300000		/* to be confirmed */
+#define MPS_SRAM_BOOT_OFFSET    0x1c0 
+
+/* Offset for CPU1 (both CPUs have same register set) */
+#define BOOT_BASE_ADDRESS   (MPS_SRAM_BASE_ADDRESS + MPS_SRAM_BOOT_OFFSET)
+#define BOOT_CPU_OFFSET     0x20
+ 
+#ifdef __ASSEMBLY__
+#define BOOT_RVEC		   (BOOT_BASE_ADDRESS + 0x00)
+#define BOOT_NVEC		   (BOOT_BASE_ADDRESS + 0x04)
+#define BOOT_EVEC		   (BOOT_BASE_ADDRESS + 0x08)
+#define BOOT_CP0_CAUSE     (BOOT_BASE_ADDRESS + 0x0C)
+#define BOOT_CP0_EPC	   (BOOT_BASE_ADDRESS + 0x10)
+#define BOOT_CP0_EEPC	   (BOOT_BASE_ADDRESS + 0x14)
+#define BOOT_SIZE          (BOOT_BASE_ADDRESS + 0x18)   /* for CPU1 */
+#define BOOT_RCU_SR        (BOOT_BASE_ADDRESS + 0x18)   /* for CPU0 */
+#define BOOT_CFG_STAT	   (BOOT_BASE_ADDRESS + 0x1C)
+#else
+#define BOOT_RVEC(cpu)		 (volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x00)
+#define BOOT_NVEC(cpu)		 (volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x04)
+#define BOOT_EVEC(cpu)		 (volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x08)
+#define BOOT_CP0_STATUS(cpu) (volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x0C)
+#define BOOT_CP0_EPC(cpu)	 (volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x10)
+#define BOOT_CP0_EEPC(cpu)	 (volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x14)
+#define BOOT_SIZE(cpu)       (volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x18)	/* for CPU1 */
+#define BOOT_RCU_SR(cpu)     (volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x18)	/* for CPU0 */
+#define BOOT_CFG_STAT(cpu)	 (volatile u32*)(BOOT_BASE_ADDRESS + (cpu * BOOT_CPU_OFFSET) + 0x1C)
+#endif
+
+#define SWITCH_TX_DESC		(volatile u32*)(BOOT_BASE_ADDRESS + (2 * BOOT_CPU_OFFSET))
+
+#define BOOT_CFG_TEST   	0x00
+#define BOOT_CFG_NOR   		0x01
+//reserved			0x02
+#define BOOT_CFG_PCI  		0x03
+#define BOOT_CFG_ASC   		0x04
+#define BOOT_CFG_SFLASH		0x05
+#define BOOT_CFG_NAND  		0x06
+//reserved			0x07
+#define BOOT_CFG_RGMII 		0x08
+#define BOOT_CFG_MII   		0x09
+#define BOOT_CFG_REVMII  	0x0A
+#define BOOT_CFG_RINMII   	0x0B
+//reserved			0x0C
+//reserved  		    	0x0D
+#define BOOT_CFG_REVTMII	0x0E
+#define BOOT_CFG_ROUTMII   	0x0F
+
+#define BOOT_NUM_RETRY  3
+
+#define BOOT_STAT_MASK_ALL     0x0000FFFF
+#define BOOT_STAT_MASK_STAT    0x0000F000
+#define BOOT_STAT_MASK_BERR    0x00000F00
+#define BOOT_STAT_MASK_BSTRAP  0x000000F0
+#define BOOT_STAT_MASK_BMODULE 0x0000000F
+
+#define BOOT_STAT_INIT         0x00000000
+#define BOOT_STAT_BSTRAP       0x00001000
+#define BOOT_STAT_RETRY        0x00002000
+#define BOOT_STAT_START        0x00003000
+#define BOOT_STAT_HALT         0x0000F000
+
+#define BOOT_ERR_NO_RVEC       0x00000100
+#define BOOT_ERR_NO_NVEC       0x00000200
+#define BOOT_ERR_NO_EVEC       0x00000300
+#define BOOT_ERR_BSTRAP        0x00000400
+#define BOOT_ERR_EXC           0x00000800
+
+#ifndef __ASSEMBLY__
+
+void mips_dcache_flush(u32 lock_size, u32 cache_line_size,  u32 start_address);
+void mips_allcache_invalidate(u32 size, u32 cache_line_size, u32 start_address, u32 cache);
+
+void change_k0_cca(void);
+void boot_cp0(u32 cpu_num, u32 core_num, u32 vpe_num, u32 core_id);
+void boot_main(u32 cpu_num, u32 core_num, u32 vpe_num, u32 core_id);
+void boot_others(u32 cpu_num, u32 core_num, u32 vpe_num, u32 core_id);
+void boot_bootrom_config(void);
+void boot_set_status( u32 status, u32 mask);
+void boot_set_config( u32 config);
+void boot_set_rvec( u32 vector);
+void boot_set_size( u32 size);
+void boot_sdbg( u8* string, u32 value);
+void boot_error( u32 berr);
+int boot_from_ebu(void);
+void _boot_rvec(void);
+typedef struct
+{
+	u32   cpu;              /** CPU number */
+	u32   config;           /** Boot configuration */
+	u32   endian;           /** CPU endianess */
+	u32   debug;            /** Debug mode */
+	u32	(*exit)(void);	    /** application vector */
+} boot_data;
+
+extern boot_data bootrom;
+#endif
+
+
+#define LEAF(name)\
+    .##text;\
+    .##globl    name;\
+    .##ent  name;\
+name:
+
+#define END(name)\
+    .##size name,.-name;\
+    .##end  name
+
+//For GRX500
+#define GCR_CONFIG_ADDR     0xb2300000  // KSEG0 address of the GCR registers
+#define GIC_P_BASE_ADDR		0x12320000  // physical address of the GIC
+#define GIC_BASE_ADDR		0xb2320000  // KSEG0 address address of the GIC
+#define CPC_P_BASE_ADDR 	0x12310001  // physical address of the CPC
+#define CPC_BASE_ADDR		0xb2310000  // KSEG0 address address of the CPC
+
+#define CUS_P_BASE_ADDR 	0x123f0001  // physical address of the CUS
+#define CUS_BASE_ADDR		0xb23f0000  // KSEG0 address address of the CUS
+
+#define CDMM_P_BASE_ADDR 	0x123e0001  // physical address of the CDMM
+#define CDMM_BASE_ADDR		0xb23e0000  // KSEG0 address address of the CDMM
+
+/**************************************************************************************
+ Register use while executing in this file: ("GLOBAL" denotes a common value.)
+**************************************************************************************/
+
+#define r1_all_ones     $1   /* at Will hold 0xffffffff to simplify bit insertion of 1's. GLOBAL! */
+
+// $2 - $7 (v0, v1 a0 - a3) reserved for program use
+
+#define r8_core_num    $8  /* t0 Core number. Only core 0 is active after reset. */
+#define r9_vpe_num     $9  /* t1 MT ASE VPE number that this TC is bound to (0 if non-MT.) */
+#define r10_has_mt_ase  $10   /* t2 Core implements the MT ASE. */
+#define r11_is_cps      $11   /* t3 Core is part of a Coherent Processing System. */
+
+// $12 - $15 (t4 - t7) are free to use
+// $16, $17 (s0 and s1) reserved for program use
+
+#define r18_tc_num      $18  /* s2 MT ASE TC number (0 if non-MT.) */
+#define r19_more_cores  $19  /* s3 Number of cores in CPS in addition to core 0. GLOBAL! */
+#define r20_more_vpes   $20  /* s4 Number of vpes in this core in addition to vpe 0. */
+#define r21_more_tcs    $21  /* s5 Number of tcs in vpe in addition to the first. */
+#define r22_gcr_addr    $22  /* s6 Uncached (kseg1) base address of the Global Config Registers. */
+#define r23_cpu_num     $23  /* s7 Unique per vpe "cpu" identifier (CP0 EBase[CPUNUM]). */
+#define r24_malta_word  $24  /* t8 Uncached (kseg1) base address of Malta ascii display. GLOBAL! */
+#define r25_coreid      $25  /* t9 Copy of cp0 PRiD GLOBAL! */
+#define r26_int_addr    $26  /* k0 Interrupt handler scratch address. */
+#define r27_int_data    $27  /* k1 Interrupt handler scratch data. */
+// $28 gp and $29 sp
+#define r30_cpc_addr    $30  /* s8 Address of CPC register block after cpc_init. 0 indicates no CPC. */
+// $31 ra
+
+
+
+#endif /* #ifdef _BOOT_H */
diff --git a/arch/mips/include/asm/cps.h b/arch/mips/include/asm/cps.h
new file mode 100755
--- /dev/null
+++ b/arch/mips/include/asm/cps.h
@@ -0,0 +1,886 @@
+/*
+ * cps.h
+ *
+ *  Created on: May 1, 2012
+ *      Author: MIPS TECHNOLOGIES, INC
+*/
+/*
+Unpublished work (c) MIPS Technologies, Inc.  All rights reserved.  Unpublished rights reserved
+under the copyright laws of the United States of America and other countries.
+
+This code is confidential and proprietary to MIPS Technologies, Inc. ("MIPS Technologies") and
+may be disclosed only as permitted in writing by MIPS Technologies or an authorized third party.
+Any copying, reproducing, modifying, use or disclosure of this code (in whole or in part) that is
+not expressly permitted in writing by MIPS Technologies or an authorized third party is strictly
+prohibited. At a minimum, this code is protected under trade secret, unfair competition, and
+copyright laws. Violations thereof may result in criminal penalties and fines.
+
+MIPS Technologies reserves the right to change this code to improve function, design or
+otherwise. MIPS Technologies does not assume any liability arising out of the application or use
+of this code, or of any error or omission in such code.  Any warranties, whether express, statutory,
+implied or otherwise, including but not limited to the implied warranties of merchantability or
+fitness for a particular purpose, are excluded.  Except as expressly provided in any written license
+agreement from MIPS Technologies or an authorized third party, the furnishing of this code does
+not give recipient any license to any intellectual property rights, including any patent rights, that
+cover this code.
+
+This code shall not be exported, reexported, transferred, or released, directly or indirectly, in
+violation of the law of any country or international law, regulation, treaty, Executive Order,
+statute, amendments or supplements thereto.  Should a conflict arise regarding the export,
+reexport, transfer, or release of this code, the laws of the United States of America shall be
+the governing law.
+
+This code may only be disclosed to the United States government ("Government"), or to
+Government users, with prior written consent from MIPS Technologies or an authorized third
+party.  This code constitutes one or more of the following: commercial computer software,
+commercial computer software documentation or other commercial items.  If the user of this
+code, or any related documentation of any kind, including related technical data or manuals, is an
+agency, department, or other entity of the Government, the use, duplication, reproduction, release,
+modification, disclosure, or transfer of this code, or any related documentation of any kind, is
+restricted in accordance with Federal Acquisition Regulation 12.212 for civilian agencies and
+Defense Federal Acquisition Regulation Supplement 227.7202 for military agencies.  The use of
+this code by the Government is further restricted in accordance with the terms of the license
+agreement(s) and/or applicable contract terms and conditions covering this code from MIPS
+Technologies or an authorized third party.
+*/
+
+/*
+ * This include file contains #defines for the memory mapped registers in a coherent Processing system
+ * of both single cores and multi threaded cores. It contains registers offset for all the registers,
+ * defines for the fields with in the registers and encodings for some of the fields.
+ *
+ * The fields in the registers are defined by a pair of #defines, one define is the starting bit position of
+ * the field and another, (with a "_S" appended to the name), is the size of the field. Here is an example of
+ * how you would use these #defines in the the extraction of a filed:
+ *
+ *   li      $5, GIC_BASE_ADDR			         # load GIC KSEG0 Address
+ *   lw      $4, GIC_SH_CONFIG($5)               # Read the GIC_SH_CONFIG Register
+ *   ext     $4, NUMINTERRUPTS, NUMINTERRUPTS_S  # Extract NUMINTERRUPTS
+ *
+ *   The names for the registers and fields are usually the same as used in the Software Users Manual
+ *   (SUM). The exceptions occur when the names would conflict with each other in that case the name
+ *   is appended with something to make it unique.
+ */
+
+#ifndef CPS_H_
+#define CPS_H_
+
+// GCR Offset for GCR_CONFIG, field positions and field size
+#define GCR_CONFIG 0x0000
+#define NUM_ADDR_REGIONS 16
+#define NUM_ADDR_REGIONS_S 4
+#define NUMIOCU 8
+#define NUMIOCU_S 4
+#define PCORES 0
+#define PCORES_S 8
+
+// GCR Offset for GCR_BASE, field positions and field size
+#define GCR_BASE 0x0008
+#define GCR_BASE_ADDR 15
+#define GCR_BASE_ADDR_S 17
+#define CCA_DEFAULT_OVERRIDE_VALUE 5
+#define CCA_DEFAULT_OVERRIDE_VALUE_S 3
+#define CCA_DEFAULT_OVERRIDE_ENABLE 4
+#define CCA_DEFAULT_OVERRIDE_ENABLE_S 1
+#define CM_DEFAULT_TARGET 0
+#define CM_DEFAULT_TARGET_S 2
+
+// GCR Offset for GCR_CONTROL, field positions and field size
+#define GCR_CONTROL 0x0010
+#define SYNCCTL 16
+#define SYNCCTL_S 1
+#define CM_SYNC_TX_DISABLE 5
+#define CM_SYNC_TX_DISABLE_S 1
+#define CM_AUTO_CLR_IVU_EN 4
+#define CM_AUTO_CLR_IVU_EN_S 1
+#define CM_COHST_SH_ALWAYS_EN 3
+#define CM_COHST_SH_ALWAYS_EN_S 1
+#define CM_PARK_EN 2
+#define CM_PARK_EN_S 1
+#define CM_DISABLE_MMIO_LIMIT 1
+#define CM_DISABLE_MMIO_LIMIT_S 1
+#define CM_SPEC_READ_EN 0
+#define CM_SPEC_READ_EN_S 1
+
+// GCR Offset for GCR_CONTROL_2, field positions and field size
+#define GCR_CONTROL2 0x0018
+#define L2_CACHEOP_LIMIT 16
+#define L2_CACHEOP_LIMIT_S 4
+#define L1_CACHEOP_LIMIT 3
+#define L1_CACHEOP_LIMIT_S 4
+
+// GCR Offset for GCR_ACCESS, field positions and field size
+#define GCR_ACCESS 0x0020
+#define CM_ACCESS_EN 0
+#define CM_ACCESS_EN_S 8
+
+// GCR Offset for GCR_REV, field positions and field size
+#define GCR_REV 0x0030
+#define MAJOR_REV_GCR 8
+#define MAJOR_REV_GCR_S 8
+#define MINOR_REV_GCR 7
+#define MINOR_REV_GCR_S 8
+
+// GCR Offset for GCR_ERROR_MASK
+#define GCR_ERROR_MASK 0x0040
+
+// error type encoding
+#define GC_WR_ERR 1
+#define GC_RD_ERR 2
+#define COH_WR_ERR 3
+#define COH_RD_ERR 4
+#define MMIO_WR_ERR 5
+#define MMIO_RD_ERR 6
+#define INTVN_WR_ERR 17
+#define INTVN_RD_ERR 18
+
+// GCR Offset for GCR_ERROR_CAUSE, field positions and field size
+#define GCR_ERROR_CAUSE 0x0048
+#define CM_ERROR_TYPE 27
+#define CM_ERROR_TYPE_S 5
+#define CM_ERROR_INFO 0
+#define CM_ERROR_INFO_S 27
+
+// Fields and sizes for Error Types 1 - 5
+#define CCA 15
+#define CCA_S 3
+#define TARGET_REGION 12
+#define TARGET_REGION_S 3
+#define OCP_MCMD_ERROR 7
+#define OCP MCMD_ERROR_S 5
+#define SOURCE_TAGID 3
+#define SOURCE_TAGID_S 4
+#define SOURCE_PORT 0
+#define SOURCE_PORT_S 3
+
+// Fields for Error Types 16 - 17
+#define COHERENT_STATE_CORE_3 19
+#define COHERENT_STATE_CORE_3_S 2
+#define INTERVENTION_SRESP_CORE3 18
+#define INTERVENTION_SRESP_CORE3_S 1
+
+#define COHERENT_STATE_CORE_2 16
+#define COHERENT_STATE_CORE_2_S 2
+#define INTERVENTION_SRESP_CORE2 15
+#define INTERVENTION_SRESP_CORE2_S 1
+
+#define COHERENT_STATE_CORE_1 13
+#define COHERENT_STATE_CORE_1_S 2
+#define INTERVENTION_SRESP_CORE1 12
+#define INTERVENTION_SRESP_CORE1_S 1
+
+#define COHERENT_STATE_CORE_0 10
+#define COHERENT_STATE_CORE_0_S 2
+#define INTERVENTION_SRESP_CORE0 9
+#define INTERVENTION_SRESP_CORE0_S 1
+
+#define FROM_STORE_CONDITIONAL 8
+#define FROM_STORE_CONDITIONAL_S 1
+#define OCP_MCMD 3
+#define OCP_MCMD_S 5
+#define SOURCE_PORT 0
+#define SOURCE_PORT_S 3
+
+// Coherent state encoding
+#define CS_INVALID 0
+#define CS_SHARED 1
+#define CS_MODIFID 2
+#define CS_EXCLUSIVE
+
+// Intervention Response encoding
+#define IR_OK 0
+#define IR_DATA 1
+
+// MCmd Encodings for CM_ERROR_INFO
+#define LEGACY_WRITE 0x01
+#define LEGACY_READ 0x02
+#define COHERENT_READ_OWN 0x08
+#define COHERENT_READ_SHARE 0x09
+#define COHERENT_READ_DISCARD 0x0A
+#define COHERENT_READ_SHARE_ALWAYS 0x0B
+#define COHERENT_UPGRADE 0x0C
+#define COHERENT_WRITEBACK 0x0D
+#define COHERENT_COPYBACK 0x10
+#define COHERENT_COPYBACK_INVALIADATE 0x11
+#define COHERENT_INVALIADATE 0x12
+#define COHERENT_WRITE_INVALIADATE 0x13
+#define COHERENT_COMPLETION_SYNC 0x14
+
+// GCR Offset for GCR_ERROR_ADDR
+#define GCR_ERROR_ADDR 0x0050
+
+// GCR Offset for GCR_ERROR_MULT
+#define GCR_ERROR_MULT 0x0058
+#define CM_ERROR_2ND 0
+#define CM_ERROR_2ND_S 5
+
+// GCR Offset for GCR_GIC_BASE, fields and sizes
+#define GCR_GIC_BASE 0x0080
+#define GIC_BASEADDRESS 17
+#define GIC_BASEADDRESS_S 15
+#define GIC_EN 0
+#define GIC_EN_S 1
+
+// GCR Offset for GCR_CPC_BASE, fields and sizes
+#define GCR_CPC_BASE 0x0088
+#define CPC_BASEADDRESS 15
+#define CPC_BASEADDRESS_S 17
+#define CPC_EN 0
+#define CPC_EN_S 1
+
+// GCR Offset for GCR_REGn_BASE, fields and sizes
+#define GCR_REG0_BASE 0x0090
+#define GCR_REG1_BASE 0x00A0
+#define GCR_REG2_BASE 0x00B0
+#define GCR_REG3_BASE 0x00C0
+#define GCR_REG4_BASE 0x0190
+#define GCR_REG5_BASE 0x01A0
+
+#define CM_REGION_BASEADDRESS 16
+#define CM_REGION_BASEADDRESS_S 16
+
+// GCR Offset for GCR_REGn_MASK, fields, sizes and encodings
+#define GCR_REG0_MASK 0x0098
+#define GCR_REG1_MASK 0x00A8
+#define GCR_REG2_MASK 0x00B8
+#define GCR_REG3_MASK 0x00C8
+#define GCR_REG4_MASK 0x0198
+#define GCR_REG5_MASK 0x01A8
+#define CM_REGION_ADDRESS_MASK 16
+#define CM_REGION_ADDRESS_MASK_S 16
+#define CCA_OVERRIDE_VALUE 5
+#define CCA_OVERRIDE_VALUE_S 3
+#define CCA_OVERRIDE_ENABLE 4
+#define CCA_OVERRIDE_ENABLE_S 1
+#define CM_REGION_TARGET 0
+#define CM_REGION_TARGET_S 2
+// CM_REGION_TARGET encoding
+#define CM_REGION_TARGET_DISABLE 0x0
+#define CM_REGION_TARGET_MEMORY 0x1
+#define CM_REGION_TARGET_IOCU 0x2
+
+// GCR Offset for GCR_GIC_STATUS, fields and sizes
+#define GCR_GIC_STATUS 0x00D0
+#define GIC_EX 0
+#define GIC_EX_S 1
+
+// GCR Offset for GCR_CACHE_REV, fields and sizes
+#define GCR_CACHE_REV 0x00E0
+#define MAJOR_REV_CACHE 8
+#define MAJOR_REV_CACHE_S 8
+#define MINOR_REV_CACHE 7
+#define MINOR_REV_CACHE_S 8
+
+// GCR Offset for GCR_CPC_STATUS, fields and sizes
+#define GCR_CPC_STATUS 0x00F0
+#define CPC_EX 0
+#define CPC_EX_S 1
+
+// GCR Offset for GCR_IOCU1_REV, fields and sizes
+#define GCR_IOCU1_REV 0x0200
+#define MAJOR_REV_IOCU 8
+#define MAJOR_REV_IOCU_S 8
+#define MINOR_REV_IOCU 7
+#define MINOR_REV_IOCU_S 8
+
+// GCR Core Local and Core other offsets
+#define CORE_LOCAL_CONTROL_BLOCK 0x2000
+#define CORE_OTHER_CONTROL_BLOCK 0x4000
+
+// GCR Core Local and Other COHERENCE, fields and sizes
+#define GCR_CL_COHERENCE 0x0008
+#define GCR_CO_COHERENCE 0x0008
+#define COH_DOMAIN_EN 0
+#define COH_DOMAIN_EN_S 8
+
+// GCR Core Local and Other CONFIG , fields and sizes
+#define GCR_CL_CONFIG 0x0010
+#define GCR_CO_CONFIG 0x0010
+#define IOCU_TYPE 10
+#define IOCU_TYPE_S 2
+#define PVPE 0
+#define PVPE_S 10
+
+// GCR Core Local and Other OTHER, fields and sizes
+#define GCR_CL_OTHER 0x0018
+#define GCR_CO_OTHER 0x0018
+#define OTHER_CORE_NUM 16
+#define OTHER_CORE_NUM_S 16
+
+// GCR Core Local and Other RESET_BASE, fields and sizes
+#define GCR_CL_RESET_BASE 0x0020
+#define GCR_CO_RESET_BASE 0x0020
+#define BEV_EXCEPTION_BASE 12
+#define BEV_EXCEPTION_BASE_S 20
+
+// GCR Core Local and Other ID
+#define GCR_CL_ID 0x0028
+#define GCR_CO_ID 0x0028
+
+// GCR Global Debug Block Offsets
+#define Global_Debug_Block 0x6000
+
+// GCR Global Debug GCR_DB_TCBCONTROLB, fields and sizes
+#define GCR_DB_TCBCONTROLB 0x0008
+#define WE_DB_TCBCONTROLB 31
+#define WE_DB_TCBCONTROLB_S 1
+#define TWSRC_WIDTH 26
+#define TWSRC_WIDTH_S 2
+#define TRPAD 18
+#define TRPAD_S 1
+#define RM 16
+#define RM_S 1
+#define TR 15
+#define TR_S 1
+#define BF 14
+#define BF_S 1
+#define TM 12
+#define TM_S 2
+#define CR 8
+#define CR_S 3
+#define CAL 7
+#define CAL_S 1
+#define OFC 1
+#define OFC_S 1
+#define FUNNEL_TRACE_ENABLE 0
+#define FUNNEL_TRACE_ENABLE_S 1
+
+// GCR Global Debug GCR_DB_TCBCONTROLD, fields and sizes
+#define GCR_DB_TCBCONTROLD 0x0010
+#define P4_CTL 24
+#define P4_CTL_S 2
+#define P3_CTL 22
+#define P3_CTL_S 2
+#define P2_CTL 20
+#define P2_CTL_S 2
+#define P1_CTL 18
+#define P1_CTL_S 2
+#define P0_CTL 16
+#define P0_CTL_S 2
+#define TW_SRC_VAL 8
+#define TW_SRC_VAL_S 3
+#define TRACE_WB 7
+#define TRACE_WB_S 1
+#define CM_INHIBIT_OVERFLOW 5
+#define CM_INHIBIT_OVERFLOW_S 1
+#define TLEV 3
+#define TLEV_S 2
+#define AE_PER_PORT 2
+#define AE_PER_PORT_S 1
+#define GLOBAL_CM_EN 1
+#define GLOBAL_CM_EN_S 1
+#define CM_EN 0
+#define CM_EN_S 1
+
+// GCR Global Debug GCR_DB_TCBCONTROLE, fields and sizes
+#define GCR_DB_TCBCONTROLE 0x0020
+#define TrIdle 8
+#define TrIdle_S 1
+#define PeC 0
+#define PeC_S 1
+
+// GCR Global Debug GCR_DB_TCBConfig, fields and sizes
+#define GCR_DB_TCBCONFIG 0x0028
+#define CF1 31
+#define CF1_S 1
+#define SZ 17
+#define SZ_S 4
+#define CRMAX 14
+#define CRMAX_S 3
+#define CRMIN 11
+#define CRMIN_S 3
+#define PW 9
+#define PW_S 2
+#define ONT 5
+#define ONT_S 1
+#define OFT 4
+#define OFT_S 1
+#define TCB_REV 0
+#define TCB_REV_S 4
+
+// GCR Global Debug GCR_DB_PC_CTL, fields and sizes
+#define GCR_DB_PC_CTL 0x0100
+#define PERF_INT_EN 30
+#define PERF_INT_EN_S 1
+#define PERF_OVF_STOP 29
+#define PERF_OVF_STOP_S 1
+#define P1_RESET 9
+#define P1_RESET_S 1
+#define P1_COUNT_ON 8
+#define P1_COUNT_ON_S 1
+#define P0_RESET 7
+#define P0_RESET_S 1
+#define P0_COUNT_ON 6
+#define P0_COUNT_ON_S 1
+#define CYCL_CNT_RESET 5
+#define CYCL_CNT_RESET_S 1
+#define CYCL_CNT__ON 4
+#define CYCL_CNT__ON_S 1
+#define PERF_NUM_CNT 0
+#define PERF_NUM_CNT_S 4
+
+// GCR Global Debug Read Pointer GCR_DB_TCBRDP
+#define GCR_DB_TCBRDP 0x0108
+
+// GCR Global Debug Write Pointer GCR_DB_TCBWDP
+#define GCR_DB_TCBWRP 0x0110
+
+// GCR Global Debug Start Pointer GCR_DB_TCBSTP
+#define GCR_DB_TCBSTP 0x0118
+
+// GCR_DB_PC_OV, fields and sizes
+#define GCR_DB_PC_OV 0x0120
+#define P1_OVERFLOW 2
+#define P1_OVERFLOW_S 1
+#define P0_OVERFLOW 1
+#define P0_OVERFLOW_S 1_S 1
+#define CYCL_CNT_OVERFLOW 0
+#define CYCL_CNT_OVERFLOW_S 1
+
+// GCR Global Debug GCR_DB_PC_EVENT, fields and sizes
+#define GCR_DB_PC_EVENT 0x0130
+#define P1_EVENT 8
+#define P1_EVENT_S 8
+#define P0_EVENT 0
+#define P0_EVENT_S 8
+
+// GCR Global Debug GCR_DB_PC_CYCLE
+#define GCR_DB_PC_CYCLE 0x0180
+
+
+// GCR Global Debug Qualifier and count registers
+#define GCR_DB_PC_QUAL0 0x0190
+#define GCR_DB_PC_CNT0 0x0198
+#define GCR_DB_PC_QUAL1 0x01a0
+#define GCR_DB_PC_CNT1 0x01a8
+
+// GCR Global Debug Trace word access registers
+#define GCR_DB_TCBTW_LO 0x0200
+#define GCR_DB_TCBTW_HI 0x0208
+
+// GIC Offsets within the Global interrupt controller
+
+#define GIC_SH_CONFIG 0x0000
+#define COUNTSTOP 28
+#define COUNTSTOP_S 1
+#define COUNTBITS 24
+#define COUNTBITS_S 4
+#define NUMINTERRUPTS 16
+#define NUMINTERRUPTS_S 8
+#define PVPES 0
+#define PVPES_S 9
+
+#define GIC_SH_CounterLo 0x0010
+#define GIC_SH_CounterHi 0x0014
+
+#define GIC_RevisionID 0x0020
+
+#define GIC_SH_POL31_0 0x0100
+#define GIC_SH_POL63_32 0x0104
+#define GIC_SH_POL95_64 0x0108
+#define GIC_SH_POL127_96 0x010c
+#define GIC_SH_POL159_128 0x0110
+#define GIC_SH_POL191_160 0x0114
+#define GIC_SH_POL223_192 0x0118
+#define GIC_SH_POL255_224 0x011c
+
+#define GIC_SH_TRIG31_0 0x0180
+#define GIC_SH_TRIG63_32 0x0184
+#define GIC_SH_TRIG95_64 0x0188
+#define GIC_SH_TRIG127_96 0x018c
+#define GIC_SH_TRIG159_128 0x0190
+#define GIC_SH_TRIG191_160 0x0194
+#define GIC_SH_TRIG223_192 0x0198
+#define GIC_SH_TRIG255_224 0x019c
+
+#define GIC_SH_DUAL31_0 0x0200
+#define GIC_SH_DUAL63_32 0x0204
+#define GIC_SH_DUAL95_64 0x0208
+#define GIC_SH_DUAL127_96 0x020c
+#define GIC_SH_DUAL159_128 0x0210
+#define GIC_SH_DUAL159_128 0x0210
+#define GIC_SH_DUAL191_160 0x0214
+#define GIC_SH_DUAL223_192 0x0218
+#define GIC_SH_DUAL255_224 0x021c
+
+#define GIC_SH_WEDGE 0x0280
+
+#define GIC_SH_RMASK31_0 0x0300
+#define GIC_SH_RMASK63_32 0x0304
+#define GIC_SH_RMASK95_64 0x0308
+#define GIC_SH_RMASK127_96 0x030c
+#define GIC_SH_RMASK159_128 0x0310
+#define GIC_SH_RMASK191_160 0x0314
+#define GIC_SH_RMASK223_192 0x0318
+#define GIC_SH_RMASK255_224 0x031c
+
+#define GIC_SH_SMASK31_00 0x0380
+#define GIC_SH_SMASK63_32 0x0384
+#define GIC_SH_SMASK95_64 0x0388
+#define GIC_SH_SMASK127_96 0x038c
+#define GIC_SH_SMASK159_128 0x0390
+#define GIC_SH_SMASK191_160 0x0394
+#define GIC_SH_SMASK223_192 0x0398
+#define GIC_SH_SMASK255_224 0x039c
+
+#define GIC_SH_MASK31_00 0x0400
+#define GIC_SH_MASK63_32 0x0404
+#define GIC_SH_MASK95_64 0x0408
+#define GIC_SH_MASK127_96 0x040c
+#define GIC_SH_MASK159_128 0x0410
+#define GIC_SH_MASK191_160 0x0414
+#define GIC_SH_MASK223_192 0x0418
+#define GIC_SH_MASK255_224 0x041c
+
+#define GIC_SH_PEND31_00 0x0480
+#define GIC_SH_PEND63_32 0x0484
+#define GIC_SH_PEND95_64 0x0488
+#define GIC_SH_PEND127_96 0x048c
+#define GIC_SH_PEND159_128 0x0490
+#define GIC_SH_PEND191_160 0x0494
+#define GIC_SH_PEND223_192 0x0498
+#define GIC_SH_PEND255_224 0x049c
+
+// Global MAP to Pin GIC_SH_MAP_PIN + (4 x interrupt_source)
+#define GIC_SH_MAP_PIN 0x0500
+
+#define GIC_SH_MAP_SPACER 0x20
+
+#define GIC_SH_MAP0_PIN 0x0500
+
+// Map source to VPEs 31 - 0 GIC_SH_MAP0_VPE31_0 + (0x20 x interrupt source)
+#define GIC_SH_MAP0_VPE31_0 0x2000
+// Map source to VPEs 63 - 32 GIC_SH_MAP0_VPE63_32 + (0x20 x interrupt source)
+#define GIC_SH_MAP0_VPE63_32  0x2004
+
+// Map source to core 31 - 0 GIC_SH_MAP0_CORE31_0 + (0x20 x interrupt source)
+#define GIC_SH_MAP0_CORE31_0 0x2000
+// Map source to core 63 - 32 GIC_SH_MAP0_CORE63_32 + (0x20 x interrupt source)
+#define GIC_SH_MAP0_CORE63_32 0x2004
+
+#define GIC_VB_DINT_SEND 0x6000
+
+// GIC VPE Local offsets (note the VPEL)
+#define GIC_VPE_LOCAL_SECTION_OFFSET 0x8000
+
+#define GIC_VPEL_CTL 0x0000
+#define GIC_VPEL_PEND 0x0004
+#define GIC_VPEL_MASK 0x0008
+#define GIC_VPEL_RMASK 0x000c
+#define GIC_VPEL_SMASK 0x0010
+#define GIC_VPEL_WD_MAP 0x0040
+#define GIC_VPEL_COMPARE_MAP 0x0044
+#define GIC_VPEL_TIMER_MAP (0x0048 )
+#define GIC_VPEL_FDC_MAP 0x004c
+#define GIC_VPEL_PERFCTR_MAP 0x0050
+#define GIC_VPEL_SWInt0_MAP 0x0054
+#define GIC_VPEL_SWInt1_MAP 0x0058
+#define GIC_VPEL_OTHER_ADDR 0x0080
+#define GIC_VPEL_IDENT 0x0088
+#define GIC_VPEL_WD_CONFIG0 0x0090
+#define GIC_VPEL_WD_COUNT0 0x0094
+#define GIC_VPEL_WD_INITIAL0 0x0098
+#define GIC_VPEL_CompareLo 0x00A0
+#define GIC_VPEL_CompareHi 0x00A4
+
+// NOTE: EIC Shadow set GIC_VPEL_EICSS + (4 x interrupt number)
+#define GIC_VPEL_EICSS 0x0100
+#define GIC_VL_DINT_PART 0x3000
+#define GIC_VL_BRK_GROUP 0x3080
+
+// GIC VPE Other offsets (note the VPEO)
+#define GIC_VPE_OTHER_SECTION_OFFSET 0xc000
+
+#define GIC_VPEO_CTL 0x0000
+#define GIC_VPEO_PEND 0x0004
+#define GIC_VPEO_MASK 0x0008
+#define GIC_VPEO_RMASK 0x000c
+#define GIC_VPEO_SMASK 0x0010
+#define GIC_VPEO_WD_MAP 0x0040
+#define GIC_VPEO_COMPARE_MAP 0x0044
+#define GIC_VPEO_TIMER_MAP 0x0048
+#define GIC_VPEO_FDC_MAP 0x004c
+#define GIC_VPEO_PERFCTR_MAP 0x0050
+#define GIC_VPEO_SWInt0_MAP 0x0054
+#define GIC_VPEO_SWInt1_MAP 0x0058
+#define GIC_VPEO_OTHER_ADDR 0x0080
+#define GIC_VPEO_IDENT 0x0088
+#define GIC_VPEO_WD_CONFIG0 0x0090
+#define GIC_VPEO_WD_COUNT0 0x0094
+#define GIC_VPEO_WD_INITIAL0 0x0098
+#define GIC_VPEO_CompareLo 0x00A0
+#define GIC_VPEO_CompareHi 0x00A4
+
+// NOTE: EIC Shadow set GIC_VPEO_EICSS + (4 x interrupt number)
+#define GIC_VPEO_EICSS 0x0100
+#define GIC_VO_DINT_PART 0x3000
+#define GIC_VO_BRK_GROUP 0x3080
+
+// GIC CORE Local offsets (note the COREL)
+#define GIC_CORE_LOCAL_SECTION_OFFSET 0x8000
+
+#define GIC_COREL_CTL 0x0000
+#define GIC_COREL_PEND 0x0004
+#define GIC_COREL_MASK 0x0008
+#define GIC_COREL_RMASK 0x000c
+#define GIC_COREL_SMASK 0x0010
+#define GIC_COREL_WD_MAP 0x0040
+#define GIC_COREL_COMPARE_MAP 0x0044
+#define GIC_COREL_TIMER_MAP 0x0048
+#define GIC_COREL_FDC_MAP 0x004c
+#define GIC_COREL_PERFCTR_MAP 0x0050
+#define GIC_COREL_SWInt0_MAP 0x0054
+#define GIC_COREL_SWInt1_MAP 0x0058
+#define GIC_COREL_OTHER_ADDR 0x0080
+#define GIC_COREL_IDENT 0x0088
+#define GIC_COREL_WD_CONFIG0 0x0090
+#define GIC_COREL_WD_COUNT0 0x0094
+#define GIC_COREL_WD_INITIAL0 0x0098
+#define GIC_COREL_CompareLo 0x00A0
+#define GIC_COREL_CompareHi 0x00A4
+// NOTE: EIC Shadow set GIC_COREL_EICSS + (4 x interrupt number)
+#define GIC_COREL_EICSS 0x0100
+#define GIC_COREL_DINT_PART 0x3000
+#define GIC_COREL_BRK_GROUP 0x3080
+
+// GIC CORE Other offsets (note the COREO)
+#define GIC_CORE_OTHER_SECTION_OFFSET 0xc000
+#define GIC_COREO_CTL 0x0000
+#define GIC_COREO_PEND 0x0004
+#define GIC_COREO_MASK 0x0008
+#define GIC_COREO_RMASK 0x000c
+#define GIC_COREO_SMASK 0x0010
+#define GIC_COREO_WD_MAP 0x0040
+#define GIC_COREO_COMPARE_MAP 0x0044
+#define GIC_COREO_TIMER_MAP 0x0048
+#define GIC_COREO_FDC_MAP 0x004c
+#define GIC_COREO_PERFCTR_MAP 0x0050
+#define GIC_COREO_SWInt0_MAP 0x0054
+#define GIC_COREO_SWInt1_MAP 0x0058
+#define GIC_COREO_OTHER_ADDR 0x0080
+#define GIC_COREO_IDENT 0x0088
+#define GIC_COREO_WD_CONFIG0 0x0090
+#define GIC_COREO_WD_COUNT0 0x0094
+#define GIC_COREO_WD_INITIAL0 0x0098
+#define GIC_COREO_CompareLo 0x00A0
+#define GIC_COREO_CompareHi 0x00A4
+// NOTE: EIC Shadow set GIC_COREO_EICSS + (4 x interrupt number)
+#define GIC_COREO_EICSS 0x0100
+#define GIC_COREO_DINT_PART 0x3000
+#define GIC_COREO_BRK_GROUP 0x3080
+
+
+// Bit fields for Local Interrupt Control Register (GIC_COREi_CTL) or for MT (GIC_VPEi_CTL) or
+#define FDC_ROUTABLE 4
+#define FDC_ROUTABLE_S 1
+#define SWINT_ROUTABLE 3
+#define SWINT_ROUTABLE_S 1
+#define PERFCOUNT_ROUTABLE 2
+#define PERFCOUNT_ROUTABLE_S 1
+#define TIMER_ROUTABLE 1
+#define TIMER_ROUTABLE_S 1
+#define EIC_MODE 0
+#define EIC_MODE_S 1
+
+// Bit  fields for Local Interrupt Pending Registers (GIC_COREi_PEND) or for MT (GIC_VPEi_PEND)
+#define FDC_PEND 6
+#define FDC_PEND_S 1
+#define SWINT1_PEND 5
+#define SWINT1_PEND_S 1
+#define SWINT0_PEND 4
+#define SWINT0_PEND_S 1
+#define PERFCOUNT_PEND 3
+#define PERFCOUNT_PEND_S 1
+#define TIMER_PEND 2
+#define TIMER_PEND_S 1
+#define COMPARE_PEND 1
+#define COMPARE_PEND_S 1
+#define WD_PEND 0
+#define WD_PEND_S 1
+
+// Bit fields for Local Interrupt Mask Registers (GIC_COREi_MASK) or for MT (GIC_VPEi_MASK)
+#define FDC_MASK 6
+#define FDC_MASK_S 1
+#define SWINT1_MASK 5
+#define SWINT1_MASK_S 1
+#define SWINT0_MASK 4
+#define SWINT0_MASK_S 1
+#define PERFCOUNT_MASK 3
+#define PERFCOUNT_MASK_S 1
+#define TIMER_MASK 2
+#define TIMER_MASK_S 1
+#define COMPARE_MASK 1
+#define COMPARE_MASK_S 1
+#define WD_MASK 0
+#define WD_MASK_S 1
+
+// Bit fields for Local Interrupt Reset Mask Registers (GIC_COREi_RMASK) or for MT (GIC_VPEi_RMASK)
+#define FDC_MASK_RESET 6
+#define FDC_MASK_RESET_S 1
+#define SWINT1_MASK_RESET 5
+#define SWINT1_MASK_RESET_S 1
+#define SWINT0_MASK_RESET 4
+#define SWINT0_MASK_RESET_S 1
+#define PERFCOUNT_MASK_RESET 3
+#define PERFCOUNT_MASK_RESET_S 1
+#define TIMER_MASK_RESET 2
+#define TIMER_MASK_RESET_S 1
+#define COMPARE_MASK_RESET 1
+#define COMPARE_MASK_RESET_S 1
+#define WD_MASK_RESET 0
+#define WD_MASK_RESET_S 1
+
+// Bit fields for Local Interrupt Set Mask Registers (GIC_COREi_SMASK) or for MT (GIC_VPEi_SMASK)
+#define FDC_MASK_SET 6
+#define FDC_MASK_SET_S 1
+#define SWINT1_MASK_SET 5
+#define SWINT1_MASK_SET_S 1
+#define SWINT0_MASK_SET 4
+#define SWINT0_MASK_SET_S 1
+#define PERFCOUNT_MASK_SET 3
+#define PERFCOUNT_MASK_SET_S 1
+#define TIMER_MASK_SET 2
+#define TIMER_MASK_SET_S 1
+#define COMPARE_MASK_SET 1
+#define COMPARE_MASK_SET_S 1
+#define WD_MASK_SET 0
+#define WD_MASK_SET_S 1
+
+// Bit fields for CORE-Other or for MT VPE-Other Addressing Register
+#define VPENum 0
+#define VPENum_S 16
+#define CORENum 0
+#define CORENum_S 16
+
+// Bit fields for Core-Local Identification Register (GIC_COREi_IDENT) or for MT (GIC_VPEi_IDENT)
+#define VPENumIDENT 0
+#define VPENumIDENT_S 32
+#define CORENumIDENT 0
+#define CORENumIDENT_S 32
+
+// Bit fields for Local EIC Shadow Set Registers (GIC_COREi_EICSSj) or for MT (GIC_VPEi_EICSSj)
+#define EIC_SS 0
+#define EIC_SS_S 4
+
+// Bit fields for Local WatchDog/Compare/PerfCount/SWIntx Map to Pin Registers
+#define MAP_TO_PIN 31
+#define MAP_TO_PIN_S 1
+#define MAP_TO_NMI 30
+#define MAP_TO_NMI_S 1
+#define MAP_TO_YQ 29
+#define MAP_TO_YQ_S 1
+#define MAP 0
+#define MAP_S 6
+
+// Bit fields for Watchdog Timer Config Register (GIC_COREi_WD_CONFIGk) or for MT (GIC_VPEi_WD_CONFIGk)
+#define WDRESET 7
+#define WDRESET_S 1
+#define WDINTR 6
+#define WDINTR_S 1
+#define WAITMODE_CNTRL 5
+#define WAITMODE_CNTRL_S 1
+#define DEBUGMODE_CNTRL 5
+#define DEBUGMODE_CNTRL_S 1
+#define TYPE 1
+#define TYPE_S 3
+// TYPE Filed encoding:
+#define WD_One_Trip_Mode 0
+#define WD_Second_Countdown_Mode 1
+#define PIT_Mode 2
+
+// Bit fields for Local DINT Group Participate Register (GIC_Cx_DINT_PART) or for MT (GIC_Vx_DINT_PART)
+#define DINT_Group_Particpate 0
+#define DINT_Group_Particpate_S 1
+
+// GIC, GIC User Mode Visible Section Offsets
+#define USER_MODE_VISIBLE_SECTION_OFFSET 0x10000
+#define GIC_SH_COUNTERLO 0x0000
+#define GIC_SH_COUNTERHI 0x0004
+
+// Cluster Power Controller Global Section
+// CPC Block CPC_ACCESS_REG, fields and sizes
+#define CPC_ACCESS_REG 0x000
+#define CM_ACCESS_EN 0
+#define CM_ACCESS_EN_S 8
+
+// CPC Block CPC_SEQDEL_REG, fields and sizes
+#define CPC_SEQDEL_REG 0x008
+#define MICROSTEP 0
+#define MICROSTEP_S 10
+
+// CPC Block CPC_RAIL_REG, fields and sizes
+#define CPC_RAIL_REG 0x010
+#define RAILDELAY 0
+#define RAILDELAY_S 10
+
+// CPC Block CPC_RESETLEN_REG, fields and sizes
+#define CPC_RESETLEN_REG 0x018
+#define RESETLEN 0
+#define RESETLEN_S 10
+
+// CPC Block CPC_REVISION_REG, fields and sizes
+#define CPC_REVISION_REG 0x020
+#define MAJOR_REV_CPC 8
+#define MAJOR_REV_CPC_S 8
+#define MINOR_REV_CPC 0
+#define MINOR_REV_CPC_S 8
+
+// Cluster Power Controller Local and Other section
+#define CPS_CORE_LOCAL_CONTROL_BLOCK 0x2000
+#define CPS_CORE_OTHER_CONTROL_BLOCK 0x4000
+
+// CPC Local and Other CPC_CMD_REG, command encoding
+#define CPC_CMDL_REG 0x000
+#define CPC_CMDO_REG 0x000
+#define CLOCK_OFF 1
+#define PWR_DOWN 2
+#define PWR_UP 3
+#define CPC_RESET 4
+
+// CPC Local and Other CPC_STAT_CONF, fields, sizes and encodings
+#define CPC_STATL_CONF_REG 0x008
+#define CPC_STATO_CONF_REG 0x008
+#define PWRUP_EVENT 23
+#define PWRUP_EVENT_S 1
+#define SEQ_STATE 19
+#define SEQ_STATE_S 4
+
+// sequencer state encodings
+#define PWR_DOWN_STATE 0x0
+#define VDD_OK_STATE 0x1
+#define UP_DELAY_STATE 0x2
+#define UCLK_OFF_STATE 0x3
+#define CPC_RESET_STATE 0x4
+#define CPC_RESET_DLY_STATE 0x5
+#define NON_COHERENT_EXECUTION_STATE 0x6
+#define COHERENT_EXECUTION_STATE 0x7
+#define ISOLATE_STATE 0x8
+#define CLR_BUS_STATE 0x8
+#define DCLK_OFF_STATE 0xA
+
+#define CLKGAT_IMPL 17
+#define CLKGAT_IMPL_S 1
+#define PWRDN_IMPL 16
+#define PWRDN_IMPL_S 1
+#define EJTAG_PROBE 15
+#define EJTAG_PROBE_S 1
+#define PWUP_POLICY 8
+#define PWUP_POLICY_S 2
+// Power up state encodings
+#define POLICY_PWR_DOWN 0
+#define POLICY_GO_CLOCK_OFF 1
+#define PLOICY_PWR_UP 2
+
+#define IO_TRFFC_EN 4
+#define IO_TRFFC_EN_S 1
+#define CPC_CMD_STATE 0
+#define CPC_CMD_STATE_S 4
+
+// CPC Local and Other Addressing Register CPC_OTHER_REG, field and size
+#define CPC_OTHERL_REG 0x010
+#define CPC_OTHERO_REG 0x010
+#define CPC_CORENUM 16
+#define CPC_CORENUM_S 8
+
+
+#endif /* CPS_H_ */
diff --git a/arch/mips/include/asm/cpu.h b/arch/mips/include/asm/cpu.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/cpu.h
@@ -0,0 +1,34 @@
+
+/*
+ * FPU implementation/revision register (CP1 control register 0).
+ *
+ * +---------------------------------+----------------+----------------+
+ * | 0                   | Implementation | Revision       |
+ * +---------------------------------+----------------+----------------+
+ *  31                 16 15         8 7          0
+ */
+
+/*
+ * These are the PRID's for when 23:16 == PRID_COMP_MIPS
+ */
+
+#define CPU_4KC        0x80
+#define CPU_5KC        0x81
+#define CPU_20KC       0x82
+#define CPU_4KECR1     0x84
+#define CPU_4KSC       0x86
+#define CPU_25KF       0x88
+#define CPU_5KE        0x89
+#define CPU_4KEC       0x90
+#define CPU_4KEMPR2    0x91
+#define CPU_4KSD       0x92
+#define CPU_24K        0x93
+#define CPU_34K        0x95
+#define CPU_24KE       0x96
+#define CPU_74K        0x97
+#define CPU_1004K      0x99
+#define CPU_1074K      0x9a
+#define CPU_M14KC      0x9c
+#define CPU_M14KEC     0x9e
+#define CPU_INTERAPTIV 0xa1
+
diff --git a/arch/mips/include/asm/lq_dma.h b/arch/mips/include/asm/lq_dma.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/lq_dma.h
@@ -0,0 +1,337 @@
+typedef struct
+{
+    union
+    {
+        struct
+        {
+            volatile u32 OWN                 :1;
+            volatile u32 C                   :1;
+            volatile u32 Sop                 :1;
+            volatile u32 Eop             :1;
+            volatile u32 reserved        :3;
+            volatile u32 Byteoffset      :2;
+            volatile u32 reserve             :7;
+            volatile u32 DataLen             :16;
+        }field;
+
+        volatile u32 word;
+    }status;
+
+    volatile u32 DataPtr;
+} dma_rx_descriptor_t;
+
+typedef struct
+{
+    union
+    {
+        struct
+        {
+            volatile u32 OWN                 :1;
+            volatile u32 C                   :1;
+            volatile u32 Sop                 :1;
+            volatile u32 Eop             :1;
+            volatile u32 Byteoffset      :5;
+            volatile u32 reserved            :7;
+            volatile u32 DataLen             :16;
+        }field;
+
+        volatile u32 word;
+    }status;
+
+    volatile u32 DataPtr;
+} dma_tx_descriptor_t;
+#ifdef CONFIG_DRIVER_GRX500
+#define DMA_PKT_SIZE_DEFAULT    2048
+
+#define DMA_TX_PORT_DEFAULT_WEIGHT  1
+/** Default Port Transmit weight value */
+#define DMA_TX_CHAN_DEFAULT_WEIGHT  1
+
+#define MAX_DMA_CHAN_PER_PORT   64
+#define MAX_DMA_PORT_PER_CTRL   4
+#define MAX_DMA_CONTROLLER  7 
+
+#define DMA0_MAX_CHAN       16
+#define DMA1TX_MAX_CHAN     16
+#define DMA1RX_MAX_CHAN     32
+#define DMA2TX_MAX_CHAN     16
+#define DMA2RX_MAX_CHAN     32
+#define DMA3_MAX_CHAN       64
+#define DMA4_MAX_CHAN       16
+
+#define DMA0_IRQ        64
+#define DMA1TX_IRQ      65
+#define DMA1RX_IRQ      66
+#define DMA2TX_IRQ      67
+#define DMA2RX_IRQ      68
+#define DMA3_IRQ        69
+#define DMA4_IRQ        70
+
+#define DMA0_PORTS      4
+#define DMA_DEFAULT_PORTS   1
+
+typedef enum {
+    DMA_CLASS_0 = 0,
+    DMA_CLASS_1,
+    DMA_CLASS_2,
+    DMA_CLASS_3,
+    DMA_CLASS_4,
+    DMA_CLASS_5,
+    DMA_CLASS_6,
+    DMA_CLASS_7,
+    DMA_CLASS_8,
+    DMA_CLASS_9,
+    DMA_CLASS_10,
+    DMA_CLASS_11,
+    DMA_CLASS_12,
+    DMA_CLASS_13,
+    DMA_CLASS_14,
+    DMA_CLASS_15,
+    DMA_CLASS_16,
+    DMA_CLASS_17,
+    DMA_CLASS_18,
+    DMA_CLASS_19,
+    DMA_CLASS_20,
+    DMA_CLASS_21,
+    DMA_CLASS_22,
+    DMA_CLASS_23,
+    DMA_CLASS_24,
+    DMA_CLASS_25,
+    DMA_CLASS_26,
+    DMA_CLASS_27,
+    DMA_CLASS_28,
+    DMA_CLASS_29,
+    DMA_CLASS_30,
+    DMA_CLASS_31,
+} dma_class_t;
+
+#define DMA_CLASS_MAX       DMA_CLASS_31
+#define DMA_CLASS_LOW_MAX   DMA_CLASS_7
+
+/* bit 18~19 for high class value not defined yet*/
+
+typedef enum {
+    DMA_ENDIAN_TYPE0 = 0,
+    DMA_ENDIAN_TYPE1,   /*!< Byte Swap(B0B1B2B3 => B1B0B3B2) */
+    DMA_ENDIAN_TYPE2,   /*!< Word Swap (B0B1B2B3 => B2B3B0B1) */
+    DMA_ENDIAN_TYPE3,   /*!< DWord Swap (B0B1B2B3 => B3B2B1B0) */
+    DMA_ENDIAN_MAX,
+} dma_endian_t;
+
+#ifdef CONFIG_BIG_ENDIAN
+#define DMA_ENDIAN_DEFAULT  DMA_ENDIAN_TYPE3
+#else
+#define DMA_ENDIAN_DEFAULT  DMA_ENDIAN_TYPE0
+#endif
+
+typedef enum {
+    DMA_BURSTL_2DW = 1, /*!< 2 DWORD DMA burst length */
+    DMA_BURSTL_4DW = 2, /*!< 4 DWORD DMA burst length */
+    DMA_BURSTL_8DW = 3, /*!< 8 DWORD DMA burst length */
+    DMA_BURSTL_16DW = 16,
+} dma_burst_len_t;
+
+#define DMA_BURSTL_DEFAULT  DMA_BURSTL_16DW
+
+typedef enum {
+    DMA_CH_OFF = 0, /*!< DMA channel is OFF */
+    DMA_CH_ON = 1,  /*!< DMA channel is ON */
+} dma_channel_on_off_t;
+
+typedef enum {
+    DMA_RX_CH = 0,  /*!< Rx channel */
+    DMA_TX_CH = 1,  /*!< Tx channel */
+} dma_chan_dir_t;
+
+enum {
+    DMA_PKT_DROP_DISABLE = 0,
+    DMA_PKT_DROP_ENABLE,
+};
+
+#define DMA_FLUSH_MEMCPY        1
+#define DMA_CHAN_RST            1
+
+enum {
+    DMA_CHAN_GLOBAL_POLLING_DIS = 0,
+    DMA_CHAN_GLOBAL_POLLING_EN,
+};
+
+enum {
+    DMA_PORT_TXWGT0 = 0,
+    DMA_PORT_TXWGT1 ,
+    DMA_PORT_TXWGT2 ,
+    DMA_PORT_TXWGT3 ,
+    DMA_PORT_TXWGT4 ,
+    DMA_PORT_TXWGT5 ,
+    DMA_PORT_TXWGT6 ,
+    DMA_PORT_TXWGT7 ,
+    DMA_PORT_TXWGTMAX,
+};
+
+enum {
+    DMA_CHAN_TXWGT0 = 0,
+    DMA_CHAN_TXWGT1,
+    DMA_CHAN_TXWGT2,
+    DMA_CHAN_TXWGT3,
+    DMA_CHAN_TXWGTMAX,
+};
+
+enum {
+    DMA_ARB_BURST = 0,
+    DMA_ARB_MUL_BURST,
+    DMA_ARB_PKT,
+};
+
+#define DMA_CHAN_GLOBAL_POLLING_DEFAULT_INTERVAL    16
+
+/* Interrupt related definition */
+#define DMA_CIE_EOP     0x00000002
+/** Descriptor Under-Run Interrupt enable  */
+#define DMA_CIE_DUR     0x00000004
+/** Descriptor Complete Interrupt  enable*/
+#define DMA_CIE_DESCPT      0x00000008
+/** Channel Off Interrupt enable */
+#define DMA_CIE_CHOFF       0x00000010
+/** SAI Read Error Interrupt enable*/
+#define DMA_CIE_RDERR       0x00000020
+
+
+#define DMA_CIE_ALL (DMA_CIE_EOP | DMA_CIE_DUR | DMA_CIE_DESCPT| \
+            DMA_CIE_CHOFF | DMA_CIE_RDERR)
+
+#define DMA_CIE_DEFAULT (DMA_CIE_EOP | DMA_CIE_DESCPT)
+
+/* Four DWs desriptor format */
+typedef struct {
+    union {
+        struct {
+            volatile u32 session_id     :12;
+            volatile u32 tcp_err        :1;
+            volatile u32 nat        :1;
+            volatile u32 dec        :1;
+            volatile u32 enc        :1;
+            volatile u32 mpe2       :1;
+            volatile u32 mpe1       :1;
+            volatile u32 color      :2;
+            volatile u32 ep         :4;
+            volatile u32 resv       :4;
+            volatile u32 cla        :4;
+        }field;
+        volatile u32 all;
+    }DW1;
+    union {
+        struct {
+            volatile u32 resv       :3;
+            volatile u32 tunnel_id      :4;
+            volatile u32 flow_id        :8;
+            volatile u32 eth_type       :2;
+            volatile u32 dest_id        :15;
+        }field;
+        volatile u32 all;
+    }DW0;
+    union {
+        struct {
+        volatile u32 own        :1;
+        volatile u32 c          :1;
+        volatile u32 sop        :1;
+        volatile u32 eop        :1;
+        volatile u32 dic        :1;
+        volatile u32 pdu        :1;
+        volatile u32 byteoffset     :3;
+        volatile u32 vdsl_wan       :7;
+        volatile u32 datalen        :16;
+        }field;
+        volatile u32 all;
+    }DW3;
+    union {
+        struct {
+            volatile u32 address    :32;
+        }field;
+        volatile u32 all;
+    }DW2;
+} _dma_rx_descriptor_t;
+
+typedef struct {
+    union {
+        struct {
+            volatile u32 session_id     :12;
+            volatile u32 tcp_err        :1;
+            volatile u32 nat        :1;
+            volatile u32 dec        :1;
+            volatile u32 enc        :1;
+            volatile u32 mpe2       :1;
+            volatile u32 mpe1       :1;
+            volatile u32 color      :2;
+            volatile u32 ep         :4;
+            volatile u32 resv       :4;
+            volatile u32 cla        :4;
+        }field;
+    volatile u32 all;
+    }DW1;
+    union {
+        struct {
+            volatile u32 resv       :3;
+            volatile u32 tunnel_id      :4;
+            volatile u32 flow_id        :8;
+            volatile u32 eth_type       :2;
+            volatile u32 dest_id        :15;
+        }field;
+        volatile u32 all;
+    }DW0;
+    union {
+        struct {
+            volatile u32 own        :1;
+            volatile u32 c          :1;
+            volatile u32 sop        :1;
+            volatile u32 eop        :1;
+            volatile u32 dic        :1;
+            volatile u32 pdu        :1;
+            volatile u32 byteoffset     :3;
+            volatile u32 vdsl_wan       :7;
+            volatile u32 datalen        :16;
+        }field;
+        volatile u32 all;
+    }DW3;
+    union {
+        struct {
+            volatile u32 address        :32;
+        }field;
+    volatile u32 all;
+    }DW2;
+} _dma_tx_descriptor_t;
+
+/* 2 DWs format descriptor */
+struct dma_rx_desc_2dw {
+    union {
+        struct {
+            volatile unsigned int own:1;
+            volatile unsigned int c:1;
+            volatile unsigned int sop:1;
+            volatile unsigned int eop:1;
+            volatile unsigned int reserve_25_27:3;
+            volatile unsigned int byte_offset:2;
+            volatile unsigned int rx_sideband:4;
+            volatile unsigned int reserve16_18:3;
+            volatile unsigned int data_len:16;
+        } field;
+        volatile unsigned int word; 
+    } status;
+    volatile unsigned int data_pointer; /* Descriptor data pointer */
+};
+
+struct dma_tx_desc_2dw {
+    union {
+        struct {
+            volatile unsigned int own:1;
+            volatile unsigned int c:1;
+            volatile unsigned int sop:1;
+            volatile unsigned int eop:1;
+            volatile unsigned int byte_offset:5;
+            volatile unsigned int reserved:7;
+            volatile unsigned int data_len:16;
+        } field;
+        volatile unsigned int word;
+    } status;
+    volatile unsigned int data_pointer; /* Descriptor data pointer */
+};
+#endif
diff --git a/arch/mips/include/asm/ltq_vmb.h b/arch/mips/include/asm/ltq_vmb.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/ltq_vmb.h
@@ -0,0 +1,93 @@
+#ifndef _LTQ_VMB_H
+#define _LTQ_VMB_H
+
+#define MAX_CORE 2 
+#define MAX_VPE 2 
+#define MAX_TC	6
+#define MAX_CPU (MAX_CORE * MAX_VPE)
+
+#define vmb_msg_size (sizeof(VMB_fw_msg_t) + sizeof(FW_vmb_msg_t))
+#define CPU_LAUNCH 0xa0000000
+
+/* REVERT BACK TO 10 */
+#define QUEUE_TIMEOUT (100 * HZ) 
+
+#define get_cpu_id(core, vpe)   ((core * 2) + vpe)
+#define which_core(cpu)         (cpu / 2)
+#define vpe_in_core(cpu)        (cpu % 2)
+
+
+#define VMB_CPU_START	0x00000001
+#define VMB_CPU_STOP	0x00000002
+#define VMB_TC_START	0x00000004
+#define VMB_TC_STOP	0x00000008
+#define VMB_TC_PAUSE	0x00000010
+#define VMB_TC_RESUME	0x00000020
+
+#define FW_VMB_ACK	0x00000001
+#define FW_VMB_NACK	0x00000002
+#define FW_RESET	0x00000004
+#define IBL_IN_WAIT	0x00000008
+#define FW_VMB_PRIV_INFO	0x00000010
+
+typedef struct cpu_launch_t {
+	uint	start_addr;
+	uint	sp;
+	uint	gp;
+	uint	a0;
+	uint	eva;
+	uint	mt_group;
+	uint	priv_info;
+	uint	res;
+}CPU_launch_t; 
+
+typedef struct tc_launch_t {
+	uint	tc_num;
+	uint	mt_group;
+	uint	start_addr;
+	uint	sp;
+	uint	gp;
+	uint	a0;
+	uint	state;
+	uint	priv_info;	
+}TC_launch_t;
+
+typedef struct vmb_fw_msg_t{
+	uint	msg_id;
+	CPU_launch_t	cpu_launch;
+	TC_launch_t	tc_launch[MAX_TC];
+	uint	tc_num;
+} VMB_fw_msg_t;
+
+typedef struct fw_vmb_msg_t{
+	uint	status;
+	uint	priv_info;
+} FW_vmb_msg_t;
+
+#define read_c0_count()         __read_32bit_c0_register($9, 0)
+#define write_c0_count(val)     __write_32bit_c0_register($9, 0, val)
+
+#define read_c0_config()        __read_32bit_c0_register($16, 0)
+
+#define read_c0_ebase()         __read_32bit_c0_register($15, 1)
+
+#define read_c0_status()        __read_32bit_c0_register($12, 0)
+#define read_c0_config7()       __read_32bit_c0_register($16, 7)
+#define write_c0_config7(val)   __write_32bit_c0_register($16, 7, val)
+#define write_c0_sp(val)   __write_32bit_c0_register($29, 0, val)
+#define write_c0_gp(val)   __write_32bit_c0_register($28, 0, val)
+
+
+void r4k_wait_irqoff(void)
+{
+                __asm__ __volatile__(
+                "       .set    push            \n"   \
+                "       .set    noreorder       \n"   \
+                "       .set    mips3\n\t       \n"   \
+                "       wait                    \n"   \
+                "       .set    pop             \n");
+}
+
+
+
+#endif
diff --git a/arch/mips/include/asm/m32c0.h b/arch/mips/include/asm/m32c0.h
new file mode 100755
--- /dev/null
+++ b/arch/mips/include/asm/m32c0.h
@@ -0,0 +1,780 @@
+/*
+ * Copyright (c) 1999-2004 MIPS Technologies, Inc.
+ * All rights reserved.
+ * 
+ * Unpublished rights (if any) reserved under the copyright laws of the
+ * United States of America and other countries.
+ * 
+ * This code is proprietary to MIPS Technologies, Inc. ("MIPS
+ * Technologies").  Any copying, reproducing, modifying or use of
+ * this code (in whole or in part) that is not expressly permitted
+ * in writing by MIPS Technologies or an authorized third party is
+ * strictly prohibited.  At a minimum, this code is protected under
+ * unfair competition and copyright laws.  Violations thereof may result
+ * in criminal penalties and fines.
+ * 
+ * MIPS Technologies reserves the right to change this code to improve
+ * function, design or otherwise.  MIPS Technologies does not assume any
+ * liability arising out of the application or use of this code, or of
+ * any error or omission in such code.  Any warranties, whether express,
+ * statutory, implied or otherwise, including but not limited to the
+ * implied warranties of merchantability or fitness for a particular
+ * purpose, are excluded.  Except as expressly provided in any written
+ * license agreement from MIPS Technologies or an authorized third party,
+ * the furnishing of this code does not give recipient any license to
+ * any intellectual property rights, including any patent rights, that
+ * cover this code.
+ * 
+ * This code shall not be exported, reexported, transferred, or released,
+ * directly or indirectly, in violation of the law of any country or
+ * international law, regulation, treaty, Executive Order, statute,
+ * amendments or supplements thereto.  Should a conflict arise regarding
+ * the export, reexport, transfer, or release of this code, the laws of
+ * the United States of America shall be the governing law.
+ * 
+ * This code constitutes one or more of the following: commercial
+ * computer software, commercial computer software documentation or
+ * other commercial items.  If the user of this code, or any related
+ * documentation of any kind, including related technical data or
+ * manuals, is an agency, department, or other entity of the United
+ * States government ("Government"), the use, duplication, reproduction,
+ * release, modification, disclosure, or transfer of this code, or
+ * any related documentation of any kind, is restricted in accordance
+ * with Federal Acquisition Regulation 12.212 for civilian agencies
+ * and Defense Federal Acquisition Regulation Supplement 227.7202 for
+ * military agencies.  The use of this code by the Government is further
+ * restricted in accordance with the terms of the license agreement(s)
+ * and/or applicable contract terms and conditions covering this code
+ * from MIPS Technologies or an authorized third party.
+ * 
+ * 
+ */
+
+/*
+ * m32c0.h : MIPS32 coprocessor 0 definitions
+ */
+
+
+#ifndef _M32C0_H_
+#define _M32C0_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* MIPS32-specific MMU interface */
+//#assert mmu(m32)
+//#include <mips/m32tlb.h>
+
+/*
+ * MIPS32 Exception Codes
+ */
+#define EXC_INTR	0	/* interrupt */
+#define EXC_MOD		1	/* tlb modification */
+#define EXC_TLBL	2	/* tlb miss (load/i-fetch) */
+#define EXC_TLBS	3	/* tlb miss (store) */
+#define EXC_ADEL	4	/* address error (load/i-fetch) */
+#define EXC_ADES	5	/* address error (store) */
+#define EXC_IBE		6	/* bus error (i-fetch) */
+#define EXC_DBE		7	/* data bus error (load/store) */
+#define EXC_SYS		8	/* system call */
+#define EXC_BP		9	/* breakpoint */
+#define EXC_RI		10	/* reserved instruction */
+#define EXC_CPU		11	/* coprocessor unusable */
+#define EXC_OVF		12	/* integer overflow */
+#define EXC_TRAP	13	/* trap exception */
+#define EXC_RES14	14
+#define EXC_FPE		15	/* floating point exception */
+#define EXC_IS1		16	/* implementation-specific 1 */
+#define EXC_IS2		17	/* implementation-specific 2 */
+#define EXC_C2E		18	/* coprocessor 2 exception */
+#define EXC_RES19	19
+#define EXC_RES20	20
+#define EXC_RES21	21
+#define EXC_MDMX	22	/* mdmx unusable */
+#define EXC_WATCH	23	/* watchpoint */
+#define EXC_MCHECK	24	/* machine check */
+#define EXC_THREAD	25	/* thread */
+#define EXC_DSPU	26	/* dsp unusable */
+#define EXC_RES27	27
+#define EXC_RES28	28
+#define EXC_RES29	29
+#define EXC_RES30	30
+#define EXC_RES31	31
+
+
+/*
+ * MIPS32 Cause Register (CP0 Register 13, Select 0)
+ */
+#define CR_BD		0x80000000	/* branch delay */
+#define CR_TI		0x40000000	/* timer interrupt (r2) */
+#define CR_CEMASK	0x30000000      /* coprocessor used */
+#define CR_CESHIFT	28
+#define CR_DC		0x08000000	/* disable count (r2) */
+#define CR_PCI		0x04000000	/* performance counter i/u (r2) */
+#define CR_IV		0x00800000	/* use special i/u vec */
+#define CR_WP		0x00400000	/* deferred watchpoint */
+
+/* interrupt pending bits */
+#define CR_SINT0	0x00000100 	/* s/w interrupt 0 */
+#define CR_SINT1	0x00000200	/* s/w interrupt 1 */
+#define CR_HINT0	0x00000400	/* h/w interrupt 0 */
+#define CR_HINT1	0x00000800	/* h/w interrupt 1 */
+#define CR_HINT2	0x00001000	/* h/w interrupt 2 */
+#define CR_HINT3	0x00002000	/* h/w interrupt 3 */
+#define CR_HINT4	0x00004000	/* h/w interrupt 4 */
+#define CR_HINT5	0x00008000	/* h/w interrupt 5 */
+
+/* alternative interrupt pending bit naming */
+#define CR_IP0		0x00000100
+#define CR_IP1		0x00000200
+#define CR_IP2		0x00000400
+#define CR_IP3		0x00000800
+#define CR_IP4		0x00001000
+#define CR_IP5		0x00002000
+#define CR_IP6		0x00004000
+#define CR_IP7		0x00008000
+
+#define CR_IMASK	0x0000ff00 	/* interrupt pending mask */
+#define CR_XMASK	0x0000007c 	/* exception code mask */
+#define CR_XCPT(x)	((x)<<2)
+
+
+/*
+ * MIPS32 Status Register  (CP0 Register 12, Select 0)
+ */
+#define SR_IE		0x00000001 	/* interrupt enable */
+#define SR_EXL		0x00000002	/* exception level */
+#define SR_ERL		0x00000004	/* error level */
+
+#define SR_UM		0x00000010	/* user mode */
+#define SR_KSU_MASK	0x00000018	/* ksu mode mask */
+#define SR_KSU_USER	0x00000010	/* user mode */
+#define SR_KSU_SPVS	0x00000008	/* supervisor mode */
+#define SR_KSU_KERN	0x00000000	/* kernel mode */
+
+/* interrupt mask bits */
+#define SR_SINT0	0x00000100	/* enable s/w interrupt 0 */
+#define SR_SINT1	0x00000200	/* enable s/w interrupt 1 */
+#define SR_HINT0	0x00000400	/* enable h/w interrupt 1 */
+#define SR_HINT1	0x00000800	/* enable h/w interrupt 2 */
+#define SR_HINT2	0x00001000	/* enable h/w interrupt 3 */
+#define SR_HINT3	0x00002000	/* enable h/w interrupt 4 */
+#define SR_HINT4	0x00004000	/* enable h/w interrupt 5 */
+#define SR_HINT5	0x00008000	/* enable h/w interrupt 6 */
+
+/* alternative interrupt mask naming */
+#define SR_IM0		0x00000100
+#define SR_IM1		0x00000200
+#define SR_IM2		0x00000400
+#define SR_IM3		0x00000800
+#define SR_IM4		0x00001000
+#define SR_IM5		0x00002000
+#define SR_IM6		0x00004000
+#define SR_IM7		0x00008000
+
+#define SR_IMASK	0x0000ff00
+
+#define SR_NMI		0x00080000 	/* NMI occurred */
+#define SR_SR		0x00100000	/* soft reset occurred */
+#define SR_TS		0x00200000	/* TLB shutdown */
+#define SR_BEV		0x00400000	/* boot exception vectors */
+#define SR_PX		0x00800000	/* user 64-bit reg / 32-bit addr */
+#define SR_MX		0x01000000	/* enable MDMX ASE */
+#define SR_RE		0x02000000	/* reverse endian (user mode) */
+#define SR_FR		0x04000000	/* 64-bit fpu registers */
+#define SR_RP		0x08000000	/* reduce power */
+
+#define SR_CU0		0x10000000	/* coprocessor 0 enable */
+#define SR_CU1		0x20000000	/* coprocessor 1 enable */
+#define SR_CU2		0x40000000	/* coprocessor 2 enable */
+#define SR_CU3		0x80000000	/* coprocessor 3 enable */
+
+
+/*
+ * MIPS32r2 HWREna Register  (CP0 Register 7, Select 0)
+ */
+#define HWRENA_CPUNUM	0x00000001
+#define HWRENA_SYNCSTEP	0x00000002
+#define HWRENA_CC	0x00000004
+#define HWRENA_CCRES	0x00000008
+
+/*
+ * MIPS32r2 IntCtl Register  (CP0 Register 12, Select 1)
+ */
+#define INTCTL_IPTI	0xe0000000	/* timer i/u pending bit */
+#define  INTCTL_IPTI_SHIFT	29
+#define INTCTL_IPPCI	0x1c000000	/* perfctr i/u pending bit */
+#define  INTCTL_IPPCI_SHIFT	26
+#define INTCTL_VS	0x000003e0	/* vector spacing */
+#define  INTCTL_VS_0		(0x00<<5)
+#define  INTCTL_VS_32		(0x01<<5)
+#define  INTCTL_VS_64		(0x02<<5)
+#define  INTCTL_VS_128		(0x04<<5)
+#define  INTCTL_VS_256		(0x08<<5)
+#define  INTCTL_VS_512		(0x10<<5)
+
+/*
+ * MIPS32r2 SRSCtl Register  (CP0 Register 12, Select 2)
+ */
+#define SRSCTL_HSS	0x3c000000	/* highest shadow set */
+#define  SRSCTL_HSS_SHIFT	26
+#define SRSCTL_EICSS	0x003c0000	/* EIC shadow set */
+#define  SRSCTL_EICSS_SHIFT	18
+#define SRSCTL_ESS	0x0000f000	/* exception shadow set */
+#define  SRSCTL_ESS_SHIFT	12
+#define SRSCTL_PSS	0x000003c0	/* previous shadow set */
+#define  SRSCTL_PSS_SHIFT	 6
+#define SRSCTL_CSS	0x0000000f	/* current shadow set */
+#define  SRSCTL_CSS_SHIFT	 0
+
+/*
+ * MIPS32 Config0 Register  (CP0 Register 16, Select 0)
+ */
+#define CFG0_M		0x80000000	/* Config1 implemented */
+#define CFG0_BE		0x00008000	/* Big Endian */
+#define CFG0_ATMASK	0x00006000	/* Architecture type: */
+#define  CFG0_AT_M32	 (0<<13)	 /* MIPS32 */
+#define  CFG0_AT_M64_A32 (1<<13)	 /* MIPS64, 32-bit addresses */
+#define  CFG0_AT_M64_A64 (2<<13)	 /* MIPS64, 64-bit addresses */
+#define  CFG0_AT_RES	 (3<<13)
+#define CFG0_ARMASK	0x00001c00
+#define CFG0_ARSHIFT	10
+#define CFG0_MTMASK	0x00000380
+#define  CFG0_MT_NONE	 (0<<7)
+#define  CFG0_MT_TLB	 (1<<7)
+#define  CFG0_MT_BAT	 (2<<7)
+#define  CFG0_MT_NONSTD	 (3<<7)
+#define CFG0_VI		0x00000008	/* Icache is virtual */
+#define CFG0_K0MASK	0x00000007	/* KSEG0 coherency algorithm */
+
+/*
+ * R4000 compatibility Config Register (actually processor dependent)
+ */
+#define CFG_BE		CFG0_BE		/* Big Endian */
+#define CFG_K0MASK	CFG0_K0MASK	/* KSEG0 coherency algorithm */
+
+/*
+ * MIPS32 Config1 Register (CP0 Register 16, Select 1)
+ */
+#define CFG1_M		0x80000000	/* Config2 implemented */
+#define CFG1_MMUSMASK	0x7e000000	/* mmu size - 1 */
+#define CFG1_MMUSSHIFT	25
+#define CFG1_ISMASK	0x01c00000	/* icache lines 64<<n */
+#define CFG1_ISSHIFT	22
+#define CFG1_ILMASK	0x00380000	/* icache line size 2<<n */
+#define CFG1_ILSHIFT	19
+#define CFG1_IAMASK	0x00070000	/* icache ways - 1 */
+#define CFG1_IASHIFT	16
+#define CFG1_DSMASK	0x0000e000	/* dcache lines 64<<n */
+#define CFG1_DSSHIFT	13
+#define CFG1_DLMASK	0x00001c00	/* dcache line size 2<<n */
+#define CFG1_DLSHIFT	10
+#define CFG1_DAMASK	0x00000380	/* dcache ways - 1 */
+#define CFG1_DASHIFT	7
+#define CFG1_C2		0x00000040	/* Coprocessor 2 present */
+#define CFG1_MD		0x00000020	/* MDMX implemented */
+#define CFG1_PC		0x00000010	/* performance counters implemented */
+#define CFG1_WR		0x00000008	/* watch registers implemented */
+#define CFG1_CA		0x00000004	/* compression (mips16) implemented */
+#define CFG1_EP		0x00000002	/* ejtag implemented */
+#define CFG1_FP		0x00000001	/* fpu implemented */
+
+
+/*
+ * MIPS32r2 Config2 Register (CP0 Register 16, Select 2)
+ */
+#define CFG2_M		0x80000000	/* Config3 implemented */
+#define CFG2_TUMASK	0x70000000	/* tertiary cache control */
+#define CFG2_TUSHIFT	28
+#define CFG2_TSMASK	0x0f000000	/* tcache sets per wway 64<<n */
+#define CFG2_TSSHIFT	24
+#define CFG2_TLMASK	0x00f00000	/* tcache line size 2<<n */
+#define CFG2_TLSHIFT	20
+#define CFG2_TAMASK	0x000f0000	/* tcache ways - 1 */
+#define CFG2_TASHIFT	16
+#define CFG2_SUMASK	0x0000f000	/* secondary cache control */
+#define CFG2_SUSHIFT	12
+#define CFG2_SSMASK	0x00000f00	/* scache sets per wway 64<<n */
+#define CFG2_SSSHIFT	8
+#define CFG2_SLMASK	0x000000f0	/* scache line size 2<<n */
+#define CFG2_SLSHIFT	4
+#define CFG2_SAMASK	0x0000000f	/* scache ways - 1 */
+#define CFG2_SASHIFT	0
+
+/*
+ * MIPS32r2 Config2 Register (CP0 Register 16, Select 3)
+ */
+#define CFG3_M		0x80000000	/* Config4 implemented */
+#define CFG3_DSPP	0x00000400	/* DSP ASE present */
+#define CFG3_LPA	0x00000080	/* Large physical addresses */
+#define CFG3_VEIC	0x00000040	/* Vectored external i/u controller */
+#define CFG3_VI		0x00000020	/* Vectored i/us */
+#define CFG3_SP		0x00000010	/* Small page support */
+#define CFG3_MT		0x00000004	/* MT ASE present */
+#define CFG3_SM		0x00000002	/* SmartMIPS ASE */
+#define CFG3_TL		0x00000001	/* Trace Logic */
+
+
+/*
+ * Primary cache mode
+ */
+#define CFG_C_UNCACHED		2
+#define CFG_C_WBACK		3
+#define CFG_C_NONCOHERENT	3
+
+#if 0
+/* These cache modes are CPU specific */
+#define CFG_C_WTHRU_NOALLOC	0
+#define CFG_C_WTHRU_ALLOC	1
+#define CFG_C_COHERENTXCL	4
+#define CFG_C_COHERENTXCLW	5 	
+#define CFG_C_COHERENTUPD	6
+#define CFG_C_UNCACHED_ACCEL	7
+#endif
+
+
+/* 
+ * Primary Cache TagLo (CP0 Register 28, Select 0/2)
+ */
+#define TAG_PTAG_MASK           0xffffff00      /* Primary Tag */
+#define TAG_PTAG_SHIFT          8
+#define TAG_PSTATE_MASK         0x000000c0      /* Primary Cache State */
+#define TAG_PSTATE_SHIFT        6
+#define TAG_PSTATE_LOCK		0x00000020
+#define TAG_PARITY_MASK         0x00000001      /* Primary Tag Parity */
+#define TAG_PARITY_SHIFT        0
+
+/* primary cache state (XXX actually implementation specific) */
+#define PSTATE_INVAL		0
+#define PSTATE_SHARED		1
+#define PSTATE_CLEAN_EXCL	2
+#define PSTATE_DIRTY_EXCL	3
+
+
+/*
+ * Cache operations
+ */
+#define Index_Invalidate_I               0x00        /* 0       0 */
+#define Index_Writeback_Inv_D            0x01        /* 0       1 */
+#define Index_Writeback_Inv_T            0x02        /* 0       2 */
+#define Index_Writeback_Inv_S            0x03        /* 0       3 */
+#define Index_Load_Tag_I                 0x04        /* 1       0 */
+#define Index_Load_Tag_D                 0x05        /* 1       1 */
+#define Index_Load_Tag_T                 0x06        /* 1       2 */
+#define Index_Load_Tag_S                 0x07        /* 1       3 */
+#define Index_Store_Tag_I                0x08        /* 2       0 */
+#define Index_Store_Tag_D                0x09        /* 2       1 */
+#define Index_Store_Tag_T                0x0A        /* 2       2 */
+#define Index_Store_Tag_S                0x0B        /* 2       3 */
+#define Hit_Invalidate_I                 0x10        /* 4       0 */
+#define Hit_Invalidate_D                 0x11        /* 4       1 */
+#define Hit_Invalidate_T                 0x12        /* 4       2 */
+#define Hit_Invalidate_S                 0x13        /* 4       3 */
+#define Fill_I                           0x14        /* 5       0 */
+#define Hit_Writeback_Inv_D              0x15        /* 5       1 */
+#define Hit_Writeback_Inv_T              0x16        /* 5       2 */
+#define Hit_Writeback_Inv_S              0x17        /* 5       3 */
+#define Hit_Writeback_D                  0x19        /* 6       1 */
+#define Hit_Writeback_T                  0x1A        /* 6       1 */
+#define Hit_Writeback_S                  0x1B        /* 6       3 */
+#define Fetch_Lock_I                 	 0x1C        /* 7       0 */
+#define Fetch_Lock_D                 	 0x1D        /* 7       1 */
+
+/* MIPS32 WatchLo Register (CP0 Register 18) */
+#define WATCHLO_VA		0xfffffff8
+#define WATCHLO_I		0x00000004
+#define WATCHLO_R		0x00000002
+#define WATCHLO_W		0x00000001
+
+/* MIPS32 WatchHi Register (CP0 Register 19) */
+#define WATCHHI_M		0x80000000
+#define WATCHHI_G		0x40000000
+#define WATCHHI_ASIDMASK	0x00ff0000
+#define WATCHHI_ASIDSHIFT	16
+#define WATCHHI_MASK		0x00000ffc
+#define WATCHHI_I		0x00000004
+#define WATCHHI_R		0x00000002
+#define WATCHHI_W		0x00000001
+
+/* MIPS32 PerfCnt Register (CP0 Register 25) */
+#define PERFCNT_M		0x80000000
+#define PERFCNT_EVENTMASK	0x000007e0
+#define PERFCNT_EVENTSHFT	5
+#define PERFCNT_IE		0x00000010
+#define PERFCNT_U		0x00000008
+#define PERFCNT_S		0x00000004
+#define PERFCNT_K		0x00000002
+#define PERFCNT_EXL		0x00000001
+
+/* MIPS32r2 PageGrain  Register (CP0 Register 5, Select 1) */
+#define PAGEGRAIN_ELPA	0x20000000	/* Enable large phusical addresses */
+#define PAGEGRAIN_ESP	0x10000000	/* Enable small (1KB) page support */
+
+/* MIPS32r2 EBase  Register (CP0 Register 15, Select 1) */
+#define EBASE_BASE	0xfffff000	/* Exception base */
+#define EBASE_CPU	0x000003ff	/* CPU number */
+
+#ifdef __ASSEMBLER__
+
+/* 
+ * MIPS32 Coprocessor 0 register numbers 
+ */
+#define C0_INDEX	$0
+#define C0_INX		$0
+#define C0_RANDOM	$1
+#define C0_RAND		$1
+#define C0_ENTRYLO0	$2
+#define C0_TLBLO0	$2
+#define C0_ENTRYLO1	$3
+#define C0_TLBLO1	$3
+#define C0_CONTEXT	$4
+#define C0_CTXT		$4
+#define C0_PAGEMASK	$5
+#define C0_PAGEGRAIN	$5,1
+#define C0_WIRED	$6
+#define C0_HWRENA	$7
+#define C0_BADVADDR 	$8
+#define C0_VADDR 	$8
+#define C0_COUNT 	$9
+#define C0_ENTRYHI	$10
+#define C0_TLBHI	$10
+#define C0_COMPARE	$11
+#define C0_STATUS	$12
+#define C0_SR		$12
+#define C0_INTCTL	$12,1
+#define C0_SRSCTL	$12,2
+#define C0_SRSMAP	$12,3
+#define C0_CAUSE	$13
+#define C0_CR		$13
+#define C0_EPC 		$14
+#define C0_PRID		$15
+#define C0_EBASE	$15,1
+#define C0_CONFIG	$16
+#define C0_CONFIG0	$16,0
+#define C0_CONFIG1	$16,1
+#define C0_CONFIG2	$16,2
+#define C0_CONFIG3	$16,3
+#define C0_LLADDR	$17
+#define C0_WATCHLO	$18
+#define C0_WATCHHI	$19
+#define C0_DEBUG	$23
+#define C0_DEPC		$24
+#define C0_PERFCNT	$25
+#define C0_ERRCTL	$26
+#define C0_CACHEERR	$27
+#define C0_TAGLO	$28
+#define C0_DATALO	$28,1
+#define C0_TAGHI	$29
+#define C0_DATAHI	$29,1
+#define C0_ERRPC	$30
+#define C0_DESAVE	$31
+
+$index		=	$0
+$random		=	$1
+$entrylo0	=	$2
+$entrylo1	=	$3
+$context	=	$4
+$pagemask	=	$5
+$wired		=	$6
+$hwrena		=	$7
+$vaddr 		=	$8
+$badvaddr	=	$8
+$count 		=	$9
+$entryhi	=	$10
+$compare	=	$11
+$sr		=	$12
+$cr		=	$13
+$epc 		=	$14
+$prid		=	$15
+$config		=	$16
+$lladdr		=	$17
+$watchlo	=	$18
+$watchhi	=	$19
+$debug		= 	$23
+$depc		= 	$24
+$perfcnt	= 	$25
+$errctl		=	$26
+$cacheerr	=	$27
+$taglo		=	$28
+$taghi		=	$29
+$errpc		=	$30
+$desave		=	$31
+
+
+#else /* !__ASSEMBLER__ */
+
+/*
+ * Standard types
+ */
+typedef unsigned long		reg32_t;	/* a 32-bit register */
+typedef unsigned long long	reg64_t;	/* a 64-bit register */
+#if __mips == 64 || __mips64
+typedef unsigned long long	reg_t;
+typedef signed long long	sreg_t;
+#else
+typedef unsigned long		reg_t;
+typedef signed long		sreg_t;
+#endif
+
+/* 
+ * MIPS32 Coprocessor 0 register numbers 
+ */
+#define C0_INDEX	0
+#define C0_INX		0
+#define C0_RANDOM	1
+#define C0_RAND		1
+#define C0_ENTRYLO0	2
+#define C0_TLBLO0	2
+#define C0_ENTRYLO1	3
+#define C0_TLBLO1	3
+#define C0_CONTEXT	4
+#define C0_CTXT		4
+#define C0_PAGEMASK	5
+#define C0_WIRED	6
+#define C0_HWRENA	7
+#define C0_BADVADDR 	8
+#define C0_VADDR 	8
+#define C0_COUNT 	9
+#define C0_ENTRYHI	10
+#define C0_TLBHI	10
+#define C0_COMPARE	11
+#define C0_STATUS	12
+#define C0_SR		12
+#define C0_CAUSE	13
+#define C0_CR		13
+#define C0_EPC 		14
+#define C0_PRID		15
+#define C0_CONFIG	16
+#define C0_LLADDR	17
+#define C0_WATCHLO	18
+#define C0_WATCHHI	19
+#define C0_DEBUG	23
+#define C0_DEPC		24
+#define C0_PERFCNT	25
+#define C0_ERRCTL	26
+#define C0_CACHEERR	27
+#define C0_TAGLO	28
+#define C0_TAGHI	29
+#define C0_ERRPC	30
+#define C0_DESAVE	31
+
+#define _mips_nop() \
+  __asm__ __volatile ("%(ssnop%)" : :) 
+
+#define _mips_sync() \
+  __asm__ __volatile ("sync" : : : "memory")
+
+/* wait for unmasked interrupt */
+#define _mips_wait() \
+  __asm__ __volatile ("wait")
+
+/* 
+ * Define macros for accessing the MIPS32 coprocessor 0 registers.
+ * Most apart from "set" return the original register value.
+ */
+
+#if !__mips16
+
+#define _m32c0_mfc0(reg, sel) \
+__extension__ ({ \
+  register unsigned long __r; \
+  __asm__ __volatile ("mfc0 %0,$%1,%2" \
+		      : "=d" (__r) \
+      		      : "JK" (reg), "JK" (sel)); \
+  __r; \
+})
+
+#if __mips_isa_rev >= 2
+#define _m32c0_mtc0(reg, sel, val) \
+do { \
+    __asm__ __volatile ("%(mtc0 %z0,$%1,%2; ehb%)" \
+			: \
+			: "dJ" ((reg32_t)(val)), "JK" (reg), "JK" (sel) \
+			: "memory"); \
+} while (0)
+#else
+#define _m32c0_mtc0(reg, sel, val) \
+do { \
+    __asm__ __volatile ("%(mtc0 %z0,$%1,%2; ssnop; ssnop; ehb%)" \
+			: \
+			: "dJ" ((reg32_t)(val)), "JK" (reg), "JK" (sel) \
+			: "memory"); \
+} while (0)
+#endif
+
+#define _m32c0_mxc0(reg, sel, val) \
+__extension__ ({ \
+    register reg32_t __o; \
+    __o = _m32c0_mfc0 (reg, sel); \
+    _m32c0_mtc0 (reg, sel, val); \
+    __o; \
+})
+
+#else
+
+#define _m32c0_mfc0(rn, sel) 	_mips_xxc0 ((rn) + (sel)*32, 0, 0)
+#define _m32c0_mtc0(rn, sel, v)	(void) _mips_xxc0 ((rn) + (sel)*32, ~0, v)
+#define _m32c0_mxc0(rn, sel, v)	_mips_xxc0 ((rn) + (sel)*32, ~0, v)
+
+#endif /* !__mips16 */
+
+/* generic equivalents for mips/cpu.h */
+#define _mips_mfc0(r)		_m32c0_mfc0(r,0)
+#define _mips_mtc0(r,v)		_m32c0_mtc0(r,0,v)
+
+/* MIPS32 Config0 register */
+#define mips32_getconfig0()	_mips_mfc0(16)
+#define mips32_setconfig0(v)	_mips_mtc0(16,v)
+#define mips32_xchconfig0(v)	_mips_mxc0(16,v)
+#define mips32_bicconfig0(clr)	_mips_bcc0(16,clr)
+#define mips32_bisconfig0(set)	_mips_bsc0(16,set)
+#define mips32_bcsconfig0(c,s)	_mips_bcsc0(16,c,s)
+
+/* MIPS32 Config1, 2 & 3 register */
+#define mips32_getconfig1()	_m32c0_mfc0(16,1)
+#define mips32_getconfig2()	_m32c0_mfc0(16,2)
+#define mips32_getconfig3()	_m32c0_mfc0(16,3)
+
+/* MIPS32 WatchLo register */
+#define mips32_getwatchlo(sel)	 _mips_xxc0(18 + (sel)*32, 0, 0)
+#define mips32_setwatchlo(sel,v) _mips_xxc0(18 + (sel)*32, ~0, v)
+
+/* MIPS32 WatchHi register */
+#define mips32_getwatchhi(sel)	 _mips_xxc0(19 + (sel)*32, 0, 0)
+#define mips32_setwatchhi(sel,v) _mips_xxc0(19 + (sel)*32, ~0, v)
+
+/* MIPS32 Debug register */
+#define mips32_getdebug()	_mips_mfc0(23)
+#define mips32_setdebug(v)	_mips_mtc0(23,v)
+#define mips32_xchdebug(v)	_mips_mxc0(23,v)
+#define mips32_bicdebug(clr)	_mips_bcc0(23,clr)
+#define mips32_bisdebug(set)	_mips_bsc0(23,set)
+#define mips32_bcsdebug(c,s)	_mips_bcsc0(23,c,s)
+
+/* MIPS32 ErrCtl register */
+#define mips32_geterrctl()	_mips_mfc0(26)
+#define mips32_seterrctl(x)	_mips_mtc0(26,x)
+#define mips32_xcherrctl(x)	_mips_mxc0(26,x)
+#define mips32_bicerrctl(clr)	_mips_bcc0(26,clr)
+#define mips32_biserrctl(set)	_mips_bsc0(26,set)
+#define mips32_bcserrctl(c,s)	_mips_bcsc0(26,c,s)
+
+/* MIPS32 DataLo register */
+#define mips32_getdatalo()	_m32c0_mfc0(28,1)
+#define mips32_setdatalo(x)	_m32c0_mtc0(28,1,x)
+#define mips32_xchdatalo(x)	_m32c0_mxc0(28,1,x)
+
+/* MIPS32r2 IntCtl register */
+#define mips32_getintctl()	_m32c0_mfc0(12,1)
+#define mips32_setintctl(x)	_m32c0_mtc0(12,1,x)
+#define mips32_xchintctl(x)	_m32c0_mxc0(12,1,x)
+
+/* MIPS32r2 SRSCtl register */
+#define mips32_getsrsctl()	_m32c0_mfc0(12,2)
+#define mips32_setsrsctl(x)	_m32c0_mtc0(12,2,x)
+#define mips32_xchsrsctl(x)	_m32c0_mxc0(12,2,x)
+
+/* MIPS32r2 SRSMap register */
+#define mips32_getsrsmapl()	_m32c0_mfc0(12,3)
+#define mips32_setsrsmap(x)	_m32c0_mtc0(12,3,x)
+#define mips32_xchsrsmap(x)	_m32c0_mxc0(12,3,x)
+
+/* MIPS32r2/SmartMIPS PageGrain register */
+#define mips32_getpagegrain()	_m32c0_mfc0(5,1)
+#define mips32_setpagegrain(x)	_m32c0_mtc0(5,1,x)
+#define mips32_xchpagegrain(x)	_m32c0_mxc0(5,1,x)
+
+/* MIPS32r2 HWREna register */
+#define mips32_gethwrena()	_mips_mfc0(7)
+#define mips32_sethwrena(v)	_mips_mtc0(7,v)
+#define mips32_xchhwrena(v)	_mips_mxc0(7,v)
+#define mips32_bichwrena(clr)	_mips_bcc0(7,clr)
+#define mips32_bishwrena(set)	_mips_bsc0(7,set)
+#define mips32_bcshwrena(c,s)	_mips_bcsc0(7,c,s)
+
+/* MIPS32r2 EBase register */
+#define mips32_getebase()	_m32c0_mfc0(15,1)
+#define mips32_setebase(x)	_m32c0_mtc0(15,1,x)
+#define mips32_xchebase(x)	_m32c0_mxc0(15,1,x)
+
+/* MIPS32r2 taghi taglo register */
+#define mips32_setdtaglo(x)	_m32c0_mtc0(C0_TAGLO,2,x)
+#define mips32_setdtaghi(x)	_m32c0_mtc0(C0_TAGHI,2,x)
+//#define mips32_setdtaglo(x)	_m32c0_mtc0(28,1,x)
+//#define mips32_setdtaghi(x)	_m32c0_mtc0(29,1,x)
+
+/* MIPS32 PREF instruction hint codes */
+#define PREF_LOAD		0
+#define PREF_STORE		1
+#define PREF_LOAD_STREAMED	4
+#define PREF_STORE_STREAMED	5
+#define PREF_LOAD_RETAINED	6
+#define PREF_STORE_RETAINED	7
+#define PREF_WRITEBACK_INVAL	25
+#define PREF_PREPAREFORSTORE	30
+
+/* Define MIPS64 user-level intrinsics */
+//#include <mips/mips32.h>
+
+/* CP0 intrinsics */
+#if __mips_isa_rev >= 2 && ! __mips16
+
+/* MIPS32r2 atomic interrupt disable */
+#define _mips_intdisable() __extension__({ \
+    unsigned int __v; \
+    __asm__ __volatile__ ("di %0; ehb" : "=d" (__v)); \
+    __v; \
+})
+
+/* MIPS32r2 atomic interrupt restore */
+#define _mips_intrestore(x) \
+    mips_setsr (x)
+
+/* MIPS32r2 set SRSCtl.PSS (previous shadow set), returning old value */
+extern unsigned int _mips32r2_xchsrspss (unsigned int);
+
+#if 0
+/* simpler to make this a function in mipscp0.sx */
+#define _mips32r2_xchsrspss(set) \
+__extension__({ \
+    unsigned int __tmp, __old; \
+    __asm __volatile ("mfc0 %0,$12,2\n\
+		       ext %1,%0,6,4\n\
+		       ins %0,%z2,6,4\n\
+		       mtc0 %0,$12,2\n\
+		       la %0,1f\n\
+		       jr.hb %0\n\
+		       1:"
+      		       : "=&d" (__tmp), "=&d" (__old) \
+       		       : "dJ" (set)); \
+    __old; \
+})
+#endif
+
+/* MIPS32r2 write previous gpr */
+#define _mips32r2_wrpgpr(regno, val) \
+do { \
+    __asm __volatile ("wrpgpr $%0,%z1" \
+        	      : /* no outputs */ \
+ 		      : "JK" (regno), "dJ" (val)); \
+} while (0)
+
+/* MIPS32r2 read previous gpr */
+#define _mips32r2_rdpgpr(regno) \
+__extension__({ \
+    reg_t __val; \
+    __asm __volatile ("rdpgpr %0,$%1" \
+        	      : "=d" (__val) \
+ 		      : "JK" (regno)); \
+    __val; \
+})
+
+#endif /* __mips_isa_rev >= 2 && ! __mips16 */
+
+#endif /* __ASSEMBLER__ */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _M32C0_H_ */
diff --git a/arch/mips/include/asm/mipsmtregs.h b/arch/mips/include/asm/mipsmtregs.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/mipsmtregs.h
@@ -0,0 +1,469 @@
+/*
+ * MT regs definitions, follows on from mipsregs.h
+ * Copyright (C) 2004 - 2005 MIPS Technologies, Inc.  All rights reserved.
+ * Elizabeth Clarke et. al.
+ *
+ */
+#ifndef _ASM_MIPSMTREGS_H
+#define _ASM_MIPSMTREGS_H
+
+#include <asm/mipsregs.h>
+
+#ifndef __ASSEMBLY__
+
+/*
+ * C macros
+ */
+
+#define read_c0_mvpcontrol()		__read_32bit_c0_register($0, 1)
+#define write_c0_mvpcontrol(val)	__write_32bit_c0_register($0, 1, val)
+
+#define read_c0_mvpconf0()		__read_32bit_c0_register($0, 2)
+#define read_c0_mvpconf1()		__read_32bit_c0_register($0, 3)
+
+#define read_c0_vpecontrol()		__read_32bit_c0_register($1, 1)
+#define write_c0_vpecontrol(val)	__write_32bit_c0_register($1, 1, val)
+
+#define read_c0_vpeconf0()		__read_32bit_c0_register($1, 2)
+#define write_c0_vpeconf0(val)		__write_32bit_c0_register($1, 2, val)
+
+#define read_c0_vpeschedule()          __read_32bit_c0_register($1, 5)
+#define write_c0_vpeschedule(val)      __write_32bit_c0_register($1, 5, val)
+
+#define read_c0_vpeschefback()         __read_32bit_c0_register($1, 6)
+#define write_c0_vpeschefback(val)     __write_32bit_c0_register($1, 6, val)
+
+#define read_c0_vpeopt()              __read_32bit_c0_register($1, 7)
+#define write_c0_vpeopt(val)          __write_32bit_c0_register($1, 7, val)
+
+#define read_c0_tcstatus()		__read_32bit_c0_register($2, 1)
+#define write_c0_tcstatus(val)		__write_32bit_c0_register($2, 1, val)
+
+#define read_c0_tcbind()		__read_32bit_c0_register($2, 2)
+#define write_c0_tcbind(val)           __write_32bit_c0_register($2, 2, val)
+
+#define read_c0_tccontext()		__read_32bit_c0_register($2, 5)
+#define write_c0_tccontext(val)		__write_32bit_c0_register($2, 5, val)
+
+#define read_c0_tcschedule()           __read_32bit_c0_register($2, 6)
+#define write_c0_tcschedule(val)       __write_32bit_c0_register($2, 6, val)
+
+#define read_c0_tcschefback()          __read_32bit_c0_register($2, 7)
+#define write_c0_tcschefback(val)      __write_32bit_c0_register($2, 7, val)
+
+
+#else /* Assembly */
+/*
+ * Macros for use in assembly language code
+ */
+
+#define CP0_MVPCONTROL		$0, 1
+#define CP0_MVPCONF0		$0, 2
+#define CP0_MVPCONF1		$0, 3
+#define CP0_VPECONTROL		$1, 1
+#define CP0_VPECONF0		$1, 2
+#define CP0_VPECONF1		$1, 3
+#define CP0_YQMASK		$1, 4
+#define CP0_VPESCHEDULE		$1, 5
+#define CP0_VPESCHEFBK		$1, 6
+#define CP0_TCSTATUS		$2, 1
+#define CP0_TCBIND		$2, 2
+#define CP0_TCRESTART		$2, 3
+#define CP0_TCHALT		$2, 4
+#define CP0_TCCONTEXT		$2, 5
+#define CP0_TCSCHEDULE		$2, 6
+#define CP0_TCSCHEFBK		$2, 7
+#define CP0_SRSCONF0		$6, 1
+#define CP0_SRSCONF1		$6, 2
+#define CP0_SRSCONF2		$6, 3
+#define CP0_SRSCONF3		$6, 4
+#define CP0_SRSCONF4		$6, 5
+
+#endif
+
+/* MVPControl fields */
+#define MVPCONTROL_EVP		(_ULCAST_(1))
+
+#define MVPCONTROL_VPC_SHIFT	1
+#define MVPCONTROL_VPC		(_ULCAST_(1) << MVPCONTROL_VPC_SHIFT)
+
+#define MVPCONTROL_STLB_SHIFT	2
+#define MVPCONTROL_STLB		(_ULCAST_(1) << MVPCONTROL_STLB_SHIFT)
+
+#ifdef CONFIG_IFX_VPE_CACHE_SPLIT
+#define MVPCONTROL_CPA_SHIFT   3
+#define MVPCONTROL_CPA         (_ULCAST_(1) << MVPCONTROL_CPA_SHIFT)
+#endif
+
+/* MVPConf0 fields */
+#define MVPCONF0_PTC_SHIFT	0
+#define MVPCONF0_PTC		( _ULCAST_(0xff))
+#define MVPCONF0_PVPE_SHIFT	10
+#define MVPCONF0_PVPE		( _ULCAST_(0xf) << MVPCONF0_PVPE_SHIFT)
+#define MVPCONF0_TCA_SHIFT	15
+#define MVPCONF0_TCA		( _ULCAST_(1) << MVPCONF0_TCA_SHIFT)
+#define MVPCONF0_PTLBE_SHIFT	16
+#define MVPCONF0_PTLBE		(_ULCAST_(0x3ff) << MVPCONF0_PTLBE_SHIFT)
+
+#ifdef CONFIG_IFX_VPE_CACHE_SPLIT
+#define MVPCONF0_PCP_SHIFT     27
+#define MVPCONF0_PCP           (_ULCAST_(1) << MVPCONF0_PCP_SHIFT)
+#endif
+
+#define MVPCONF0_TLBS_SHIFT	29
+#define MVPCONF0_TLBS		(_ULCAST_(1) << MVPCONF0_TLBS_SHIFT)
+#define MVPCONF0_M_SHIFT	31
+#define MVPCONF0_M		(_ULCAST_(0x1) << MVPCONF0_M_SHIFT)
+
+
+/* config3 fields */
+#define CONFIG3_MT_SHIFT	2
+#define CONFIG3_MT		(_ULCAST_(1) << CONFIG3_MT_SHIFT)
+
+
+/* VPEControl fields (per VPE) */
+#define VPECONTROL_TARGTC	(_ULCAST_(0xff))
+
+#define VPECONTROL_TE_SHIFT	15
+#define VPECONTROL_TE		(_ULCAST_(1) << VPECONTROL_TE_SHIFT)
+#define VPECONTROL_EXCPT_SHIFT	16
+#define VPECONTROL_EXCPT	(_ULCAST_(0x7) << VPECONTROL_EXCPT_SHIFT)
+
+/* Thread Exception Codes for EXCPT field */
+#define THREX_TU		0
+#define THREX_TO		1
+#define THREX_IYQ		2
+#define THREX_GSX		3
+#define THREX_YSCH		4
+#define THREX_GSSCH		5
+
+#define VPECONTROL_GSI_SHIFT	20
+#define VPECONTROL_GSI		(_ULCAST_(1) << VPECONTROL_GSI_SHIFT)
+#define VPECONTROL_YSI_SHIFT	21
+#define VPECONTROL_YSI		(_ULCAST_(1) << VPECONTROL_YSI_SHIFT)
+
+/* VPEConf0 fields (per VPE) */
+#define VPECONF0_VPA_SHIFT	0
+#define VPECONF0_VPA		(_ULCAST_(1) << VPECONF0_VPA_SHIFT)
+#define VPECONF0_MVP_SHIFT	1
+#define VPECONF0_MVP		(_ULCAST_(1) << VPECONF0_MVP_SHIFT)
+
+#ifdef CONFIG_IFX_VPE_CACHE_SPLIT
+#define VPECONF0_ICS_SHIFT      16
+#define VPECONF0_ICS           (_ULCAST_(1) << VPECONF0_ICS_SHIFT)
+#define VPECONF0_DCS_SHIFT      17
+#define VPECONF0_DCS            (_ULCAST_(1) << VPECONF0_DCS_SHIFT)
+#endif
+
+#define VPECONF0_XTC_SHIFT	21
+#define VPECONF0_XTC		(_ULCAST_(0xff) << VPECONF0_XTC_SHIFT)
+
+#ifdef CONFIG_IFX_VPE_CACHE_SPLIT
+/* VPEOpt fields */
+#define VPEOPT_DWX_SHIFT       0
+#define VPEOPT_IWX_SHIFT       8
+#define VPEOPT_IWX0            ( _ULCAST_(0x1) << VPEOPT_IWX_SHIFT)
+#define VPEOPT_IWX1            ( _ULCAST_(0x2) << VPEOPT_IWX_SHIFT)
+#define VPEOPT_IWX2            ( _ULCAST_(0x4) << VPEOPT_IWX_SHIFT)
+#define VPEOPT_IWX3            ( _ULCAST_(0x8) << VPEOPT_IWX_SHIFT)
+#define VPEOPT_DWX0            ( _ULCAST_(0x1) << VPEOPT_DWX_SHIFT)
+#define VPEOPT_DWX1            ( _ULCAST_(0x2) << VPEOPT_DWX_SHIFT)
+#define VPEOPT_DWX2            ( _ULCAST_(0x4) << VPEOPT_DWX_SHIFT)
+#define VPEOPT_DWX3            ( _ULCAST_(0x8) << VPEOPT_DWX_SHIFT)
+#endif
+
+/* TCStatus fields (per TC) */
+#define TCSTATUS_TASID		(_ULCAST_(0xff))
+#define TCSTATUS_IXMT_SHIFT	10
+#define TCSTATUS_IXMT		(_ULCAST_(1) << TCSTATUS_IXMT_SHIFT)
+#define TCSTATUS_TKSU_SHIFT	11
+#define TCSTATUS_TKSU		(_ULCAST_(3) << TCSTATUS_TKSU_SHIFT)
+#define TCSTATUS_A_SHIFT	13
+#define TCSTATUS_A		(_ULCAST_(1) << TCSTATUS_A_SHIFT)
+#define TCSTATUS_DA_SHIFT	15
+#define TCSTATUS_DA		(_ULCAST_(1) << TCSTATUS_DA_SHIFT)
+#define TCSTATUS_DT_SHIFT	20
+#define TCSTATUS_DT		(_ULCAST_(1) << TCSTATUS_DT_SHIFT)
+#define TCSTATUS_TDS_SHIFT	21
+#define TCSTATUS_TDS		(_ULCAST_(1) << TCSTATUS_TDS_SHIFT)
+#define TCSTATUS_TSST_SHIFT	22
+#define TCSTATUS_TSST		(_ULCAST_(1) << TCSTATUS_TSST_SHIFT)
+#define TCSTATUS_RNST_SHIFT	23
+#define TCSTATUS_RNST		(_ULCAST_(3) << TCSTATUS_RNST_SHIFT)
+/* Codes for RNST */
+#define TC_RUNNING		0
+#define TC_WAITING		1
+#define TC_YIELDING		2
+#define TC_GATED		3
+
+#define TCSTATUS_TMX_SHIFT	27
+#define TCSTATUS_TMX		(_ULCAST_(1) << TCSTATUS_TMX_SHIFT)
+/* TCStatus TCU bits can use same definitions/offsets as CU bits in Status */
+
+/* TCBind */
+#define TCBIND_CURVPE_SHIFT	0
+#define TCBIND_CURVPE		(_ULCAST_(0xf))
+
+#define TCBIND_CURTC_SHIFT	21
+
+#define TCBIND_CURTC		(_ULCAST_(0xff) << TCBIND_CURTC_SHIFT)
+
+/* TCHalt */
+#define TCHALT_H		(_ULCAST_(1))
+
+#ifndef __ASSEMBLY__
+
+static inline unsigned int dvpe(void)
+{
+	int res = 0;
+
+	__asm__ __volatile__(
+	"	.set	push						\n"
+	"	.set	noreorder					\n"
+	"	.set	noat						\n"
+	"	.set	mips32r2					\n"
+	"	.word	0x41610001		# dvpe $1		\n"
+	"	move	%0, $1						\n"
+	"	ehb							\n"
+	"	.set	pop						\n"
+	: "=r" (res));
+
+	instruction_hazard();
+
+	return res;
+}
+
+static inline void __raw_evpe(void)
+{
+	__asm__ __volatile__(
+	"	.set	push						\n"
+	"	.set	noreorder					\n"
+	"	.set	noat						\n"
+	"	.set	mips32r2					\n"
+	"	.word	0x41600021		# evpe			\n"
+	"	ehb							\n"
+	"	.set	pop						\n");
+}
+
+/* Enable virtual processor execution if previous suggested it should be.
+   EVPE_ENABLE to force */
+
+#define EVPE_ENABLE MVPCONTROL_EVP
+
+static inline void evpe(int previous)
+{
+	if ((previous & MVPCONTROL_EVP))
+		__raw_evpe();
+}
+
+static inline unsigned int dmt(void)
+{
+	int res;
+
+	__asm__ __volatile__(
+	"	.set	push						\n"
+	"	.set	mips32r2					\n"
+	"	.set	noat						\n"
+	"	.word	0x41610BC1			# dmt $1	\n"
+	"	ehb							\n"
+	"	move	%0, $1						\n"
+	"	.set	pop						\n"
+	: "=r" (res));
+
+	instruction_hazard();
+
+	return res;
+}
+
+static inline void __raw_emt(void)
+{
+	__asm__ __volatile__(
+	"	.set	noreorder					\n"
+	"	.set	mips32r2					\n"
+	"	.word	0x41600be1			# emt		\n"
+	"	ehb							\n"
+	"	.set	mips0						\n"
+	"	.set	reorder");
+}
+
+/* enable multi-threaded execution if previous suggested it should be.
+   EMT_ENABLE to force */
+
+#define EMT_ENABLE VPECONTROL_TE
+
+static inline void emt(int previous)
+{
+	if ((previous & EMT_ENABLE))
+		__raw_emt();
+}
+
+static inline void ehb(void)
+{
+	__asm__ __volatile__(
+	"	.set	mips32r2				\n"
+	"	ehb						\n"
+	"	.set	mips0					\n");
+}
+
+#define mftc0(rt,sel)							\
+({									\
+	 unsigned long  __res;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	mips32r2				\n"	\
+	"	.set	noat					\n"	\
+	"	# mftc0	$1, $" #rt ", " #sel "			\n"	\
+	"	.word	0x41000800 | (" #rt " << 16) | " #sel "	\n"	\
+	"	move	%0, $1					\n"	\
+	"	.set	pop					\n"	\
+	: "=r" (__res));						\
+									\
+	__res;								\
+})
+
+#define mftgpr(rt)							\
+({									\
+	unsigned long __res;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noat					\n"	\
+	"	.set	mips32r2				\n"	\
+	"	# mftgpr $1," #rt "				\n"	\
+	"	.word	0x41000820 | (" #rt " << 16)		\n"	\
+	"	move	%0, $1					\n"	\
+	"	.set	pop					\n"	\
+	: "=r" (__res));						\
+									\
+	__res;								\
+})
+
+#define mftr(rt, u, sel)							\
+({									\
+	unsigned long __res;						\
+									\
+	__asm__ __volatile__(						\
+	"	mftr	%0, " #rt ", " #u ", " #sel "		\n"	\
+	: "=r" (__res));						\
+									\
+	__res;								\
+})
+
+#define mttgpr(rd,v)							\
+do {									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	mips32r2				\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mttgpr $1, " #rd "				\n"	\
+	"	.word	0x41810020 | (" #rd " << 11)		\n"	\
+	"	.set	pop					\n"	\
+	: : "r" (v));							\
+} while (0)
+
+#define mttc0(rd, sel, v)							\
+({									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	mips32r2				\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mttc0 %0," #rd ", " #sel "			\n"	\
+	"	.word	0x41810000 | (" #rd " << 11) | " #sel "	\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "r" (v));							\
+})
+
+
+#define mttr(rd, u, sel, v)						\
+({									\
+	__asm__ __volatile__(						\
+	"mttr	%0," #rd ", " #u ", " #sel				\
+	: : "r" (v));							\
+})
+
+
+#define mips_mt_yield(yq)                   \
+__extension__ ({                        \
+    unsigned int __yq = (yq);                   \
+    unsigned int __res;                     \
+    __asm__ __volatile ("yield %0,%z1"              \
+                        : "=d" (__res)              \
+			            : "dJ" (__yq));             \
+					    __res;                          \
+})
+
+
+
+#define settc(tc)							\
+do {									\
+	write_c0_vpecontrol((read_c0_vpecontrol()&~VPECONTROL_TARGTC) | (tc)); \
+	ehb();								\
+} while (0)
+
+
+/* you *must* set the target tc (settc) before trying to use these */
+#define read_vpe_c0_vpecontrol()	mftc0(1, 1)
+#define write_vpe_c0_vpecontrol(val)	mttc0(1, 1, val)
+#define read_vpe_c0_vpeconf0()		mftc0(1, 2)
+#define write_vpe_c0_vpeconf0(val)	mttc0(1, 2, val)
+#define read_vpe_c0_vpeschedule()      mftc0(1, 5)
+#define write_vpe_c0_vpeschedule(val)  mttc0(1, 5, val)
+#define read_vpe_c0_vpeschefback()     mftc0(1, 6)
+#define write_vpe_c0_vpeschefback(val) mttc0(1, 6, val)
+#define read_vpe_c0_count()		mftc0(9, 0)
+#define write_vpe_c0_count(val)		mttc0(9, 0, val)
+#define read_vpe_c0_status()		mftc0(12, 0)
+#define write_vpe_c0_status(val)	mttc0(12, 0, val)
+#define read_vpe_c0_cause()		mftc0(13, 0)
+#define write_vpe_c0_cause(val)		mttc0(13, 0, val)
+#define read_vpe_c0_config()		mftc0(16, 0)
+#define write_vpe_c0_config(val)	mttc0(16, 0, val)
+#define read_vpe_c0_config1()		mftc0(16, 1)
+#define write_vpe_c0_config1(val)	mttc0(16, 1, val)
+#define read_vpe_c0_config7()		mftc0(16, 7)
+#define write_vpe_c0_config7(val)	mttc0(16, 7, val)
+#define read_vpe_c0_ebase()		mftc0(15, 1)
+#define write_vpe_c0_ebase(val)		mttc0(15, 1, val)
+#define write_vpe_c0_compare(val)	mttc0(11, 0, val)
+#define read_vpe_c0_badvaddr()		mftc0(8, 0)
+#define read_vpe_c0_epc()		mftc0(14, 0)
+#define write_vpe_c0_epc(val)		mttc0(14, 0, val)
+
+#define read_vpe_c0_vpeopt()            mftc0(1, 7)
+#define write_vpe_c0_vpeopt(val)        mttc0(1, 7, val)
+#define read_vpe_c0_wired()            mftc0(6, 0)
+#define write_vpe_c0_wired(val)                mttc0(6, 0, val)
+
+/* TC */
+#define read_tc_c0_tcstatus()		mftc0(2, 1)
+#define write_tc_c0_tcstatus(val)	mttc0(2, 1, val)
+#define read_tc_c0_tcbind()		mftc0(2, 2)
+#define write_tc_c0_tcbind(val)		mttc0(2, 2, val)
+#define read_tc_c0_tcrestart()		mftc0(2, 3)
+#define write_tc_c0_tcrestart(val)	mttc0(2, 3, val)
+#define read_tc_c0_tchalt()		mftc0(2, 4)
+#define write_tc_c0_tchalt(val)		mttc0(2, 4, val)
+#define read_tc_c0_tccontext()		mftc0(2, 5)
+#define write_tc_c0_tccontext(val)	mttc0(2, 5, val)
+#define read_tc_c0_tcschedule()         mftc0(2, 6)
+#define write_tc_c0_tcschedule(val)    	mttc0(2,6,val)
+#define read_tc_c0_tcschefback()       	mftc0(2, 7)
+#define write_tc_c0_tcschefback(val)   	mttc0(2,7,val)
+#define read_tc_c0_entryhi()            mftc0(10, 0)
+#define write_tc_c0_entryhi(val)        mttc0(10,0,val)
+            
+/* GPR */
+#define read_tc_gpr_sp()		mftgpr(29)
+#define write_tc_gpr_sp(val)		mttgpr(29, val)
+#define read_tc_gpr_gp()		mftgpr(28)
+#define write_tc_gpr_gp(val)		mttgpr(28, val)
+
+__BUILD_SET_C0(mvpcontrol)
+
+#endif /* Not __ASSEMBLY__ */
+
+#endif
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -954,6 +954,9 @@ do {									\
 #define read_c0_taglo()		__read_32bit_c0_register($28, 0)
 #define write_c0_taglo(val)	__write_32bit_c0_register($28, 0, val)
 
+#define read_c0_staglo()    __read_32bit_c0_register($28, 4)
+#define write_c0_staglo(val)    __write_32bit_c0_register($28, 4, val)
+
 #define read_c0_dtaglo()	__read_32bit_c0_register($28, 2)
 #define write_c0_dtaglo(val)	__write_32bit_c0_register($28, 2, val)
 
diff --git a/arch/mips/include/asm/mt.h b/arch/mips/include/asm/mt.h
new file mode 100755
--- /dev/null
+++ b/arch/mips/include/asm/mt.h
@@ -0,0 +1,504 @@
+/*
+ * Copyright (c) 2004-2005 MIPS Technologies, Inc.
+ * All rights reserved.
+ * 
+ * Unpublished rights (if any) reserved under the copyright laws of the
+ * United States of America and other countries.
+ * 
+ * This code is proprietary to MIPS Technologies, Inc. ("MIPS
+ * Technologies").  Any copying, reproducing, modifying or use of
+ * this code (in whole or in part) that is not expressly permitted
+ * in writing by MIPS Technologies or an authorized third party is
+ * strictly prohibited.  At a minimum, this code is protected under
+ * unfair competition and copyright laws.  Violations thereof may result
+ * in criminal penalties and fines.
+ * 
+ * MIPS Technologies reserves the right to change this code to improve
+ * function, design or otherwise.  MIPS Technologies does not assume any
+ * liability arising out of the application or use of this code, or of
+ * any error or omission in such code.  Any warranties, whether express,
+ * statutory, implied or otherwise, including but not limited to the
+ * implied warranties of merchantability or fitness for a particular
+ * purpose, are excluded.  Except as expressly provided in any written
+ * license agreement from MIPS Technologies or an authorized third party,
+ * the furnishing of this code does not give recipient any license to
+ * any intellectual property rights, including any patent rights, that
+ * cover this code.
+ * 
+ * This code shall not be exported, reexported, transferred, or released,
+ * directly or indirectly, in violation of the law of any country or
+ * international law, regulation, treaty, Executive Order, statute,
+ * amendments or supplements thereto.  Should a conflict arise regarding
+ * the export, reexport, transfer, or release of this code, the laws of
+ * the United States of America shall be the governing law.
+ * 
+ * This code constitutes one or more of the following: commercial
+ * computer software, commercial computer software documentation or
+ * other commercial items.  If the user of this code, or any related
+ * documentation of any kind, including related technical data or
+ * manuals, is an agency, department, or other entity of the United
+ * States government ("Government"), the use, duplication, reproduction,
+ * release, modification, disclosure, or transfer of this code, or
+ * any related documentation of any kind, is restricted in accordance
+ * with Federal Acquisition Regulation 12.212 for civilian agencies
+ * and Defense Federal Acquisition Regulation Supplement 227.7202 for
+ * military agencies.  The use of this code by the Government is further
+ * restricted in accordance with the terms of the license agreement(s)
+ * and/or applicable contract terms and conditions covering this code
+ * from MIPS Technologies or an authorized third party.
+ * 
+ * 
+ */
+
+/*
+ * mips/mt.h: MIPS MT ASE registers and intrinsics
+ */
+
+
+#ifndef _MIPS_MT_H_
+#define _MIPS_MT_H_
+
+#include <asm/m32c0.h>
+
+
+
+/*
+ * MIPS32 MVPControl Register (CP0 Register 0, Select 1)
+ */
+#define MVPCONTROL_EVP		0x00000001
+#define MVPCONTROL_VPC		0x00000002
+#define MVPCONTROL_STLB		0x00000004
+
+/*
+ * MIPS32 MVPConf0 Register (CP0 Register 0, Select 2)
+ */
+#define MVPCONF0_PTC		0x000000ff	
+#define  MVPCONF0_PTC_SHIFT		 0	
+#define MVPCONF0_PVPE		0x00003c00	
+#define  MVPCONF0_PVPE_SHIFT		10	
+#define MVPCONF0_TCA		0x00008000	
+#define MVPCONF0_PTLBE		0x03ff0000	
+#define  MVPCONF0_PTLBE_SHIFT		16
+#define MVPCONF0_TLBS		0x20000000	
+#define MVPCONF0_M		0x80000000	
+
+/*
+ * MIPS32 MVPConf1 Register (CP0 Register 0, Select 3)
+ */
+#define MVPCONF1_PCP1		0x000000ff	
+#define  MVPCONF1_PCP1_SHIFT		 0	
+#define MVPCONF1_PCP2		0x0003fc00	
+#define  MVPCONF1_PCP2_SHIFT		10	
+#define MVPCONF1_PCX		0x0ff00000	
+#define  MVPCONF1_PCX_SHIFT		20
+#define MVPCONF1_C1F		0x40000000     
+#define MVPCONF1_C1M		0x80000000	
+
+/*
+ * MIPS32 VPEControl Register (CP0 Register 1, Select 1)
+ */
+#define VPECONTROL_TARGTC	0x000000ff	
+#define  VPECONTROL_TARGTC_SHIFT	 0	
+#define VPECONTROL_TARGVPE	0x00003c00	
+#define  VPECONTROL_TARGVPE_SHIFT	10	
+#define VPECONTROL_TE		0x00008000	
+#define VPECONTROL_EXCPT	0x00070000	
+#define  VPECONTROL_EXCPT_SHIFT	        16	
+#define VPECONTROL_GSI		0x00100000	
+#define VPECONTROL_YSI		0x00200000	
+
+/*
+ * MIPS32 VPEConf0 Register (CP0 Register 1, Select 2)
+ */
+#define VPECONF0_VPA		0x00000001
+#define VPECONF0_MVP		0x00000002
+#define VPECONF0_XTC		0x1fe00000
+#define VPECONF0_XTC_SHIFT		21
+#define VPECONF0_M		0x80000000	
+
+/*
+ * MIPS32 VPEConf1 Register (CP0 Register 1, Select 3)
+ */
+#define VPECONF1_NCP1		0x000000ff	
+#define  VPECONF1_NCP1_SHIFT		 0	
+#define VPECONF1_NCP2		0x0003fc00	
+#define  VPECONF1_NCP2_SHIFT		10	
+#define VPECONF1_NCX		0x0ff00000	
+#define  VPECONF1_NCX_SHIFT		20	
+
+/*
+ * MIPS32 YQMask Register (CP0 Register 1, Select 4)
+ */
+#define YQMASK_MASK		0x7fffffff
+#define  YQMASK_MASK_SHIFT		 0
+
+/*
+ * MIPS32 TCStatus Register (CP0 Register 2, Select 1)
+ */
+#define TCSTATUS_TASID		0x000000ff
+#define  TCSTATUS_TASID_SHIFT	         0
+#define TCSTATUS_IXMT		0x00000400
+#define TCSTATUS_TKSU		0x00001800
+#define  TCSTATUS_TKSU_SHIFT		11
+#define TCSTATUS_A		0x00002000
+#define TCSTATUS_DA		0x00008000
+#define TCSTATUS_IMPL		0x000f0000
+#define  TCSTATUS_IMPL_SHIFT		16
+#define TCSTATUS_DT		0x00100000
+#define TCSTATUS_TDS		0x00200000
+#define TCSTATUS_TSST		0x00400000
+#define TCSTATUS_RNST		0x01800000
+#define  TCSTATUS_RNST_SHIFT		23
+#define TCSTATUS_TCU0		0x10000000
+#define TCSTATUS_TCU1		0x20000000
+#define TCSTATUS_TCU2		0x40000000
+#define TCSTATUS_TCU3		0x80000000
+
+/*
+ * MIPS32 TCBind Register (CP0 Register 2, Select 2)
+ */
+#define TCBIND_CURVPE		0x0000000f	
+#define  TCBIND_CURVPE_SHIFT		 0	
+#define TCBIND_CURTC		0x1fe00000	
+#define  TCBIND_CURTC_SHIFT		21
+
+/*
+ * MIPS32 TCHalt Register (CP0 Register 2, Select 4)
+ */
+#define TCHALT_H		0x00000001
+
+/*
+ * MIPS32 SRSConf0 Register (CP0 Register 6, Select 1)
+ */
+#define SRSCONF0_SRS1		0x000003ff
+#define  SRSCONF0_SRS1_SHIFT		 0
+#define SRSCONF0_SRS2		0x000ffc00
+#define  SRSCONF0_SRS2_SHIFT		10
+#define SRSCONF0_SRS3		0x3ff00000
+#define  SRSCONF0_SRS3_SHIFT		20
+#define SRSCONF0_M		0x80000000
+
+/*
+ * MIPS32 SRSConf1 Register (CP0 Register 6, Select 2)
+ */
+#define SRSCONF1_SRS4		0x000003ff
+#define  SRSCONF1_SRS4_SHIFT		 0
+#define SRSCONF1_SRS5		0x000ffc00
+#define  SRSCONF1_SRS5_SHIFT		10
+#define SRSCONF1_SRS6		0x3ff00000
+#define  SRSCONF1_SRS6_SHIFT		20
+#define SRSCONF1_M		0x80000000
+
+/*
+ * MIPS32 SRSConf2 Register (CP0 Register 6, Select 3)
+ */
+#define SRSCONF2_SRS7		0x000003ff
+#define  SRSCONF2_SRS7_SHIFT		 0
+#define SRSCONF2_SRS8		0x000ffc00
+#define  SRSCONF2_SRS8_SHIFT		10
+#define SRSCONF2_SRS9		0x3ff00000
+#define  SRSCONF2_SRS9_SHIFT		20
+#define SRSCONF2_M		0x80000000
+
+/*
+ * MIPS32 SRSConf3 Register (CP0 Register 6, Select 4)
+ */
+#define SRSCONF3_SRS10		0x000003ff
+#define  SRSCONF3_SRS10_SHIFT		 0
+#define SRSCONF3_SRS11		0x000ffc00
+#define  SRSCONF3_SRS11_SHIFT		10
+#define SRSCONF3_SRS12		0x3ff00000
+#define  SRSCONF3_SRS12_SHIFT		20
+#define SRSCONF3_M		0x80000000
+
+/*
+ * MIPS32 SRSConf4 Register (CP0 Register 6, Select 5)
+ */
+#define SRSCONF4_SRS13		0x000003ff
+#define  SRSCONF4_SRS13_SHIFT		 0
+#define SRSCONF4_SRS14		0x000ffc00
+#define  SRSCONF4_SRS14_SHIFT		10
+#define SRSCONF4_SRS15		0x3ff00000
+#define  SRSCONF4_SRS15_SHIFT		20
+
+/*
+ * MIPS32 Config3 Register (CP0 Register 16, Select 3)
+ * New fields for MT
+ */
+#define CFG3_MT			0x00000004
+
+#ifdef __ASSEMBLER__
+
+/* 
+ * MT Coprocessor 0 register numbers 
+ */
+#define C0_MVPCONTROL         $0,1
+#define C0_MVPCONF0           $0,2
+#define C0_MVPCONF1           $0,3
+#define C0_VPECONTROL         $1,1
+#define C0_VPECONF0           $1,2
+#define C0_VPECONF1           $1,3
+#define C0_YQMASK             $1,4
+#define C0_VPESCHEDULE        $1,5
+#define C0_VPESCHEFBACK       $1,6
+#define C0_TCSTATUS           $2,1
+#define C0_TCBIND             $2,2
+#define C0_TCRESTART          $2,3
+#define C0_TCHALT             $2,4
+#define C0_TCCONTEXT          $2,5
+#define C0_TCSCHEDULE         $2,6
+#define C0_TCSCHEFBACK        $2,7
+#define C0_SRSCONF0           $6,1
+#define C0_SRSCONF1           $6,2
+#define C0_SRSCONF2           $6,3
+#define C0_SRSCONF3           $6,4
+#define C0_SRSCONF4           $6,5
+
+#else
+
+#define mips32_getmvpcontrol()	        _m32c0_mfc0(0,1)
+#define mips32_setmvpcontrol(x)	        _m32c0_mtc0(0,1,x)
+#define mips32_xchmvpcontrol(x)	        _m32c0_mxc0(0,1,x)
+
+#define mips32_getmvpconf0()	        _m32c0_mfc0(0,2)
+#define mips32_setmvpconf0(x)	        _m32c0_mtc0(0,2,x)
+#define mips32_xchmvpconf0(x)	        _m32c0_mxc0(0,2,x)
+
+#define mips32_getmvpconf1()	        _m32c0_mfc0(0,3)
+#define mips32_setmvpconf1(x)	        _m32c0_mtc0(0,3,x)
+#define mips32_xchmvpconf1(x)	        _m32c0_mxc0(0,3,x)
+
+#define mips32_getvpecontrol()	        _m32c0_mfc0(1,1)
+#define mips32_setvpecontrol(x)	        _m32c0_mtc0(1,1,x)
+#define mips32_xchvpecontrol(x)	        _m32c0_mxc0(1,1,x)
+
+#define mips32_getvpeconf0()	        _m32c0_mfc0(1,2)
+#define mips32_setvpeconf0(x)	        _m32c0_mtc0(1,2,x)
+#define mips32_xchvpeconf0(x)	        _m32c0_mxc0(1,2,x)
+
+#define mips32_getvpeconf1()	        _m32c0_mfc0(1,3)
+#define mips32_setvpeconf1(x)	        _m32c0_mtc0(1,3,x)
+#define mips32_xchvpeconf1(x)	        _m32c0_mxc0(1,3,x)
+
+#define mips32_getyqmask()	        _m32c0_mfc0(1,4)
+#define mips32_setyqmask(x)	        _m32c0_mtc0(1,4,x)
+#define mips32_xchyqmask(x)	        _m32c0_mxc0(1,4,x)
+
+#define mips32_getvpeschedule()	        _m32c0_mfc0(1,5)
+#define mips32_setvpeschedule(x)	_m32c0_mtc0(1,5,x)
+#define mips32_xchvpeschedule(x)	_m32c0_mxc0(1,5,x)
+
+#define mips32_getvpeschefback()        _m32c0_mfc0(1,6)
+#define mips32_setvpeschefback(x)       _m32c0_mtc0(1,6,x)
+#define mips32_xchvpeschefback(x)       _m32c0_mxc0(1,6,x)
+
+#define mips32_gettcstatus()	        _m32c0_mfc0(2,1)
+#define mips32_settcstatus(x)	        _m32c0_mtc0(2,1,x)
+#define mips32_xchtcstatus(x)	        _m32c0_mxc0(2,1,x)
+
+#define mips32_gettcbind()	        _m32c0_mfc0(2,2)
+#define mips32_settcbind(x)	        _m32c0_mtc0(2,2,x)
+#define mips32_xchtcbind(x)	        _m32c0_mxc0(2,2,x)
+
+#define mips32_gettcrestart()	        _m32c0_mfc0(2,3)
+#define mips32_settcrestart(x)	        _m32c0_mtc0(2,3,x)
+#define mips32_xchtcrestart(x)	        _m32c0_mxc0(2,3,x)
+
+#define mips32_gettchalt()	        _m32c0_mfc0(2,4)
+#define mips32_settchalt(x)	        _m32c0_mtc0(2,4,x)
+#define mips32_xchtchalt(x)	        _m32c0_mxc0(2,4,x)
+
+#define mips32_gettccontext()	        _m32c0_mfc0(2,5)
+#define mips32_settccontext(x)	        _m32c0_mtc0(2,5,x)
+#define mips32_xchtccontext(x)	        _m32c0_mxc0(2,5,x)
+
+#define mips32_gettcschedule()	        _m32c0_mfc0(2,6)
+#define mips32_settcschedule(x)	        _m32c0_mtc0(2,6,x)
+#define mips32_xchtcschedule(x)	        _m32c0_mxc0(2,6,x)
+
+#define mips32_gettcschefback()	        _m32c0_mfc0(2,7)
+#define mips32_settcschefback(x)        _m32c0_mtc0(2,7,x)
+#define mips32_xchtcschefback(x)        _m32c0_mxc0(2,7,x)
+
+#define mips32_getsrsconf0()	        _m32c0_mfc0(6,1)
+#define mips32_setsrsconf0(x)	        _m32c0_mtc0(6,1,x)
+#define mips32_xchsrsconf0(x)	        _m32c0_mxc0(6,1,x)
+
+#define mips32_getsrsconf1()	        _m32c0_mfc0(6,2)
+#define mips32_setsrsconf1(x)	        _m32c0_mtc0(6,2,x)
+#define mips32_xchsrsconf1(x)	        _m32c0_mxc0(6,2,x)
+
+#define mips32_getsrsconf2()	        _m32c0_mfc0(6,3)
+#define mips32_setsrsconf2(x)	        _m32c0_mtc0(6,3,x)
+#define mips32_xchsrsconf2(x)	        _m32c0_mxc0(6,3,x)
+
+#define mips32_getsrsconf3()	        _m32c0_mfc0(6,4)
+#define mips32_setsrsconf3(x)	        _m32c0_mtc0(6,4,x)
+#define mips32_xchsrsconf3(x)	        _m32c0_mxc0(6,4,x)
+
+#define mips32_getsrsconf4()	        _m32c0_mfc0(6,5)
+#define mips32_setsrsconf4(x)	        _m32c0_mtc0(6,5,x)
+#define mips32_xchsrsconf4(x)	        _m32c0_mxc0(6,5,x)
+
+#if !__mips16
+/* Access to other VPE/TC registers */
+
+/* move from gpr */
+#define _m32c0_mftgpr(rt) \
+__extension__ ({ \
+	unsigned long __res; \
+	__asm__ __volatile__( \
+	"%[mftgpr\t%0,$" #rt "%]" \
+		: "=d" (__res)); \
+	__res; \
+})
+
+/* move to gpr */
+#define _m32c0_mttgpr(rd,v) \
+do { \
+	__asm__ __volatile__( \
+		"%[mttgpr\t%z0,$" #rd "%]" \
+		: : "dJ" (v)); \
+} while (0)
+
+/* move from cp0 */
+#define _m32c0_mftc0(rt,sel) \
+__extension__ ({ \
+	unsigned long  __res; \
+	__asm__ __volatile__( \
+		"mftc0\t%0,$" #rt "," #sel \
+		: "=d" (__res)); \
+	__res; \
+})
+
+/* move to cp0 */
+#define _m32c0_mttc0(rd,sel,v) \
+do { \
+	__asm__ __volatile__( \
+		"%(mttc0\t %z0,$" #rd "," #sel "; ehb%)" \
+		: : "dJ" (v)); \
+} while (0)
+#endif /* ! __mips16 */
+
+/*
+ * targeted VPE register macros
+ */
+#define mips32_mt_settarget(tc) \
+	mips32_setvpecontrol ( \
+		(mips32_getvpecontrol () & ~(VPECONTROL_TARGTC)) \
+		| ((tc) << VPECONTROL_TARGTC_SHIFT))
+
+/*
+ * Before using any mips32_mt_ macros you should ensure the
+ * destination VPE and TC are set with a call to mips32_mt_settarget()
+ */
+
+/*
+ * Non-MT CP0 registers
+ */
+#define mips32_mt_getc0status()		_m32c0_mftc0(12, 0)
+#define mips32_mt_setc0status(val)	_m32c0_mttc0(12, 0, val)
+#define mips32_mt_getc0cause()		_m32c0_mftc0(13, 0)
+#define mips32_mt_setc0cause(val)	_m32c0_mttc0(13, 0, val)
+#define mips32_mt_getc0config()		_m32c0_mftc0(16, 0)
+#define mips32_mt_setc0config(val)	_m32c0_mttc0(16, 0, val)
+#define mips32_mt_getc0config1()	_m32c0_mftc0(16, 1)
+#define mips32_mt_setc0config1(val) 	_m32c0_mttc0(16, 1, val)
+#define mips32_mt_getc0ebase()		_m32c0_mftc0(15, 1)
+#define mips32_mt_setc0ebase(val)	_m32c0_mttc0(15, 1, val)
+
+/*
+ * Non-MT GPR registers
+ */
+#define mips32_mt_getsp()			_m32c0_mftgpr(29)
+#define mips32_mt_setsp(val)		_m32c0_mttgpr(29, val)
+#define mips32_mt_getgp()			_m32c0_mftgpr(28)
+#define mips32_mt_setgp(val)		_m32c0_mttgpr(28, val)
+#define mips32_mt_sett9(val)		_m32c0_mttgpr(25, val)
+
+/*
+ * VPE
+ */
+#define mips32_mt_getvpecontrol()		_m32c0_mftc0(1, 1)
+#define mips32_mt_setvpecontrol(val)	_m32c0_mttc0(1, 1, val)
+#define mips32_mt_getvpeconf0()			_m32c0_mftc0(1, 2)
+#define mips32_mt_setvpeconf0(val)		_m32c0_mttc0(1, 2, val)
+
+/*
+ * TC
+ */
+#define mips32_mt_gettcstatus() 	_m32c0_mftc0(2, 1)
+#define mips32_mt_settcstatus(val)	_m32c0_mttc0(2, 1, val)
+#define mips32_mt_gettcbind()		_m32c0_mftc0(2, 2)
+#define mips32_mt_settcbind(val)	_m32c0_mttc0(2, 2, val)
+#define mips32_mt_gettcrestart()	_m32c0_mftc0(2, 3)
+#define mips32_mt_settcrestart(val)	_m32c0_mttc0(2, 3, val)
+#define mips32_mt_gettchalt()		_m32c0_mftc0(2, 4)
+#define mips32_mt_settchalt(val)	_m32c0_mttc0(2, 4, val)
+#define mips32_mt_gettccontext()	_m32c0_mftc0(2, 5)
+#define mips32_mt_settccontext(val)	_m32c0_mttc0(2, 5, val)
+
+
+/* 
+ * MT Intrinsics
+ */
+#define mips_mt_fork(a, pv, cv)					\
+__extension__ ({						\
+    void * __a = (a);						\
+    unsigned int __cv = (cv);					\
+    unsigned int __res = (pv); 					\
+    __asm__ __volatile ("fork %0,%1,%z2"			\
+			: "+d" (__res)				\
+			: "d" (__a), "dJ" (__cv));		\
+    __res; 							\
+})
+
+#define mips_mt_yield(yq)					\
+__extension__ ({						\
+    unsigned int __yq = (yq);					\
+    unsigned int __res; 					\
+    __asm__ __volatile ("yield %0,%z1"				\
+			: "=d" (__res)				\
+			: "dJ" (__yq));				\
+    __res; 							\
+})
+
+#define mips_mt_dmt() 						\
+__extension__ ({						\
+    unsigned int __res; 					\
+    __asm__ __volatile ("dmt %0; ehb"				\
+			: "=d" (__res));			\
+    __res & VPECONTROL_TE;					\
+})
+
+#define mips_mt_emt() 						\
+__extension__ ({						\
+    unsigned int __res; 					\
+    __asm__ __volatile ("emt %0; ehb"				\
+			: "=d" (__res));			\
+    __res & VPECONTROL_TE;					\
+})
+
+#define mips_mt_dvpe() 						\
+__extension__ ({						\
+    unsigned int __res; 					\
+    __asm__ __volatile ("dvpe %0; ehb"				\
+			: "=d" (__res));			\
+    __res & MVPCONTROL_EVP;					\
+})
+
+#define mips_mt_evpe() 						\
+__extension__ ({						\ 
+    unsigned int __res; 					\
+    __asm__ __volatile ("evpe %0; ehb"				\
+			: "=d" (__res));			\
+    __res & MVPCONTROL_EVP;					\
+})
+
+#define mips32_mt_gettcschedule()          _m32c0_mftc0(2,6)
+#define mips32_mt_settcschedule(val)         _m32c0_mttc0(2,6,val)
+
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* _MIPS_MT_H_ */
diff --git a/arch/mips/include/asm/pinstrap.h b/arch/mips/include/asm/pinstrap.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/pinstrap.h
@@ -0,0 +1,12 @@
+#define FLASH_STRAP		0x1		
+#define MII_0_STRAP		0x2
+#define MII_1_STRAP		0x3
+#define ASC_STRAP		0x4
+#define SFLASH_STRAP		0x5
+#define RESERVE_STRAP		0x6
+#define PRODUCT_TEST_STRAP	0x7
+#define PIN_STRAP_MASK		0x001C0000
+#define PIN_STRAP_SHIFT		18
+#define PIN_STRAP		0xB0100914
+#define SDRAM_WIDTH_MASK	0x400000
+#define SDRAM_WIDTH_SHIFT	22
diff --git a/arch/mips/include/asm/yamon.h b/arch/mips/include/asm/yamon.h
new file mode 100644
--- /dev/null
+++ b/arch/mips/include/asm/yamon.h
@@ -0,0 +1,497 @@
+/*
+ * Values in the Company ID field
+ */
+#define K_PRIdCoID_MIPS	1
+#define K_PRIdCoID_Broadcom 2
+#define K_PRIdCoID_Alchemy 3
+#define K_PRIdCoID_SiByte 4
+#define K_PRIdCoID_SandCraft 5
+#define K_PRIdCoID_Philips 6
+#define K_PRIdCoID_Toshiba 7
+#define K_PRIdCoID_LSI 8
+#define K_PRIdCoID_Intrinsity 9
+#define K_PRIdCoID_UNANNOUNCED10 10
+#define K_PRIdCoID_Lexra 11
+#define K_PRIdCoID_UNANNOUNCED12 12
+#define K_PRIdCoID_UNANNOUNCED13 13
+#define K_PRIdCoID_NextAvailable 14 /* Next available encoding */
+
+
+/*
+ * Values in the implementation number field
+ */
+#define K_PRIdImp_4KC		0x80	/* MIPS32 4Kc with TLB MMU and Release 1 Architecture*/
+#define K_PRIdImp_Jade		0x80	/*   Alternate (obsolete) name */
+#define K_PRIdImp_5KC		0x81	/* MIPS64 5Kc/5Kf with TLB MMU and Release 1 Architecture */
+#define K_PRIdImp_Opal		0x81	/*   Alternate (obsolete) name */
+#define K_PRIdImp_20KC		0x82	/* MIPS64 20Kc with TLB MMU and Release 1 Architecture */
+#define K_PRIdImp_Ruby		0x82	/*   Alternate (obsolete) name */
+#define K_PRIdImp_4KMP		0x83	/* MIPS32 4Kp/4Km with FM MMU and Release 1 Architectur */
+#define K_PRIdImp_JadeLite	0x83	/*   Alternate (obsolete) name */
+#define K_PRIdImp_4KEc		0x84	/* MIPS32 4KEc with TLB MMU and Release 1 Architecture */
+#define K_PRIdImp_4KEmp		0x85	/* MIPS32 4KEm/4KEp with FM MMU and Release 1 Architecture */
+#define K_PRIdImp_4KSc		0x86	/* MIPS32 4KSc with TLB MMU and Release 1 Architecture */
+#define K_PRIdImp_M4K		0x87	/* MIPS32 M4K with FM MMU and Release 2 Architecture */
+#define K_PRIdImp_25Kf		0x88	/* MIPS64 25Kf with TLB MMU and Release 1 Architecture */
+#define K_PRIdImp_Amethyst	0x88	/*   Alternate (obsolete) name */
+#define K_PRIdImp_5KE		0x89	/* MIPS64 5KE with TLB MMU and Release 2 Architecture */
+#define K_PRIdImp_4KEc_R2	0x90	/* MIPS32 4KEc with TLB MMU and Release 2 Architecture */
+#define K_PRIdImp_4KEmp_R2	0x91	/* MIPS32 4KEm/4KEp with FM MMU and Release 2 Architecture */
+#define K_PRIdImp_4KSd		0x92	/* MIPS32 4KSd with TLB MMU and Release 2 Architecture */
+
+#define K_PRIdImp_24K		0x93	/* MIPS32 24K (Topaz) with Release 2 Architecture */
+#define K_PRIdImp_Topaz		0x93	/*   Alternate (obsolete) name */
+#define K_PRIdImp_TopazTLB	0x93	/*   Alternate (obsolete) name */
+
+#define K_PRIdImp_34K		0x95	/* MIPS32 34K */
+#define K_PRIdImp_24KE		0x96	/* MIPS32 24KE */
+
+#define K_PRIdImp_R3000		0x01
+#define K_PRIdImp_R4000		0x04
+#define K_PRIdImp_R10000	0x09
+#define K_PRIdImp_R4300		0x0b
+#define K_PRIdImp_R5000		0x23
+#define K_PRIdImp_R5200		0x28
+#define K_PRIdImp_R5400		0x54
+
+
+
+/*  We use ssnop instead of nop operations in order to handle 
+ *  superscalar CPUs.
+ *  The "sll zero,zero,1" notation is compiler backwards compatible.
+ */
+#define SSNOP   sll zero,zero,1
+#define EHB     sll zero,zero,3
+#define NOPS	SSNOP; SSNOP; SSNOP; EHB
+
+/*  Workaround for bug in early revisions of MIPS 4K family of 
+ *  processors.
+ *
+ *  This concerns the nop instruction before mtc0 in the 
+ *  MTC0 macro below.
+ *
+ *  The bug is described in :
+ *
+ *  MIPS32 4K(tm) Processor Core Family RTL Errata Sheet
+ *  MIPS Document No: MD00003
+ *
+ *  The bug is identified as : C27
+ */
+
+#define MTC0(src, dst)       \
+		nop;	     \
+	        mtc0 src,dst;\
+		NOPS
+
+#define DMTC0(src, dst)       \
+		nop;	      \
+	        dmtc0 src,dst;\
+		NOPS
+
+#define MFC0(dst, src)       \
+	  	mfc0 dst,src
+
+#define DMFC0(dst, src)       \
+	  	dmfc0 dst,src
+
+#define MFC0_SEL_OPCODE(dst, src, sel)\
+	  	.##word (0x40000000 | ((dst)<<16) | ((src)<<11) | (sel))
+
+#define MTC0_SEL_OPCODE(src, dst, sel)\
+	  	.##word (0x40800000 | ((src)<<16) | ((dst)<<11) | (sel));\
+		NOPS
+
+#define LDC1(dst, src, offs)\
+		.##word (0xd4000000 | ((src)<<21) | ((dst)<<16) | (offs))
+
+#define SDC1(src, dst, offs)\
+		.##word (0xf4000000 | ((dst)<<21) | ((src)<<16) | (offs))
+
+
+/*
+ * Cache attribute values in the C field of EntryLo and the
+ * K0 field of Config
+ */
+#define K_CacheAttrCWTnWA	0			/* Cacheable, write-thru, no write allocate */
+#define K_CacheAttrCWTWA	1			/* Cacheable, write-thru, write allocate */
+#define K_CacheAttrU		2			/* Uncached */
+#define K_CacheAttrC		3			/* Cacheable */
+#define K_CacheAttrCN		3			/* Cacheable, non-coherent */
+#define K_CacheAttrCCE		4			/* Cacheable, coherent, exclusive */
+#define K_CacheAttrCCS		5			/* Cacheable, coherent, shared */
+#define K_CacheAttrCCU		6			/* Cacheable, coherent, update */
+#define K_CacheAttrUA		7			/* Uncached accelerated */
+
+/*
+ * The following definitions are technically part of the "reserved for
+ * implementations" field, but are the semi-standard definition used in
+ * fixed-mapping MMUs to control the cacheability of kuseg and kseg2/3
+ * references.  For that reason, they are included here, but may be
+ * overridden by true implementation-specific definitions
+ */
+#define S_ConfigK23		28			/* Kseg2/3 coherency algorithm (FM MMU only) (R/W) */
+#define M_ConfigK23		(0x7 << S_ConfigK23)
+#define W_ConfigK23		3
+#define S_ConfigKU		25			/* Kuseg coherency algorithm (FM MMU only) (R/W) */
+#define M_ConfigKU		(0x7 << S_ConfigKU)
+#define W_ConfigKU		3
+
+#define S_ConfigK0		0			/* Kseg0 coherency algorithm (R/W) */
+#define M_ConfigK0		(0x7 << S_ConfigK0)
+
+
+/*
+ ************************************************************************
+ *                T A G L O   R E G I S T E R   ( 2 8 )                 * TagLo
+ ************************************************************************
+ * 	
+ *  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                            TagLo                              | TagLo
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+#define C0_TagLo		$28
+#define R_C0_TagLo		28
+#define R_C0_SelTagLo		0
+
+/*
+ ************************************************************************
+ *                T A G H I   R E G I S T E R   ( 2 9 )                 * TagHi
+ ************************************************************************
+ * 	
+ *  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                            TagHi                              | TagHi
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+#define C0_TagHi		$29
+#define R_C0_TagHi		29
+#define R_C0_SelTagHi		0
+
+
+
+/*
+ ************************************************************************
+ *               S T A T U S   R E G I S T E R   ( 1 2 )                *
+ ************************************************************************
+ * 	
+ *  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |C|C|C|C|R|F|R|M|P|B|T|S|M| | R |I|I|I|I|I|I|I|I|K|S|U|U|R|E|E|I|
+ * |U|U|U|U|P|R|E|X|X|E|S|R|M| | s |M|M|M|M|M|M|M|M|X|X|X|M|s|R|X|E| Status
+ * |3|2|1|0| | | | | |V| | |I| | v |7|6|5|4|3|2|1|0| | | | |v|L|L| |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+#define C0_Status		$12
+
+/*
+ ************************************************************************
+ *                  P R I D   R E G I S T E R   ( 1 5 )                 *
+ ************************************************************************
+ * 	
+ *  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |  Company Opts |   Company ID  |  Procesor ID  |   Revision    | PRId
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+#define C0_PRId			$15
+
+
+/*
+ ************************************************************************
+ *               C O N F I G   R E G I S T E R   ( 1 6 )                *
+ ************************************************************************
+ * 	
+ *  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |M|                             |B| A |  A  |  M  |RSVD |V|  K  | Config
+ * | | Reserved for Implementations|E| T |  R  |  T  |     |I|  0  |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+#define C0_Config		$16
+
+#define S_StatusBEV		22			/* Enable Boot Exception Vectors (R/W) */
+#define M_StatusBEV		(0x1 << S_StatusBEV)
+
+#define S_StatusFR		26			/* Enable 64-bit FPRs (R/W) */
+#define M_StatusFR		(0x1 << S_StatusFR)
+
+#ifdef KSEG0_UNCACHED
+#define CONFIG0_MIPS32_64    (K_CacheAttrU << S_ConfigK0)
+#else
+#define CONFIG0_MIPS32_64    (K_CacheAttrCN << S_ConfigK0)
+//#define CONFIG0_MIPS32_64    (K_CacheAttrCWTnWA << S_ConfigK0)
+#endif
+
+
+/*
+ ************************************************************************
+ *         C O N F I G 1   R E G I S T E R   ( 1 6, SELECT 1 )          *
+ ************************************************************************
+ * 	
+ *  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+ *  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |M|  MMU Size |  IS |  IL |  IA |  DS |  DL |  DA |C|M|P|W|C|E|F| Config1
+ * | |           |     |     |     |     |     |     |2|D|C|R|A|P|P|
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+#define C0_Config1		$16,1
+#define R_C0_Config1		16
+#define R_C0_SelConfig1		1
+
+
+
+/* MIPS32/MIPS64 specifics */
+
+/*  Setup of STATUS register used for MIPS32/MIPS64 processors
+ *  FR field only relevant for MIPS64 (Read only for MIPS32)
+ */
+#define STATUS_MIPS32_64   (M_StatusBEV | M_StatusFR)
+
+/*  Generic MIPS32/MIPS64 fields of STATUS register (ie the ones not 
+ *  reserved for implementations)
+ */
+#define STATUS_MIPS32_64_MSK   0xfffcffff
+
+
+/*  Generic MIPS32/MIPS64 fields of CONFIG0 register (ie the ones not
+ *  reserved for implementations)
+ */
+#define CONFIG0_MIPS32_64_MSK  0x8000ffff
+
+/* MIPS 4K/5K family specifics (excluding generic MIPS32/MIPS64 fields) */
+#define STATUS_MIPS4K5K	    0
+#define CONFIG0_MIPS4K5K ((K_CacheAttrCN << S_ConfigK23) |\
+			  (K_CacheAttrCN << S_ConfigKU))
+
+#define S_ConfigMM              18     /* 24K specific, merging enable/disable */
+#define M_ConfigMM              (0x1 << S_ConfigMM)
+		  
+/* MIPS 34K specifics */
+#define STATUS_MIPS34K	    0
+#define CONFIG0_MIPS34K  ((K_CacheAttrCN << S_ConfigK23) |\
+			  (K_CacheAttrCN << S_ConfigKU)  |\
+			  (M_ConfigMM))
+
+
+#define S_PRIdCoID		16			/* Company ID (R) */
+#define M_PRIdCoID		(0xff << S_PRIdCoID)
+#define S_PRIdImp		8			/* Implementation ID (R) */
+#define M_PRIdImp		(0xff << S_PRIdImp)
+
+#define MIPS_4Kc			( (K_PRIdCoID_MIPS << S_PRIdCoID) | \
+					  (K_PRIdImp_Jade  << S_PRIdImp) )
+
+#define MIPS_4KEc			( (K_PRIdCoID_MIPS << S_PRIdCoID) | \
+					  (K_PRIdImp_4KEc  << S_PRIdImp) )
+
+#define MIPS_24KE           ( (K_PRIdCoID_MIPS << S_PRIdCoID) | \
+                      (K_PRIdImp_24KE   << S_PRIdImp) )
+										  
+
+#define MIPS_34K			( (K_PRIdCoID_MIPS << S_PRIdCoID) | \
+					  (K_PRIdImp_34K   << S_PRIdImp) )
+
+#define S_Config1IS		22			/* Icache sets per way (R) */
+#define M_Config1IS		(0x7 << S_Config1IS)
+#define S_Config1IL		19			/* Icache line size (R) */
+#define M_Config1IL		(0x7 << S_Config1IL)
+#define S_Config1IA		16			/* Icache associativity - 1 (R) */
+#define M_Config1IA		(0x7 << S_Config1IA)
+					  
+#define S_Config1DS		13			/* Dcache sets per way (R) */
+#define M_Config1DS		(0x7 << S_Config1DS)
+#define W_Config1DS		3
+#define S_Config1DL		10			/* Dcache line size (R) */
+#define M_Config1DL		(0x7 << S_Config1DL)
+#define W_Config1DL		3
+#define S_Config1DA		7			/* Dcache associativity (R) */
+#define M_Config1DA		(0x7 << S_Config1DA)
+
+
+/*
+ *************************************************************************
+ *                H A R D W A R E   G P R   I N D I C E S                *
+ *************************************************************************
+ *
+ * These definitions provide the index (number) of the GPR, as opposed
+ * to the assembler register name ($n).
+ */
+
+#define R_r0			 0
+#define R_r1			 1
+#define R_r2			 2
+#define R_r3			 3
+#define R_r4			 4
+#define R_r5			 5
+#define R_r6			 6
+#define R_r7			 7
+#define R_r8			 8
+#define R_r9			 9
+#define R_r10			10
+#define R_r11			11
+#define R_r12			12
+#define R_r13			13
+#define R_r14			14
+#define R_r15			15
+#define R_r16			16
+#define R_r17			17
+#define R_r18			18
+#define R_r19			19
+#define R_r20			20
+#define R_r21			21
+#define R_r22			22
+#define R_r23			23
+#define R_r24			24
+#define R_r25			25
+#define R_r26			26
+#define R_r27			27
+#define R_r28			28
+#define R_r29			29
+#define R_r30			30
+#define R_r31			31
+#define R_hi			32			/* Hi register */
+#define R_lo			33			/* Lo register */
+
+
+/*
+ *************************************************************************
+ *                S O F T W A R E   G P R   I N D I C E S                *
+ *************************************************************************
+ *
+ * These definitions provide the index (number) of the GPR, as opposed
+ * to the assembler register name ($n).
+ */
+
+#define R_zero			 0
+#define R_AT			 1
+#define R_v0			 2
+#define R_v1			 3
+#define R_a0			 4
+#define R_a1			 5
+#define R_a2			 6
+#define R_a3			 7
+#define R_t0			 8
+#define R_t1			 9
+#define R_t2			10
+#define R_t3			11
+#define R_t4			12
+#define R_t5			13
+#define R_t6			14
+#define R_t7			15
+#define R_s0			16
+#define R_s1			17
+#define R_s2			18
+#define R_s3			19
+#define R_s4			20
+#define R_s5			21
+#define R_s6			22
+#define R_s7			23
+#define R_t8			24
+#define R_t9			25
+#define R_k0			26
+#define R_k1			27
+#define R_gp			28
+#define R_sp			29
+#define R_fp			30
+#define R_s8			30
+#define R_ra			31
+
+
+/* cache operations */
+
+#define CACHE_OP( code, type )			( ((code) << 2) | (type) )
+
+#define ICACHE_INDEX_INVALIDATE			CACHE_OP(0x0, 0)
+#define ICACHE_INDEX_LOAD_TAG			CACHE_OP(0x1, 0)
+#define ICACHE_INDEX_STORE_TAG			CACHE_OP(0x2, 0)
+#define DCACHE_INDEX_WRITEBACK_INVALIDATE	CACHE_OP(0x0, 1)
+#define DCACHE_INDEX_LOAD_TAG			CACHE_OP(0x1, 1)
+#define DCACHE_INDEX_STORE_TAG			CACHE_OP(0x2, 1)
+#define SCACHE_INDEX_WRITEBACK_INVALIDATE	CACHE_OP(0x0, 3)
+#define SCACHE_INDEX_STORE_TAG			CACHE_OP(0x2, 3)
+
+#define ICACHE_ADDR_HIT_INVALIDATE		CACHE_OP(0x4, 0)
+#define ICACHE_ADDR_FILL			CACHE_OP(0x5, 0)
+#define ICACHE_ADDR_FETCH_LOCK			CACHE_OP(0x7, 0)
+#define DCACHE_ADDR_HIT_INVALIDATE		CACHE_OP(0x4, 1)
+#define DCACHE_ADDR_HIT_WRITEBACK_INVALIDATE	CACHE_OP(0x5, 1)
+#define DCACHE_ADDR_HIT_WRITEBACK		CACHE_OP(0x6, 1)
+#define DCACHE_ADDR_FETCH_LOCK			CACHE_OP(0x7, 1)
+
+#define SCACHE_ADDR_HIT_WRITEBACK_INVALIDATE	CACHE_OP(0x5, 3)
+
+/*  Workaround for bug in early revisions of MIPS 4K family of 
+ *  processors. Only relevant in early engineering samples of test
+ *  chips (RTL revision <= 3.0).
+ *
+ *  The bug is described in :
+ *
+ *  MIPS32 4K(tm) Processor Core Family RTL Errata Sheet
+ *  MIPS Document No: MD00003
+ *
+ *  The bug is identified as : C16
+ */
+#define ICACHE_INVALIDATE_WORKAROUND(reg) \
+SET_PUSH();				  \
+SET_MIPS0();				  \
+	la     reg, 999f;		  \
+SET_POP();				  \
+	cache  ICACHE_ADDR_FILL, 0(reg);  \
+	sync;				  \
+	nop; nop; nop; nop;		  \
+999:
+
+#define ICACHE_INDEX_INVALIDATE_OP(index,scratch)		  \
+	    ICACHE_INVALIDATE_WORKAROUND(scratch);		  \
+	    cache ICACHE_INDEX_INVALIDATE, 0(index)
+
+#define ICACHE_ADDR_INVALIDATE_OP(addr,scratch)			  \
+	    ICACHE_INVALIDATE_WORKAROUND(scratch);		  \
+	    cache ICACHE_ADDR_HIT_INVALIDATE, 0(addr)
+
+#define SCACHE_ADDR_HIT_WB_INVALIDATE_OP(reg)			  \
+	    cache   SCACHE_ADDR_HIT_WRITEBACK_INVALIDATE, 0(reg);
+
+#define SCACHE_INDEX_WRITEBACK_INVALIDATE_OP(reg)			  \
+	    cache   SCACHE_INDEX_WRITEBACK_INVALIDATE, 0(reg);
+
+/* Config1 cache field decoding */
+#define CACHE_CALC_SPW(s)	( 64 << (s) )
+#define CACHE_CALC_LS(l)	( (l) ? 2 << (l) : 0 )
+#define CACHE_CALC_BPW(l,s)	( CACHE_CALC_LS(l) * CACHE_CALC_SPW(s) )
+#define CACHE_CALC_ASSOC(a)	( (a) + 1 )
+
+#define R_C0_ITagLo		28
+#define R_C0_SelITagLo		0
+
+#define R_C0_DTagLo	        28
+#define R_C0_SelDTagLo	        2
+#define R_C0_DTagHi	        29
+#define R_C0_SelDTagHi	        2
+
+#if 0					  
+#define DISP_STR( s );\
+		la   a0, s;\
+		move t8, ra;\
+		jal  asc_puts_asm;\
+		nop;\
+		move ra, t8
+
+#define MSG( name, s ) \
+	.##align 3;      \
+name:   .##asciiz  s
+
+MSG( hello_infineon, "\n\n\nhello_infineon\n\n");
+#endif
diff --git a/include/common.h b/include/common.h
--- a/include/common.h
+++ b/include/common.h
@@ -262,6 +262,14 @@ int	saveenv	     (void);
 int inline setenv   (char *, char *);
 #else
 int	setenv	     (char *, char *);
+
+#ifdef CONFIG_CMD_UBI
+int ubi_create_vol(char *volume, int size, int dynamic, int vol_id);
+int ubi_remove_vol(char *volume);
+int ubi_volume_write(char *volume, void *buf, size_t size);
+int ubi_volume_read(char *volume, char *buf, size_t size);
+#endif
+
 #ifdef CONFIG_HAS_UID
 void	forceenv     (char *, char *);
 #endif
diff --git a/include/configs/lq_extra_env.h b/include/configs/lq_extra_env.h
new file mode 100755
--- /dev/null
+++ b/include/configs/lq_extra_env.h
@@ -0,0 +1,119 @@
+  "mem="CONFIG_MEM"\0"                              
+  "phym="CONFIG_PHYM"\0"                            
+#ifdef CONFIG_DRIVER_AR10
+  "wlanm="CONFIG_WLANM"\0"
+#endif
+  "ipaddr=" CONFIG_IP_ADDRESS "\0"                  
+  "serverip=" CONFIG_SERVER_IP_ADDRESS "\0"         
+  "ethaddr=" CONFIG_ETHERNET_ADDRESS "\0"           
+  "sup_mac=" CONFIG_NUMBER_OF_MAC_SUPPORTED "\0"           
+  "res_mac=" CONFIG_NUMBER_OF_MAC_RESERVED "\0" 
+  "netdev=" CONFIG_ETHERNET_DEVICE "\0"             
+  "console="CONFIG_CONSOLE"\0"                      
+  "tftppath="CONFIG_TFTPPATH"\0"                    
+  "loadaddr=" CONFIG_TFTP_LOAD_ADDRESS "\0"         
+  "rootpath="CONFIG_ROOT_PATH "\0"                  
+  "rootfsmtd="CONFIG_ROOTFSMTD"\0"                  
+  "nfsargs= "CONFIG_NFSARGS"\0"                     
+  "ramargs="CONFIG_RAMARGS"\0"                      
+  "addip="CONFIG_ADDIP"\0"                          
+  "addmisc="CONFIG_ADDMISC" \0"                     
+  "flash_nfs="CONFIG_FLASH_NFS"\0"                  
+  "net_nfs="CONFIG_NET_NFS"\0"                      
+  "net_flash="CONFIG_NET_FLASH"\0"                  
+  "net_ram="CONFIG_NET_RAM"\0"                      
+  "u-boot="CONFIG_U_BOOT"\0"                        
+  "rootfs="CONFIG_ROOTFS"\0"                        
+  "firmware="CONFIG_FIRMWARE"\0"                    
+  "fullimage="CONFIG_FULLIMAGE"\0"                  
+  "totalimage="CONFIG_TOTALIMAGE"\0"                
+  "load=tftp $(loadaddr) $(u-boot)\0"               
+  "update=protect off 1:0-2;era 1:0-2;cp.b $(loadaddr) B0000000 $(filesize)\0"  
+  "flashargs="CONFIG_FLASHARGS"\0"                  
+  "flash_flash="CONFIG_FLASH_FLASH"\0"              
+#if defined(CONFIG_BOOT_FROM_NAND) || defined(CONFIG_SPI_WITH_NAND)  
+  "update_nandboot="CONFIG_UPDATE_NANDBOOT"\0"
+ #ifdef CONFIG_CMD_UBI
+  "ubi_init="CONFIG_UBI_INIT"\0"
+ #ifdef CONFIG_DUAL_IMAGE
+  "update_chk="CONFIG_UPDATE_CHK"\0"
+  "switchbankA="CONFIG_SWITCH_BANKA"\0"
+  "switchbankB="CONFIG_SWITCH_BANKB"\0"
+  "check_image0="CONFIG_CHECK_IMAGE0"\0"
+  "check_image1="CONFIG_CHECK_IMAGE1"\0"
+  "check_image2="CONFIG_CHECK_IMAGE2"\0"
+  "check_image3="CONFIG_CHECK_IMAGE3"\0"
+ #endif
+ #endif  
+#endif
+  "update_uboot="CONFIG_UPDATE_UBOOT"\0"            
+  "update_kernel="CONFIG_UPDATE_KERNEL"\0"          
+  "update_bootloader="CONFIG_UPDATE_BOOTLOADER"\0"
+  "update_rootfs="CONFIG_UPDATE_ROOTFS"\0"          
+#ifdef CONFIG_UPDATE_FIRMWARE
+  "update_firmware="CONFIG_UPDATE_FIRMWARE"\0"      
+#endif 
+  "update_fullimage="CONFIG_UPDATE_FULLIMAGE"\0"    
+  "update_totalimage="CONFIG_UPDATE_TOTALIMAGE"\0"  
+#if defined(CONFIG_DRIVER_VR9) && !defined(CONFIG_VR9_GPHY_FW_EMBEDDED)
+  "update_gphyfirmware="CONFIG_UPDATE_GPHYFIRMWARE"\0"
+  "gphy_fw_addr="MK_STR(CONFIG_VR9_EXTERN_GPHY_FW_ADDR)"\0"
+#endif
+#if defined(CONFIG_DRIVER_AR10) && !defined(CONFIG_AR10_GPHY_FW_EMBEDDED)
+  "update_gphyfirmware="CONFIG_UPDATE_GPHYFIRMWARE"\0"
+  "gphy_fw_addr="MK_STR(CONFIG_AR10_EXTERN_GPHY_FW_ADDR)"\0"
+#endif
+#if defined(CONFIG_DRIVER_HN1) && !defined(CONFIG_HN1_GPHY_FW_EMBEDDED)
+  "update_gphyfirmware="CONFIG_UPDATE_GPHYFIRMWARE"\0"
+  "gphy_fw_addr="MK_STR(CONFIG_HN1_EXTERN_GPHY_FW_ADDR)"\0"
+#endif
+#ifndef CONFIG_ENV_IS_NOWHERE 
+  "reset_uboot_config="CONFIG_RESET_UBOOT_CONFIG"\0" 
+  "reset_ddr_config="CONFIG_RESET_DDR_CONFIG"\0" 
+  "mtdparts="CONFIG_MTDPARTS"\0"                     
+  IFX_CFG_FLASH_PARTITIONS_INFO   
+  "flash_end=" MK_STR(IFX_CFG_FLASH_END_ADDR) "\0"   
+  IFX_CFG_FLASH_DATA_BLOCKS_INFO  
+  "f_uboot_addr=" MK_STR(IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR) "\0"      
+  "f_uboot_size=" MK_STR(IFX_CFG_FLASH_UBOOT_IMAGE_SIZE) "\0"            
+  "f_ubootconfig_addr=" MK_STR(CONFIG_ENV_OFFSET) "\0"  
+  "f_ubootconfig_size=" MK_STR(CONFIG_ENV_SIZE) "\0"        
+  "f_ubootconfig_end=" MK_STR(IFX_CFG_FLASH_UBOOT_CFG_END_ADDR) "\0"     
+#ifdef CONFIG_BOOT_FROM_NAND
+  "f_ubootconfig_range=" MK_STR(CONFIG_ENV_RANGE) "\0"
+#ifdef CONFIG_ENV_REDUND
+  "f_red_ubootconfig_addr=" MK_STR(CONFIG_ENV_OFFSET_REDUND) "\0"
+#endif
+#endif
+  "f_gphy_firmware_addr=" MK_STR(IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_START_ADDR) "\0"    
+  "f_gphy_firmware_size=" MK_STR(IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_SIZE) "\0"          
+  "f_gphy_firmware_end=" MK_STR(IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_END_ADDR) "\0"       
+  "f_kernel_addr=" MK_STR(IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR) "\0"    
+  "f_kernel_size=" MK_STR(IFX_CFG_FLASH_KERNEL_IMAGE_SIZE) "\0"          
+  "f_kernel_end=" MK_STR(IFX_CFG_FLASH_KERNEL_IMAGE_END_ADDR) "\0"       
+  "f_rootfs_addr=" MK_STR(IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR) "\0"    
+  "f_rootfs_size=" MK_STR(IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE) "\0"          
+  "f_rootfs_end=" MK_STR(IFX_CFG_FLASH_ROOTFS_IMAGE_END_ADDR) "\0"     
+#ifndef CONFIG_FIRMWARE_IN_ROOTFS  
+  "f_firmware_addr=" MK_STR(IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR) "\0" 
+  "f_firmware_size=" MK_STR(IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE) "\0"       
+#endif
+  "f_fwdiag_addr=" MK_STR(IFX_CFG_FLASH_FIRMWARE_DIAG_START_ADDR) "\0"
+  "f_fwdiag_size=" MK_STR(IFX_CFG_FLASH_FIRMWARE_DIAG_SIZE) "\0"
+  "f_sysconfig_addr=" MK_STR(IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR) "\0"    
+  "f_sysconfig_size=" MK_STR(IFX_CFG_FLASH_SYSTEM_CFG_SIZE) "\0"          
+  "f_dectconfig_addr=" MK_STR(IFX_CFG_FLASH_DECT_CFG_START_ADDR) "\0"    
+  "f_dectconfig_size=" MK_STR(IFX_CFG_FLASH_DECT_CFG_SIZE) "\0"          
+  "f_wlanconfig_addr= " MK_STR(IFX_CFG_FLASH_WLAN_CFG_START_ADDR) "\0"  
+  "f_wlanconfig_size=" MK_STR(IFX_CFG_FLASH_WLAN_CFG_SIZE) "\0"  
+  "f_ddrconfig_addr=" MK_STR(IFX_CFG_FLASH_DDR_CFG_START_ADDR) "\0"       
+  "f_ddrconfig_size=" MK_STR(IFX_CFG_FLASH_DDR_CFG_SIZE) "\0"             
+  "f_ddrconfig_end=" MK_STR(IFX_CFG_FLASH_DDR_CFG_END_ADDR) "\0"        
+#ifdef CONFIG_OVERLAY
+  "f_overlay_addr=" MK_STR(IFX_CFG_FLASH_OVERLAY_IMAGE_START_ADDR) "\0"       
+  "f_overlay_size=" MK_STR(IFX_CFG_FLASH_OVERLAY_IMAGE_SIZE) "\0"   
+  "f_overlay_end=" MK_STR(IFX_CFG_FLASH_OVERLAY_IMAGE_END_ADDR) "\0"
+#endif
+#endif
+  ""
+	
