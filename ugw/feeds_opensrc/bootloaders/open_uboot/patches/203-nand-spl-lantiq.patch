# HG changeset patch
# Parent cfb1cfd603b56cc538f79127a53671c55fe9ca9a
nand_spl layer for nand flash u-boot

diff --git a/nand_spl/board/lantiq/Makefile b/nand_spl/board/lantiq/Makefile
new file mode 100644
--- /dev/null
+++ b/nand_spl/board/lantiq/Makefile
@@ -0,0 +1,441 @@
+
+CONFIG_NAND_SPL	= y
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/lantiq/config.mk
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/lantiq/u-boot.lds
+LDFLAGS	= -Bstatic -T $(nandobj)u-boot.lds -Ttext $(CONFIG_NAND_SPL_TEXT_BASE) $(PLATFORM_LDFLAGS)
+AFLAGS	+=-mabicalls -fpic -DCONFIG_NAND_SPL -I$(TOPDIR)/board/$(BOARD)/
+CFLAGS	+=-mabicalls -fpic -DCONFIG_NAND_SPL -I$(TOPDIR)/board/$(BOARD)/
+
+SOBJS	= start.o lowlevel_init.o 
+COBJS	= nand_boot.o lq_nand.o board.o asc.o clock.o string.o time.o
+
+ifdef CONFIG_LANTIQ_UBOOT_grx500
+COBJS += crc32.o
+ifdef CONFIG_NAND_ECC_BCH
+ COBJS += nand_bch.o bch.o
+endif
+ifdef CONFIG_NAND_ECC_SOFT 
+ COBJS += nand_ecc.o
+endif
+ifdef CONFIG_SPINAND_LANTIQ
+ COBJS +=$(TOPDIR)/drivers/spi/lq_spi.o
+endif 
+ COBJS +=$(TOPDIR)/arch/mips/cpu/grx500/libmips.a
+
+else
+ COBJS += nand_ecc.o
+endif
+
+ifdef CONFIG_NAND_BENAND
+BCH_VAL = 0
+else
+BCH_VAL = 8
+endif
+
+spinandflag-${CONFIG_GIGA_DEVICE_SPINAND}=--gdsnand 
+
+ifdef CONFIG_TUNE_DDR
+COBJS  +=tune_ddr.o
+endif
+
+ifdef CONFIG_NAND_SPL_BBT
+COBJS  +=nand_bbt.o
+endif
+
+ifndef CONFIG_DRIVER_GRX500
+ifdef CONFIG_NAND_ECC_HW_REED_SOLOMON
+COBJS  += cache.o
+endif
+endif
+
+ifeq (${CONFIG_ENABLE_DDR_DCDC},y) 
+COBJS	+= ddr_dcdc.o
+endif
+
+ifeq ($(CONFIG_LTQ_SECURE_BOOT)$(CONFIG_DRIVER_VR9)$(DRIVER_AR10),yy)
+COBJS  += deu_aes.o 
+ifndef  CONFIG_NAND_ECC_HW_REED_SOLOMON
+COBJS  += cache.o
+endif
+endif
+
+
+
+#### grx500 secure boot configuration
+
+SIGN_IMAGE_OPT :=
+
+ifeq ($(CONFIG_LTQ_SECURE_BOOT)$(CONFIG_LANTIQ_UBOOT_grx500),yy)
+    ifdef CONFIG_CERTIFICATION_SUPPORT
+        SIGN_IMAGE_OPT += -cert $(CONFIG_CERTIFICATION)
+    endif
+
+    ifeq ($(CONFIG_MANUBOOT)$(CONFIG_MANUBOOT_CREDENTIAL_SUPPORT),yy)
+        SIGN_IMAGE_OPT += -cred $(CONFIG_MANUBOOT_CREDENTIAL)
+    endif
+
+    ifeq ($(CONFIG_MANUBOOT)$(CONFIG_MANUBOOT_OTP_SUPPORT)$(CONFIG_GRX500_BOOT_4KEC_ONLY),yy)
+        COBJS   += otp.o
+        CFLAGS += -DOTP_IN_FSB
+    endif
+endif
+
+#### end grx500 secure boot configuration
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(OBJTREE)/nand_spl/board/lantiq
+
+nandobj	:= $(OBJTREE)/nand_spl/board/lantiq
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-16k.bin 
+
+all:	$(obj).depend $(ALL)
+	@rm -f u-boot-spl.bin u-boot-spl-16k.bin 
+	@ln -s $(nandobj)u-boot-spl.bin $(TOPDIR)/nand_spl/u-boot-spl.bin
+	@ln -s $(nandobj)u-boot-spl-16k.bin $(TOPDIR)/nand_spl/u-boot-spl-16k.bin
+
+ifdef CONFIG_NAND_PRELOAD
+ALL +=nandpreload.bin
+
+LDFLAGS_NANDPRELOAD = -Bstatic -T nandpreload.lds -Ttext $(CONFIG_NAND_PRELOAD_TEXT_BASE)
+OBJS_NANDPRELOAD =  start_nandpreload.o
+OBJS_NANDPRELOAD += nand_preload.o
+
+nandpreload.bin: nandpreload
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+nandpreload:  $(OBJS_NANDPRELOAD)
+	$(LD) $(LDFLAGS_NANDPRELOAD) $(OBJS_NANDPRELOAD) -Map nandpreload.map -o nandpreload
+	$(OBJDUMP) -S -d nandpreload > nandpreload.dis				
+
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl.bin nandpreload.bin
+	touch dummy
+	$(TOPDIR)/scripts_platform/mk_sf.pl dummy nandpreload.bin $(CONFIG_NAND_PRELOAD_TEXT_BASE) $(nandobj)u-boot-spl-16k.bin
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 512 $(nandobj)u-boot-spl-16k.bin
+	cat $(nandobj)u-boot-spl.bin >> $(nandobj)u-boot-spl-16k.bin
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_SPL_BLOCK_SIZE) $(nandobj)u-boot-spl-16k.bin 
+else
+
+ifeq ($(CONFIG_NAND_ECC_HW_REED_SOLOMON)$(CONFIG_LANTIQ_UBOOT_ar10),yy) #hack to break specific Reed Solomon option , we don't need to differentiate in grx500
+ifdef CONFIG_LTQ_SECURE_BOOT
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl.bin stools
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 0x6000 $(nandobj)u-boot-spl.bin
+	cat $(TOPDIR)/stage2_key.bin >>$(nandobj)u-boot-spl.bin
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 32 $(nandobj)u-boot-spl.bin
+	./stools -i $(nandobj)u-boot-spl.bin -o u-boot-spl.enc -e 0xbe1a0030 -d 0xbe1a0000 -j 0xbe1a0000 \
+	-k $(CONFIG_AES_KEY)
+	$(TOPDIR)/scripts_platform/mk_mlc_image.pl u-boot-spl.enc $(nandobj)u-boot-spl-32k.bin
+	$(TOPDIR)/scripts_platform/swap_bin.pl $(nandobj)u-boot-spl-32k.bin $(nandobj)u-boot-spl-16k.bin
+	$(TOPDIR)/scripts_platform/duplicate.sh $(CONFIG_MLC_NAND_HEADER_NUMBER) $(nandobj)u-boot-spl-16k.bin
+else #not secure boot
+ifdef CONFIG_LANTIQ_UBOOT_grx500
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl.bin
+	$(TOPDIR)/scripts_platform/mk_ltq_header.pl --ddr $(TOPDIR)/board/$(BOARD)/ddr.conf \
+          --bch 8 --col 2 --row 3 --blocksize $(CONFIG_NAND_BLOCK_SIZE) --pagesize $(CONFIG_NAND_PAGE_SIZE)\
+          --offset $(CONFIG_NAND_PAGE_SIZE) --out header.ltq
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 1760 header.ltq
+	$(HOSTCC) -o bch_enc $(TOPDIR)/board/$(BOARD)/bch_enc.c
+	./bch_enc header.ltq header.bch $(CONFIG_GRX500_ROM_HEADER_BCH_CAP)
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_PAGE_SIZE) header.bch
+	$(TOPDIR)/scripts_platform/mk_sf_image.pl -i $(nandobj)u-boot-spl.bin -o output.bin -j $(CONFIG_NAND_SPL_TEXT_BASE) -m 0
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 440 output.bin
+	./bch_enc output.bin output.bch 8
+	cp header.bch $(nandobj)u-boot-spl-16k.bin
+	cat output.bch >>$(nandobj)u-boot-spl-16k.bin
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_SPL_BLOCK_SIZE) $(nandobj)u-boot-spl-16k.bin
+else
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl.bin
+	$(TOPDIR)/scripts_platform/mk_mlc_image.pl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-32k.bin
+	$(TOPDIR)/scripts_platform/swap_bin.pl $(nandobj)u-boot-spl-32k.bin $(nandobj)u-boot-spl-16k.bin
+	$(TOPDIR)/scripts_platform/duplicate.sh $(CONFIG_MLC_NAND_HEADER_NUMBER) $(nandobj)u-boot-spl-16k.bin 
+endif
+endif
+else  #not using REED_SOLOMON
+ifdef CONFIG_LTQ_SECURE_BOOT
+ifdef CONFIG_LANTIQ_UBOOT_vr9
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl.bin stools ds_crypt.bin
+	touch dummy
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 0x6000 $(nandobj)u-boot-spl.bin
+	cat $(TOPDIR)/stage2_key.bin >>$(nandobj)u-boot-spl.bin
+	./stools -i $(nandobj)u-boot-spl.bin -o nand_spl.enc -d ./ds_crypt.bin -a $(CONFIG_NAND_SPL_TEXT_BASE) -k $(CONFIG_AES_KEY) -s
+	$(TOPDIR)/scripts_platform/mk_sf.pl dummy nand_spl.enc $(CONFIG_NAND_SPL_TEXT_BASE) $(nandobj)u-boot-spl-16k.bin
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_SPL_BLOCK_SIZE) $(nandobj)u-boot-spl-16k.bin
+endif
+ifdef CONFIG_LANTIQ_UBOOT_ar10
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl.bin stools
+	touch dummy
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 0x6000 $(nandobj)u-boot-spl.bin
+	cat $(TOPDIR)/stage2_key.bin >>$(nandobj)u-boot-spl.bin
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 32 $(nandobj)u-boot-spl.bin
+	./stools -i $(nandobj)u-boot-spl.bin -o u-boot-spl.enc -e 0xbe1a0030 -d 0xbe1a0000 -j 0xbe1a0000 \
+	-k $(CONFIG_AES_KEY)
+	$(TOPDIR)/scripts_platform/mk_sf.pl dummy u-boot-spl.enc 0xbe1a0000 $(nandobj)u-boot-spl-16k.bin
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_SPL_BLOCK_SIZE) $(nandobj)u-boot-spl-16k.bin
+endif
+ifdef CONFIG_LANTIQ_UBOOT_grx500
+ifdef CONFIG_MANUBOOT
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl.bin
+	$(CONFIG_SIGNTOOL) sign -type BLw  -infile $(nandobj)u-boot-spl.bin \
+			   -prikey $(CONFIG_PRIVATE_KEY) \
+			   -wrapkey $(CONFIG_PROD_UNIQUE_KEY) \
+                           -attribute rollback=2 \
+                           -attribute 0x80000000=$(CONFIG_NAND_SPL_TEXT_BASE)\
+                           -attribute 0x80000001=0x00000001 \
+                           -attribute 0x80000002=$(CONFIG_NAND_SPL_TEXT_BASE) \
+                           -encattr \
+                           -manuboot \
+                           $(SIGN_IMAGE_OPT) \
+                           -outfile blwSignedImg.bin
+    ifdef CONFIG_GRX500_A11
+	sed -i -e 's/0xb6200008 *\(.\{8\}\).\(.*\)/0xb6200008 \1E\2/' \
+               -e 's/0xB6200008 *\(.\{8\}\).\(.*\)/0xB6200008 \1E\2/' $(TOPDIR)/board/$(BOARD)/ddr.conf
+    endif
+	$(TOPDIR)/scripts_platform/mk_ltq_header.pl --ddr $(TOPDIR)/board/$(BOARD)/ddr.conf \
+                                                    --bch $(BCH_VAL) --col 2 --row 3 --blocksize $(CONFIG_NAND_BLOCK_SIZE) \
+                                                    --pagesize $(CONFIG_NAND_PAGE_SIZE) --offset $(CONFIG_NAND_PAGE_SIZE),0x4000,0x6000,0x8000 --out header.ltq
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 1760 header.ltq
+	$(HOSTCC) -o bch_enc $(TOPDIR)/board/$(BOARD)/bch_enc.c
+	./bch_enc header.ltq header.bch $(CONFIG_GRX500_ROM_HEADER_BCH_CAP)
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_PAGE_SIZE) header.bch
+	$(TOPDIR)/scripts_platform/mk_sf_image.pl -i blwSignedImg.bin -o output.bin -j 0xA0900000 -m 1
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 440 output.bin
+    ifdef CONFIG_NAND_BENAND
+	cp header.bch $(nandobj)u-boot-spl-16k.bin
+	cat output.bin >> $(nandobj)u-boot-spl-16k.bin
+    else
+	./bch_enc output.bin output.bch 8
+	cp header.bch $(nandobj)u-boot-spl-16k.bin
+	cat output.bch >>$(nandobj)u-boot-spl-16k.bin
+    endif
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_SPL_BLOCK_SIZE) $(nandobj)u-boot-spl-16k.bin
+else # not manuboot
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl.bin
+	$(CONFIG_SIGNTOOL) sign -type BLw  -infile $(nandobj)u-boot-spl.bin \
+			   -prikey $(CONFIG_PRIVATE_KEY) \
+			   -wrapkey $(CONFIG_PROD_UNIQUE_KEY) \
+                           -attribute rollback=2 \
+                           -attribute 0x80000000=$(CONFIG_NAND_SPL_TEXT_BASE)\
+                           -attribute 0x80000001=0x00000001 \
+                           -attribute 0x80000002=$(CONFIG_NAND_SPL_TEXT_BASE) \
+                           -encattr \
+                           $(SIGN_IMAGE_OPT) \
+                           -kdk \
+                           -pubkeytype otp \
+                           -algo aes256 \
+                           -outfile blwSignedImg.bin
+    ifdef CONFIG_GRX500_A11
+	sed -i -e 's/0xb6200008 *\(.\{8\}\).\(.*\)/0xb6200008 \1E\2/' \
+               -e 's/0xB6200008 *\(.\{8\}\).\(.*\)/0xB6200008 \1E\2/' $(TOPDIR)/board/$(BOARD)/ddr.conf
+    endif
+	$(TOPDIR)/scripts_platform/mk_ltq_header.pl --ddr $(TOPDIR)/board/$(BOARD)/ddr.conf \
+                                                    --bch $(BCH_VAL) --col 2 --row 3 --blocksize $(CONFIG_NAND_BLOCK_SIZE) \
+                                                    --pagesize $(CONFIG_NAND_PAGE_SIZE) --offset $(CONFIG_NAND_PAGE_SIZE) --out header.ltq
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 1760 header.ltq
+	$(HOSTCC) -o bch_enc $(TOPDIR)/board/$(BOARD)/bch_enc.c
+	./bch_enc header.ltq header.bch $(CONFIG_GRX500_ROM_HEADER_BCH_CAP)
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_PAGE_SIZE) header.bch
+	$(TOPDIR)/scripts_platform/mk_sf_image.pl -i blwSignedImg.bin -o output.bin -j 0xa0100000 -m 2
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 440 output.bin
+    ifdef CONFIG_NAND_BENAND
+	cp header.bch $(nandobj)u-boot-spl-16k.bin
+	cat output.bin >> $(nandobj)u-boot-spl-16k.bin
+    else
+	./bch_enc output.bin output.bch 8
+	cp header.bch $(nandobj)u-boot-spl-16k.bin
+	cat output.bch >>$(nandobj)u-boot-spl-16k.bin
+    endif
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_SPL_BLOCK_SIZE) $(nandobj)u-boot-spl-16k.bin
+endif # end CONFIG_MANUBOOT
+endif 
+else  #not secure boot
+ifdef CONFIG_LANTIQ_UBOOT_grx500
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl.bin
+	$(TOPDIR)/scripts_platform/mk_ltq_header.pl $(spinandflag-y) --ddr $(TOPDIR)/board/$(BOARD)/ddr.conf \
+          --bch $(BCH_VAL) --col 2 --row 3 --blocksize $(CONFIG_NAND_BLOCK_SIZE) --pagesize $(CONFIG_NAND_PAGE_SIZE) --offset $(CONFIG_NAND_PAGE_SIZE) --out header.ltq
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 1760 header.ltq
+	$(HOSTCC) -o bch_enc $(TOPDIR)/board/$(BOARD)/bch_enc.c
+	./bch_enc header.ltq header.bch $(CONFIG_GRX500_ROM_HEADER_BCH_CAP)
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_PAGE_SIZE) header.bch
+	$(TOPDIR)/scripts_platform/mk_sf_image.pl -i $(nandobj)u-boot-spl.bin -o output.bin -j $(CONFIG_NAND_SPL_TEXT_BASE) -m 0
+	$(TOPDIR)/scripts_platform/pad2align.sh -n 440 output.bin
+ifdef CONFIG_NAND_BENAND
+	cp header.bch $(nandobj)u-boot-spl-16k.bin
+	cat output.bin >> $(nandobj)u-boot-spl-16k.bin	
+else
+	./bch_enc output.bin output.bch 8
+	cp header.bch $(nandobj)u-boot-spl-16k.bin
+	cat output.bch >>$(nandobj)u-boot-spl-16k.bin
+endif
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_SPL_BLOCK_SIZE) $(nandobj)u-boot-spl-16k.bin
+else
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl.bin 
+	touch dummy
+	$(TOPDIR)/scripts_platform/mk_sf.pl dummy $(nandobj)u-boot-spl.bin $(CONFIG_NAND_PRELOAD_TEXT_BASE) $(nandobj)u-boot-spl-16k.bin
+	$(TOPDIR)/scripts_platform/pad2align.sh -n $(CONFIG_NAND_SPL_BLOCK_SIZE) $(nandobj)u-boot-spl-16k.bin
+endif
+endif
+endif
+endif
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:$(OBJS) $(nandobj)u-boot.lds
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $(__OBJS) \
+		 $(PLATFORM_LIBS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+	$(OBJDUMP) -S -d $(nandobj)u-boot-spl > $(nandobj)u-boot-spl.dis
+
+$(nandobj)u-boot.lds: $(LDSCRIPT)
+	$(CPP) $(CPPFLAGS) $(LDPPFLAGS) -ansi -D__ASSEMBLY__ -P - <$^ >$@
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $@
+	@ln -s $(TOPDIR)/arch/mips/cpu/$(BOARD)/start_nand_spl.S $@
+	
+clock.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/arch/mips/cpu/$(BOARD)/clock.c $@
+
+cache.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/arch/mips/cpu/$(BOARD)/cache.c $@
+
+# from driver/serial directory
+asc.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/drivers/serial/lq_asc.c $@
+		
+
+# from board directory
+$(obj)lowlevel_init.S:
+	@rm -f $@
+	@ln -s $(TOPDIR)/board/$(BOARD)/lowlevel_init.S $@
+
+
+board.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/board/$(BOARD)/nand_spl_board.c $@
+		
+$(obj)ddr_dcdc.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/board/$(BOARD)/ddr_dcdc.c $@
+
+ds_crypt.bin: ds_crypt
+	$(OBJCOPY) --gap-fill=0xff -O binary $< $@
+
+ds_crypt: rsa_crypt.o
+	$(LD) -G 0 -static -T $(TOPDIR)/board/$(BOARD)/rsalinker.lds --start-group rsa_crypt.o --end-group -o ds_crypt
+
+rsa_crypt.o: $(TOPDIR)/board/$(BOARD)/rsa_crypt.c
+	$(CC) -g -ggdb -G0 -fno-common -fno-strict-aliasing -fno-builtin -pipe -eb -Wall -c -o $@ $<
+
+stools: $(TOPDIR)/board/$(BOARD)/stools.c
+	$(HOSTCC) -o $@ $<
+
+
+#from lib_bootstrap directory
+tune_ddr.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/lib_bootstrap/tune_ddr.c $@
+
+
+# from nand_spl directory
+
+ifeq ($(CONFIG_NAND_ECC_HW_REED_SOLOMON),y)
+$(obj)nand_boot.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/nand_spl/nand_boot_lq_mlc.c $@
+else ifeq ($(CONFIG_SPINAND_LANTIQ),y)		
+$(obj)nand_boot.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/nand_spl/spinand_boot.c $@
+else
+$(obj)nand_boot.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/nand_spl/nand_boot.c $@
+endif
+
+# from drivers/mtd/nand directory
+$(obj)nand_ecc.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/drivers/mtd/nand/nand_ecc.c $@
+
+$(obj)nand_bch.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/drivers/mtd/nand/nand_bch.c $@
+
+$(obj)bch.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/lib/bch.c $@
+
+ifdef CONFIG_SPINAND_LANTIQ
+$(obj)lq_nand.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/drivers/mtd/nand/lq_spinand.c $@
+else
+$(obj)lq_nand.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/drivers/mtd/nand/lq_nand.c $@
+endif
+
+#from lib directory
+string.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/lib/string.c $@
+
+time.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/arch/mips/lib/time.c $@
+		
+crc32.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/lib/crc32.c
+
+ifeq ($(CONFIG_MANUBOOT)$(CONFIG_MANUBOOT_OTP_SUPPORT)$(CONFIG_GRX500_BOOT_4KEC_ONLY),yy)
+OTP_H := otp_bin.h
+# OTP_HEX := $(shell hexdump -ve '1/1 "%02x"' $(CONFIG_MANUBOOT_OTP)  )
+
+# old method depend on hexdump
+# .PHONY : $(OTP_H)
+# $(OTP_H):
+#	@echo "Generate OTP content"
+# 	-@rm -f  $(TOPDIR)/include/$(OTP_H)
+# 	@$(TOPDIR)/scripts_platform/hex2array.pl oem_keys $(OTP_HEX) > $(TOPDIR)/include/$(OTP_H)
+
+.PHONY : $(OTP_H)
+$(OTP_H):
+	@echo "Generate OTP content"
+	-@rm -f  $(TOPDIR)/include/$(OTP_H)
+	@$(TOPDIR)/scripts_platform/bin2array.pl $(CONFIG_MANUBOOT_OTP) $(TOPDIR)/include/$(OTP_H) oem_keys
+
+# phony target to force it to rebuild otp_bin.h everytime
+otp.c: $(OTP_H)
+	@rm -f $@
+	@ln -s $(TOPDIR)/common/otp.c $@
+
+endif
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/nand_spl/board/lantiq/config.mk b/nand_spl/board/lantiq/config.mk
new file mode 100644
--- /dev/null
+++ b/nand_spl/board/lantiq/config.mk
@@ -0,0 +1,40 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Samsung S3C64xx Reference Platform (smdk6400) board
+
+# TEXT_BASE for SPL:
+#
+# On S3C64xx platforms the SPL is located in SRAM at 0.
+#
+# TEXT_BASE = 0
+
+include $(TOPDIR)/board/$(BOARDDIR)/config.mk
+
+# PAD_TO used to generate a 4kByte binary needed for the combined image
+# -> PAD_TO = TEXT_BASE + 4096
+PAD_TO	:= $(shell expr $$[$(TEXT_BASE) + 4096])
+
+ifeq ($(debug),1)
+PLATFORM_CPPFLAGS += -DDEBUG
+endif
diff --git a/nand_spl/board/lantiq/nand_preload.c b/nand_spl/board/lantiq/nand_preload.c
new file mode 100644
--- /dev/null
+++ b/nand_spl/board/lantiq/nand_preload.c
@@ -0,0 +1,76 @@
+#include <common.h>
+
+
+static void read_page(u32 page_addr, u32 dest_addr)
+{
+   int i;
+   u8 *tmp;
+   u8 col_addr_num;
+	 u8 page_addr_num;
+
+   if(CONFIG_NAND_PAGE_SIZE<=0x200){
+     col_addr_num=1;
+           		
+     if(CONFIG_NAND_FLASH_SIZE<32){
+        page_addr_num=2;     	
+      }else
+      	page_addr_num=3;
+   }else{
+     col_addr_num=2;
+     
+     if(CONFIG_NAND_FLASH_SIZE<128){
+     	  page_addr_num=2;
+      }else{
+      	page_addr_num=3;
+      }
+   }
+   
+   NAND_CE_SET;
+   NAND_WRITE(WRITE_CMD,0);
+   IFX_NAND_CTL_SETALE;
+   for(i=0;i<col_addr_num;i++){
+    NAND_WRITE(WRITE_ADDR,0);
+  }
+   for(i=0;i<page_addr_num;i++){
+   	 NAND_WRITE(WRITE_ADDR,(u8)((page_addr>>(i*8)) & 0xff ));
+   } 
+   IFX_NAND_CTL_CLRALE;
+   
+   if(CONFIG_NAND_PAGE_SIZE>0x200){
+     NAND_WRITE(WRITE_CMD,0x30);
+   } 
+   
+  while(!NAND_READY){}
+   
+   /* Read page */
+   tmp = (u8*)dest_addr;
+   for (i = 0; i < CONFIG_NAND_PAGE_SIZE; i++)
+   {
+     NAND_READ(READ_DATA, *tmp++); 
+   }
+   NAND_CE_CLEAR;
+   
+   while(!NAND_READY){}
+}
+
+#define FILE_SIZE CONFIG_NAND_SPL_BLOCK_SIZE
+#define STARTING_ADDRESS CONFIG_NAND_PRELOAD_TEXT_BASE+0x200
+
+void nand_init(void)
+{
+   int i;
+   for(i=0;i<(FILE_SIZE/CONFIG_NAND_PAGE_SIZE+1);i++){    
+    read_page(i,STARTING_ADDRESS+CONFIG_NAND_PAGE_SIZE*i);   	 
+   }
+
+   // jump start
+   void (*start)(void);
+   
+  
+   start = (void *)CONFIG_NAND_SPL_TEXT_BASE;
+   start();
+
+}
+
+
+
diff --git a/nand_spl/board/lantiq/nandpreload.lds b/nand_spl/board/lantiq/nandpreload.lds
new file mode 100644
--- /dev/null
+++ b/nand_spl/board/lantiq/nandpreload.lds
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+  . = 0x00000000;
+  . = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+  . = ALIGN(4);
+  .rodata  : { *(.rodata) }
+  . = ALIGN(4);
+  .data  : { *(.data) }
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+  _gp = ABSOLUTE(.);
+  _etext = ABSOLUTE(.);
+  .got  : { *(.got) }
+  .sbss  : { *(.sbss) }
+  .bss  : { *(.bss) }
+	
+}
diff --git a/nand_spl/board/lantiq/start_nandpreload.S b/nand_spl/board/lantiq/start_nandpreload.S
new file mode 100644
--- /dev/null
+++ b/nand_spl/board/lantiq/start_nandpreload.S
@@ -0,0 +1,46 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/cacheops.h>
+#include <asm/addrspace.h>
+#include <asm/yamon.h>
+
+    .set noreorder
+	  .option pic0
+
+   	.globl _start
+   	.text
+_start:
+    li   t0, CONFIG_TUNING_SP
+    la      sp, 0(t0)
+    
+    la   t9, nand_init
+    j    t9
+    nop
+    
diff --git a/nand_spl/board/lantiq/u-boot.lds b/nand_spl/board/lantiq/u-boot.lds
new file mode 100644
--- /dev/null
+++ b/nand_spl/board/lantiq/u-boot.lds
@@ -0,0 +1,70 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+OUTPUT_FORMAT("elf32-bigmips", "elf32-bigmips", "elf32-bigmips")
+*/
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+        . = 0x00000000;
+
+        . = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+        . = ALIGN(4);
+        .rodata  : { *(.rodata) }
+
+        . = ALIGN(4);
+        .data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	. = ALIGN(16);
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	. = .;
+        __u_boot_cmd_start = .;
+        .u_boot_cmd : { *(.u_boot_cmd) }
+        __u_boot_cmd_end = .;
+    got_size = (__got_end - __got_start);
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+        . = ALIGN(4);
+	.sbss  : { *(.sbss) }
+        .bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/nand_spl/nand_boot.c b/nand_spl/nand_boot.c
old mode 100644
new mode 100755
--- a/nand_spl/nand_boot.c
+++ b/nand_spl/nand_boot.c
@@ -21,11 +21,317 @@
 #include <common.h>
 #include <nand.h>
 #include <asm/io.h>
+#include <image.h>
+#include <asm/boot.h>
 
+extern int cpu_is_cps(void);
+extern struct nand_bch_control *nand_bch_init(struct mtd_info *mtd, 
+			unsigned int eccsize, unsigned int eccbytes,
+			struct nand_ecclayout **ecclayout);
+
+static int bbt_valid=0;
+
+#define TOTAL_MALLOC_LEN    CONFIG_SYS_MALLOC_LEN
 #define CONFIG_SYS_NAND_READ_DELAY \
 	{ volatile int dummy; int i; for (i=0; i<10000; i++) dummy = i; }
 
-static int nand_ecc_pos[] = CONFIG_SYS_NAND_ECCPOS;
+#ifdef CONFIG_DRIVER_GRX500
+ #if defined (CONFIG_NAND_ECC_SOFT)
+ static int nand_ecc_pos[] = CONFIG_SYS_NAND_ECCPOS;
+ #elif defined (CONFIG_NAND_ECC_BCH) 
+ static int *nand_ecc_pos;
+ #endif
+#else 
+ static int nand_ecc_pos[] = CONFIG_SYS_NAND_ECCPOS;
+ #define CONFIG_NAND_SPL_OOBSIZE		CONFIG_SYS_NAND_OOBSIZE	
+#endif /* CONFIG_DRIVER_GRX500 */
+
+#if defined (CONFIG_DRIVER_GRX500)
+static int check_4kec_header(u32 src, u32 *jmp_addr, u32 dst_size)
+{
+	int image_len;
+    u8 *image_start = NULL;
+    u32 ret_check, checksum = 0;
+	u32 hdr_len, load_addr;
+	image_header_t *pimg_header = (image_header_t *)src;
+    
+	/* check magic number */
+	if (ntohl(pimg_header->ih_magic) != IH_MAGIC)
+		return -1;
+
+	asm("sync");
+	/* mkimage type kernel without the 8B offset */
+	image_start = (u8 *)pimg_header + sizeof(image_header_t);
+    image_len = ntohl(pimg_header->ih_size);
+	load_addr = ntohl(pimg_header->ih_load);
+	*jmp_addr = load_addr;
+	asm("sync");
+
+	hdr_len = sizeof(image_header_t);
+	checksum = ntohl(pimg_header->ih_hcrc);
+	pimg_header->ih_hcrc = 0;
+
+	asm("sync");
+	ret_check = crc32(0, (unsigned char *) src, hdr_len);
+	if (ret_check != checksum)
+		return -1;
+
+	asm("sync");
+	memcpy((u32 *) load_addr, (u32 *)image_start, image_len);
+
+	return 0; // success
+}
+
+#endif /* CONFIG_DRIVER_GRX500 */ 
+
+#ifdef CONFIG_LTQ_SECURE_BOOT
+
+#define ROLLBACKID_BUFF 0xBF806100
+//#define ROLLBACKID_BUFF 0xA0100000
+
+#ifdef CPHYSADDR
+	#undef CPHYSADDR
+	#define PHYS_ADDR(a) (unsigned long)a<0xb0000000?((((unsigned long)a) & 0x1fffffff) | 0x20000000):(((unsigned long)a) & 0x1fffffff)
+	#define CPHYSADDR(a) cpu_is_cps()?(PHYS_ADDR(a)+0xa0000000):(PHYS_ADDR(a))
+	#undef KSEG1ADDR
+	#define KSEG1ADDR(a) ((unsigned long)a & 0x1fffffff)|KSEG1;
+#endif
+
+void rollback_id_chk_pre(u32 addr)
+{
+    memcpy((void*)ROLLBACKID_BUFF, (const void*)addr, (size_t)264);
+    return;
+}
+
+void rollback_id_chk_do()
+{
+    u32 val   = 0;
+    u32 a6    = 0;
+    u32 akek  = 0;
+    u32 i     = 0;
+    u8  *pTmp = 0;
+    u32 word  = 0;
+    u32 aw    = 0;
+    u32 id    = 0;
+    u32 cid   = 0;
+    u32 reset = 0;
+
+    REG32(0xbe003f00) = 0x00000004;
+
+    REG32(0xbe000000) = 0x07000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe00000C) = 0x00068000;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rst;
+    }
+    a6 = REG32(0xbe000004);
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x07000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = 0x00003001;
+    REG32(0xbe00000C) = 0x00000020;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rst;
+    }
+    akek = REG32(0xbe000004);
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x17000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = akek;
+    REG32(0xbe00000C) = 0x01400000;
+    REG32(0xbe00001C) = a6;
+    for (i=0; i<64; i+=4)
+    {
+        pTmp  = ROLLBACKID_BUFF+8+i;
+        word  = *pTmp++;
+        word |= (*pTmp++) << 8;
+        word |= (*pTmp++) << 16;
+        word |= (*pTmp++) << 24;
+        REG32(0xbe000020+i) = word;
+    }
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_akek;
+    }
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x07000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = 0x00003001;
+    REG32(0xbe00000C) = 0x00000020;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_akek;
+    }
+    aw = REG32(0xbe000004);
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x17000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = aw;
+    REG32(0xbe00000C) = 0x10000028;
+    REG32(0xbe000010) = CPHYSADDR(ROLLBACKID_BUFF+136);
+    #if 0
+     REG32(0xbe000014) = 0xAAAAAAAA;
+     REG32(0xbe000018) = 0xAAAAAAAA;
+    #endif
+    REG32(0xbe00001C) = akek;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_aw;
+    }
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x0100BABE;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = 0x00000040;
+    REG32(0xbe00000C) = CPHYSADDR(ROLLBACKID_BUFF+196);
+    REG32(0xbe000010) = 0x00000040;
+    REG32(0xbe000014) = 0x00000000;
+    REG32(0xbe000018) = CPHYSADDR(ROLLBACKID_BUFF+196);
+    REG32(0xbe00001C) = 0x00000040;
+    REG32(0xbe000020) = 0x00000000;
+    REG32(0xbe000028) = 0x00030110;
+    for (i=0; i<16; i+=4)
+    {
+        pTmp  = ROLLBACKID_BUFF+176+i;
+        word  = *pTmp++;
+        word |= (*pTmp++) << 8;
+        word |= (*pTmp++) << 16;
+        word |= (*pTmp++) << 24;
+        REG32(0xbe000030+i) = word;
+    }
+    REG32(0xbe000040) = aw;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if (REG32(0xbe000000) != 0x0000BABE)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_aw;
+    }
+    REG32(0xbe003f00) = 0x00000002;
+
+    for (i=0; i<64; i+=8)
+    {
+        if(*((u32*)(ROLLBACKID_BUFF+196+i)) == 0)
+            break;
+
+        if(*((u32*)(ROLLBACKID_BUFF+196+i)) == 2)
+        {
+            id = *((u32*)(ROLLBACKID_BUFF+196+i+4));
+            break;
+        }
+    }
+    if (REG32(0xb6080304) == 0xFFFFFFFFUL)
+        cid = 32; // safety against undefine ffz when no 0
+    else
+        /* the index of first zero coincidentally also count the number of consecutive trailing bit 1 */
+        cid = ffz(REG32(0xb6080304));
+
+    if (id < cid)
+        reset = 1;
+
+    rm_aw:
+    REG32(0xbe000000) = 0x37000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = aw;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    #if 0
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        return;
+    }
+    #endif
+    REG32(0xbe003f00) = 0x00000002;
+
+    rm_akek:
+    REG32(0xbe000000) = 0x37000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = akek;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    #if 0
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        return;
+    }
+    #endif
+    REG32(0xbe003f00) = 0x00000002;
+
+    memset((void*)ROLLBACKID_BUFF,0,(size_t)264);
+
+    rst:
+    if(reset)
+        REG32(0xb6000010) |= 0x40000000;
+
+    return;
+}
+
+void bootrom_auth(u32 addr)
+{
+    ulong *img_p = (ulong *)addr;
+    int    image_len;
+    int    certnum;
+
+    void (*auth)(u32 addr, int len, u32* entry_p, u32* target_p) = (void*)0x9fc1a001;
+
+    certnum   = (int)(*(img_p+65));
+    image_len = 66*4+128*certnum+(int)(*(img_p+48));
+
+    asm("sync");
+
+    rollback_id_chk_pre(addr);
+    rollback_id_chk_do();
+    auth((u32)img_p, image_len, NULL, NULL);
+    // rollback_id_chk_do(); //safer after auth but cant check bootcore if put here
+
+    return;
+}
+#endif /* CONFIG_LTQ_SECURE_BOOT */
 
 #if (CONFIG_SYS_NAND_PAGE_SIZE <= 512)
 /*
@@ -127,28 +433,40 @@ static int nand_command(struct mtd_info 
 static int nand_is_bad_block(struct mtd_info *mtd, int block)
 {
 	struct nand_chip *this = mtd->priv;
+#ifdef CONFIG_NAND_SPL_BBT	
+	if(bbt_valid){
+      return nand_isbad_bbt(mtd, block<<this->bbt_erase_shift, 1);
+	}else{
+#endif	
+	 nand_command(mtd, block, 0, CONFIG_SYS_NAND_BAD_BLOCK_POS, NAND_CMD_READOOB);
 
-	nand_command(mtd, block, 0, CONFIG_SYS_NAND_BAD_BLOCK_POS, NAND_CMD_READOOB);
-
-	/*
+	 /*
 	 * Read one byte
 	 */
 	if (readb(this->IO_ADDR_R) != 0xff)
 		return 1;
-
+#ifdef CONFIG_NAND_SPL_BBT    
+	}
+#endif	
 	return 0;
 }
 
+#ifndef CONFIG_NAND_BENAND
+#ifdef CONFIG_NAND_SPL_BBT
+int nand_read_page(struct mtd_info *mtd, int block, int page, uchar *dst)
+#else
 static int nand_read_page(struct mtd_info *mtd, int block, int page, uchar *dst)
+#endif
 {
 	struct nand_chip *this = mtd->priv;
 	u_char *ecc_calc;
 	u_char *ecc_code;
 	u_char *oob_data;
-	int i;
-	int eccsize = CONFIG_SYS_NAND_ECCSIZE;
-	int eccbytes = CONFIG_SYS_NAND_ECCBYTES;
-	int eccsteps = CONFIG_SYS_NAND_ECCSTEPS;
+	int i, j=0;
+    int eccsize = CONFIG_SYS_NAND_ECCSIZE;
+    int eccbytes = CONFIG_SYS_NAND_ECCBYTES;
+    int eccsteps = CONFIG_SYS_NAND_ECCSTEPS;
+
 	uint8_t *p = dst;
 	int stat;
 
@@ -156,35 +474,68 @@ static int nand_read_page(struct mtd_inf
 
 	/* No malloc available for now, just use some temporary locations
 	 * in SDRAM
+
 	 */
 	ecc_calc = (u_char *)(CONFIG_SYS_SDRAM_BASE + 0x10000);
-	ecc_code = ecc_calc + 0x100;
-	oob_data = ecc_calc + 0x200;
+	ecc_code = ecc_calc + 0x10000;
+	oob_data = ecc_calc + 0x20000;
 
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		this->ecc.hwctl(mtd, NAND_ECC_READ);
 		this->read_buf(mtd, p, eccsize);
 		this->ecc.calculate(mtd, p, &ecc_calc[i]);
 	}
-	this->read_buf(mtd, oob_data, CONFIG_SYS_NAND_OOBSIZE);
+	this->read_buf(mtd, oob_data, CONFIG_NAND_SPL_OOBSIZE);
 
 	/* Pick the ECC bytes out of the oob data */
-	for (i = 0; i < CONFIG_SYS_NAND_ECCTOTAL; i++)
+	for (i = 0; i < CONFIG_SYS_NAND_ECCTOTAL; i++) {
 		ecc_code[i] = oob_data[nand_ecc_pos[i]];
+	}
 
-	eccsteps = CONFIG_SYS_NAND_ECCSTEPS;
+	eccsteps = this->ecc.steps;
 	p = dst;
 
-	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+	for (i = 0; eccsteps > 0; eccsteps--, i += eccbytes, p += eccsize) {
 		/* No chance to do something with the possible error message
 		 * from correct_data(). We just hope that all possible errors
 		 * are corrected by this routine.
 		 */
 		stat = this->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
+		if (stat < 0)
+			goto error;
 	}
+	return 0;
 
-	return 0;
+error:
+	return stat;
 }
+#else
+static int nand_read_page(struct mtd_info *mtd, int block, int page, uchar *dst)
+{
+	struct nand_chip *this = mtd->priv;
+	this->oob_poi = (u_char *)(CONFIG_SYS_SDRAM_BASE + 0x10000);
+	int err = 0;
+	
+	nand_command(mtd, block, page, 0, NAND_CMD_READ0);
+	/* ecc is handled by benand */
+	err = this->ecc.read_page(mtd, this, dst, page);
+
+	return err;
+}
+#endif /* CONFIG_NAND_BENAND */
+
+#ifdef CONFIG_NAND_SPL_BBT
+int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs, size_t len)
+{
+	 struct nand_chip *this = mtd->priv;
+	 int block,page;
+	 block=offs>>this->bbt_erase_shift;
+	 page=0;/*always the first page for bbt*/
+	
+	 nand_command(mtd, block, page, 0, NAND_CMD_READ0);
+	 this->read_buf(mtd, buf, mtd->writesize+mtd->oobsize);
+}			 
+#endif
 
 static int nand_load(struct mtd_info *mtd, unsigned int offs,
 		     unsigned int uboot_size, uchar *dst)
@@ -200,7 +551,7 @@ static int nand_load(struct mtd_info *mt
 	page = (offs % CONFIG_SYS_NAND_BLOCK_SIZE) / CONFIG_SYS_NAND_PAGE_SIZE;
 
 	while (block <= lastblock) {
-		if (!nand_is_bad_block(mtd, block)) {
+				if (!nand_is_bad_block(mtd,block)){
 			/*
 			 * Skip bad blocks
 			 */
@@ -233,22 +584,108 @@ void nand_boot(void)
 	int ret;
 	__attribute__((noreturn)) void (*uboot)(void);
 
+#if defined(CONFIG_LTQ_SECURE_BOOT) && !CONFIG_DRIVER_GRX500
+    int i;
+    unsigned char aes_key[32];
+    unsigned char iv[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	unsigned char* masked_key=(unsigned char*)(CONFIG_NAND_SPL_TEXT_BASE+0x6000);
+#endif
+
+#if defined(CONFIG_DRIVER_GRX500) && !defined(CONFIG_GRX500_BOOT_4KEC_ONLY)
+    /* Since IAP has already initialised the H/W, we do not want to 
+     * reset the nand datapath when 4kec boots. Otherwise, there will
+     * be an unknown state for the controller when IAP access the EBU bus 
+     */
+    if (!cpu_is_cps())
+        goto cpy_bootcore;
+#endif
+
+	memset(&nand_chip, 0, sizeof(struct nand_chip));
 	/*
 	 * Init board specific nand support
 	 */
 	nand_info.priv = &nand_chip;
+	
 	nand_chip.IO_ADDR_R = nand_chip.IO_ADDR_W = (void  __iomem *)CONFIG_SYS_NAND_BASE;
 	nand_chip.dev_ready = NULL;	/* preset to NULL */
 	board_nand_init(&nand_chip);
 
 	if (nand_chip.select_chip)
 		nand_chip.select_chip(&nand_info, 0);
+#ifdef CONFIG_NAND_SPL_BBT
+   /*search and setup bbt in the memory*/
 
-	/*
+    nand_info.size=CONFIG_NAND_FLASH_SIZE*(1<<20);
+    nand_info.erasesize=CONFIG_NAND_BLOCK_SIZE;
+    nand_info.writesize=CONFIG_NAND_PAGE_SIZE;
+    nand_info.oobsize=64;
+    nand_chip.page_shift=ffs(nand_info.writesize)-1;
+    nand_chip.bbt_erase_shift=ffs(nand_info.erasesize)-1;
+    nand_chip.numchips=1;
+    nand_chip.bbt_td=NULL;
+    nand_chip.bbt_md=NULL;
+    nand_chip.chipsize=nand_info.size;
+    nand_chip.badblock_pattern=NULL;
+
+    if(nand_default_bbt(&nand_info)){
+    		bbt_valid=1;
+    }else{
+    	  bbt_valid=0;
+    }
+#endif
+
+#ifdef CONFIG_NAND_BENAND
+   nand_info.writesize = CONFIG_SYS_NAND_PAGE_SIZE;
+   nand_info.oobsize = (CONFIG_SYS_NAND_PAGE_SIZE == 0x1000) ? 128 : 64;
+#endif
+
+#if  defined(CONFIG_NAND_ECC_BCH) && defined(CONFIG_DRIVER_GRX500)
+	struct nand_ecclayout *ecc;
+	struct nand_ecc_ctrl *ctrl;
+	ulong malloc_base;
+
+	malloc_base = 0x82000000;
+	mem_malloc_init(malloc_base, TOTAL_MALLOC_LEN);
+    nand_info.size=CONFIG_NAND_FLASH_SIZE*(1<<20);
+    nand_info.erasesize=CONFIG_NAND_BLOCK_SIZE;
+    nand_info.writesize=CONFIG_NAND_PAGE_SIZE;
+    nand_info.oobsize=CONFIG_NAND_SPL_OOBSIZE;
+    nand_chip.page_shift=ffs(nand_info.writesize)-1;
+    nand_chip.bbt_erase_shift=ffs(nand_info.erasesize)-1;
+    nand_chip.numchips=1;
+    nand_chip.bbt_td=NULL;
+    nand_chip.bbt_md=NULL;
+    nand_chip.chipsize=nand_info.size;
+    nand_chip.badblock_pattern=NULL;
+
+	nand_chip.ecc.size = CONFIG_SYS_NAND_ECCSIZE;
+	nand_chip.ecc.bytes = CONFIG_SYS_NAND_ECCBYTES;
+	nand_chip.ecc.steps = CONFIG_SYS_NAND_ECCSTEPS;
+    nand_chip.ecc.priv = nand_bch_init(&nand_info,
+			                    nand_chip.ecc.size, 
+								nand_chip.ecc.bytes, 
+								&nand_chip.ecc.layout);
+
+	ctrl = &nand_chip.ecc;
+	ecc = ctrl->layout;
+	nand_ecc_pos = &ecc->eccpos;
+#endif
+
+cpy_bootcore:
+#if !defined(CONFIG_GRX500_BOOT_4KEC_ONLY) && defined(CONFIG_DRIVER_GRX500)
+    if (cpu_is_cps()) {
+#endif /* CONFIG_GRX500_BOOT_4KEC_ONLY && CONFIG_DRIVER_GRX500 */
+
+    /*
 	 * Load U-Boot image from NAND into RAM
 	 */
-	ret = nand_load(&nand_info, CONFIG_SYS_NAND_U_BOOT_OFFS, CONFIG_SYS_NAND_U_BOOT_SIZE,
+#if defined(CONFIG_LTQ_SECURE_BOOT) && defined(CONFIG_DRIVER_GRX500) && !defined(CONFIG_MANUBOOT)
+        ret = nand_load(&nand_info, CONFIG_SYS_NAND_U_BOOT_OFFS, CONFIG_SYS_NAND_U_BOOT_SIZE,
+                        (uchar *)0xa0800000);
+#else
+        ret = nand_load(&nand_info, CONFIG_SYS_NAND_U_BOOT_OFFS, CONFIG_SYS_NAND_U_BOOT_SIZE,
 			(uchar *)CONFIG_SYS_NAND_U_BOOT_DST);
+#endif /* CONFIG_LTQ_SECURE_BOOT && CONFIG_DRIVER_GRX500 */
 
 #ifdef CONFIG_NAND_ENV_DST
 	nand_load(&nand_info, CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
@@ -257,15 +694,80 @@ void nand_boot(void)
 #ifdef CONFIG_ENV_OFFSET_REDUND
 	nand_load(&nand_info, CONFIG_ENV_OFFSET_REDUND, CONFIG_ENV_SIZE,
 		  (uchar *)CONFIG_NAND_ENV_DST + CONFIG_ENV_SIZE);
-#endif
-#endif
+#endif /* CONFIG_ENV_OFFSET_REDUND */
+#endif /* CONFIG_NAND_ENV_DST */
 
 	if (nand_chip.select_chip)
 		nand_chip.select_chip(&nand_info, -1);
 
+       asm("sync");
+
+#if defined(CONFIG_LTQ_SECURE_BOOT) && (!CONFIG_DRIVER_GRX500) 
+#include "mask.h"
+extern secure_decrypt(u8 *key, u8 *iv, u8 *src, u8 *dst, u32 nbytes);
+extern void flush_dcache_range(ulong start_addr, ulong stop);
+       for(i=0;i<32;i++){
+          aes_key[i]=masked_key[i]^mask[i];
+		  masked_key[i]=mask[i]=0xff;
+	   }
+       secure_decrypt(aes_key, iv,(u8*)CONFIG_STAGE2_LOADADDR,\
+	                (u8*)CONFIG_STAGE2_LOADADDR, CONFIG_STAGE2_SIZE);
+	   flush_dcache_range((ulong)CONFIG_STAGE2_LOADADDR,\
+	                      (ulong)(CONFIG_STAGE2_LOADADDR+CONFIG_STAGE2_SIZE));			
+#endif
+
+#ifndef CONFIG_MANUBOOT
+#if defined(CONFIG_LTQ_SECURE_BOOT) && defined(CONFIG_DRIVER_GRX500)
+    #if defined(CONFIG_GRX500_BOOT_4KEC_ONLY)
+    bootrom_auth(0xa0800000);
+    #else /* defined(CONFIG_GRX500_BOOT_4KEC_ONLY) */
+    /* Inform 4kec , to auth img */
+    REG32(SRAMFLAG) = IPCMAGIC;
+    /* wait for reply , assume during delay, SRAMFLAG will be cleared by 4kec */
+    mdelay(200);
+    while (REG32(SRAMFLAG) != (~IPCMAGIC));
+    REG32(SRAMFLAG) = 0;
+    asm("sync");
+    #endif /* defined(CONFIG_GRX500_BOOT_4KEC_ONLY) */
+#endif /* CONFIG_LTQ_SECURE_BOOT && CONFIG_DRIVER_GRX500 && CONFIG_GRX500_A21 */ 
+#endif /* CONFIG_MANUBOOT */
 	/*
 	 * Jump to U-Boot image
 	 */
 	uboot = (void *)CONFIG_SYS_NAND_U_BOOT_START;
 	(*uboot)();
+
+#if !defined(CONFIG_GRX500_BOOT_4KEC_ONLY) && defined(CONFIG_DRIVER_GRX500)
+    } else {
+        ulong load_address;
+        ulong jump_address;
+		ulong ddr_address, bootcore_size;
+
+		asm("sync");
+		load_address = REG32(MPS_LOAD_ADDR); /* 4Kec load addr */
+		ddr_address = REG32(MPS_DDR_LOC);	 /* ddr where TOS is copied to */
+		bootcore_size = REG32(MPS_SIZE_LOC); /* size of TOS/bootcore img */
+
+        #if defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT)
+        /* reuse ddr loc only */
+        bootrom_auth((u32)ddr_address);
+
+        /* safeguard , but shall never come here in first place*/
+        while(1);
+        #else /* defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT) */
+		memcpy((unsigned char *) load_address, 
+				(unsigned char *) ddr_address, 
+				bootcore_size);
+
+		ret = check_4kec_header(load_address, 
+								&jump_address, 
+								bootcore_size);
+		if (ret)
+			while(1); // if img is bad, we prevent 4kec from loading it
+
+        uboot = (void*)jump_address;
+        (*uboot)();
+        #endif /* defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT) */
+    }
+#endif /* CONFIG_GRX500_BOOT_4KEC_ONLY  && CONFIG_DRIVER_GRX500 */
 }
diff --git a/nand_spl/nand_boot_lq_mlc.c b/nand_spl/nand_boot_lq_mlc.c
new file mode 100755
--- /dev/null
+++ b/nand_spl/nand_boot_lq_mlc.c
@@ -0,0 +1,601 @@
+/*
+ * (C) Copyright 2006-2008
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/boot.h>
+
+#ifndef CONFIG_DRIVER_GRX500
+extern void init_ddr(void);
+extern void tune_ddr(void);
+#endif
+
+#define CONFIG_SYS_NAND_READ_DELAY \
+	{ volatile int dummy; int i; for (i=0; i<10000; i++) dummy = i; }
+
+#if defined (CONFIG_DRIVER_GRX500)
+static int check_4kec_header(u32 src, u32 *jmp_addr, u32 dst_size)
+{
+    int image_len;
+    u8 *image_start = NULL;
+    u32 ret_check, checksum = 0;
+    u32 hdr_len, load_addr; 
+    image_header_t *pimg_header = (image_header_t *)src;
+    
+    /* check magic number */
+    if (ntohl(pimg_header->ih_magic) != IH_MAGIC)
+        return -1;
+
+    asm("sync");
+    /* mkimage type kernel without the 8B offset */
+    image_start = (u8 *)pimg_header + sizeof(image_header_t);
+    image_len = ntohl(pimg_header->ih_size);
+    load_addr = ntohl(pimg_header->ih_load);
+    *jmp_addr = load_addr;
+    asm("sync");
+    
+    hdr_len = sizeof(image_header_t);
+    checksum = ntohl(pimg_header->ih_hcrc);
+    pimg_header->ih_hcrc = 0;
+    
+    asm("sync");
+    ret_check = crc32(0, (unsigned char *) src, hdr_len);
+    if (ret_check != checksum)
+        return -1;
+
+    asm("sync");
+    memcpy((u32 *) load_addr, (u32 *)image_start, image_len);
+
+    return 0; // success
+}
+
+#ifdef CONFIG_LTQ_SECURE_BOOT
+#define ROLLBACKID_BUFF 0xBF806100
+//#define ROLLBACKID_BUFF 0xA0100000
+
+#ifdef CPHYSADDR
+	#undef CPHYSADDR
+	#define PHYS_ADDR(a) (unsigned long)a<0xb0000000?((((unsigned long)a) & 0x1fffffff) | 0x20000000):(((unsigned long)a) & 0x1fffffff)
+	#define CPHYSADDR(a) cpu_is_cps()?(PHYS_ADDR(a)+0xa0000000):(PHYS_ADDR(a))
+	#undef KSEG1ADDR
+	#define KSEG1ADDR(a) ((unsigned long)a & 0x1fffffff)|KSEG1;
+#endif
+
+void rollback_id_chk_pre(u32 addr)
+{
+    memcpy((void*)ROLLBACKID_BUFF, (const void*)addr, (size_t)264);
+    return;
+}
+
+void rollback_id_chk_do()
+{
+    u32 val   = 0;
+    u32 a6    = 0;
+    u32 akek  = 0;
+    u32 i     = 0;
+    u8  *pTmp = 0;
+    u32 word  = 0;
+    u32 aw    = 0;
+    u32 id    = 0;
+    u32 cid   = 0;
+    u32 reset = 0;
+
+    REG32(0xbe003f00) = 0x00000004;
+
+    REG32(0xbe000000) = 0x07000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe00000C) = 0x00068000;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rst;
+    }
+    a6 = REG32(0xbe000004);
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x07000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = 0x00003001;
+    REG32(0xbe00000C) = 0x00000020;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rst;
+    }
+    akek = REG32(0xbe000004);
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x17000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = akek;
+    REG32(0xbe00000C) = 0x01400000;
+    REG32(0xbe00001C) = a6;
+    for (i=0; i<64; i+=4)
+    {
+        pTmp  = ROLLBACKID_BUFF+8+i;
+        word  = *pTmp++;
+        word |= (*pTmp++) << 8;
+        word |= (*pTmp++) << 16;
+        word |= (*pTmp++) << 24;
+        REG32(0xbe000020+i) = word;
+    }
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_akek;
+    }
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x07000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = 0x00003001;
+    REG32(0xbe00000C) = 0x00000020;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_akek;
+    }
+    aw = REG32(0xbe000004);
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x17000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = aw;
+    REG32(0xbe00000C) = 0x10000028;
+    REG32(0xbe000010) = CPHYSADDR(ROLLBACKID_BUFF+136);
+    #if 0
+     REG32(0xbe000014) = 0xAAAAAAAA;
+     REG32(0xbe000018) = 0xAAAAAAAA;
+    #endif
+    REG32(0xbe00001C) = akek;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_aw;
+    }
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x0100BABE;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = 0x00000040;
+    REG32(0xbe00000C) = CPHYSADDR(ROLLBACKID_BUFF+196);
+    REG32(0xbe000010) = 0x00000040;
+    REG32(0xbe000014) = 0x00000000;
+    REG32(0xbe000018) = CPHYSADDR(ROLLBACKID_BUFF+196);
+    REG32(0xbe00001C) = 0x00000040;
+    REG32(0xbe000020) = 0x00000000;
+    REG32(0xbe000028) = 0x00030110;
+    for (i=0; i<16; i+=4)
+    {
+        pTmp  = ROLLBACKID_BUFF+176+i;
+        word  = *pTmp++;
+        word |= (*pTmp++) << 8;
+        word |= (*pTmp++) << 16;
+        word |= (*pTmp++) << 24;
+        REG32(0xbe000030+i) = word;
+    }
+    REG32(0xbe000040) = aw;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if (REG32(0xbe000000) != 0x0000BABE)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_aw;
+    }
+    REG32(0xbe003f00) = 0x00000002;
+
+    for (i=0; i<64; i+=8)
+    {
+        if(*((u32*)(ROLLBACKID_BUFF+196+i)) == 0)
+            break;
+
+        if(*((u32*)(ROLLBACKID_BUFF+196+i)) == 2)
+        {
+            id = *((u32*)(ROLLBACKID_BUFF+196+i+4));
+            break;
+        }
+    }
+    if (REG32(0xb6080304) == 0xFFFFFFFFUL)
+        cid = 32; // safety against undefine ffz when no 0
+    else
+        /* the index of first zero coincidentally also count the number of consecutive trailing bit 1 */
+        cid = ffz(REG32(0xb6080304));
+
+    if (id < cid)
+        reset = 1;
+
+    rm_aw:
+    REG32(0xbe000000) = 0x37000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = aw;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    #if 0
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        return;
+    }
+    #endif
+    REG32(0xbe003f00) = 0x00000002;
+
+    rm_akek:
+    REG32(0xbe000000) = 0x37000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = akek;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    #if 0
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        return;
+    }
+    #endif
+    REG32(0xbe003f00) = 0x00000002;
+
+    memset((void*)ROLLBACKID_BUFF,0,(size_t)264);
+
+    rst:
+    if(reset)
+        REG32(0xb6000010) |= 0x40000000;
+
+    return;
+}
+
+// make sure to put image in 0xa0800000
+void bootrom_auth(u32 addr)
+{
+    ulong *img_p = (ulong *)addr;
+    int    image_len;
+    int    certnum;
+
+    void (*auth)(u32 addr, int len, u32* entry_p, u32* target_p) = (void*)0x9fc1a001;
+
+    certnum   = (int)(*(img_p+65));
+    image_len = 66*4+128*certnum+(int)(*(img_p+48));
+
+    asm("sync");
+
+    rollback_id_chk_pre(addr);
+    rollback_id_chk_do();
+    auth((u32)img_p, image_len, NULL, NULL);
+    // rollback_id_chk_do(); //safer after auth but cant check bootcore if put here
+
+    return;
+}
+#endif /* CONFIG_LTQ_SECURE_BOOT */
+
+#endif /* CONFIG_DRIVER_GRX500 */
+
+/*
+ * NAND command for large page NAND devices (2k)
+ */
+static int nand_command(struct mtd_info *mtd, int block, int page, int offs, u8 cmd)
+{
+	struct nand_chip *this = mtd->priv;
+	int page_addr = page + block * CONFIG_SYS_NAND_PAGE_COUNT;
+
+	if (this->dev_ready)
+		while (!this->dev_ready(mtd))
+			;
+	else
+		CONFIG_SYS_NAND_READ_DELAY;
+
+	/* Emulate NAND_CMD_READOOB */
+	if (cmd == NAND_CMD_READOOB) {
+		offs += CONFIG_SYS_NAND_PAGE_SIZE;
+		cmd = NAND_CMD_READ0;
+	}
+
+	/* Begin command latch cycle */
+	this->cmd_ctrl(mtd, cmd, NAND_CTRL_CLE | NAND_CTRL_CHANGE);
+	/* Set ALE and clear CLE to start address cycle */
+	/* Column address */
+	this->cmd_ctrl(mtd, offs & 0xff,
+		       NAND_CTRL_ALE | NAND_CTRL_CHANGE); /* A[7:0] */
+	this->cmd_ctrl(mtd, (offs >> 8) & 0xff, NAND_CTRL_ALE); /* A[11:9] */
+	/* Row address */
+	this->cmd_ctrl(mtd, (page_addr & 0xff), NAND_CTRL_ALE); /* A[19:12] */
+	this->cmd_ctrl(mtd, ((page_addr >> 8) & 0xff),
+		       NAND_CTRL_ALE); /* A[27:20] */
+#ifdef CONFIG_SYS_NAND_5_ADDR_CYCLE
+	/* One more address cycle for devices > 128MiB */
+	this->cmd_ctrl(mtd, (page_addr >> 16) & 0x0f,
+		       NAND_CTRL_ALE); /* A[31:28] */
+#endif
+	/* Latch in address */
+	this->cmd_ctrl(mtd, NAND_CMD_READSTART,
+		       NAND_CTRL_CLE | NAND_CTRL_CHANGE);
+	this->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+
+	/*
+	 * Wait a while for the data to be ready
+	 */
+	if (this->dev_ready)
+		while (!this->dev_ready(mtd))
+			;
+	else
+		CONFIG_SYS_NAND_READ_DELAY;
+
+	return 0;
+}
+
+static int nand_is_bad_block(struct mtd_info *mtd, int block)
+{
+
+	return 0;
+}
+
+static int nand_read_page(struct mtd_info *mtd, int block, int page, uchar *dst)
+{
+	struct nand_chip *this = mtd->priv;
+	nand_command(mtd, block, page, 0, NAND_CMD_READ0);
+    this->ecc.read_page(mtd, this, dst, page);
+							
+	return 0;
+}
+
+static int nand_load(struct mtd_info *mtd, unsigned int offs,
+		     unsigned int uboot_size, uchar *dst)
+{
+	unsigned int block, lastblock;
+	unsigned int page;
+
+	/*
+	 * offs has to be aligned to a page address!
+	 */
+	block = offs / CONFIG_SYS_NAND_BLOCK_SIZE;
+	lastblock = (offs + uboot_size - 1) / CONFIG_SYS_NAND_BLOCK_SIZE;
+	page = (offs % CONFIG_SYS_NAND_BLOCK_SIZE) / CONFIG_SYS_NAND_PAGE_SIZE;
+
+	while (block <= lastblock) {
+		if (!nand_is_bad_block(mtd, block)) {
+			/*
+			 * Skip bad blocks
+			 */
+			while (page < CONFIG_SYS_NAND_PAGE_COUNT) {
+				nand_read_page(mtd, block, page, dst);
+				dst += CONFIG_SYS_NAND_PAGE_SIZE;
+				page++;
+			}
+
+			page = 0;
+		} else {
+			lastblock++;
+		}
+
+		block++;
+	}
+
+	return 0;
+}
+
+/*
+ * The main entry for NAND booting. It's necessary that SDRAM is already
+ * configured and available since this code loads the main U-Boot image
+ * from NAND into SDRAM and starts it from there.
+ */
+void nand_boot(void)
+{
+	struct nand_chip nand_chip;
+	nand_info_t nand_info;
+	int ret;
+	int i;
+	ulong  ecc;
+        ulong  buffer[8];
+        ulong ddr_magic=0x88888888;
+	__attribute__((noreturn)) void (*uboot)(void);
+    
+#if defined(CONFIG_LTQ_SECURE_BOOT) && (!CONFIG_DRIVER_GRX500)
+        unsigned char aes_key[32];
+        unsigned char iv[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+        unsigned char* masked_key=(unsigned char*)(CONFIG_NAND_SPL_TEXT_BASE+0x6000);
+#endif
+
+#if defined(CONFIG_DRIVER_GRX500) && !defined(CONFIG_GRX500_BOOT_4KEC_ONLY)
+	/* Since IAP has already initialised the H/W, we do not want to 
+	 * reset the nand datapath when 4kec boots. Otherwise, there will
+	 * be a write hang issue 
+     */
+	if (!cpu_is_cps())
+		goto cpy_bootcore;
+#endif
+    	
+	/*
+	 * Init board specific nand support
+	 */
+	nand_info.priv = &nand_chip;
+	nand_chip.IO_ADDR_R = nand_chip.IO_ADDR_W = (void  __iomem *)CONFIG_SYS_NAND_BASE;
+	nand_chip.dev_ready = NULL;	/* preset to NULL */
+	board_nand_init(&nand_chip);
+
+	if (nand_chip.select_chip)
+		nand_chip.select_chip(&nand_info, 0);
+  
+    NAND_WRITE(WRITE_CMD, 0xff);
+    while(!NAND_READY){}
+  
+    nand_info.erasesize = CONFIG_NAND_BLOCK_SIZE; 
+    nand_info.writesize = CONFIG_NAND_PAGE_SIZE;
+    nand_chip.onfi_version = 1;
+#ifndef CONFIG_DRIVER_GRX500
+    init_ddr();
+#endif
+#ifdef CONFIG_TUNE_DDR    
+    nand_load(&nand_info, IFX_CFG_FLASH_DDR_CFG_END_ADDR+1-CONFIG_SYS_NAND_PAGE_SIZE, CONFIG_SYS_NAND_PAGE_SIZE, (u8*)0xa0100000);
+    buffer[0] = 0;
+    for(i=0;i<8;i++){
+    buffer[i] = *(volatile u32*)((u8*)0xa0100000+CONFIG_NAND_PAGE_SIZE-32+i*4); 
+     }
+    if(buffer[0]==ddr_magic)
+       {
+             ecc=buffer[1]^buffer[2]^buffer[3]^buffer[4]^buffer[5]^buffer[6];
+               if(ecc!=buffer[7]){
+                  REG32(CONFIG_TUNING_STATUS)=0xff;
+                }else{
+                    REG32(CONFIG_TUNING_STATUS)=0;
+                }
+         }
+     else{
+        REG32(CONFIG_TUNING_STATUS)=0xff;
+    }
+     if(REG32(CONFIG_TUNING_STATUS)!=0xff){
+          REG32(0xBF801000) = 0x0 ; 	    
+          REG32(0xBF8014C0) = buffer[1]; /*PHYR6*/
+          REG32(0xBF8014D0) = buffer[2]; /*PHYR8*/
+          REG32(0xBF8014E0) = buffer[3]; /*PHYR7*/
+          REG32(0xBF8014F0) = buffer[4]; /*PHYR9*/
+          REG32(CSS_DDR_ECHO_DLL0) = buffer[5];
+          REG32(CSS_DDR_ECHO_DLL1) = buffer[6];
+          REG32(0xBF801000) = 0x401;
+          mdelay(1);
+      }
+    tune_ddr();
+#endif	
+
+#if defined(CONFIG_DRIVER_GRX500) && !defined(CONFIG_GRX500_BOOT_4KEC_ONLY)
+cpy_bootcore:
+	if (!cpu_is_cps()) { /* 4Kec only */
+		ulong load_address;
+		ulong jump_address;
+		ulong ddr_address, bootcore_size;
+		asm("sync");
+
+		load_address = REG32(MPS_LOAD_ADDR); /* 4Kec load addr */
+		ddr_address = REG32(MPS_DDR_LOC);	 /* ddr where TOS is copied to */
+		bootcore_size = REG32(MPS_SIZE_LOC); /* size of TOS/bootcore img */
+
+		#if defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT)
+		/* reuse ddr loc only */
+		bootrom_auth((u32)ddr_address);
+
+		/* safeguard , but shall never come here in first place*/
+		while(1);
+		#else /* defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT) */
+		/* copy bootcore image */ 
+		memcpy((unsigned char *) load_address,
+				(unsigned char *) ddr_address,
+				bootcore_size);
+
+		ret = check_4kec_header(load_address,
+							&jump_address,
+							bootcore_size);
+        if (ret)
+            while(1); // if img is bad, we prevent 4kec from loading it
+
+		uboot = (void*)jump_address;
+		(*uboot)();
+		#endif /*  defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT) */
+	} 
+#endif /* CONFIG_DRIVER_GRX500 && !CONFIG_GRX500_BOOT_4KEC_ONLY */
+
+	/*
+	 * Load U-Boot image from NAND into RAM
+	 */
+    #if defined(CONFIG_LTQ_SECURE_BOOT) && defined(CONFIG_DRIVER_GRX500) && !defined(CONFIG_MANUBOOT)
+    ret = nand_load(&nand_info, CONFIG_SYS_NAND_U_BOOT_OFFS, CONFIG_SYS_NAND_U_BOOT_SIZE,
+                    (uchar *)0xa0800000);
+    #else
+	ret = nand_load(&nand_info, CONFIG_SYS_NAND_U_BOOT_OFFS, CONFIG_SYS_NAND_U_BOOT_SIZE,
+			(uchar *)CONFIG_SYS_NAND_U_BOOT_DST);
+    #endif /* defined(CONFIG_LTQ_SECURE_BOOT) && defined(CONFIG_DRIVER_GRX500) && !defined(CONFIG_MANUBOOT) */
+
+#ifdef CONFIG_NAND_ENV_DST
+	nand_load(&nand_info, CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+		  (uchar *)CONFIG_NAND_ENV_DST);
+
+#ifdef CONFIG_ENV_OFFSET_REDUND
+	nand_load(&nand_info, CONFIG_ENV_OFFSET_REDUND, CONFIG_ENV_SIZE,
+		  (uchar *)CONFIG_NAND_ENV_DST + CONFIG_ENV_SIZE);
+#endif
+#endif
+	if (nand_chip.select_chip)
+		nand_chip.select_chip(&nand_info, -1);
+
+#ifndef CONFIG_MANUBOOT
+#ifdef CONFIG_LTQ_SECURE_BOOT
+#ifndef CONFIG_DRIVER_GRX500
+#include "mask.h"
+extern secure_decrypt(u8 *key, u8 *iv, u8 *src, u8 *dst, u32 nbytes);
+extern void flush_dcache_range(ulong start_addr, ulong stop);
+       for(i=0;i<32;i++){
+           aes_key[i]=masked_key[i]^mask[i];
+           masked_key[i]=mask[i]=0xff;
+    			          }
+	   secure_decrypt(aes_key, iv,(u8*)CONFIG_STAGE2_LOADADDR,\
+	                 (u8*)CONFIG_STAGE2_LOADADDR, CONFIG_STAGE2_SIZE);
+	   flush_dcache_range((ulong)CONFIG_STAGE2_LOADADDR,\
+	                      (ulong)(CONFIG_STAGE2_LOADADDR+CONFIG_STAGE2_SIZE));
+#else
+    #if defined(CONFIG_GRX500_BOOT_4KEC_ONLY)
+    bootrom_auth(0xa0800000);
+    #else /* defined(CONFIG_GRX500_BOOT_4KEC_ONLY) */
+    /* Inform 4kec , to auth img */
+    REG32(SRAMFLAG) = IPCMAGIC;
+    /* wait for reply , assume during delay, SRAMFLAG will be cleared by 4kec */
+    mdelay(200);
+    while (REG32(SRAMFLAG) != (~IPCMAGIC));
+    REG32(SRAMFLAG) = 0;
+    asm("sync");
+    #endif /* defined(CONFIG_GRX500_BOOT_4KEC_ONLY) */
+#endif
+#endif
+#endif /* CONFIG_MANUBOOT */
+
+	/*
+	 * Jump to U-Boot image
+	 */
+	uboot = (void *)CONFIG_SYS_NAND_U_BOOT_START;
+	(*uboot)();
+}
diff --git a/nand_spl/spinand_boot.c b/nand_spl/spinand_boot.c
new file mode 100755
--- /dev/null
+++ b/nand_spl/spinand_boot.c
@@ -0,0 +1,500 @@
+/*
+ * (C) Copyright 2006-2008
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <image.h>
+#include <asm/boot.h>
+#include <spinand.h>
+
+extern int cpu_is_cps(void);
+unsigned char oob_buf[64];
+
+#define TOTAL_MALLOC_LEN    CONFIG_SYS_MALLOC_LEN
+#define CONFIG_SYS_NAND_READ_DELAY \
+	{ volatile int dummy; int i; for (i=0; i<10000; i++) dummy = i; }
+
+#ifdef CONFIG_DRIVER_GRX500
+ #if defined (CONFIG_NAND_ECC_SOFT)
+ static int nand_ecc_pos[] = CONFIG_SYS_NAND_ECCPOS;
+ #elif defined (CONFIG_NAND_ECC_BCH) 
+ static int *nand_ecc_pos;
+ #endif
+#else 
+ static int nand_ecc_pos[] = CONFIG_SYS_NAND_ECCPOS;
+ #define CONFIG_NAND_SPL_OOBSIZE		CONFIG_SYS_NAND_OOBSIZE	
+#endif /* CONFIG_DRIVER_GRX500 */
+
+#if defined (CONFIG_DRIVER_GRX500)
+static int check_4kec_header(u32 src, u32 *jmp_addr, u32 dst_size)
+{
+	int image_len;
+    u8 *image_start = NULL;
+    u32 ret_check, checksum = 0;
+	u32 hdr_len, load_addr;
+	image_header_t *pimg_header = (image_header_t *)src;
+    
+	/* check magic number */
+	if (ntohl(pimg_header->ih_magic) != IH_MAGIC)
+		return -1;
+
+	asm("sync");
+	/* mkimage type kernel without the 8B offset */
+	image_start = (u8 *)pimg_header + sizeof(image_header_t);
+    image_len = ntohl(pimg_header->ih_size);
+	load_addr = ntohl(pimg_header->ih_load);
+	*jmp_addr = load_addr;
+	asm("sync");
+
+	hdr_len = sizeof(image_header_t);
+	checksum = ntohl(pimg_header->ih_hcrc);
+	pimg_header->ih_hcrc = 0;
+
+	asm("sync");
+	ret_check = crc32(0, (unsigned char *) src, hdr_len);
+	if (ret_check != checksum)
+		return -1;
+
+	asm("sync");
+	memcpy((u32 *) load_addr, (u32 *)image_start, image_len);
+
+	return 0; // success
+}
+
+#endif /* CONFIG_DRIVER_GRX500 */ 
+
+#ifdef CONFIG_LTQ_SECURE_BOOT
+
+#define ROLLBACKID_BUFF 0xBF806100
+//#define ROLLBACKID_BUFF 0xA0100000
+
+#ifdef CPHYSADDR
+	#undef CPHYSADDR
+	#define PHYS_ADDR(a) (unsigned long)a<0xb0000000?((((unsigned long)a) & 0x1fffffff) | 0x20000000):(((unsigned long)a) & 0x1fffffff)
+	#define CPHYSADDR(a) cpu_is_cps()?(PHYS_ADDR(a)+0xa0000000):(PHYS_ADDR(a))
+	#undef KSEG1ADDR
+	#define KSEG1ADDR(a) ((unsigned long)a & 0x1fffffff)|KSEG1;
+#endif
+
+void rollback_id_chk_pre(u32 addr)
+{
+    memcpy((void*)ROLLBACKID_BUFF, (const void*)addr, (size_t)264);
+    return;
+}
+
+void rollback_id_chk_do()
+{
+    u32 val   = 0;
+    u32 a6    = 0;
+    u32 akek  = 0;
+    u32 i     = 0;
+    u8  *pTmp = 0;
+    u32 word  = 0;
+    u32 aw    = 0;
+    u32 id    = 0;
+    u32 cid   = 0;
+    u32 reset = 0;
+
+    REG32(0xbe003f00) = 0x00000004;
+
+    REG32(0xbe000000) = 0x07000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe00000C) = 0x00068000;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rst;
+    }
+    a6 = REG32(0xbe000004);
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x07000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = 0x00003001;
+    REG32(0xbe00000C) = 0x00000020;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rst;
+    }
+    akek = REG32(0xbe000004);
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x17000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = akek;
+    REG32(0xbe00000C) = 0x01400000;
+    REG32(0xbe00001C) = a6;
+    for (i=0; i<64; i+=4)
+    {
+        pTmp  = ROLLBACKID_BUFF+8+i;
+        word  = *pTmp++;
+        word |= (*pTmp++) << 8;
+        word |= (*pTmp++) << 16;
+        word |= (*pTmp++) << 24;
+        REG32(0xbe000020+i) = word;
+    }
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_akek;
+    }
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x07000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = 0x00003001;
+    REG32(0xbe00000C) = 0x00000020;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_akek;
+    }
+    aw = REG32(0xbe000004);
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x17000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = aw;
+    REG32(0xbe00000C) = 0x10000028;
+    REG32(0xbe000010) = CPHYSADDR(ROLLBACKID_BUFF+136);
+    #if 0
+     REG32(0xbe000014) = 0xAAAAAAAA;
+     REG32(0xbe000018) = 0xAAAAAAAA;
+    #endif
+    REG32(0xbe00001C) = akek;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_aw;
+    }
+    REG32(0xbe003f00) = 0x00000002;
+
+    REG32(0xbe000000) = 0x0100BABE;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = 0x00000040;
+    REG32(0xbe00000C) = CPHYSADDR(ROLLBACKID_BUFF+196);
+    REG32(0xbe000010) = 0x00000040;
+    REG32(0xbe000014) = 0x00000000;
+    REG32(0xbe000018) = CPHYSADDR(ROLLBACKID_BUFF+196);
+    REG32(0xbe00001C) = 0x00000040;
+    REG32(0xbe000020) = 0x00000000;
+    REG32(0xbe000028) = 0x00030110;
+    for (i=0; i<16; i+=4)
+    {
+        pTmp  = ROLLBACKID_BUFF+176+i;
+        word  = *pTmp++;
+        word |= (*pTmp++) << 8;
+        word |= (*pTmp++) << 16;
+        word |= (*pTmp++) << 24;
+        REG32(0xbe000030+i) = word;
+    }
+    REG32(0xbe000040) = aw;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    if (REG32(0xbe000000) != 0x0000BABE)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        reset = 1;
+        goto rm_aw;
+    }
+    REG32(0xbe003f00) = 0x00000002;
+
+    for (i=0; i<64; i+=8)
+    {
+        if(*((u32*)(ROLLBACKID_BUFF+196+i)) == 0)
+            break;
+
+        if(*((u32*)(ROLLBACKID_BUFF+196+i)) == 2)
+        {
+            id = *((u32*)(ROLLBACKID_BUFF+196+i+4));
+            break;
+        }
+    }
+    if (REG32(0xb6080304) == 0xFFFFFFFFUL)
+        cid = 32; // safety against undefine ffz when no 0
+    else
+        /* the index of first zero coincidentally also count the number of consecutive trailing bit 1 */
+        cid = ffz(REG32(0xb6080304));
+
+    if (id < cid)
+        reset = 1;
+
+    rm_aw:
+    REG32(0xbe000000) = 0x37000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = aw;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    #if 0
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        return;
+    }
+    #endif
+    REG32(0xbe003f00) = 0x00000002;
+
+    rm_akek:
+    REG32(0xbe000000) = 0x37000000;
+    REG32(0xbe000004) = 0x4011BA23;
+    REG32(0xbe000008) = akek;
+    REG32(0xbe003f00) = 0x00000001;
+    val = REG32(0xbe003f00);
+    while( (val & 0x00000002) != 2)
+        val = REG32(0xbe003f00);
+    #if 0
+    if ((REG32(0xbe000000) & 0x80000000) != 0)
+    {
+        REG32(0xbe003f00) = 0x00000002;
+        return;
+    }
+    #endif
+    REG32(0xbe003f00) = 0x00000002;
+
+    memset((void*)ROLLBACKID_BUFF,0,(size_t)264);
+
+    rst:
+    if(reset)
+        REG32(0xb6000010) |= 0x40000000;
+
+    return;
+}
+
+void bootrom_auth(u32 addr)
+{
+    ulong *img_p = (ulong *)addr;
+    int    image_len;
+    int    certnum;
+
+    void (*auth)(u32 addr, int len, u32* entry_p, u32* target_p) = (void*)0x9fc1a001;
+
+    certnum   = (int)(*(img_p+65));
+    image_len = 66*4+128*certnum+(int)(*(img_p+48));
+
+    asm("sync");
+
+    rollback_id_chk_pre(addr);
+    rollback_id_chk_do();
+    auth((u32)img_p, image_len, NULL, NULL);
+    // rollback_id_chk_do(); //safer after auth but cant check bootcore if put here
+
+    return;
+}
+#endif /* CONFIG_LTQ_SECURE_BOOT */
+
+
+static int nand_load(struct mtd_info *mtd, unsigned int offs,
+		     unsigned int uboot_size, uchar *dst)
+{
+	unsigned int block, lastblock;
+	unsigned int page;
+        struct nand_chip *chip =(struct nand_chip*)mtd->priv;
+	/*
+	 * offs has to be aligned to a page address!
+	 */
+	block = offs / CONFIG_SYS_NAND_BLOCK_SIZE;
+	lastblock = (offs + uboot_size - 1) / CONFIG_SYS_NAND_BLOCK_SIZE;
+	page = (offs % CONFIG_SYS_NAND_BLOCK_SIZE) / CONFIG_SYS_NAND_PAGE_SIZE;
+
+	while (block <= lastblock) {
+				if (!chip->block_bad(mtd, offs, 0)){
+			/*
+			 * Skip bad blocks
+			 */
+			while (page < CONFIG_SYS_NAND_PAGE_COUNT) {
+				chip->ecc.read_page(mtd, chip, dst,block*CONFIG_SYS_NAND_PAGE_COUNT+page);
+				dst += CONFIG_SYS_NAND_PAGE_SIZE;
+				page++;
+			}
+			page = 0;
+		} else {
+			lastblock++;
+		}
+
+		block++;
+	}
+	return 0;
+}
+
+/*
+ * The main entry for NAND booting. It's necessary that SDRAM is already
+ * configured and available since this code loads the main U-Boot image
+ * from NAND into SDRAM and starts it from there.
+ */
+void nand_boot(void)
+{
+	struct nand_chip nand_chip;
+	nand_info_t nand_info;
+	struct spinand_info* spinand_info;
+        int ret;
+	__attribute__((noreturn)) void (*uboot)(void);
+
+#if defined(CONFIG_DRIVER_GRX500) && !defined(CONFIG_GRX500_BOOT_4KEC_ONLY)
+    /* Since IAP has already initialised the H/W, we do not want to 
+     * reset the nand datapath when 4kec boots. Otherwise, there will
+     * be an unknown state for the controller when IAP access the EBU bus 
+     */
+    if (!cpu_is_cps())
+        goto cpy_bootcore;
+#endif
+
+	memset(&nand_chip, 0, sizeof(struct nand_chip));
+	/*
+	 * Init board specific nand support
+	 */
+	nand_info.priv = &nand_chip;
+	board_nand_init(&nand_chip);
+
+	if (nand_chip.select_chip)
+		nand_chip.select_chip(&nand_info, 0);
+
+#ifdef CONFIG_GIGA_DEVICE_SPINAND
+        spinand_info=(struct spinand_info*)nand_chip.priv;
+        spinand_info->options|=GIGADEVICE_DUMMY_TYPE;
+#endif 
+
+        nand_info.size=CONFIG_NAND_FLASH_SIZE*(1<<20);
+        nand_info.erasesize=CONFIG_NAND_BLOCK_SIZE;
+        nand_info.writesize=CONFIG_NAND_PAGE_SIZE;
+        nand_info.oobsize=64;
+        nand_chip.page_shift=ffs(nand_info.writesize)-1;
+        nand_chip.bbt_erase_shift=ffs(nand_info.erasesize)-1;
+        nand_chip.numchips=1;
+        nand_chip.chipsize=nand_info.size;
+        nand_chip.oob_poi=&oob_buf;
+
+
+cpy_bootcore:
+#if !defined(CONFIG_GRX500_BOOT_4KEC_ONLY) && defined(CONFIG_DRIVER_GRX500)
+    if (cpu_is_cps()) {
+#endif /* CONFIG_GRX500_BOOT_4KEC_ONLY && CONFIG_DRIVER_GRX500 */
+
+    /*
+	 * Load U-Boot image from NAND into RAM
+	 */
+#if defined(CONFIG_LTQ_SECURE_BOOT) && defined(CONFIG_DRIVER_GRX500) && !defined(CONFIG_MANUBOOT)
+        ret = nand_load(&nand_info, CONFIG_SYS_NAND_U_BOOT_OFFS, CONFIG_SYS_NAND_U_BOOT_SIZE,
+                        (uchar *)0xa0800000);
+#else
+        ret = nand_load(&nand_info, CONFIG_SYS_NAND_U_BOOT_OFFS, CONFIG_SYS_NAND_U_BOOT_SIZE,
+			(uchar *)CONFIG_SYS_NAND_U_BOOT_DST);
+#endif /* CONFIG_LTQ_SECURE_BOOT && CONFIG_DRIVER_GRX500 */
+
+#ifdef CONFIG_NAND_ENV_DST
+	nand_load(&nand_info, CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+		  (uchar *)CONFIG_NAND_ENV_DST);
+
+#ifdef CONFIG_ENV_OFFSET_REDUND
+	nand_load(&nand_info, CONFIG_ENV_OFFSET_REDUND, CONFIG_ENV_SIZE,
+		  (uchar *)CONFIG_NAND_ENV_DST + CONFIG_ENV_SIZE);
+#endif /* CONFIG_ENV_OFFSET_REDUND */
+#endif /* CONFIG_NAND_ENV_DST */
+
+	if (nand_chip.select_chip)
+		nand_chip.select_chip(&nand_info, -1);
+
+       asm("sync");
+
+#ifndef CONFIG_MANUBOOT
+#if defined(CONFIG_LTQ_SECURE_BOOT) && defined(CONFIG_DRIVER_GRX500)
+    #if defined(CONFIG_GRX500_BOOT_4KEC_ONLY)
+    bootrom_auth(0xa0800000);
+    #else /* defined(CONFIG_GRX500_BOOT_4KEC_ONLY) */
+    /* Inform 4kec , to auth img */
+    REG32(SRAMFLAG) = IPCMAGIC;
+    /* wait for reply , assume during delay, SRAMFLAG will be cleared by 4kec */
+    mdelay(200);
+    while (REG32(SRAMFLAG) != (~IPCMAGIC));
+    REG32(SRAMFLAG) = 0;
+    asm("sync");
+    #endif /* defined(CONFIG_GRX500_BOOT_4KEC_ONLY) */
+#endif /* CONFIG_LTQ_SECURE_BOOT && CONFIG_DRIVER_GRX500 && CONFIG_GRX500_A21 */ 
+#endif /* CONFIG_MANUBOOT */
+	/*
+	 * Jump to U-Boot image
+	 */
+	uboot = (void *)CONFIG_SYS_NAND_U_BOOT_START;
+	(*uboot)();
+
+#if !defined(CONFIG_GRX500_BOOT_4KEC_ONLY) && defined(CONFIG_DRIVER_GRX500)
+    } else {
+        ulong load_address;
+        ulong jump_address;
+		ulong ddr_address, bootcore_size;
+
+		asm("sync");
+		load_address = REG32(MPS_LOAD_ADDR); /* 4Kec load addr */
+		ddr_address = REG32(MPS_DDR_LOC);	 /* ddr where TOS is copied to */
+		bootcore_size = REG32(MPS_SIZE_LOC); /* size of TOS/bootcore img */
+
+        #if defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT)
+        /* reuse ddr loc only */
+        bootrom_auth((u32)ddr_address);
+
+        /* safeguard , but shall never come here in first place*/
+        while(1);
+        #else /* defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT) */
+		memcpy((unsigned char *) load_address, 
+				(unsigned char *) ddr_address, 
+				bootcore_size);
+
+		ret = check_4kec_header(load_address, 
+								&jump_address, 
+								bootcore_size);
+		if (ret)
+			while(1); // if img is bad, we prevent 4kec from loading it
+
+        uboot = (void*)jump_address;
+        (*uboot)();
+        #endif /* defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT) */
+    }
+#endif /* CONFIG_GRX500_BOOT_4KEC_ONLY  && CONFIG_DRIVER_GRX500 */
+}
