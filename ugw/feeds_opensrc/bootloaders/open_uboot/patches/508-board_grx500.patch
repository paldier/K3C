# HG changeset patch
# Parent 1b9838bffd3a019c9c0dac45305000d51a776cbb

diff --git a/arch/mips/cpu/grx500/init_caches2.S b/arch/mips/cpu/grx500/init_caches2.S
deleted file mode 100755
--- a/arch/mips/cpu/grx500/init_caches2.S
+++ /dev/null
@@ -1,255 +0,0 @@
-#include <asm/boot.h>
-#include <asm/regdef.h>
-#include <asm/mipsregs.h>
-	.set	noreorder           // Don't allow the assembler to reorder instructions.
-	.set	noat                // Don't allow the assembler to use r1(at) for synthetic instr.
-
-/**************************************************************************************
-* init_icache invalidates all Instruction cache entries
-**************************************************************************************/
-
-LEAF(sys_init_icache)
-
-	// Can be skipped if using magic simulation cache flush
-
-	// Determine how big the I$ is
-	mfc0	v0, CP0_CONFIG, 1				
-
-	// I$ Line Size
-	ext	    v1, v0, MIPS_CONF1_IL_SHIFT, 3		// extract IL (16B/4KEc, 32B/InterAptiv)
-
-	// Skip ahead if No I$
-	beq	    v1, zero, done_icache
-	nop
-
-	li	    a2, 2
-	sllv    v1, a2, v1					// Now have true I$ line size in bytes (v1=32B/set) 
-
-	ext	    a0, v0,  MIPS_CONF1_IS_SHIFT , 3		// extract IS
-	li	    a2, 64
-	sllv    a0, a2, a0					// I$ Sets per way (512sets/way/4KEc, 256sets/way/InterAptiv)
-
-	// Config1IA == I$ Assoc - 1
-	ext	    a1, v0, MIPS_CONF1_IA_SHIFT, 3		// extract IA
-	add	    a1, 1					// a1 = 4 ways	
-
-	mul	    a0, a0, a1					// Total number of sets (2048sets/4KEc, 1024sets/InterAptiv)
-	lui	    a2, 0x8000					// 0x9fc0 Get a KSeg0 address for cacheops
-
-	// Clear TagLo/TagHi registers
-	mtc0    zero, CP0_TAGLO				// write C0_ITagLo $28,0
-
-	// For 4Kec
-	mtc0    zero, CP0_TAGHI
-
-	move    a3, a0						
-
-next_icache_tag:
-	cache   0x8, 0(a2)					// ICIndexStTag
-	add	    a3, -1						// Decrement set counter
-	bne     a3, zero, next_icache_tag
-	add     a2, v1						// Get next line address
-
-done_icache:
-
-    jr      ra
-    nop
-END(sys_init_icache)
-
-/**************************************************************************************
-* init_icache invalidates all Instruction cache entries
-**************************************************************************************/
-LEAF(sys_init_dcache)
-
-	mfc0	v0, CP0_CONFIG, 1				// read C0_Config1
-
-	// Isolate D$ Line Size
-	ext	    v1, v0,  MIPS_CONF1_DL_SHIFT, 3		// extract DL
-
-	// Skip ahead if No D$
-	beq	    v1, zero, done_dcache
-	nop
-
-	li	    a2, 2
-	sllv	v1, a2, v1					// Now have true D$ line size in bytes (16B/set/4KEc, 32B/set/InterAptiv)
-
-	ext	    a0, v0, MIPS_CONF1_DS_SHIFT, 3		// extract DS
-	li	    a2, 64
-	sllv	a0, a2, a0					// D$ Sets per way (512sets/way/4KEc, 256sets/way/InterAptiv)
-
-	ext	    a1, v0,  MIPS_CONF1_DA_SHIFT, 3		// extract DA
-	add	    a1, 1						// a1 = 4 ways
-
-	mul	    a0, a0, a1					// Get total number of sets (2048sets/4KEc, 1024sets/InterAptiv)
-
-	// Clear TagLo/TagHi registers
-	// Clear TagLo/TagHi registers
-	mtc0	zero, CP0_TAGLO				// write C0_TagLo 
-
-	// For 4Kec
-	mtc0    zero, CP0_TAGHI
-	
-	mtc0	zero, CP0_TAGLO, 2			// write C0_DTagLo
-	mtc0	zero, CP0_TAGHI, 2			// write C0_DTagHi
-	
-//DCIndexStTag	
-	lui     a2, 0x8000		    		// 9fc0 Get a KSeg0 address for cacheops
-	move	a3, a0						
-1:
-	// Index Store Tag Cache Op
-	// Will invalidate the tag entry, clear the lock bit, and clear the LRF bit
-
-        cache	    0x9, 0(a2)					// DCIndexStTag=0x9
-	add	    a3, -1			    		// Decrement set counter
-
-	bne	    a3, zero, 1b
-	add	    a2, v1		    			// Get next line address
-	
-done_dcache:
-    jr      ra
-    nop
-END(sys_init_dcache)
-
-/**************************************************************************************
-* fetch and lock 16KB dcache lines 
-**************************************************************************************/
-LEAF(init_dcache_lock)
-
-	mfc0	v0, CP0_CONFIG, 1				// read C0_Config1
-
-	// Isolate D$ Line Size
-	ext	    v1, v0,  MIPS_CONF1_DL_SHIFT, 3		// extract DL
-
-	// Skip ahead if No D$
-	beq	    v1, zero, done_dcache
-	nop
-
-	li	    a2, 2
-	sllv	v1, a2, v1					// Now have true D$ line size in bytes (16B/4KEc, 32B/InterAptiv)
-
-	ext	    a0, v0, MIPS_CONF1_DS_SHIFT, 3		// extract DS
-	li	    a2, 64
-	sllv	a0, a2, a0					// D$ Sets per way (512sets/way/4KEc, 256sets/way/InterAptiv)
-
-	ext	    a1, v0, MIPS_CONF1_DA_SHIFT, 3		// extract DA
-	add	    a1, 1						// (4ways/4KEc, 8ways/InterAptiv
-
-	mul	    a0, a0, a1					// Get total number of sets (2048sets/4KEc, 1024sets/InterAptiv)
-
-	
-//DCAddrFetchLock for first 8KBytes	
-	lui	    a2, 0x9fc0		    		// 9fc0 Get a KSeg0 address for cacheops
-	move	a3, a0						
-	
-	li		a0, 2
-	srlv	a3, a3, a0					// a3/=4, 8KByte 
-	
-1:
-	// Index Store Tag Cache Op
-	// Will invalidate the tag entry, clear the lock bit, and clear the LRF bit
-
-        cache	0x1d, 0(a2)					// DCAddrFetchLock=0x1d
-	add	    a3, -1			    		// Decrement set counter
-
-	bne	    a3, zero, 1b
-	add	    a2, v1		    			// Get next line address
-
-done_dcache_lock:
-    jr      ra
-    nop
-END(init_dcache_lock)
-
-/**************************************************************************************
-**************************************************************************************/
-LEAF(disable_L23)
-    beqz    r11_is_cps, done_disable_L23	# no cps skips
-    nop
-
-	bnez    r8_core_num, done_disable_L23	# Only done from core 0.
-
-    // Use CCA Override disable the L2 cache
-    // NOTE: If you have a L3 cache you must add code here
-    // to disable it or initialize it if it can't be disabled.
-    // Disable the L2 cache using CCA override by writing a 0x50 to
-    // the GCR Base register. 0x50 enables the CCA override bit and sets
-    // the CCA to uncached.
-
-	lw	    a0, 0x0008(r22_gcr_addr)  	// Read GCR_BASE
-    li      a3, 0x50                  	// Enable CCA and set to uncached
-    ins     a0, a3, 0, 8    			// Insert bits
-    sw      a0, 0x0008(r22_gcr_addr)  	// Write GCR_BASE
-
-done_disable_L23:
-    jr      ra
-    nop
-END(disable_L23)
-
-/**************************************************************************************
-* Initialize the L2 and L3 caches
-**************************************************************************************/
-LEAF(init_L23)
-    beqz    r11_is_cps, done_cach_init	// no cps skips
-    nop
-
-	bnez    r8_core_num, done_cach_init	// Only done from core 0.
-
-	// L2 Cache initialization routine
-	// Check L2 cache size
-	mfc0	v0, CP0_CONFIG, 2				// Read C0_Config2
-	// Isolate L2$ Line Size
-	ext	    v1, v0, 4, 4				// extract L2 line size
-	li	    a2, 2
-	sllv	v1, a2, v1					// Now have true L2$ line size in bytes (32B/InterAptiv)
-
-	// Isolate L2 Sets per Way (cache lines per way)
-	ext	    a3, v0, 8, 4				// extrace sets per way encoding
-	li	    a2, 64
-	sllv	a3, a2, a3					// L2$ Sets per way (1024 sets/way)
-
-	// Isolate L2 Associativity (number of ways)
-	// L2$ Assoc (-1)
-	ext	    a1, v0, 0, 4				// extract ways encoding
-	add	    a1, 1						// Decode L2 number of ways (8 ways)
-
-	mul	    a3, a3, a1					// Get total number of sets (8196 sets)
-	lui	    a2, 0x8000					// Get a KSeg0 address for cacheops
-
-	// Clear L23TagLo/L23TagHi registers these are used to set the cache tag
-	mtc0	zero, CP0_TAGLO, 4
-	
-	// L2$ Index Store Tag Cache Op
-	// Will invalidate the tag entry, clear the lock bit, and clear the LRF bit
-next_L2cache_tag:
-	cache	0xb, 0(a2)					// Write Tag using index store tag
-	add	    a3, -1						// Decrement set counter
-
-	bne	    a3, zero, next_L2cache_tag 	// Done yet?
-	add	    a2, v1						// Get next line address (each tag covers one line)
-
-done_l2cache:
-    // disable CCA Override to enable L2 cache
-	lw	    a0, 0x0008(r22_gcr_addr)  	// GCR_BASE
-    ins     a0, zero, 0, 8            	// CCA Override disabled
-    sw      a0, 0x0008(r22_gcr_addr)  	// GCR_BASE
-
-done_cach_init:
-    jr      ra
-    nop
-END(init_L23)
-
-LEAF(change_k0_cca)
-	// NOTE! This code must be executed in KSEG1 (not KSGE0 uncached)
-    // Set CCA for kseg0 to cacheable
-	mfc0	v0, CP0_CONFIG				// read C0_Config
-	beqz    r11_is_cps, set_kseg0_cca
-	li	    v1, 3						// CCA for non coherent core
-	li	    v1, 5						// CCA for coherent cores
-
-set_kseg0_cca:
-
-    ins	    v0, v1, 0, 3				// insert K0
-    mtc0	v0, CP0_CONFIG				// write C0_Config
-    jr.hb      ra
-    nop
-
-END(change_k0_cca)
diff --git a/arch/mips/cpu/grx500/init_cm.S b/arch/mips/cpu/grx500/init_cm.S
deleted file mode 100755
--- a/arch/mips/cpu/grx500/init_cm.S
+++ /dev/null
@@ -1,40 +0,0 @@
-#include <asm/boot.h>
-#include <asm/regdef.h>
-#include <asm/cps.h>
-
-	.set	noreorder           // Don't allow the assembler to reorder instructions.
-	.set	noat                // Don't allow the assembler to use r1(at) for synthetic instr.
-/**************************************************************************************
-**************************************************************************************/
-LEAF(init_cm)
-
-
-	// Allow each core access to the CM registers (they should only access their local registers.)
-	li	    a0, 2							// Start building mask for cores in this cps.
-    sll     a0, a0, r19_more_cores
-    addiu   a0, -1							// Complete mask.
-	sw	    a0, GCR_ACCESS(r22_gcr_addr)	// GCR_ACCESS
-
-    // Check to see if this CPS implements an IOCU.
-    lw      a0, GCR_CONFIG(r22_gcr_addr)	// Load GCR_CONFIG
-    ext	    a0, a0, NUMIOCU, NUMIOCU_S		// Extract NUMIOCU.
-    beqz    a0, done_cm_init
-    lui	    a0, 0xffff
-
-	// Disable the CM regions if there is an IOCU.
-	sw	    a0, GCR_REG0_BASE(r22_gcr_addr)	// GCR_REG0_BASE
-	sw	    a0, GCR_REG0_MASK(r22_gcr_addr)	// GCR_REG0_MASK
-	sw	    a0, GCR_REG1_BASE(r22_gcr_addr)	// GCR_REG1_BASE
-	sw	    a0, GCR_REG1_MASK(r22_gcr_addr)	// GCR_REG1_MASK
-	sw	    a0, GCR_REG2_BASE(r22_gcr_addr)	// GCR_REG2_BASE
-	sw	    a0, GCR_REG2_MASK(r22_gcr_addr)	// GCR_REG2_MASK
-	sw	    a0, GCR_REG3_BASE(r22_gcr_addr)	// GCR_REG3_BASE
-	sw	    a0, GCR_REG3_MASK(r22_gcr_addr)	// GCR_REG3_MASK
-	sw	    a0, GCR_REG4_BASE(r22_gcr_addr)	// GCR_REG4_BASE
-	sw	    a0, GCR_REG4_MASK(r22_gcr_addr)	// GCR_REG4_MASK
-	sw	    a0, GCR_REG5_BASE(r22_gcr_addr)	// GCR_REG5_BASE
-	sw	    a0, GCR_REG5_MASK(r22_gcr_addr)	// GCR_REG5_MASK
-done_cm_init:
-	jr      ra
-	nop
-END(init_cm)
diff --git a/arch/mips/cpu/grx500/init_cp0.S b/arch/mips/cpu/grx500/init_cp0.S
deleted file mode 100755
--- a/arch/mips/cpu/grx500/init_cp0.S
+++ /dev/null
@@ -1,73 +0,0 @@
-#include <asm/boot.h>
-#include <config.h>
-#include <asm/regdef.h>
-#include <asm/mipsregs.h>
-#include <asm/addrspace.h>
-
-
-	.set	noreorder           // Don't allow the assembler to reorder instructions.
-	.set	noat                // Don't allow the assembler to use r1(at) for synthetic instr.
-/**************************************************************************************
-**************************************************************************************/
-LEAF(init_cp0)
-
-        // Initialize Status
-	li	v1, 0x00400404		// (M_StatusBEV=1 | M_StatusIM | M_StatusERL) - Compatibility Int Mode
-	mtc0	v1, CP0_STATUS		// write C0_Status $12
-
-	// Initialize Watch registers if implemented.
-	mfc0	v0, CP0_CONFIG,1		// read C0_Config1
-	ext     v1, v0, 3, 1		// extract bit 3 WR (Watch registers implemented)
-	beq 	v1, zero, done_wr
-	li    	v1, 0x7				// (M_WatchHiI | M_WatchHiR | M_WatchHiW)
-
-	// Clear Watch Status bits and disable watch exceptions
-	mtc0	v1, CP0_WATCHHI		// write C0_WatchHi0
-	mfc0	v0, CP0_WATCHHI		// read C0_WatchHi0
-	beq 	v0, zero, done_wr
-	mtc0	zero, CP0_WATCHLO	// write C0_WatchLo0
-
-	mtc0	v1, CP0_WATCHHI, 1	// write C0_WatchHi1
-	mfc0	v0, CP0_WATCHHI, 1	// read C0_WatchHi1
-	beq 	v0, zero, done_wr
-	mtc0	zero, CP0_WATCHLO, 1	// write C0_WatchLo1
-
-	mtc0	v1, CP0_WATCHHI, 2	// write C0_WatchHi2
-	mfc0	v0, CP0_WATCHHI, 2	// read C0_WatchHi2
-	beq 	v0, zero, done_wr
-	mtc0	zero, CP0_WATCHLO, 2	// write C0_WatchLo2
-
-	mtc0	v1, CP0_WATCHHI, 3	// write C0_WatchHi3
-	mfc0	v0, CP0_WATCHHI, 3	// read C0_WatchHi3
-	beq 	v0, zero, done_wr
-	mtc0	zero, CP0_WATCHLO, 3	// write C0_WatchLo3
-
-	mtc0	v1, CP0_WATCHHI, 4	// write C0_WatchHi4
-	mfc0	v0, CP0_WATCHHI, 4	// read C0_WatchHi4
-	beq 	v0, zero, done_wr
-	mtc0	zero, CP0_WATCHLO, 4	// write C0_WatchLo4
-
-	mtc0	v1, CP0_WATCHHI, 5	// write C0_WatchHi5
-	mfc0	v0, CP0_WATCHHI, 5	// read C0_WatchHi5
-	beq 	v0, zero, done_wr
-	mtc0	zero, CP0_WATCHLO, 5	// write C0_WatchLo5
-
-	mtc0	v1, CP0_WATCHHI, 6	// write C0_WatchHi6
-	mfc0	v0, CP0_WATCHHI, 6	// read C0_WatchHi6
-	beq 	v0, zero, done_wr
-	mtc0	zero, CP0_WATCHLO, 6	// write C0_WatchLo6
-
-	mtc0	v1, CP0_WATCHHI, 7	// write C0_WatchHi7
-	mtc0	zero, CP0_WATCHLO, 7	// write C0_WatchLo7
-
-done_wr:
-
-	// Clear WP bit to avoid watch exception upon user code entry, IV, and software interrupts.
-	mtc0	zero, CP0_CAUSE		// write C0_Cause: Init AFTER init of CP0 WatchHi/Lo registers.
-
-	// Clear timer interrupt. (Count was cleared at the reset vector to allow timing boot.)
-	mtc0	zero, CP0_COMPARE	// write C0_Compare
-
-    jr      ra
-	nop
-END(init_cp0)
diff --git a/arch/mips/cpu/grx500/init_cpc.S b/arch/mips/cpu/grx500/init_cpc.S
deleted file mode 100755
--- a/arch/mips/cpu/grx500/init_cpc.S
+++ /dev/null
@@ -1,16 +0,0 @@
-#include <asm/boot.h>
-#include <asm/regdef.h>
-#include <asm/cps.h>
-
-	.set	noreorder           // Don't allow the assembler to reorder instructions.
-	.set	noat                // Don't allow the assembler to use r1(at) for synthetic instr.
-
-/**************************************************************************************
-**************************************************************************************/
-LEAF(init_cpc)
-    li      a0, CPC_P_BASE_ADDR				
-    sw      a0, GCR_CPC_BASE(r22_gcr_addr)		
-    li      r30_cpc_addr, CPC_BASE_ADDR		
-    jr      ra
-    nop
-END(init_cpc)
diff --git a/arch/mips/cpu/grx500/init_gic.S b/arch/mips/cpu/grx500/init_gic.S
deleted file mode 100755
--- a/arch/mips/cpu/grx500/init_gic.S
+++ /dev/null
@@ -1,54 +0,0 @@
-#include <asm/boot.h>
-#include <asm/regdef.h>
-#include <asm/cps.h>
-
-	.set	noreorder           
-	.set	noat                
-
-/**************************************************************************************
-**************************************************************************************/
-LEAF(init_gic)
-
-    beqz    r11_is_cps, done_gic				// Skip if non-CPS.
-    nop
-
-    bnez    r23_cpu_num, done_gic				// Only core0 vpe0 inits shared portion.
-    nop
-
-//Only cpu0 = core0+vpe0 to reach here
-/*set GIC base address and enable it*/
-
-    li      a1, GCR_CONFIG_ADDR + GCR_GIC_BASE  	// Locate and enable GIC
-    li      a0, GIC_P_BASE_ADDR | 1 			// Physical address + enable bit
-    sw      a0, 0(a1)				        // a0 = 0x12320001
-
-
-/*initialize IPI for VPE1/core0, VPE0/core1, VPE1/core1*/
-    li      a1, GIC_BASE_ADDR		// GIC_BASE_ADDR = 0xb2320000
-    // IPI interrupts 20, 21 85  
-    li      a0, 0x00300000
-    sw      a0, GIC_SH_RMASK31_0(a1)	// (disable     56..59)
-    sw      a0, GIC_SH_POL31_0(a1)		// (high/rise   56..59)
-    sw      a0, GIC_SH_TRIG31_0(a1)	// (edge        56..59)
-    sw      a0, GIC_SH_SMASK31_00(a1)	// (enable      56..59)
-
-    li      a0, 0x00200000
-    sw      a0, GIC_SH_RMASK95_64(a1)	// (disable     56..59)
-    sw      a0, GIC_SH_POL95_64(a1)		// (high/rise   56..59)
-    sw      a0, GIC_SH_TRIG95_64(a1)	// (edge        56..59)
-    sw      a0, GIC_SH_SMASK95_64(a1)	// (enable      56..59)
-     
- 
-    li      a0, 1              // set bit 0 for CORE0 or for MT vpe0
-    sll     a0, a0, 1          // set bit 1 for CORE1 or for MT vpe1
-    sw      a0, GIC_SH_MAP0_VPE31_0 + (GIC_SH_MAP_SPACER * 20) (a1)
-    sll     a0, a0, 1          // set bit 2 for CORE2 or for MT vpe2
-    sw      a0, GIC_SH_MAP0_VPE31_0 + (GIC_SH_MAP_SPACER * 21) (a1)
-    sll     a0, a0, 1          // set bit 3 for CORE3 or for MT vpe3
-    sw      a0, GIC_SH_MAP0_VPE31_0 + (GIC_SH_MAP_SPACER * 85) (a1)
-
-done_gic:
-    jr      ra
-    nop
-
-END(init_gic)
diff --git a/arch/mips/cpu/grx500/join_domain.S b/arch/mips/cpu/grx500/join_domain.S
deleted file mode 100755
--- a/arch/mips/cpu/grx500/join_domain.S
+++ /dev/null
@@ -1,50 +0,0 @@
-#include <asm/boot.h>
-#include <asm/regdef.h>
-#include <asm/cps.h>
-
-	.set	noreorder           // Don't allow the assembler to reorder instructions.
-	.set	noat                // Don't allow the assembler to use r1(at) for synthetic instr.
-
-/**************************************************************************************
-**************************************************************************************/
-LEAF(join_domain)
-
-
-	// Enable coherence and allow interventions from all other cores.
-	// (Write access enabled via GCR_ACCESS by core 0.)
-	// r22_gcr_addr = 0xbfbf8000
-	// CORE_LOCAL_CONTROL_BLOCK = 0x2000
-	// GCR_CL_COHERENCE = 0x008
-	// GCR_CL_OTHER = 0x018
-
-	// Next command, 0x0f for 1004K, 0x03 for GRX500(2 cores) and 0x33 for GRX500(2x cores + 2x iocu)
-
-
-	li	    a0, 0x33					   // Set Coherent domain enable for all cores
-	sw	    a0, (CORE_LOCAL_CONTROL_BLOCK | GCR_CL_COHERENCE)(r22_gcr_addr)	// GCR_CL_COHERENCE
-	ehb
-
-	// Cores other than core 0 can relinquish write access to CM regs here.
-
-    move    a3, zero
-	li	 	t0, CORE_ON
-
-next_coherent_core:
-    sll     a0, a3, 16
-    sw      a0, (CORE_LOCAL_CONTROL_BLOCK | GCR_CL_OTHER)(r22_gcr_addr) 	// GCR_CL_OTHER[CoreNum]
-
-busy_wait_coherent_core:
-    lw      a0, (CORE_OTHER_CONTROL_BLOCK | GCR_CO_COHERENCE)(r22_gcr_addr) // GCR_CO_COHERENCE
-    beqz    a0, busy_wait_coherent_core   									// Busy wait on cores joining.
-    nop
-
-//  bne     a3, r19_more_cores, next_coherent_core
-    addiu   a3, 1
-
-    bne     a3, t0, next_coherent_core
-	nop
-
-done_join_domain:
-	jr      ra
-	nop
-END(join_domain)
diff --git a/arch/mips/cpu/grx500/release_mp.S b/arch/mips/cpu/grx500/release_mp.S
deleted file mode 100755
--- a/arch/mips/cpu/grx500/release_mp.S
+++ /dev/null
@@ -1,31 +0,0 @@
-#include <asm/boot.h>
-#include <asm/regdef.h>
-#include <asm/cps.h>
-
-	.set	noreorder           // Don't allow the assembler to reorder instructions.
-	.set	noat                // Don't allow the assembler to use r1(at) for synthetic instr.
-/**************************************************************************************
-After the first processor in an MP system has completed the boot code, 
-it can release the remaining processors to execute the boot code.
-**************************************************************************************/
-LEAF(release_mp)
-
-
-    // At this point, r30_cpc_addr = 0xb2310000
-    // CPS_CORE_LOCAL_CONTROL_BLOCK = 0x2000
-    // CPC_OTHERL_REG = 0x010
-    // CPS_CORE_OTHER_CONTROL_BLOCK = 0x4000
-    // CPC_CMDO_REG = 0x000
-
-powerup_next_core:
-    // Send PwrUp command to next core causing execution at their reset exception vector.
-    li      a0, 1
-    sll     a0, 16
-    sw      a0, (CPS_CORE_LOCAL_CONTROL_BLOCK | CPC_OTHERL_REG)(r30_cpc_addr)
-    li      a0, PWR_UP							// "PwrUp" power domain command.
-    sw      a0, (CPS_CORE_OTHER_CONTROL_BLOCK | CPC_CMDO_REG)(r30_cpc_addr)
-1:
-    jr      ra
-    nop
-
-END(release_mp)
diff --git a/arch/mips/cpu/grx500/set_gpr_boot_values.S b/arch/mips/cpu/grx500/set_gpr_boot_values.S
deleted file mode 100755
--- a/arch/mips/cpu/grx500/set_gpr_boot_values.S
+++ /dev/null
@@ -1,65 +0,0 @@
-#include <asm/boot.h>
-#include <config.h>
-#include <asm/regdef.h>
-#include <asm/mipsregs.h>
-#include <asm/addrspace.h>
-#include <asm/cps.h>
-
-#define C0_MVPCTL $0, 1
-#define C0_MVPCONF0 $0, 2
-#define C0_VPECTL $1, 1
-#define C0_VPECONF0 $1, 2
-#define C0_TCSTATUS $2, 1
-#define C0_TCRESTART $2, 3
-#define C0_TCHALT $2, 4
-#define C0_TCBIND $2, 2
-
-	.set	noreorder           // Don't allow the assembler to reorder instructions.
-	.set	noat                // Don't allow the assembler to use r1(at) for synthetic instr.
-/**************************************************************************************
-**************************************************************************************/
-LEAF(set_gpr_boot_values)
-
-    li      r1_all_ones, 0xffffffff             // Simplify code and improve clarity
-    
-    mfc0    k1, CP0_PRID             
-    ext     k1, k1, 8, 16						// Company ID & Processor ID
-    li	    k0, 0x0190							// 4KEc
-    beq     k0, k1, is_not_interAptiv
-    li 	    r23_cpu_num, 8						// Assign 8=CPUNum for 4KEc
-    
-    mfc0    a0, CP0_EBASE                		// Read CP0 EBase
-    li      r11_is_cps, 1
-    ext	    r23_cpu_num, a0, 0, 4     			// Extract CPUNum
-    li      r10_has_mt_ase, 1
-
-    // Every vpe will set up the following to simplify resource initialization.
-    mfc0    a0, C0_TCBIND						// Read CP0 TCBind
-    ext	    r9_vpe_num, a0,  0, 4				// Extract CurVPE
-    ext	    r18_tc_num, a0, 21, 8				// Extract CurTC
-    mfc0    a0, C0_MVPCONF0						// C0_MVPConf0
-    ext	    r21_more_tcs, a0, 0, 8   			// Extract PTC
-    ext	    r20_more_vpes, a0, 10, 4			// Extract VPE
-
-    li      r22_gcr_addr, GCR_CONFIG_ADDR
-    lw      r8_core_num, (CORE_LOCAL_CONTROL_BLOCK + GCR_CL_ID) (r22_gcr_addr) // Load GCR_CL_ID
-    lw      a0, GCR_CONFIG(r22_gcr_addr)                // Load GCR_CONFIG
-    ext     r19_more_cores, a0, PCORES, PCORES_S        // Extract PCORES (r19_more_cores=1 from core 0)
-    
-    b       done_init_gpr
-    nop
-
-is_not_interAptiv: 	// This processor is not a InterAptiv Core. Set up defaults for 4Kc.
-    li      r11_is_cps, 0
-    li      r8_core_num, 0
-    li      r9_vpe_num, 0
-    li      r18_tc_num, 0
-    li      r20_more_vpes, 0
-    li      r21_more_tcs, 0
-    li      r19_more_cores, 0
-        
-	
-done_init_gpr:
-    jr     ra
-    nop
-END(set_gpr_boot_values)
diff --git a/board/grx500/' b/board/grx500/'
new file mode 100644
--- /dev/null
+++ b/board/grx500/'
@@ -0,0 +1,82 @@
+#!/usr/bin/perl -w
+#perl script to generate lantiq header 
+#Revision history
+#19/11/2014 Author Wu Qi Ming
+
+use strict;
+use Getopt::Long;
+
+my $TAG_DEBUG=0x11000000;
+my $TAG_REGCFG=0x22000000;
+my $TAG_IDWNLD=0x33000000;
+my $TAG_CDWNLD=0x44000000;
+my $TAG_DWNLD=0x55000000;
+my $TAG_IFCFG=0x66000000;
+my $TAG_START=0x77000000;
+my $TAG_SOCMODE=0x88000000;
+my $TAG_CHKSUM=0x99000000;
+my $TAG_LQHDR=0xAA000000;
+
+my $FLAG_RST=0x00800000;
+my $FLAG_CFG=0x00700000;
+my $FLAG_CFG2=0x00400000;
+my $FLAG_CFG1=0x00200000;
+my $FLAG_CFG0=0x00100000;
+my $FLAG_SDBG=0x00080000;
+my $FLAG_DBG=0x00040000;
+my $FLAG_DEC=0x00020000;
+my $FLAG_START=0x00010000;
+
+
+
+sub usage
+{
+   print "mk_ltq_header.pl --options\n";
+   print "      --bch strength         enable bch, strength 8/16/40\n";
+   print "      --col col              nand column address cycle\n";
+   print "      --row row              nand row address cycle\n";
+   print "      --pagesize pagesize    nand page size \n";
+   print "      --blocksize blocksize  nand block size \n";
+   print "      --backup  backup       copies of backup images\n";
+   print "      --ddr ddrconfig        ddr configuration file\n";
+   print "      --out output           output file name\n";
+   print "      --help                 show this menu\n"
+}
+
+# setup my defaults
+my $bch      = 0;
+my $help     = 0;
+my $col      = 0;
+my $row      = 0;
+my $pagesize = 0;
+my $blocksize = 0;
+my $backup    = 1;
+my $ddr = "";
+my $output = "";
+
+GetOptions(
+    'bch=i' => \$bch,
+    'col=i' => \$col,
+    'row=i' => \$row,
+    'pagesize=i' => \$pagesize,
+    'blocksize=i' => \$blocksize,
+    'backup=i' => \$backup,
+    'ddr=s'    => \$ddr,
+    'out=s'    => \$output,
+    'help!'     => \$help,
+) or usage();
+
+if( $help ) {
+    usage();
+} 
+
+
+#my $lnmw=0;
+
+#$byte=(($bch>0)?1:0)<<4;
+#$byte=$byte|(($col-1)<<2)|($row-1);
+
+#print "byte=$byte\n";
+
+
+
diff --git a/board/grx500/CONFIG_DDR3_600M400M.conf b/board/grx500/CONFIG_DDR3_600M400M.conf
new file mode 100644
--- /dev/null
+++ b/board/grx500/CONFIG_DDR3_600M400M.conf
@@ -0,0 +1,190 @@
+0xb608005c    0xdfffff
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000040    0xf004641f
+0xb2200004    0xC0131
+0xb2200120    0x0
+0xb2200124    0x1528B
+0xb49001d0    0xF8002000
+0xb49001d4    0xF8002800
+0xb49001d8    0xFE00A000
+0xb21000c0    0xC8
+0xb21000c4    0xC8
+0xb21000cc    0x14
+0xb21000c8    0x1F4
+0xb2100134    0x2A
+0xb2100080    0x40021
+0xb210007c    0x0
+0xb2000044    0x1000040B
+0xb2000054    0x520
+0xb2000058    0x4E
+0xb200005c    0x200
+0xb2000060    0x0
+0xb2000048    0x550F6644
+0xb200004c    0x22834280
+0xb2000050    0x50018C6C
+0xb200008c    0xF86DB0
+0xb200001c    0x1900C810
+0xb2000020    0x4E200258
+0xb2000024    0x83DEF
+0xb200003c    0x44181884
+0xb20001c0    0x7c001e81
+0xb2000200    0x7c001e81
+0xb2000184    0x105d
+0xB2000005    0x0
+0xB2000011    0xB000000F
+0xb20001e8    0x6E6E
+0xb2000228    0x6E6E
+0xb2000004    0x40001
+0xB2000011    0xB000001F
+0xB21002C1    0x1
+0xb2100044    0x1
+0xB2100049    0x1
+0xb21000c0    0xC8
+0xb21000c4    0xC8
+0xb21000cc    0x14
+0xb21000d0    0x8001009C
+0xb21000d4    0x4
+0xb21000d8    0x68
+0xb21000dc    0x6
+0xb21000e4    0x5
+0xb21000e8    0x6
+0xb21000ec    0x5
+0xb21000f0    0xF
+0xb21000f4    0x15
+0xb21000f8    0x6
+0xb21000fc    0x4
+0xb2100100    0x4
+0xb21000e0    0x3
+0xb2100104    0x6
+0xb2100108    0x4
+0xb210010c    0x200
+0xb2100110    0x3
+0xb2100120    0x3
+0xb2100124    0x5
+0xb2100128    0x5
+0xb2100130    0xC
+0xb210012c    0x3
+0xb21000c8    0x1F4
+0xb2100134    0x2A
+0xb2100118    0x40
+0xb2100138    0x200
+0xb2100114    0xA
+0xb210011c    0x5
+0xb2100140    0x4
+0xb2100144    0x0
+0xb2100148    0xC30
+0xb2100000    0x4480
+0xb2100254    0x3
+0xb2100260    0x4
+0xb2100250    0x1
+0xb2100258    0x3
+0xb2100264    0xF
+0xb21002d4    0x2
+0xb21002d0    0x2
+0xb2100240    0x2
+0xb2100244    0x8
+0xb2100248    0x6060101
+0xb210024c    0x1
+0xb2100284    0x40
+0xb2100290    0x7
+0xb2100040    0x86F00000
+0xB2100041    0x6F00000
+0x80000000    0xFFFF
+0xb2100040    0x80F42003
+0xB2100041    0xF42003
+0x80000000    0xFFFF
+0xb2100040    0x80F60003
+0xB2100041    0xF60003
+0x80000000    0xFFFF
+0xb2100040    0x80F204E3
+0xB2100041    0xF204E3
+0x80000000    0xFFFF
+0xb2100040    0x80F05203
+0xB2100041    0xF05203
+0x80000000    0xFFFF
+0xb2100040    0x80F00005
+0xB2100041    0xF00005
+0x80000000    0xFFFF
+0xb2100040    0x80F0000A
+0xB2100041    0xF0000A
+0x80000000    0xFFFF
+0xb2100004    0x1
+0xB2100009    0x1
+0xb2100084    0x0
+0xb21002c4    0x7
+0xb21002c8    0x3
+0xb21002d8    0x0
+0xb21002f0    0x70101
+0xb2100180    0x0
+0xb2100290    0x3
+0xb2100050    0x1
+0xB210004D    0x1
+0xb2100004    0x2
+0xB2100009    0x3
+0x80000000    0xFFFF
+0xb2100004    0x3
+0xB2100009    0x45
+0x80000000    0xFFFF
+0xb6200008    0x40403868
+0x80000000    0xFFFF
+0xb6200038    0x40401756
+0x80000000    0xFFFF
+0xb6200018    0x40000000
+0x80000000    0xFFFF
+0xb6200018    0x0001c000
+0x80000000    0xFFFF
+0xb2100004    0x4
+0xB2100009    0x3
+0x80000000    0xFFFF
+0xb2100004    0x1
+0xB2100009    0x1
+0x80000000    0xFFFF
+0xb2000068    0x910078c7
+0xb2000004    0x8000000
+0xB2000011    0xB0000017
+0x80000000    0xFFFF
+0xb2000004    0x13
+0xB2000011    0xB000001f
+0x80000000    0xFFFF
+0xb20001cc    0x18618618
+0xb20001d0    0x18618618
+0xb20001d4    0x618
+0xb20001d8    0x0
+0xb20001dc    0x0
+0xb200020c    0x18618618
+0xb2000210    0x18618618
+0xb2000214    0x618
+0xb2000218    0x0
+0xb200021c    0x0
+0xb2000004    0x201
+0xB2000011    0xB000003F
+0xb2000004    0x401
+0xB2000011    0xB000007F
+0xb2000004    0x801
+0xB2000011    0xB00000FF
+0xb2000004    0x1001
+0xB2000011    0xB00001FF
+0xb2000004    0x2001
+0xB2000011    0xB00003FF
+0xb2000004    0x4001
+0xB2000011    0xB00007FF
+0xb2000004    0x8001
+0xB2000011    0xB0000FFF
+0xb2100004    0x2
+0xB2100009    0x3
+
diff --git a/board/grx500/CONFIG_DDR3_600M666M.conf b/board/grx500/CONFIG_DDR3_600M666M.conf
new file mode 100644
--- /dev/null
+++ b/board/grx500/CONFIG_DDR3_600M666M.conf
@@ -0,0 +1,190 @@
+0xb608005c    0xdfffff
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000040    0xf004641f
+0xb2200004    0xC0131
+0xb2200120    0x0
+0xb2200124    0x1528B
+0xb49001d0    0xF8002000
+0xb49001d4    0xF8002800
+0xb49001d8    0xFE00A000
+0xb21000c0    0x14D
+0xb21000c4    0xC8
+0xb21000cc    0x21
+0xb21000c8    0x1F4
+0xb2100134    0x44
+0xb2100080    0x80021
+0xb210007c    0x0
+0xb2000044    0x1000040B
+0xb2000054    0xB50
+0xb2000058    0x4E
+0xb200005c    0x210
+0xb2000060    0x0
+0xb2000048    0x85589955
+0xb200004c    0x228573C0
+0xb2000050    0x500210B4
+0xb200008c    0xF8B6E7
+0xb200001c    0x29A14D10
+0xb2000020    0x821403E7
+0xb2000024    0x83DEF
+0xb200003c    0x44181884
+0xb20001c0    0x7c001e81
+0xb2000200    0x7c001e81
+0xb2000184    0x105d
+0xB2000005    0x0
+0xB2000011    0xB000000F
+0xb20001e8    0x6E6E
+0xb2000228    0x6E6E
+0xb2000004    0x40001
+0xB2000011    0xB000001F
+0xB21002C1    0x1
+0xb2100044    0x1
+0xB2100049    0x1
+0xb21000c0    0x14D
+0xb21000c4    0xC8
+0xb21000cc    0x21
+0xb21000d0    0x8001009C
+0xb21000d4    0x4
+0xb21000d8    0xAE
+0xb21000dc    0x9
+0xb21000e4    0x8
+0xb21000e8    0x9
+0xb21000ec    0x7
+0xb21000f0    0x18
+0xb21000f4    0x21
+0xb21000f8    0x9
+0xb21000fc    0x5
+0xb2100100    0x5
+0xb21000e0    0x3
+0xb2100104    0xA
+0xb2100108    0x5
+0xb210010c    0x200
+0xb2100110    0x4
+0xb2100120    0x3
+0xb2100124    0x7
+0xb2100128    0x7
+0xb2100130    0xC
+0xb210012c    0x4
+0xb21000c8    0x1F4
+0xb2100134    0x44
+0xb2100118    0x40
+0xb2100138    0x200
+0xb2100114    0x10
+0xb210011c    0x5
+0xb2100140    0x5
+0xb2100144    0x0
+0xb2100148    0x1452
+0xb2100000    0x4480
+0xb2100254    0x6
+0xb2100260    0x7
+0xb2100250    0x1
+0xb2100258    0x3
+0xb2100264    0xF
+0xb21002d4    0x2
+0xb21002d0    0x2
+0xb2100240    0x2
+0xb2100244    0x8
+0xb2100248    0x6060201
+0xb210024c    0x1
+0xb2100284    0x40
+0xb2100290    0x7
+0xb2100040    0x86F00000
+0xB2100041    0x6F00000
+0x80000000    0xFFFF
+0xb2100040    0x80F42103
+0xB2100041    0xF42103
+0x80000000    0xFFFF
+0xb2100040    0x80F60003
+0xB2100041    0xF60003
+0x80000000    0xFFFF
+0xb2100040    0x80F204E3
+0xB2100041    0xF204E3
+0x80000000    0xFFFF
+0xb2100040    0x80F0B503
+0xB2100041    0xF0B503
+0x80000000    0xFFFF
+0xb2100040    0x80F00005
+0xB2100041    0xF00005
+0x80000000    0xFFFF
+0xb2100040    0x80F0000A
+0xB2100041    0xF0000A
+0x80000000    0xFFFF
+0xb2100004    0x1
+0xB2100009    0x1
+0xb2100084    0x0
+0xb21002c4    0x7
+0xb21002c8    0x3
+0xb21002d8    0x0
+0xb21002f0    0x70101
+0xb2100180    0x0
+0xb2100290    0x3
+0xb2100050    0x1
+0xB210004D    0x1
+0xb2100004    0x2
+0xB2100009    0x3
+0x80000000    0xFFFF
+0xb2100004    0x3
+0xB2100009    0x45
+0x80000000    0xFFFF
+0xb6200008    0x40403868
+0x80000000    0xFFFF
+0xb6200038    0x40401556
+0x80000000    0xFFFF
+0xb6200018    0x40000000
+0x80000000    0xFFFF
+0xb6200018    0x0001c000
+0x80000000    0xFFFF
+0xb2100004    0x4
+0xB2100009    0x3
+0x80000000    0xFFFF
+0xb2100004    0x1
+0xB2100009    0x1
+0x80000000    0xFFFF
+0xb2000068    0x910035c7
+0xb2000004    0x8000000
+0xB2000011    0xB0000017
+0x80000000    0xFFFF
+0xb2000004    0x13
+0xB2000011    0xB000001f
+0x80000000    0xFFFF
+0xb20001cc    0x18618618
+0xb20001d0    0x18618618
+0xb20001d4    0x618
+0xb20001d8    0x0
+0xb20001dc    0x0
+0xb200020c    0x18618618
+0xb2000210    0x18618618
+0xb2000214    0x618
+0xb2000218    0x0
+0xb200021c    0x0
+0xb2000004    0x201
+0xB2000011    0xB000003F
+0xb2000004    0x401
+0xB2000011    0xB000007F
+0xb2000004    0x801
+0xB2000011    0xB00000FF
+0xb2000004    0x1001
+0xB2000011    0xB00001FF
+0xb2000004    0x2001
+0xB2000011    0xB00003FF
+0xb2000004    0x4001
+0xB2000011    0xB00007FF
+0xb2000004    0x8001
+0xB2000011    0xB0000FFF
+0xb2100004    0x2
+0xB2100009    0x3
+
diff --git a/board/grx500/CONFIG_DDR3_800M666M.conf b/board/grx500/CONFIG_DDR3_800M666M.conf
new file mode 100644
--- /dev/null
+++ b/board/grx500/CONFIG_DDR3_800M666M.conf
@@ -0,0 +1,190 @@
+0xb608005c    0xdfffff
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000040    0xf004641f
+0xb2200004    0xC0131
+0xb2200120    0x0
+0xb2200124    0x1528B
+0xb49001d0    0xF8002000
+0xb49001d4    0xF8002800
+0xb49001d8    0xFE00A000
+0xb21000c0    0x14D
+0xb21000c4    0xC8
+0xb21000cc    0x21
+0xb21000c8    0x1F4
+0xb2100134    0x44
+0xb2100080    0x80021
+0xb210007c    0x0
+0xb2000044    0x1000040B
+0xb2000054    0xB50
+0xb2000058    0x4E
+0xb200005c    0x210
+0xb2000060    0x0
+0xb2000048    0x85589955
+0xb200004c    0x228573C0
+0xb2000050    0x500210B4
+0xb200008c    0xF8B6E7
+0xb200001c    0x29A14D10
+0xb2000020    0x821403E7
+0xb2000024    0x83DEF
+0xb200003c    0x44181884
+0xb20001c0    0x7c001e81
+0xb2000200    0x7c001e81
+0xb2000184    0x105d
+0xB2000005    0x0
+0xB2000011    0xB000000F
+0xb20001e8    0x6E6E
+0xb2000228    0x6E6E
+0xb2000004    0x40001
+0xB2000011    0xB000001F
+0xB21002C1    0x1
+0xb2100044    0x1
+0xB2100049    0x1
+0xb21000c0    0x14D
+0xb21000c4    0xC8
+0xb21000cc    0x21
+0xb21000d0    0x8001009C
+0xb21000d4    0x4
+0xb21000d8    0xAE
+0xb21000dc    0x9
+0xb21000e4    0x8
+0xb21000e8    0x9
+0xb21000ec    0x7
+0xb21000f0    0x18
+0xb21000f4    0x21
+0xb21000f8    0x9
+0xb21000fc    0x5
+0xb2100100    0x5
+0xb21000e0    0x3
+0xb2100104    0xA
+0xb2100108    0x5
+0xb210010c    0x200
+0xb2100110    0x4
+0xb2100120    0x3
+0xb2100124    0x7
+0xb2100128    0x7
+0xb2100130    0xC
+0xb210012c    0x4
+0xb21000c8    0x1F4
+0xb2100134    0x44
+0xb2100118    0x40
+0xb2100138    0x200
+0xb2100114    0x10
+0xb210011c    0x5
+0xb2100140    0x5
+0xb2100144    0x0
+0xb2100148    0x1452
+0xb2100000    0x4480
+0xb2100254    0x6
+0xb2100260    0x7
+0xb2100250    0x1
+0xb2100258    0x3
+0xb2100264    0xF
+0xb21002d4    0x2
+0xb21002d0    0x2
+0xb2100240    0x2
+0xb2100244    0x8
+0xb2100248    0x6060201
+0xb210024c    0x1
+0xb2100284    0x40
+0xb2100290    0x7
+0xb2100040    0x86F00000
+0xB2100041    0x6F00000
+0x80000000    0xFFFF
+0xb2100040    0x80F42103
+0xB2100041    0xF42103
+0x80000000    0xFFFF
+0xb2100040    0x80F60003
+0xB2100041    0xF60003
+0x80000000    0xFFFF
+0xb2100040    0x80F204E3
+0xB2100041    0xF204E3
+0x80000000    0xFFFF
+0xb2100040    0x80F0B503
+0xB2100041    0xF0B503
+0x80000000    0xFFFF
+0xb2100040    0x80F00005
+0xB2100041    0xF00005
+0x80000000    0xFFFF
+0xb2100040    0x80F0000A
+0xB2100041    0xF0000A
+0x80000000    0xFFFF
+0xb2100004    0x1
+0xB2100009    0x1
+0xb2100084    0x0
+0xb21002c4    0x7
+0xb21002c8    0x3
+0xb21002d8    0x0
+0xb21002f0    0x70101
+0xb2100180    0x0
+0xb2100290    0x3
+0xb2100050    0x1
+0xB210004D    0x1
+0xb2100004    0x2
+0xB2100009    0x3
+0x80000000    0xFFFF
+0xb2100004    0x3
+0xB2100009    0x45
+0x80000000    0xFFFF
+0xb6200008    0x40402868
+0x80000000    0xFFFF
+0xb6200038    0x40401556
+0x80000000    0xFFFF
+0xb6200018    0x40000000
+0x80000000    0xFFFF
+0xb6200018    0x0001c000
+0x80000000    0xFFFF
+0xb2100004    0x4
+0xB2100009    0x3
+0x80000000    0xFFFF
+0xb2100004    0x1
+0xB2100009    0x1
+0x80000000    0xFFFF
+0xb2000068    0x910035c7
+0xb2000004    0x8000000
+0xB2000011    0xB0000017
+0x80000000    0xFFFF
+0xb2000004    0x13
+0xB2000011    0xB000001f
+0x80000000    0xFFFF
+0xb20001cc    0x18618618
+0xb20001d0    0x18618618
+0xb20001d4    0x618
+0xb20001d8    0x0
+0xb20001dc    0x0
+0xb200020c    0x18618618
+0xb2000210    0x18618618
+0xb2000214    0x618
+0xb2000218    0x0
+0xb200021c    0x0
+0xb2000004    0x201
+0xB2000011    0xB000003F
+0xb2000004    0x401
+0xB2000011    0xB000007F
+0xb2000004    0x801
+0xB2000011    0xB00000FF
+0xb2000004    0x1001
+0xB2000011    0xB00001FF
+0xb2000004    0x2001
+0xB2000011    0xB00003FF
+0xb2000004    0x4001
+0xB2000011    0xB00007FF
+0xb2000004    0x8001
+0xB2000011    0xB0000FFF
+0xb2100004    0x2
+0xB2100009    0x3
+
diff --git a/board/grx500/DDR3-667-999-al1.conf b/board/grx500/DDR3-667-999-al1.conf
new file mode 100755
--- /dev/null
+++ b/board/grx500/DDR3-667-999-al1.conf
@@ -0,0 +1,190 @@
+0xb608005c    0xdfffff
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000000    0x0014a315
+0xb2000040    0xf004641f
+0xb2200004    0xC0131
+0xb2200120    0x0
+0xb2200124    0x1528B
+0xb49001d0    0xF8002000
+0xb49001d4    0xF8002800
+0xb49001d8    0xFE00A000
+0xb21000c0    0x14D
+0xb21000c4    0xC8
+0xb21000cc    0x21
+0xb21000c8    0x1F4
+0xb2100134    0x44
+0xb2100080    0x80021
+0xb210007c    0x0
+0xb2000044    0x1000040B
+0xb2000054    0xB50
+0xb2000058    0x4E
+0xb200005c    0x210
+0xb2000060    0x0
+0xb2000048    0x85589955
+0xb200004c    0x228573C0
+0xb2000050    0x500210B4
+0xb200008c    0xF8B6E7
+0xb200001c    0x29A14D10
+0xb2000020    0x821403E7
+0xb2000024    0x83DEF
+0xb200003c    0x44181884
+0xb20001c0    0x7c001e81
+0xb2000200    0x7c001e81
+0xb2000184    0x105d
+0xB2000005    0x0
+0xB2000011    0xB000000F
+0xb20001e8    0x6E6E
+0xb2000228    0x6E6E
+0xb2000004    0x40001
+0xB2000011    0xB000001F
+0xB21002C1    0x1
+0xb2100044    0x1
+0xB2100049    0x1
+0xb21000c0    0x14D
+0xb21000c4    0xC8
+0xb21000cc    0x21
+0xb21000d0    0x8001009C
+0xb21000d4    0x4
+0xb21000d8    0xAE
+0xb21000dc    0x9
+0xb21000e4    0x8
+0xb21000e8    0x9
+0xb21000ec    0x7
+0xb21000f0    0x18
+0xb21000f4    0x21
+0xb21000f8    0x9
+0xb21000fc    0x5
+0xb2100100    0x5
+0xb21000e0    0x3
+0xb2100104    0xA
+0xb2100108    0x5
+0xb210010c    0x200
+0xb2100110    0x4
+0xb2100120    0x3
+0xb2100124    0x7
+0xb2100128    0x7
+0xb2100130    0xC
+0xb210012c    0x4
+0xb21000c8    0x1F4
+0xb2100134    0x44
+0xb2100118    0x40
+0xb2100138    0x200
+0xb2100114    0x10
+0xb210011c    0x5
+0xb2100140    0x5
+0xb2100144    0x0
+0xb2100148    0x1452
+0xb2100000    0x4480
+0xb2100254    0x6
+0xb2100260    0x7
+0xb2100250    0x1
+0xb2100258    0x3
+0xb2100264    0xF
+0xb21002d4    0x2
+0xb21002d0    0x2
+0xb2100240    0x2
+0xb2100244    0x8
+0xb2100248    0x6060201
+0xb210024c    0x1
+0xb2100284    0x40
+0xb2100290    0x7
+0xb2100040    0x86F00000
+0xB2100041    0x6F00000
+0x80000000    0xFFFF
+0xb2100040    0x80F42103
+0xB2100041    0xF42103
+0x80000000    0xFFFF
+0xb2100040    0x80F60003
+0xB2100041    0xF60003
+0x80000000    0xFFFF
+0xb2100040    0x80F204E3
+0xB2100041    0xF204E3
+0x80000000    0xFFFF
+0xb2100040    0x80F0B503
+0xB2100041    0xF0B503
+0x80000000    0xFFFF
+0xb2100040    0x80F00005
+0xB2100041    0xF00005
+0x80000000    0xFFFF
+0xb2100040    0x80F0000A
+0xB2100041    0xF0000A
+0x80000000    0xFFFF
+0xb2100004    0x1
+0xB2100009    0x1
+0xb2100084    0x0
+0xb21002c4    0x7
+0xb21002c8    0x3
+0xb21002d8    0x0
+0xb21002f0    0x70101
+0xb2100180    0x0
+0xb2100290    0x3
+0xb2100050    0x1
+0xB210004D    0x1
+0xb2100004    0x2
+0xB2100009    0x3
+0x80000000    0xFFFF
+0xb2100004    0x3
+0xB2100009    0x45
+0x80000000    0xFFFF
+0xb6200008    0x40403868
+0x80000000    0xFFFF
+0xb6200038    0x40401556
+0x80000000    0xFFFF
+0xb6200018    0x40000000
+0x80000000    0xFFFF
+0xb6200018    0x0001c000
+0x80000000    0xFFFF
+0xb2100004    0x4
+0xB2100009    0x3
+0x80000000    0xFFFF
+0xb2100004    0x1
+0xB2100009    0x1
+0x80000000    0xFFFF
+0xb2000068    0x910035c7
+0xb2000004    0x8000000
+0xB2000011    0xB0000017
+0x80000000    0xFFFF
+0xb2000004    0x13
+0xB2000011    0xB000001f
+0x80000000    0xFFFF
+0xb20001cc    0x18618618
+0xb20001d0    0x18618618
+0xb20001d4    0x618
+0xb20001d8    0x0
+0xb20001dc    0x0
+0xb200020c    0x18618618
+0xb2000210    0x18618618
+0xb2000214    0x618
+0xb2000218    0x0
+0xb200021c    0x0
+0xb2000004    0x201
+0xB2000011    0xB000003F
+0xb2000004    0x401
+0xB2000011    0xB000007F
+0xb2000004    0x801
+0xB2000011    0xB00000FF
+0xb2000004    0x1001
+0xB2000011    0xB00001FF
+0xb2000004    0x2001
+0xB2000011    0xB00003FF
+0xb2000004    0x4001
+0xB2000011    0xB00007FF
+0xb2000004    0x8001
+0xB2000011    0xB0000FFF
+0xb2100004    0x2
+0xB2100009    0x3
+
diff --git a/board/grx500/Kconfig b/board/grx500/Kconfig
new file mode 100644
--- /dev/null
+++ b/board/grx500/Kconfig
@@ -0,0 +1,381 @@
+
+config DRIVER_GRX500
+      bool
+      default y
+
+choice 
+      prompt "Chipset Version"
+      default GRX500_A11
+
+config GRX500_A11
+      bool "GRX500 version A11"
+
+config GRX500_A21
+      bool "GRX500 version A21"
+endchoice
+
+choice
+	prompt "Board Specific"
+	default BOARD_EASY350
+	depends on GRX500_A21
+
+config BOARD_EASY350
+	bool "EASY350 Family Board"
+
+config BOARD_EVM
+	bool "GRX500 Evaluation Board"
+
+endchoice
+
+config GRX500_ROM_HEADER_BCH_CAP
+       int
+       default 40 if ( GRX500_A11 )
+       default 8  if ( GRX500_A21 )  
+
+config GRX500_BOOT_4KEC_ONLY
+       bool "boot 4kec only"
+       default n
+
+menu "Memory configuration for Trusted OS"
+choice 
+    prompt "Memory reserved for TOS"
+    default TOS_128M
+
+config TOS_16M
+	bool "16M for tos"
+
+config TOS_32M
+	bool "32M for tos"
+
+config TOS_64M
+	bool "64M for tos"
+
+config TOS_128M
+	bool "128M for tos"
+endchoice
+
+choice 
+    prompt "DDR present in system"
+    default DDR_512M
+
+config DDR_256M
+    bool "256M DDR"
+
+config DDR_512M
+	bool "512M DDR"
+
+config DDR_1G
+    bool "1G DDR"
+endchoice
+
+config FMT1_REG
+	hex  
+	default "0xFF002F00" if (DDR_256M  &&  TOS_16M)
+	default "0xFE002E00" if (DDR_256M  &&  TOS_32M)
+	default "0xFC002C00" if (DDR_256M  &&  TOS_64M)
+	default "0xF8002800" if (DDR_256M  &&  TOS_128M)
+	default "0xFF003F00" if (DDR_512M  &&  TOS_16M)
+	default "0xFE003E00" if (DDR_512M  &&  TOS_32M)
+	default "0xFC003C00" if (DDR_512M  &&  TOS_64M)
+	default "0xF8003800" if (DDR_512M  &&  TOS_128M)
+	default "0xFF005F00" if (DDR_1G  &&  TOS_16M)
+	default "0xFE005E00" if (DDR_1G  &&  TOS_32M)
+	default "0xFC005C00" if (DDR_1G  &&  TOS_64M)
+	default "0xF8005800" if (DDR_1G  &&  TOS_128M)
+endmenu
+
+menu "MIPS and DDR Settings"
+config GRX500_USE_DDR_PRECONFIG
+       bool "use pre-config DDR setting" 
+       default n
+
+config GRX500_DDR_CONFIG_FILE
+       string "ddr config file path"
+       default "ddr.conf"
+       depends on GRX500_USE_DDR_PRECONFIG
+
+choice 
+	prompt "DDR Type"
+	default GRX500_DDR3
+        depends on !GRX500_USE_DDR_PRECONFIG
+	help
+		Choose between DDR3/DDR2
+
+config GRX500_DDR2
+	bool "DDR2"
+
+config GRX500_DDR3
+	bool "DDR3"
+
+endchoice
+
+choice
+	prompt "DDR Grade"
+	default GRX500_667M_CL9
+        depends on !GRX500_USE_DDR_PRECONFIG
+	help
+		This options list down the CAS-Latency and DDR frequency
+		that the system will run on
+
+config GRX500_400M_CL6
+	bool "400Mhz CL6"
+
+config GRX500_533M_CL6
+	bool "533Mhz CL6"
+
+config GRX500_533M_CL7
+	bool "533Mhz CL7"
+
+config GRX500_533M_CL8
+	bool "533Mhz CL8"
+
+config GRX500_667M_CL8
+	bool "667Mhz CL8"
+
+config GRX500_667M_CL9
+	bool "667Mhz CL9"
+
+config GRX500_667M_CL10
+	bool "667Mhz CL10"
+
+config GRX500_800M_CL9
+	bool "800Mhz CL9"
+
+config GRX500_800M_CL10
+	bool "800Mhz CL10"
+
+config GRX500_800M_CL11
+	bool "800Mhz CL11"
+
+endchoice
+
+choice 
+	prompt "DDR Density Configurations"
+	default GRX500_256Mx16
+        depends on !GRX500_USE_DDR_PRECONFIG
+	help
+		Choose the configuration of the DDR to determine the MAX size
+		of the system DDR
+
+config GRX500_32Mx16
+	bool "32M x 16"
+
+config GRX500_64Mx8
+	bool "64M x 8"
+
+config GRX500_64Mx16
+	bool "64M x 16"
+
+config GRX500_128Mx8
+	bool "128M x 8"
+
+config GRX500_128Mx16
+	bool "128M x 16"
+
+config GRX500_256Mx8
+	bool "256M x 8"
+
+config GRX500_256Mx16
+	bool "256M x 16"
+
+config GRX500_512Mx8
+	bool "512M x 8"
+
+config GRX500_512Mx16
+	bool "512M x 16"
+
+endchoice 
+
+choice
+	prompt "DDR Operating Burst Length"
+	default GRX500_BL8
+		depends on !GRX500_USE_DDR_PRECONFIG
+	help
+		Choose the operating burst length of the DDR
+
+config GRX500_BL8
+	bool "Configuration BL8"
+
+config GRX500_BC4
+	bool "Configuration BC4"
+
+endchoice
+
+menu "DDR Pre-Seed Rank 0 Value"
+	depends on !GRX500_USE_DDR_PRECONFIG
+
+config GRX500_1ST_SR0_VALUE
+	int "Fist pre-seed value"
+	default "24"
+
+config GRX500_2ND_SR0_VALUE
+	int "Second pre-seed value"
+	default "24"
+endmenu
+
+menu "DDR Pre-Seed Rank 1 Value"
+	depends on !GRX500_USE_DDR_PRECONFIG
+
+config GRX500_1ST_SR1_VALUE
+	int "First pre-seed value"
+	default "24"
+
+config GRX500_2ND_SR1_VALUE
+	int "Second pre-seed value"
+	default "24"
+endmenu
+
+choice 
+	prompt "DDR Controller Speed (set as 1/2 DDR Grade/Speed)"
+	default GRX500_DDR_CTRL_333M
+        depends on !GRX500_USE_DDR_PRECONFIG
+	help
+		DDR Controller speed. It should be set at half the speed of the 
+		intended frequency of the DDR
+
+config GRX500_DDR_CTRL_200M
+	bool "DDR Controller @ 200Mhz"
+	
+config GRX500_DDR_CTRL_333M
+	bool "DDR Controller @ 333Mhz"
+
+config GRX500_DDR_CTRL_400M
+	bool "DDR Controller @ 400Mhz"
+
+endchoice
+
+config GRX500_CS0_ONLY
+	bool "DDR is using CS0 only"
+	default y
+	depends on !GRX500_USE_DDR_PRECONFIG
+	help
+		Select if DDR config is only using CS0.
+		If DDR config uses both CS0/CS1, un-select this option
+
+config GRX500_ADDITIVE_LATENCY
+	int "DDR Additive Latency CL 'N' value" 
+	default "1"
+        depends on !GRX500_USE_DDR_PRECONFIG
+	help
+		CL valid values: N [0, -1, -2]
+
+comment "End of DDR configurations " 
+	depends on !GRX500_USE_DDR_PRECONFIG
+
+choice 
+	prompt "MIPS CPS Speed"
+	default GRX500_CPU_600M
+        depends on !GRX500_USE_DDR_PRECONFIG
+	help
+		Choose the frquency at which MIPS Interaptive is running
+
+config GRX500_CPU_600M
+	bool "CPU running at 600Mhz"
+
+config GRX500_CPU_800M
+	bool "CPU running at 800Mhz"
+
+config GRX500_CPU_1000M
+	bool "CPU running at 1000Mhz"
+	
+config GRX500_CPU_1200M
+	bool "CPU running at 1200Mhz"
+
+endchoice
+
+
+choice 
+	prompt "CBM Frequency settings"
+	default GRX500_CBM_FREQ_200M
+        depends on !GRX500_USE_DDR_PRECONFIG
+	help
+		Sets the CBM frequency
+
+config GRX500_CBM_FREQ_200M
+	bool "CBM Frequency @ 200Mhz"
+
+config GRX500_CBM_FREQ_300M
+	bool "CBM Frequency @ 300Mhz"
+
+config GRX500_CBM_FREQ_400M
+	bool "CBM Frequency @ 400Mhz"
+
+config GRX500_CBM_FREQ_480M
+	bool "CBM Frequency @ 480Mhz"
+
+config GRX500_CBM_FREQ_600M
+	bool "CBM Frequency @ 600Mhz"
+
+config GRX500_CBM_FREQ_800M
+	bool "CBM Frequency @ 800Mhz"
+
+config GRX500_CBM_FREQ_1200M
+	bool "CBM Frequency @ 1200Mhz"
+
+config GRX500_CBM_FREQ_2400M
+	bool "CBM Frequency @ 2400Mhz"
+
+endchoice
+
+config GRX500_MIPS_ENDIAN_BE
+	bool "Select to run MIPS in BE mode"
+	default y
+        depends on !GRX500_USE_DDR_PRECONFIG
+	help
+		Set MIPS to run in BE/LE
+
+endmenu
+
+menu "SWITCH OPTIONS"
+
+choice 
+	prompt "Interfaces"
+
+config NETWORK_VIA_LAN
+	bool "Network via LAN ports"
+	select GRX500_PHY2
+	select GRX500_PHY3
+	select GRX500_PHY4
+	select GRX500_PHY5
+
+config NETWORK_VIA_WAN
+	bool "Network via WAN port"
+	select GRX500_PHY2
+	select GRX500_PHY3
+	select GRX500_PHY4
+	select GRX500_PHY5
+	select GRX500_PHY6F
+
+endchoice
+
+config GRX500_PHY2
+	bool
+
+config GRX500_PHY3
+	bool
+
+config GRX500_PHY4
+	bool
+
+config GRX500_PHY5
+	bool
+
+config GRX500_PHY6F
+	bool
+
+config GRX500_GPHY_FW_EMBEDDED
+    bool "gphy firmware embedded"
+    default y
+
+config GRX500_GPHY_FW_ADDR
+    hex
+    default "0xa0220000" if ( BOOT_FROM_SPI )
+    default "0xa0220000" if ( BOOT_FROM_NAND )
+    depends on GRX500_GPHY_FW_EMBEDDED
+
+config GRX500_EXTERN_GPHY_FW_ADDR
+    hex "gphy firmware address"
+    default "0xb0010000"
+    depends on !GRX500_GPHY_FW_EMBEDDED
+
+endmenu
diff --git a/board/grx500/Makefile b/board/grx500/Makefile
new file mode 100644
--- /dev/null
+++ b/board/grx500/Makefile
@@ -0,0 +1,48 @@
+#
+# (C) Copyright 2003-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	= $(BOARD).o 
+#SOBJS	= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+sfddr: start_sfddr.o sfddr_board.o lowlevel_init.o 
+
+	
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/grx500/Makefile.lq b/board/grx500/Makefile.lq
new file mode 100644
--- /dev/null
+++ b/board/grx500/Makefile.lq
@@ -0,0 +1,302 @@
+ifeq ($(CONFIG_GRX500_A21),y)
+    BCH_ENCODER := $(TOPDIR)/board/$(BOARD)/bch_enc_a21.c
+else
+    BCH_ENCODER := $(TOPDIR)/board/$(BOARD)/bch_enc_a11.c
+endif
+
+ifeq ($(CONFIG_GRX500_A21),y)
+	GPHYFW_AXX := $(TOPDIR)/board/$(BOARD)/gphy_firmware_a21.img
+else
+	GPHYFW_AXX := $(TOPDIR)/board/$(BOARD)/gphy_firmware_a11.img
+endif
+
+ifdef CONFIG_GRX500_DDR3
+DDR_TYPE := 3
+else
+DDR_TYPE := 2
+endif
+
+ifeq ($(CONFIG_GRX500_400M_CL6),y)
+    DDR_GRADE := 1
+else ifeq ($(CONFIG_GRX500_533M_CL6),y)
+    DDR_GRADE := 2
+else ifeq ($(CONFIG_GRX500_533M_CL7),y)
+    DDR_GRADE := 3
+else ifeq ($(CONFIG_GRX500_533M_CL8),y)
+    DDR_GRADE := 4
+else ifeq ($(CONFIG_GRX500_667M_CL8),y)
+    DDR_GRADE := 5
+else ifeq ($(CONFIG_GRX500_667M_CL9),y)
+    DDR_GRADE := 6
+else ifeq ($(CONFIG_GRX500_667M_CL10),y)
+    DDR_GRADE := 7
+else ifeq ($(CONFIG_GRX500_800M_CL9),y)
+    DDR_GRADE := 8
+else ifeq ($(CONFIG_GRX500_800M_CL10),y)
+    DDR_GRADE := 9
+else ifeq ($(CONFIG_GRX500_800M_CL11),y)
+    DDR_GRADE := 10
+else
+    $(Unsupported DDR Grade, please recheck selected settings)   
+endif
+
+ifeq ($(CONFIG_GRX500_32Mx16),y)
+    DDR_DENSITY := 2
+else ifeq ($(CONFIG_GRX500_64Mx8),y)
+    DDR_DENSITY := 3
+else ifeq ($(CONFIG_GRX500_64Mx16),y)
+    DDR_DENSITY := 4
+else ifeq ($(CONFIG_GRX500_128Mx8),y)
+    DDR_DENSITY := 5
+else ifeq ($(CONFIG_GRX500_128Mx16),y)
+    DDR_DENSITY := 6
+else ifeq ($(CONFIG_GRX500_256Mx8),y)
+    DDR_DENSITY := 7
+else ifeq ($(CONFIG_GRX500_256Mx16),y)
+    DDR_DENSITY := 8
+else ifeq ($(CONFIG_GRX500_512Mx8),y)
+    DDR_DENSITY := 9
+else ifeq ($(CONFIG_GRX500_512Mx16),y)
+    DDR_DENSITY := 10
+else 
+   $(Unsupported DDR Density, please recheck selected settings)
+endif
+
+ifeq ($(CONFIG_GRX500_CPU_600M),y)
+    CPU_SPEED := 3
+else ifeq ($(CONFIG_GRX500_CPU_800M),y)
+    CPU_SPEED := 2
+else ifeq ($(CONFIG_GRX500_CPU_1000M),y)
+    CPU_SPEED := 16
+else ifeq ($(CONFIG_GRX500_CPU_1200M),y)
+    CPU_SPEED := 1
+else
+    $(Unsupported CPU Speed, please recheck selected settings)
+endif
+
+ifeq ($(CONFIG_GRX500_DDR_CTRL_200M),y)
+    DDR_CTRL_SPEED := 7
+else ifeq ($(CONFIG_GRX500_DDR_CTRL_333M),y)
+    DDR_CTRL_SPEED := 5
+else ifeq ($(CONFIG_GRX500_DDR_CTRL_400M),y)
+    DDR_CTRL_SPEED := 4
+else
+    $(Unsupported DDR Controller settings, please recheck selected settings)
+endif
+
+ifdef CONFIG_GRX500_MIPS_ENDIAN_BE
+MIPS_ENDIAN := 1
+else
+MIPS_ENDIAN := 0
+endif
+
+ifeq ($(CONFIG_GRX500_CBM_FREQ_200M),y)
+	CBM_FREQ := 8
+else ifeq ($(CONFIG_GRX500_CBM_FREQ_300M),y)
+	CBM_FREQ := 6
+else ifeq ($(CONFIG_GRX500_CBM_FREQ_400M),y)
+	CBM_FREQ := 5
+else ifeq ($(CONFIG_GRX500_CBM_FREQ_480M),y)
+	CBM_FREQ := 4
+else ifeq ($(CONFIG_GRX500_CBM_FREQ_600M),y)
+	CBM_FREQ := 3
+else ifeq ($(CONFIG_GRX500_CBM_FREQ_800M),y)
+	CBM_FREQ := 2
+else ifeq ($(CONFIG_GRX500_CBM_FREQ_1200M),y)
+	CBM_FREQ := 1
+else ifeq ($(CONFIG_GRX500_CBM_FREQ_2400M),y)
+	CBM_FREQ := 0
+else
+    $(Unsupported CBM freq settings, please recheck selected settings)
+endif
+
+ifeq ($(CONFIG_GRX500_BL8),y)
+	BL := 8
+else ifeq ($(CONFIG_GRX500_BC4),y)
+	BL := 4
+else
+        BL := 8	
+endif
+
+ifeq ($(CONFIG_GRX500_CS0_ONLY),y)
+	CS := 1
+else
+	CS := 2
+endif
+
+##### end grx500 ddr configurations
+
+SIGN_IMAGE     := n
+SIGN_IMAGE_OPT :=
+
+ifdef CONFIG_LTQ_SECURE_BOOT
+    ifdef CONFIG_GRX500_A21
+        SIGN_IMAGE := y
+    else
+        ifeq ($(CONFIG_GRX500_A11)$(CONFIG_GRX500_LOAD_BOOTCORE),yy)
+        SIGN_IMAGE := y
+        endif
+    endif
+
+    # extra command line option to signtool
+    ifdef CONFIG_CERTIFICATION_SUPPORT
+        SIGN_IMAGE_OPT += -cert $(CONFIG_CERTIFICATION)
+    endif
+    ifdef CONFIG_GRX500_A21
+        # let fsb handle the jump to u-boot part
+        SIGN_IMAGE_OPT += -attribute 0x80000006=0x00000000
+    endif
+
+endif
+
+##### end grx500 secure boot configurations
+
+ifdef CONFIG_BUILD_ENV_BLOCK
+ENV_BLOCK=ubootenv.img
+endif
+
+ifdef CONFIG_GRX500_GPHY_FW_EMBEDDED
+    GPHY_FIRMWARE = $(TOPDIR)/board/$(BOARD)/gphy_firmware.img
+else
+    GPHY_FIRMWARE = $(TOPDIR)/dummy
+endif
+
+ALL +=u-boot.lzimg u-boot.ltq $(ENV_BLOCK)
+LDSCRIPT_BOOTSTRAP := $(TOPDIR)/board/$(BOARD)/bootstrap.lds
+ifdef CONFIG_BOOT_FROM_NAND
+SFDDR_START_ADDR := $(CONFIG_NAND_SPL_TEXT_BASE)
+endif
+
+ifdef CONFIG_BOOT_FROM_SPI
+SFDDR_START_ADDR := $(CONFIG_SFDDR_TEXT_BASE)
+GPHYFIRMWARE := $(TOPDIR)/board/grx500/gphy_firmware.img
+endif
+
+
+OBJS_BOOTSTRAP  = $(TOPDIR)/$(CPUDIR)/$(BOARD)/start_uncomp.o
+OBJS_BOOTSTRAP  += $(TOPDIR)/lib/string.o
+LIBS_BOOTSTRAP  = $(TOPDIR)/lib_bootstrap/libbootstrap.a
+LIBS_BOOTSTRAP += $(TOPDIR)/lib/crc32.o
+BOOTSTRAP_LDFLAGS = -Bstatic -T $(LDSCRIPT_BOOTSTRAP) -Ttext $(CONFIG_BOOTSTRAP_TEXT_BASE)
+
+ifdef CONFIG_BOOT_FROM_NAND
+$(obj)u-boot.ltq: $(obj)System.map $(obj)bootstrap.bin $(obj)u-boot.lzimg ddr.conf 
+		@cp -f $(BCH_ENCODER) $(TOPDIR)/board/grx500/bch_enc.c
+		@$(TOPDIR)/scripts_platform/pad2align.sh -n 10240 bootstrap.bin
+		@cat $(obj)bootstrap.bin > $(obj)u-boot.ltq
+		@cat $(obj)u-boot.lzimg >> $(obj)u-boot.ltq
+ifdef CONFIG_GRX500_GPHY_FW_EMBEDDED
+		@cp $(obj)u-boot.bin $(obj)u-boot-gphy.bin
+		@$(TOPDIR)/scripts_platform/pad2align.sh -n 0x40000 u-boot-gphy.bin
+		@$(TOPDIR)/scripts_platform/pad2align.sh -n 65536 u-boot.ltq
+		@cp $(GPHYFW_AXX) $(GPHY_FIRMWARE)
+		@cat $(GPHY_FIRMWARE) >>u-boot.ltq	
+endif
+ifndef CONFIG_MANUBOOT
+ifeq ($(CONFIG_LTQ_SECURE_BOOT)$(SIGN_IMAGE),yy)
+		@$(CONFIG_SIGNTOOL) sign -type BLw  -infile u-boot.ltq \
+                           -prikey $(CONFIG_PRIVATE_KEY) \
+                           -wrapkey $(CONFIG_PROD_UNIQUE_KEY) \
+                           -attribute rollback=2 \
+                           -attribute 0x80000000=$(CONFIG_BOOTSTRAP_TEXT_BASE)\
+                           -attribute 0x80000001=0x00000001 \
+                           -attribute 0x80000002=$(CONFIG_BOOTSTRAP_TEXT_BASE) \
+                           -encattr \
+                           -kdk \
+                           -pubkeytype otp \
+                           -algo aes256 \
+                           $(SIGN_IMAGE_OPT) \
+                           -outfile signed_uboot.ltq
+		@cp signed_uboot.ltq u-boot.ltq
+endif 
+endif # end CONFIG_MANUBOOT
+endif
+
+ifdef CONFIG_BOOT_FROM_SPI
+$(obj)u-boot.ltq: $(obj)System.map $(obj)u-boot.lzimg ddr.conf sfddr.bin 
+		@@cp -f $(BCH_ENCODER) $(TOPDIR)/board/grx500/bch_enc.c
+		@$(TOPDIR)/scripts_platform/mk_ltq_header.pl --ddr $(TOPDIR)/board/$(BOARD)/ddr.conf --offset 0x800 --out header.ltq 
+		@$(TOPDIR)/scripts_platform/pad2align.sh -n 1760 header.ltq
+		@$(HOSTCC) -o bch_enc $(BCH_ENCODER)
+		@./bch_enc header.ltq header.bch $(CONFIG_GRX500_ROM_HEADER_BCH_CAP)
+		@$(TOPDIR)/scripts_platform/mk_sf_image.pl -i sfddr.bin -o tail.bin -j $(SFDDR_START_ADDR) -m 0
+		@cp header.bch u-boot.ltq
+		@cat tail.bin >>u-boot.ltq
+		@$(TOPDIR)/scripts_platform/pad2align.sh -n 0x6000 u-boot.ltq
+		@cat u-boot.lzimg >>u-boot.ltq
+ifdef CONFIG_GRX500_GPHY_FW_EMBEDDED
+		@cp $(obj)u-boot.bin $(obj)u-boot-gphy.bin	
+		@$(TOPDIR)/scripts_platform/pad2align.sh -n 0x40000 u-boot-gphy.bin
+		@$(TOPDIR)/scripts_platform/pad2align.sh -n 0x20000 u-boot.ltq
+		@cp $(GPHYFW_AXX) $(GPHY_FIRMWARE)
+		@cat $(GPHYFIRMWARE) >>u-boot.ltq
+endif
+endif
+						
+LDFLAGS_SFDDR = -Bstatic -T $(TOPDIR)/board/$(BOARD)/bootstrap.lds -Ttext $(SFDDR_START_ADDR) $(PLATFORM_LDFLAGS)
+OBJS_SFDDR = $(TOPDIR)/board/$(BOARD)/start_sfddr.o 
+OBJS_SFDDR +=$(TOPDIR)/board/$(BOARD)/sfddr_board.o 
+OBJS_SFDDR +=$(TOPDIR)/board/$(BOARD)/lowlevel_init.o
+
+LIBS_SFDDR = $(TOPDIR)/lib/libgeneric.a
+LIBS_SFDDR += $(TOPDIR)/drivers/serial/lq_asc.o
+LIBS_SFDDR += $(TOPDIR)/arch/mips/lib/time.o
+LIBS_SFDDR += $(TOPDIR)/lib_bootstrap/LzmaDecode.o
+LIBS_SFDDR += $(TOPDIR)/lib_bootstrap/LzmaWrapper.o
+LIBS_SFDDR += $(TOPDIR)/$(CPUDIR)/$(BOARD)/libmips.a
+
+
+ddr.conf:
+	@rm -rf $(TOPDIR)/board/$(BOARD)/ddr.conf
+ifeq ($(CONFIG_GRX500_USE_DDR_PRECONFIG),y)
+	@cp $(CONFIG_GRX500_DDR_CONFIG_FILE) $(TOPDIR)/board/$(BOARD)/ddr.conf 
+else
+	@rm -f $(TOPDIR)/board/$(BOARD)/init_ddr
+	@gcc -o $(TOPDIR)/board/$(BOARD)/init_ddr $(TOPDIR)/board/$(BOARD)/init_ddr.c
+	@$(TOPDIR)/board/$(BOARD)/init_ddr -type $(DDR_TYPE) -grade $(DDR_GRADE) -density $(DDR_DENSITY) \
+		-rank $(CS)	-bl $(BL) -al $(CONFIG_GRX500_ADDITIVE_LATENCY) -endian $(MIPS_ENDIAN) \
+		-sr0 $(CONFIG_GRX500_1ST_SR0_VALUE) $(CONFIG_GRX500_2ND_SR0_VALUE) \
+		-sr1 $(CONFIG_GRX500_1ST_SR1_VALUE) $(CONFIG_GRX500_2ND_SR1_VALUE) \
+		-fcps $(CPU_SPEED) -fsl 8 -fngi 6 -fcbm $(CBM_FREQ) -fcps2 1 -fdctl $(DDR_CTRL_SPEED) \
+		-fgsw 5 -fgswr 6 -o $(TOPDIR)/board/$(BOARD)/ddr.conf 
+endif
+
+
+sfddr.bin:    $(obj)sfddr
+		@$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+sfddr: $(SUBDIRS) $(OBJS_SFDDR) $(LIBS_SFDDR) 
+		$(LD) $(LDFLAGS_SFDDR) $(OBJS_SFDDR) $(LIBS_SFDDR) \
+	     -Map sfddr.map -o sfddr
+
+$(OBJS_SFDDR):
+		rm -f $(OBJS_SFDDR)
+		$(MAKE) -C `dirname $@` sfddr
+				
+
+bootstrap.bin:    $(obj)bootstrap
+		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+bootstrap: $(OBJS_BOOTSTRAP) $(LIBS_BOOTSTRAP)  $(LDSCRIPT_BOOTSTRAP)
+		$(LD) $(BOOTSTRAP_LDFLAGS) $$UNDEF_SYM $(OBJS_BOOTSTRAP) $(LIBS_BOOTSTRAP) \
+                -Map bootstrap.map -o bootstrap
+
+$(LIBS_BOOTSTRAP):
+		$(MAKE) -C `dirname $@` all
+
+
+u-boot.lzimg: $(obj)u-boot.bin System.map
+		lzma e $(obj)u-boot.bin $(obj)u-boot.lzma
+		scripts_platform/pad2align.sh -n 16 u-boot.lzma
+		$(TOPDIR)/tools/mkimage -A mips -T firmware -C lzma \
+		-a 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-e 0x$(shell grep "T _start" $(TOPDIR)/System.map | awk '{ printf "%s", $$1 }') \
+		-n 'u-boot image' -d $(obj)u-boot.lzma $@
+
+
+
+$(ENV_BLOCK): $(obj)u-boot $(obj)u-boot.bin
+		$(NM) -Ss u-boot >u-boot.sym
+		scripts_platform/mk_envimg.sh $@
+
+
diff --git a/board/grx500/bch_enc_a11.c b/board/grx500/bch_enc_a11.c
new file mode 100644
--- /dev/null
+++ b/board/grx500/bch_enc_a11.c
@@ -0,0 +1,858 @@
+/*
+Author : Wang Yunliang
+Company : Lantqi Asia Pacific Pte. Ltd.
+Release date : 2014 -10 -31
+
+Introduciton:
+This BCH encoder can generate 40 bits error correction encoder file "output.bin" from original file "sample.bin"
+You can choose how many errors you want to inject and the inject positions.
+
+All rights reserved.
+*/
+
+
+#include <math.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+
+#define BIN	"sample.bin"
+#define WBIN	"output.bin"
+#define RSBIN	"result.bin"
+
+int             m, n, length, k, t, d;
+int             p[21];
+int             alpha_to[1048576], index_of[1048576], g[548576];
+int             recd[1048576], data[1048576], bb[548576];
+int             seed;
+int             numerr, errpos[1024], decerror = 0;
+int 		filesize;
+uint8_t		input[8192];
+
+static sector_bits=4096;
+static Gx_num=521;
+
+
+int m_value=13;
+int t_value;
+char *argv0;
+char *input_str;
+char *output_str;
+char *argv3;
+uint8_t		source[512];
+uint8_t		source_temp2[4096];//512*8
+uint8_t		destination[512];
+uint8_t		output[512];
+uint8_t		source_temp[4096];//512*8
+uint8_t		Gx_record[3520][530];
+
+
+
+
+
+
+
+
+
+
+void 
+byte2bit(int len)
+{
+       int a, b, c;	
+       c = 0;
+       for (a = 0; a < len; a++) {
+            for (b = 0; b < 8; b++)
+	    {
+	        data[c] = (input[a] >> (7 - b)) & 1; 
+		c++;
+	    }
+	}
+
+}
+
+void 
+bit2byte(len)
+{
+	int a, b;
+	
+	for (a = 0; a < len; a++) {
+		output[a] = 0;
+		for (b = 0; b < 8; b++) {
+			output[a]|= (recd[(a*8)+b] << (7 - b));
+		}
+	}
+
+}
+
+
+
+void Gx_gen()
+{
+/*
+Author : Wang Yunliang
+Company : Lantqi Asia Pacific Pte. Ltd.
+Release date : 2014 -10 -31
+
+Introduciton:
+This BCH encoder can generate 40 bits error correction encoder file "output.bin" from original file "sample.bin"
+You can choose how many errors you want to inject and the inject positions.
+
+All rights reserved.
+*/
+
+
+int i,j,k,q;
+int x[14];
+int y[14];
+int x_next[2];
+int mx[100][14];
+
+int temp1,temp2;
+
+int z_value,nor_value;
+
+int shift_times=0;
+
+int shift_record[14];
+int overlap;
+
+int keep;
+int message_temp=0;
+int Gx_b=0;
+int Gx_b_temp=0;
+int ref_Gx;
+int r=0;
+int n=0;
+int kk=0;
+
+
+int Gx[Gx_num];
+int Gx_temp[sector_bits];
+int ref_Gx_byte[Gx_num];
+
+int q_max=79;
+
+int m_test;
+int ref_m;
+
+int error_num;
+int error_pos[40];
+
+
+int choose_num;
+
+choose_num = m_value;
+//printf("\n %d is choosed. \n",choose_num);
+
+switch(choose_num)
+{
+
+case 3:
+ m_test=3;
+ ref_m=0x3;
+break;
+
+case 4:
+ m_test=4;
+ ref_m=0x3;
+break;
+
+case 5:
+ m_test=5;
+ ref_m=0x5;
+break;
+
+case 6:
+ m_test=6;
+ ref_m=0x3;
+break;
+
+case 7:
+ m_test=7;
+ ref_m=0x3;
+break;
+
+case 8:
+ m_test=8;
+ ref_m=0x71;
+break;
+
+case 9:
+ m_test=9;
+ ref_m=0x11;
+break;
+
+case 10:
+ m_test=10;
+ ref_m=0x9;
+break;
+
+case 11:
+ m_test=11;
+ ref_m=0x5;
+break;
+
+case 12:
+ m_test=12;
+ ref_m=0x99;
+break;
+
+case 13:
+ m_test=13;
+ ref_m=0x1b;
+break;
+
+
+}
+
+//printf("\n m_test=%d  \n", m_test);
+//printf("\n ref_m=0x%x  \n", ref_m);
+
+
+
+//int message=0x1;
+//int message_bits=50;
+
+
+//uint8_t		source[512];
+//uint8_t		source_temp[sector_bits];//512*8
+//uint8_t		source_temp2[sector_bits];//512*8
+uint8_t		temp_s;
+
+//int 	source_len=3520;//440*8   , 72*8=576
+int 	source_len=3520;//440*8   , 72*8=576
+int 	byte_s;
+int 	bit_s;
+
+
+uint8_t temp_w;
+int w_byte;
+int w_bit;
+
+
+
+FILE *input_file, *output_file;
+int input_sz, output_sz;
+int readlen;
+int ii;
+
+
+
+			
+int t;   //use the global t
+int d;
+
+//////////////////////
+
+
+
+t = t_value;
+//printf("\n t = %d is choosed. \n",t);
+
+
+
+
+
+
+////////////////////////
+
+for(i=0;i<14;i++)
+{
+x[i]=0;
+y[i]=0;
+
+}
+x_next[0]=0;
+x_next[1]=0;
+
+
+
+
+
+
+#if 1 
+
+for(q=1;q<=q_max;q=q+2)//m1(x),m3(x),...
+
+{
+/////////////
+
+for(i=0;i<14;i++)
+{
+x[i]=0;
+y[i]=0;
+shift_record[i]=0;
+
+}
+
+
+	x[0]=1;
+
+	for(i=1;i<=q;i++)
+	{
+
+		x[0]=x[0]<<1;
+
+		if((x[0]&(0x1<<m_test))!=0)
+		{
+
+			x[0]^=ref_m;
+
+		}
+
+
+		x[0]&=((0x1<<m_test)-1);
+
+
+	}
+
+x[1]=0x1;
+
+/////////////////////
+
+if(q>=(0x1<<m_test))
+{
+	shift_times=(q)%((0x1<<m_test)-1);
+	//printf("q*(1<<(i-1)) = 0x%x \n",q*(1<<(i-1)));
+	//printf("(0x1<<m_test)-1 = 0x%x \n",(0x1<<m_test)-1);
+	//printf("shift_times = 0x%x \n",shift_times);
+
+}
+else
+{
+	shift_times=q;
+	//printf("shift_times = 0x%x \n",shift_times);
+
+}
+shift_record[1]=shift_times;
+
+
+/////////////////////////
+
+
+
+
+
+for(i=2;i<=m_test;i++)
+{
+
+	//x_next[0]=1<<(3*(1<<(i-1)));
+	//x_next[1]=1;
+
+	overlap=0;
+
+	if(q*(1<<(i-1))>=(0x1<<m_test))
+	{
+		shift_times=(q*(1<<(i-1)))%((0x1<<m_test)-1);
+		//printf("q*(1<<(i-1)) = 0x%x \n",q*(1<<(i-1)));
+		//printf("(0x1<<m_test)-1 = 0x%x \n",(0x1<<m_test)-1);
+		//printf("shift_times = 0x%x \n",shift_times);
+
+	}
+	else
+	{
+		shift_times=q*(1<<(i-1));
+		//printf("shift_times = 0x%x \n",shift_times);
+
+	}
+
+	for(j=1;j<=i-1;j++)
+	{
+		if(shift_times==shift_record[j])
+			{
+				overlap=1;
+				//printf("overlap here.\n");
+				break;
+			}
+		else
+			{
+				overlap=0;
+			}
+			
+	}
+
+	if(overlap==1)
+		{
+			//printf("skip current item. \n");
+			continue;
+
+		}
+
+
+
+
+
+	shift_record[i]=shift_times;
+
+
+
+	y[0]=0;
+	for(j=0;j<=(m_test-1);j++)
+	{
+		y[j+1]=x[j];
+	}
+
+
+	
+	for(j=1;j<=shift_times;j++)
+	{
+		for(k=0;k<=i-1;k++)
+		{
+
+
+		
+		
+			if((x[k]&(0x1<<(m_test-1)))!=0)
+			{
+				x[k]=(x[k]<<1)&((0x1<<m_test)-1);
+				x[k]^=ref_m;
+			}
+			else
+			{
+				x[k]=(x[k]<<1)&((0x1<<m_test)-1);
+
+			}
+
+		}
+
+
+		
+	}
+	
+	for(j=0;j<=m_test;j++)
+	{
+		x[j]^=y[j];
+	}
+
+
+
+
+}
+
+//printf("q= %d,x[j]^y[j]= ",q);
+
+for(j=0;j<=m_test;j++)
+{
+//	printf("%4d ,",x[j]);
+	mx[q][j]=x[j];
+}
+
+//printf("\n\n\n\n");
+
+/////////////////
+}	
+#endif
+
+
+////////////////////////////////////////////////////////////////////////
+#if 1
+for(i=0;i<Gx_num;i++)
+{
+	Gx_temp[i]=0;
+	Gx[i]=0;
+}
+
+for(i=0;i<=m_test;i++)
+{
+
+	Gx_temp[i]=mx[1][i];
+}
+
+////////////
+d=0;
+q=1;
+for(i=0;i<=m_test;i++)
+{
+
+	Gx[i]=mx[1][i];
+	if(Gx[i]==1)
+	{
+		r=i;
+	}
+	
+		
+}
+
+
+
+if(t<=1)
+{
+	keep=0;
+
+}
+else
+{
+	keep=1;
+}
+
+/////////////
+
+
+if(keep ==1 )
+{
+for(q=3;q<=q_max;q=q+2)
+{
+
+	for(i=0;i<Gx_num;i++)
+	{
+		Gx[i]=0;
+	}
+
+
+	for(i=0;i<=m_test;i++)
+	{
+		if((mx[q][i]!=1)&&(mx[q][i]!=0))
+		{
+			printf("error on mx ! \n");
+			return;
+		}
+		else if (mx[q][i]==1)
+		{
+			for(j=0;j<Gx_num;j++)
+			{
+				Gx[j+i]^=Gx_temp[j];
+			}
+
+		}
+		
+	}
+
+
+	for(i=0;i<Gx_num;i++)
+	{
+
+		Gx_temp[i]=Gx[i];
+		if(Gx[i]==1)
+		{
+
+			r=i;
+		}
+		
+			
+	}
+
+	if(q>=(2*t-1))
+	{
+		break;
+	}
+
+
+
+}
+}
+
+
+if(q>=(2*t-1))
+{
+//	printf("q=%d >= (2*t-1)=%d , t=%d \n",q,(2*t-1),t);
+
+}
+else
+{
+	printf("failed,q<(2*t-1) \n");
+	return;
+}
+
+d=2*t+1;
+
+n=(1<<m_test)-1;
+kk=n-r;
+
+
+
+#if 1
+
+
+
+for(j=0;j<3520;j++)
+{
+	for(ii=0;ii<530;ii++)
+	{
+	
+		Gx_record[j][ii]=0;
+	}
+}
+
+
+
+
+
+
+
+if(kk>=source_len)
+{
+//	printf("kk=%d  >= source_len=%d \n",kk,source_len);
+
+	for(i=0;i<source_len;i++)
+	{
+
+
+			if(i==0)
+			{
+			
+				for(j=0;j<Gx_num;j++)
+				{
+		
+					Gx_temp[j]=Gx[j];
+				}
+			
+			}
+
+			else if(Gx_temp[r-1]==1)
+			{
+				//Gx_b_temp= (0x1<<(r+i))| (((Gx_b_temp<<1) &((0x1<<r)-1))^ref_Gx);
+				Gx_temp[r+i]=1;
+				Gx_temp[r+i-1]=0;
+				for(j=(r-2);j>=0;j--)
+				{
+					Gx_temp[j+1]=Gx_temp[j];
+				}					
+				Gx_temp[0]=0;
+				
+				for(j=0;j<r;j++)
+				{
+		
+					Gx_temp[j]^=Gx[j];
+				}
+					
+			}
+			else
+			{
+ 					//Gx_b_temp= (0x1<<(r+i))| ((Gx_b_temp<<1) &((0x1<<r)-1));  	
+ 				Gx_temp[r+i]=1;
+				Gx_temp[r+i-1]=0;
+				for(j=(r-2);j>=0;j--)
+				{
+					Gx_temp[j+1]=Gx_temp[j];
+				}					
+				Gx_temp[0]=0;
+			}
+
+				for(j=0;j<r;j++)
+				{
+					Gx_record[i][j]=Gx_temp[j];
+				}
+				
+			
+
+	}
+	
+}
+else
+{
+	printf("error! kk must >= source_len.\n");
+	printf("kk=%d  , source_len=%d \n",kk,source_len);
+	return;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+input_file = fopen(input_str, "rb");
+if (!input_file) {
+		printf("Error opening file %s\n", input_str);
+		return;
+}
+
+
+output_file = fopen(output_str, "wb");
+if (!output_file) {
+		printf("Error opening file %s\n", output_str);
+		return;
+}
+
+
+fseek(input_file, 0L, SEEK_END);
+input_sz = ftell(input_file);
+fseek(input_file, 0L, SEEK_SET);
+
+
+
+
+
+for(ii=0;ii<input_sz;ii+=440){
+	//printf("i=%d\n",i);
+	fseek(input_file, ii, SEEK_SET);  
+
+
+	if(ii+440<=input_sz)
+	{
+		readlen=fread(input, 440, 1, input_file); 
+
+	}
+	else
+	{
+		readlen=fread(input, (input_sz-ii), 1, input_file); 
+		for (j = (input_sz-ii); j < 440; j++)
+		{
+			input[j]=0;
+		
+		}
+
+	}
+	
+
+	
+	byte2bit(440);
+
+	for (j = 0; j < 3520; j++)
+	{
+		source_temp[j]=data[j];
+
+	}
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
+
+
+for(j=0;j<sector_bits;j++)
+	{
+		Gx_temp[j]=0;
+		source_temp2[j]=0;
+	}
+
+
+if(kk>=source_len)
+{
+//	printf("kk=%d  >= source_len=%d \n",kk,source_len);
+
+	for(i=0;i<source_len;i++)
+	{
+
+			if(source_temp[i])
+			{
+			
+				//message_temp = (message_temp ^ Gx_b_temp);
+				for(j=0;j<r;j++)
+				{
+					source_temp2[j]^=Gx_record[i][j];
+				}
+
+				source_temp2[r+i]=1;
+				
+			}
+			//printf("message_temp = 0x%x \n",message_temp);
+
+
+	}
+	
+}
+else
+{
+	printf("error! kk must >= source_len.\n");
+	printf("kk=%d  , source_len=%d \n",kk,source_len);
+	return;
+}
+
+
+error_num=0;
+for(j=0;j<40;j++)
+{
+	error_pos[j]=0;
+}
+
+
+	error_num=0;
+
+
+if((error_num>0)&&(error_num<=40))
+{
+	for(j=0;j<error_num;j++)
+	{
+		scanf("%d", &error_pos[j]);
+
+	}
+
+	for(j=0;j<error_num;j++)
+	{
+		source_temp2[error_pos[j]]^=1;
+
+	}	
+	
+}
+else if (error_num >40)
+{
+	printf("error number must <= 40 \n");
+}
+
+
+
+
+
+for (i = 0; i < 4096; i++) 
+{
+	w_byte=i/8;
+	w_bit=i%8;
+	if(w_bit==0)
+	{
+		temp_w=0;
+	}
+	
+
+	temp_w|= ((source_temp2[i])&(0x1))<<(7-w_bit);	
+
+	if(w_bit==7)
+	{
+		output[w_byte]=temp_w;
+	}
+
+}
+
+
+
+
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+	fwrite(&output, 512, 1, output_file);
+ }		  
+
+
+fclose(input_file);
+fclose(output_file);
+
+
+
+#endif
+
+
+
+/////////////////////////////////
+
+#endif 
+
+}
+
+
+
+
+int main(int argc, char *argv[])
+{
+	int  i,j;
+
+        argv0 = argv[0];
+	input_str = argv[1];
+	output_str = argv[2];
+	argv3 = argv[3];
+	
+
+	t_value = strtoul(argv3,NULL,10);
+
+
+	Gx_gen();
+
+        return 0;
+	
+}
+
diff --git a/board/grx500/bch_enc_a21.c b/board/grx500/bch_enc_a21.c
new file mode 100755
--- /dev/null
+++ b/board/grx500/bch_enc_a21.c
@@ -0,0 +1,901 @@
+/*
+Author : Wang Yunliang
+Company : Lantqi Asia Pacific Pte. Ltd.
+Release date : 2014 -10 -31
+
+Introduciton:
+This BCH encoder can generate 40 bits error correction encoder file "output.bin" from original file "sample.bin"
+You can choose how many errors you want to inject and the inject positions.
+
+All rights reserved.
+*/
+
+
+#include <math.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+
+#define BIN	"sample.bin"
+#define WBIN	"output.bin"
+#define RSBIN	"result.bin"
+
+int             m, n, length, k, t, d;
+int             p[21];
+int             alpha_to[1048576], index_of[1048576], g[548576];
+int             recd[1048576], data[1048576], bb[548576];
+int             seed;
+int             numerr, errpos[1024], decerror = 0;
+int 		filesize;
+uint8_t		input[8192];
+
+static sector_bits=4096;
+static Gx_num=521;
+
+
+int m_value=12;
+int t_value;
+char *argv0;
+char *input_str;
+char *output_str;
+char *argv3;
+uint8_t		source[512];
+uint8_t		source_temp2[4096];//512*8
+uint8_t		source_temp2_temp[4096];//512*8
+
+uint8_t		destination[512];
+uint8_t		output[512];
+uint8_t		source_temp[4096];//512*8
+uint8_t		Gx_record[3520][530];
+
+
+
+
+
+
+
+
+
+
+
+void 
+byte2bit(int len)
+{
+       int a, b, c;	
+       c = 0;
+       for (a = 0; a < len; a++) {
+            for (b = 0; b < 8; b++)
+	    {
+	        data[c] = (input[a] >> (7 - b)) & 1; 
+		c++;
+
+	    }
+	}
+
+}
+
+void 
+bit2byte(len)
+{
+	int a, b;
+	
+	for (a = 0; a < len; a++) {
+		output[a] = 0;
+		for (b = 0; b < 8; b++) {
+			output[a]|= (recd[(a*8)+b] << (7 - b));
+		}
+	}
+
+}
+
+
+
+void Gx_gen()
+{
+/*
+Author : Wang Yunliang
+Company : Lantqi Asia Pacific Pte. Ltd.
+Release date : 2014 -10 -31
+
+Introduciton:
+This BCH encoder can generate 40 bits error correction encoder file "output.bin" from original file "sample.bin"
+You can choose how many errors you want to inject and the inject positions.
+
+All rights reserved.
+*/
+
+
+int i,j,k,q;
+int x[14];
+int y[14];
+int x_next[2];
+int mx[100][14];
+
+int temp1,temp2;
+
+int z_value,nor_value;
+
+int shift_times=0;
+
+int shift_record[14];
+int overlap;
+
+int keep;
+int message_temp=0;
+int Gx_b=0;
+int Gx_b_temp=0;
+int ref_Gx;
+int r=0;
+int n=0;
+int kk=0;
+
+
+
+int Gx[Gx_num];
+int Gx_temp[sector_bits];
+int ref_Gx_byte[Gx_num];
+
+int q_max=79;
+
+
+int m_test;
+int ref_m;
+
+int error_num;
+int error_pos[40];
+
+
+int choose_num;
+
+choose_num = m_value;
+//printf("\n %d is choosed. \n",choose_num);
+
+switch(choose_num)
+{
+
+case 3:
+ m_test=3;
+ ref_m=0x3;
+break;
+
+case 4:
+ m_test=4;
+ ref_m=0x3;
+break;
+
+case 5:
+ m_test=5;
+ ref_m=0x5;
+break;
+
+case 6:
+ m_test=6;
+ ref_m=0x3;
+break;
+
+case 7:
+ m_test=7;
+ ref_m=0x3;
+break;
+
+case 8:
+ m_test=8;
+ ref_m=0x71;
+break;
+
+case 9:
+ m_test=9;
+ ref_m=0x11;
+break;
+
+case 10:
+ m_test=10;
+ ref_m=0x9;
+break;
+
+case 11:
+ m_test=11;
+ ref_m=0x5;
+break;
+
+case 12:
+ m_test=12;
+//ref_m=0x99 //old
+ ref_m=0x53;
+break;
+
+case 13:
+ m_test=13;
+ ref_m=0x1b;
+break;
+
+
+}
+
+//printf("\n m_test=%d  \n", m_test);
+//printf("\n ref_m=0x%x  \n", ref_m);
+
+
+
+//int message=0x1;
+//int message_bits=50;
+
+
+//uint8_t		source[512];
+//uint8_t		source_temp[sector_bits];//512*8
+//uint8_t		source_temp2[sector_bits];//512*8
+uint8_t		temp_s;
+
+//int 	source_len=3520;//440*8   , 72*8=576
+int 	source_len=3520;//440*8   , 72*8=576
+int 	byte_s;
+int 	bit_s;
+
+
+uint8_t temp_w;
+int w_byte;
+int w_bit;
+
+
+
+
+FILE *input_file, *output_file;
+int input_sz, output_sz;
+int readlen;
+int ii;
+
+
+
+			
+int t;   //use the global t
+int d;
+
+//////////////////////
+
+
+
+t = t_value;
+//printf("\n t = %d is choosed. \n",t);
+
+
+
+
+
+
+////////////////////////
+
+for(i=0;i<14;i++)
+{
+x[i]=0;
+y[i]=0;
+
+}
+x_next[0]=0;
+x_next[1]=0;
+
+
+
+
+
+
+
+#if 1 
+
+for(q=1;q<=q_max;q=q+2)//m1(x),m3(x),...
+
+{
+/////////////
+
+
+for(i=0;i<14;i++)
+{
+x[i]=0;
+y[i]=0;
+shift_record[i]=0;
+
+}
+
+
+	x[0]=1;
+
+	for(i=1;i<=q;i++)
+	{
+
+		x[0]=x[0]<<1;
+
+		if((x[0]&(0x1<<m_test))!=0)
+		{
+
+
+			x[0]^=ref_m;
+
+		}
+
+
+		x[0]&=((0x1<<m_test)-1);
+
+
+	}
+
+x[1]=0x1;
+
+/////////////////////
+
+if(q>=(0x1<<m_test))
+{
+	shift_times=(q)%((0x1<<m_test)-1);
+	//printf("q*(1<<(i-1)) = 0x%x \n",q*(1<<(i-1)));
+	//printf("(0x1<<m_test)-1 = 0x%x \n",(0x1<<m_test)-1);
+	//printf("shift_times = 0x%x \n",shift_times);
+
+
+}
+else
+{
+	shift_times=q;
+	//printf("shift_times = 0x%x \n",shift_times);
+
+}
+shift_record[1]=shift_times;
+
+
+/////////////////////////
+
+
+
+
+
+for(i=2;i<=m_test;i++)
+{
+
+
+	//x_next[0]=1<<(3*(1<<(i-1)));
+	//x_next[1]=1;
+
+	overlap=0;
+
+	if(q*(1<<(i-1))>=(0x1<<m_test))
+	{
+		shift_times=(q*(1<<(i-1)))%((0x1<<m_test)-1);
+		//printf("q*(1<<(i-1)) = 0x%x \n",q*(1<<(i-1)));
+		//printf("(0x1<<m_test)-1 = 0x%x \n",(0x1<<m_test)-1);
+		//printf("shift_times = 0x%x \n",shift_times);
+
+	}
+	else
+	{
+		shift_times=q*(1<<(i-1));
+		//printf("shift_times = 0x%x \n",shift_times);
+
+	}
+
+	for(j=1;j<=i-1;j++)
+	{
+		if(shift_times==shift_record[j])
+			{
+
+				overlap=1;
+				//printf("overlap here.\n");
+				break;
+			}
+		else
+			{
+				overlap=0;
+			}
+			
+	}
+
+	if(overlap==1)
+		{
+			//printf("skip current item. \n");
+			continue;
+
+		}
+
+
+
+
+
+	shift_record[i]=shift_times;
+
+
+
+	y[0]=0;
+	for(j=0;j<=(m_test-1);j++)
+	{
+
+		y[j+1]=x[j];
+	}
+
+
+	
+	for(j=1;j<=shift_times;j++)
+	{
+		for(k=0;k<=i-1;k++)
+		{
+
+
+
+		
+		
+			if((x[k]&(0x1<<(m_test-1)))!=0)
+			{
+
+				x[k]=(x[k]<<1)&((0x1<<m_test)-1);
+				x[k]^=ref_m;
+			}
+			else
+			{
+				x[k]=(x[k]<<1)&((0x1<<m_test)-1);
+
+			}
+
+		}
+
+
+		
+	}
+	
+	for(j=0;j<=m_test;j++)
+	{
+
+		x[j]^=y[j];
+	}
+
+
+
+
+}
+
+//printf("q= %d,x[j]^y[j]= ",q);
+
+for(j=0;j<=m_test;j++)
+{
+//	printf("%4d ,",x[j]);
+
+	mx[q][j]=x[j];
+}
+
+//printf("\n\n\n\n");
+
+/////////////////
+}	
+#endif
+
+
+////////////////////////////////////////////////////////////////////////
+#if 1
+for(i=0;i<Gx_num;i++)
+{
+
+	Gx_temp[i]=0;
+	Gx[i]=0;
+}
+
+for(i=0;i<=m_test;i++)
+{
+
+
+	Gx_temp[i]=mx[1][i];
+}
+
+////////////
+d=0;
+q=1;
+for(i=0;i<=m_test;i++)
+{
+
+
+	Gx[i]=mx[1][i];
+	if(Gx[i]==1)
+	{
+		r=i;
+	}
+	
+		
+}
+
+
+
+if(t<=1)
+{
+	keep=0;
+
+}
+else
+{
+	keep=1;
+}
+
+/////////////
+
+
+if(keep ==1 )
+{
+for(q=3;q<=q_max;q=q+2)
+{
+
+	for(i=0;i<Gx_num;i++)
+	{
+		Gx[i]=0;
+	}
+
+
+
+	for(i=0;i<=m_test;i++)
+	{
+		if((mx[q][i]!=1)&&(mx[q][i]!=0))
+		{
+			printf("error on mx ! \n");
+			return;
+		}
+		else if (mx[q][i]==1)
+		{
+			for(j=0;j<Gx_num;j++)
+			{
+				Gx[j+i]^=Gx_temp[j];
+			}
+
+
+		}
+		
+	}
+
+
+	for(i=0;i<Gx_num;i++)
+	{
+
+		Gx_temp[i]=Gx[i];
+		if(Gx[i]==1)
+		{
+
+			r=i;
+		}
+		
+			
+	}
+
+
+	if(q>=(2*t-1))
+	{
+		break;
+	}
+
+
+
+}
+}
+
+
+if(q>=(2*t-1))
+{
+//	printf("q=%d >= (2*t-1)=%d , t=%d \n",q,(2*t-1),t);
+
+}
+else
+{
+	printf("failed,q<(2*t-1) \n");
+	return;
+}
+
+d=2*t+1;
+
+n=(1<<m_test)-1;
+kk=n-r;
+
+
+
+
+#if 1
+
+
+
+for(j=0;j<3520;j++)
+{
+	for(ii=0;ii<530;ii++)
+	{
+	
+		Gx_record[j][ii]=0;
+	}
+}
+
+
+
+
+
+
+
+
+if(kk>=source_len)
+{
+//	printf("kk=%d  >= source_len=%d \n",kk,source_len);
+
+	for(i=0;i<source_len;i++)
+	{
+
+
+			if(i==0)
+			{
+			
+				for(j=0;j<Gx_num;j++)
+				{
+		
+					Gx_temp[j]=Gx[j];
+				}
+			
+			}
+
+			else if(Gx_temp[r-1]==1)
+			{
+				//Gx_b_temp= (0x1<<(r+i))| (((Gx_b_temp<<1) &((0x1<<r)-1))^ref_Gx);
+				Gx_temp[r+i]=1;
+				Gx_temp[r+i-1]=0;
+				for(j=(r-2);j>=0;j--)
+				{
+					Gx_temp[j+1]=Gx_temp[j];
+				}					
+				Gx_temp[0]=0;
+				
+				for(j=0;j<r;j++)
+				{
+		
+					Gx_temp[j]^=Gx[j];
+				}
+
+					
+			}
+			else
+			{
+ 					//Gx_b_temp= (0x1<<(r+i))| ((Gx_b_temp<<1) &((0x1<<r)-1));  	
+ 				Gx_temp[r+i]=1;
+				Gx_temp[r+i-1]=0;
+				for(j=(r-2);j>=0;j--)
+				{
+					Gx_temp[j+1]=Gx_temp[j];
+				}					
+				Gx_temp[0]=0;
+			}
+
+				for(j=0;j<r;j++)
+				{
+					Gx_record[i][j]=Gx_temp[j];
+				}
+				
+
+			
+
+	}
+	
+}
+else
+{
+	printf("error! kk must >= source_len.\n");
+	printf("kk=%d  , source_len=%d \n",kk,source_len);
+	return;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+input_file = fopen(input_str, "rb");
+if (!input_file) {
+		printf("Error opening file %s\n", input_str);
+		return;
+}
+
+
+output_file = fopen(output_str, "wb");
+if (!output_file) {
+		printf("Error opening file %s\n", output_str);
+		return;
+}
+
+
+
+fseek(input_file, 0L, SEEK_END);
+input_sz = ftell(input_file);
+fseek(input_file, 0L, SEEK_SET);
+
+
+
+
+
+
+for(ii=0;ii<input_sz;ii+=440){
+	//printf("i=%d\n",i);
+	fseek(input_file, ii, SEEK_SET);  
+
+
+	if(ii+440<=input_sz)
+	{
+		readlen=fread(input, 440, 1, input_file); 
+
+	}
+	else
+	{
+		readlen=fread(input, (input_sz-ii), 1, input_file); 
+		for (j = (input_sz-ii); j < 440; j++)
+		{
+			input[j]=0;
+		
+		}
+
+	}
+	
+
+
+	
+	byte2bit(440);
+
+	for (j = 0; j < 3520; j++)
+	{
+		source_temp[j]=data[j];
+
+	}
+/////////////////////////////////////////////////////////////////////////////////////////////////
+//come here
+
+
+
+
+for(j=0;j<sector_bits;j++)
+	{
+		Gx_temp[j]=0;
+		source_temp2[j]=0;
+		source_temp2_temp[j]=0;
+	}
+
+
+if(kk>=source_len)
+{
+//	printf("kk=%d  >= source_len=%d \n",kk,source_len);
+
+	for(i=0;i<source_len;i++)
+	{
+
+			if(source_temp[i])
+			{
+			
+				//message_temp = (message_temp ^ Gx_b_temp);
+				for(j=0;j<r;j++)
+				{
+					source_temp2_temp[j]^=Gx_record[i][j];
+				}
+
+				source_temp2_temp[r+i]=1;
+				
+			}
+			//printf("message_temp = 0x%x \n",message_temp);
+
+
+
+	}
+	
+}
+else
+{
+	printf("error! kk must >= source_len.\n");
+	printf("kk=%d  , source_len=%d \n",kk,source_len);
+	return;
+}
+
+
+
+for(j=0;j<source_len;j++)
+{
+	source_temp2[j]=source_temp2_temp[r+j];
+}
+for(j=source_len;j<(source_len+r);j++)
+{
+	source_temp2[j]=source_temp2_temp[j-source_len];
+}
+
+
+
+error_num=0;
+for(j=0;j<40;j++)
+{
+	error_pos[j]=0;
+}
+
+
+	error_num=0;
+
+
+if((error_num>0)&&(error_num<=40))
+{
+	for(j=0;j<error_num;j++)
+	{
+		scanf("%d", &error_pos[j]);
+
+	}
+
+	for(j=0;j<error_num;j++)
+	{
+		source_temp2[error_pos[j]]^=1;
+
+	}	
+	
+}
+else if (error_num >40)
+{
+	printf("error number must <= 40 \n");
+}
+
+
+
+
+
+for (i = 0; i < 4096; i++) 
+{
+	w_byte=i/8;
+	w_bit=i%8;
+	if(w_bit==0)
+	{
+		temp_w=0;
+	}
+	
+
+	temp_w|= ((source_temp2[i])&(0x1))<<(7-w_bit);	
+
+	if(w_bit==7)
+	{
+		output[w_byte]=temp_w;
+	}
+
+}
+
+
+
+
+
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+	fwrite(&output, 512, 1, output_file);
+ }		  
+
+
+fclose(input_file);
+fclose(output_file);
+
+
+
+#endif
+
+
+
+/////////////////////////////////
+
+#endif 
+
+}
+
+
+
+
+int main(int argc, char *argv[])
+{
+	int  i,j;
+
+    argv0 = argv[0];
+	input_str = argv[1];
+	output_str = argv[2];
+	argv3 = argv[3];
+	
+	t_value = strtoul(argv3,NULL,10);
+
+	Gx_gen();
+	return 0;
+}
+
diff --git a/board/grx500/bootstrap.lds b/board/grx500/bootstrap.lds
new file mode 100644
--- /dev/null
+++ b/board/grx500/bootstrap.lds
@@ -0,0 +1,72 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+OUTPUT_FORMAT("elf32-bigmips", "elf32-bigmips", "elf32-bigmips")
+*/
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+        . = 0x00000000;
+
+        . = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+        . = ALIGN(4);
+        .rodata  : { *(.rodata) }
+
+        . = ALIGN(4);
+        .data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	. = ALIGN(16);
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	. = .;
+        __u_boot_cmd_start = .;
+        .u_boot_cmd : { *(.u_boot_cmd) }
+        __u_boot_cmd_end = .;
+
+    . = ALIGN(4);
+	uboot_end_data = .;
+	got_size = (__got_end - __got_start);
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+  . = ALIGN(4);
+	.sbss  : { *(.sbss) }
+        .bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/grx500/build_asc_gphy.pl b/board/grx500/build_asc_gphy.pl
new file mode 100755
--- /dev/null
+++ b/board/grx500/build_asc_gphy.pl
@@ -0,0 +1,198 @@
+#!/usr/bin/perl
+my $aline;
+my $lineid;
+my $length;
+my $address;
+my @bytes;
+my $addstr;
+my $chsum=0;
+my $count=0;
+my $firstime=1;
+my $i;
+my $currentaddr;
+my $tmp;
+my $holder="";
+my $loadaddr;
+my $socmode;
+my $datastr;
+
+if(@ARGV < 5){
+	print "\n not enough arguments";
+	print "\n Syntax: ./build_asc_gphy.pl <ddr-config> <u-boot.bin> <u-boot-start-addr> <gphy-firmware> <gphy-firmware-addr> <output> <socmode>\n";
+}
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(GPHYFILE, "<$ARGV[3]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[5]") || die("\nOutput file open fail\n");
+$socmode = hex($ARGV[6]);
+
+binmode INFILE2;
+binmode GPHYFILE;
+
+$i=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+                  if($i eq 0){
+		  printf OUTFILE ("33333333");
+		  }
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  printf OUTFILE ("%08x%08x",hex($addr),hex($regval));
+                  $i=$i+1;
+		  if($i eq 8)
+		  {
+                      $i=0;
+		      printf OUTFILE ("\n");
+		  }
+
+               }
+             }
+
+	    }
+
+        while($i lt 8 && $i gt 0){
+            printf OUTFILE "00"x8;
+		    $i=$i+1;
+		}
+
+###################
+# u-boot-gphy.bin #
+###################
+
+$i=0;
+$addr=$ARGV[2];
+$addr=hex($addr);
+$loadaddr = sprintf("%x",$addr);
+
+while (read (INFILE2, $buffer, 4))
+{
+   if(($i % 16) eq 0)
+   {
+     printf OUTFILE ("\n%08x",$addr);
+	 $addrstr = sprintf("%08x", $addr);
+     addchsum($addrstr);
+     $addr+=0x40;
+   }
+   $i+=1;
+   $data=unpack("H*",$buffer);
+   $data=hex($data);
+   printf OUTFILE ("%08x",$data);
+   $datastr = sprintf("%08x", $data);
+   addchsum($datastr);
+}
+
+while ( ($i % 16) != 0 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+################
+# gphyfirmware #
+################
+
+$i=0;
+$addr=$ARGV[4];
+$addr=hex($addr);
+
+while (read (GPHYFILE, $buffer, 4))
+{
+   if(($i % 16) eq 0)
+   {
+     printf OUTFILE ("\n%08x",$addr);
+     $addrstr = sprintf("%08x", $addr);
+     addchsum($addrstr);
+     $addr+=0x40;
+   }
+   $i+=1;
+   $data=unpack("H*",$buffer);
+   $data=hex($data);
+   printf OUTFILE ("%08x",$data);
+   $datastr = sprintf("%08x", $data);
+   addchsum($datastr);
+}
+
+
+while ( ($i % 16) != 0 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+
+printf OUTFILE ("\n");
+
+
+##############
+# SOCMODE_IND
+##############
+print OUTFILE "55"x4;
+$socmode = sprintf("%08X", $socmode);
+print OUTFILE $socmode;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+
+##############
+# CHECKSUM_IND
+##############
+print OUTFILE "11"x4;
+use integer;
+$chsum=$chsum & 0xffffffff;
+$chsum = sprintf("%X", $chsum);
+$chsum = "0"x(8-length($chsum)).$chsum;
+$chsum =~tr/ABCDEF/abcdef/;
+print OUTFILE $chsum;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+##############
+# TERMINATING_ADDR
+##############
+print OUTFILE "99"x4;
+print OUTFILE $loadaddr;
+#print OUTFILE "00"x60;
+$i=0;
+if(($socmode eq "00000002") || ($socmode eq "00000001"))
+{
+   $datafile_size=(-s $ARGV[1]);
+   printf OUTFILE ("%08x",$datafile_size);
+   $i=1;
+}
+while ( $i < 15 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+
+close OUTFILE;
+#END of Program
+
+
+
+sub addchsum{
+	my $cc=$_[0];
+	$holder=$holder.$cc;
+	if(length($holder)==8){
+		$holder = hex($holder);
+		$chsum+=$holder;
+		$holder="";
+	}
+}
+#END
+
+
diff --git a/board/grx500/build_grx500_asc.pl b/board/grx500/build_grx500_asc.pl
new file mode 100755
--- /dev/null
+++ b/board/grx500/build_grx500_asc.pl
@@ -0,0 +1,140 @@
+#!/usr/bin/perl
+my $aline;
+my $lineid;
+my $length;
+my $address;
+my @bytes;
+my $addstr;
+my $chsum=0;
+my $count=0;
+my $firstime=1;
+my $i;
+my $currentaddr;
+my $tmp;
+my $holder="";
+my $loadaddr;
+
+if(@ARGV < 3){
+	print "\n not enough arguments";
+	print "\n Syntax: build_grx500_asc.pl ram.conf data.bin offset u-boot.asc socmode\n";
+    exit;
+}
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[3]") || die("\nOutput file open fail\n");
+$socmode = hex($ARGV[4]);
+
+
+binmode INFILE2;
+
+$i=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+                  if($i eq 0){
+		  printf OUTFILE ("33333333");
+		  }
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  printf OUTFILE ("%08x%08x",hex($addr),hex($regval));
+                  $i=$i+1;
+		  if($i eq 8)
+		  {
+                      $i=0;
+		      printf OUTFILE ("\n");
+		  }
+
+           }
+        }
+
+	    }
+
+        while($i lt 8 && $i gt 0){
+                   printf OUTFILE "00"x8;
+		   $i=$i+1;
+		   }
+
+$i=0;
+$addr=$ARGV[2];
+$addr=hex($addr);
+$chsum=0x0;
+
+while (read (INFILE2, $buffer, 4))
+{
+   if(($i % 16) eq 0)
+   {
+     printf OUTFILE ("\n%08x",$addr);
+	 $chsum+=$addr;
+	 $addr+=0x40;
+   }
+   $i+=1;
+   $data=unpack("H*",$buffer);
+   $data=hex($data);
+   printf OUTFILE ("%08x",$data);
+   $chsum+=$data;
+}
+
+while ( ($i % 16) != 0 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+
+
+##############
+# SOCMODE_IND
+##############
+print OUTFILE "\n";
+print OUTFILE "55"x4;
+$socmode = sprintf("%08X", $socmode);
+print OUTFILE $socmode;
+print OUTFILE "00"x60;
+
+###############
+# checksum now
+###############
+$chsum=$chsum & 0xffffffff;
+printf OUTFILE ("\n11111111");
+printf OUTFILE ("%08x",$chsum);
+$i=0;
+while ( $i < 15 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+
+
+printf OUTFILE ("\n99999999");
+
+printf OUTFILE ("%08x",hex($ARGV[2]));
+
+$i=0;
+if(($socmode eq "00000002") || ($socmode eq "00000001"))
+{
+   $datafile_size=(-s $ARGV[1]);
+   printf OUTFILE ("%08x",$datafile_size);
+   $i=1;
+}
+while ( $i < 15 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+
+printf OUTFILE ("\n");
+
+close(INFILE1);
+close(INFILE2);
+close(OUTFILE);
diff --git a/board/grx500/build_image.sh b/board/grx500/build_image.sh
new file mode 100755
--- /dev/null
+++ b/board/grx500/build_image.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+
+./mk_ltq_header.pl --ddr haps-ram.conf --bch 8 --col 2 --row 3 --blocksize 0x20000 --pagesize 0x800 --offset 0x800 --out header.ltq
+../../scripts_platform/pad2align.sh -n 1760 header.ltq
+gcc -o bch_enc bch_enc.c
+./bch_enc header.ltq header.bch 40
+../../scripts_platform/pad2align.sh -n 0x800 header.bch
+
+./mk_sf_image.pl -i chiptest.bin -o output.bin -j 0xa0400000 -m 0
+../../scripts_platform/pad2align.sh -n 440 output.bin
+./bch_enc output.bin output.bch 8
+
+cp header.bch image.bin
+cat output.bch >>image.bin
+
+
diff --git a/board/grx500/config.mk b/board/grx500/config.mk
new file mode 100644
--- /dev/null
+++ b/board/grx500/config.mk
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+-include $(TOPDIR)/.config
+
+MIPSFLAGS:=-march=r1004kc -mno-dsp -mno-mips3d  
+
+TEXT_BASE = $(CONFIG_RAM_TEXT_BASE)
+
diff --git a/board/grx500/gct_500.pl b/board/grx500/gct_500.pl
new file mode 100755
--- /dev/null
+++ b/board/grx500/gct_500.pl
@@ -0,0 +1,173 @@
+#!/usr/bin/perl
+my $aline;
+my $lineid;
+my $length;
+my $address;
+my @bytes;
+my $addstr;
+my $chsum=0;
+my $count=0;
+my $firstime=1;
+my $i;
+my $currentaddr;
+my $tmp;
+my $holder="";
+my $loadaddr;
+my $socmode;
+
+if(@ARGV < 4){
+	print "\n not enough arguments";
+	print "\n Syntax: ./gct_500.pl config input output socmode\n";
+}
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[2]") || die("\nOutput file open fail\n");
+$socmode = hex($ARGV[3]);
+
+$i=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+                  if($i eq 0){
+		  printf OUTFILE ("33333333");
+		  }
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  printf OUTFILE ("%08x%08x",hex($addr),hex($regval));
+                  $i=$i+1;
+		  if($i eq 8)
+		  {
+                      $i=0;
+		      printf OUTFILE ("\n");
+		  }
+
+               }
+             }
+
+	    }
+
+        while($i lt 8 && $i gt 0){
+                   printf OUTFILE "00"x8;
+		   $i=$i+1;
+		   }
+        if($i eq 8){
+	printf OUTFILE ("\n");
+        }
+
+while($aline=<INFILE2>){
+	$aline=uc($aline);
+	chomp($aline);
+	next if(($aline=~/^S0/) || ($aline=~/^S7/));
+	($lineid, $length, $address, @bytes) = unpack"A2A2A8"."A2"x300, $aline;
+	$length = hex($length);
+	$address = hex($address);
+	$length -=5;
+	$i=0;
+
+	while($length>0){
+		if($firstime==1){
+				$addstr = sprintf("%x", $address);
+				$addstr = "0"x(8-length($addstr)).$addstr;
+				print OUTFILE $addstr;
+				addchsum($addstr);
+				$firstime=0;
+				$currentaddr=$address;
+				$loadaddr = $addstr;
+		}
+		else{
+			if($count==64){
+				$addstr = sprintf("%x", $currentaddr);
+				$addstr = "0"x(8-length($addstr)).$addstr;
+				print OUTFILE $addstr;
+				addchsum($addstr);
+				$count=0;
+			}
+		}
+		while($count<64){
+		        $bytes[$i]=~tr/ABCDEF/abcdef/;
+			print OUTFILE "$bytes[$i]";
+			addchsum($bytes[$i]);
+			$i++;
+			$count++;
+			$length--;
+			last if($length==0);
+		}
+		if($count==64){
+			print OUTFILE "\n";
+			#print OUTFILE "\r";
+			$currentaddr+=64;
+		}
+	}
+}
+if($count != 64){
+	$tmp = "00";
+	for($i=0;$i<(64-$count);$i++){
+		print OUTFILE "00";
+		addchsum($tmp);
+	}
+	print OUTFILE "\n";
+	#print OUTFILE "\r";
+}
+
+##############
+# SOCMODE_IND
+##############
+print OUTFILE "55"x4;
+$socmode = sprintf("%08X", $socmode);
+print OUTFILE $socmode;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+
+##############
+# CHECKSUM_IND
+##############
+print OUTFILE "11"x4;
+use integer;
+$chsum=$chsum & 0xffffffff;
+$chsum = sprintf("%X", $chsum);
+$chsum = "0"x(8-length($chsum)).$chsum;
+$chsum =~tr/ABCDEF/abcdef/;
+print OUTFILE $chsum;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+##############
+# TERMINATING_ADDR
+##############
+print OUTFILE "99"x4;
+print OUTFILE $loadaddr;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+
+close OUTFILE;
+#END of Program
+
+
+
+sub addchsum{
+	my $cc=$_[0];
+	$holder=$holder.$cc;
+	if(length($holder)==8){
+		$holder = hex($holder);
+		$chsum+=$holder;
+		$holder="";
+	}
+}
+#END
+
+
diff --git a/board/grx500/gen_ddr.pl b/board/grx500/gen_ddr.pl
new file mode 100755
--- /dev/null
+++ b/board/grx500/gen_ddr.pl
@@ -0,0 +1,1910 @@
+#!/usr/bin/perl 
+use strict;
+use Getopt::Std;
+
+
+
+my $i=0;
+my $output="";
+my $DDR_TYPE=3;
+my $DDR_GRADE=7;
+my $DDR_DENSITY=10;
+my $DDR_BLEN=8;
+my $DDR_AL=1;
+my $endianval=1;
+
+my $A_CPS_F=2;
+my $A_Share_Link_F=8;
+my $A_NGI_TEP_F=6;
+my $A_CBM_F=3;
+my $B_CPS_F=1;
+my $B_DDR_Controller_F=5;
+my $B_GSWIP_L_F=5;
+my $B_GSWIP_RMII=6;
+
+
+
+
+
+
+
+#post silicon =2
+#haps=1
+#palladium =0
+my $platform=2;
+
+my @ddr2_chips = (1,2,1,2,1,2,1,2,1,2);
+my @ddr2_banks = (4,4,4,4,8,8,8,8,8,8);
+my @ddr2_rows  = (13,13,13,14,13,14,14,15,15,16);
+my @ddr2_cols  = (9,10,10,10,10,10,10,10,10,10);
+my @ddr2_pagesize = (1,1,2,1,2,1,2,1,2,1);
+my @ddr2_MM_SWAP0_H = (0x11634c,	0x117,	0x117,	0xd9,	0,	0,	0,	0,	0,	0);
+my @ddr2_MM_SWAP0_L = (0x016c420a,	0x0d30324b,	0x0d30324b,	0x0f30324b,	0x0461128b,	0x0369228b,	0x0369228b,	0x0271328b,	0x0271328b,	0x01428b);
+my @ddr2_freq = (200,0,266,0,333,333,400,400,0,533);
+my @ddr2_TFAW_CFG = (5,0,5,0,5,5,5,5,0,4);
+my @ddr2_TFAW_CFG_OFF = (0,0,1,0,3,3,2,2,0,0);
+my @ddr2_TCL = (3,0,4,0,4,5,5,6,0,7);
+my @ddr2_TWR = (3,0,4,0,5,5,6,6,0,8);
+my @ddr2_TRC = (11,0,16,0,19,20,23,24,0,31);
+my @ddr2_TRRD = (2,0,3,0,4,4,4,4,0,6);
+my @ddr2_TRAS = (8,0,12,0,15,15,18,18,0,24);
+my @ddr2_TRTP = (2,0,2,0,3,3,3,3,0,4);
+my @ddr2_TRFC = (66,0,88,0,109,109,131,131,0,175);
+my @ddr2_TFAW = (10,0,14,0,17,17,18,18,0,24);
+my @ddr2_TXP = (5,0,7,0,8,8,10,10,0,13);
+
+
+
+
+
+
+my @ddr3_chips = (0,0,1,2,1,2,1,2,1,2,1);
+my @ddr3_banks = (0,0,8,8,8,8,8,8,8,8,8);
+my @ddr3_rows  = (0,0,12,13,13,14,14,15,15,16,16);
+my @ddr3_cols  = (0,0,10,10,10,10,10,10,10,10,10);
+my @ddr3_pagesize = (0,0,2,1,2,1,2,1,2,1,2);
+my @ddr3_MM_SWAP0_H = (0,0,0,0,0,0,0,0,0,0,0);
+my @ddr3_MM_SWAP0_L = (0,0,0x0559028b,	0x0461128b,	0x0461128b,	0x0369228b,	0x0369228b,	0x0271328b,	0x0271328b,	0x01428b,	0x01428b);
+my @ddr3_freq = (400,400,533,533,533,667,667,667,800,800,800);
+my @ddr3_TFAW_CFG = (5,5,5,5,5,6,6,6,6,6,6);
+my @ddr3_TFAW_CFG_OFF = (0,0,3,3,3,0,0,0,1,1,1);
+my @ddr3_TCL = (5,6,6,7,8,8,9,10,9,10,11);
+my @ddr3_TWR = (6,6,8,8,8,10,10,10,12,12,12);
+my @ddr3_TRC = (20,21,26,27,28,32,33,34,37,38,39);
+my @ddr3_TRRD = (4,4,6,6,6,5,5,5,6,6,6);
+my @ddr3_TRAS = (15,15,20,20,20,24,24,24,28,28,28);
+my @ddr3_TRTP = (4,4,5,5,5,5,5,5,6,6,6);
+my @ddr3_TRFC = (140,140,187,187,187,234,234,234,280,280,280);
+my @ddr3_TFAW = (20,20,27,27,27,30,30,30,32,32,32);
+my @ddr3_TXS = (144,144,193,193,193,240,240,240,288,288,288);
+my @ddr3_TXP = (10,10,13,13,13,16,16,16,20,20,20);
+
+
+
+
+sub usage()
+{
+   print "gen_ddr.pl -[options]\n";
+   print "   -t  type          ddr type 2/3\n";
+   	print "\t 2 ddr2\n";
+   	print "\t 3 ddr3\n";
+   print "   -g  grade         ddr grade\n";
+    print "	\t ddr2grade	# \n";
+    print "	\t 200MHz @ CL=3	0\n";
+    print "	\t 266MHz @ CL=4	2\n";
+    print "	\t 333MHz @ CL=4	4\n";
+    print "	\t 333MHz @ CL=5	5\n";
+    print "	\t 400MHz @ CL=5	6\n";
+    print "	\t 400MHz @ CL=6	7\n";
+    print "	\t 533MHz @ CL=7	9\n";
+
+    print "	\t ddr3grade	#\n";
+    print "	\t 400MHz @ CL=5	0\n";
+    print "	\t 400MHz @ CL=6	1\n";
+    print "	\t 533MHz @ CL=6	2\n";
+    print "	\t 533MHz @ CL=7	3\n";
+    print "	\t 533MHz @ CL=8	4\n";
+    print "	\t 667MHz @ CL=8	5\n";
+    print "	\t 667MHz @ CL=9	6\n";
+    print "	\t 667MHz @ CL=10	7\n";
+    print "	\t 800MHz @ CL=9	8\n";
+    print "	\t 800MHz @ CL=10	9\n";
+    print "	\t 800MHz @ CL=11	10\n";
+	
+     
+   print "   -d  density       ddr density\n";
+
+    print "	\t dd2density	#\n";
+    print "	\t 16Mx16		0\n";
+    print "	\t 32Mx8		1\n";
+    print "	\t 32Mx16		2\n";
+    print "	\t 64Mx8		3\n";
+    print "	\t 64Mx16		4\n";
+    print "	\t 128Mx8		5\n";
+    print "	\t 128Mx16	6\n";
+    print "	\t 256Mx8		7\n";
+    print "	\t 256Mx16	8\n";
+    print "	\t 512Mx8		9\n";
+
+    print "	\t dd3density	#\n";
+    print "	\t 32Mx16		2\n";
+    print "	\t 64Mx8		3\n";
+    print "	\t 64Mx16		4\n";
+    print "	\t 128Mx8		5\n";
+    print "	\t 128Mx16	6\n";
+    print "	\t 256Mx8		7\n";
+    print "	\t 256Mx16	8\n";
+    print "	\t 512Mx8		9\n";
+    print "	\t 512Mx16	10\n";
+
+
+   
+   print "   -b  length        burst length\n";
+    print "	\t BL4	4\n";
+    print "	\t BL8	8\n";
+
+
+
+   print "   -l  latency       additive latency\n";
+    print "	\t ddr2 	#\n";
+    print "	\t AL=0	0\n";
+    print "	\t AL=1	1\n";
+    print "	\t AL=2	2\n";
+    print "	\t AL=3	3\n";
+    print "	\t AL=4	4\n";
+    print "	\t AL=5	5\n";
+    print "	\t AL=6	6\n";
+
+    print "	\t ddr3 	#\n";
+    print "	\t N0 AL	0\n";
+    print "	\t CL-1	1\n";
+    print "	\t CL-2	2\n";
+
+
+   
+   print "   -e  endian        endianness(B/L)\n";
+    print "	\t Little Endian	0\n";
+    print "	\t Big Endian	1\n";
+
+      
+      
+   print "   -o  output        output file\n"; 
+   print "   -h                help information\n";
+
+   print "\n\t|--------------------------------------|\n";
+   print "\t|---------- PLL0A Settings ------------|\n";
+   print "\t|--------------------------------------|\n";
+   print "   -cps              PLL0A CK4 - CPS    \n";
+   print "   -share            PLL0A CK3 - Share Link    \n";
+   print "   -ngi              PLL0A CK2 - NGI/TEP    \n";
+   print "   -cbm              PLL0A CK1 - CBM     \n";
+
+   print "\t   Frequency settings for all pll0a configurations	#   \n";
+   print "\t   2400MHz	0   \n";
+   print "\t   1200MHz	1   \n";
+   print "\t   800MHz	2   \n";
+   print "\t   600MHz	3   \n";
+   print "\t   480MHz	4   \n";
+   print "\t   400MHz	5   \n";
+   print "\t   300MHz	6   \n";
+   print "\t   240MHz	7   \n";
+   print "\t   200MHz	8   \n";
+   print "\t   150MHz	9   \n";
+   print "\t   120MHz	10   \n";
+   print "\t   100MHz	11   \n";
+   print "\t   75MHz	12   \n";
+   print "\t   60MHz	13   \n";
+   print "\t   50MHz	14   \n";
+   print "\t   37.5MHz	15   \n";
+   
+
+   print "\n\t|--------------------------------------|\n";
+   print "\t|---------- PLL0B Settings ------------|\n";
+   print "\t|--------------------------------------|\n";
+   print "   -bc            PLL0B CK4 - CPS    \n";
+   print "   -bd            PLL0B CK3 - DDR Controller    \n";
+   print "   -bg            PLL0B CK2 - GSWIP-L    \n";
+   print "   -bgr           PLL0B CK1 - GSWIP-R/MII     \n";
+   
+   print "\t    Frequency settings for all pll0b	configurations	#   \n";
+   print "\t    2000MHz	0   \n";
+   print "\t    1000MHz	1   \n";
+   print "\t    666MHz	2   \n";
+   print "\t    500MHz	3   \n";
+   print "\t    400MHz	4   \n";
+   print "\t    333MHz	5   \n";
+   print "\t    250MHz	6   \n";
+   print "\t    200MHz	7   \n";
+   print "\t    166MHz	8   \n";
+   print "\t    125MHz	9   \n";
+   print "\t    100MHz	10   \n";
+   print "\t    83MHz	11   \n";
+   print "\t    62.5MHz	12   \n";
+   print "\t    50MHz	13   \n";
+   print "\t    41.6MHz	14   \n";
+   print "\t    51.25MHz	15   \n";
+
+   exit;
+}
+
+
+
+
+# declare the perl command line flags/options we want to allow
+my %options=();
+getopts("t:g:d:b:a:e:o:h:c:s:n:m:p:k:l:r:", \%options);
+
+usage() if $options{h};
+
+
+$output=$options{o} if defined $options{o};
+$DDR_TYPE=$options{t} if defined $options{t};
+$DDR_GRADE=$options{g} if defined $options{g};
+$DDR_DENSITY=$options{d} if defined $options{d};
+$DDR_BLEN=$options{b} if defined $options{b};
+$DDR_AL=$options{a} if defined $options{a};
+$endianval=$options{e} if defined $options{e};
+
+#PLL0A_CFG1
+$A_CPS_F=$options{c} if defined $options{c};
+$A_Share_Link_F=$options{s} if defined $options{s};
+$A_NGI_TEP_F=$options{n} if defined $options{n};
+$A_CBM_F=$options{m} if defined $options{m};
+
+#PLL0B_CFG1
+$B_CPS_F=$options{p} if defined $options{p};
+$B_DDR_Controller_F=$options{k} if defined $options{k};
+$B_GSWIP_L_F=$options{l} if defined $options{l};
+$B_GSWIP_RMII=$options{r} if defined $options{r};
+
+
+
+
+if($output eq ''){
+   print "no output file specified!\n";
+   usage();
+}
+
+if ($DDR_TYPE=~/2|DDR2|ddr2/){
+   $DDR_TYPE=2;
+
+	if ($DDR_GRADE=~/0|2|4|5|6|7|9/)
+	{
+
+	}
+	else
+	{
+	print "parameters are invalid.\n";
+   	print "   -g  grade         ddr grade\n";
+    print "	\t ddr2grade	# \n";
+    print "	\t 200MHz @ CL=3	0\n";
+    print "	\t 266MHz @ CL=4	2\n";
+    print "	\t 333MHz @ CL=4	4\n";
+    print "	\t 333MHz @ CL=5	5\n";
+    print "	\t 400MHz @ CL=5	6\n";
+    print "	\t 400MHz @ CL=6	7\n";
+    print "	\t 533MHz @ CL=7	9\n";
+    exit;
+	}
+
+	if ($DDR_DENSITY=~/0|1|2|3|4|5|6|7|8|9/)
+	{
+
+	}
+	else
+	{
+   print "   -d  density       ddr density\n";
+
+    print "	\t dd2density	#\n";
+    print "	\t 16Mx16		0\n";
+    print "	\t 32Mx8		1\n";
+    print "	\t 32Mx16		2\n";
+    print "	\t 64Mx8		3\n";
+    print "	\t 64Mx16		4\n";
+    print "	\t 128Mx8		5\n";
+    print "	\t 128Mx16	6\n";
+    print "	\t 256Mx8		7\n";
+    print "	\t 256Mx16	8\n";
+    print "	\t 512Mx8		9\n";
+
+    exit;
+	}
+
+
+	if ($DDR_BLEN=~/4|8/)
+	{
+
+	}
+	else
+	{
+   print "   -b  length        burst length\n";
+    print "	\t BL4	4\n";
+    print "	\t BL8	8\n";
+    exit;
+	}
+
+
+	if ($DDR_AL=~/0|1|2|3|4|5|6/)
+	{
+
+	}
+	else
+	{
+   print "   -a  latency       additive latency\n";
+    print "	\t ddr2 	#\n";
+    print "	\t AL=0	0\n";
+    print "	\t AL=1	1\n";
+    print "	\t AL=2	2\n";
+    print "	\t AL=3	3\n";
+    print "	\t AL=4	4\n";
+    print "	\t AL=5	5\n";
+    print "	\t AL=6	6\n";
+
+
+    exit;
+	}
+
+
+	if ($endianval=~/0|1/)
+	{
+
+	}
+	else
+	{
+   print "   -e  endian        endianness(B/L)\n";
+    print "	\t Little Endian	0\n";
+    print "	\t Big Endian	1\n";
+
+    exit;
+	}
+
+}elsif ($DDR_TYPE=~/3|DDR3|ddr3/){
+   $DDR_TYPE=3;
+
+	if ($DDR_GRADE=~/0|1|2|3|4|5|6|7|8|9|10/)
+	{
+
+	}
+	else
+	{
+	print "parameters are invalid.\n";
+   	print "   -g  grade         ddr grade\n";
+    print "	\t ddr3grade	#\n";
+    print "	\t 400MHz @ CL=5	0\n";
+    print "	\t 400MHz @ CL=6	1\n";
+    print "	\t 533MHz @ CL=6	2\n";
+    print "	\t 533MHz @ CL=7	3\n";
+    print "	\t 533MHz @ CL=8	4\n";
+    print "	\t 667MHz @ CL=8	5\n";
+    print "	\t 667MHz @ CL=9	6\n";
+    print "	\t 667MHz @ CL=10	7\n";
+    print "	\t 800MHz @ CL=9	8\n";
+    print "	\t 800MHz @ CL=10	9\n";
+    print "	\t 800MHz @ CL=11	10\n";
+    exit;
+	}
+
+	if ($DDR_DENSITY=~/2|3|4|5|6|7|8|9|10/)
+	{
+
+	}
+	else
+	{
+   print "   -d  density       ddr density\n";
+    print "	\t dd3density	#\n";
+    print "	\t 32Mx16		2\n";
+    print "	\t 64Mx8		3\n";
+    print "	\t 64Mx16		4\n";
+    print "	\t 128Mx8		5\n";
+    print "	\t 128Mx16	6\n";
+    print "	\t 256Mx8		7\n";
+    print "	\t 256Mx16	8\n";
+    print "	\t 512Mx8		9\n";
+    print "	\t 512Mx16	10\n";
+
+
+    exit;
+	}
+
+	if ($DDR_BLEN=~/4|8/)
+	{
+
+	}
+	else
+	{
+   print "   -b  length        burst length\n";
+    print "	\t BL4	4\n";
+    print "	\t BL8	8\n";
+    exit;
+	}
+
+	if ($DDR_AL=~/0|1|2/)
+	{
+
+	}
+	else
+	{
+   print "   -a  latency       additive latency\n";
+    print "	\t ddr3 	#\n";
+    print "	\t N0 AL	0\n";
+    print "	\t CL-1	1\n";
+    print "	\t CL-2	2\n";
+
+    exit;
+	}
+
+	if ($endianval=~/0|1/)
+	{
+
+	}
+	else
+	{
+   print "   -e  endian        endianness(B/L)\n";
+    print "	\t Little Endian	0\n";
+    print "	\t Big Endian	1\n";
+
+    exit;
+	}
+
+
+   
+}else{
+   usage();
+   exit;
+}
+
+	if ($A_CPS_F=~/0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15/)
+	{
+
+	}
+	else
+	{
+   		print "  -c should be within range of 0 to 15.\n";
+		print " \t 2400Mhz		0\n";
+		print " \t 1200Mhz		1\n";
+		print " \t 800Mhz		2\n";
+		print " \t 600Mhz		3\n";
+		print " \t 480Mhz		5\n";
+		print " \t 400Mhz		5\n";
+		print " \t 300Mhz		6\n";
+		print " \t 240Mhz		7\n";
+		print " \t 200Mhz		8\n";
+		print " \t 150hz		9\n";
+		print " \t 120hz		10\n";
+		print " \t 100Mhz		11\n";
+		print " \t 75Mhz		12\n";
+		print " \t 60Mhz		13\n";
+		print " \t 50Mhz		14\n";
+   		print " \t 37Mhz		15\n";
+
+    exit;
+	}
+
+	if ($A_Share_Link_F=~/0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15/)
+	{
+
+	}
+	else
+	{
+   		print "  -s should be within range of 0 to 15.\n";
+		print " \t 2400Mhz		0\n";
+		print " \t 1200Mhz		1\n";
+		print " \t 800Mhz		2\n";
+		print " \t 600Mhz		3\n";
+		print " \t 480Mhz		5\n";
+		print " \t 400Mhz		5\n";
+		print " \t 300Mhz		6\n";
+		print " \t 240Mhz		7\n";
+		print " \t 200Mhz		8\n";
+		print " \t 150hz		9\n";
+		print " \t 120hz		10\n";
+		print " \t 100Mhz		11\n";
+		print " \t 75Mhz		12\n";
+		print " \t 60Mhz		13\n";
+		print " \t 50Mhz		14\n";
+   		print " \t 37Mhz		15\n";
+
+    exit;
+	}
+
+	if ($A_NGI_TEP_F=~/0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15/)
+	{
+
+	}
+	else
+	{
+   		print "  -n should be within range of 0 to 15.\n";
+		print " \t 2400Mhz		0\n";
+		print " \t 1200Mhz		1\n";
+		print " \t 800Mhz		2\n";
+		print " \t 600Mhz		3\n";
+		print " \t 480Mhz		5\n";
+		print " \t 400Mhz		5\n";
+		print " \t 300Mhz		6\n";
+		print " \t 240Mhz		7\n";
+		print " \t 200Mhz		8\n";
+		print " \t 150hz		9\n";
+		print " \t 120hz		10\n";
+		print " \t 100Mhz		11\n";
+		print " \t 75Mhz		12\n";
+		print " \t 60Mhz		13\n";
+		print " \t 50Mhz		14\n";
+   		print " \t 37Mhz		15\n";
+
+    exit;
+	}
+
+	if ($A_CBM_F=~/0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15/)
+	{
+
+	}
+	else
+	{
+   		print "  -m should be within range of 0 to 15.\n";
+		print " \t 2400Mhz		0\n";
+		print " \t 1200Mhz		1\n";
+		print " \t 800Mhz		2\n";
+		print " \t 600Mhz		3\n";
+		print " \t 480Mhz		5\n";
+		print " \t 400Mhz		5\n";
+		print " \t 300Mhz		6\n";
+		print " \t 240Mhz		7\n";
+		print " \t 200Mhz		8\n";
+		print " \t 150hz		9\n";
+		print " \t 120hz		10\n";
+		print " \t 100Mhz		11\n";
+		print " \t 75Mhz		12\n";
+		print " \t 60Mhz		13\n";
+		print " \t 50Mhz		14\n";
+   		print " \t 37Mhz		15\n";
+
+    exit;
+	}
+
+	if ($B_CPS_F=~/0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15/)
+	{
+
+	}
+	else
+	{
+   		print "  -p should be within range of 0 to 15.\n";
+		print " \t 2000Mhz		0\n";
+		print " \t 1000Mhz		1\n";
+		print " \t 666Mhz		2\n";
+		print " \t 500Mhz		3\n";
+		print " \t 400Mhz		5\n";
+		print " \t 333Mhz		5\n";
+		print " \t 250Mhz		6\n";
+		print " \t 200Mhz		7\n";
+		print " \t 166Mhz		8\n";
+		print " \t 125hz		9\n";
+		print " \t 100hz		10\n";
+		print " \t 83Mhz		11\n";
+		print " \t 62.5Mhz		12\n";
+		print " \t 50Mhz		13\n";
+		print " \t 41.6Mhz		14\n";
+   		print " \t 51.25Mhz		15\n";
+
+    exit;
+	}
+
+	if ($B_DDR_Controller_F=~/0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15/)
+	{
+
+	}
+	else
+	{
+   		print "  -k should be within range of 0 to 15.\n";
+		print " \t 2000Mhz		0\n";
+		print " \t 1000Mhz		1\n";
+		print " \t 666Mhz		2\n";
+		print " \t 500Mhz		3\n";
+		print " \t 400Mhz		5\n";
+		print " \t 333Mhz		5\n";
+		print " \t 250Mhz		6\n";
+		print " \t 200Mhz		7\n";
+		print " \t 166Mhz		8\n";
+		print " \t 125hz		9\n";
+		print " \t 100hz		10\n";
+		print " \t 83Mhz		11\n";
+		print " \t 62.5Mhz		12\n";
+		print " \t 50Mhz		13\n";
+		print " \t 41.6Mhz		14\n";
+   		print " \t 51.25Mhz		15\n";
+
+    exit;
+	}
+
+	if ($B_GSWIP_L_F=~/0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15/)
+	{
+
+	}
+	else
+	{
+   		print "  -l should be within range of 0 to 15.\n";
+		print " \t 2000Mhz		0\n";
+		print " \t 1000Mhz		1\n";
+		print " \t 666Mhz		2\n";
+		print " \t 500Mhz		3\n";
+		print " \t 400Mhz		5\n";
+		print " \t 333Mhz		5\n";
+		print " \t 250Mhz		6\n";
+		print " \t 200Mhz		7\n";
+		print " \t 166Mhz		8\n";
+		print " \t 125hz		9\n";
+		print " \t 100hz		10\n";
+		print " \t 83Mhz		11\n";
+		print " \t 62.5Mhz		12\n";
+		print " \t 50Mhz		13\n";
+		print " \t 41.6Mhz		14\n";
+   		print " \t 51.25Mhz		15\n";
+
+    exit;
+	}
+
+	if ($B_GSWIP_RMII=~/0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15/)
+	{
+
+	}
+	else
+	{
+   		print "  -r should be within range of 0 to 15.\n";
+		print " \t 2000Mhz		0\n";
+		print " \t 1000Mhz		1\n";
+		print " \t 666Mhz		2\n";
+		print " \t 500Mhz		3\n";
+		print " \t 400Mhz		5\n";
+		print " \t 333Mhz		5\n";
+		print " \t 250Mhz		6\n";
+		print " \t 200Mhz		7\n";
+		print " \t 166Mhz		8\n";
+		print " \t 125hz		9\n";
+		print " \t 100hz		10\n";
+		print " \t 83Mhz		11\n";
+		print " \t 62.5Mhz		12\n";
+		print " \t 50Mhz		13\n";
+		print " \t 41.6Mhz		14\n";
+   		print " \t 51.25Mhz		15\n";
+
+    exit;
+	}
+
+sub get_DDR_TFAW_CFG_OFF {
+	if ($DDR_TYPE==2) {
+		if ($DDR_GRADE < 2) {
+			return (($DDR_DENSITY<2)?2:(($DDR_DENSITY%2)==0)?0:2);
+		}
+		elsif ($DDR_GRADE < 4) {
+			return (($DDR_DENSITY<2)?0:(($DDR_DENSITY%2)==0)?1:0);
+		}
+		elsif ($DDR_GRADE < 6) {
+			return (($DDR_DENSITY<2)?2:(($DDR_DENSITY%2)==0)?3:2);
+		}
+		elsif ($DDR_GRADE < 8) {
+			return (($DDR_DENSITY<2)?1:(($DDR_DENSITY%2)==0)?2:1);
+		}
+		else {
+			return (($DDR_DENSITY<2)?1:(($DDR_DENSITY%2)==0)?0:1);
+		}
+	} else {
+		if ($DDR_GRADE < 2) {
+			return 0;
+		}
+		elsif ($DDR_GRADE < 5) {
+			return (($DDR_DENSITY>9)?3:(($DDR_DENSITY%2)==0)?3:0);
+		}
+		elsif ($DDR_GRADE < 8) {
+			return 0;
+		}
+		else {
+			return (($DDR_DENSITY>9)?4:(($DDR_DENSITY%2)==0)?4:1);
+		}
+	}
+}
+
+sub get_TRRD {
+	if ($DDR_TYPE==2) {
+		if ($DDR_GRADE < 2) {
+			return 2;
+		} 
+		elsif ($DDR_GRADE < 4) {
+			return (($DDR_DENSITY<2)?2:(($DDR_DENSITY%2)==0)?3:2);
+		}
+		elsif ($DDR_GRADE < 6) {
+			return (($DDR_DENSITY<2)?3:(($DDR_DENSITY%2)==0)?4:3);
+		}
+		elsif ($DDR_GRADE < 8) {
+			return (($DDR_DENSITY<2)?3:(($DDR_DENSITY%2)==0)?4:3);
+		} 
+		else {
+			return (($DDR_DENSITY<2)?4:(($DDR_DENSITY%2)==0)?6:4);
+		}
+	} 
+	else {
+		if ($DDR_GRADE < 2) {
+			return 4;
+		}
+		elsif ($DDR_GRADE < 5) {
+			return (($DDR_DENSITY>9)?6:(($DDR_DENSITY%2)==0)?6:4);
+		}
+		elsif ($DDR_GRADE < 8) {
+			return (($DDR_DENSITY>9)?5:(($DDR_DENSITY%2)==0)?5:4);
+		}
+		else {
+			return (($DDR_DENSITY>9)?6:(($DDR_DENSITY%2)==0)?6:5);
+		}
+	}
+}
+
+sub get_TRFC {
+	if ($DDR_TYPE==2) {
+		if ($DDR_GRADE < 2) {
+			return (($DDR_DENSITY<2)?15:(($DDR_DENSITY<4)?21:(($DDR_DENSITY<6)?26:(($DDR_DENSITY<8)?39:66))));
+		}
+		elsif ($DDR_GRADE < 4) {
+			return (($DDR_DENSITY<2)?20:(($DDR_DENSITY<4)?28:(($DDR_DENSITY<6)?34:(($DDR_DENSITY<8)?52:88))));
+		}
+		elsif ($DDR_GRADE < 6) {
+			return (($DDR_DENSITY<2)?25:(($DDR_DENSITY<4)?35:(($DDR_DENSITY<6)?43:(($DDR_DENSITY<8)?65:109))));
+		}
+		elsif ($DDR_GRADE < 8) {
+			return (($DDR_DENSITY<2)?30:(($DDR_DENSITY<4)?42:(($DDR_DENSITY<6)?51:(($DDR_DENSITY<8)?78:131))));
+		}
+		else {
+			return (($DDR_DENSITY<2)?40:(($DDR_DENSITY<4)?57:(($DDR_DENSITY<6)?68:(($DDR_DENSITY<8)?102:175))));
+		}
+	} 
+	else {
+		if ($DDR_GRADE < 2) {
+			return (($DDR_DENSITY<4)?36:(($DDR_DENSITY<6)?44:(($DDR_DENSITY<8)?64:(($DDR_DENSITY<10)?104:140))));
+		}
+		elsif ($DDR_GRADE < 5) {
+			return (($DDR_DENSITY<4)?48:(($DDR_DENSITY<6)?59:(($DDR_DENSITY<8)?86:(($DDR_DENSITY<10)?139:187))));
+		}
+		elsif ($DDR_GRADE < 8) {
+			return (($DDR_DENSITY<4)?60:(($DDR_DENSITY<6)?74:(($DDR_DENSITY<8)?107:(($DDR_DENSITY<10)?174:234))));
+		}
+		else {
+			return (($DDR_DENSITY<4)?72:(($DDR_DENSITY<6)?88:(($DDR_DENSITY<8)?128:(($DDR_DENSITY<10)?208:280))));
+		}
+	}
+}
+
+sub get_TFAW {
+	if ($DDR_TYPE==2) {
+		if ($DDR_GRADE < 2) {
+			return (($DDR_DENSITY<2)?8:(($DDR_DENSITY%2)==0)?10:8);
+		}
+		elsif ($DDR_GRADE < 4) {
+			return (($DDR_DENSITY<2)?10:(($DDR_DENSITY%2)==0)?14:10);
+		}
+		elsif ($DDR_GRADE < 6) {
+			return (($DDR_DENSITY<2)?13:(($DDR_DENSITY%2)==0)?17:13);
+		}
+		elsif ($DDR_GRADE < 8) {
+			return (($DDR_DENSITY<2)?14:(($DDR_DENSITY%2)==0)?18:14);
+		}
+		else {
+			return (($DDR_DENSITY<2)?19:(($DDR_DENSITY%2)==0)?24:19);
+		}
+	} 
+	else {
+		if ($DDR_GRADE < 2) {
+			return ((($DDR_DENSITY%2)==0)?20:16);
+		}
+		elsif ($DDR_GRADE < 5) {
+			return (($DDR_DENSITY>9)?27:(($DDR_DENSITY%2)==0)?27:20);
+		}
+		elsif ($DDR_GRADE < 8) {
+			return (($DDR_DENSITY>9)?30:(($DDR_DENSITY%2)==0)?30:20);
+		}
+		else {
+			return (($DDR_DENSITY>9)?32:(($DDR_DENSITY%2)==0)?32:24);
+		}
+	}
+}
+
+sub get_DDR_TXS {
+	if ($DDR_TYPE==2) {
+		return 200;
+	} 
+	else {
+		if ($DDR_GRADE < 2) {
+			return (($DDR_DENSITY<4)?40:($DDR_DENSITY<6)?48:($DDR_DENSITY<8)?68:($DDR_DENSITY<10)?108:144);
+		}
+		elsif ($DDR_GRADE < 5) {
+			return (($DDR_DENSITY<4)?54:($DDR_DENSITY<6)?65:($DDR_DENSITY<8)?72:($DDR_DENSITY<10)?145:193);
+		}
+		elsif ($DDR_GRADE < 8) {
+			return (($DDR_DENSITY<4)?66:($DDR_DENSITY<6)?80:($DDR_DENSITY<8)?113:($DDR_DENSITY<10)?180:240);
+		}
+		else {
+			return (($DDR_DENSITY<4)?80:($DDR_DENSITY<6)?96:($DDR_DENSITY<8)?136:($DDR_DENSITY<10)?216:288);
+		}
+	}
+}
+
+my $DDR2_TFAW_CFG=(($DDR_GRADE<8)?5:(($DDR_DENSITY<2)?5:((($DDR_DENSITY % 2)==0)?4:5)));
+my $DDR3_TFAW_CFG=(($DDR_GRADE<3)?((($DDR_DENSITY%2)==0)?5:4):(($DDR_GRADE<5)?5:(($DDR_DENSITY>9)?6:((($DDR_DENSITY%2)==0)?6:5))));
+
+my $chip=($DDR_TYPE==2)?$ddr2_chips[$DDR_DENSITY]:$ddr3_chips[$DDR_DENSITY];
+my $DDR_BANKSZ=($DDR_TYPE==2)?$ddr2_banks[$DDR_DENSITY]:$ddr3_banks[$DDR_DENSITY];
+my $ddr_freq=($DDR_TYPE==2)?$ddr2_freq[$DDR_GRADE]:$ddr3_freq[$DDR_GRADE];
+my $ddr_period=1000/$ddr_freq;
+
+
+my $DDR_TINIT =($platform==2)?200:1;
+my $DDR_TFAW_CFG=($DDR_TYPE==2)?$DDR2_TFAW_CFG:$DDR3_TFAW_CFG;
+my $DDR_TFAW_CFG_OFF=get_DDR_TFAW_CFG_OFF();
+my $DDR_TCL=($DDR_TYPE==2)?$ddr2_TCL[$DDR_GRADE]:$ddr3_TCL[$DDR_GRADE];
+my $DDR_TWR=($DDR_TYPE==2)?$ddr2_TWR[$DDR_GRADE]:$ddr3_TWR[$DDR_GRADE];
+my $DDR_TCWL=($DDR_TYPE==2)?($DDR_TCL-1):(($DDR_GRADE<2)?(5):(($DDR_GRADE<5)?(6):(($DDR_GRADE<8)?(7):(8))));
+my $DDR_TRC=($DDR_TYPE==2)?$ddr2_TRC[$DDR_GRADE]:$ddr3_TRC[$DDR_GRADE];
+my $DDR_TRRD=get_TRRD();
+my $DDR_TRAS=($DDR_TYPE==2)?$ddr2_TRAS[$DDR_GRADE]:$ddr3_TRAS[$DDR_GRADE];
+my $DDR_TRTP=($DDR_TYPE==2)?$ddr2_TRTP[$DDR_GRADE]:$ddr3_TRTP[$DDR_GRADE];
+my $DDR_TWLO=($DDR_TYPE==2)?0:8;
+my $DDR_TWLMRD=($DDR_TYPE==2)?0:40;
+my $DDR_TRFC=get_TRFC();
+my $DDR_TFAW=get_TFAW();
+my $DDR_TMOD=($DDR_TYPE==2)?0:12;
+my $DDR_TMRD=($DDR_TYPE==2)?2:4;
+my $DDR_TCKE=($DDR_TYPE==2)?3:(($DDR_GRADE<2)?3:(($DDR_GRADE<5)?4:(($DDR_GRADE<8)?4:4)));
+my $DDR_TXP=($DDR_TYPE==2)?2:(($DDR_GRADE<2)?3:(($DDR_GRADE<5)?5:(($DDR_GRADE<8)?4:5)));
+my $DDR_TXS=get_DDR_TXS();
+my $DDR_TREFPRD=int(9*7800/$ddr_period);
+my $DDR_TPLLPD=($DDR_TYPE==2)?(($DDR_GRADE<2)?100:($DDR_GRADE<4)?133:($DDR_GRADE<6)?167:($DDR_GRADE<8)?200:266):(($DDR_GRADE<2)?200:($DDR_GRADE<5)?266:($DDR_GRADE<8)?333:400);
+my $DDR_TPLLGS=$DDR_TPLLPD*4;
+my $DDR_TPLLRST=3*($DDR_TPLLPD);
+my $DDR_TPLLLOCK=100*($DDR_TPLLPD);
+my $DDR_TCKSRE=($DDR_TYPE==2)?0:(($DDR_GRADE<2)?5:(($DDR_GRADE<5)?6:(($DDR_GRADE<8)?7:8)));
+my $DDR_TAL=($DDR_TYPE==2)?$DDR_AL:(($DDR_AL>0)?($DDR_TCL-$DDR_AL):0);
+my $DDR_MR0=($DDR_TYPE==2)?((($DDR_BLEN==8)?3:2)+$DDR_TCL*16+($DDR_TWR-1)*512+256):  ((($DDR_BLEN==8)?0:(($DDR_BLEN==4)?0:1))+(($DDR_TCL<=11)?(($DDR_TCL-4)*16):(($DDR_TCL-11)*16+4))+256+ (($DDR_TWR<=8)?(($DDR_TWR-4)*512):(($DDR_TWR/2)*512)));
+my $DDR_MR1=(($DDR_TYPE==2)?(($DDR_GRADE<6)?($DDR_AL*8+0x4):($DDR_AL*8+0x40)):(($DDR_GRADE<8)?($DDR_AL*8+0x46):($DDR_AL*8+0x44)));
+my $DDR_MR2=($DDR_TYPE==2)?0:(($DDR_GRADE<8)?(($DDR_TCWL-5)*8 + 0x200):(($DDR_TCWL-5)*8 + 0x400));
+my $DDR_MR3=0;
+my $DDR_TCCD=4;
+my $DDR_TDLLK=512;
+my $DDR_TPHYRST=16;
+my $DDR_TCALON=15;
+my $DDR_TCALS=15;
+my $DDR_TCALH=15;
+my $DDR_TWLDLYS=16;
+my $DDR_TREFI_N=2;
+my $DDR_TREFI_C=($DDR_TREFI_N)*78;
+my $DDR_DFIODTCFG1=($DDR_TYPE==2)?(($DDR_GRADE<9)?(0x06060000+(($DDR_TCL + $DDR_TAL - 3)<<8)+($DDR_TCWL +
+$DDR_TAL - 3)):(0x07070000+(($DDR_TCL+$DDR_TAL-4)<<8)+(($DDR_TCWL+$DDR_TAL)-4))):(0x06060001+(($DDR_TCL-$DDR_TCWL)<<8));
+my $PLL0A_CFG1=(0x40400000+($A_CPS_F<<12)+($A_Share_Link_F<<8)+($A_NGI_TEP_F<<4)+$A_CBM_F);
+my $PLL0B_CFG1=(0x40400000+($B_CPS_F<<12)+($B_DDR_Controller_F<<8)+($B_GSWIP_L_F<<4)+($B_GSWIP_RMII));
+
+my $DDR_TOGCNT1U=int($ddr_freq/2);
+my $DDR_TOGCNT100N=int($ddr_freq/20);
+
+
+########################################################################################
+
+
+
+open(OUTFILE, ">$output") || die("\nOutput file open fail\n");
+my $value=0;
+my $addr=0;
+
+#NGI_ENDIAN_IA
+$addr=0xb608005c;
+$value=(($endianval==1)?0xdfffff:0x200000);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DIR
+for ($i=0; $i<16; $i++) {
+	$addr=0xb2000000;
+	$value=0x0014a315;
+	printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+}
+
+#PUB_DSGCR
+$addr=0xb2000040;
+$value=(($DDR_TYPE==2)?0xf000641f:0xf004641f);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MM_DRAMCONFIG:
+$addr=(($endianval==1)?0xb2200004:0xb2200000);
+$value= (($DDR_TYPE==2)?0x000c0020:0x000c0030)+(($DDR_BLEN==8)?256:0)+(($DDR_BANKSZ==8)?1:0);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MM_SWAP0_H
+$addr=(($endianval==1)?0xb2200120:0xb2200124);
+$value= (($DDR_TYPE==2)?(($DDR_DENSITY==2)?0xd8:0):0);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MM_SWAP0_L
+$addr=(($endianval==1)?0xb2200124:0xb2200120);
+$value= (($DDR_TYPE==2)?(($DDR_DENSITY==2)?0x0f2c420a:0x0369228b):0x0001528B);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#FMT_0
+$addr=0xb49001d0;
+$value= 0xF8002000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#FMT_1
+$addr=0xb49001d4;
+$value= 0xF8002800;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#FMT_2
+$addr=0xb49001d8;
+$value= 0xFE00A000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TOGCNT1U
+$addr=0xb21000c0;
+$value=$DDR_TOGCNT1U;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TINIT
+$addr=0xb21000c4;
+$value=$DDR_TINIT;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TOGCNT100N
+$addr=0xb21000cc;
+$value=$DDR_TOGCNT100N;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRSTH
+$addr=0xb21000c8;
+$value=($DDR_TYPE==2)?0:(($platform==2)?500:1);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRSTL
+$addr=0xb2100134;
+$value=($DDR_TYPE==2)?0:(($DDR_GRADE<2)?42:(($DDR_GRADE<5)?55:(($DDR_GRADE<8)?68:82)));
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCFG
+$addr=0xb2100080;
+$value=($DDR_TFAW_CFG-4)*(1<<18)+($DDR_TYPE-2)*(1<<5)+(($DDR_BLEN==8)?1:0);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCFG1
+$addr=0xb210007c;
+$value=($DDR_TFAW_CFG_OFF)*(1<<8);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DCR
+$addr=0xb2000044;
+$value=($DDR_TYPE==2)?0x40a:0x1000040b;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_MR0
+$addr=0xb2000054;
+$value=$DDR_MR0;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_MR1
+$addr=0xb2000058;
+$value=$DDR_MR1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_MR2
+$addr=0xb200005c;
+$value=$DDR_MR2;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_MR3
+$addr=0xb2000060;
+$value=$DDR_MR3;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DTPR0
+$addr=0xb2000048;
+$value=$DDR_TRC*(1<<26)+$DDR_TRRD*(1<<22)+$DDR_TRAS*(1<<16)+$DDR_TCL*(1<<12)+$DDR_TCL*(1<<8)+$DDR_TRTP*(1<<4)+$DDR_TRTP;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DTPR1
+$addr=0xb200004c;
+$value=(($DDR_TYPE==2)?8:$DDR_TWLO)*(1<<26)+(($DDR_TYPE==2)?40:$DDR_TWLMRD)*(1<<20)+ $DDR_TRFC*(1<<11)+$DDR_TFAW*(1<<5)+(($DDR_TYPE==2)?4:($DDR_TMOD-12))*(1<<2)+(($DDR_TYPE==2)?$DDR_TMRD:($DDR_TMRD-4));
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DTPR2
+$addr=0xb2000050;
+$value=(($DDR_TCCD>4)?1*(1<<31):0) + ($DDR_TDLLK)*(1<<19)+  $DDR_TCKE*(1<<15)+  $DDR_TXP*(1<<10)+ $DDR_TXS + 1*(1<<30);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGCR2
+$addr=0xb200008c;
+$value=(($DDR_TYPE==2)?0x00f00000:0x00f80000)+ $DDR_TREFPRD;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PTR0
+$addr=0xb200001c;
+$value=$DDR_TPHYRST+  $DDR_TPLLGS*(1<<6)+  $DDR_TPLLPD*(1<<21);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PTR1
+$addr=0xb2000020;
+$value=$DDR_TPLLRST+ $DDR_TPLLLOCK*(1<<16);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PTR2
+$addr=0xb2000024;
+$value=$DDR_TCALON + $DDR_TCALS*(1<<5) + ($DDR_TCALH)*(1<<10) + ($DDR_TWLDLYS)*(1<<15);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DXCCR
+$addr=0xb200003c;
+$value=0x44181884;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0GCR
+$addr=0xb20001c0;
+$value=0x7c001e81;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX1GCR
+$addr=0xb2000200;
+$value=0x7c001e81;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_ZQ0CR1
+$addr=0xb2000184;
+$value=(($DDR_TYPE==2)?(($DDR_GRADE < 6)?0x0000104b:0x0000101b):(($DDR_GRADE < 8)?0x0000105d:0x0000101b));
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004+1;
+$value=0x0;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB000000F;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0LCDLR2
+$addr=0xb20001e8;
+$value=0x6E6E;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX1LCDLR2
+$addr=0xb2000228;
+$value=0x6E6E;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x40001;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB000001F;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFISTSTAT0
+$addr=0xb21002c0+1;
+$value=0x1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#POWCTL
+$addr=0xb2100044;
+$value=0x1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#POWSTAT
+$addr=0xb2100048+1;
+$value=0x1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TOGCNT1U
+$addr=0xb21000c0;
+$value=$DDR_TOGCNT1U;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TINIT
+$addr=0xb21000c4;
+$value=$DDR_TINIT;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TOGCNT100N
+$addr=0xb21000cc;
+$value=$DDR_TOGCNT100N;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TREFI
+$addr=0xb21000d0;
+$value=(1<<31)+(($DDR_TREFI_N-1)<<16)+($DDR_TREFI_C);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TMRD
+$addr=0xb21000d4;
+$value=$DDR_TMRD;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRFC
+$addr=0xb21000d8;
+$value=$DDR_TRFC;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRP
+$addr=0xb21000dc;
+$value=($DDR_TYPE==2)?(($DDR_BANKSZ==8)?($DDR_TCL+65536):$DDR_TCL):$DDR_TCL;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TAL
+$addr=0xb21000e4;
+$value=$DDR_TAL;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TCL
+$addr=0xb21000e8;
+$value=$DDR_TCL;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TCWL
+$addr=0xb21000ec;
+$value=$DDR_TCWL;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRAS
+$addr=0xb21000f0;
+$value=$DDR_TRAS;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRC
+$addr=0xb21000f4;
+$value=$DDR_TRC;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRCD
+$addr=0xb21000f8;
+$value=$DDR_TCL;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRRD
+$addr=0xb21000fc;
+$value=$DDR_TRRD;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRTP
+$addr=0xb2100100;
+$value=$DDR_TRTP;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRTW
+$addr=0xb21000e0;
+$value=3;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TWR
+$addr=0xb2100104;
+$value=$DDR_TWR;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TWTR
+$addr=0xb2100108;
+$value=$DDR_TRTP;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TEXSR
+$addr=0xb210010c;
+$value=($DDR_TYPE==2)?200:512;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TXP
+$addr=0xb2100110;
+$value=$DDR_TXP;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TDQS
+$addr=0xb2100120;
+$value=($DDR_TYPE==2)?2:3;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TCKSRE
+$addr=0xb2100124;
+$value=$DDR_TCKSRE;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TCKSRX
+$addr=0xb2100128;
+$value=($DDR_TYPE==2)?0:$DDR_TCKSRE;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TMOD
+$addr=0xb2100130;
+$value=$DDR_TMOD;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TCKE
+$addr=0xb210012c;
+$value=$DDR_TCKE;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRSTH
+$addr=0xb21000c8;
+$value=($DDR_TYPE==2)?0:(($platform==2)?500:1);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TRSTL
+$addr=0xb2100134;
+$value=($DDR_TYPE==2)?0:(($DDR_GRADE<2)?42:(($DDR_GRADE<5)?55:(($DDR_GRADE<8)?68:82)));
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TZQCS
+$addr=0xb2100118;
+$value=($DDR_TYPE==2)?0:64;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TZQCL
+$addr=0xb2100138;
+$value=($DDR_TYPE==2)?0:512;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TXPDLL
+$addr=0xb2100114;
+$value=($DDR_TYPE==2)?$ddr2_TXP[$DDR_GRADE]:$ddr3_TXP[$DDR_GRADE];
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TZQCSI
+$addr=0xb210011c;
+$value=($DDR_TYPE==2)?0:5;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TCKESR
+$addr=0xb2100140;
+$value=($DDR_TYPE==2)?0:($DDR_TCKE+1);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#TDPD
+$addr=0xb2100144;
+$value=0;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#EFI_MEM_DDR3
+$addr=0xb2100148;
+$value=($DDR_TYPE==2)?0:(int(7800/$ddr_period));
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#SCFG
+$addr=0xb2100000;
+$value=0x4480;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFITPHYWRLAT
+$addr=0xb2100254;
+$value=(((($DDR_TCWL+$DDR_TAL)-1) >> 1) - 1);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFITRDDATAEN
+$addr=0xb2100260;
+$value=$DDR_TCL-2;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFITPHYWRDATA
+$addr=0xb2100250;
+$value=1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFITPHYWRDATALAT
+$addr=0xb2100258;
+$value=3;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFITPHYRDLAT
+$addr=0xb2100264;
+$value=15;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFITDRAMCLKDIS
+$addr=0xb21002d4;
+$value=2;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFITDRAMCLKEN
+$addr=0xb21002d0;
+$value=2;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFITCTRLDELAY
+$addr=0xb2100240;
+$value=2;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFIODTCFG
+$addr=0xb2100244;
+$value=0x8;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFIODTCFG1
+$addr=0xb2100248;
+$value=$DDR_DFIODTCFG1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFIODTRANKMAP
+$addr=0xb210024c;
+$value=0x21;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFITCTRLUPDMAX
+$addr=0xb2100284;
+$value=64;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFIUPDCFG
+$addr=0xb2100290;
+$value=7;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#####################
+#MCMD
+$addr=0xb2100040;
+$value=0x86F00000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+##MCMD
+$addr=0xb2100040+1;
+$value=0x86F00000 - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+if ($DDR_TYPE == 2) {
+#MCMD 
+$addr=0xb2100040;
+$value=0x86F00001;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+}
+
+#MCMD
+$addr=0xb2100040;
+$value=0x80f40003 +  $DDR_MR2*(1<<4);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040+1;
+$value=0x80f40003 +  $DDR_MR2*(1<<4) - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040;
+$value= 0x80f60003 + $DDR_MR3*(1<<4);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040+1;
+$value=0x80f60003 + $DDR_MR3*(1<<4) - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040;
+$value= 0x80f20003 + $DDR_MR1*(1<<4);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+##MCMD
+$addr=0xb2100040+1;
+$value= 0x80f20003 + $DDR_MR1*(1<<4) - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040;
+$value= 0x80f00003 + $DDR_MR0*(1<<4);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+##MCMD
+$addr=0xb2100040+1;
+$value=0x80f00003 + $DDR_MR0*(1<<4) - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+if ($DDR_TYPE==2) {
+#MCMD
+$addr=0xb2100040;
+$value=0x80F00001;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040+1;
+$value=0x80F00001 - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040;
+$value=0x80f00002;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040+1;
+$value=0x80F00002 - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040;
+$value=0x80f00002;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040+1;
+$value=0x80F00002 - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040;
+$value= 0x80f00003+ ($DDR_MR0-  ((int($DDR_MR0/256)%2==1)?256:0) )*16;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040+1;
+$value=0x80f00003+ ($DDR_MR0-  ((int($DDR_MR0/256)%2==1)?256:0) )*16 - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040;
+$value=0x80f20003 + ($DDR_MR1)*(1<<4);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040+1;
+$value=0x80f20003 + ($DDR_MR1)*(1<<4) - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+}
+
+#MCMD
+$addr=0xb2100040;
+$value=0x80f00005;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040+1;
+$value=0x80F00005 - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040;
+$value=0x80f0000A;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#MCMD
+$addr=0xb2100040+1;
+$value=0x80F0000A - 0x80000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#SCTL
+$addr=0xb2100004;
+$value=1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#STAT
+$addr=0xb2100008+1;
+$value=1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PPCFG
+$addr=0xb2100084;
+$value=0;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFISTCFG0
+$addr=0xb21002c4;
+$value=7;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFISTCFG1
+$addr=0xb21002c8;
+$value=3;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFISTCFG2
+$addr=0xb21002d8;
+$value=0;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFILPCFG0
+$addr=0xb21002f0;
+$value=0x70101;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#ECCCFG
+$addr=0xb2100180;
+$value=0;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DFIUPDCFG
+$addr=0xb2100290;
+$value=3;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#CMDSTATEN
+$addr=0xb2100050;
+$value=1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#CMDSTAT
+$addr=0xb210004c+1;
+$value=1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#SCTL
+$addr=0xb2100004;
+$value=2;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#STAT
+$addr=0xb2100008+1;
+$value=3;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#SCTL
+$addr=0xb2100004;
+$value=3;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#STAT
+$addr=0xb2100008+1;
+$value=0x45;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PLL0A_CFG1
+$addr=0xb6200008;
+#$value= 0x40403866;
+$value=$PLL0A_CFG1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PLL0B_CFG1
+$addr=0xb6200038;
+#$value= ($DDR_TYPE==2)?0x40401656:0x40401556;
+$value=$PLL0B_CFG1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PLLCR
+$addr=0xb6200018;
+$value=0x40000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PLLCR
+$addr=0xb6200018;
+$value=0x0001c000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#SCTL
+$addr=0xb2100004;
+$value=4;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#STAT
+$addr=0xb2100008+1;
+$value=3;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#SCTL
+$addr=0xb2100004;
+$value=1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#STAT
+$addr=0xb2100008+1;
+$value=1;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DTCR
+$addr=0xb2000068;
+$value=($DDR_TYPE==2)?0x91007887:(($DDR_GRADE>5)?0x910035c7:0x910078c7);
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x8000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB0000017;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x13;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB000001F;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#DELAY
+$addr=0x80000000;
+$value=0x0000ffff;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0BDLR0
+$addr=0xb20001cc;
+$value=0x18618618;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0BDLR1
+$addr=0xb20001d0;
+$value=0x18618618;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0BDLR2
+$addr=0xb20001d4;
+$value=0x00000618;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0BDLR3
+$addr=0xb20001d8;
+$value=0x00000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0BDLR4
+$addr=0xb20001dc;
+$value=0x00000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0BDLR0
+$addr=0xb200020c;
+$value=0x18618618;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0BDLR1
+$addr=0xb2000210;
+$value=0x18618618;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0BDLR2
+$addr=0xb2000214;
+$value=0x00000618;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0BDLR3
+$addr=0xb2000218;
+$value=0x00000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_DX0BDLR4
+$addr=0xb200021c;
+$value=0x00000000;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+if ($DDR_TYPE==2) {
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x401;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB000005F;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x1001;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB000015f;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x2001;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010;
+$value=0xB000035f;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x4001;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010;
+$value=0xB000075F;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x8001;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010;
+$value=0xB0000F5F;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+}
+else {
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x201;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB000003F;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x401;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB000007F;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x801;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB00000FF;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x1001;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB00001FF;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x2001;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB00003FF;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x4001;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB00007FF;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PIR
+$addr=0xb2000004;
+$value=0x8001;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#PUB_PGSR0
+$addr=0xb2000010+1;
+$value=0xB0000FFF;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+}
+
+#SCTL
+$addr=0xb2100004;
+$value=2;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+#STAT
+$addr=0xb2100008+1;
+$value=3;
+printf OUTFILE ("0x%08x 0x%08x \n",$addr, $value);
+
+
diff --git a/board/grx500/grx500.c b/board/grx500/grx500.c
new file mode 100755
--- /dev/null
+++ b/board/grx500/grx500.c
@@ -0,0 +1,225 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+#include <environment.h>
+
+
+#define GPIO_OUTPUT 1
+#define GPIO_INPUT 0
+#define MAX_4KEC_DDR	128
+
+extern u32 get_cpu_id(void);
+
+int cpu_is_cps(void)
+{
+    int ret=0;
+    if(get_cpu_id()==0xa1) ret=1;
+    return ret;
+}
+
+phys_size_t initdram(int board_type)
+{
+	if (!cpu_is_cps() && (CONFIG_IFX_MEMORY_SIZE > 128))
+		return (1024*1024*MAX_4KEC_DDR);
+	else
+		return (1024*1024*CONFIG_IFX_MEMORY_SIZE);
+}
+
+void config_led(void)
+{
+	int i;
+	REG32(GPT2_CLC) = 0x00010100;							//gptc2 - full kernel clock
+	REG32(GPT1_CLC) = 0x00010100;							//gptc1 - full kernel clock
+	REG32(GPT3_CLC) = 0x00010100;							//gptc0 - full kernel clock
+	REG32(GPT3_RELOAD_2_A) = 50;							//GPT_RELOAD_N_A		
+	REG32(GPT3_CON_2_A) = 0x00;								//16-bit, timer, count down, auto-reload
+	REG32(GPT3_RUN_2_A) = 0x05;								//Reload and Run 	
+	while ((REG32(GPT3_CON_2_A) & 1) == 0);					//wait for status bit
+
+	/* GPIO settings */
+	REG32(0xb6c80000 + 4*4) = 0;							//GPIO4 as IO
+	REG32(0xb6c80080) &= ~(1<<4);							//GPIO4 PUEN disabled
+	REG32(0xb6c80084) &= ~(1<<4);							//GPIO4 PDEN disabled
+	REG32(0xb6c80088) |= (1<<4);							//GPIO4 fast slowrate
+	REG32(0xb6c8008c) |= (3<<(2*4));						//GPIO4 12mA driver
+	REG32(0xb6c80094) &= ~(1<<4);							//GPIO4 normal output (not open drain) - if output
+
+	REG32(0xb6c80000 + 4*5) = 0;							//GPIO5 as IO
+	REG32(0xb6c80080) &= ~(1<<5);							//GPIO5 PUEN disabled
+	REG32(0xb6c80084) &= ~(1<<5);							//GPIO5 PDEN disabled
+	REG32(0xb6c80088) |= (1<<5);							//GPIO5 fast slowrate
+	REG32(0xb6c8008c) |= (3<<(2*5));						//GPIO5 12mA driver
+	REG32(0xb6c80094) &= ~(1<<5);							//GPIO5 normal output (not open drain) - if output
+
+	REG32(0xb6c80000 + 4*6) = 0;							//GPIO6 as IO
+	REG32(0xb6c80080) &= ~(1<<6);							//GPIO6 PUEN disabled
+	REG32(0xb6c80084) &= ~(1<<6);							//GPIO6 PDEN disabled
+	REG32(0xb6c80088) |= (1<<6);							//GPIO6 fast slowrate
+	REG32(0xb6c8008c) |= (3<<(2*6));						//GPIO6 12mA driver
+	REG32(0xb6c80094) &= ~(1<<6);							//GPIO6 normal output (not open drain) - if output
+	
+   	REG32(0xb6c80010) = 1;									//LED_ST selected instead of GPIO4 
+   	REG32(0xb6c80014) = 1;									//LED_D  selected instead of GPIO5   
+   	REG32(0xb6c80018) = 1;									//LED_SH selected instead of GPIO6
+
+	/* End GPIO settings */
+   	
+   	REG32(SSO_CON0) = 0x44000000;				            //SSIO_SSO_CON0, /auto dim = 0 disabled, blink rate = update rate
+														
+#ifdef CONFIG_BOARD_EASY350
+	REG32(SSO_CON1) = 0x40000003;							//SSIO_SSO_CON1;
+#else	
+	REG32(SSO_CON1) = 0x4000000f;							//LED_SH=25MHz, LED_ST=single, Data Offset = 0, 
+#endif														//Blink rate for LED[23:0] - use FSC: 8K/4000 = 2Hz	
+
+	REG32(LED_BLINK_H8_0) = 0x00000000;						//Blink rate for LED[28:24] - use FSC	
+	REG32(LED_BLINK_H8_1) = 0x00000000;						//Blink rate for LED[31:29] - use FSC
+								 							//Blink rate for LED[23:0]  - use FSC 	
+															//   if use FSC, rate = 2Hz  (FSC = 8KHz/4000)	 
+								 							//   if use GPT, rate = 1KHz (GPTC0-T2A = 2MHz/2000)								 							
+	REG32(SSO_AR) = 0x00000000;								//CPU0 selected	
+	
+	for (i = 0; i < 32; i++)
+		REG32(DUTY_CYCLE_0 + i*4) = 0x80;	
+		
+//Set Orange Color R:G:B = half bright of 255:165:0
+#ifdef CONFIG_BOARD_EASY350	
+	REG32(SSO_CPU0) = 0xa000;		//Blue off
+	REG32(DUTY_CYCLE_13) = 0x80;		//Red  
+	REG32(DUTY_CYCLE_15) = 0x52;		//Grn		
+#else
+	REG32(SSO_CPU0) = 0xa0000000;	//Blue off
+	REG32(DUTY_CYCLE_29) = 0x80;		//Red  
+	REG32(DUTY_CYCLE_31) = 0x52;		//Grn		
+#endif	
+
+}
+
+int flash_probe(void)
+{
+     return 1;
+}
+
+void show_boot_progress(int arg)
+{
+  return;
+}
+
+int checkboard (void)
+{
+    int i;
+    if(cpu_is_cps()){
+      printf("interAptiv\n");
+      printf("cps cpu/ddr run in %d/%d Mhz\n",get_cpu_clk()/1000000, get_ddr_clk()/1000000);
+    }else{
+       printf("4Kec\n");
+    }
+
+#ifdef CONFIG_GRX500_A21
+	config_led();
+#endif
+
+    return 0;
+}
+
+void config_gpio(u32 pin, int dir, u32 func_num)
+{
+    u32 portmux_base = pin>31?GPIO_PAD_CTRL_PORTMUXC32:GPIO_PAD_CTRL_PORTMUXC0; 
+    u32 dir_base = pin>31?GPIO_FUNCTION_DIR_1:GPIO_FUNCTION_DIR_0;    
+    u32 od_base = pin>31?GPIO_PAD_CTRL_OD_1:GPIO_PAD_CTRL_OD_0;
+    u32 rel_port_num = pin>31?(pin-32):pin;
+
+    REG32(portmux_base + (rel_port_num<<2)) = func_num;
+
+    if(dir == GPIO_OUTPUT)
+    {
+        REG32(dir_base)|= (1<<rel_port_num); 
+        REG32(od_base) &=~(1<<rel_port_num);
+    }else{
+        REG32(dir_base)&= ~(1<<rel_port_num);
+        //REG32(od_base) |=(1<<rel_port_num);
+    }
+}
+
+#ifdef CONFIG_LANTIQ_SPI
+
+int spi_gpio_init(unsigned int cs)
+{
+     /*Enable SPI0 clock*/
+     REG32(CGU_CLKGCR1_A)|= CGU_CLKGCR1_A_SPI0_MASK;
+     
+     /*GPIO 18, SPI0 CLK*/
+     config_gpio(18, GPIO_OUTPUT, 1);
+    
+     /*enable all chip select signals*/ 
+     config_gpio(15, GPIO_OUTPUT, 1);
+     config_gpio(10, GPIO_OUTPUT, 0x2);
+     config_gpio(11, GPIO_OUTPUT, 0x3);
+     
+     /*RX gpio*/
+     config_gpio(17, GPIO_OUTPUT, 0x1);
+     /*TX gpio*/
+     config_gpio(16, GPIO_INPUT, 0x1);
+   
+     return 1;
+}
+
+#endif
+
+
+#ifdef CONFIG_NAND_FLASH
+void nand_gpio_init(void)
+{
+     config_gpio(13, GPIO_OUTPUT, 1);
+     config_gpio(23, GPIO_OUTPUT, 1);
+     config_gpio(24, GPIO_OUTPUT, 1);
+     config_gpio(48, GPIO_INPUT,  1);
+     config_gpio(49, GPIO_OUTPUT, 1);
+     config_gpio(50, GPIO_OUTPUT, 1);
+     config_gpio(51, GPIO_OUTPUT, 1);
+     config_gpio(52, GPIO_OUTPUT, 1);
+     config_gpio(53, GPIO_OUTPUT, 1);
+     config_gpio(54, GPIO_OUTPUT, 1);
+     config_gpio(55, GPIO_OUTPUT, 1);
+     config_gpio(56, GPIO_OUTPUT, 1);
+     config_gpio(57, GPIO_OUTPUT, 1);
+     config_gpio(59, GPIO_OUTPUT, 1);
+     config_gpio(60, GPIO_OUTPUT, 1);
+     config_gpio(61, GPIO_OUTPUT, 1);
+
+     REG32(EBU_ADDR_SEL_0) = 0x17400051;
+
+}
+#endif
+
+int board_eth_init(bd_t *bis)
+{
+   if (grx500_eth_initialize(bis)<0)
+             return -1;
+   
+	return 0;
+}
+						 
diff --git a/board/grx500/haps-ram-no-in.cmm b/board/grx500/haps-ram-no-in.cmm
new file mode 100755
--- /dev/null
+++ b/board/grx500/haps-ram-no-in.cmm
@@ -0,0 +1,149 @@
+Data.Set 0xb2200000 %Long 0x100c0020
+Data.Set 0xb2200120 %Long 0x000d838c
+Data.Set 0xb2200124 %Long 0x016c420a
+Data.Set 0xb21000c0 %Long 0x00000190
+Data.Set 0xb21000c4 %Long 0x000000c8
+Data.Set 0xb21000cc %Long 0x00000028
+Data.Set 0xb21000c8 %Long 0x00000000
+Data.Set 0xb2100134 %Long 0x00000032
+Data.Set 0xb2100080 %Long 0x00040000
+Data.Set 0xb210007c %Long 0x00000200
+Data.Set 0xb2000044 %Long 0x0000040a
+Data.Set 0xb2000054 %Long 0x00000b62
+Data.Set 0xb2000058 %Long 0x00000000
+Data.Set 0xb200005c %Long 0x00000000
+Data.Set 0xb2000060 %Long 0x00000000
+Data.Set 0xb2000048 %Long 0x61126644
+Data.Set 0xb200004c %Long 0x00015243
+Data.Set 0xb2000050 %Long 0x10018c03
+Data.Set 0xb2000008 %Long 0xa8003e3f
+Data.Set 0xb200000c %Long 0x0300c461
+Data.Set 0xb200008c %Long 0x00f46db0
+Data.Set 0xb200001c %Long 0x32019010
+Data.Set 0xb2000020 %Long 0x9c4004b0
+Data.Set 0xb2000024 %Long 0x00083def
+Data.Set 0xb2000028 %Long 0x03461a80
+Data.Set 0xb200002c %Long 0x0c827100
+Data.Set 0xb2000004 %Long 0x60000000
+Data.Set 0xb20001e8 %Long 0x00006e6e
+Data.Set 0xb2000228 %Long 0x00006e6e
+Data.Set 0xb2000004 %Long 0x00040001
+Data.Set 0xb2100044 %Long 0x00000001
+Data.Set 0xb21000c0 %Long 0x00000190
+Data.Set 0xb21000c4 %Long 0x000000c8
+Data.Set 0xb21000cc %Long 0x00000028
+Data.Set 0xb21000d0 %Long 0x80030138
+Data.Set 0xb21000d4 %Long 0x00000003
+Data.Set 0xb21000d8 %Long 0x0000002a
+Data.Set 0xb21000dc %Long 0x00000006
+Data.Set 0xb21000e4 %Long 0x00000000
+Data.Set 0xb21000e8 %Long 0x00000006
+Data.Set 0xb21000ec %Long 0x00000005
+Data.Set 0xb21000f0 %Long 0x00000012
+Data.Set 0xb21000f4 %Long 0x00000018
+Data.Set 0xb21000f8 %Long 0x00000006
+Data.Set 0xb21000fc %Long 0x00000004
+Data.Set 0xb2100100 %Long 0x00000004
+Data.Set 0xb21000e0 %Long 0x00000002
+Data.Set 0xb2100104 %Long 0x00000006
+Data.Set 0xb2100108 %Long 0x00000004
+Data.Set 0xb210010c %Long 0x000000c8
+Data.Set 0xb2100110 %Long 0x00000003
+Data.Set 0xb2100120 %Long 0x00000004
+Data.Set 0xb2100124 %Long 0x00000000
+Data.Set 0xb2100128 %Long 0x00000000
+Data.Set 0xb2100130 %Long 0x00000000
+Data.Set 0xb210012c %Long 0x00000003
+Data.Set 0xb21000c8 %Long 0x00000000
+Data.Set 0xb2100134 %Long 0x00000000
+Data.Set 0xb2100118 %Long 0x00000000
+Data.Set 0xb2100138 %Long 0x00000000
+Data.Set 0xb2100114 %Long 0x00000003
+Data.Set 0xb210011c %Long 0x00000000
+Data.Set 0xb2100140 %Long 0x00000000
+Data.Set 0xb2100144 %Long 0x00000000
+Data.Set 0xb2100148 %Long 0x00000000
+Data.Set 0xb2100000 %Long 0x00004780
+Data.Set 0xb2100254 %Long 0x00000001
+Data.Set 0xb2100260 %Long 0x00000003
+Data.Set 0xb2100258 %Long 0x00000003
+Data.Set 0xb2100250 %Long 0x00000001
+Data.Set 0xb2100264 %Long 0x0000000f
+Data.Set 0xb21002d4 %Long 0x00000002
+Data.Set 0xb21002d0 %Long 0x00000002
+Data.Set 0xb2100240 %Long 0x00000002
+Data.Set 0xb2100284 %Long 0x00000040
+Data.Set 0xb2100290 %Long 0x00000007
+Data.Set 0xb2100040 %Long 0x86f00000
+Data.Set 0xb2100040 %Long 0x80f00001
+Data.Set 0xb2100040 %Long 0x80f40003
+Data.Set 0xb2100040 %Long 0x80f60003
+Data.Set 0xb2100040 %Long 0x80f20003
+Data.Set 0xb2100040 %Long 0x80f0b623
+Data.Set 0xb2100040 %Long 0x80f00001
+Data.Set 0xb2100040 %Long 0x80f00002
+Data.Set 0xb2100040 %Long 0x80f00002
+Data.Set 0xb2100040 %Long 0x80f0a623
+Data.Set 0xb2100040 %Long 0x80f20003
+Data.Set 0xb2100040 %Long 0x80f00005
+Data.Set 0xb2100040 %Long 0x80f0000a
+Data.Set 0xb2100004 %Long 0x00000001
+Data.Set 0xb2100080 %Long 0x00040000
+Data.Set 0xb210007c %Long 0x00000200
+Data.Set 0xb2100000 %Long 0x00004780
+Data.Set 0xb2100084 %Long 0x00000000
+Data.Set 0xb21002c4 %Long 0x00000007
+Data.Set 0xb21002c8 %Long 0x00000003
+Data.Set 0xb21002d8 %Long 0x00000000
+Data.Set 0xb21002f0 %Long 0x00070101
+Data.Set 0xb2100180 %Long 0x00000000
+Data.Set 0xb21000c0 %Long 0x00000190
+Data.Set 0xb21000c4 %Long 0x000000c8
+Data.Set 0xb21000cc %Long 0x00000028
+Data.Set 0xb21000d0 %Long 0x80030138
+Data.Set 0xb21000d4 %Long 0x00000003
+Data.Set 0xb21000d8 %Long 0x0000002a
+Data.Set 0xb21000dc %Long 0x00000006
+Data.Set 0xb21000e4 %Long 0x00000000
+Data.Set 0xb21000e8 %Long 0x00000006
+Data.Set 0xb21000ec %Long 0x00000005
+Data.Set 0xb21000f0 %Long 0x00000012
+Data.Set 0xb21000f4 %Long 0x00000018
+Data.Set 0xb21000f8 %Long 0x00000006
+Data.Set 0xb21000fc %Long 0x00000004
+Data.Set 0xb2100100 %Long 0x00000004
+Data.Set 0xb21000e0 %Long 0x00000002
+Data.Set 0xb2100104 %Long 0x00000006
+Data.Set 0xb2100108 %Long 0x00000004
+Data.Set 0xb210010c %Long 0x000000c8
+Data.Set 0xb2100110 %Long 0x00000003
+Data.Set 0xb2100120 %Long 0x00000004
+Data.Set 0xb2100124 %Long 0x00000000
+Data.Set 0xb2100128 %Long 0x00000000
+Data.Set 0xb2100130 %Long 0x00000000
+Data.Set 0xb210012c %Long 0x00000003
+Data.Set 0xb21000c8 %Long 0x00000000
+Data.Set 0xb2100134 %Long 0x00000000
+Data.Set 0xb2100118 %Long 0x00000000
+Data.Set 0xb2100138 %Long 0x00000000
+Data.Set 0xb2100114 %Long 0x00000003
+Data.Set 0xb210011c %Long 0x00000000
+Data.Set 0xb2100140 %Long 0x00000000
+Data.Set 0xb2100144 %Long 0x00000000
+Data.Set 0xb2100148 %Long 0x00000000
+Data.Set 0xb2100254 %Long 0x00000001
+Data.Set 0xb2100260 %Long 0x00000003
+Data.Set 0xb2100258 %Long 0x00000003
+Data.Set 0xb2100250 %Long 0x00000001
+Data.Set 0xb2100264 %Long 0x0000000f
+Data.Set 0xb21002d4 %Long 0x00000002
+Data.Set 0xb21002d0 %Long 0x00000002
+Data.Set 0xb2100240 %Long 0x00000002
+Data.Set 0xb2100284 %Long 0x00000040
+Data.Set 0xb2100290 %Long 0x00000003
+Data.Set 0xb2100050 %Long 0x00000001
+Data.Set 0xb2100004 %Long 0x00000002
+Data.Set 0xb49001d0 %Long 0xf0002000
+Data.Set 0xb49001d8 %Long 0xfe00a000
+
+
diff --git a/board/grx500/haps-ram.cmm b/board/grx500/haps-ram.cmm
new file mode 100755
--- /dev/null
+++ b/board/grx500/haps-ram.cmm
@@ -0,0 +1,183 @@
+
+
+Data.Set 0xb2200000 %Long 0x100c0020
+Data.Set 0xb2200120 %Long 0x000d838c
+Data.Set 0xb2200124 %Long 0x016c420a
+
+Data.In 0xb2100008
+Data.Set 0xb21000c0 %Long 0x00000190
+Data.In 0xb21000c0
+Data.Set 0xb21000c4 %Long 0x000000c8
+Data.Set 0xb21000cc %Long 0x00000028
+Data.Set 0xb21000c8 %Long 0x00000000
+Data.Set 0xb2100134 %Long 0x00000032
+Data.In 0xb2100080
+Data.Set 0xb2100080 %Long 0x00040000
+Data.In 0xb210007c
+Data.Set 0xb210007c %Long 0x00000200
+Data.Set 0xb2000044 %Long 0x0000040a
+Data.Set 0xb2000054 %Long 0x00000b62
+Data.Set 0xb2000058 %Long 0x00000000
+Data.Set 0xb200005c %Long 0x00000000
+Data.Set 0xb2000060 %Long 0x00000000
+Data.Set 0xb2000048 %Long 0x61126644
+Data.Set 0xb200004c %Long 0x00015243
+Data.Set 0xb2000050 %Long 0x10018c03
+Data.Set 0xb2000008 %Long 0xa8003e3f
+Data.Set 0xb200000c %Long 0x0300c461
+Data.Set 0xb200008c %Long 0x00f46db0
+Data.Set 0xb200001c %Long 0x32019010
+Data.Set 0xb2000020 %Long 0x9c4004b0
+Data.Set 0xb2000024 %Long 0x00083def
+Data.Set 0xb2000028 %Long 0x03461a80
+Data.Set 0xb200002c %Long 0x0c827100
+Data.In 0xb2000004
+Data.Set 0xb2000004 %Long 0x60000000
+Data.In 0xb2000010
+Data.Set 0xb20001e8 %Long 0x00006e6e
+Data.Set 0xb2000228 %Long 0x00006e6e
+Data.In 0xb2000004
+Data.Set 0xb2000004 %Long 0x00040001
+Data.In 0xb2000010
+Data.In 0xb21002c0
+Data.Set 0xb2100044 %Long 0x00000001
+Data.In 0xb2100048
+Data.Set 0xb21000c0 %Long 0x00000190
+Data.Set 0xb21000c4 %Long 0x000000c8
+Data.Set 0xb21000cc %Long 0x00000028
+Data.Set 0xb21000d0 %Long 0x80030138
+Data.Set 0xb21000d4 %Long 0x00000003
+Data.Set 0xb21000d8 %Long 0x0000002a
+Data.Set 0xb21000dc %Long 0x00000006
+Data.Set 0xb21000e4 %Long 0x00000000
+Data.Set 0xb21000e8 %Long 0x00000006
+Data.Set 0xb21000ec %Long 0x00000005
+Data.Set 0xb21000f0 %Long 0x00000012
+Data.Set 0xb21000f4 %Long 0x00000018
+Data.Set 0xb21000f8 %Long 0x00000006
+Data.Set 0xb21000fc %Long 0x00000004
+Data.Set 0xb2100100 %Long 0x00000004
+Data.Set 0xb21000e0 %Long 0x00000002
+Data.Set 0xb2100104 %Long 0x00000006
+Data.Set 0xb2100108 %Long 0x00000004
+Data.Set 0xb210010c %Long 0x000000c8
+Data.Set 0xb2100110 %Long 0x00000003
+Data.Set 0xb2100120 %Long 0x00000004
+Data.Set 0xb2100124 %Long 0x00000000
+Data.Set 0xb2100128 %Long 0x00000000
+Data.Set 0xb2100130 %Long 0x00000000
+Data.Set 0xb210012c %Long 0x00000003
+Data.Set 0xb21000c8 %Long 0x00000000
+Data.Set 0xb2100134 %Long 0x00000000
+Data.Set 0xb2100118 %Long 0x00000000
+Data.Set 0xb2100138 %Long 0x00000000
+Data.Set 0xb2100114 %Long 0x00000003
+Data.Set 0xb210011c %Long 0x00000000
+Data.Set 0xb2100140 %Long 0x00000000
+Data.Set 0xb2100144 %Long 0x00000000
+Data.Set 0xb2100148 %Long 0x00000000
+Data.Set 0xb2100000 %Long 0x00004780
+Data.Set 0xb2100254 %Long 0x00000001
+Data.Set 0xb2100260 %Long 0x00000003
+Data.Set 0xb2100258 %Long 0x00000003
+Data.Set 0xb2100250 %Long 0x00000001
+Data.Set 0xb2100264 %Long 0x0000000f
+Data.Set 0xb21002d4 %Long 0x00000002
+Data.Set 0xb21002d0 %Long 0x00000002
+Data.Set 0xb2100240 %Long 0x00000002
+Data.Set 0xb2100284 %Long 0x00000040
+Data.Set 0xb2100290 %Long 0x00000007
+Data.Set 0xb2100040 %Long 0x86f00000
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f00001
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f40003
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f60003
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f20003
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f0b623
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f00001
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f00002
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f00002
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f0a623
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f20003
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f00005
+Data.In 0xb2100040
+Data.Set 0xb2100040 %Long 0x80f0000a
+Data.In 0xb2100040
+Data.In 0xb2100008
+Data.Set 0xb2100004 %Long 0x00000001
+Data.In 0xb2100008
+Data.In 0xb2100080
+Data.Set 0xb2100080 %Long 0x00040000
+Data.In 0xb210007c
+Data.Set 0xb210007c %Long 0x00000200
+Data.Set 0xb2100000 %Long 0x00004780
+Data.Set 0xb2100084 %Long 0x00000000
+Data.Set 0xb21002c4 %Long 0x00000007
+Data.Set 0xb21002c8 %Long 0x00000003
+Data.Set 0xb21002d8 %Long 0x00000000
+Data.Set 0xb21002f0 %Long 0x00070101
+Data.Set 0xb2100180 %Long 0x00000000
+Data.Set 0xb21000c0 %Long 0x00000190
+Data.Set 0xb21000c4 %Long 0x000000c8
+Data.Set 0xb21000cc %Long 0x00000028
+Data.Set 0xb21000d0 %Long 0x80030138
+Data.Set 0xb21000d4 %Long 0x00000003
+Data.Set 0xb21000d8 %Long 0x0000002a
+Data.Set 0xb21000dc %Long 0x00000006
+Data.Set 0xb21000e4 %Long 0x00000000
+Data.Set 0xb21000e8 %Long 0x00000006
+Data.Set 0xb21000ec %Long 0x00000005
+Data.Set 0xb21000f0 %Long 0x00000012
+Data.Set 0xb21000f4 %Long 0x00000018
+Data.Set 0xb21000f8 %Long 0x00000006
+Data.Set 0xb21000fc %Long 0x00000004
+Data.Set 0xb2100100 %Long 0x00000004
+Data.Set 0xb21000e0 %Long 0x00000002
+Data.Set 0xb2100104 %Long 0x00000006
+Data.Set 0xb2100108 %Long 0x00000004
+Data.Set 0xb210010c %Long 0x000000c8
+Data.Set 0xb2100110 %Long 0x00000003
+Data.Set 0xb2100120 %Long 0x00000004
+Data.Set 0xb2100124 %Long 0x00000000
+Data.Set 0xb2100128 %Long 0x00000000
+Data.Set 0xb2100130 %Long 0x00000000
+Data.Set 0xb210012c %Long 0x00000003
+Data.Set 0xb21000c8 %Long 0x00000000
+Data.Set 0xb2100134 %Long 0x00000000
+Data.Set 0xb2100118 %Long 0x00000000
+Data.Set 0xb2100138 %Long 0x00000000
+Data.Set 0xb2100114 %Long 0x00000003
+Data.Set 0xb210011c %Long 0x00000000
+Data.Set 0xb2100140 %Long 0x00000000
+Data.Set 0xb2100144 %Long 0x00000000
+Data.Set 0xb2100148 %Long 0x00000000
+Data.Set 0xb2100254 %Long 0x00000001
+Data.Set 0xb2100260 %Long 0x00000003
+Data.Set 0xb2100258 %Long 0x00000003
+Data.Set 0xb2100250 %Long 0x00000001
+Data.Set 0xb2100264 %Long 0x0000000f
+Data.Set 0xb21002d4 %Long 0x00000002
+Data.Set 0xb21002d0 %Long 0x00000002
+Data.Set 0xb2100240 %Long 0x00000002
+Data.Set 0xb2100284 %Long 0x00000040
+Data.Set 0xb2100290 %Long 0x00000003
+Data.Set 0xb2100050 %Long 0x00000001
+Data.In 0xb210004c
+Data.Set 0xb2100004 %Long 0x00000002
+Data.In 0xb2100008
+
+Data.Set 0xb49001d0 %Long 0xf0002000
+Data.Set 0xb49001d8 %Long 0xfe00a000
+
+;SYStem.Down
+
diff --git a/board/grx500/haps-ram.conf b/board/grx500/haps-ram.conf
new file mode 100755
--- /dev/null
+++ b/board/grx500/haps-ram.conf
@@ -0,0 +1,149 @@
+0xb2200000  0x100c0020
+0xb2200120  0x000d838c
+0xb2200124  0x016c420a
+0xb21000c0  0x00000190
+0xb21000c4  0x000000c8
+0xb21000cc  0x00000028
+0xb21000c8  0x00000000
+0xb2100134  0x00000032
+0xb2100080  0x00040000
+0xb210007c  0x00000200
+0xb2000044  0x0000040a
+0xb2000054  0x00000b62
+0xb2000058  0x00000000
+0xb200005c  0x00000000
+0xb2000060  0x00000000
+0xb2000048  0x61126644
+0xb200004c  0x00015243
+0xb2000050  0x10018c03
+0xb2000008  0xa8003e3f
+0xb200000c  0x0300c461
+0xb200008c  0x00f46db0
+0xb200001c  0x32019010
+0xb2000020  0x9c4004b0
+0xb2000024  0x00083def
+0xb2000028  0x03461a80
+0xb200002c  0x0c827100
+0xb2000004  0x60000000
+0xb20001e8  0x00006e6e
+0xb2000228  0x00006e6e
+0xb2000004  0x00040001
+0xb2100044  0x00000001
+0xb21000c0  0x00000190
+0xb21000c4  0x000000c8
+0xb21000cc  0x00000028
+0xb21000d0  0x80030138
+0xb21000d4  0x00000003
+0xb21000d8  0x0000002a
+0xb21000dc  0x00000006
+0xb21000e4  0x00000000
+0xb21000e8  0x00000006
+0xb21000ec  0x00000005
+0xb21000f0  0x00000012
+0xb21000f4  0x00000018
+0xb21000f8  0x00000006
+0xb21000fc  0x00000004
+0xb2100100  0x00000004
+0xb21000e0  0x00000002
+0xb2100104  0x00000006
+0xb2100108  0x00000004
+0xb210010c  0x000000c8
+0xb2100110  0x00000003
+0xb2100120  0x00000004
+0xb2100124  0x00000000
+0xb2100128  0x00000000
+0xb2100130  0x00000000
+0xb210012c  0x00000003
+0xb21000c8  0x00000000
+0xb2100134  0x00000000
+0xb2100118  0x00000000
+0xb2100138  0x00000000
+0xb2100114  0x00000003
+0xb210011c  0x00000000
+0xb2100140  0x00000000
+0xb2100144  0x00000000
+0xb2100148  0x00000000
+0xb2100000  0x00004780
+0xb2100254  0x00000001
+0xb2100260  0x00000003
+0xb2100258  0x00000003
+0xb2100250  0x00000001
+0xb2100264  0x0000000f
+0xb21002d4  0x00000002
+0xb21002d0  0x00000002
+0xb2100240  0x00000002
+0xb2100284  0x00000040
+0xb2100290  0x00000007
+0xb2100040  0x86f00000
+0xb2100040  0x80f00001
+0xb2100040  0x80f40003
+0xb2100040  0x80f60003
+0xb2100040  0x80f20003
+0xb2100040  0x80f0b623
+0xb2100040  0x80f00001
+0xb2100040  0x80f00002
+0xb2100040  0x80f00002
+0xb2100040  0x80f0a623
+0xb2100040  0x80f20003
+0xb2100040  0x80f00005
+0xb2100040  0x80f0000a
+0xb2100004  0x00000001
+0xb2100080  0x00040000
+0xb210007c  0x00000200
+0xb2100000  0x00004780
+0xb2100084  0x00000000
+0xb21002c4  0x00000007
+0xb21002c8  0x00000003
+0xb21002d8  0x00000000
+0xb21002f0  0x00070101
+0xb2100180  0x00000000
+0xb21000c0  0x00000190
+0xb21000c4  0x000000c8
+0xb21000cc  0x00000028
+0xb21000d0  0x80030138
+0xb21000d4  0x00000003
+0xb21000d8  0x0000002a
+0xb21000dc  0x00000006
+0xb21000e4  0x00000000
+0xb21000e8  0x00000006
+0xb21000ec  0x00000005
+0xb21000f0  0x00000012
+0xb21000f4  0x00000018
+0xb21000f8  0x00000006
+0xb21000fc  0x00000004
+0xb2100100  0x00000004
+0xb21000e0  0x00000002
+0xb2100104  0x00000006
+0xb2100108  0x00000004
+0xb210010c  0x000000c8
+0xb2100110  0x00000003
+0xb2100120  0x00000004
+0xb2100124  0x00000000
+0xb2100128  0x00000000
+0xb2100130  0x00000000
+0xb210012c  0x00000003
+0xb21000c8  0x00000000
+0xb2100134  0x00000000
+0xb2100118  0x00000000
+0xb2100138  0x00000000
+0xb2100114  0x00000003
+0xb210011c  0x00000000
+0xb2100140  0x00000000
+0xb2100144  0x00000000
+0xb2100148  0x00000000
+0xb2100254  0x00000001
+0xb2100260  0x00000003
+0xb2100258  0x00000003
+0xb2100250  0x00000001
+0xb2100264  0x0000000f
+0xb21002d4  0x00000002
+0xb21002d0  0x00000002
+0xb2100240  0x00000002
+0xb2100284  0x00000040
+0xb2100290  0x00000003
+0xb2100050  0x00000001
+0xb2100004  0x00000002
+0xb49001d0  0xf0002000
+0xb49001d8  0xfe00a000
+
+
diff --git a/board/grx500/haps_eb_poll.conf b/board/grx500/haps_eb_poll.conf
new file mode 100755
--- /dev/null
+++ b/board/grx500/haps_eb_poll.conf
@@ -0,0 +1,166 @@
+0xb2200000  0x100c0020
+0xb2200120  0x000d838c
+0xb2200124  0x016c420a
+
+0xb49001d0  0xf0002000
+0xb49001d8  0xfe00a000
+
+0xb21000c0  0x00000190
+0xb21000c4  0x000000c8
+0xb21000cc  0x00000028
+0xb21000c8  0x00000000
+0xb2100134  0x00000032
+0xb2100080  0x00040000
+0xb210007c  0x00000200
+0xb2000044  0x0000040a
+0xb2000054  0x00000b62
+0xb2000058  0x00000000
+0xb200005c  0x00000000
+0xb2000060  0x00000000
+0xb2000048  0x61126644
+0xb200004c  0x00015243
+0xb2000050  0x10018c03
+0xb200008c  0x00f46db0
+0xb200001c  0x32019010
+0xb2000020  0x9c4004b0
+0xb2000024  0x00083def
+
+0xb2000005  0x00000000
+
+0xb2000004  0x60000000
+
+0xb2000011  0xb000000f
+
+0xb20001e8  0x00006e6e
+0xb2000228  0x00006e6e
+0xb2000004  0x00040001
+
+0xb2000011  0xb000001f
+0xb21002c1  0x00000001
+
+0xb2100044  0x00000001
+
+0xb2100049  0x00000001
+
+0xb21000c0  0x00000190
+0xb21000c4  0x000000c8
+0xb21000cc  0x00000028
+0xb21000d0  0x80030138
+0xb21000d4  0x00000003
+0xb21000d8  0x0000002a
+0xb21000dc  0x00000006
+0xb21000e4  0x00000000
+0xb21000e8  0x00000006
+0xb21000ec  0x00000005
+0xb21000f0  0x00000012
+0xb21000f4  0x00000018
+0xb21000f8  0x00000006
+0xb21000fc  0x00000004
+0xb2100100  0x00000004
+0xb21000e0  0x00000002
+0xb2100104  0x00000006
+0xb2100108  0x00000004
+0xb210010c  0x000000c8
+0xb2100110  0x00000003
+0xb2100120  0x00000004
+0xb2100124  0x00000000
+0xb2100128  0x00000000
+0xb2100130  0x00000000
+0xb210012c  0x00000003
+0xb21000c8  0x00000000
+0xb2100134  0x00000000
+0xb2100118  0x00000000
+0xb2100138  0x00000000
+0xb2100114  0x00000003
+0xb210011c  0x00000000
+0xb2100140  0x00000000
+0xb2100144  0x00000000
+0xb2100148  0x00000000
+0xb2100000  0x00004780
+0xb2100254  0x00000001
+0xb2100260  0x00000003
+0xb2100258  0x00000003
+0xb2100250  0x00000001
+0xb2100264  0x0000000f
+0xb21002d4  0x00000002
+0xb21002d0  0x00000002
+0xb2100240  0x00000002
+0xb2100284  0x00000040
+0xb2100290  0x00000007
+0xb2100040  0x86f00000
+
+0xb2100041  0x06f00000
+
+0xb2100040  0x80f00001
+
+0xb2100041  0x00f00001
+
+0xb2100040  0x80f40003
+
+0xb2100041  0x00f40003
+
+0xb2100040  0x80f60003
+
+0xb2100041  0x00f60003
+
+0xb2100040  0x80f20003
+
+0xb2100041  0x00f20003
+
+0xb2100040  0x80f0b623
+
+0xb2100041  0x00f0b623
+
+0xb2100040  0x80f00001
+
+0xb2100041  0x00f00001
+
+0xb2100040  0x80f00002
+
+0xb2100041  0x00f00002
+
+0xb2100040  0x80f00002
+
+0xb2100041  0x00f00002
+
+0xb2100040  0x80f0a623
+
+0xb2100041  0x00f0a623
+
+0xb2100040  0x80f20003
+
+0xb2100041  0x00f20003
+
+0xb2100040  0x80f00005
+
+0xb2100041  0x00f00005
+
+0xb2100040  0x80f0000a
+
+0xb2100041  0x00f0000a
+
+0xb2100004  0x00000001
+
+0xb2100009  0x00000001
+
+0xb2100084  0x00000000
+0xb21002c4  0x00000007
+0xb21002c8  0x00000003
+0xb21002d8  0x00000000
+0xb21002f0  0x00070101
+0xb2100180  0x00000000
+0xb2100290  0x00000003
+0xb2100050  0x00000001
+
+0xb210004d  0x00000001
+
+0xb2000004  0x00000200
+0xb2000004  0x00000400
+0xb2000004  0x00000800
+0xb2000004  0x00001000
+0xb2000004  0x00002000
+0xb2000004  0x00004000
+0xb2000004  0x00008000
+0xb2100004  0x00000002
+
+
diff --git a/board/grx500/init_ddr.c b/board/grx500/init_ddr.c
new file mode 100644
--- /dev/null
+++ b/board/grx500/init_ddr.c
@@ -0,0 +1,1460 @@
+/************************************************************************
+ *
+ *  init_ddr.c
+ *
+ *  Configuration of Synopsys' DDR3 Controller+PHY
+ *
+ ************************************************************************/
+
+/************************************************************************
+ *  Include files
+ ************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include "init_ddr.h"
+
+#define asc_puts printf
+#define print_u32(A) (printf("%d\n", (A)))
+#define print_u16(A) (printf("%d\n", (A)))
+#define print_u8(A) (printf("%d\n", (A)))
+#define REG32
+
+/************************************************************************
+ * typedef Definition
+ ************************************************************************/
+typedef unsigned char u8;
+typedef unsigned int u32;
+
+struct ddr_settings {
+	u32 xDDR_TOGCNT1U;
+	u32 xDDR_TOGCNT100N;
+	u32 xDDR_TREFPRD;
+	u32 xDDR_TRAS;
+	u32 xDDR_TRC;
+	u32 xDDR_TFAW;
+	u32 xDDR_TRRD;
+	u32 xDDR_TFAW_CFG;
+	u32 xDDR_TFAW_CFG_OFF;
+	u32 xDDR_TRFC;
+	u32 xDDR_TXSNR;
+	u32 xDDR_TEFI_MEM_DDR3;
+	u32 xDDR_BANKSZ;
+	u32 xDDR_TINIT;
+	u32 xDDR_TRSTH;
+	u32 xDDR_TRSTL;
+	u32 xDDR_TRP;
+	u32 xDDR_TAL;
+	u32 xDDR_TCL;
+	u32 xDDR_DFITPHYWRLAT;
+	u32 xDDR_DFITRDDATAEN;
+	u32 xDDR_TCWL;
+	u32 xDDR_TRCD;
+	u32 xDDR_TRTP;
+	u32 xDDR_TRTW;
+	u32 xDDR_TWR;
+	u32 xDDR_TWTR;
+	u32 xDDR_TEXSR;  
+	u32 xDDR_TDQS;   
+	u32 xDDR_TCKSRE; 
+	u32 xDDR_TCKSRX; 
+	u32 xDDR_TMOD;   
+	u32 xDDR_TCKE;   
+	u32 xDDR_TZQCS;  
+	u32 xDDR_TZQCL;  
+	u32 xDDR_TZQCSI; 
+	u32 xDDR_TCKESR; 
+	u32 xDDR_TDPD;   
+	u32 xDDR_TREFI_N;
+	u32 xDDR_TREFI_C;
+	u32 xDDR_TMRD;   
+	u32 xDDR_TCCD;   
+	u32 xDDR_TDLLK;  
+	u32 xDDR_TXPDLL; 
+	u32 xDDR_TXP;    
+	u32 xDDR_TXSDLL; 
+	u32 xDDR_TXSRD;  
+	u32 xDDR_TXS;    
+	u32 xDDR_DCR;    
+	
+	u32 xDDR_MR0;   
+	u32 xDDR_MR1; 	
+	u32 xDDR_MR2;    
+	u32 xDDR_MR3;    	
+	u32 xDDR_TWLMRD; 	
+	u32 xDDR_TWLO;   	
+	u32 xDDR_TAOND;  	
+	u32 xDDR_TPHYRST;	
+	u32 xDDR_TPLLGS; 
+	u32 xDDR_TPLLPD; 
+	u32 xDDR_TPLLRST;
+	u32 xDDR_TPLLLOCK;
+	u32 xDDR_TCALON; 	
+	u32 xDDR_TCALS;  	
+	u32 xDDR_TCALH;  	
+	u32 xDDR_TWLDLYS;		
+	u32 xDDR_TDINIT0;	
+	u32 xDDR_TDINIT1;	
+	u32 xDDR_TDINIT2;	
+	u32 xDDR_TDINIT3;	
+
+	u32 xMM_DRAMCONFIG;	
+	u32 xMM_SWAP0_H;
+	u32 xMM_SWAP0_L;
+};
+
+void mem_t(struct ddr_settings * ds);
+void dfi_t(struct ddr_settings * ds);
+void memmax_init(struct ddr_settings * ds);
+void fmt_init(void);
+void init_ddr(int id);
+void seed(u8 lane, u8 seedw, u8 seedr);
+void prt_bdl(u8 lane);
+int mtest(void);
+ 
+/************************************************************************
+ *  Global variables
+ ************************************************************************/
+ 
+int gate_ext = 1; 
+FILE * fp;
+ 
+/* Defaul Value Assigned for 512MB DDR3 9-9-9 667MHz single rank*/ 
+int ddr_type = 3;
+int ddr_grade = 6;
+int ddr_density = 8;
+int ddr_blen = 8;
+int ddr_rank = 1;
+int ddr_al = 1;
+int endianness = 1;
+int fcps = 3;
+int fsl = 8;
+int fngi = 6;
+int fcbm = 6;
+int fcps2 = 1;
+int fdctl = 5;
+int fgsw = 5;
+int fgswr = 6;
+int cgu_pll0a_cfg1 = 0x40403866;		//cpu/ sl/ngi/cbm =  600/200/300/300 MHz
+int cgu_pll0b_cfg1 = 0x40401556;		//cpu/ddr/gsw/mii = 1000/250/330/250 MHz		
+int sr0[2] = {24, 24};
+int sr1[2] = {24, 24};
+int g_output = 0;
+
+static char filename[100];
+
+/************************************************************************
+ *  Static variables
+ ************************************************************************/
+static char *Progname = "init_ddr";
+
+/************************************************************************
+ *  Static function prototypes
+ ************************************************************************/
+extern  u32 dl;
+static void __delay(void);
+
+static void __prt_wr(char* s, u32 addr, u32 cmd){
+	if (g_output == 1) {
+		fprintf(fp, "0x%X    0x%X\n%", (addr), (cmd));
+	}
+}
+
+static void __prt_rd(char* s, u32 addr, u32 read_reg){
+	if (g_output == 1) {
+		fprintf(fp, "0x%X    0x%X\n%", (addr+1), read_reg);
+	}
+}
+ 
+static void __delay(void) {
+	__prt_wr("", 0x80000000, 0xFFFF);
+}
+
+static void setup_ddr(struct ddr_settings *ds) {
+	/* DDR2 */
+	if ((ddr_type)==2) {
+		if ((ddr_grade)<2) {	  							//f=200MHz, tCK=5nS, 3-3-3 
+			ds->xDDR_TOGCNT1U      = 100;		 			// 100*2*5=1uS (based on n_clk)
+			ds->xDDR_TOGCNT100N    = 10; 					//  10*2*5=100nS 
+			ds->xDDR_TREFPRD       = 14080; 				//9*7800/5=28080
+			ds->xDDR_TRAS          = 8;						//min=40nS
+			ds->xDDR_TRC           = 11;					//min=55nS
+			ds->xDDR_TFAW          = ((ddr_density)<2)?(8):((ddr_density)%2==0)?(10):(8);		//tFAW=37.5-50nS
+			ds->xDDR_TRRD          = 2;																	//10nS all cases
+			ds->xDDR_TFAW_CFG      = 5;
+			ds->xDDR_TFAW_CFG_OFF  = ((ddr_density)<2)?(2):((ddr_density)%2==0)?(0):(2);
+			ds->xDDR_TRFC          = ((ddr_density)<2)?(15):((ddr_density)<4)?(21):((ddr_density)<6)?(26):((ddr_density)<8)?(39):(66);
+			ds->xDDR_TXSNR         = ((ddr_density)<2)?(17):((ddr_density)<4)?(23):((ddr_density)<6)?(28):((ddr_density)<8)?(41):(68);
+		} else 
+		if ((ddr_grade)<4) {	  							//f=266MHz, tCK=3.75nS, 4-4-4 
+			ds->xDDR_TOGCNT1U      = 133;		 			// 133*2*3.75=1uS (based on n_clk)
+			ds->xDDR_TOGCNT100N    = 13; 					//  13*2*3.75=100nS 
+			ds->xDDR_TREFPRD       = 18720; 				//9*7800/3.75=18720
+			ds->xDDR_TRAS          = 12;					//min=45nS
+			ds->xDDR_TRC           = 16;  					//min=60nS
+			ds->xDDR_TFAW          = ((ddr_density)<2)?(10):((ddr_density)%2==0)?(14):(10);	//tFAW=37.5-50nS
+			ds->xDDR_TRRD          = ((ddr_density)<2)?(2):((ddr_density)%2==0)?(3):(2);		//7.5-10nS, page always 1K for 256Mb         
+			ds->xDDR_TFAW_CFG      = 5;
+			ds->xDDR_TFAW_CFG_OFF  = ((ddr_density)<2)?(0):((ddr_density)%2==0)?(1):(0);       
+			ds->xDDR_TRFC          = ((ddr_density)<2)?(20):((ddr_density)<4)?(28):((ddr_density)<6)?(34):((ddr_density)<8)?(52):(88);
+			ds->xDDR_TXSNR         = ((ddr_density)<2)?(23):((ddr_density)<4)?(31):((ddr_density)<6)?(37):((ddr_density)<8)?(55):(91);
+		} else
+		if ((ddr_grade)<6) {	 	  						//f=333MHz, tCK=3nS, 4-4-4/5-5-5 
+			ds->xDDR_TOGCNT1U      = 167;		 			// 167*2*3=1uS (based on n_clk)
+			ds->xDDR_TOGCNT100N    = 17 ;					//  17*2*3=100nS 
+			ds->xDDR_TREFPRD       = 23400; 				//9*7800/3=23400
+			ds->xDDR_TRAS          = 15;					//min=45nS
+			ds->xDDR_TRC           = 19+(((ddr_grade))-4);	//min=57(4-4-4)/60nS(5-5-5)
+			ds->xDDR_TFAW          = ((ddr_density)<2)?(13):((ddr_density)%2==0)?(17):(13);	//tFAW=37.5-50nS
+			ds->xDDR_TRRD          = ((ddr_density)<2)?(3):((ddr_density)%2==0)?(4):(3);		//7.5-10nS, page always 1K for 256Mb
+			ds->xDDR_TFAW_CFG      = 5;
+			ds->xDDR_TFAW_CFG_OFF  = ((ddr_density)<2)?(2):((ddr_density)%2==0)?(3):(2);       
+			ds->xDDR_TRFC          = ((ddr_density)<2)?(25):((ddr_density)<4)?(35):((ddr_density)<6)?(43):((ddr_density)<8)?(65):(109);
+			ds->xDDR_TXSNR         = ((ddr_density)<2)?(29):((ddr_density)<4)?(39):((ddr_density)<6)?(47):((ddr_density)<8)?(69):(113);
+		} else 
+		if ((ddr_grade)<8) {	 	  						//f=400MHz, tCK=2.5nS, 5-5-5/6-6-6 
+			ds->xDDR_TOGCNT1U      = 200;		 			// 200 *2*2.5=1uS (based on n_clk)
+			ds->xDDR_TOGCNT100N    = 20; 					//  20 *2*2.5=100nS 
+			ds->xDDR_TREFPRD       = 28080; 				//9*7800/2.5=28080
+			ds->xDDR_TRAS          = 18;					//min=45nS
+			ds->xDDR_TRC           = 23+(((ddr_grade))-6);	//min=57.5(5-5-5)/60nS(6-6-6)
+			ds->xDDR_TFAW          = ((ddr_density)<2)?(14):((ddr_density)%2==0)?(18):(14);	//tFAW=35-45nS
+			ds->xDDR_TRRD          = ((ddr_density)<2)?(3):((ddr_density)%2==0)?(4):(3);		//7.5-10nS, page always 1K for 256Mb         
+			ds->xDDR_TFAW_CFG      = 5;
+			ds->xDDR_TFAW_CFG_OFF  = ((ddr_density)<2)?(1):((ddr_density)%2==0)?(2):(1);          
+			ds->xDDR_TRFC          = ((ddr_density)<2)?(30):((ddr_density)<4)?(42):((ddr_density)<6)?(51):((ddr_density)<8)?(78):(131);
+			ds->xDDR_TXSNR         = ((ddr_density)<2)?(34):((ddr_density)<4)?(46):((ddr_density)<6)?(55):((ddr_density)<8)?(82):(135);
+		} else {
+			 				 	  							//f=533MHz, tCK=1.87nS, 7-7-7 
+			ds->xDDR_TOGCNT1U      = 267;		 			// 268*2*1.876=1uS (based on n_clk)
+			ds->xDDR_TOGCNT100N    = 27; 					//  27*2*1.876=100nS 
+			ds->xDDR_TREFPRD       = 37416; 				//9*7800/1.876=37540
+			ds->xDDR_TRAS          = 24;					//min=45nS
+			ds->xDDR_TRC           = 31;  					//min=58.125nS				
+			ds->xDDR_TFAW          = ((ddr_density)<2)?(19):((ddr_density)%2==0)?(24):(19);	//tFAW=35-45nS
+			ds->xDDR_TRRD          = ((ddr_density)<2)?(4):((ddr_density)%2==0)?(6):(4);		//7.5-10nS, page always 1K for 256Mb        
+			ds->xDDR_TFAW_CFG      = ((ddr_density)<2)?(5):((ddr_density)%2==0)?(4):(5);
+			ds->xDDR_TFAW_CFG_OFF  = ((ddr_density)<2)?(1):((ddr_density)%2==0)?(0):(1);     
+			ds->xDDR_TRFC          = ((ddr_density)<2)?(40):((ddr_density)<4)?(57):((ddr_density)<6)?(68):((ddr_density)<8)?(102):(175);
+			ds->xDDR_TXSNR         = ((ddr_density)<2)?(46):((ddr_density)<4)?(63):((ddr_density)<6)?(74):((ddr_density)<8)?(108):(181);
+		}
+
+		ds->xDDR_TEFI_MEM_DDR3 = 0;
+		ds->xDDR_BANKSZ        = ((ddr_density)<4)?(4):(8);
+		ds->xDDR_TINIT         = 200;     
+		ds->xDDR_TRSTH         = 0;
+		ds->xDDR_TRSTL         = 0;
+		ds->xDDR_TAL           = (ddr_al);			
+		ds->xDDR_TCL           = ((ddr_grade)<2)?(3):((ddr_grade)<4)?(4):((ddr_grade)<6)?((ddr_grade)):((ddr_grade)<8)?(((ddr_grade))-(1)):(7);
+		ds->xDDR_TRP           = ((ds->xDDR_BANKSZ)==8)?((1<<16)+(ds->xDDR_TCL)):(ds->xDDR_TCL);
+
+		ds->xDDR_TCWL          = ((ds->xDDR_TCL)-(1));
+
+		ds->xDDR_DFITPHYWRLAT  = (((((ds->xDDR_TCWL)+(ds->xDDR_TAL))-(1))>>1)-(1));
+		ds->xDDR_DFITRDDATAEN  = (((((ds->xDDR_TCWL)+(ds->xDDR_TAL)))>>1)-(1));
+
+		ds->xDDR_TRCD          = (ds->xDDR_TCL);
+		ds->xDDR_TRTP          = ((ddr_grade)<2)?(2):((ddr_grade)<4)?(2):((ddr_grade)<6)?(3):((ddr_grade)<9)?(3):(4);
+		ds->xDDR_TRTW          = 4; 	
+		ds->xDDR_TWR           = ((ddr_grade)<2)?(3):((ddr_grade)<4)?(4):((ddr_grade)<6)?(5):((ddr_grade)<9)?(6):(8);
+		ds->xDDR_TWTR          = (ds->xDDR_TRTP);
+		ds->xDDR_TEXSR         = 200;
+		ds->xDDR_TDQS          = 5;
+		ds->xDDR_TCKSRE        = 0;
+		ds->xDDR_TCKSRX        = 0;
+		ds->xDDR_TMOD          = 0;
+		ds->xDDR_TCKE          = 3;
+		ds->xDDR_TZQCS         = 0;
+		ds->xDDR_TZQCL         = 0;
+		ds->xDDR_TZQCSI        = 0;
+		ds->xDDR_TCKESR        = 0;
+		ds->xDDR_TDPD          = 0;
+		ds->xDDR_TREFI_N       = 2;
+		ds->xDDR_TREFI_C       = (78*(ds->xDDR_TREFI_N));
+		ds->xDDR_TMRD          = 2;
+		ds->xDDR_TCCD          = 4;
+		ds->xDDR_TDLLK         = 512;
+		ds->xDDR_TXPDLL        = ((ddr_grade)<2)?(5):((ddr_grade)<4)?(7):((ddr_grade)<6)?(8):((ddr_grade)<9)?(10):(13);
+		ds->xDDR_TXP           = 2;
+		ds->xDDR_TXSDLL        = 3;
+		ds->xDDR_TXSRD         = 200;
+		ds->xDDR_TXS           = (ds->xDDR_TXSRD);
+		ds->xDDR_DCR           = 0x1000040a;
+		ds->xDDR_MR0           = (((ddr_blen)==8)?(3):(2)) + ((ds->xDDR_TCL)<<4) + (((ds->xDDR_TWR)-1)<<9) + (0x100);
+
+		if ((ddr_grade)<6)
+			ds->xDDR_MR1       = (((ddr_al)<<3) + (0x04));		//  75Ohm, full drive
+		else
+			ds->xDDR_MR1       = (((ddr_al)<<3) + (0x40));		// 150Ohm, full drive
+
+		ds->xDDR_MR2           = 0;
+		ds->xDDR_MR3           = 0;
+
+		ds->xDDR_TWLMRD        = 0;
+		ds->xDDR_TWLO          = 0;
+		ds->xDDR_TAOND         = 0;
+
+		ds->xDDR_TPHYRST       = 16;
+		ds->xDDR_TPLLPD        = ((ddr_grade)<2)?(100):((ddr_grade)<4)?(133):((ddr_grade)<6)?(167):((ddr_grade)<8)?(200):(266); //1uS
+		ds->xDDR_TPLLGS        = (4*(ds->xDDR_TPLLPD));
+		ds->xDDR_TPLLRST       = (3*(ds->xDDR_TPLLPD));
+		ds->xDDR_TPLLLOCK      = (100*(ds->xDDR_TPLLPD));
+
+		ds->xDDR_TCALON 	   = 15;
+		ds->xDDR_TCALS         = 15;
+		ds->xDDR_TCALH         = 15;
+		ds->xDDR_TWLDLYS       = 16;
+	
+		ds->xDDR_TDINIT0       = (1000*(ds->xDDR_TPLLPD));
+		ds->xDDR_TDINIT1       = ((ds->xDDR_TRFC)+(10));
+		ds->xDDR_TDINIT2       = (400*(ds->xDDR_TPLLPD));
+		ds->xDDR_TDINIT3       = (2*(ds->xDDR_TPLLPD));
+
+		ds->xMM_DRAMCONFIG     = (0x100c0020)+(((ddr_blen)==8)?(0x100):(0))+(((ds->xDDR_BANKSZ)==8)?(1):(0));
+
+		if (ddr_rank==1) {
+			ds->xMM_SWAP0_H    = ((ddr_density)<1)?(0x0011634c):((ddr_density)<3)?(0x00000117):((ddr_density)<4)?(0x000000d9):(0);
+			ds->xMM_SWAP0_L    = ((ddr_density)<1)?(0x016c420a):((ddr_density)<3)?(0x0d30324b):((ddr_density)<4)?(0x0f30324b):
+                          			((ddr_density)<5)?(0x0461128b):((ddr_density)<7)?(0x0369228b):((ddr_density)<9)?(0x0001528b):(0x01fd428b);
+		} else {
+			ds->xMM_SWAP0_H    = ((ddr_density)<1)?(0x0011634c):((ddr_density)<3)?(0x00000117):((ddr_density)<4)?(0x000000d9):(0);
+			ds->xMM_SWAP0_L    = ((ddr_density)<1)?(0x016c420a):((ddr_density)<3)?(0x0d30324b):((ddr_density)<4)?(0x0f30324b):
+                          			((ddr_density)<5)?(0x0461128b):((ddr_density)<7)?(0x0369228b):(0x0001528b);    
+		}
+	} else {
+	/* DDR3 */
+
+/************************
+*  ONLY FOR ddr_type 3  *
+************************/
+		if ((ddr_grade)<2){ 	  							//f=400MHz, tCK=2.5nS, 5-5-5/6-6-6 
+			ds->xDDR_TOGCNT1U      = 200;		 			// 200*2*2.5=1uS		(based on n_clk)
+			ds->xDDR_TOGCNT100N    = 20; 					//  20*2*2.5=100nS 
+			ds->xDDR_TEFI_MEM_DDR3 = 3120;					//7800  /2.5=3120
+			ds->xDDR_TREFPRD       = 28080; 				//9*7800/2.5=28080
+			ds->xDDR_TRAS          = 15;
+			ds->xDDR_TRC           = (20)+((ddr_grade));
+			ds->xDDR_TFAW          = ((ddr_density)%2==0)?(20):(16);							//tFAW=40-50nS
+			ds->xDDR_TRRD          = 4;																//10nS all sizes
+			ds->xDDR_TFAW_CFG      = ((ddr_density)%2==0)?(5):(4);							
+			ds->xDDR_TFAW_CFG_OFF  = 0;
+			ds->xDDR_TRFC          = ((ddr_density)<4)?(36):((ddr_density)<6)?(44):((ddr_density)<8)?(64):((ddr_density)<10)?(104):(140);
+			ds->xDDR_TXS           = ((ddr_density)<4)?(40):((ddr_density)<6)?(48):((ddr_density)<8)?(68):((ddr_density)<10)?(108):(144);
+		} else	
+		if ((ddr_grade)<5){		  							//f=533MHz, tCK=1.87nS, 7-7-7/8-8-8 
+			ds->xDDR_TOGCNT1U      = 267;		 			// 268*2*1.876=1uS		(based on n_clk)
+			ds->xDDR_TOGCNT100N    = 27; 					//  27*2*1.876=100nS 
+			ds->xDDR_TEFI_MEM_DDR3 = 4157;					//7800  /1.876=4172
+			ds->xDDR_TREFPRD       = 37416; 				//9*7800/1.876=37540
+			ds->xDDR_TRAS          = 20;
+			ds->xDDR_TRC           = (26)+((ddr_grade)-2);
+			ds->xDDR_TFAW          = ((ddr_density)>9)?(27):((ddr_density)%2==0)?(27):(20);	//tFAW=37.5-50nS
+			ds->xDDR_TRRD          = ((ddr_density)>9)?(6):((ddr_density)%2==0)?(6):(4);		//7.5-10nS, page always 2K for 8Gb
+			ds->xDDR_TFAW_CFG      = 5;
+			ds->xDDR_TFAW_CFG_OFF  = ((ddr_density)>9)?(3):((ddr_density)%2==0)?(3):(0);
+			ds->xDDR_TRFC          = ((ddr_density)<4)?(48):((ddr_density)<6)?(59): ((ddr_density)<8)?(86):((ddr_density)<10)?(139):(187);
+			ds->xDDR_TXS           = ((ddr_density)<4)?(54):((ddr_density)<6)?(65): ((ddr_density)<8)?(72):((ddr_density)<10)?(145):(193);
+		} else 
+		if ((ddr_grade)<8){	 	  							//f=667MHz, tCK=1.5nS, 9-9-9/10-10-10 
+			ds->xDDR_TOGCNT1U      = 333;		 			// 333*2*1.5=1uS 		(based on n_clk)
+			ds->xDDR_TOGCNT100N    = 33; 					//  33*2*1.5=100nS 
+			ds->xDDR_TEFI_MEM_DDR3 = 5208;					//7800  /1.5=5208
+			ds->xDDR_TREFPRD       = 46800 ;				//9*7800/1.5=46800
+			ds->xDDR_TRAS          = 24;
+			ds->xDDR_TRC           = (32)+((ddr_grade)-5);
+			ds->xDDR_TFAW          = ((ddr_density)>9)?(30):((ddr_density)%2==0)?(30):(20);	//tFAW=30-45nS
+			ds->xDDR_TRRD          = ((ddr_density)>9)?(5):((ddr_density)%2==0)?(5):(4);	//6-7.5nS, page always 2K for 8Gb
+			ds->xDDR_TFAW_CFG      = ((ddr_density)>9)?(6):((ddr_density)%2==0)?(6):(5);
+			ds->xDDR_TFAW_CFG_OFF  = 0;
+			ds->xDDR_TRFC          = ((ddr_density)<4)?(60):((ddr_density)<6)?(74):((ddr_density)<8)?(107):((ddr_density)<10)?(174):(234);
+			ds->xDDR_TXS           = ((ddr_density)<4)?(66):((ddr_density)<6)?(80):((ddr_density)<8)?(113):((ddr_density)<10)?(180):(240);
+		} else {
+			 				 	  							//f=800MHz, tCK=1.25nS, 10-10-10/11-11-11 
+			ds->xDDR_TOGCNT1U      = 400;		 			//400  *2*1.25=1uS 		(based on n_clk)
+			ds->xDDR_TOGCNT100N    = 40; 					// 40  *2*1.25=100nS 
+			ds->xDDR_TEFI_MEM_DDR3 = 6240;					//7800   /1.25=6240
+			ds->xDDR_TREFPRD       = 56160; 				//9*7800 /1.25=56160
+			ds->xDDR_TRAS          = 28;
+			ds->xDDR_TRC           = (37)+((ddr_grade)-8);
+			ds->xDDR_TFAW          = ((ddr_density)>9)?(32):((ddr_density)%2==0)?(32):(24);	//tFAW=30-40nS
+			ds->xDDR_TRRD          = ((ddr_density)>9)?(6):((ddr_density)%2==0)?(6):(5);	//6-7.5nS, page always 2K for 8Gb
+			ds->xDDR_TFAW_CFG      = ((ddr_density)>9)?(6):((ddr_density)%2==0)?(6):(5);
+			ds->xDDR_TFAW_CFG_OFF  = ((ddr_density)>9)?(4):((ddr_density)%2==0)?(4):(1);
+			ds->xDDR_TRFC          = ((ddr_density)<4)?(72):((ddr_density)<6)?(88):((ddr_density)<8)?(128):((ddr_density)<10)?(208):(280);
+			ds->xDDR_TXS           = ((ddr_density)<4)?(80):((ddr_density)<6)?(96):((ddr_density)<8)?(136):((ddr_density)<10)?(216):(288);
+		}
+
+		ds->xDDR_BANKSZ        = 8;
+
+		ds->xDDR_TINIT         = 200;      
+		ds->xDDR_TRSTH         = 500;  
+		ds->xDDR_TRSTL         = ((ddr_grade)<2)?(42):((ddr_grade)<5)?(55):((ddr_grade)<8)?(68):(82);	//100nS + 2CK
+		ds->xDDR_TCL           = ((ddr_grade)<2)?(((ddr_grade))+5):((ddr_grade)<5)?(((ddr_grade))+4):((ddr_grade)<8)?
+                          			(((ddr_grade))+3):(((ddr_grade))+1);
+		ds->xDDR_TAL           = ((ddr_al)>0)?((ds->xDDR_TCL)-(ddr_al)):(0); 
+		ds->xDDR_TRP           = (ds->xDDR_TCL);
+
+		ds->xDDR_TCWL          = ((ddr_grade)<2)?(5):((ddr_grade)<5)?(6):((ddr_grade)<8)?(7):(8);
+                         	
+		ds->xDDR_DFITPHYWRLAT  = (((((ds->xDDR_TCWL)+(ds->xDDR_TAL))-(1))>>1)-(1));
+		ds->xDDR_DFITRDDATAEN  = ((ddr_al)>0)?((ds->xDDR_TCL)-(ddr_al)-(1)):							
+                          			(((ddr_grade)<3)?(1):((ddr_grade)<6)?(2):((ddr_grade)<10)?(3):(4));	
+
+		ds->xDDR_TRCD          = (ds->xDDR_TCL);
+		ds->xDDR_TRTP          = ((ddr_grade)<2)?(4):((ddr_grade)<5)?(5):((ddr_grade)<8)?(5):(6);	
+		ds->xDDR_TRTW          = 4;
+		ds->xDDR_TWR           = ((ddr_grade)<2)?(6):((ddr_grade)<5)?(8):((ddr_grade)<8)?(10):(12);	
+		ds->xDDR_TWTR          = (ds->xDDR_TRTP);
+		ds->xDDR_TEXSR         = 512;
+		ds->xDDR_TDQS          = 5;
+		ds->xDDR_TCKSRE        = ((ddr_grade)<2)?(5):((ddr_grade)<5)?(6):((ddr_grade)<8)?(7):(8);	
+		ds->xDDR_TCKSRX        = (ds->xDDR_TCKSRE);
+		ds->xDDR_TMOD          = 12;																
+		ds->xDDR_TCKE          = ((ddr_grade)<2)?(3):((ddr_grade)<5)?(4):((ddr_grade)<8)?(4):(4);	
+		ds->xDDR_TZQCS         = 64;
+		ds->xDDR_TZQCL         = 512;
+		ds->xDDR_TZQCSI        = 5;
+		ds->xDDR_TCKESR        = ((ds->xDDR_TCKE)+(1));
+		ds->xDDR_TDPD          = 0;
+		ds->xDDR_TREFI_N       = 2;
+		ds->xDDR_TREFI_C       = (78*(ds->xDDR_TREFI_N));
+		ds->xDDR_TMRD          = 4;
+		ds->xDDR_TCCD          = 4;
+		ds->xDDR_TDLLK         = 512;
+		ds->xDDR_TXPDLL        = ((ddr_grade)<2)?(10):((ddr_grade)<5)?(13):((ddr_grade)<8)?(16):(20);
+		ds->xDDR_TXP           = ((ddr_grade)<2)?(3):((ddr_grade)<5)?(5):((ddr_grade)<8)?(4):(5);	
+		ds->xDDR_TXSDLL        = (ds->xDDR_TDLLK);
+		ds->xDDR_DCR           = 0x1000040b;                        
+		ds->xDDR_MR0           = (((ddr_blen)==8)?(0):((ddr_blen)==4)?(0):(1)) + 
+                          			(((ds->xDDR_TCL)<=11)?(((ds->xDDR_TCL)-4)<<4):((((ds->xDDR_TCL)-11)<<4) + (4))) + ((1)<<8) + 
+                          			(((ds->xDDR_TWR)<= 8)?(((ds->xDDR_TWR)-4)<<9):(((ds->xDDR_TWR)>>1)<<9));
+ 
+		if ((ddr_grade)<8) {
+			ds->xDDR_MR1	   = (((ddr_al)<<3) + (0x46));											//ODS=34 Ohm, Rtt=34hm (667MHz)
+			ds->xDDR_MR2	   = ((((ds->xDDR_TCWL)-5)<<3) + (0x200));								//Dyn ODT Rtt = 60 Ohm  
+		} else {                        
+			ds->xDDR_MR1	   = (((ddr_al)<<3) + (0x44));											//ODS=40 Ohm, Rtt=40 Ohm (800MHz)
+			ds->xDDR_MR2	   = ((((ds->xDDR_TCWL)-5)<<3) + (0x400));								//Dyn ODT Rtt = 120 Ohm
+		}
+
+		ds->xDDR_MR3           = 0;
+
+		ds->xDDR_TWLMRD        = 40;
+		ds->xDDR_TWLO          = 8;
+		ds->xDDR_TAOND         = 0;
+
+		ds->xDDR_TPHYRST       = 16	;
+		ds->xDDR_TPLLPD        = ((ddr_grade)<2)?(200):((ddr_grade)<5)?(266):((ddr_grade)<8)?(333):(400);
+		ds->xDDR_TPLLGS        = (4*(ds->xDDR_TPLLPD));
+		ds->xDDR_TPLLRST       = (3*(ds->xDDR_TPLLPD));
+		ds->xDDR_TPLLLOCK      = (100*(ds->xDDR_TPLLPD));
+
+		ds->xDDR_TCALON 	   = 15;			
+		ds->xDDR_TCALS         = 15;
+		ds->xDDR_TCALH         = 15;
+		ds->xDDR_TWLDLYS       = 16;
+	
+		ds->xDDR_TDINIT0       = (1000*(ds->xDDR_TPLLPD));
+		ds->xDDR_TDINIT1       = (ds->xDDR_TRFC)+(10);
+		ds->xDDR_TDINIT2       = (400*(ds->xDDR_TPLLPD));
+		ds->xDDR_TDINIT3       = (2*(ds->xDDR_TPLLPD));
+
+		ds->xMM_DRAMCONFIG     = (0x100c0030)+(((ddr_blen)==8)?(0x100):(0))+(((ds->xDDR_BANKSZ)==8)?(1):(0));
+
+		if ((ddr_rank)==1) {
+			ds->xMM_SWAP0_H    = 0;
+			ds->xMM_SWAP0_L    = ((ddr_density)<3)?(0x0559028b):((ddr_density)<5)?(0x0461128b):((ddr_density)<7)?
+						  			(0x0369228b):((ddr_density)<9)?(0x01528b):(0x01fd428b);
+		} else {
+			ds->xMM_SWAP0_H    = 0;
+			ds->xMM_SWAP0_L    = ((ddr_density)<3)?(0x0559028b):((ddr_density)<5)?(0x0461128b):((ddr_density)<7)?
+								  (0x0369228b):(0x01528b);
+		}
+	}
+}
+
+/***** functions ******/
+void seed(u8 lane, u8 seedw, u8 seedr){
+	u32 xw, xr, x2;
+	u32 cmd;
+	xw = (seedw<<24) + (seedw<<18) + (seedw<<12) + (seedw<<6) + seedw; 
+	x2 = (seedr<<18) + (seedr<<12) + (seedw<<6) + seedw; 
+	xr = (seedr<<24) + (seedr<<18) + (seedr<<12) + (seedr<<6) + seedr; 
+	
+	if (lane==0){
+		cmd = xw;
+		__prt_wr("PUB_DX0BDLR0", PUB_DX0BDLR0_REG_addr, cmd);
+		cmd = xw;
+		__prt_wr("PUB_DX0BDLR1", PUB_DX0BDLR1_REG_addr, cmd);
+		cmd = x2;
+		__prt_wr("PUB_DX0BDLR2", PUB_DX0BDLR2_REG_addr, cmd);
+		cmd = xr;
+		__prt_wr("PUB_DX0BDLR3", PUB_DX0BDLR3_REG_addr, cmd);
+		cmd = xr;
+		__prt_wr("PUB_DX0BDLR4", PUB_DX0BDLR4_REG_addr, cmd);
+	} else {
+		cmd = xw;
+		__prt_wr("PUB_DX1BDLR0", PUB_DX1BDLR0_REG_addr, cmd);
+		cmd = xw;   
+		__prt_wr("PUB_DX1BDLR1", PUB_DX1BDLR1_REG_addr, cmd);
+		cmd = x2;  
+		__prt_wr("PUB_DX1BDLR2", PUB_DX1BDLR2_REG_addr, cmd);
+		cmd = xr;
+		__prt_wr("PUB_DX1BDLR3", PUB_DX1BDLR3_REG_addr, cmd);
+		cmd = xr;
+		__prt_wr("PUB_DX1BDLR4", PUB_DX1BDLR4_REG_addr, cmd);
+	}	
+}
+
+void mem_t(struct ddr_settings * ds){
+    u32 cmd;
+    cmd = (0x80000000 + (((ds->xDDR_TREFI_N)-1)<<16) + (ds->xDDR_TREFI_C));	
+    __prt_wr("TREFI", TREFI_REG_addr, cmd);			
+    cmd = (ds->xDDR_TMRD);
+    __prt_wr("TMRD", TMRD_REG_addr, cmd);
+    cmd = (ds->xDDR_TRFC);
+    __prt_wr("TRFC", TRFC_REG_addr, cmd);
+    cmd = (ds->xDDR_TRP);
+    __prt_wr("TRP", TRP_REG_addr, cmd);
+    cmd = (ds->xDDR_TAL);
+    __prt_wr("TAL", TAL_REG_addr, cmd);
+    cmd = (ds->xDDR_TCL);
+    __prt_wr("TCL", TCL_REG_addr, cmd);
+    cmd = (ds->xDDR_TCWL);
+    __prt_wr("TCWL", TCWL_REG_addr, cmd);
+    cmd = (ds->xDDR_TRAS);
+    __prt_wr("TRAS", TRAS_REG_addr, cmd);
+    cmd = (ds->xDDR_TRC);
+    __prt_wr("TRC", TRC_REG_addr, cmd);
+    cmd = (ds->xDDR_TRCD);
+    __prt_wr("TRCD", TRCD_REG_addr, cmd);
+    cmd = (ds->xDDR_TRRD);
+    __prt_wr("TRRD", TRRD_REG_addr, cmd);
+    cmd = (ds->xDDR_TRTP);
+    __prt_wr("TRTP", TRTP_REG_addr, cmd);
+    cmd = (ds->xDDR_TRTW);
+    __prt_wr("TRTW", TRTW_REG_addr, cmd);
+    cmd = (ds->xDDR_TWR);
+    __prt_wr("TWR", TWR_REG_addr, cmd);
+    cmd = (ds->xDDR_TWTR);
+    __prt_wr("TWTR", TWTR_REG_addr, cmd);
+    cmd = (ds->xDDR_TEXSR);
+    __prt_wr("TEXSR", TEXSR_REG_addr, cmd);
+    cmd = (ds->xDDR_TXP);
+    __prt_wr("TXP", TXP_REG_addr, cmd);
+    cmd = (ds->xDDR_TDQS);
+    __prt_wr("TDQS", TDQS_REG_addr, cmd);
+    cmd = (ds->xDDR_TCKSRE);
+    __prt_wr("TCKSRE", TCKSRE_REG_addr, cmd);
+    cmd = (ds->xDDR_TCKSRX);
+    __prt_wr("TCKSRX", TCKSRX_REG_addr, cmd);
+    cmd = (ds->xDDR_TMOD);
+    __prt_wr("TMOD", TMOD_REG_addr, cmd);
+    cmd = (ds->xDDR_TCKE);
+    __prt_wr("TCKE", TCKE_REG_addr, cmd);
+    cmd = (ds->xDDR_TZQCS);
+    __prt_wr("TZQCS", TZQCS_REG_addr, cmd);
+    cmd = (ds->xDDR_TZQCL);
+    __prt_wr("TZQCL", TZQCL_REG_addr, cmd);
+    cmd = (ds->xDDR_TXPDLL);
+    __prt_wr("TXPDLL", TXPDLL_REG_addr, cmd);
+    cmd = (ds->xDDR_TZQCSI);
+    __prt_wr("TZQCSI", TZQCSI_REG_addr, cmd);
+    cmd = (ds->xDDR_TCKESR);
+    __prt_wr("TCKESR", TCKESR_REG_addr, cmd);
+    cmd = (ds->xDDR_TDPD);
+    __prt_wr("TDPD", TDPD_REG_addr, cmd);
+    cmd = (ds->xDDR_TEFI_MEM_DDR3);
+    __prt_wr("EFI_MEM_DDR3", EFI_MEM_DDR3_REG_addr, cmd);
+} 
+ 
+void dfi_t(struct ddr_settings * ds){	
+	u32 cmd;
+    cmd = ds->xDDR_DFITPHYWRLAT;
+    __prt_wr("DFITPHYWRLAT", DFITPHYWRLAT_REG_addr, cmd);
+    cmd = ds->xDDR_DFITRDDATAEN;
+    __prt_wr("DFITRDDATAEN", DFITRDDATAEN_REG_addr, cmd);
+    cmd = 0x00000001;    	//1  
+    __prt_wr("DFITPHYWRDATA", DFITPHYWRDATA_REG_addr, cmd);
+    cmd = 0x00000003;		//3
+    __prt_wr("DFITPHYWRDATALAT", DFITPHYWRDATALAT_REG_addr, cmd);
+    cmd = 0x0000000f;   	//f
+    __prt_wr("DFITPHYRDLAT", DFITPHYRDLAT_REG_addr, cmd);
+    cmd = 0x00000002;
+    __prt_wr("DFITDRAMCLKDIS", DFITDRAMCLKDIS_REG_addr, cmd);
+    cmd = 0x00000002;   
+    __prt_wr("DFITDRAMCLKEN", DFITDRAMCLKEN_REG_addr, cmd);
+    cmd = 0x00000003;		//2
+    __prt_wr("DFITCTRLDELAY", DFITCTRLDELAY_REG_addr, cmd);
+	
+//TRI activate ODT from CTRL
+	
+	cmd = (ddr_rank==1)?0x08:0x0808;		//Enable ODT for rank 0 and 1 when a write access on this rank
+	__prt_wr("DFIODTCFG", DFIODTCFG_REG_addr, cmd);
+	
+	if (ddr_type==2) { 
+		if ((ddr_grade)<9)							//All DDR2 except DDR2-1066
+			cmd = 0x06060000 + (((ds->xDDR_TCL)+(ds->xDDR_TAL)-3)<<8) +	((ds->xDDR_TCWL)+(ds->xDDR_TAL)-3);	
+		else
+			cmd = 0x07070000 + (((ds->xDDR_TCL)+(ds->xDDR_TAL)-4)<<8) + ((ds->xDDR_TCWL)+(ds->xDDR_TAL)-4);	
+	} else {
+		cmd = 0x06060000 + (((ds->xDDR_TCL)-(ds->xDDR_TCWL))<<8);	
+	}
+
+	__prt_wr("DFIODTCFG1", DFIODTCFG1_REG_addr, cmd);	
+
+	cmd = (ddr_rank==1)?0x01:0x21;			//dfi_odt[x] will be asserted to terminate rank x (x=1,2)
+	__prt_wr("DFIODTRANKMAP", DFIODTRANKMAP_REG_addr, cmd);	
+	    
+    cmd = 0x00000040;
+    __prt_wr("DFITCTRLUPDMAX", DFITCTRLUPDMAX_REG_addr, cmd);
+}
+
+void memmax_init(struct ddr_settings * ds) {
+	u32 cmd;
+	if (endianness == 1) {
+		//BIG_ENDIAN
+		cmd = ds->xMM_DRAMCONFIG;	
+		__prt_wr("MM_DRAMCONFIG", 0xb2200004, cmd);	
+		cmd = ds->xMM_SWAP0_H;	
+		__prt_wr("MM_SWAP0_H", 0xb2200120, cmd); 
+		cmd = ds->xMM_SWAP0_L;		
+		__prt_wr("MM_SWAP0_L", 0xb2200124, cmd);
+	} else {
+		cmd = ds->xMM_DRAMCONFIG;	
+		__prt_wr("MM_DRAMCONFIG", 0xb2200000, cmd);	
+		cmd = ds->xMM_SWAP0_H;	
+		__prt_wr("MM_SWAP0_H", 0xb2200124, cmd); 	
+		cmd = ds->xMM_SWAP0_L;		
+		__prt_wr("MM_SWAP0_L", 0xb2200120, cmd); 
+	}
+}
+
+void fmt_init(void) {
+	u32 cmd;
+	cmd = 0xf8002000;		//FMT0 0x80000000/0xa0000000 > 0x20000000 (128MB DRAM )
+	__prt_wr("FMT_0", 0xb49001d0, cmd); 
+	cmd = 0xf8002800;		//FMT1 0x88000000/0xa8000000 > 0x28000000 (128MB DRAM )
+	__prt_wr("FMT_1", 0xb49001d4, cmd); 
+	cmd = 0xfe00a000;		//FMT2 0x90000000/0xb0000000 > 0xa0000000 ( 32MB IOCU1)
+	__prt_wr("FMT_2", 0xb49001d8, cmd); 
+}
+
+void syntax(void)
+{
+    printf("Syntax: %s [options]\n", Progname);
+    printf("Options:\n");
+    printf("  -h        Display this (help) information\n");
+    printf("  --help    Display this (help) information\n");
+	printf("  -type  DDR type (3)\n");
+	printf("            2: DDR2\n");	
+	printf("            3: DDR3\n\n");
+	printf("  -grade (6)\n");
+	printf("            DDR2#           \t  DDR3#\n");
+	printf("            0: 200MHz @ CL=3\t  0: 400MHz @ CL=5  \n");	
+	printf("            2: 266MHz @ CL=4\t  1: 400MHz @ CL=6  \n");
+	printf("            4: 333MHz @ CL=4\t  2: 533MHz @ CL=6  \n");	
+	printf("            5: 333MHz @ CL=5\t  3: 533MHz @ CL=7  \n");	
+	printf("            6: 400MHz @ CL=5\t  4: 533MHz @ CL=8  \n");
+	printf("            7: 400MHz @ CL=6\t  5: 667MHz @ CL=8  \n");	
+	printf("            9: 533MHz @ CL=7\t  6: 667MHz @ CL=9  \n");	
+	printf("                            \t  7: 667MHz @ CL=10 \n");
+	printf("                            \t  8: 800MHz @ CL=9  \n");
+	printf("                            \t  9: 800MHz @ CL=10 \n");	
+	printf("                            \t  10: 800MHz @ CL=11\n\n");
+
+	printf("  -density (8)\n");	
+	printf("            DDR2#           \t  DDR3#\n");	
+	printf("            0: 16Mx16	    \t  2: 32Mx16  \n");	
+	printf("            1: 32Mx8	    \t  3: 64Mx8   \n");	
+	printf("            2: 32Mx16	    \t  4: 64Mx16  \n");
+	printf("            3: 64Mx8	    \t  5: 128Mx8  \n");	
+	printf("            4: 64Mx16	    \t  6: 128Mx16 \n");	
+	printf("            5: 128Mx8	    \t  7: 256Mx8  \n");
+	printf("            6: 128Mx16      \t  8: 256Mx16 \n");
+	printf("            7: 256Mx8	    \t  9: 512Mx8  \n");	
+	printf("            8: 256Mx16      \t  10: 512Mx16\n");
+	printf("            9: 512Mx8\n\n");
+
+	printf("  -bl    burst length (8)\n");	
+	printf("            4: Burst chop 4   \n");	
+	printf("            8: Burst length 8 \n\n");	
+	printf("  -al    additive latency (1)\n");	
+	printf("            DDR2#           \t  DDR3#\n");	
+	printf("            0: AL=0         \t  0: no AL\n");	
+	printf("            1: AL=1         \t  1: AL=CL-1\n");	
+	printf("            2: AL=2         \t  2: AL=CL-2\n");	
+	printf("            3: AL=3\n");
+	printf("            4: AL=4\n");
+	printf("            5: AL=5\n");
+	printf("            6: AL=6\n\n");
+
+	printf("  -rank  (1)\n");	
+	printf("            1: CS0 only\n");	
+	printf("            2: CS0, CS1\n\n");	
+
+	printf("  -sr0   pre-seed rank 0 (24 24)\n");	
+	printf("  -sr1   pre-seed rank 1 (24 24)\n");		
+	printf("            Valid value: 0 .. 63\n\n");	
+
+	printf("  -endian (1)\n");	
+	printf("            0: Little endian\n");
+	printf("            1: Big endian\n\n");
+	
+	printf("  -o     output file name\n");
+	printf("\t without -o arg, there will not be any output file generated\n\n");	
+	
+	printf("  -fcps  CPS frequency (3)\n");
+	printf("  -fsl   Share Link frequency (8)\n");		
+	printf("  -fngi  NGI/TEP frequency (6)\n");	
+	printf("  -fcbm  CBM frequency (6)\n");	
+	printf("            0:  2400MHz     \t  1: 1200MHz\n");	
+	printf("            2:   800MHz     \t  3:  600MHz\n");
+	printf("            4:   480MHz     \t  5:  400MHz\n");
+	printf("            6:   300MHz     \t  7:  240MHz\n");
+	printf("            8:   200MHz     \t  9:  150MHz\n");
+	printf("            10:  120MHz     \t  11: 100MHz\n"); 
+	printf("            12:   75MHz     \t  13:  60MHz\n");
+	printf("            14:   50MHz     \t  15:  37.5MHz\n");
+	printf("            16: 1000MHz (cps only) \n\n");	
+
+	printf("  -fcps2 CPS Frequency alternative(1)\n");			
+	printf("  -fdctl DDR Controller frequency (5)\n");		
+	printf("  -fgsw  GSWIP-L frequency (5)\n");	
+	printf("  -fgswr GSWIP-R/MII frequency (6)\n");		
+	printf("            0:  2000MHz     \t  1: 1000MHz\n");	
+	printf("            2:   666MHz     \t  3:  500MHz\n");	
+	printf("            4:   400MHz     \t  5:  333MHz\n");
+	printf("            6:   250MHz     \t  7:  200MHz\n");
+	printf("            8:   166MHz     \t  9:  125MHz\n");
+	printf("            10:	 100MHz     \t  11:  83MHz\n"); 
+	printf("            12:  62.5MHz    \t  13:  50MHz\n");
+	printf("            14:  41.6MHz    \t  15:  51.25MHz\n\n");	
+	
+	printf("Example: ./init_ddr -h\n");
+	printf("         ./init_ddr -type 3 -grade 6 -density 8 -rank 1 -bl 8 -al 1 -endian 1 -sr0 20 20 -sr1 20 20 -fcps 3 -fsl 8 -fngi 6 -fcbm 6 -fcps2 1 -fdctl 5 -fgsw 5 -fgswr 6 -o ddr.conf\n");
+	printf("         ./init_ddr -type 3 -grade 10 -density 8 -rank 1 -bl 8 -al 1 -endian 1 -sr0 20 20 -sr1 20 20 -fcps 2 -fsl 8 -fngi 6 -fcbm 6 -fcps2 1 -fdctl 4 -fgsw 5 -fgswr 6 -o ddr.conf\n");
+
+	printf("\n");			
+}
+
+void parse_args1(int argc, char *argv[])
+{
+	int i;
+	u32 x;
+	char *str;
+	if (argc >= 2) {
+		for (i=1; i<argc; i++) {
+			str = argv[i];
+			if (strcmp(str, "-h") == 0 || strcmp(str, "--help") == 0) {
+				syntax();
+				return;					
+			}
+			else if (strcmp(str, "-type") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if (x!=2 && x!=3){
+						printf("Incorrect type input\n");
+						return;
+					}
+					ddr_type = x;
+				}
+			}
+			else if (strcmp(str, "-grade") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if ((ddr_type==2 && x!=0 && x!=2 && x!=4 && x!=5 && x!=6 && x!=7 && x!=9) ||
+						(ddr_type==3 && x>10)) {
+						printf("Incorrect grade input\n");
+						return;
+					}
+					ddr_grade = x;			
+				}
+			}
+			else if (strcmp(str, "-rank") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if (x!=1 && x!=2){
+						printf("Incorrect rank input\n");
+						return;
+					}
+					ddr_rank = x;
+				}
+			}	
+					
+			else if (strcmp(str, "-density") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if ((ddr_type==2 && x>9 ) ||
+						(ddr_type==3 && (x>10 || x<2))) {
+						printf("Incorrect density input\n");
+						return;
+					}
+					ddr_density = x;
+				}		
+			}	
+			else if (strcmp(str, "-bl") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if (x!=4 && x!=8){
+						printf("Incorrect BL input x=%d\n", x);
+						return;
+					}
+					ddr_blen = x;
+				}
+			}
+			else if (strcmp(str, "-al") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if ((ddr_type==2 && x>6) ||
+						(ddr_type==3 && x>2)) {
+						printf("Incorrect AL input\n");
+						return;
+					}
+					ddr_al = x;
+				}
+			}	
+			else if (strcmp(str, "-endian") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if (x>1){
+						printf("Incorrect endian input\n");
+						return;
+					}
+					endianness = x;
+				}
+			}		
+			else if (strcmp(str, "-o") == 0) {
+				g_output = 1;
+				i++;
+				strncpy(filename, argv[i], strlen(argv[i]));
+			}	
+			else if (strcmp(str, "-fcps") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if (x>17) {
+						printf("Incorrect CPS frequency input\n");
+						return;
+					}
+					fcps = x;
+				}
+			}
+			else if (strcmp(str, "-fsl") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if (x>16) {
+						printf("Incorrect Share Link frequency input\n");
+						return;
+					}
+					fsl = x;
+				}
+			}
+			else if (strcmp(str, "-fngi") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if (x>16) {
+						printf("Incorrect NGI frequency input\n");
+						return;
+					}
+					fngi = x;
+				}
+			}	
+			else if (strcmp(str, "-fcbm") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if (x>16) {
+						printf("Incorrect CBM frequency input\n");
+						return;
+					}
+					fcbm = x;
+				}
+			}		
+			else if (strcmp(str, "-fcps2") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if (x>16) {
+						printf("Incorrect alternative CPS frequency input\n");
+						return;
+					}
+					fcps2 = x;
+				}
+			}
+			else if (strcmp(str, "-fdctl") == 0) {
+				if (i == argc - 1) 
+					syntax();
+					else {
+					i++;
+					x = atoi(argv[i]);
+					if (x>16) {
+						printf("Incorrect DDR Ctrl frequency input\n");
+						return;
+					}
+					fdctl = x;
+				}
+			}
+			else if (strcmp(str, "-fgsw") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if (x>16) {
+						printf("Incorrect GSW frequency input\n");
+						return;
+					}
+					fgsw = x;
+				}
+			}	
+			else if (strcmp(str, "-fgswr") == 0) {
+				if (i == argc - 1) 
+					syntax();
+				else {
+					i++;
+					x = atoi(argv[i]);
+					if (x>16) {
+						printf("Incorrect GSW-R frequency input\n");
+						return;
+					}
+					fgswr = x;
+				}
+			}	
+			else if (strcmp(str, "-sr0") == 0) {
+				if ((i == argc-1) || (i == argc-2)) 
+					syntax();
+				else {
+					i++;
+					if (atoi(argv[i])>63 || atoi(argv[i+1])>63) {
+						printf("Incorrect Pre-seed Rank 0 input\n");
+						return;
+					}
+					sr0[0] = atoi(argv[i]);
+					i++;
+					sr0[1] = atoi(argv[i]);		
+				}
+			}	
+			else if (strcmp(str, "-sr1") == 0) {
+				if ((i == argc-1) || (i == argc-2)) 
+					syntax();
+				else {
+					i++;
+					if (atoi(argv[i])>63 || atoi(argv[i+1])>63) {
+						printf("Incorrect Pre-seed Rank 1 input\n");
+						return;
+					}
+					sr1[0] = atoi(argv[i]);
+					i++;
+					sr1[1] = atoi(argv[i]);		
+				}
+			}
+			else {
+				printf("Invalid input\n");
+				return;
+			}
+		}
+	} 
+	else if (argc == 1)
+		syntax();
+
+	printf("Summary: \n");
+	printf("\tType:%d Grade:%d Density:%d BL:%d AL:%d Rank:%d Endian:%d SR0:%d %d SR1:%d %d\n", 
+	ddr_type, ddr_grade, ddr_density, ddr_blen, ddr_al, ddr_rank, endianness, sr0[0], sr0[1], sr1[0], sr1[1]);	
+
+	if (fcps < 16) { 
+		cgu_pll0a_cfg1 = 0x40400000 + (fcps <<12) + (fsl <<8) + (fngi<<4) + (fcbm );
+	} else {
+		cgu_pll0a_cfg1 = 0x60400000 + (   3<<12)  + (fsl <<8) + (fngi<<4) + (fcbm );
+	}
+	cgu_pll0b_cfg1 = 0x40400000 + (fcps2<<12) + (fdctl<<8) + (fgsw<<4) + (fgswr);	
+	printf("\tcgu_pll0a_cfg1: 0x%08x\n", cgu_pll0a_cfg1);
+	printf("\tcgu_pll0b_cfg1: 0x%08x\n", cgu_pll0b_cfg1);
+	if (g_output)
+		printf("\tdram.conf generated\n");	
+	else
+		printf("\tOutput disabled\n");
+
+}
+
+/************************************************************************
+ *  Implementation : Public functions
+ ************************************************************************/
+int main(int argc, char *argv[])
+{
+	u8 n, max, min, p0, p1;
+	u32 i, rank, dxreg, x0, x1, cmd, read_reg = 0;
+	struct ddr_settings  ds;
+ 	
+	parse_args1(argc, argv);
+	
+	fp = fopen(filename, "w+");
+	if (!fp) {
+		syntax();
+		return 0;
+	}
+	
+	setup_ddr(&ds);
+ 
+	// BIG_ENDIAN
+	if (endianness == 1)
+		cmd = 0xdfffff;	
+	else 
+		cmd = 0x200000; 
+	__prt_wr("NGI_ENDIAN", 0xb608005c, cmd);
+	
+	__delay();
+
+	for (i=0; i<16; i++){
+	    cmd = 0x0014a315;
+	    __prt_wr("PUB_RIDR", PUB_RIDR_REG_addr, cmd);
+    }
+      
+	if (ddr_type == 2 || gate_ext != 1)      
+		cmd = 0xf004641f;
+	else
+		cmd = 0xf004645f;
+    __prt_wr("PUB_DSGCR", PUB_DSGCR_REG_addr, cmd);
+    
+	/*MEMMAX, FMT initialization*/
+    memmax_init(&ds);
+    fmt_init(); 
+    
+	/*uPCTL initialization*/
+	// s1
+	cmd = (ds.xDDR_TOGCNT1U);
+	__prt_wr("TOGCNT1U", TOGCNT1U_REG_addr, cmd);
+	cmd = (ds.xDDR_TINIT);
+	__prt_wr("TINIT", TINIT_REG_addr, cmd);
+	cmd = (ds.xDDR_TOGCNT100N);
+	__prt_wr("TOGCNT100N", TOGCNT100N_REG_addr, cmd);
+	cmd = (ds.xDDR_TRSTH);		
+	__prt_wr("TRSTH", TRSTH_REG_addr, cmd);
+	cmd = (ds.xDDR_TRSTL);		
+	__prt_wr("TRSTL", TRSTL_REG_addr, cmd);
+
+	// s2	
+	cmd = ((((ds.xDDR_TFAW_CFG)-4)<<18) + (((ddr_type)-2)<<5) + ((ddr_blen==8)?(1):(0)));
+	__prt_wr("MCFG", MCFG_REG_addr, cmd);
+	cmd = ((ds.xDDR_TFAW_CFG_OFF)<<8);
+	__prt_wr("MCFG1", MCFG1_REG_addr, cmd);
+  
+	/*PHY powered up & initialization*/	 
+	// s3
+	cmd = (ds.xDDR_DCR); 
+	__prt_wr("PUB_DCR", PUB_DCR_REG_addr, cmd);
+	cmd = (ds.xDDR_MR0);				
+	__prt_wr("PUB_MR0", PUB_MR0_REG_addr, cmd);
+	cmd = (ds.xDDR_MR1);				
+	__prt_wr("PUB_MR1", PUB_MR1_REG_addr, cmd);
+	cmd = (ds.xDDR_MR2);				
+	__prt_wr("PUB_MR2", PUB_MR2_REG_addr, cmd);
+	cmd = (ds.xDDR_MR3);
+	__prt_wr("PUB_MR3", PUB_MR3_REG_addr, cmd);
+	cmd = ((ds.xDDR_TRC)<<26) + ((ds.xDDR_TRRD)<<22) + ((ds.xDDR_TRAS)<<16) + ((ds.xDDR_TRCD)<<12) + 
+                                ((ds.xDDR_TCL)<<8)  + ((ds.xDDR_TWTR)<<4)  + (ds.xDDR_TRTP);     	
+                                //TRP always = TCL                               
+	__prt_wr("PUB_DTPR0", PUB_DTPR0_REG_addr, cmd);
+	cmd = ((ds.xDDR_TAOND)<<30) + ((((ddr_type)==2)?(8):(ds.xDDR_TWLO))<<26) + 
+   									  ((((ddr_type)==2)?(40):(ds.xDDR_TWLMRD))<<20) + ((ds.xDDR_TRFC)<<11) + 
+									  ((ds.xDDR_TFAW)<<5) + 
+   									  ((((ddr_type)==2)?(4):((ds.xDDR_TMOD)-12))<<2) + (((ddr_type)==2)?
+									  (ds.xDDR_TMRD):((ds.xDDR_TMRD)-4));
+   								//Some unused in DDR2, keep default
+	__prt_wr("PUB_DTPR1", PUB_DTPR1_REG_addr, cmd);
+	
+	cmd = (((ds.xDDR_TCCD)>4)?(1<<31):(0)) + ((ds.xDDR_TDLLK)<<19) + ((ds.xDDR_TCKE)<<15) + 
+   								 	  ((ds.xDDR_TXP)<<10) + (ds.xDDR_TXS) + (1<<30); 
+	__prt_wr("PUB_DTPR2", PUB_DTPR2_REG_addr, cmd);
+   
+	cmd = (((ddr_type)==2)?(0x00f00000):(0x00f80000)) + (ds.xDDR_TREFPRD);
+   								//DDR3 uses Fixed Latency				
+	__prt_wr("PUB_PGCR2", PUB_PGCR2_REG_addr, cmd);
+
+	cmd = (ds.xDDR_TPHYRST) + ((ds.xDDR_TPLLGS)<<6) + ((ds.xDDR_TPLLPD)<<21);
+	__prt_wr("PUB_PTR0", PUB_PTR0_REG_addr, cmd);
+	cmd = (ds.xDDR_TPLLRST) + ((ds.xDDR_TPLLLOCK)<<16);					
+	__prt_wr("PUB_PTR1", PUB_PTR1_REG_addr, cmd);
+	cmd = (ds.xDDR_TCALON) + ((ds.xDDR_TCALS)<<5) + ((ds.xDDR_TCALH)<<10) + ((ds.xDDR_TWLDLYS)<<15);
+	__prt_wr("PUB_PTR2", PUB_PTR2_REG_addr, cmd);
+   
+	/* PHY Default, support 2 ranks */  
+
+	if (ddr_type == 2 || gate_ext != 1)
+		cmd  = 0x44181224;
+	else
+		cmd  = 0x44181ee4;
+	__prt_wr("PUB_DXCCR_REG_addr", PUB_DXCCR_REG_addr, cmd);
+	cmd = 0x7c001e81;
+	__prt_wr("PUB_DX0GCR_REG_addr", PUB_DX0GCR_REG_addr, cmd);
+	cmd = 0x7c001e81;
+	__prt_wr("PUB_DX1GCR_REG_addr", PUB_DX1GCR_REG_addr, cmd);
+
+	if (ddr_type == 2)
+		if (ddr_grade < 6) {
+			cmd = 0x104b;	//Rodt(Rtt) = 75 Ohm, Rods(output drive) = 40 Ohm - <=333MHz
+			__prt_wr("PUB_ZQ0CR1", PUB_ZQ0CR1_REG_addr, cmd);
+		}
+		else {
+			cmd = 0x101b;	//Rodt(Rtt) = 150 Ohm, Rods(output drive) = 40 Ohm - >=400MHz
+			__prt_wr("PUB_ZQ0CR1", PUB_ZQ0CR1_REG_addr, cmd);
+		}
+	else {
+		//GATE_EXT or OTHERS
+		cmd = 0x105d;
+		__prt_wr("PUB_ZQ0CR1", PUB_ZQ0CR1_REG_addr, cmd);
+	}
+
+	/* PUB PHY initialization page 51 */
+	// - At reset, the PHY moves into the PLL initialization lock phase. This phase may be 
+	//   bypassed at any time by writing a '1' to the PLL initialization bypass register bit (PIR[LOCKBYP]). 
+	// - In parallel to PLL initialization, the impedance calibration phase also starts at reset de-assertion. This 
+	//   phase can also be bypassed by writing a '1' to bit PIR[ZCALBYP]
+	// - Once the PLL is initialized, the delay calibration phase starts. This phase can also be bypassed by 
+	//   writing a '1' to bit PIR[DCALBYP]. 
+	// - Special to emulation: set DCALBYP (Digital Delay Line Calibration) and ZCALBYP (Impedance Calibration) so 
+	//   that calibration of data delay lines and termination resistor is skipped
+	// - Since the clocks to the PHY are not stable until after the PLL is locked and the delay lines are 
+	//   calibrated, the initialization phase waits a few programmable clock cycles in the PHY initialization 
+	//   reset phase before de-asserting the reset to the PHY.   
+   
+	read_reg = 0;
+	__prt_rd("PUB_PIR", PUB_PIR_REG_addr, read_reg);			//default = 0
+
+	// Wait until the lower 4 bits are set:
+	// Bit 0: IDONE: PHY initialization done
+	// Bit 1: PLDONE: PLL lock done
+	// Bit 2: DCDONE: Digital Delay Line calibration done 
+	// Bit 3: ZCDONE: Impedance Calibration done
+	// Bit 4: DIDONE: DRAM Initialization Done
+	// Bit 20: ZCERR : Impedance Calibration Error
+	// Bit 28: PLDONE_CHN 0: PLL Lock Done channel 0
+	// Bit 29: PLDONE_CHN 1: PLL Lock Done channel 1
+	// Bit 31: APLOCK: AC PLL has locked
+	// There are the following value transitions in Synopsys' DDR3 reference simulation with behavioral 
+	// PHY model: 
+	// 0x00000000 => 0x30000002 => 0xb0000002 => 0xb0000006 => 0xb000000e => 0xb000000f
+
+	// s4
+         // In emulation ZCERR (Impedance Calibration Error) bit (bit#20) is set although in case
+         // a) Z calibration is not bypassed: Z calibration state machine finishs (Z_DONE), but the
+         //    previously set ZCERR is not reset. 
+         // b) Z calibration is bypassed: Z_DONE is directly set by bypassing the calibration state 
+         //    machine, nethertheless ZCERR is set as before. In reference simulation (with encrypted 
+         //    PHY model) ZCERR it is not set. To be clarified
+    read_reg = 0xb000000f;
+    __prt_rd("PUB_PGSR0", PUB_PGSR0_REG_addr, read_reg);
+
+	//DATX8 Local Calibrated Delay Line Register 2 (DXnLCDLR2)
+	//[7:0]   R0DQSGD    Rank 0 Read DQS Gating Delay: Rank 0 delay select for the read DQS gating (DQSG) LCDL
+	//[15:8]  R1DQSGD    Rank 1 Read DQS Gating Delay: Rank 1 delay select for the read DQS gating (DQSG) LCDL
+	cmd = 0x6e6e;
+	__prt_wr("PUB_DX0LCDLR2", PUB_DX0LCDLR2_REG_addr, cmd);
+	cmd = 0x6e6e;
+	__prt_wr("PUB_DX1LCDLR2", PUB_DX1LCDLR2_REG_addr, cmd);
+
+	// PIR = PHY initialization register
+	// Bit  0: INIT 1    => Triggers DDR initialization (PHY, DDR, ... depending on the other bit settings)
+	// Bit 18: CTLDINT 1 => Controller DRAM initialization, performed by DRAM controller
+	cmd = 0x00040001;
+	__prt_wr("PUB_PIR", PUB_PIR_REG_addr, cmd);
+ 
+	// Wait on initialized DRAM
+    read_reg = 0xb000001f; 
+    __prt_rd("PUB_PGSR0", PUB_PGSR0_REG_addr, read_reg);
+
+	/*Memory powered up*/  
+	// s5
+	read_reg = 0x00000001; 
+    __prt_rd("DFISTSTAT0", DFISTSTAT0_REG_addr, read_reg);
+
+	// s6
+	cmd = 0x00000001;
+	__prt_wr("POWCTL", POWCTL_REG_addr, cmd);
+	// wait on memory power-on sequence finished.
+    read_reg = 0x00000001; 
+     __prt_rd("POWSTAT", POWSTAT_REG_addr, read_reg);
+      
+	/*Memory initialization*/   
+	// s7
+	mem_t(&ds);
+
+	cmd = 0x00004780;																
+	__prt_wr("SCFG", SCFG_REG_addr, cmd);
+
+	// s8
+	dfi_t(&ds);		
+	cmd = 0x00000007;
+	__prt_wr("DFIUPDCFG", DFIUPDCFG_REG_addr, cmd);
+
+	// s9
+	// Memory command register:
+	// bit 31: start command (is reset by uPCTL when command executed)
+	// bit 27:24: command additional delay
+	// bit 23:20: rank select (1111 means broadcast)
+		
+	cmd = 0x86f00000;		//Deselect
+	__prt_wr("MCMD", MCMD_REG_addr, cmd);
+    read_reg = cmd&0x7fffffff; 
+    __prt_rd("MCMD", MCMD_REG_addr, read_reg);
+	__delay();
+	
+    if ((ddr_type)==2) {
+		cmd = 0x80f00001;	//PreA
+		__prt_wr("MCMD", MCMD_REG_addr, cmd);
+		read_reg = cmd & 0x7fffffff; 
+		__prt_rd("MCMD", MCMD_REG_addr, read_reg); 
+		__delay();		   
+    }
+
+	cmd = (0x80f40003 | ((ds.xDDR_MR2)<<4));	
+	__prt_wr("MCMD", MCMD_REG_addr, cmd);
+    read_reg = cmd & 0x7fffffff; 
+    __prt_rd("MCMD", MCMD_REG_addr, read_reg);
+	__delay();
+	
+	cmd = (0x80f60003 | ((ds.xDDR_MR3)<<4));
+	__prt_wr("MCMD", MCMD_REG_addr, cmd);
+    read_reg = cmd & 0x7fffffff; 
+    __prt_rd("MCMD", MCMD_REG_addr, read_reg);
+	__delay();
+   
+	cmd = (0x80f20003 | ((ds.xDDR_MR1)<<4));				//PLL enabled by pre-defined
+	__prt_wr("MCMD", MCMD_REG_addr, cmd);
+    read_reg = cmd & 0x7fffffff; 
+    __prt_rd("MCMD", MCMD_REG_addr, read_reg);
+	__delay();
+
+	cmd = (0x80f00003 | ((ds.xDDR_MR0)<<4));				//PLL reset=1 by pre-defined
+	__prt_wr("MCMD", MCMD_REG_addr, cmd);
+    read_reg = cmd & 0x7fffffff; 
+    __prt_rd("MCMD", MCMD_REG_addr, read_reg);
+	__delay();
+	
+    if  ((ddr_type)==2) {
+		cmd = 0x80f00001;	//PreA
+		__prt_wr("MCMD", MCMD_REG_addr, cmd);
+		read_reg = cmd & 0x7fffffff; 
+		__prt_rd("MCMD", MCMD_REG_addr, read_reg);    
+		__delay();
+		
+		cmd = 0x80f00002;	//Refresh
+		__prt_wr("MCMD", MCMD_REG_addr, cmd);
+		read_reg = cmd & 0x7fffffff; REG32(MCMD_REG_addr);
+		__prt_rd("MCMD", MCMD_REG_addr, read_reg);
+		__delay();
+		
+		cmd = 0x80f00002;	//Refresh
+		__prt_wr("MCMD", MCMD_REG_addr, cmd);
+			read_reg = cmd & 0x7fffffff;
+			__prt_rd("MCMD", MCMD_REG_addr, read_reg);
+        __delay();  
+	   
+		cmd = (0x80f00003 | (((ds.xDDR_MR0)&(~0x100))<<4)); 	//PLL reset=0, for timing programming
+		__prt_wr("MCMD", MCMD_REG_addr, cmd);
+		read_reg = cmd & 0x7fffffff;
+		__prt_rd("MCMD", MCMD_REG_addr, read_reg);  
+		__delay();	
+	   
+		cmd = (0x80f20003 | ((ds.xDDR_MR1)<<4));				//OCD
+		__prt_wr("MCMD", MCMD_REG_addr, cmd);
+		read_reg = cmd & 0x7fffffff; 
+		__prt_rd("MCMD", MCMD_REG_addr, read_reg);
+		__delay();
+	}
+
+	cmd = 0x80f00005;		//ZQ Calibration Long
+	__prt_wr("MCMD", MCMD_REG_addr, cmd);
+      read_reg = cmd & 0x7fffffff;
+      __prt_rd("MCMD", MCMD_REG_addr, read_reg);
+	__delay(); 
+
+	// s10 
+	cmd = 0x80f0000a;		//DFI Controller Update
+	__prt_wr("MCMD", MCMD_REG_addr, cmd);
+    read_reg = cmd & 0x7fffffff; 
+    __prt_rd("MCMD", MCMD_REG_addr, read_reg);
+	__delay();
+   
+	/*Move uPCTL into config status*/   
+	// s11
+	// operational state control register 
+	// bits(2:0) = 1: move to cfg state
+	cmd = 0x00000001;
+	__prt_wr("SCTL", SCTL_REG_addr, cmd);
+    read_reg = 0x00000001; 
+    __prt_rd("STAT", STAT_REG_addr, read_reg);
+      
+	/*Refine configuration*/   
+	// s12	
+	cmd = 0x00000000; 
+	__prt_wr("PPCFG", PPCFG_REG_addr, cmd);	
+	cmd = 0x00000007;	
+	__prt_wr("DFISTCFG0", DFISTCFG0_REG_addr, cmd);
+	cmd = 0x00000003;
+	__prt_wr("DFISTCFG1", DFISTCFG1_REG_addr, cmd);
+	cmd = 0x00000000;
+	__prt_wr("DFISTCFG2", DFISTCFG2_REG_addr, cmd);
+	cmd = 0x00070101; 
+	__prt_wr("DFILPCFG0", DFILPCFG0_REG_addr, cmd);
+	cmd = 0x00000000;
+	__prt_wr("ECCCFG", ECCCFG_REG_addr, cmd);	
+	cmd = 0x00000003;
+	__prt_wr("DFIUPDCFG", DFIUPDCFG_REG_addr, cmd);
+
+	// s13
+	cmd = 0x00000001;
+	__prt_wr("CMDSTATEN", CMDSTATEN_REG_addr, cmd);
+    read_reg = 0x00000001; 
+    __prt_rd("CMDSTAT", CMDSTAT_REG_addr, read_reg);
+
+	/* Move uPCTL into access state */
+    // s16
+    cmd = 0x00000002;     
+    __prt_wr("SCTL", SCTL_REG_addr, cmd);
+	read_reg = 0x00000003; 
+    __prt_rd("STAT", STAT_REG_addr, read_reg);
+  
+/****************************/
+/*  Clock Change Procedure  */
+/****************************/
+
+	// Issue sleep command to controller to low power state
+    cmd = 0x00000003;     
+    __prt_wr("SCTL", SCTL_REG_addr, cmd);
+	read_reg = 0x00000045; 
+	__prt_rd("STAT", STAT_REG_addr, read_reg);  
+
+	// change DDR clock freq 
+	cmd = cgu_pll0a_cfg1;
+	__prt_wr("PLL0A_CFG1", 0xb6200008, cmd);
+	cmd = cgu_pll0b_cfg1;	
+	__prt_wr("PLL0B_CFG1", 0xb6200038, cmd);
+	__delay();
+	
+	// issue pll reset
+    cmd = 0x40000000;
+    __prt_wr("PUB_PLLCR", PUB_PLLCR_REG_addr, cmd);
+   	__delay();  
+    cmd = 0x0001c000;	
+    __prt_wr("PUB_PLLCR", PUB_PLLCR_REG_addr, cmd);	
+
+	//clear status bits pgsr resgister bits
+   	cmd = 0x08000000; 
+   	__prt_wr("PUB_PIR", PUB_PIR_REG_addr, cmd);	
+
+	read_reg = 0xb0000017; 
+	__prt_rd("PUB_PGSR0", PUB_PGSR0_REG_addr, read_reg); 
+	__delay();
+			
+	/*
+		PIR[0] Initialization Trigger
+		PIR[1] Impedance Calibration: impedance calibration performed in parallel with PHY initialization 
+				(PLL initialization + DDL calibration + PHY reset).
+	 	PIR[4] PLL Initialization: Executes the PLL initialization, including driving of PLL power-down, 
+	 			reset and gear shift pins, and then waiting for the PHY PLLs to lock.
+	 	PIR[5] Digital Delay Line (DDL) Calibration: Performs PHY DL & VT calibration .		
+	*/
+	cmd = 0x00000033; 	
+   	__prt_wr("PUB_PIR", PUB_PIR_REG_addr, cmd);
+	read_reg = 0xb000001f; 
+	__prt_rd("PUB_PGSR0", PUB_PGSR0_REG_addr, read_reg);         	
+	
+	// move upctl to power up state
+	cmd = 0x00000004;     
+    __prt_wr("SCTL", SCTL_REG_addr, cmd);
+	read_reg = 0x00000003; 
+	__prt_rd("STAT", STAT_REG_addr, read_reg);
+	__delay(); 
+
+	/*******************************************************
+	*   TRAINING STARTS                                    *
+	*******************************************************/
+
+	//move upctl to config state
+	cmd = 0x00000001;     
+    __prt_wr("SCTL", SCTL_REG_addr, cmd);
+	read_reg = 0x00000001; 
+	__prt_rd("STAT", STAT_REG_addr, read_reg);
+	__delay();
+	
+	for (rank=0; rank<ddr_rank; rank++) {	
+		if (ddr_type == 2)	
+			cmd = 0x90007887 | (((ddr_rank)==2?3:1)<<24) | (rank<<4);
+		else {
+			if ((ddr_grade)>5)
+				cmd = 0x900035c7 | (((ddr_rank)==2?3:1)<<24) | (rank<<4);	
+							//def=0x93003587 high freq uses 1/4CK 0x910035c7
+			else
+				cmd = 0x900078c7 | (((ddr_rank)==2?3:1)<<24) | (rank<<4);	
+							//def=0x93003587 low freq uses margin override
+		}
+		__prt_wr("PUB_DTCR", PUB_DTCR_REG_addr, cmd);
+
+		//clear status bits pgsr resgister bits
+    	cmd = 0x08000000;
+    	__prt_wr("PUB_PIR", PUB_PIR_REG_addr, cmd);
+		read_reg = 0xb0000017; 
+		__prt_rd("PUB_PGSR0", PUB_PGSR0_REG_addr, read_reg);
+		__delay();
+
+		seed(0, (rank==0)?sr0[0]:sr1[0], 0);	
+		seed(1, (rank==0)?sr0[1]:sr1[1], 0);	
+
+		if (ddr_type == 2) {
+			cmd = 0xf401; 
+			__prt_wr("PUB_PIR", PUB_PIR_REG_addr, cmd);
+			read_reg = 0xb0000f57;          
+			__prt_rd("PUB_PGSR0", PUB_PGSR0_REG_addr, read_reg);
+		}
+		else  {
+			cmd = 0xfe01;
+			__prt_wr("PUB_PIR", PUB_PIR_REG_addr, cmd);
+			read_reg = 0xb0000ff7; 
+			__prt_rd("PUB_PGSR0", PUB_PGSR0_REG_addr, read_reg);
+		}
+	}
+	
+	//move upctl back to access state
+	cmd = 0x2;     
+    __prt_wr("SCTL", SCTL_REG_addr, cmd);
+    read_reg = 0x3; 
+	__prt_rd("STAT", STAT_REG_addr, read_reg);
+
+	fclose(fp);
+	
+	return 0;
+}
diff --git a/board/grx500/init_ddr.h b/board/grx500/init_ddr.h
new file mode 100644
--- /dev/null
+++ b/board/grx500/init_ddr.h
@@ -0,0 +1,164 @@
+/**************************************************************************
+ * Definition of SoC specific address mapping                             *
+ **************************************************************************/
+//Use address registers uncached otherwise exception with exception code 2
+//#define PUB_BASE     0x12000000
+#define PUB_BASE       0xb2000000
+//#define uPCTL_BASE   0x12100000
+#define uPCTL_BASE     0xb2100000
+//#define MEMAX_BASE   0x12200000
+#define MEMAX_BASE     0xb2200000
+#define DDR3_1_BASE    0x20000000
+#define DDR3_2_BASE    0x40000000
+
+/**************************************************************************
+ * Definition of DDR3 controller/phy  specific address mapping            *
+ **************************************************************************/
+#define DFILPCFG0_REG_addr 	 	(0x000002f0 + uPCTL_BASE)
+#define DFISTCFG0_REG_addr 	 	(0x000002c4 + uPCTL_BASE)
+#define DFISTCFG1_REG_addr 	 	(0x000002c8 + uPCTL_BASE)
+#define DFISTCFG2_REG_addr 	 	(0x000002d8 + uPCTL_BASE)
+#define DFISTSTAT0_REG_addr 	(0x000002c0 + uPCTL_BASE)
+#define DFITPHYRDLAT_REG_addr 	(0x00000264 + uPCTL_BASE)
+#define DFITPHYWRLAT_REG_addr 	(0x00000254 + uPCTL_BASE)
+#define DFITPHYWRDATALAT_REG_addr 	(0x00000258 + uPCTL_BASE)
+#define DFITRDDATAEN_REG_addr 	(0x00000260 + uPCTL_BASE)
+#define DFIUPDCFG_REG_addr 	 	(0x00000290 + uPCTL_BASE)
+#define ECCCFG_REG_addr 	 	(0x00000180 + uPCTL_BASE)
+#define EFI_MEM_DDR3_REG_addr 	(0x00000148 + uPCTL_BASE)
+#define DFITCTRLDELAY_REG_addr 	(0x00000240 + uPCTL_BASE)
+#define DFITDRAMCLKEN_REG_addr 	(0x000002d0 + uPCTL_BASE)
+#define DFITPHYWRDATA_REG_addr 	(0x00000250 + uPCTL_BASE)
+#define DFITCTRLUPDMAX_REG_addr (0x00000284 + uPCTL_BASE)
+#define DFITDRAMCLKDIS_REG_addr (0x000002d4 + uPCTL_BASE)
+
+#define DFIODTCFG_REG_addr      (0x00000244 + uPCTL_BASE)
+#define DFIODTCFG1_REG_addr     (0x00000248 + uPCTL_BASE)
+#define DFIODTRANKMAP_REG_addr  (0x0000024c + uPCTL_BASE)
+
+
+#define MCFG1_REG_addr 	 		(0x0000007c + uPCTL_BASE)
+#define MCFG_REG_addr 	 		(0x00000080 + uPCTL_BASE)
+#define MCMD_REG_addr 	 		(0x00000040 + uPCTL_BASE)
+#define POWCTL_REG_addr 	 	(0x00000044 + uPCTL_BASE)
+#define POWSTAT_REG_addr 	 	(0x00000048 + uPCTL_BASE)
+#define CMDSTAT_REG_addr 	 	(0x0000004C + uPCTL_BASE)
+#define CMDSTATEN_REG_addr 	 	(0x00000050 + uPCTL_BASE)
+#define PPCFG_REG_addr 	 		(0x00000084 + uPCTL_BASE)
+
+#define PUB_RIDR_REG_addr 	 	(0x00000000 + PUB_BASE)
+#define PUB_PLLCR_REG_addr 	 	(0x00000018 + PUB_BASE)
+#define PUB_DCR_REG_addr 	 	(0x00000044 + PUB_BASE)
+#define PUB_DTPR0_REG_addr 	 	(0x00000048 + PUB_BASE)
+#define PUB_DTPR1_REG_addr 	 	(0x0000004c + PUB_BASE)
+#define PUB_DTPR2_REG_addr 	 	(0x00000050 + PUB_BASE)
+
+#define PUB_DX0LCDLR0_REG_addr  (0x000001e0 + PUB_BASE)
+#define PUB_DX0LCDLR1_REG_addr  (0x000001e4 + PUB_BASE)
+#define PUB_DX0LCDLR2_REG_addr  (0x000001e8 + PUB_BASE)
+
+#define PUB_DX1LCDLR0_REG_addr  (0x00000220 + PUB_BASE)
+#define PUB_DX1LCDLR1_REG_addr  (0x00000224 + PUB_BASE)
+#define PUB_DX1LCDLR2_REG_addr  (0x00000228 + PUB_BASE)
+
+#define PUB_DSGCR_REG_addr      (0x00000040 + PUB_BASE)
+#define PUB_MR0_REG_addr 	 	(0x00000054 + PUB_BASE)
+#define PUB_MR1_REG_addr 	 	(0x00000058 + PUB_BASE)
+#define PUB_MR2_REG_addr 	 	(0x0000005c + PUB_BASE)
+#define PUB_MR3_REG_addr 	 	(0x00000060 + PUB_BASE)
+#define PUB_PGCR0_REG_addr 	 	(0x00000008 + PUB_BASE)
+#define PUB_PGCR1_REG_addr 	 	(0x0000000c + PUB_BASE)
+#define PUB_PGCR2_REG_addr 	 	(0x0000008c + PUB_BASE)
+#define PUB_PGSR0_REG_addr 	 	(0x00000010 + PUB_BASE)
+#define PUB_PGSR1_REG_addr 	 	(0x00000014 + PUB_BASE)
+#define PUB_PIR_REG_addr 	 	(0x00000004 + PUB_BASE)
+#define PUB_PTR0_REG_addr 	 	(0x0000001c + PUB_BASE)
+#define PUB_PTR1_REG_addr 	 	(0x00000020 + PUB_BASE)
+#define PUB_PTR2_REG_addr 	 	(0x00000024 + PUB_BASE)
+#define PUB_PTR3_REG_addr 	 	(0x00000028 + PUB_BASE)
+#define PUB_PTR4_REG_addr 	 	(0x0000002c + PUB_BASE)
+#define PUB_GX0GTR_REG_addr	 	(0x000001f0 + PUB_BASE)
+#define PUB_GX1GTR_REG_addr	 	(0x00000230 + PUB_BASE)
+#define PUB_GX2GTR_REG_addr	 	(0x00000270 + PUB_BASE)
+#define PUB_GX3GTR_REG_addr	 	(0x000002b0 + PUB_BASE)
+
+#define PUB_DX0GCR_REG_addr	 	(0x000001c0 + PUB_BASE)
+#define PUB_DX0GSR0_REG_addr	(0x000001c4 + PUB_BASE)
+#define PUB_DX0GSR1_REG_addr	(0x000001c8 + PUB_BASE)
+#define PUB_DX0GSR2_REG_addr	(0x000001f4 + PUB_BASE)
+#define PUB_DX0GTR_REG_addr		(0x000001f0 + PUB_BASE)
+#define PUB_DX0MDLR_REG_addr	(0x000001ec + PUB_BASE)
+
+#define PUB_DX0BDLR0_REG_addr	(0x000001cc + PUB_BASE)
+#define PUB_DX0BDLR1_REG_addr	(0x000001d0 + PUB_BASE)
+#define PUB_DX0BDLR2_REG_addr	(0x000001d4 + PUB_BASE)
+#define PUB_DX0BDLR3_REG_addr	(0x000001d8 + PUB_BASE)
+#define PUB_DX0BDLR4_REG_addr	(0x000001dc + PUB_BASE)
+
+#define PUB_DX1GCR_REG_addr	 	(0x00000200 + PUB_BASE)
+#define PUB_DX1GSR0_REG_addr	(0x00000204 + PUB_BASE)
+#define PUB_DX1GSR1_REG_addr	(0x00000208 + PUB_BASE)
+#define PUB_DX1GSR2_REG_addr	(0x00000234 + PUB_BASE)
+#define PUB_DX1GTR_REG_addr		(0x00000230 + PUB_BASE)
+#define PUB_DX1MDLR_REG_addr	(0x0000022c + PUB_BASE)
+
+#define PUB_DX1BDLR0_REG_addr	(0x0000020c + PUB_BASE)
+#define PUB_DX1BDLR1_REG_addr	(0x00000210 + PUB_BASE)
+#define PUB_DX1BDLR2_REG_addr	(0x00000214 + PUB_BASE)
+#define PUB_DX1BDLR3_REG_addr	(0x00000218 + PUB_BASE)
+#define PUB_DX1BDLR4_REG_addr	(0x0000021c + PUB_BASE)
+
+#define PUB_DXCCR_REG_addr	 	(0x0000003c + PUB_BASE)
+#define PUB_DTCR_REG_addr	 	(0x00000068 + PUB_BASE)
+
+#define PUB_DTDR0_REG_addr	 	(0x0000007c + PUB_BASE)
+#define PUB_DTDR1_REG_addr	 	(0x00000080 + PUB_BASE)
+#define PUB_DTEDR0_REG_addr	 	(0x00000084 + PUB_BASE)
+#define PUB_DTEDR1_REG_addr	 	(0x00000088 + PUB_BASE)
+
+#define PUB_ZQ0CR0_REG_addr	 	(0x00000180 + PUB_BASE)
+#define PUB_ZQ0CR1_REG_addr	 	(0x00000184 + PUB_BASE)
+#define PUB_ZQ1CR0_REG_addr	 	(0x00000190 + PUB_BASE)
+#define PUB_ZQ1CR1_REG_addr	 	(0x00000194 + PUB_BASE)
+
+#define PUB_ACMDLR 				(0x00000030 + PUB_BASE)
+#define PUB_ACBDLR 				(0x00000034 + PUB_BASE)
+#define PUB_ACIOCR 				(0x00000038 + PUB_BASE)
+
+#define SCFG_REG_addr 	 		(0x00000000 + uPCTL_BASE)
+#define SCTL_REG_addr 	 		(0x00000004 + uPCTL_BASE)
+#define STAT_REG_addr 	 		(0x00000008 + uPCTL_BASE)
+#define TAL_REG_addr 			(0x000000e4 + uPCTL_BASE)
+#define TCKESR_REG_addr  		(0x00000140 + uPCTL_BASE)
+#define TCKE_REG_addr 	 		(0x0000012c + uPCTL_BASE)
+#define TCKSRE_REG_addr  		(0x00000124 + uPCTL_BASE)
+#define TCKSRX_REG_addr  		(0x00000128 + uPCTL_BASE)
+#define TCL_REG_addr 	 		(0x000000e8 + uPCTL_BASE)
+#define TCWL_REG_addr 	 		(0x000000ec + uPCTL_BASE)
+#define TDPD_REG_addr 	 		(0x00000144 + uPCTL_BASE)
+#define TDQS_REG_addr 	 		(0x00000120 + uPCTL_BASE)
+#define TEXSR_REG_addr 	 		(0x0000010c + uPCTL_BASE)
+#define TINIT_REG_addr 	 		(0x000000c4 + uPCTL_BASE)
+#define TMOD_REG_addr 	 		(0x00000130 + uPCTL_BASE)
+#define TMRD_REG_addr 	 		(0x000000d4 + uPCTL_BASE)
+#define TOGCNT100N_REG_addr  	(0x000000cc + uPCTL_BASE)
+#define TOGCNT1U_REG_addr 	 	(0x000000c0 + uPCTL_BASE)
+#define TRAS_REG_addr 	 		(0x000000f0 + uPCTL_BASE)
+#define TRCD_REG_addr 	 		(0x000000f8 + uPCTL_BASE)
+#define TRC_REG_addr 	 		(0x000000f4 + uPCTL_BASE)
+#define TREFI_REG_addr 	 		(0x000000d0 + uPCTL_BASE)
+#define TRFC_REG_addr 	 		(0x000000d8 + uPCTL_BASE)
+#define TRP_REG_addr 	 		(0x000000dc + uPCTL_BASE)
+#define TRRD_REG_addr 	 		(0x000000fc + uPCTL_BASE)
+#define TRSTH_REG_addr 	 		(0x000000c8 + uPCTL_BASE)
+#define TRSTL_REG_addr 	 		(0x00000134 + uPCTL_BASE)
+#define TRTP_REG_addr 	 		(0x00000100 + uPCTL_BASE)
+#define TRTW_REG_addr 	 		(0x000000e0 + uPCTL_BASE)
+#define TWR_REG_addr 	 		(0x00000104 + uPCTL_BASE)
+#define TWTR_REG_addr 	 		(0x00000108 + uPCTL_BASE)
+#define TXPDLL_REG_addr  		(0x00000114 + uPCTL_BASE)
+#define TXP_REG_addr 	 		(0x00000110 + uPCTL_BASE)
+#define TZQCL_REG_addr 	 		(0x00000138 + uPCTL_BASE)
+#define TZQCSI_REG_addr  		(0x0000011c + uPCTL_BASE)
+#define TZQCS_REG_addr 	 		(0x00000118 + uPCTL_BASE)
+
diff --git a/board/grx500/load-t32-ddr2-config-10oct2014.cmm b/board/grx500/load-t32-ddr2-config-10oct2014.cmm
new file mode 100755
--- /dev/null
+++ b/board/grx500/load-t32-ddr2-config-10oct2014.cmm
@@ -0,0 +1,157 @@
+;SYStem.CPU MIPSINTERAPTIV 
+SYStem.CPU MIPS4kec 
+
+SYStem.JTAGCLOCK 4mhz
+SYSTEM.CPUACCESS Enable
+SYSTEM.MEMACCESS CPU
+SYStem.Option TURBO OFF
+SYStem.MODE NODEBUG
+SYStem.Down
+SYStem.CONFIG.IRPOST  25.
+SYStem.CONFIG.DRPOST  5.
+SYStem.CONFIG.IRPRE   0.
+SYStem.CONFIG.DRPRE   0.
+Core.Number 1.
+SYStem.MODE NODEBUG
+SYStem.MODE ATTACH
+SYStem.Option TURBO OFF
+break
+
+Data.Set 0xb2200004 %Long 0x100c0020
+Data.Set 0xb2200124 %Long 0x0f2c420a
+Data.Set 0xb2200120 %Long 0x000000d8
+
+Data.Set 0xb49001d0 %Long 0xf0002000
+Data.Set 0xb49001d8 %Long 0xfe00a000
+
+Data.Set 0xb21000c0 %Long 0x000000c8
+Data.Set 0xb21000c4 %Long 0x000000c8
+Data.Set 0xb21000cc %Long 0x00000014
+Data.Set 0xb21000c8 %Long 0x00000000
+Data.Set 0xb2100134 %Long 0x00000000
+Data.Set 0xb2100080 %Long 0x00040000
+Data.Set 0xb210007c %Long 0x00000200
+Data.Set 0xb2000044 %Long 0x0000040a
+Data.Set 0xb2000054 %Long 0x00000b62
+Data.Set 0xb2000058 %Long 0x00000002
+Data.Set 0xb200005c %Long 0x00000000
+Data.Set 0xb2000060 %Long 0x00000000
+Data.Set 0xb2000048 %Long 0x61126633
+Data.Set 0xb200004c %Long 0x22815252
+Data.Set 0xb2000050 %Long 0x100188c8
+Data.Set 0xb200008c %Long 0x00f06db0
+Data.Set 0xb200001c %Long 0x1900c810
+Data.Set 0xb2000020 %Long 0x4e200258
+Data.Set 0xb2000024 %Long 0x00083def
+Data.In  0xb2000004 /Long                ;=0x00000000
+Data.Set 0xb2000004 %Long 0x60000000
+Data.In  0xb2000010 /Long                ;=0xb000000f
+Data.Set 0xb20001e8 %Long 0x00006e6e
+Data.Set 0xb2000228 %Long 0x00006e6e
+Data.Set 0xb2000004 %Long 0x00040001
+Data.In  0xb2000010 /Long                ;=0xb000001f
+Data.In  0xb21002c0 /Long                ;=0x00000001
+Data.Set 0xb2100044 %Long 0x00000001
+Data.In  0xb2100048 /Long                ;=0x00000001
+Data.Set 0xb21000c0 %Long 0x000000c8
+Data.Set 0xb21000c4 %Long 0x000000c8
+Data.Set 0xb21000cc %Long 0x00000014
+Data.Set 0xb21000d0 %Long 0x8001009c
+Data.Set 0xb21000d4 %Long 0x00000002
+Data.Set 0xb21000d8 %Long 0x0000002a
+Data.Set 0xb21000dc %Long 0x00000006
+Data.Set 0xb21000e4 %Long 0x00000000
+Data.Set 0xb21000e8 %Long 0x00000006
+Data.Set 0xb21000ec %Long 0x00000005
+Data.Set 0xb21000f0 %Long 0x00000012
+Data.Set 0xb21000f4 %Long 0x00000018
+Data.Set 0xb21000f8 %Long 0x00000006
+Data.Set 0xb21000fc %Long 0x00000004
+Data.Set 0xb2100100 %Long 0x00000003
+Data.Set 0xb21000e0 %Long 0x00000002
+Data.Set 0xb2100104 %Long 0x00000006
+Data.Set 0xb2100108 %Long 0x00000003
+Data.Set 0xb210010c %Long 0x000000c8
+Data.Set 0xb2100110 %Long 0x00000002
+Data.Set 0xb2100120 %Long 0x00000001
+Data.Set 0xb2100124 %Long 0x00000000
+Data.Set 0xb2100128 %Long 0x00000000
+Data.Set 0xb2100130 %Long 0x00000000
+Data.Set 0xb210012c %Long 0x00000003
+Data.Set 0xb21000c8 %Long 0x00000000
+Data.Set 0xb2100134 %Long 0x00000000
+Data.Set 0xb2100118 %Long 0x00000000
+Data.Set 0xb2100138 %Long 0x00000000
+Data.Set 0xb2100114 %Long 0x0000000a
+Data.Set 0xb210011c %Long 0x00000000
+Data.Set 0xb2100140 %Long 0x00000000
+Data.Set 0xb2100144 %Long 0x00000000
+Data.Set 0xb2100148 %Long 0x00000000
+Data.Set 0xb2100000 %Long 0x00004780
+Data.Set 0xb2100254 %Long 0x00000001
+Data.Set 0xb2100260 %Long 0x00000004
+Data.Set 0xb2100250 %Long 0x00000001
+Data.Set 0xb2100258 %Long 0x00000003
+Data.Set 0xb2100264 %Long 0x0000000f
+Data.Set 0xb21002d4 %Long 0x00000002
+Data.Set 0xb21002d0 %Long 0x00000002
+Data.Set 0xb2100240 %Long 0x00000002
+Data.Set 0xb2100284 %Long 0x00000040
+Data.Set 0xb2100290 %Long 0x00000007
+Data.Set 0xb2100040 %Long 0x86f00000
+Data.In  0xb2100040 /Long                ;=0x06f00000
+Data.Set 0xb2100040 %Long 0x80f00001
+Data.In  0xb2100040 /Long                ;=0x00f00001
+Data.Set 0xb2100040 %Long 0x80f40003
+Data.In  0xb2100040 /Long                ;=0x00f40003
+Data.Set 0xb2100040 %Long 0x80f60003
+Data.In  0xb2100040 /Long                ;=0x00f60003
+Data.Set 0xb2100040 %Long 0x80f20023
+Data.In  0xb2100040 /Long                ;=0x00f20023
+Data.Set 0xb2100040 %Long 0x80f0b623
+Data.In  0xb2100040 /Long                ;=0x00f0b623
+Data.Set 0xb2100040 %Long 0x80f00001
+Data.In  0xb2100040 /Long                ;=0x00f00001
+Data.Set 0xb2100040 %Long 0x80f00002
+Data.In  0xb2100040 /Long                ;=0x00f00002
+Data.Set 0xb2100040 %Long 0x80f00002
+Data.In  0xb2100040 /Long                ;=0x00f00002
+Data.Set 0xb2100040 %Long 0x80f0a623
+Data.In  0xb2100040 /Long                ;=0x00f0a623
+Data.Set 0xb2100040 %Long 0x80f20023
+Data.In  0xb2100040 /Long                ;=0x00f20023
+Data.Set 0xb2100040 %Long 0x80f00005
+Data.In  0xb2100040 /Long                ;=0x00f00005
+Data.Set 0xb2100040 %Long 0x80f0000a
+Data.In  0xb2100040 /Long                ;=0x00f0000a
+Data.Set 0xb2100004 %Long 0x00000001
+Data.In  0xb2100008 /Long                ;=0x00000001
+Data.Set 0xb2100084 %Long 0x00000000
+Data.Set 0xb21002c4 %Long 0x00000007
+Data.Set 0xb21002c8 %Long 0x00000003
+Data.Set 0xb21002d8 %Long 0x00000000
+Data.Set 0xb21002f0 %Long 0x00070101
+Data.Set 0xb2100180 %Long 0x00000000
+Data.Set 0xb2100290 %Long 0x00000003
+Data.Set 0xb2100050 %Long 0x00000001
+Data.In  0xb210004c /Long                ;=0x00000001
+Data.Set 0xb2000004 %Long 0x00000200
+Data.In  0xb2000010 /Long                ;=0xb000003f
+Data.Set 0xb2000004 %Long 0x00000400
+Data.In  0xb2000010 /Long                ;=0xb000007f
+Data.Set 0xb2000004 %Long 0x00000800
+Data.In  0xb2000010 /Long                ;=0xb00000ff
+Data.Set 0xb2000004 %Long 0x00001000
+Data.In  0xb2000010 /Long                ;=0xb00001ff
+Data.Set 0xb2000004 %Long 0x00002000
+Data.In  0xb2000010 /Long                ;=0xb00003ff
+Data.Set 0xb2000004 %Long 0x00004000
+Data.In  0xb2000010 /Long                ;=0xb00007ff
+Data.Set 0xb2000004 %Long 0x00008000
+Data.In  0xb2000010 /Long                ;=0xb0000fff
+Data.Set 0xb2100004 %Long 0x00000002
+Data.In  0xb2100008 /Long                ;=0x00000003
+
+go
+;SYStem.Down
+
diff --git a/board/grx500/load-t32-ddr2-config.cmm b/board/grx500/load-t32-ddr2-config.cmm
new file mode 100755
--- /dev/null
+++ b/board/grx500/load-t32-ddr2-config.cmm
@@ -0,0 +1,157 @@
+;SYStem.CPU MIPSINTERAPTIV 
+SYStem.CPU MIPS4kec 
+
+SYStem.JTAGCLOCK 4mhz
+SYSTEM.CPUACCESS Enable
+SYSTEM.MEMACCESS CPU
+SYStem.Option TURBO OFF
+SYStem.MODE NODEBUG
+SYStem.Down
+SYStem.CONFIG.IRPOST  25.
+SYStem.CONFIG.DRPOST  5.
+SYStem.CONFIG.IRPRE   0.
+SYStem.CONFIG.DRPRE   0.
+Core.Number 1.
+SYStem.MODE NODEBUG
+SYStem.MODE ATTACH
+SYStem.Option TURBO OFF
+break
+
+Data.Set 0xb2200000 %Long 0x100c0020
+Data.Set 0xb2200120 %Long 0x000d838c
+Data.Set 0xb2200124 %Long 0x016c420a
+
+Data.Set 0xb49001d0 %Long 0xf0002000
+Data.Set 0xb49001d8 %Long 0xfe00a000
+
+Data.Set 0xb21000c0 %Long 0x00000190
+Data.Set 0xb21000c4 %Long 0x000000c8
+Data.Set 0xb21000cc %Long 0x00000028
+Data.Set 0xb21000c8 %Long 0x00000000
+Data.Set 0xb2100134 %Long 0x00000032
+Data.Set 0xb2100080 %Long 0x00040000
+Data.Set 0xb210007c %Long 0x00000200
+Data.Set 0xb2000044 %Long 0x0000040a
+Data.Set 0xb2000054 %Long 0x00000b62
+Data.Set 0xb2000058 %Long 0x00000000
+Data.Set 0xb200005c %Long 0x00000000
+Data.Set 0xb2000060 %Long 0x00000000
+Data.Set 0xb2000048 %Long 0x61126644
+Data.Set 0xb200004c %Long 0x00015243
+Data.Set 0xb2000050 %Long 0x10018c03
+Data.Set 0xb200008c %Long 0x00f46db0
+Data.Set 0xb200001c %Long 0x32019010
+Data.Set 0xb2000020 %Long 0x9c4004b0
+Data.Set 0xb2000024 %Long 0x00083def
+Data.In  0xb2000004 /Long                ;=0x00000000
+Data.Set 0xb2000004 %Long 0x60000000
+Data.In  0xb2000010 /Long                ;=0xb000000f
+Data.Set 0xb20001e8 %Long 0x00006e6e
+Data.Set 0xb2000228 %Long 0x00006e6e
+Data.Set 0xb2000004 %Long 0x00040001
+Data.In  0xb2000010 /Long                ;=0xb000001f
+Data.In  0xb21002c0 /Long                ;=0x00000001
+Data.Set 0xb2100044 %Long 0x00000001
+Data.In  0xb2100048 /Long                ;=0x00000001
+Data.Set 0xb21000c0 %Long 0x00000190
+Data.Set 0xb21000c4 %Long 0x000000c8
+Data.Set 0xb21000cc %Long 0x00000028
+Data.Set 0xb21000d0 %Long 0x80030138
+Data.Set 0xb21000d4 %Long 0x00000003
+Data.Set 0xb21000d8 %Long 0x0000002a
+Data.Set 0xb21000dc %Long 0x00000006
+Data.Set 0xb21000e4 %Long 0x00000000
+Data.Set 0xb21000e8 %Long 0x00000006
+Data.Set 0xb21000ec %Long 0x00000005
+Data.Set 0xb21000f0 %Long 0x00000012
+Data.Set 0xb21000f4 %Long 0x00000018
+Data.Set 0xb21000f8 %Long 0x00000006
+Data.Set 0xb21000fc %Long 0x00000004
+Data.Set 0xb2100100 %Long 0x00000004
+Data.Set 0xb21000e0 %Long 0x00000002
+Data.Set 0xb2100104 %Long 0x00000006
+Data.Set 0xb2100108 %Long 0x00000004
+Data.Set 0xb210010c %Long 0x000000c8
+Data.Set 0xb2100110 %Long 0x00000003
+Data.Set 0xb2100120 %Long 0x00000004
+Data.Set 0xb2100124 %Long 0x00000000
+Data.Set 0xb2100128 %Long 0x00000000
+Data.Set 0xb2100130 %Long 0x00000000
+Data.Set 0xb210012c %Long 0x00000003
+Data.Set 0xb21000c8 %Long 0x00000000
+Data.Set 0xb2100134 %Long 0x00000000
+Data.Set 0xb2100118 %Long 0x00000000
+Data.Set 0xb2100138 %Long 0x00000000
+Data.Set 0xb2100114 %Long 0x00000003
+Data.Set 0xb210011c %Long 0x00000000
+Data.Set 0xb2100140 %Long 0x00000000
+Data.Set 0xb2100144 %Long 0x00000000
+Data.Set 0xb2100148 %Long 0x00000000
+Data.Set 0xb2100000 %Long 0x00004780
+Data.Set 0xb2100254 %Long 0x00000001
+Data.Set 0xb2100260 %Long 0x00000003
+Data.Set 0xb2100258 %Long 0x00000003
+Data.Set 0xb2100250 %Long 0x00000001
+Data.Set 0xb2100264 %Long 0x0000000f
+Data.Set 0xb21002d4 %Long 0x00000002
+Data.Set 0xb21002d0 %Long 0x00000002
+Data.Set 0xb2100240 %Long 0x00000002
+Data.Set 0xb2100284 %Long 0x00000040
+Data.Set 0xb2100290 %Long 0x00000007
+Data.Set 0xb2100040 %Long 0x86f00000
+Data.In  0xb2100040 /Long                ;=0x06f00000
+Data.Set 0xb2100040 %Long 0x80f00001
+Data.In  0xb2100040 /Long                ;=0x00f00001
+Data.Set 0xb2100040 %Long 0x80f40003
+Data.In  0xb2100040 /Long                ;=0x00f40003
+Data.Set 0xb2100040 %Long 0x80f60003
+Data.In  0xb2100040 /Long                ;=0x00f60003
+Data.Set 0xb2100040 %Long 0x80f20003
+Data.In  0xb2100040 /Long                ;=0x00f20003
+Data.Set 0xb2100040 %Long 0x80f0b623
+Data.In  0xb2100040 /Long                ;=0x00f0b623
+Data.Set 0xb2100040 %Long 0x80f00001
+Data.In  0xb2100040 /Long                ;=0x00f00001
+Data.Set 0xb2100040 %Long 0x80f00002
+Data.In  0xb2100040 /Long                ;=0x00f00002
+Data.Set 0xb2100040 %Long 0x80f00002
+Data.In  0xb2100040 /Long                ;=0x00f00002
+Data.Set 0xb2100040 %Long 0x80f0a623
+Data.In  0xb2100040 /Long                ;=0x00f0a623
+Data.Set 0xb2100040 %Long 0x80f20003
+Data.In  0xb2100040 /Long                ;=0x00f20003
+Data.Set 0xb2100040 %Long 0x80f00005
+Data.In  0xb2100040 /Long                ;=0x00f00005
+Data.Set 0xb2100040 %Long 0x80f0000a
+Data.In  0xb2100040 /Long                ;=0x00f0000a
+Data.Set 0xb2100004 %Long 0x00000001
+Data.In  0xb2100008 /Long                ;=0x00000001
+Data.Set 0xb2100084 %Long 0x00000000
+Data.Set 0xb21002c4 %Long 0x00000007
+Data.Set 0xb21002c8 %Long 0x00000003
+Data.Set 0xb21002d8 %Long 0x00000000
+Data.Set 0xb21002f0 %Long 0x00070101
+Data.Set 0xb2100180 %Long 0x00000000
+Data.Set 0xb2100290 %Long 0x00000003
+Data.Set 0xb2100050 %Long 0x00000001
+Data.In  0xb210004c /Long                ;=0x00000001
+Data.Set 0xb2000004 %Long 0x00000200
+Data.In  0xb2000010 /Long                ;=0xb000003f
+Data.Set 0xb2000004 %Long 0x00000400
+Data.In  0xb2000010 /Long                ;=0xb000007f
+Data.Set 0xb2000004 %Long 0x00000800
+Data.In  0xb2000010 /Long                ;=0xb00000ff
+Data.Set 0xb2000004 %Long 0x00001000
+Data.In  0xb2000010 /Long                ;=0xb00001ff
+Data.Set 0xb2000004 %Long 0x00002000
+Data.In  0xb2000010 /Long                ;=0xb00003ff
+Data.Set 0xb2000004 %Long 0x00004000
+Data.In  0xb2000010 /Long                ;=0xb00007ff
+Data.Set 0xb2000004 %Long 0x00008000
+Data.In  0xb2000010 /Long                ;=0xb0000fff
+Data.Set 0xb2100004 %Long 0x00000002
+Data.In  0xb2100008 /Long                ;=0x00000003
+
+go
+;SYStem.Down
+
diff --git a/board/grx500/load-t32-ddr3-config-10oct2014.cmm b/board/grx500/load-t32-ddr3-config-10oct2014.cmm
new file mode 100755
--- /dev/null
+++ b/board/grx500/load-t32-ddr3-config-10oct2014.cmm
@@ -0,0 +1,144 @@
+;SYStem.CPU MIPSINTERAPTIV 
+SYStem.CPU MIPS4kec 
+
+SYStem.JTAGCLOCK 200khz
+SYSTEM.CPUACCESS Enable
+SYSTEM.MEMACCESS CPU
+SYStem.Option TURBO OFF
+SYStem.MODE NODEBUG
+SYStem.Down
+SYStem.CONFIG.IRPOST  25.
+SYStem.CONFIG.DRPOST  5.
+SYStem.CONFIG.IRPRE   0.
+SYStem.CONFIG.DRPRE   0.
+Core.Number 1.
+SYStem.MODE NODEBUG
+SYStem.MODE ATTACH
+SYStem.Option TURBO OFF
+break
+
+Data.Set 0xb2200004 %Long 0x100c0131
+Data.Set 0xb2200124 %Long 0x0461128b
+Data.Set 0xb2200120 %Long 0x00000000
+
+Data.Set 0xb49001d0 %Long 0xf0002000
+Data.Set 0xb49001d8 %Long 0xfe00a000
+
+Data.Set 0xb21000c0 %Long 0x0000014d
+Data.Set 0xb21000c4 %Long 0x00000001
+Data.Set 0xb21000cc %Long 0x00000021
+Data.Set 0xb21000c8 %Long 0x00000001
+Data.Set 0xb2100134 %Long 0x00000044
+Data.Set 0xb2100080 %Long 0x00080021
+Data.Set 0xb210007c %Long 0x00000000
+Data.Set 0xb2000044 %Long 0x0000040b
+Data.Set 0xb2000054 %Long 0x00000b50
+Data.Set 0xb2000058 %Long 0x000000ce
+Data.Set 0xb200005c %Long 0x00000010
+Data.Set 0xb2000060 %Long 0x00000000
+Data.Set 0xb2000048 %Long 0x85589955
+Data.Set 0xb200004c %Long 0x228253c0
+Data.Set 0xb2000050 %Long 0x10021050
+Data.Set 0xb200008c %Long 0x00f8b6d0
+Data.Set 0xb200001c %Long 0x29a14d10
+Data.Set 0xb2000020 %Long 0x821403e7
+Data.Set 0xb2000024 %Long 0x00083def
+Data.In  0xb2000004 /Long                ;=0x00000000
+Data.Set 0xb2000004 %Long 0x60000000
+Data.In  0xb2000010 /Long                ;=0xb000000f
+Data.Set 0xb20001e8 %Long 0x00006e6e
+Data.Set 0xb2000228 %Long 0x00006e6e
+Data.Set 0xb2000004 %Long 0x00040001
+Data.In  0xb2000010 /Long                ;=0xb000001f
+Data.In  0xb21002c0 /Long                ;=0x00000001
+Data.Set 0xb2100044 %Long 0x00000001
+Data.In  0xb2100048 /Long                ;=0x00000001
+Data.Set 0xb21000c0 %Long 0x0000014d
+Data.Set 0xb21000c4 %Long 0x00000001
+Data.Set 0xb21000cc %Long 0x00000021
+Data.Set 0xb21000d0 %Long 0x8001009c
+Data.Set 0xb21000d4 %Long 0x00000004
+Data.Set 0xb21000d8 %Long 0x0000004a
+Data.Set 0xb21000dc %Long 0x00000009
+Data.Set 0xb21000e4 %Long 0x00000008
+Data.Set 0xb21000e8 %Long 0x00000009
+Data.Set 0xb21000ec %Long 0x00000007
+Data.Set 0xb21000f0 %Long 0x00000018
+Data.Set 0xb21000f4 %Long 0x00000021
+Data.Set 0xb21000f8 %Long 0x00000009
+Data.Set 0xb21000fc %Long 0x00000005
+Data.Set 0xb2100100 %Long 0x00000005
+Data.Set 0xb21000e0 %Long 0x00000002
+Data.Set 0xb2100104 %Long 0x0000000a
+Data.Set 0xb2100108 %Long 0x00000005
+Data.Set 0xb210010c %Long 0x00000200
+Data.Set 0xb2100110 %Long 0x00000004
+Data.Set 0xb2100120 %Long 0x00000001
+Data.Set 0xb2100124 %Long 0x00000007
+Data.Set 0xb2100128 %Long 0x00000007
+Data.Set 0xb2100130 %Long 0x0000000c
+Data.Set 0xb210012c %Long 0x00000004
+Data.Set 0xb21000c8 %Long 0x00000001
+Data.Set 0xb2100134 %Long 0x00000044
+Data.Set 0xb2100118 %Long 0x00000040
+Data.Set 0xb2100138 %Long 0x00000200
+Data.Set 0xb2100114 %Long 0x00000010
+Data.Set 0xb210011c %Long 0x00000005
+Data.Set 0xb2100140 %Long 0x00000005
+Data.Set 0xb2100144 %Long 0x00000000
+Data.Set 0xb2100148 %Long 0x00001458
+Data.Set 0xb2100000 %Long 0x00004780
+Data.Set 0xb2100254 %Long 0x00000006
+Data.Set 0xb2100260 %Long 0x00000007
+Data.Set 0xb2100250 %Long 0x00000001
+Data.Set 0xb2100258 %Long 0x00000003
+Data.Set 0xb2100264 %Long 0x0000000f
+Data.Set 0xb21002d4 %Long 0x00000002
+Data.Set 0xb21002d0 %Long 0x00000002
+Data.Set 0xb2100240 %Long 0x00000002
+Data.Set 0xb2100284 %Long 0x00000040
+Data.Set 0xb2100290 %Long 0x00000007
+Data.Set 0xb2100040 %Long 0x86f00000
+Data.In  0xb2100040 /Long                ;=0x06f00000
+Data.Set 0xb2100040 %Long 0x80f40103
+Data.In  0xb2100040 /Long                ;=0x00f40103
+Data.Set 0xb2100040 %Long 0x80f60003
+Data.In  0xb2100040 /Long                ;=0x00f60003
+Data.Set 0xb2100040 %Long 0x80f20ce3
+Data.In  0xb2100040 /Long                ;=0x00f20ce3
+Data.Set 0xb2100040 %Long 0x80f0b503
+Data.In  0xb2100040 /Long                ;=0x00f0b503
+Data.Set 0xb2100040 %Long 0x80f00005
+Data.In  0xb2100040 /Long                ;=0x00f00005
+Data.Set 0xb2100040 %Long 0x80f0000a
+Data.In  0xb2100040 /Long                ;=0x00f0000a
+Data.Set 0xb2100004 %Long 0x00000001
+Data.In  0xb2100008 /Long                ;=0x00000001
+Data.Set 0xb2100084 %Long 0x00000000
+Data.Set 0xb21002c4 %Long 0x00000007
+Data.Set 0xb21002c8 %Long 0x00000003
+Data.Set 0xb21002d8 %Long 0x00000000
+Data.Set 0xb21002f0 %Long 0x00070101
+Data.Set 0xb2100180 %Long 0x00000000
+Data.Set 0xb2100290 %Long 0x00000003
+Data.Set 0xb2100050 %Long 0x00000001
+Data.In  0xb210004c /Long                ;=0x00000001
+Data.Set 0xb2000004 %Long 0x00000200
+Data.In  0xb2000010 /Long                ;=0xb000003f
+Data.Set 0xb2000004 %Long 0x00000400
+Data.In  0xb2000010 /Long                ;=0xb000007f
+Data.Set 0xb2000004 %Long 0x00000800
+Data.In  0xb2000010 /Long                ;=0xb00000ff
+Data.Set 0xb2000004 %Long 0x00001000
+Data.In  0xb2000010 /Long                ;=0xb00001ff
+Data.Set 0xb2000004 %Long 0x00002000
+Data.In  0xb2000010 /Long                ;=0xb00003ff
+Data.Set 0xb2000004 %Long 0x00004000
+Data.In  0xb2000010 /Long                ;=0xb00007ff
+Data.Set 0xb2000004 %Long 0x00008000
+Data.In  0xb2000010 /Long                ;=0xb0000fff
+Data.Set 0xb2100004 %Long 0x00000002
+Data.In  0xb2100008 /Long                ;=0x00000003
+
+go
+;SYStem.Down
diff --git a/board/grx500/load-t32-ddr3-config.cmm b/board/grx500/load-t32-ddr3-config.cmm
new file mode 100755
--- /dev/null
+++ b/board/grx500/load-t32-ddr3-config.cmm
@@ -0,0 +1,144 @@
+;SYStem.CPU MIPSINTERAPTIV 
+SYStem.CPU MIPS4kec 
+
+SYStem.JTAGCLOCK 200khz
+SYSTEM.CPUACCESS Enable
+SYSTEM.MEMACCESS CPU
+SYStem.Option TURBO OFF
+SYStem.MODE NODEBUG
+SYStem.Down
+SYStem.CONFIG.IRPOST  25.
+SYStem.CONFIG.DRPOST  5.
+SYStem.CONFIG.IRPRE   0.
+SYStem.CONFIG.DRPRE   0.
+Core.Number 1.
+SYStem.MODE NODEBUG
+SYStem.MODE ATTACH
+SYStem.Option TURBO OFF
+break
+
+Data.Set 0xb2200000 %Long 0x100c0131
+Data.Set 0xb2200120 %Long 0x00000000
+Data.Set 0xb2200124 %Long 0x0461128b
+
+Data.Set 0xb49001d0 %Long 0xf0002000
+Data.Set 0xb49001d8 %Long 0xfe00a000
+
+Data.Set 0xb21000c0 %Long 0x0000029a
+Data.Set 0xb21000c4 %Long 0x00000001
+Data.Set 0xb21000cc %Long 0x00000042
+Data.Set 0xb21000c8 %Long 0x00000001
+Data.Set 0xb2100134 %Long 0x0000004c
+Data.Set 0xb2100080 %Long 0x00080021
+Data.Set 0xb210007c %Long 0x00000000
+Data.Set 0xb2000044 %Long 0x0000040b
+Data.Set 0xb2000054 %Long 0x00000d50
+Data.Set 0xb2000058 %Long 0x0000000a
+Data.Set 0xb200005c %Long 0x00000010
+Data.Set 0xb2000060 %Long 0x00000000
+Data.Set 0xb2000048 %Long 0x85589964
+Data.Set 0xb200004c %Long 0x228253c8
+Data.Set 0xb2000050 %Long 0x1006b200
+Data.Set 0xb200008c %Long 0x00f4b6d0
+Data.Set 0xb200001c %Long 0x00200110
+Data.Set 0xb2000020 %Long 0x00640003
+Data.Set 0xb2000024 %Long 0x00083def
+Data.In  0xb2000004 /Long                ;=0x00000000
+Data.Set 0xb2000004 %Long 0x60000000
+Data.In  0xb2000010 /Long                ;=0xb000000f
+Data.Set 0xb20001e8 %Long 0x00006e6e
+Data.Set 0xb2000228 %Long 0x00006e6e
+Data.Set 0xb2000004 %Long 0x00040001
+Data.In  0xb2000010 /Long                ;=0xb000001f
+Data.In  0xb21002c0 /Long                ;=0x00000001
+Data.Set 0xb2100044 %Long 0x00000001
+Data.In  0xb2100048 /Long                ;=0x00000001
+Data.Set 0xb21000c0 %Long 0x0000029a
+Data.Set 0xb21000c4 %Long 0x00000001
+Data.Set 0xb21000cc %Long 0x00000042
+Data.Set 0xb21000d0 %Long 0x80030138
+Data.Set 0xb21000d4 %Long 0x00000004
+Data.Set 0xb21000d8 %Long 0x0000004a
+Data.Set 0xb21000dc %Long 0x00000009
+Data.Set 0xb21000e4 %Long 0x00000008
+Data.Set 0xb21000e8 %Long 0x00000009
+Data.Set 0xb21000ec %Long 0x00000007
+Data.Set 0xb21000f0 %Long 0x00000018
+Data.Set 0xb21000f4 %Long 0x00000021
+Data.Set 0xb21000f8 %Long 0x00000009
+Data.Set 0xb21000fc %Long 0x00000005
+Data.Set 0xb2100100 %Long 0x00000004
+Data.Set 0xb21000e0 %Long 0x00000002
+Data.Set 0xb2100104 %Long 0x0000000c
+Data.Set 0xb2100108 %Long 0x00000006
+Data.Set 0xb210010c %Long 0x00000200
+Data.Set 0xb2100110 %Long 0x0000000c
+Data.Set 0xb2100120 %Long 0x00000004
+Data.Set 0xb2100124 %Long 0x00000006
+Data.Set 0xb2100128 %Long 0x00000006
+Data.Set 0xb2100130 %Long 0x0000000d
+Data.Set 0xb210012c %Long 0x0000000d
+Data.Set 0xb21000c8 %Long 0x00000001
+Data.Set 0xb2100134 %Long 0x0000004c
+Data.Set 0xb2100118 %Long 0x00000040
+Data.Set 0xb2100138 %Long 0x00000200
+Data.Set 0xb2100114 %Long 0x0000000c
+Data.Set 0xb210011c %Long 0x00000005
+Data.Set 0xb2100140 %Long 0x0000000e
+Data.Set 0xb2100144 %Long 0x00000000
+Data.Set 0xb2100148 %Long 0x00001458
+Data.Set 0xb2100000 %Long 0x00004780
+Data.Set 0xb2100254 %Long 0x00000006
+Data.Set 0xb2100260 %Long 0x00000007
+Data.Set 0xb2100258 %Long 0x00000003
+Data.Set 0xb2100250 %Long 0x00000001
+Data.Set 0xb2100264 %Long 0x0000000f
+Data.Set 0xb21002d4 %Long 0x00000002
+Data.Set 0xb21002d0 %Long 0x00000002
+Data.Set 0xb2100240 %Long 0x00000002
+Data.Set 0xb2100284 %Long 0x00000040
+Data.Set 0xb2100290 %Long 0x00000007
+Data.Set 0xb2100040 %Long 0x86f00000
+Data.In  0xb2100040 /Long                ;=0x06f00000
+Data.Set 0xb2100040 %Long 0x80f40103
+Data.In  0xb2100040 /Long                ;=0x00f40103
+Data.Set 0xb2100040 %Long 0x80f60003
+Data.In  0xb2100040 /Long                ;=0x00f60003
+Data.Set 0xb2100040 %Long 0x80f200a3
+Data.In  0xb2100040 /Long                ;=0x00f200a3
+Data.Set 0xb2100040 %Long 0x80f0d503
+Data.In  0xb2100040 /Long                ;=0x00f0d503
+Data.Set 0xb2100040 %Long 0x80f00005
+Data.In  0xb2100040 /Long                ;=0x00f00005
+Data.Set 0xb2100040 %Long 0x80f0000a
+Data.In  0xb2100040 /Long                ;=0x00f0000a
+Data.Set 0xb2100004 %Long 0x00000001
+Data.In  0xb2100008 /Long                ;=0x00000001
+Data.Set 0xb2100084 %Long 0x00000000
+Data.Set 0xb21002c4 %Long 0x00000007
+Data.Set 0xb21002c8 %Long 0x00000003
+Data.Set 0xb21002d8 %Long 0x00000000
+Data.Set 0xb21002f0 %Long 0x00070101
+Data.Set 0xb2100180 %Long 0x00000000
+Data.Set 0xb2100290 %Long 0x00000003
+Data.Set 0xb2100050 %Long 0x00000001
+Data.In  0xb210004c /Long                ;=0x00000001
+Data.Set 0xb2000004 %Long 0x00000200
+Data.In  0xb2000010 /Long                ;=0xb000003f
+Data.Set 0xb2000004 %Long 0x00000400
+Data.In  0xb2000010 /Long                ;=0xb000007f
+Data.Set 0xb2000004 %Long 0x00000800
+Data.In  0xb2000010 /Long                ;=0xb00000ff
+Data.Set 0xb2000004 %Long 0x00001000
+Data.In  0xb2000010 /Long                ;=0xb00001ff
+Data.Set 0xb2000004 %Long 0x00002000
+Data.In  0xb2000010 /Long                ;=0xb00003ff
+Data.Set 0xb2000004 %Long 0x00004000
+Data.In  0xb2000010 /Long                ;=0xb00007ff
+Data.Set 0xb2000004 %Long 0x00008000
+Data.In  0xb2000010 /Long                ;=0xb0000fff
+Data.Set 0xb2100004 %Long 0x00000002
+Data.In  0xb2100008 /Long                ;=0x00000003
+
+go
+;SYStem.Down
diff --git a/board/grx500/lowlevel_init.S b/board/grx500/lowlevel_init.S
new file mode 100755
--- /dev/null
+++ b/board/grx500/lowlevel_init.S
@@ -0,0 +1,424 @@
+
+/*
+ *  Memory sub-system initialization code for INCA-IP2 development board.
+ *  Andre Messerschmidt
+ *  Copyright (c) 2005  Infineon Technologies AG 
+ *
+ *  Based on Inca-IP code 
+ *  Copyright (c) 2003  Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/* History:
+      Wu Qi Ming Sep 18, 2009 initial version
+ */
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+
+
+#define DDR_OFFSET   0xbf801000
+#define DDR_CCR00      (DDR_OFFSET + 0x0000 )
+#define DDR_CCR01      (DDR_OFFSET + 0x0010 )
+#define DDR_CCR02      (DDR_OFFSET + 0x0020 )
+#define DDR_CCR03      (DDR_OFFSET + 0x0030 )
+#define DDR_CCR04      (DDR_OFFSET + 0x0040 )
+#define DDR_CCR05      (DDR_OFFSET + 0x0050 )
+#define DDR_CCR06      (DDR_OFFSET + 0x0060 )
+#define DDR_CCR07      (DDR_OFFSET + 0x0070 )
+#define DDR_CCR08      (DDR_OFFSET + 0x0080 )
+#define DDR_CCR09      (DDR_OFFSET + 0x0090 )
+#define DDR_CCR10      (DDR_OFFSET + 0x00A0 )
+#define DDR_CCR11      (DDR_OFFSET + 0x00B0 )
+#define DDR_CCR12      (DDR_OFFSET + 0x00C0 )
+#define DDR_CCR13      (DDR_OFFSET + 0x00D0 )
+#define DDR_CCR14      (DDR_OFFSET + 0x00E0 )
+#define DDR_CCR15      (DDR_OFFSET + 0x00F0 )
+#define DDR_CCR16      (DDR_OFFSET + 0x0100 )
+#define DDR_CCR17      (DDR_OFFSET + 0x0110 )
+#define DDR_CCR18      (DDR_OFFSET + 0x0120 )
+#define DDR_CCR19      (DDR_OFFSET + 0x0130 )
+#define DDR_CCR20      (DDR_OFFSET + 0x0140 )
+#define DDR_CCR21      (DDR_OFFSET + 0x0150 )
+#define DDR_CCR22      (DDR_OFFSET + 0x0160 )
+#define DDR_CCR23      (DDR_OFFSET + 0x0170 )
+#define DDR_CCR24      (DDR_OFFSET + 0x0180 )
+#define DDR_CCR25      (DDR_OFFSET + 0x0190 )
+#define DDR_CCR26      (DDR_OFFSET + 0x01A0 )
+#define DDR_CCR27      (DDR_OFFSET + 0x01B0 )
+#define DDR_CCR28      (DDR_OFFSET + 0x01C0 )
+#define DDR_CCR29      (DDR_OFFSET + 0x01D0 )
+#define DDR_CCR30      (DDR_OFFSET + 0x01E0 )
+#define DDR_CCR31      (DDR_OFFSET + 0x01F0 )
+#define DDR_CCR32      (DDR_OFFSET + 0x0200 )
+#define DDR_CCR33      (DDR_OFFSET + 0x0210 )
+#define DDR_CCR34      (DDR_OFFSET + 0x0220 )
+#define DDR_CCR35      (DDR_OFFSET + 0x0230 )
+#define DDR_CCR36      (DDR_OFFSET + 0x0240 )
+#define DDR_CCR37      (DDR_OFFSET + 0x0250 )
+#define DDR_CCR38      (DDR_OFFSET + 0x0260 )
+#define DDR_CCR48      (DDR_OFFSET + 0x0270 )
+#define DDR_CCR49      (DDR_OFFSET + 0x0280 )
+#define DDR_CCR50      (DDR_OFFSET + 0x0290 )
+#define DDR_CCR51      (DDR_OFFSET + 0x02A0 )
+#define DDR_CCR54      (DDR_OFFSET + 0x02B0 )
+#define DDR_CCR55      (DDR_OFFSET + 0x02C0 )
+#define DDR_PHYR0      (DDR_OFFSET + 0x0400 )
+#define DDR_PHYR1      (DDR_OFFSET + 0x0410 )
+#define DDR_PHYR2      (DDR_OFFSET + 0x0420 )
+#define DDR_PHYR3      (DDR_OFFSET + 0x0430 )
+#define DDR_PHYR4      (DDR_OFFSET + 0x0440 )
+#define DDR_PHYR5      (DDR_OFFSET + 0x0450 )
+#define DDR_PHYR6      (DDR_OFFSET + 0x0460 )
+#define DDR_PHYR7      (DDR_OFFSET + 0x0470 )
+#define DDR_PHYR8      (DDR_OFFSET + 0x0480 )
+#define DDR_PHYR9      (DDR_OFFSET + 0x0490 )
+#define DDR_PHYR10     (DDR_OFFSET + 0x04A0 )
+#define DDR_PHYR11     (DDR_OFFSET + 0x04B0 )
+#define DDR_PHYR12     (DDR_OFFSET + 0x04C0 )
+#define DDR_PHYR13     (DDR_OFFSET + 0x04D0 )
+#define DDR_PHYR14     (DDR_OFFSET + 0x04E0 ) 
+#define DDR_PHYR15     (DDR_OFFSET + 0x04F0 )
+
+
+#ifdef CONFIG_AR10_CPU_125M_RAM_125M
+   #define CONFIG_AR10_CGU_SYS_VALUE    0x22
+#elif defined(CONFIG_AR10_CPU_250M_RAM_125M)
+   #define CONFIG_AR10_CGU_SYS_VALUE    0x12
+#elif defined(CONFIG_AR10_CPU_250M_RAM_250M)
+   #define CONFIG_AR10_CGU_SYS_VALUE    0x11
+#elif defined(CONFIG_AR10_CPU_500M_RAM_250M)
+   #define CONFIG_AR10_CGU_SYS_VALUE    0x01
+#elif defined(CONFIG_AR10_CPU_600M_RAM_150M) 
+   #define CONFIG_AR10_CGU_SYS_VALUE    0x102
+#elif defined(CONFIG_AR10_CPU_600M_RAM_300M)
+   #define CONFIG_AR10_CGU_SYS_VALUE    0x101
+#elif defined(CONFIG_AR10_CPU_150M_RAM_150M)
+   #define CONFIG_AR10_CGU_SYS_VALUE    0x122
+#elif defined(CONFIG_AR10_CPU_300M_RAM_150M)
+   #define CONFIG_AR10_CGU_SYS_VALUE    0x112
+#elif defined(CONFIG_AR10_CPU_300M_RAM_300M)
+   #define CONFIG_AR10_CGU_SYS_VALUE    0x111
+#elif defined(CONFIG_GRX390_CPU_666M_RAM_333M)
+   #define CONFIG_AR10_CGU_SYS_VALUE	0x301
+#elif defined(CONFIG_GRX390_CPU_180M_RAM_180M)
+   #define CONFIG_AR10_CGU_SYS_VALUE	0x522
+   #define CONFIG_GRX390_PLL2_CFG_VALUE 0x241 /* N = 9, M = 0 */
+#elif defined(CONFIG_GRX390_CPU_360M_RAM_180M)
+   #define CONFIG_AR10_CGU_SYS_VALUE	0x512
+   #define CONFIG_GRX390_PLL2_CFG_VALUE 0x241 /* N = 9, M = 0 */
+#elif defined(CONFIG_GRX390_CPU_360M_RAM_360M)
+   #define CONFIG_AR10_CGU_SYS_VALUE	0x511
+   #define CONFIG_GRX390_PLL2_CFG_VALUE 0x241 /* N = 9, M = 0 */
+#elif defined(CONFIG_GRX390_CPU_720M_RAM_360M)
+   #define CONFIG_AR10_CGU_SYS_VALUE	0x501
+   #define CONFIG_GRX390_PLL2_CFG_VALUE 0x241 /* N = 9, M = 0 */
+#else
+      /*fix me, put correct values here*/
+   #define CONFIG_AR10_CGU_SYS_VALUE    0x13
+#endif
+
+#ifdef CONFIG_DRIVER_GRX390
+   #ifdef CONFIG_AR10_PPE_FREQ_250M
+       #define CONFIG_AR10_CGU_CLKFSR_VALUE 0x10000
+   #elif defined(CONFIG_AR10_PPE_FREQ_400M) /*400M*/
+       #define CONFIG_AR10_CGU_CLKFSR_VALUE 0x40000
+   #elif defined(CONFIG_AR10_PPE_FREQ_432M) /*432M*/
+       #define CONFIG_AR10_CGU_CLKFSR_VALUE 0x20000
+   #else  
+       #define CONFIG_AR10_CGU_CLKFSR_VALUE 0x20000
+	   /* N= 12, M=0 for PPE to run at 468Mhz */
+	   #define CONFIG_GRX390_PLL2_CFG_VALUE 0x301
+   #endif
+#else
+   #if defined(CONFIG_AR10_PPE_FREQ_250M)
+       #define CONFIG_AR10_CGU_CLKFSR_VALUE 0x10010000
+   #elif defined(CONFIG_AR10_PPE_FREQ_400M)
+       #define CONFIG_AR10_CGU_CLKFSR_VALUE 0x10040000
+   #else /*432M*/
+       #define CONFIG_AR10_CGU_CLKFSR_VALUE 0x20000
+   #endif
+#endif
+
+
+#ifdef CONFIG_AR10_CRYSTAL_25M /*25M crystal clock*/
+    #define CONFIG_AR10_PLL0_CFG_VALUE 0x00F018D1   /*default value for 25M crystal*/
+#else
+    //#define CONFIG_AR10_PLL0_CFG_VALUE 0x00B01F21
+	/*M=2, N(6:0)=49, N(7)=1, */
+	/*setting bit 7 of N means the final pll clk frequency should be multiplied by 1.66*/
+	/*bit 7 itself should not be considered as part of N value*/
+	#define CONFIG_AR10_PLL0_CFG_VALUE 0x00B02C49
+    /*M=5, N(6:0)=99, N(7)=1*/
+	//#define CONFIG_AR10_PLL0_CFG_VALUE 0x00B038D5
+#endif
+
+
+#define CGU_OFFSET  0xBF103000
+#define PLL0_CFG    (CGU_OFFSET + 0x0004)
+#define PLL1_CFG    (CGU_OFFSET + 0x0008)
+#define CGU_SYS     (CGU_OFFSET + 0x000C)
+#define CGU_CLKFSR  (CGU_OFFSET + 0x0010)
+#define CGU_UPDATE  (CGU_OFFSET + 0x0020)
+#define IF_CLK      (CGU_OFFSET + 0x0024)
+#ifdef CONFIG_DRIVER_GRX390
+    #define PLL2_CFG    (CGU_OFFSET + 0x0060)
+#endif
+
+#define RCU_OFFSET   0xBF203000
+#define RST_REQ      (RCU_OFFSET + 0x0010)
+#define CHIPID       0xBF107340
+#define GRX390_ID    (CHIPID + 0x08)
+#define ID_CFG		 (CHIPID + 0x10)
+
+#define PPE400M_CONFIG 0x10040000
+#define PPE432M_CONFIG 0x20000
+
+#ifdef CONFIG_GRX390_CPUFREQ_AUTO_DETECT
+	#define CGU_SYS_600M		0x101
+	#define CGU_CLKFSR_300M		0x20000	/* 432Mhz PPE*/
+	#define CGU_SYS_720M		0x501
+	#define CGU_CLKFSR_360M		0x40000 /* 400Mhz PPE */
+	#define CONFIG_GRX390_PLL2_CFG_VALUE 0x241 /* N = 9, M = 0 */
+#endif /* CONFIG_GRX390_CPUFREQ_AUTO_DETECT */
+
+
+  .set  noreorder
+
+/*
+ * void cgu_init(long)
+ */
+  .globl  cgu_init
+  .ent  cgu_init
+cgu_init:
+    li  t2, CGU_SYS
+    lw  t2, 0(t2)
+    bne t2, CONFIG_AR10_CGU_SYS_VALUE, 1f /*check if CGU_SYS is correct*/
+    nop
+
+    li  a0, CONFIG_AR10_CGU_CLKFSR_VALUE
+    bne a0, PPE432M_CONFIG, 3f /* check if ppe config to 432M */
+    nop
+
+    li   t2, GRX390_ID
+    lw   t2, 0(t2)
+    andi t2, t2, 0x1 /* check if grx387/grx39X or ar10 */
+    beq  t2, 0x1, 3f
+    nop
+ 
+    /* if ar10 & ppe clk config to 432M */
+    li a0, PPE400M_CONFIG /* config to max 400M if chip is ar10 */
+
+3:
+    li  t2, CGU_CLKFSR
+    lw  t2, 0(t2)
+    bne t2, a0, 1f /*check if CGU_CLKFSR is correct*/
+    nop
+
+freq_up2date:
+    j ra
+	nop
+
+1:
+#if defined(CONFIG_AR10_PPE_FREQ_468M) || defined(CONFIG_GRX390_CPU_720M_RAM_360M) || \
+	defined(CONFIG_GRX390_CPU_360M_RAM_360M) || defined (CONFIG_GRX390_CPU_360M_RAM_180M) || \
+	defined(CONFIG_GRX390_CPU_180M_RAM_180M) /* change for 720Mhz & PPE clk 468Mhz */
+
+   li  t2, PLL2_CFG
+   lw  a0, 0(t2)
+   and a0, a0, 0xffffc000
+   or  a0, a0, CONFIG_GRX390_PLL2_CFG_VALUE
+   sw  a0, 0(t2)
+
+   li  t2, CGU_SYS
+   lw  a0, 0(t2)
+   or  a0, 0x80
+   sw  a0, 0(t2)
+
+   and a0, 0xffffff7f
+   sw  a0, 0(t2)
+
+2:
+   li  t2,  PLL2_CFG  
+   lw  t2, 0(t2)
+   andi t2, t2, 0x02
+   bne t2, 0x2, 2b
+   nop
+#endif
+
+   li  t2, CGU_SYS
+   li  a0, CONFIG_AR10_CGU_SYS_VALUE
+   addi a0, a0, 0x80
+   sw  a0, 0(t2)    /*store predefined value to CGU_SYS*/
+
+   li  a0, CONFIG_AR10_CGU_CLKFSR_VALUE
+   bne a0, PPE432M_CONFIG, 4f /* check if ppe config to 432M */
+   nop
+
+   li   t2, GRX390_ID
+   lw   t2, 0(t2)
+   andi t2, t2, 0x1 /* check if grx387/grx39X or ar10 */
+   beq  t2, 0x1, 4f
+   nop
+ 
+   /* if ar10 & ppe clk config to 432M */
+   li a0, PPE400M_CONFIG /* config to max 400M if chip is ar10 */
+
+4:
+   li  t2, CGU_CLKFSR
+   sw  a0, 0(t2)
+
+   li  t2, PLL0_CFG
+   li  a0, CONFIG_AR10_PLL0_CFG_VALUE /*store predefined value to PLL0_CFG*/
+   sw  a0, 0(t2)
+
+   li  t2, CGU_UPDATE
+   li  a0, 1
+   sw  a0, 0(t2) /*write 0x1 to CGU_UPDATE*/
+
+   li  t2, RST_REQ
+   li  a0, 0x40000000
+   sw  a0, 0(t2)  /*issue global software reset*/
+wait_reset:
+    b   wait_reset
+    nop
+
+    .end  cgu_init
+
+
+#ifdef CONFIG_GRX390_CPUFREQ_AUTO_DETECT
+
+/*
+ * void cgu_auto_select(long)
+ */
+  .globl cgu_auto_select
+  .ent	cgu_auto_select
+cgu_auto_select:
+ 	li	t2, ID_CFG 
+ 	lw	a0, 0(t2)
+	and a0, a0, 0x20000 /* check if the chip is fused */
+	beqz a0, 1f			/* not fused, 720Mhz is allowed */
+	nop 
+
+	li	a1, CGU_SYS_600M /* load a1 to 600M CGU settings */
+	li	a2, CGU_CLKFSR_300M /* load a2 with 432M PPE settings */
+	b	2f
+	nop
+
+1:
+	li	a1, CGU_SYS_720M /* load a1 to 720M CGU settings */
+	li	a2, CGU_CLKFSR_360M /* load a2 to 400M PPE settings */
+	
+2:
+    li  t2, CGU_SYS
+    lw  t2, 0(t2)
+    bne t2, a1, 3f /*check if CGU_SYS is correct*/
+    nop
+
+    li  t2, CGU_CLKFSR
+    lw  t2, 0(t2)
+    bne t2, a2, 3f /*check if CGU_CLKFSR is correct*/
+    nop
+
+update_done:
+    j ra
+    nop
+
+3: 
+	bne	a1, CGU_SYS_720M, 5f /* do PLL2 cfg if 720M */
+	nop
+
+	/* start PLL2 cfg */
+	li  t2, PLL2_CFG
+	lw  a0, 0(t2)
+	and a0, a0, 0xffffc000
+	or  a0, a0, CONFIG_GRX390_PLL2_CFG_VALUE
+	sw  a0, 0(t2)
+
+	li  t2, CGU_SYS
+	lw  a0, 0(t2)
+	or  a0, 0x80
+	sw  a0, 0(t2)
+
+	and a0, 0xffffff7f
+	sw  a0, 0(t2)
+
+4:
+	li  t2,  PLL2_CFG
+	lw  t2, 0(t2)
+	andi t2, t2, 0x02
+	bne t2, 0x2, 4b
+	nop
+	/* end PLL2 cfg */
+
+5:
+	li  t2, CGU_SYS
+	addi a1, a1, 0x80
+	sw  a1, 0(t2)    /*store predefined value to CGU_SYS*/
+
+	li  t2, CGU_CLKFSR
+	sw  a2, 0(t2)
+
+	li  t2, PLL0_CFG
+	li  a0, CONFIG_AR10_PLL0_CFG_VALUE /*store predefined value to PLL0_CFG*/
+	sw  a0, 0(t2)
+
+	li  t2, CGU_UPDATE
+	li  a0, 1
+	sw  a0, 0(t2) /*write 0x1 to CGU_UPDATE*/
+
+	li  t2, RST_REQ
+	li  a0, 0x40000000
+	sw  a0, 0(t2)  /*issue global software reset*/
+reset:
+    b   reset
+    nop
+
+	.end	cgu_auto_select
+
+#endif /* CONFIG_GRX390_CPUFREQ_AUTO_DETECT */
+
+/*
+ * void ddrram_init(long)
+ */
+  .globl  ddrram_init
+  .ent  ddrram_init
+ddrram_init:
+
+   .end ddrram_init
+   
+  .globl  lowlevel_init
+  .ent  lowlevel_init
+lowlevel_init:
+  /* EBU, CGU and SDRAM/DDR-RAM Initialization.
+   */
+  move  t0, ra
+
+#ifdef CONFIG_GRX390_CPUFREQ_AUTO_DETECT
+  bal cgu_auto_select
+#else
+  bal cgu_init
+#endif /* CONFIG_GRX390_CPUFREQ_AUTO_DETECT */
+  nop
+ 
+  move  ra, t0
+  j ra
+  nop
+
+  .end  lowlevel_init
diff --git a/board/grx500/nand_spl_board.c b/board/grx500/nand_spl_board.c
new file mode 100755
--- /dev/null
+++ b/board/grx500/nand_spl_board.c
@@ -0,0 +1,263 @@
+//#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/grx500.h>
+#include <environment.h>
+#include <nand.h>
+#include <asm/boot.h>
+#define GPIO_OUTPUT 1
+#define GPIO_INPUT 0
+
+
+extern void start_interaptiv(u32 addr);
+extern void ibl(u32 cpu_num, u32 core_num, u32 vpe_num);
+
+extern u32 get_cpu_id(void);
+
+#ifdef CONFIG_LTQ_SECURE_BOOT
+extern void bootrom_auth(u32 addr);
+#endif /* CONFIG_LTQ_SECURE_BOOT */
+#if defined(CONFIG_MANUBOOT_OTP_SUPPORT)
+extern int otp_prog_execute(void);
+#endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) */
+
+int cpu_is_cps(void)
+{
+    int ret=0;
+    if(get_cpu_id()==0xa1) ret=1;
+    return ret;
+}
+
+#ifdef CONFIG_NAND_ECC_BCH
+/*
+ * Begin and End of memory area for malloc(), and current "brk"
+ */
+
+static ulong mem_malloc_start;
+static ulong mem_malloc_end;
+static ulong mem_malloc_brk;
+
+
+/*
+ * The Malloc area is immediately below the monitor copy in DRAM
+ */
+void mem_malloc_init (ulong dest_addr, ulong size)
+{
+//  ulong dest_addr = BOOTSTRAP_CFG_MONITOR_BASE + gd->reloc_off;
+
+    mem_malloc_end = dest_addr;
+    mem_malloc_start = dest_addr - size;
+    mem_malloc_brk = mem_malloc_start;
+
+    memset ((void *) mem_malloc_start,
+        0,
+        mem_malloc_end - mem_malloc_start);
+}
+
+void *malloc(unsigned int size)
+{
+	/* ensure alignment */
+	if (size & 0x7) {
+		size += (8 - (size & 7));
+	}
+
+    if(size < (mem_malloc_end - mem_malloc_start))
+    {
+        mem_malloc_start += size;
+        return (void *)(mem_malloc_start - size);
+    }
+    return NULL;
+}
+
+void *realloc(void *src,unsigned int size)
+{
+    return NULL;
+}
+
+void free(void *src)
+{
+    return;
+}
+
+void * calloc(
+    size_t nelem,
+    size_t size)
+{
+   return;
+}
+
+void *sbrk (ptrdiff_t increment)
+{
+    ulong old = mem_malloc_brk;
+    ulong new = old + increment;
+
+    if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
+        return (NULL);
+    }
+    mem_malloc_brk = new;
+    return ((void *) old);
+}
+#else
+void *malloc(unsigned int size)
+{
+	return NULL;
+}
+#endif /* CONFIG_NAND_ECC_BCH */
+
+void config_gpio(u32 pin, int dir, u32 func_num)
+{
+    u32 portmux_base = pin>31?GPIO_PAD_CTRL_PORTMUXC32:GPIO_PAD_CTRL_PORTMUXC0;
+    u32 dir_base = pin>31?GPIO_FUNCTION_DIR_1:GPIO_FUNCTION_DIR_0;
+    u32 od_base = pin>31?GPIO_PAD_CTRL_OD_1:GPIO_PAD_CTRL_OD_0;
+    u32 rel_port_num = pin>31?(pin-32):pin;
+
+    REG32(portmux_base + (rel_port_num<<2)) = func_num;
+
+    if(dir == GPIO_OUTPUT)
+    {
+        REG32(dir_base)|= (1<<rel_port_num);
+        REG32(od_base) &=~(1<<rel_port_num);
+    }else{
+        REG32(dir_base)&= ~(1<<rel_port_num);
+        //REG32(od_base) |=(1<<rel_port_num);
+    }
+}
+
+
+void nand_gpio_init(void)
+{
+     config_gpio(13, GPIO_OUTPUT, 1);
+     config_gpio(23, GPIO_OUTPUT, 1);
+     config_gpio(24, GPIO_OUTPUT, 1);
+     config_gpio(48, GPIO_INPUT,  1);
+     config_gpio(49, GPIO_OUTPUT, 1);
+     config_gpio(50, GPIO_OUTPUT, 1);
+     config_gpio(51, GPIO_OUTPUT, 1);
+     config_gpio(52, GPIO_OUTPUT, 1);
+     config_gpio(53, GPIO_OUTPUT, 1);
+     config_gpio(54, GPIO_OUTPUT, 1);
+     config_gpio(55, GPIO_OUTPUT, 1);
+     config_gpio(56, GPIO_OUTPUT, 1);
+     config_gpio(57, GPIO_OUTPUT, 1);
+     config_gpio(59, GPIO_OUTPUT, 1);
+     config_gpio(60, GPIO_OUTPUT, 1);
+     config_gpio(61, GPIO_OUTPUT, 1);
+
+     REG32(EBU_ADDR_SEL_0) = 0x17400051;
+
+}
+
+
+#ifdef CONFIG_LANTIQ_SPI
+
+int spi_gpio_init(unsigned int cs)
+{
+     /*Enable SPI0 clock*/
+     REG32(CGU_CLKGCR1_A)|= CGU_CLKGCR1_A_SPI0_MASK;
+
+     /*GPIO 18, SPI0 CLK*/
+     config_gpio(18, GPIO_OUTPUT, 1);
+
+     /*enable all chip select signals*/
+     config_gpio(15, GPIO_OUTPUT, 1);
+     config_gpio(10, GPIO_OUTPUT, 0x2);
+     config_gpio(11, GPIO_OUTPUT, 0x3);
+
+     /*RX gpio*/
+     config_gpio(17, GPIO_OUTPUT, 0x1);
+     /*TX gpio*/
+     config_gpio(16, GPIO_INPUT, 0x1);
+
+     return 1;
+}
+
+#endif
+
+#if defined(CONFIG_LTQ_EIP123_IAP_ACCESS) && !defined(CONFIG_MANUBOOT)
+void enable_eip123_iap_access()
+{
+   u32 reg_val = 0;
+
+   // i=0;
+   // i += permission_wr(0xbff80058, 0x1f);
+   // i += permission_wr(0xbff80050, 0x1f);
+
+   REG32(0xb608004c) &=~(1<<3);
+   REG32(0xb608005c) |= 0xdfffff;
+
+   reg_val = REG32(0xbe003F10);
+   REG32(0xbe003F10) = reg_val & 0xFFFFFF00;
+}
+#endif /* defined(CONFIG_LTQ_EIP123_IAP_ACCESS) && !defined(CONFIG_MANUBOOT) */
+
+void main(u32 cpu_num, u32 core_num, u32 vpe_num)
+{
+      int i;
+
+      switch (cpu_num) {
+        case 8:
+#if !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) /* IAP boot */
+			/* Initialize flag */
+			REG32(SRAMFLAG) = 0;
+			/* trigger IAP to run */
+			start_interaptiv(CONFIG_NAND_SPL_TEXT_BASE);
+            #if defined(CONFIG_MANUBOOT_OTP_SUPPORT)
+            wait:
+            #endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) */
+			/*wait until IAP release */
+			while (REG32(SRAMFLAG) != IPCMAGIC); 
+			mdelay(200);
+	#if defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT)
+           /*auth uboot , agree on 0xa0800000 */
+           bootrom_auth(0xa0800000);
+           /* inform iap done */
+           REG32(SRAMFLAG)= (~IPCMAGIC);
+           asm("sync");
+           #ifdef CONFIG_LTQ_EIP123_IAP_ACCESS
+           /* need to do it after bootrom img auth, since they reset eip123 again */
+           enable_eip123_iap_access();
+           #endif /* CONFIG_LTQ_EIP123_IAP_ACCESS */
+           /* next round of wait, tos command */
+           mdelay(200);
+           while (REG32(SRAMFLAG) != IPCMAGIC);
+	#endif /* defined(CONFIG_LTQ_SECURE_BOOT) && !defined(CONFIG_MANUBOOT) */
+#endif  /* !CONFIG_GRX500_BOOT_4KEC_ONLY */
+
+           #if defined(CONFIG_MANUBOOT_OTP_SUPPORT) && !defined(CONFIG_GRX500_BOOT_4KEC_ONLY)
+           /* this render the tos command become otp programming in manufacturing boot */
+           /* and break the ability to load bootcore when RoT */
+           otp_prog_execute();
+           goto wait; /* back to wait magic */
+           #else /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) && !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) */
+		   /* FMT settings */
+           REG32(0xb49001d4) = CONFIG_FMT1_REG;
+           nand_boot();
+           #endif /* defined(CONFIG_MANUBOOT_OTP_SUPPORT) && !defined (CONFIG_GRX500_BOOT_4KEC_ONLY) */
+           break;
+        case 0:
+            for (i=0; i<4; i++){                            //Reset All MSG
+                REG32(CPUMSG + 4*i) = 0;
+                REG32(INTMSG + 4*i) = 0;
+                REG32(JMPMSG + 4*i) = 0;
+            }
+
+           REG32(CPUMSG)+=1; 
+           /* 
+           REG32(0xb23f0014) = 2;
+           for (i=0; i<32; i++){
+                REG32(0xb23f0018 + i*4) = 5;
+           }
+           mdelay(500);
+           */
+           //while(REG32(0xa0400000)!=0x88888888);
+           nand_boot();
+           break;
+        default:
+           ibl(cpu_num,core_num,vpe_num);
+           //while(1);
+           break;
+      }
+}
+	
+
diff --git a/board/grx500/sfddr_board.c b/board/grx500/sfddr_board.c
new file mode 100755
--- /dev/null
+++ b/board/grx500/sfddr_board.c
@@ -0,0 +1,427 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <version.h>
+#include <net.h>
+#include <environment.h>
+#include <asm/mipsregs.h>
+#include <asm/boot.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define	TOTAL_MALLOC_LEN	CONFIG_SYS_MALLOC_LEN
+
+
+ulong monitor_flash_len;
+
+const char version_string[] =
+	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ")";
+
+static char *failed = "*** failed ***\n";
+
+
+#include <spi.h>
+#include <asm/ifx_ssc.h>
+
+#ifndef CONFIG_ENV_SPI_BUS
+# define CONFIG_ENV_SPI_BUS 0
+#endif
+#ifndef CONFIG_ENV_SPI_CS
+# define CONFIG_ENV_SPI_CS      1
+#endif
+#ifndef CONFIG_ENV_SPI_MAX_HZ
+# define CONFIG_ENV_SPI_MAX_HZ  1000000
+#endif
+#ifndef CONFIG_ENV_SPI_MODE
+# define CONFIG_ENV_SPI_MODE    SPI_MODE_3
+#endif
+
+#define CMD_MX25L_READ     0x03
+
+#define SRC_OFFSET  0x00001000
+#define DST_ADDRESS 0xbe221000
+#define DATA_SIZE   0x4000
+
+
+extern void start_interaptiv(u32 addr);
+
+extern u32 get_cpu_id(void);
+
+int cpu_is_cps(void)
+{
+    int ret=0;
+    if(get_cpu_id()==0xa1) ret=1;
+    return ret;
+}
+
+int check_4kec_spi_header(u32 src, u32 *jmp_addr, u32 dst_size)
+{       
+    int image_len;
+    u8 *image_start = NULL;
+    u32 ret_check, checksum = 0;
+    u32 hdr_len, load_addr;
+    image_header_t *pimg_header = (image_header_t *)src;
+        
+    /* check magic number */    
+    if (ntohl(pimg_header->ih_magic) != IH_MAGIC) {
+        return -1;
+	}
+            
+    asm("sync");
+    /* mkimage type kernel without the 8B offset */
+    image_start = (u8 *)pimg_header + sizeof(image_header_t);
+    image_len = ntohl(pimg_header->ih_size);
+    load_addr = ntohl(pimg_header->ih_load);
+    *jmp_addr = load_addr;
+    asm("sync");
+
+    hdr_len = sizeof(image_header_t);
+    checksum = ntohl(pimg_header->ih_hcrc);
+    pimg_header->ih_hcrc = 0;
+
+    asm("sync");
+    ret_check = crc32(0, (unsigned char *) src, hdr_len);
+    if (ret_check != checksum) {
+        return -1;
+	}
+
+    asm("sync");
+    memcpy((u32 *) load_addr, (u32 *)image_start, image_len);
+
+    return 0; // success
+}
+											
+static void
+SPI_ON(unsigned int cs)
+{
+    ssc_cs_clr(cs);
+}
+
+static void	SPI_OFF(unsigned int cs)
+{
+    ssc_cs_set(cs);
+}
+
+void spi_write_byte(uint8_t transmit)
+{
+    asm("sync");
+    ssc_tx_only();
+    ssc_write(transmit);
+    asm("sync");
+    return;
+}
+
+static uint8_t	spi_read_byte(void)
+{
+    ssc_rx_only();
+    return ssc_read();
+}
+
+
+void sf_read(const u8 cmd, ulong src_addr, 
+		size_t addr_len, u8 *data, size_t data_len)
+{
+	  int i;
+	  u8 offset[5];
+          for(i=0;i<addr_len;i++){
+          offset[i]= (u8)((src_addr >>((addr_len-i-1)*8)) & 0xff);
+          }
+	  SPI_ON(CONFIG_ENV_SPI_CS);
+	  spi_write_byte(cmd);
+	  for(i=0;i<addr_len;i++){
+	  	spi_write_byte(*(offset+i));
+	  }
+	  for(i=0;i<data_len;i++){
+	  	*(data+i)=spi_read_byte();
+	  }
+	  SPI_OFF(CONFIG_ENV_SPI_CS);
+}		
+
+
+
+/*
+ * Begin and End of memory area for malloc(), and current "brk"
+ */
+
+static ulong mem_malloc_start;
+static ulong mem_malloc_end;
+static ulong mem_malloc_brk;
+
+
+/*
+ * The Malloc area is immediately below the monitor copy in DRAM
+ */
+static void mem_malloc_init (ulong dest_addr, ulong size)
+{
+//  ulong dest_addr = BOOTSTRAP_CFG_MONITOR_BASE + gd->reloc_off;
+
+    mem_malloc_end = dest_addr;
+    mem_malloc_start = dest_addr - size;
+    mem_malloc_brk = mem_malloc_start;
+
+    memset ((void *) mem_malloc_start,
+        0,
+        mem_malloc_end - mem_malloc_start);
+}
+
+void *malloc(unsigned int size)
+{
+    if(size < (mem_malloc_end - mem_malloc_start))
+    {
+        mem_malloc_start += size;
+        return (void *)(mem_malloc_start - size);
+    }
+    return NULL;
+}
+
+void *realloc(void *src,unsigned int size)
+{
+    return NULL;
+}
+
+void free(void *src)
+{
+    return;
+}
+
+void * calloc(
+    size_t nelem,
+    size_t size)
+{
+   return;
+}
+
+void *sbrk (ptrdiff_t increment)
+{
+    ulong old = mem_malloc_brk;
+    ulong new = old + increment;
+
+    if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
+        return (NULL);
+    }
+    mem_malloc_brk = new;
+    return ((void *) old);
+}
+
+
+static int init_baudrate (void)
+{
+
+	gd->baudrate = CONFIG_BAUDRATE;
+
+	return (0);
+}
+
+void uncompress_image(ulong image_addr)
+{
+
+   ulong   addr;
+   ulong   data, len, checksum;
+   ulong  *len_ptr;
+   unsigned int destLen;
+   image_header_t header;
+   image_header_t *hdr = &header;
+   int (*fn)();
+
+   mem_malloc_init(0x82000000, TOTAL_MALLOC_LEN);
+   addr = image_addr;
+   memmove (&header, (char *)addr, sizeof(image_header_t));
+
+   if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+           return;
+                            		       }
+
+   data = (ulong)&header;
+   len  = sizeof(image_header_t);
+
+   checksum = ntohl(hdr->ih_hcrc);
+   hdr->ih_hcrc = 0;
+   asm("sync");
+   if (crc32 (0, (char *)data, len) != checksum) {
+		         return;
+						     }
+
+   asm("sync");
+
+   data = addr + sizeof(image_header_t);
+
+   asm("sync");
+
+   len  = ntohl(hdr->ih_size);
+   asm("sync");
+
+   len_ptr = (ulong *)data;
+   asm("sync");
+
+   destLen = 0x0;
+
+   lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &destLen);
+   fn = ntohl(hdr->ih_load);
+
+   (*fn)();
+
+}
+
+
+int spi_gpio_init(void)
+{
+     /*Enable SPI0 clock*/
+     REG32(CGU_CLKGCR1_A)|= CGU_CLKGCR1_A_SPI0_MASK;
+     //while(!(REG32(CGU_CLKGSR1) & CGU_CLKGCR1_A_SPI0_MASK))
+
+     /*GPIO 18, SPI0 CLK*/
+     REG32(GPIO_PAD_CTRL_PORTMUXC18) = 0x1;
+     REG32(GPIO_PAD_CTRL_PORTMUXC15) = 0x1;
+     REG32(GPIO_PAD_CTRL_PORTMUXC10) = 0x2;
+     REG32(GPIO_PAD_CTRL_PORTMUXC11) = 0x3;
+     REG32(GPIO_PAD_CTRL_PORTMUXC17) = 0x1;
+     REG32(GPIO_PAD_CTRL_PORTMUXC16) = 0x1;
+     return 1;
+}
+
+
+void spi_init (void)
+{
+        /* Clock Control Register */
+        /* DISS OFF and RMC = 1 */
+        //CLC
+        *SPI_CLC = 0x0100;
+        /* Disable SSC to get access to the control bits */
+        *SPI_WHBSTATE = 0x1;
+        asm("SYNC");
+
+        /*clear all chip select pins*/
+        *SPI_FGPO = 0xff00;
+
+        /*set chip select pin*/
+        //*SPI_GPOCON =1<<(spi.cs+8); /*boot from SPI, chip select already set by bootrom*/
+
+	*SPI_BRT = (((F_SSC_CLK>>1) + CONFIG_ENV_SPI_MAX_HZ/2)/(CONFIG_ENV_SPI_MAX_HZ) - 1) & 0xffff;
+        /*enable and flush RX/TX FIFO*/
+        *SPI_RXFCON = 0xF03;
+        *SPI_TXFCON = 0xF03;
+        /* set CON, TX off , RX off, ENBV=0, BM=7(8
+         * bit valid) HB=1(MSB first), PO=0,PH=1(SPI
+         * Mode 0)*/
+        *SPI_CON = 0x00070033;
+        asm("SYNC");
+        /*Set Master mode and  Enable
+         * SSC */
+        *SPI_WHBSTATE = 0xA;
+        asm("SYNC");
+}
+
+
+
+void board_init_f(ulong bootflag)
+{
+	u8  cmd = CMD_MX25L_READ;
+	u32 reg;
+	size_t  addr_len = 3;
+	int i, cpu_num, vpe_num, ret;
+	__attribute__((noreturn)) void (*uboot)(void);
+
+	asm("sync");
+	if (cpu_is_cps()) {
+		/*
+		REG32(0xb23f0014) = 2;
+		for (i=0; i<32; i++) {
+			REG32(0xb23f0018 + i*4) = 5;
+		}
+		*/
+		reg = read_c0_ebase();
+		cpu_num = reg & 0x1ff;
+		switch (cpu_num) {
+		case 0:
+			for (i=0; i<4; i++){                            //Reset All MSG
+                REG32(CPUMSG + 4*i) = 0;
+                REG32(INTMSG + 4*i) = 0;
+                REG32(JMPMSG + 4*i) = 0;
+            }
+
+            REG32(CPUMSG)+=1;
+
+			serial_init();
+			spi_gpio_init();
+			spi_init();
+			asm("sync");
+			sf_read(cmd,(ulong)0x6000,addr_len,(u8*)0x80200000,0x19000);
+			sf_read(cmd,(ulong)0x20000,addr_len,(u8*)0x80220000,0x10000);
+			asm("sync");
+			uncompress_image(0x80200000);
+		break;
+		default:
+			reg = read_c0_tcbind();
+			vpe_num = reg & 0xf;
+
+			ibl(cpu_num, cpu_num, vpe_num);
+			break;	
+		}
+	} else {
+		ulong load_address;
+		ulong jump_address;
+		ulong ddr_address, bootcore_size;
+
+#if defined(CONFIG_GRX500_BOOT_4KEC_ONLY) 
+		REG32(0xb49001d4) = CONFIG_FMT1_REG;
+		serial_init();
+		spi_gpio_init();
+		spi_init();
+		asm("sync");
+		sf_read(cmd,(ulong)0x6000,addr_len,(u8*)0x80200000,0x19000);
+		sf_read(cmd,(ulong)0x20000,addr_len,(u8*)0x80220000,0x10000);
+		asm("sync");
+		uncompress_image(0x80200000);
+#else
+		/* Initialize flag */
+		REG32(SRAMFLAG) = 0;
+		/* trigger IAP to run */
+		start_interaptiv(CONFIG_SFDDR_TEXT_BASE);
+		while (REG32(SRAMFLAG) != IPCMAGIC);
+		mdelay(300);	
+
+		REG32(0xb49001d4) = CONFIG_FMT1_REG;
+
+		asm("sync");
+		load_address = REG32(MPS_LOAD_ADDR); /* 4Kec load addr */
+		ddr_address = REG32(MPS_DDR_LOC);    /* ddr where TOS is copied to */
+		bootcore_size = REG32(MPS_SIZE_LOC); /* size of TOS/bootcore img */
+
+		memcpy((unsigned char *) load_address,
+				 (unsigned char *) ddr_address,
+				 bootcore_size);
+
+		ret = check_4kec_spi_header(load_address,
+									&jump_address,
+									bootcore_size);
+		if (ret)
+			while(1); // if img is bad, we prevent 4kec from loading it
+
+		uboot = (void*)jump_address;
+		(*uboot)();
+#endif
+	}
+}
diff --git a/board/grx500/start_sfddr.S b/board/grx500/start_sfddr.S
new file mode 100644
--- /dev/null
+++ b/board/grx500/start_sfddr.S
@@ -0,0 +1,308 @@
+/*
+ *  Startup Code for MIPS32 CPU-core
+ *
+ *  Copyright (c) 2003	Wolfgang Denk <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/cacheops.h>
+#include <asm/addrspace.h>
+#include <asm/yamon.h>
+#include <asm/boot.h>
+#include <asm/cps.h>
+/*****************************************************************************
+ * Local assembler register definitions
+ *****************************************************************************/
+#define C0_EBASe     $15,1
+#define C0_SEGCTL0  $5,2
+#define C0_SEGCTL1  $5,3
+#define C0_SEGCTL2  $5,4
+#define C0_CONFIG5  $16,5
+
+
+#define S_EBASeExpBase     12       /* Exception Base */
+#define M_EBASeExpBase     (0x3ffff << S_EBASeExpBase)
+#define S_EBASeCPUNum      0        /* CPU Number */
+#define M_EBASeCPUNum      (0x1ff << S_EBASeCPUNum)
+
+/*
+ * Values in the CPU Number field
+ */
+#define K_EBASeCPUNum_Host 0
+#define K_EBASeCPUNum_Voice 1
+
+/* C0_EBASE register encoding */
+#define CO_EBASE_EXPBASE_SHF     S_EBASeExpBase
+#define CO_EBASE_EXPBASE_MSK     M_EBASeExpBase
+
+#define CO_EBASE_CPUNUM_SHF      S_EBASeCPUNum
+#define CO_EBASE_CPUNUM_MSK      M_EBASeCPUNum
+
+#define CO_EBASE_CPU_HOST     K_EBASeCPUNum_Host
+#define CO_EBASE_CPU_VOICE    K_EBASeCPUNum_Voice
+
+    .set noreorder
+/*	  .option pic0*/
+   	.globl _start
+   	.globl __exception_vector_tlb_refill
+   	.globl __exception_vector_xtlb_refill
+   	.globl __exception_vector_general
+   	.globl __exception_vector_int
+   	.text
+LEAF(__reset_vector)
+_start:
+	/* RESET entry */
+   	b     reset
+   	nop
+   	nop
+   	nop
+END(__reset_vector)
+.org 0x200 /* General exception. */
+    li      k0, (GIC_SH_WEDGE | GIC_BASE_ADDR)
+    mfc0    k1, CP0_EBASE                // Get cp0 EBase = $15
+    ext     k1, k1, 0, 10                               // Extract CPUNum
+    li      v0, 1
+    li      v1, 1
+    bne     k1, v0, 1f
+    add     v0, v1
+    li      k1, 20
+    b       ipi_calculation_done
+    nop
+
+1:  bne     k1, v0, 1f
+    add     v0, v1
+    li      k1, 21
+    b       ipi_calculation_done
+    nop
+
+1:  li      k1, 85
+    b       ipi_calculation_done
+    nop
+
+ipi_calculation_done:
+    sw      k1, 0(k0)                                   // Clear this IPI.
+    
+
+    li      k0, INTMSG
+    mfc0    k1, CP0_EBASE                                // Get cp0 EBase
+    ext     k1, k1, 0, 10                               // Extract CPUNum
+    sll     k1, k1, 2                                   // k1 = k1*4
+    addu    k0, k0, k1                                  // index into CMP global "C" variable start_test
+    li      k1, 1
+    sw      k1, 0(k0)                                   // Release "cpu"/vpe to execute "C" test code.
+    eret
+    nop
+
+reset:
+        /* Initialize GOT pointer.
+        */
+        bal     1f
+        nop
+        .word   _GLOBAL_OFFSET_TABLE_
+1:
+        move    gp, ra
+        lw      t1, 0(ra)
+        move    gp, t1
+
+#if 1
+    	/* Only set GOT for IAP Core 1 and abv */
+	    mfc0    k1, CP0_PRID             
+	    ext     k1, k1, 8, 16       /* Company ID & Processor ID */
+	    li      k0, 0x0190          /* 4Kec ID*/
+    	beq     k0, k1, start_init	/* jmp if 4Kec */
+	    nop
+
+		/* CPU core 0, we shall ignore and jmp away */
+	    mfc0    k0, CP0_EBASE       // Read CP0 EBase
+	    ext     k1, k0, 0, 4        // Extract CPUNum
+    	beq     k1, 0, start_init	/* jmp if core 0 */
+    	nop	
+
+		/* Check if the core is in EVA mode */
+    	mfc0	v0, CP0_CONFIG5	
+		li      v1, 0x40000000
+		and		v0, v0, v1
+		beqz	v0, start_init		/* if EVA bit is not set, we are in legacy mode. hence no need 	*/
+		nop							/* to change the GOT table location							 	*/
+
+		/* Re-adjust GOT when in EVA mode */
+        bal     1f
+        nop
+        .word   got_size
+1:
+        move    t1, ra
+        lw      t1, 0(t1)
+
+        move    t0, gp
+        add     t1, t0, t1
+        addi    t0, 8 /*skip first 2 entries*/
+		
+		/* Check if we need to add the GOT back to 0xA0000000 range */
+		lw		t2, 0(t0)
+		and		t2, t2, 0x70000000	/* mask value */
+		bnez	t2, start_init		/* if GOT already in 0xA000000 range, skip */
+		nop
+		
+		/* Remap GOT table to 0xA000XXXX region */
+2:
+        lw      t2, 0(t0)
+        addu    t2, 0x20000000
+        sw      t2, 0(t0)
+        bne     t0, t1, 2b
+        addi    t0, t0, 4
+#endif
+
+start_init:
+        la      a2,  set_gpr_boot_values             // Fill register file boot info. r23_cpu_num = 8 for 4KEc
+        jalr    a2
+        nop
+
+        la          a2, init_cp0                    // Init CP0 Status, Count, Compare, Watch*, and Cause.
+        jalr        a2
+        nop
+
+#ifdef CONFIG_LTQ_SECURE_BOOT 
+        li              k0, 8
+        beq             k0, r23_cpu_num, init_done     // CPUNum = 8 = 4KEc
+        nop
+#endif        
+        la          a2, init_gic                    // Configure the global interrupt controller.
+        jalr        a2
+        nop
+        
+        la          a2, init_exception
+        jalr        a2
+        nop
+        
+        bnez        r9_vpe_num, init_done   // If we are not vpe0 then we are done.
+        nop
+
+        la          a2, disable_L23                 // Disable L2/L3 caches
+        jalr        a2
+        nop
+
+        la          a2, sys_init_icache                 // Initialize the L1 instruction cache. (Executing using I$ on return.)
+        jalr        a2
+        nop
+
+        la          a2, change_k0_cca
+        jalr        a2
+        nop
+
+        la          a2, sys_init_dcache                 // Initialize the L1 data cache
+        jalr        a2
+        nop
+
+        li              k0, 8
+        beq             k0, r23_cpu_num, init_done     // CPUNum = 8 = 4KEc
+        nop
+
+        bgtz            r23_cpu_num, init_sys_resources_done
+        nop
+
+init_sys_resources:
+        /*interAptiv start to initialize system resources*/
+        la          a2, init_cpc                    // Initialize the CPS CPC (Cluster Power Controller.)
+        jalr        a2
+        nop
+
+        la          a2, init_cm                             // Initialize the CPS CM (Coherence Manager.)
+        jalr        a2
+        nop
+
+        la          a2, init_L23                    // Initialize the unified L2 and L3 caches
+        jalr        a2
+        nop
+        
+        la          a2, release_mp                  // Release other cores to execute this boot code.
+        jalr        a2
+        nop
+init_sys_resources_done:
+        la          a2, join_domain                 // Join the Coherence  domain. (OK to use D$ on return.)
+        jalr        a2
+        nop
+
+        la          a2, init_vpe1                   // Set up MT ASE vpe1 to execute this boot code also.
+        jalr        a2
+        nop
+
+init_done:
+        la          a2, init_legacy                 // init cpu into non-eva mode
+        jalr        a2
+        nop
+
+	/* Set up temporary stack.
+	 */
+
+        li              k1, (CONFIG_SFDDR_TEXT_BASE | 0x8000)
+        li              k0, 8
+        beq             k0, r23_cpu_num, change_got_table
+        nop
+        addi            k1, 0x2000
+        ins             k1, r23_cpu_num, STACK_SIZE_LOG2, 2 
+        b               change_got_table_done
+        nop
+               
+change_got_table:
+        bal     1f
+              nop
+        .word   got_size
+1:
+        move    t1, ra
+        lw      t1, 0(t1)
+
+        move    t0, gp
+        add     t1, t0, t1
+        addi    t0, 8 /*skip first 2 entries*/
+2:
+        lw      t2, 0(t0)
+        subu    t2, 0x20000000
+        sw      t2, 0(t0)
+        bne     t0, t1, 2b
+        addi    t0, t0, 4
+
+        subu    gp, 0x20000000
+
+change_got_table_done:
+#if defined(CONFIG_LTQ_SECURE_BOOT)
+        li      k0, 8
+        bne     k0, r23_cpu_num, iap_stack     // CPUNum = 8 = 4KEc
+        nop
+        li      sp, 0x9fc87ff0
+        j       stack_done
+        nop
+iap_stack:
+#endif
+        la      sp, 0(k1)
+#if defined(CONFIG_LTQ_SECURE_BOOT)
+stack_done:
+#endif
+
+	la	t9, board_init_f
+
+	j	t9
+	nop
+     
+
diff --git a/board/grx500/u-boot.lds b/board/grx500/u-boot.lds
new file mode 100644
--- /dev/null
+++ b/board/grx500/u-boot.lds
@@ -0,0 +1,70 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+OUTPUT_FORMAT("elf32-bigmips", "elf32-bigmips", "elf32-bigmips")
+*/
+OUTPUT_FORMAT("elf32-tradbigmips", "elf32-tradbigmips", "elf32-tradbigmips")
+OUTPUT_ARCH(mips)
+ENTRY(_start)
+SECTIONS
+{
+        . = 0x00000000;
+
+        . = ALIGN(4);
+	.text       :
+	{
+	  *(.text)
+	}
+
+        . = ALIGN(4);
+        .rodata  : { *(.rodata) }
+
+        . = ALIGN(4);
+        .data  : { *(.data) }
+
+	. = ALIGN(4);
+	.sdata  : { *(.sdata) }
+
+	_gp = ALIGN(16);
+
+	. = ALIGN(16);
+	__got_start = .;
+	.got  : { *(.got) }
+	__got_end = .;
+
+	.sdata  : { *(.sdata) }
+
+	. = .;
+        __u_boot_cmd_start = .;
+        .u_boot_cmd : { *(.u_boot_cmd) }
+        __u_boot_cmd_end = .;
+    got_size = (__got_end - __got_start);
+	uboot_end_data = .;
+	num_got_entries = (__got_end - __got_start) >> 2;
+
+        . = ALIGN(4);
+	.sbss  : { *(.sbss) }
+        .bss  : { *(.bss) }
+	uboot_end = .;
+}
diff --git a/board/grx500/uart-download-readme b/board/grx500/uart-download-readme
new file mode 100644
--- /dev/null
+++ b/board/grx500/uart-download-readme
@@ -0,0 +1,7 @@
+uart download instructions:
+1. Prepare images:
+   ./gct_500.pl uartddr.conf u-boot.srec u-boot.asc 0
+
+2. download uart.txt to the board
+3. download u-boot.asc to the board after uart.txt
+
diff --git a/board/grx500/uart.txt b/board/grx500/uart.txt
new file mode 100755
--- /dev/null
+++ b/board/grx500/uart.txt
@@ -0,0 +1,63 @@
+be720000100000030000000000000000000000003c08bf8035087ff0251d00003c1cbe72279c0ed03c08be7225080ed03c09bf80252960003c0abf80254a6000112a000e
+be720040000000008d0b000021080004ad2b0000152afffc212900043c08bf80250860003c09bf80252960482529fffcad0000001509fffe210800043c19be722739094c
+be72008003200008000000003c0bb608356a00288d49000027bdfff8afa900008fa800003c03bf8031070001afa700048fa6000000062f8230a40001ac6460048fa20004
+be7200c03c04bf80144000043c03bf803c0cbf2010000002358201c03c02bf803c19b608ac626000373801288f0f000027bd0008ac8f60088c8e6008000e6fc2ac8d6008
+be72010003e000080000000027bdffe0afb100142402000a309100ffafb00010afbf0018162200033c10b6600f9c80422404000d240300108e06004830c53f0000052202
+be7201401083fffc00000000ae1100208e0800143c0300100103382410e000058fbf00188e0a001835490040ae0900188fbf00188fb100148fb0001003e0000827bd0020
+be72018027bdffe8afb00010afbf0014008080219204000010800005308400ff0f9c8042261000011000fffb920400008fbf00148fb0001003e0000827bd00183c03b660
+be7201c08c6400483082003f1040fffd000000008c65002403e0000830a200ff27bdfff83403ffffafa300048fa20004104000153c03b6603404ffffafa400048c660048
+be72020030c5003f14a00007000000008fa900042528ffffafa800048fa7000414e0fff7000000008faa000411400003000000008c6b0024a3ab00008fac00041580ffee
+be7202400000000003e0000827bd000818c0000c000040219083000090a20000250800010106382a248400011062000324a5000103e000082402000114e0fff600000000
+be72028003e000080000102118a0001200001021908600000002490024c2ffd0304200ff24c7ff9f2c43000a2ce8000624a5ffff248400011460000524c7ffa924c3ffc9
+be7202c01500000230e200ff306200ff14a0fff00122102103e000080000000090820000000018211040000424840001908200001000fffc2463000103e0000800601021
+be72030027bdffc0afbf003cafb40038afb30034afb20030afb1002cafb000283c06be720f9c806024c40e0403e020210f9c8299000000003c05be7224b40ebc0f9c8060
+be720340028020213c03be720f9c806024640e1003a020210f9c8299000000000f9c8060028020213c04be720f9c806024840e1c3c02bf802443600c24640032a0600000
+be720380246300010064382a14e0fffc3c08bf802511600c000080213c0bbf800f9c806f2572600c304a00ff0212282124090008014020211549000ba0a200003c0cbe72
+be7203c01a00000a25840e24a0a00000a0a0ffff2610fffe0f9c80602631fffe10000004922400000f9c80420000000092240000240d000a108d000726100001240e000d
+be7204002a030032108e0003263100011460ffe33c0bbf800f9c80600280202127a6001002402021000098212407002000c02821908f000015e700052403002024840001
+be720440909000001203fffd000000009083000010600121387900200019c02b0003902b02588824aca40000267300011220000924a50004248400019088000039090020
+be7204800009182b0008102b0043f82417e0fff900000000908a00001140010b2a6b0005a08000001560ffe2248400013c04be720f9c806024840e283c05be728fa40010
+be7204c024a50e340f9c8093240600021440000c3c07be72240600021666000a8fa400100f9c80b78fa400148fa400140f9c80a2004028210040f809000000003c07be72
+be7205008fa4001024e50e380f9c809324060004144000253c10be72240c0003166c00238fa400108fa400140f9c80b7000090218fa400140f9c80a2004028218fa40018
+be7205400f9c80b7004080218fa400180f9c80a2004028211040001000408821324d00030280202115a00003265200010f9c8060000000008e0400000f9c829926100004
+be7205803c0fbe720f9c806025e40e480251702b15c0fff3324d00033c14be720f9c806026840ebc3c10be728fa4001026050e400f9c809324060004144000213c18be72
+be7205c0241100041671001e000000000f9c80b78fa400148fa400140f9c80a2004028218fa400180f9c80b7004088218fa400180f9c80a2004028218fa4001c0f9c80b7
+be720600004080218fa4001c0f9c80a200402821120000070040202102201821020010212442ffffac6400001440fffd246300043c12be720f9c806026440ebc3c18be72
+be7206408fa4001027050e4c0f9c809324060005144000273c0bbe7224190003167900258fa400108fa400140f9c80b7000090218fa400140f9c80a2004028218fa40018
+be7206800f9c80b7004080218fa400180f9c80a20040282110400012004088213c02be72325f000f24440ebc17e00003265200010f9c8060000000009209000026100001
+be7206c00f9c8285312400ff3c08be720f9c806025040e480251182b1460fff13c02be723c0abe720f9c806025440ebc3c0bbe728fa4001025650e540f9c809324060006
+be7207001440001f240400041664001e3c06be720f9c80b78fa400148fa400140f9c80a2004028218fa400180f9c80b7004088218fa400180f9c80a2004028218fa4001c
+be7207400f9c80b7004080218fa4001c0f9c80a20040282112000007304400ff02201821020010212442ffffa06400001440fffd246300013c05be720f9c806024a40ebc
+be7207803c06be728fa4001024c50e5c0f9c809324060004144000213c0ebe72240700031667001f8fa400108fa400140f9c80b7000088218fa400140f9c80a200402821
+be7207c08fa400180f9c80b7004080218fa400180f9c80a2004028211040000702002021004018218c8c00002463ffff022c88211460fffc248400043c0dbe7225b40ebc
+be7208000f9c8060028020210f9c8299022020210f9c8060028020213c0ebe728fa4001025c50e640f9c80932406000414400013240f0003166f00123c13be720f9c80b7
+be7208408fa400148fa400140f9c80a2004028218fa400180f9c80b7004088218fa400180f9c80a2004028218e320000164200083c18be721000fffc263100043c13be72
+be7208800f9c806026640ebc1000fea53c06be7227100ebc0f9c806002002021024020210f9c82993c12be720f9c806026440e6c0f9c8299022020210f9c806002002021
+be7208c01000ffef3c13be720013c8800326882110000002ae200000aca000001000fef6a080ffff308300032402000114620009240800032403fffc008320248c870000
+be72090000e5302414c5fffd0000000003e0000800000000146800082409fffc008920248c8b0000016550241145fffd0000000003e00008000000001080000200000000
+be720940ac85000003e00008000000003c02be7227bdffe8afbf00100f9c806024440e7c3c04be720f9c806024840e980f9c82fc000000001000ffff0000000000801021
+be72098030a500ff0080382110c0000624c3ffff2406ffff2463ffffa0e500001466fffd24e7000103e000080000000010c0000b24c7ffff2406ffff90a2000090830000
+be7209c024e7ffff1062000324a5000103e000080080102114e6fff82484000103e00008000010210080382110c0000824c3ffff2406ffff90a200002463ffffa0e20000
+be720a0024a500011466fffb24e7000103e0000800801021308900ff3c0abe7227bdffe025470df43128000f00093102afbf001800c72021010728219082000090a30000
+be720a4027a40010a7a00010a3a00012a3a200100f9c8060a3a300118fbf001803e0000827bd002027bdffe8afb0001000808021afbf00140f9c82850004260200101402
+be720a800f9c8285304400ff001022020f9c8285308400ff320400ff8fbf00148fb000100b9c828527bd001827bdffe0afb10014afb00010afbf00180080882110a00007
+be720ac024b0ffff922400000f9c82852610ffff2402ffff1602fffb263100013c04be728fbf00188fb100148fb0001024840ebc0b9c806027bd002027bdffe0afb10014
+be720b00afb00010afbf001800008821000080210f9c806f00000000304400ff2a0800072482ffa9261000012c8300612a0700082486ffc92c85004110600005304200ff
+be720b402483ffd010a0000230c200ff306200ff022228210005210000a0882114e0ffec0088880b022010218fbf00188fb100148fb0001003e0000827bd00208c830000
+be720b80246200010b9c82beac82000027bdffe0afb10014afbf0018afb000108c900000008088212e02001110400005000000000f9c82be261000011000fffb2e020011
+be720bc00f9c806f000000000f9c80422404002aae2000008fbf00188fb100148fb0001003e0000827bd002003e00008000000003c08be7227bdffe025040eb8afbf001c
+be720c000f9c8060afb000183c03bf803c05be723c06be723c07be72246460402402001024a50b7c24c60b8c24e70be80f9c831aafa200103c04be720040802110400003
+be720c4024840ec00f9c8060000000000f9c807700000000020010218fbf001c8fb0001803e0000827bd002027bdffd0afb4002093b40043afb60028afb50024afb3001c
+be720c80afb20018afbf002cafb10014afb000100080902100a0982100c0b02100e0a8210260f80902402021004080213c02333334423333120200280050182b14600007
+be720cc03c0755553c05111134a411111204001400000000100000310000000034e65555120600063c099999352899991208001200000000100000290000000012800030
+be720d00028080212610ffff0260f809024020211600fffd2610ffff10000029000000000260f8090240202102a0f8090240202110000023000000000260f80902402021
+be720d400f9c8077004080210200f809000000001000001b00000000001410421040001800000000004088210260f80902402021024020210260f809004080212631ffff
+be720d80020020210f9c8239004028211620fff6000000001000000a000000001280000800000000028088210260f809024020212631ffffae0200001620fffb26100004
+be720dc002c0f809024020211000ffb5000000000a53656375726520626f6f74206d6f646520616c726561647920636c6f7365640a000000303132333435363738396162
+be720e00636465667233312028726129203d20007232392028737029203d2000524f4d203e200000082008006d61782035206172670a0000676f000064756d7000000000
+be720e406d7365740000000020200000627265616400000062777269746500006373756d0000000066666e7000000000206973206174206164647220000000000a554152
+be720e80542074656d706f7261727920776f726b61726f756e640a000a53656e6420796f757220696363702e7478742066696c65206e6f770a000000554152540a000000
+be720ec044574e4c44204641494c0a00ffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
+5555555500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
+11111111be2678c8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
+99999999be720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
diff --git a/board/grx500/uartddr.conf b/board/grx500/uartddr.conf
new file mode 100755
--- /dev/null
+++ b/board/grx500/uartddr.conf
@@ -0,0 +1,139 @@
+0xb608005c    0x00dfffff
+0xb2200004    0x100c0131
+0xb2200120    0x0000005d
+0xb2200124    0x0f34328b
+0xb49001d0    0xf8002000
+0xb49001d4    0xf8002800
+0xb49001d8    0xfe00a000
+0xb21000c0    0x0000014d
+0xb21000c4    0x000000c8
+0xb21000cc    0x00000021
+0xb21000c8    0x000001f4
+0xb2100134    0x00000044
+0xb2100080    0x00080021
+0xb210007c    0x00000000
+0xb2000044    0x0000040b
+0xb2000054    0x00000b50
+0xb2000058    0x0000000c
+0xb200005c    0x00000010
+0xb2000060    0x00000000
+0xb2000048    0x85589955
+0xb200004c    0x228573c0
+0xb2000050    0x100210b4
+0xb200008c    0x00f8b6d0
+0xb200001c    0x29a14d10
+0xb2000020    0x821403e7
+0xb2000024    0x00083def
+0xb20001c0    0x44000e81
+0xb2000200    0x44000e81
+0xb2000068    0x91003587
+0xb2000005    0x00000000
+0xb2000011    0xb000000f
+0xb20001e8    0x00006e6e
+0xb2000228    0x00006e6e
+0xb2000004    0x00040001
+0xb2000011    0xb000001f
+0xb21002c1    0x00000001
+0xb2100044    0x00000001
+0xb2100049    0x00000001
+0xb21000c0    0x0000014d
+0xb21000c4    0x000000c8
+0xb21000cc    0x00000021
+0xb21000d0    0x8001009c
+0xb21000d4    0x00000004
+0xb21000d8    0x000000ae
+0xb21000dc    0x00000009
+0xb21000e4    0x00000008
+0xb21000e8    0x00000009
+0xb21000ec    0x00000007
+0xb21000f0    0x00000018
+0xb21000f4    0x00000021
+0xb21000f8    0x00000009
+0xb21000fc    0x00000005
+0xb2100100    0x00000005
+0xb21000e0    0x00000002
+0xb2100104    0x0000000a
+0xb2100108    0x00000005
+0xb210010c    0x00000200
+0xb2100110    0x00000004
+0xb2100120    0x00000003
+0xb2100124    0x00000007
+0xb2100128    0x00000007
+0xb2100130    0x0000000c
+0xb210012c    0x00000004
+0xb21000c8    0x000001f4
+0xb2100134    0x00000044
+0xb2100118    0x00000040
+0xb2100138    0x00000200
+0xb2100114    0x00000010
+0xb210011c    0x00000005
+0xb2100140    0x00000005
+0xb2100144    0x00000000
+0xb2100148    0x00001458
+0xb2100000    0x00004780
+0xb2100254    0x00000006
+0xb2100260    0x00000007
+0xb2100250    0x00000001
+0xb2100258    0x00000003
+0xb2100264    0x0000000f
+0xb21002d4    0x00000002
+0xb21002d0    0x00000002
+0xb2100240    0x00000002
+0xb2100284    0x00000040
+0xb2100290    0x00000007
+0xb2100040    0x86f00000
+0xb2100041    0x06f00000
+0xb2100040    0x80f40103
+0xb2100041    0x00f40103
+0xb2100040    0x80f60003
+0xb2100041    0x00f60003
+0xb2100040    0x80f200c3
+0xb2100041    0x00f200c3
+0xb2100040    0x80f0b503
+0xb2100041    0x00f0b503
+0xb2100040    0x80f00005
+0xb2100041    0x00f00005
+0xb2100040    0x80f0000a
+0xb2100041    0x00f0000a
+0xb2100004    0x00000001
+0xb2100009    0x00000001
+0xb2100084    0x00000000
+0xb21002c4    0x00000007
+0xb21002c8    0x00000003
+0xb21002d8    0x00000000
+0xb21002f0    0x00070101
+0xb2100180    0x00000000
+0xb2100290    0x00000003
+0xb2100050    0x00000001
+0xb210004d    0x00000001
+0xb2000004    0x00000201
+0xb2000011    0xb000003f
+0xb2000004    0x00000401
+0xb2000011    0xb000007f
+0xb2000004    0x00000801
+0xb2000011    0xb00000ff
+0xb2000004    0x00001001
+0xb2000011    0xb00001ff
+0xb2000004    0x00002001
+0xb2000011    0xb00003ff
+0xb2000004    0x00004001
+0xb2000011    0xb00007ff
+0xb2000004    0x00008001
+0xb2000011    0xb0000fff
+0xb2100004    0x00000002
+0xb2100009    0x00000003
+0xb2100004    0x00000003
+0xb6200008    0x40403863
+0xb6200038    0x40401756
+0xb2100004    0x00000004
+0xb2100009    0x00000003
+0xb2100004    0x00000001
+0xb2100009    0x00000001
+0xb2000018    0x40000000
+0xb2000018    0x0001c000
+0xb2000004    0x00000110
+0xb2000010    0xb000005f
+0xb2000004    0x00000401
+0xb2000011    0xb000005f
+0xb2100004    0x00000002
+0xb2100009    0x00000003
diff --git a/include/configs/grx500.h b/include/configs/grx500.h
new file mode 100644
--- /dev/null
+++ b/include/configs/grx500.h
@@ -0,0 +1,334 @@
+/*
+ * (C) Copyright 2003-2005
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This file contains the configuration parameters for the AR9 board.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <configs/autoconf.h>
+#include <configs/lq_cfg.h>
+#include <asm/grx500.h>
+
+
+#define CPU_CLOCK_RATE          800000000   /* 800 MHz clock for the MIPS core */
+#define RAM_CLOCK_RATE          400000000   /* 400 MHz clock for RAM           */
+
+#define F_SSC_CLK  get_fpi_clk()
+#define CONFIG_SYS_HZ 1000
+#define CONFIG_ENV_SPI_CS 1
+#define CONFIG_ENV_SPI_MODE CONFIG_SF_DEFAULT_MODE
+
+
+
+#ifndef	CPU_CLOCK_RATE
+/* allowed values: 100000000, 133000000, and 150000000 */
+#define CPU_CLOCK_RATE	150000000	/* default: 150 MHz clock for the MIPS core */
+#endif
+
+//#define CONFIG_BAUDRATE		115200
+//#define CONFIG_BAUDRATE           2400
+
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CONFIG_SYS_ASC_BASE 0xb6600000
+#define	CONFIG_TIMESTAMP		/* Print image info with timestamp */
+
+#ifndef CONFIG_PREBOOT
+#define CONFIG_PREBOOT	"echo;"	\
+	"echo Type \\\"run flash_nfs\\\" to mount root filesystem over NFS;" \
+	"echo"
+#endif
+
+#undef	CONFIG_BOOTARGS
+
+#define CONFIG_EXTRA_ENV_SETTINGS   <configs/lq_extra_env.h>
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CONFIG_SYS_LONGHELP				/* undef to save memory      */
+#define	CONFIG_SYS_PROMPT		"GRX500 # "	/* Monitor Command Prompt    */
+#define	CONFIG_SYS_CBSIZE		1024		/* Console I/O Buffer Size   */
+#define	CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)  /* Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		32		/* max number of command args*/
+
+#ifdef CONFIG_BOOT_FROM_NAND
+#define CONFIG_SYS_MALLOC_LEN		CONFIG_NAND_PAGE_SIZE*1024*2
+#else
+#define CONFIG_SYS_MALLOC_LEN       512*1024*4
+#endif
+
+#define CONFIG_SYS_BOOTPARAMS_LEN	256*1024
+
+#define CONFIG_SYS_MIPS_TIMER_FREQ	CPU_CLOCK_RATE/2
+
+
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+
+#define	CONFIG_SYS_LOAD_ADDR		0x80100000	/* default load address	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x80100000
+#define CONFIG_SYS_MEMTEST_END		0x80800000
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)	/* max number of sectors on one chip */
+
+#define PHYS_FLASH_1		0xb0000000 /* Flash Bank #1 */
+#define PHYS_FLASH_2		0xb0800000 /* Flash Bank #2 */
+
+#define CONFIG_SYS_FLASH_SWAP_ADDR
+
+#define FLASH_FIXUP_ADDR_8(addr)        ((void*)((ulong)(addr)^2))
+#define FLASH_FIXUP_ADDR_16(addr)       ((void*)((ulong)(addr)^2))
+
+#define CONFIG_SYS_FLASH_CFI_WIDTH      FLASH_CFI_16BIT
+
+#define CONFIG_EBU_ADDSEL0               0x10000031
+#define CONFIG_EBU_BUSCON0               0x0001D7FF
+
+
+/* The following #defines are needed to get flash environment right */
+#define	CONFIG_SYS_MONITOR_BASE	CONFIG_RAM_TEXT_BASE
+
+#define	CONFIG_SYS_MONITOR_LEN		(512 << 10)
+
+#define CONFIG_SYS_INIT_SP_OFFSET	0x400000
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(2 * CONFIG_SYS_HZ) /* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(2 * CONFIG_SYS_HZ) /* Timeout for Flash Write */
+
+
+#define CONFIG_FLASH_16BIT
+
+#define CONFIG_NR_DRAM_BANKS	1
+
+#define CONFIG_NET_MULTI
+
+#define CONFIG_SYS_MAX_NAND_DEVICE    1
+#ifdef CONFIG_NAND_CS0
+#define CONFIG_SYS_NAND_BASE   0xb7400000
+#else
+#define CONFIG_SYS_NAND_BASE   0xb7C00000
+#endif
+
+
+#define NAND_BASE_ADDRESS  CONFIG_SYS_NAND_BASE
+#define NAND_WRITE(addr, val)     *((volatile u8*)(NAND_BASE_ADDRESS | (addr))) = val;while((*EBU_NAND_WAIT & 0x08) == 0);
+#define NAND_READ(addr, val)      val = *((volatile u8*)(NAND_BASE_ADDRESS | (addr)));while((*EBU_NAND_WAIT & 0x08) == 0);
+
+#ifdef CONFIG_NAND_CS0
+#define NAND_CE_SET         *EBU_NAND_CON |= 1<<20;
+#define NAND_CE_CLEAR       *EBU_NAND_CON &= ~(1<<20);
+#else
+#define NAND_CE_SET         *EBU_NAND_CON   = 0x00F405F3
+#define NAND_CE_CLEAR       *EBU_NAND_CON   = 0x000005F3
+#endif
+
+//#define NAND_READY       ( ((*EBU_NAND_WAIT)&0x07) == 7)
+#define NAND_READY       ( ((*EBU_NAND_WAIT)&0x01) == 1)
+
+#define NAND_READY_CLEAR  *EBU_NAND_WAIT = 0;
+#define WRITE_CMD    0x18
+#define WRITE_ADDR   0x14
+#define WRITE_LADDR  0x10
+#define WRITE_DATA  0x10
+#define READ_DATA    0x10
+#define READ_LDATA   0x00
+#define ACCESS_WAIT
+#define IFX_ATC_NAND 0xc176
+#define IFX_BTC_NAND 0xc166
+#define ST_512WB2_NAND 0x2076
+#define NAND_LATCH_ENABLE 
+#define NAND_CLRALE  *EBU_NAND_CON &=~(1<<18);
+#define NAND_SETALE  *EBU_NAND_CON |=1<<18; 
+#define NAND_CLRCLE  *EBU_NAND_CON &=~(1<<19);
+#define NAND_SETCLE  *EBU_NAND_CON |=1<<19;
+
+
+
+#define NAND_DISABLE_CE(nand) *EBU_NAND_CON = *EBU_NAND_CON & ~(1<<20);
+#define NAND_ENABLE_CE(nand)  *EBU_NAND_CON = *EBU_NAND_CON |(1<<20);
+#define NAND_WAIT_READY(nand) while(!NAND_READY){}
+#define WRITE_NAND_COMMAND(d, adr) NAND_WRITE(WRITE_CMD,d);
+#define WRITE_NAND_ADDRESS(d, adr) NAND_WRITE(WRITE_ADDR,d);
+#define WRITE_NAND(d, adr) NAND_WRITE(WRITE_DATA,d);
+#define READ_NAND(adr) *((volatile u8*)(NAND_BASE_ADDRESS | (READ_DATA)))
+#define IFX_NAND_CTL_CLRALE *EBU_NAND_CON &=~(1<<18);
+#define IFX_NAND_CTL_SETALE *EBU_NAND_CON |=1<<18;
+
+
+//#define CONFIG_SYS_NAND_PAGE_SIZE   ( 2<<10 )   /* NAND chip page size        */
+//#define CONFIG_SYS_NAND_BLOCK_SIZE  ( 256 << 10 ) /* NAND chip block size       */
+
+#define CONFIG_SYS_NAND_PAGE_SIZE   CONFIG_NAND_PAGE_SIZE   /* NAND chip page size        */
+#define CONFIG_SYS_NAND_BLOCK_SIZE  CONFIG_NAND_BLOCK_SIZE /* NAND chip block size       */
+#define CONFIG_SYS_NAND_PAGE_COUNT  (CONFIG_SYS_NAND_BLOCK_SIZE / CONFIG_SYS_NAND_PAGE_SIZE)
+/* NAND chip page count       */
+
+
+#if (CONFIG_NAND_PAGE_SIZE == 0x200 )
+   #define CONFIG_SYS_NAND_BAD_BLOCK_POS   5       /* Location of bad block marker*/
+   #define CONFIG_SYS_NAND_OOBSIZE 16
+   #define CONFIG_SYS_NAND_ECCPOS      {0, 1, 2, 3, 6, 7}
+   #if (CONFIG_NAND_FLASH_SIZE>=32)
+    #define CONFIG_SYS_NAND_4_ADDR_CYCLE
+   #endif
+ #elif (CONFIG_NAND_PAGE_SIZE == 0x800)
+   #define CONFIG_SYS_NAND_BAD_BLOCK_POS   0       /* Location of bad block marker*/
+   #define CONFIG_SYS_NAND_OOBSIZE 		64
+   #define CONFIG_SYS_NAND_ECCPOS      {40, 41, 42, 43, 44, 45, 46, 47, \
+                                        48, 49, 50, 51, 52, 53, 54, 55, \
+                                        56, 57, 58, 59, 60, 61, 62, 63}
+   #define CONFIG_SYS_NAND_5_ADDR_CYCLE            /* Fifth addr used (<=128MB)  */
+ #elif (CONFIG_NAND_PAGE_SIZE == 0x1000)
+   #define CONFIG_SYS_NAND_BAD_BLOCK_POS   0       /* Location of bad block marker*/
+   #define CONFIG_SYS_NAND_OOBSIZE 		128
+   #define CONFIG_SYS_NAND_ECCPOS      {80, 81, 82, 83, 84, 85, 86, 87, \
+										88, 89, 90, 91, 92, 93, 94, 95, \
+										96, 97, 98, 99, 100, 101, 102, 103, \
+										104, 105, 106, 107, 108, 109, 110, 111, \
+                                        112, 113, 114, 115, 116, 117, 118, 119, \
+                                        120, 121, 122, 123, 124, 125, 126, 127}
+   #define CONFIG_SYS_NAND_5_ADDR_CYCLE            /* Fifth addr used (<=128MB)  */
+  #else
+   #define CONFIG_SYS_NAND_5_ADDR_CYCLE
+   #define CONFIG_SYS_NAND_BAD_BLOCK_POS   0       /* Location of bad block marker*/
+#endif
+
+
+#ifndef CONFIG_NAND_ECC_BCH
+#define CONFIG_SYS_NAND_ECCSIZE 	256
+#define CONFIG_SYS_NAND_ECCBYTES    3
+#define CONFIG_SYS_NAND_ECCSTEPS    (CONFIG_SYS_NAND_PAGE_SIZE / CONFIG_SYS_NAND_ECCSIZE)
+#define CONFIG_SYS_NAND_ECCTOTAL    (CONFIG_SYS_NAND_ECCBYTES * CONFIG_SYS_NAND_ECCSTEPS)
+#define CONFIG_NAND_SPL_OOBSIZE		CONFIG_SYS_NAND_OOBSIZE	
+#else
+#define CONFIG_SYS_NAND_ECCSIZE 	512
+#define CONFIG_SYS_NAND_ECCBYTES    CONFIG_BCH_CONT_T
+#define CONFIG_SYS_NAND_ECCSTEPS    (CONFIG_SYS_NAND_PAGE_SIZE / CONFIG_SYS_NAND_ECCSIZE)
+#define CONFIG_SYS_NAND_ECCTOTAL    (CONFIG_SYS_NAND_ECCBYTES * CONFIG_SYS_NAND_ECCSTEPS)
+#define CONFIG_NAND_SPL_OOBSIZE		CONFIG_SPL_OOBSIZE	
+#endif
+
+#define CONFIG_SYS_NAND_U_BOOT_SIZE  ( 256 << 10 )
+
+#define CONFIG_SYS_NAND_U_BOOT_DST   CONFIG_BOOTSTRAP_TEXT_BASE
+#define CONFIG_SYS_NAND_U_BOOT_START CONFIG_BOOTSTRAP_TEXT_BASE
+
+#define CONFIG_SYS_NAND_U_BOOT_OFFS  CONFIG_NAND_SPL_BLOCK_SIZE
+
+#ifdef CONFIG_BOOT_FROM_NOR
+#define IFX_CFG_FLASH_DDR_CFG_START_ADDR      0xB000FFE8
+#define IFX_CFG_FLASH_DDR_CFG_SIZE            24
+#define IFX_CFG_FLASH_DDR_CFG_END_ADDR        0xb000ffff
+#elif defined(CONFIG_BOOT_FROM_SPI)
+#define IFX_CFG_FLASH_DDR_CFG_START_ADDR      0x0000FFE8
+#define IFX_CFG_FLASH_DDR_CFG_SIZE            24
+#define IFX_CFG_FLASH_DDR_CFG_END_ADDR        0x0000ffff
+#define CONFIG_ENV_SECT_SIZE 0x1000
+#else /*CONFIG_BOOT_FRON_NAND*/
+ #ifdef CONFIG_NAND_ECC_HW_REED_SOLOMON
+   #define IFX_CFG_FLASH_DDR_CFG_START_ADDR      0x0003ffe8
+   #define IFX_CFG_FLASH_DDR_CFG_SIZE            24
+   #define IFX_CFG_FLASH_DDR_CFG_END_ADDR        0x0003ffff 
+ #else
+  #ifdef CONFIG_LTQ_SECURE_BOOT
+   #define IFX_CFG_FLASH_DDR_CFG_START_ADDR      0x00007fe8
+   #define IFX_CFG_FLASH_DDR_CFG_SIZE            24
+   #define IFX_CFG_FLASH_DDR_CFG_END_ADDR        0x00007fff
+  #else
+   #define IFX_CFG_FLASH_DDR_CFG_START_ADDR      0x00003fe8
+   #define IFX_CFG_FLASH_DDR_CFG_SIZE            24
+   #define IFX_CFG_FLASH_DDR_CFG_END_ADDR        0x00003fff
+  #endif
+ #endif
+#endif
+
+/* Address and size of Primary Environment Sector	*/
+#if (defined CONFIG_CMD_UBI) && !(defined CONFIG_NAND_ECC_HW) 
+#define CONFIG_ENV_OFFSET     0x100000
+#define CONFIG_ENV_ADDR       CONFIG_ENV_OFFSET
+//#define CONFIG_NAND_ENV_DST   (CONFIG_SYS_NAND_U_BOOT_DST + CONFIG_SYS_NAND_U_BOOT_SIZE)
+#elif (defined CONFIG_CMD_UBI) && (defined CONFIG_NAND_ECC_HW)
+#define CONFIG_ENV_OFFSET     0x200000
+#define CONFIG_ENV_ADDR       0x200000
+//#define CONFIG_NAND_ENV_DST   (CONFIG_SYS_NAND_U_BOOT_DST + CONFIG_SYS_NAND_U_BOOT_SIZE)
+#else
+#define CONFIG_ENV_OFFSET	  IFX_CFG_FLASH_UBOOT_CFG_START_ADDR
+#define CONFIG_ENV_ADDR		  IFX_CFG_FLASH_UBOOT_CFG_START_ADDR
+#ifndef CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_SIZE       IFX_CFG_FLASH_UBOOT_CFG_SIZE
+#else
+#define CONFIG_ENV_SIZE       0x1000
+#endif
+#endif
+
+
+/*define u-boot env range, only meaningful for nand flash*/
+#ifndef CONFIG_NAND_ECC_HW
+  #ifdef CONFIG_ENV_REDUND
+     #define CONFIG_ENV_OFFSET_REDUND    0x140000
+     #define CONFIG_ENV_SIZE_REDUND      CONFIG_ENV_SIZE
+     #define CONFIG_ENV_RANGE            0x40000
+  #else
+     #define CONFIG_ENV_RANGE            0x80000
+  #endif
+#else
+  #ifdef CONFIG_ENV_REDUND
+     #define CONFIG_ENV_OFFSET_REDUND    0x600000
+     #define CONFIG_ENV_SIZE_REDUND      CONFIG_ENV_SIZE
+     #define CONFIG_ENV_RANGE            0x400000
+  #else
+     #define CONFIG_ENV_RANGE            0x800000
+     #endif
+#endif
+
+
+/*********************************************************/
+
+//#define CONFIG_SYS_RX_ETH_BUFFER        8
+
+#define CONFIG_TUNING_STATUS 0xBE22FF20 
+#define CONFIG_TUNING_SP     0xBE22FF00 
+
+#ifdef CONFIG_DEBUG
+#define DEBUG
+#endif
+
+#define MTDIDS_DEFAULT   CONFIG_MTDIDS
+#define MTDPARTS_DEFAULT CONFIG_MTDPARTS
+
+/* i2c definitions */
+#define CONFIG_SYS_I2C_SPEED	100000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/grx500_cfg.h b/include/configs/grx500_cfg.h
new file mode 100755
--- /dev/null
+++ b/include/configs/grx500_cfg.h
@@ -0,0 +1,1812 @@
+/* ============================================================================
+ * Copyright (C) 2003[- 2004] ? Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ *
+ * File Name: ifx_cfg.h
+ * Author : Mars Lin (mars.lin@infineon.com)
+ * Date:
+ *
+ * ===========================================================================
+ *
+ * Project:
+ * Block:
+ *
+ * ===========================================================================
+ * Contents:  This file contains the data structures and definitions used
+ *        by the core iptables and the sip alg modules.
+ * ===========================================================================
+ * References:
+ */
+
+/*
+ * This file contains the configuration parameters for the IFX board.
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Board specific configurations
+ */
+#if defined(CONFIG_BOOT_FROM_NOR) || defined(CONFIG_BOOT_FROM_UART)
+
+#ifdef CONFIG_NOR_FLASH_2M
+#define IFX_CONFIG_FLASH_SIZE 2
+#elif CONFIG_NOR_FLASH_4M
+#define IFX_CONFIG_FLASH_SIZE 4
+#elif CONFIG_NOR_FLASH_8M
+#define IFX_CONFIG_FLASH_SIZE 8
+#endif
+
+#ifndef IFX_CONFIG_FLASH_SIZE
+#define IFX_CONFIG_FLASH_SIZE 4
+#endif
+
+#ifdef CONFIG_FIRMWARE_IN_ROOTFS
+//2MB flash partition
+#if (IFX_CONFIG_FLASH_SIZE == 2)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0020000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"  \
+  "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0xB0020000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0xB01FADFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0xB01FB200
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x4000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0xB01FEDFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0xB01FEE00
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0xB01FFDFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME        "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR        0xB01FFE00
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE              0x0200
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR          0xB01FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0xB01FFFFF
+
+//4MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 4)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0020000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME           "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR           0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME          "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR          0xB0020000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME          "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR          0xB03F6DFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME            "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR            0xB03ECE00
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                  0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR              0xB03FCDFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME             "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR             0xB03FEE00
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                   0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR               0xB03FFDFF
+
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME         "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR         0xB03FFE00
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE               0x0200
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR           0xB03FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                         0xB03FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 8)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0020000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0xB0020000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0xB07EDFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0xB07EE000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0xB07FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0xB07FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0xB07FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0xB07FF000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0xB07FF3FF
+
+  #define IFX_CFG_FLASH_END_ADDR                         0xB07FFFFF
+
+
+#else
+  #error "ERROR!! Define flash size first!"
+#endif
+
+#else /*Not defined CONFIG_FIRMWARE_IN_ROOTFS*/
+//2MB flash partition
+#if (IFX_CONFIG_FLASH_SIZE == 2)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0020000\0"                                      \
+        "part2_begin=0xB00A0000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"  \
+  "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME       "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR       0xB0020000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE             0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME    "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0xB00A0000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0xB01FADFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0xB01FAE00
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x4000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0xB01FEDFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0xB01FEE00
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0xB01FFDFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME        "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR        0xB01FFE00
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE              0x0200
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR          0xB01FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0xB01FFFFF
+
+//4MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 4)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0020000\0"                                      \
+        "part2_begin=0xB00A0000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME           "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR           0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME        "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR        0xB0020000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE              0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME     "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME          "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR          0xB00A0000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0xB03EDFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0xB03EE000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0xB03FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME             "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR             0xB03FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                   0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR               0xB03FEFFF
+
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME         "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0xB03FF000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0xB03FF3FF
+
+
+  #define IFX_CFG_FLASH_END_ADDR                         0xB03FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 8)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0xB0000000\0"                                      \
+        "part1_begin=0xB0020000\0"                                      \
+        "part2_begin=0xB00A0000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0xB0000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0xB0020000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0xB00A0000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0xB07EDFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0xB07EE000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0xB07FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0xB07FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0xB07FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0xB07FF000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0xB07FF3FF
+  
+   #define IFX_CFG_FLASH_END_ADDR                          0xB07FFFFF
+
+
+#else
+  #error "ERROR!! Define flash size first!"
+#endif
+
+#endif /*CONFIG_FIRMWARE_IN_ROOTFS*/
+
+
+#endif /*CONFIG_BOOT_FROM_NOR*/
+
+/***************************************************************************/
+/***************************************************************************/
+/***************SPI FLASH map starts here***********************************/
+/***************************************************************************/
+/***************************************************************************/
+
+#ifdef CONFIG_BOOT_FROM_SPI
+
+#ifdef CONFIG_SPI_FLASH_1M
+#define IFX_CONFIG_FLASH_SIZE 1
+#elif CONFIG_SPI_FLASH_2M
+#define IFX_CONFIG_FLASH_SIZE 2
+#elif CONFIG_SPI_FLASH_4M
+#define IFX_CONFIG_FLASH_SIZE 4
+#elif CONFIG_SPI_FLASH_8M
+#define IFX_CONFIG_FLASH_SIZE 8
+#elif CONFIG_SPI_FLASH_16M
+#define IFX_CONFIG_FLASH_SIZE 16
+#endif
+
+#ifndef IFX_CONFIG_FLASH_SIZE
+#define IFX_CONFIG_FLASH_SIZE 4
+#endif
+
+#ifdef CONFIG_FIRMWARE_IN_ROOTFS
+//1MB flash partition
+#if (IFX_CONFIG_FLASH_SIZE == 1)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00020000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"  \
+  "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0x00020000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0x000F5FFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0x000F6000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x8000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0x001FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0x000FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0x000FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME        "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR        0x000FFE00
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE              0x0200
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR          0x000FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0x000FFFFF
+//2MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 2)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"  \
+  "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0x00010000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0x001F5FFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0x001F6000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x8000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0x001FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0x001FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0x001FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME        "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR        0x001FFE00
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE              0x0200
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR          0x001FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0x001FFFFF
+
+//4MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 4)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=6\0"
+        
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME           "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR           0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME          "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR          0x00010000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME          "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR          0x003F5FFF  
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME            "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR            0x003F6000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                  0x8000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR              0x003FDFFF
+
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME             "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR             0x003FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                   0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR               0x003FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME         "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR         0x003FFE00
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE               0x0200
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR           0x003FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                         0x003FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 8)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00020000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00020000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x007EDFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME            "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR            0x007EE000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                  0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR              0x007FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME             "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR             0x007FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                   0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR               0x007FEFFF
+
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME         "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR         0x007FF000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE               0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR           0x007FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                         0x007FFFFF
+
+
+#else
+  #error "ERROR!! Define flash size first!"
+#endif
+
+#else /*Not defined CONFIG_FIRMWARE_IN_ROOTFS*/
+#if (IFX_CONFIG_FLASH_SIZE == 1)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00020000\0"                                      \
+        "part2_begin=0x000A0000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"  \
+  "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME       "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR       0x00020000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE             0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME    "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0x000A0000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0x000F5FFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0x000F6000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x8000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0x000FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0x000FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0x000FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME        "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR        0x000FFE00
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE              0x0200
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR          0x000FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0x000FFFFF
+
+//2MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 2)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00020000\0"                                      \
+        "part2_begin=0x000A0000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"  \
+  "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME       "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR       0x00020000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE             0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME    "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0x000A0000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0x001F5FFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0x001F6000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x8000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0x001FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0x001FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0x001FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME        "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR        0x001FFE00
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE              0x0200
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR          0x001FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0x001FFFFF
+
+//4MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 4)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00020000\0"                                      \
+        "part2_begin=0x000A0000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME           "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR           0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME        "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR        0x00020000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE              0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME     "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME          "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR          0x000A0000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME          "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR          0x003F5FFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME            "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR            0x003F6000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                  0x8000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR              0x003FDFFF
+
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME             "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR             0x003FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                   0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR               0x003FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME         "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR         0x003FFE00
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE               0x0200
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR           0x003FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                         0x003FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 8)
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "part2_begin=0x00020000\0"                                      \
+        "part3_begin=0x00054000\0"                                      \
+        "total_part=4\0"
+#else
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00020000\0"                                      \
+        "part2_begin=0x00054000\0"                                      \
+        "total_part=3\0"
+#endif
+
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_BLOCK_NAME "\0"\
+        "data_block2=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block3=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block5=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block6=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block7=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "data_block8=" IFX_CFG_FLASH_WLAN_CFG_BLOCK_NAME "\0"    \
+        "total_db=9\0"
+#else
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+	"data_block7=" IFX_CFG_FLASH_WLAN_CFG_BLOCK_NAME "\0"    \
+        "total_db=8\0"
+#endif
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_BLOCK_NAME    "gphy_firmware"
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_START_ADDR    0x00010000
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_SIZE          0
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_MTDBLOCK_NAME "/dev/mtdblock1"
+#endif
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0x00020000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+#if !defined( CONFIG_VR9_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock2"
+#else
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+#endif
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00054000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0	
+#if !defined( CONFIG_VR9_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock3"
+#else
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+#endif
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x007DFFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x007E0000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x007EFFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x007F0000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x2000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x007F1FFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME               "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR               0x007F2000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                     0x1000
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR                 0x007F2FFF
+
+  #define IFX_CFG_FLASH_WLAN_CFG_BLOCK_NAME	          "wlanconfig"
+  #define IFX_CFG_FLASH_WLAN_CFG_START_ADDR	      	  0x007F3000
+  #define IFX_CFG_FLASH_WLAN_CFG_SIZE		          0x2000
+  #define IFX_CFG_FLASH_WLAN_CFG_END_ADDR		  0x007F4FFF  
+
+  #define IFX_CFG_FLASH_END_ADDR                          0x007FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 16)
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "part2_begin=0x00020000\0"                                      \
+        "part3_begin=0x00054000\0"                                      \
+        "total_part=4\0"
+#else
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00020000\0"                                      \
+        "part2_begin=0x00054000\0"                                      \
+        "total_part=3\0"
+#endif
+
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_BLOCK_NAME "\0"\
+        "data_block2=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block3=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block5=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block6=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block7=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "data_block8=" IFX_CFG_FLASH_WLAN_CFG_BLOCK_NAME "\0"    \
+        "total_db=9\0"
+#else
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+	"data_block7=" IFX_CFG_FLASH_WLAN_CFG_BLOCK_NAME "\0"    \
+        "total_db=8\0"
+#endif
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_BLOCK_NAME    "gphy_firmware"
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_START_ADDR    0x00010000
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_SIZE          0
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_MTDBLOCK_NAME "/dev/mtdblock1"
+#endif
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0x00020000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+#if !defined( CONFIG_VR9_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock2"
+#else
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+#endif
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00054000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0	
+#if !defined( CONFIG_VR9_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock3"
+#else
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+#endif
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x00FDFFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x00FE0000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x00FEFFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x00FF0000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x2000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x00FF1FFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME               "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR               0x00FF2000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                     0x1000
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR                 0x00FF2FFF
+
+  #define IFX_CFG_FLASH_WLAN_CFG_BLOCK_NAME	          "wlanconfig"
+  #define IFX_CFG_FLASH_WLAN_CFG_START_ADDR	      	  0x00FF3000
+  #define IFX_CFG_FLASH_WLAN_CFG_SIZE		          0x2000
+  #define IFX_CFG_FLASH_WLAN_CFG_END_ADDR		  0x00FF4FFF
+
+  #define IFX_CFG_FLASH_END_ADDR                          0x00FFFFFF
+
+#else
+  #error "ERROR!! Define flash size first!"
+#endif
+
+#endif /*CONFIG_FIRMWARE_IN_ROOTFS*/
+
+
+#endif /*CONFIG_BOOT_FROM_SPI*/
+/* End of Board specific configurations
+ *-----------------------------------------------------------------------
+ */
+
+
+
+/***************************************************************************/
+/***************************************************************************/
+/***************NAND FLASH map starts here***********************************/
+/***************************************************************************/
+/***************************************************************************/
+
+#ifdef CONFIG_BOOT_FROM_NAND
+
+#ifdef CONFIG_NAND_FLASH_2M
+#define IFX_CONFIG_FLASH_SIZE 2
+#elif CONFIG_NAND_FLASH_4M
+#define IFX_CONFIG_FLASH_SIZE 4
+#elif CONFIG_NAND_FLASH_8M
+#define IFX_CONFIG_FLASH_SIZE 8
+#elif CONFIG_NAND_FLASH_128M
+#define IFX_CONFIG_FLASH_SIZE 128
+#elif CONFIG_NAND_FLASH_512M
+#define IFX_CONFIG_FLASH_SIZE 512
+#elif CONFIG_NAND_FLASH_2048M
+#define IFX_CONFIG_FLASH_SIZE 2048
+#elif CONFIG_NAND_FLASH_4096M
+#define IFX_CONFIG_FLASH_SIZE 4096
+#endif
+
+#ifndef IFX_CONFIG_FLASH_SIZE
+#define IFX_CONFIG_FLASH_SIZE 4
+#endif
+
+#ifdef CONFIG_FIRMWARE_IN_ROOTFS
+//2MB flash partition
+#if (IFX_CONFIG_FLASH_SIZE == 2)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"  \
+  "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0x00010000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0x001FADFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0x001FB200
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x4000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0x001FEDFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0x001FEE00
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0x001FFDFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME        "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR        0x001FFE00
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE              0x0200
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR          0x001FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0x001FFFFF
+
+//4MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 4)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=6\0"
+        
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME           "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR           0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME          "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR          0x00010000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x003EDFFF  
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x007EE000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x007FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x003FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x003FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0x003FF000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0x003FF3FF
+
+  #define IFX_CFG_FLASH_END_ADDR                          0x003FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 8)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00010000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x007EDFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x007EE000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x007FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x007FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x007FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0x007FF000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0x007FF3FF
+
+ 
+  #define IFX_CFG_FLASH_END_ADDR                         0x007FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 128)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00040000\0"                                      \
+        "part2_begin=0x002C0000\0"                                      \
+        "part3_begin=0x07000000\0"                                      \
+        "part4_begin=0x07040000\0"                                      \
+        "part5_begin=0x07080000\0"                                      \
+        "total_part=6\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0x40000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x00040000
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x002C0000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x07000000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x0700FFFF
+  #define IFX_CFG_FLASH_SYSTEM_CFG_MTDBLOCK_NAME          "/dev/mtdblock3"
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x07040000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x07040FFF
+  #define IFX_CFG_FLASH_UBOOT_CFG_MTDBLOCK_NAME           "/dev/mtdblock4"
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0x07080000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0x0708003FF
+  #define IFX_CFG_FLASH_DECT_CFG_MTDBLOCK_NAME       "/dev/mtdblock5"
+
+  #define IFX_CFG_FLASH_END_ADDR                         0x07FFFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 512)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "total_part=2\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block4=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block5=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=6\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0x40000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00040000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x007EDFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x007EE000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x007FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x007FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x007FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0x007FF000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0x007FF3FF
+
+  #define IFX_CFG_FLASH_END_ADDR                         0x007FFFFF
+
+
+#else
+  #error "ERROR!! Define flash size first!"
+#endif
+
+#else /*Not defined CONFIG_FIRMWARE_IN_ROOTFS*/
+//2MB flash partition
+#if (IFX_CONFIG_FLASH_SIZE == 2)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "part2_begin=0x00040000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO          \
+  "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"  \
+  "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0" \
+  "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0" \
+  "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0" \
+  "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"   \
+  "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"    \
+  "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"  \
+  "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME          "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR          0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME       "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR       0x00010000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE             0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME    "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME         "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR         0x00040000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME         "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR         0x001FADFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE               0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME           "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR           0x001FAE00
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                 0x4000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR             0x001FEDFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME            "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR            0x001FEE00
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                  0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR              0x001FFDFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME        "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR        0x001FFE00
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE              0x0200
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR          0x001FFFFF
+
+  #define IFX_CFG_FLASH_END_ADDR                        0x001FFFFF
+
+//4MB flash partition
+#elif (IFX_CONFIG_FLASH_SIZE == 4)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "part2_begin=0x00040000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME           "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR           0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME        "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR        0x00010000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE              0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME     "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME          "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR          0x00040000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME       "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x003EDFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x003EE000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x003FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x003FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x003FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0x003FF000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0x003FF3FF
+  
+  #define IFX_CFG_FLASH_END_ADDR                         0x003FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 8)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00010000\0"                                      \
+        "part2_begin=0x00050000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0x00010000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00050000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x007EDFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x007EE000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x007FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x007FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x007FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0x007FF000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0x007FF3FF
+  
+ 
+  #define IFX_CFG_FLASH_END_ADDR                          0x007FFFFF
+  
+#elif (IFX_CONFIG_FLASH_SIZE == 128) && !(defined CONFIG_NAND_ECC_HW)
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00040000\0"                                      \
+        "part2_begin=0x00060000\0"                                      \
+        "part3_begin=0x000e0000\0"                                      \
+        "part4_begin=0x002e0000\0"                                      \
+        "part5_begin=0x07000000\0"                                      \
+        "part6_begin=0x07040000\0"                                      \
+        "part7_begin=0x07080000\0"                                      \
+        "total_part=8\0"
+#else
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00040000\0"                                      \
+        "part2_begin=0x000C0000\0"                                      \
+        "part3_begin=0x002C0000\0"                                      \
+        "part4_begin=0x07000000\0"                                      \
+        "part5_begin=0x07040000\0"                                      \
+        "part6_begin=0x07080000\0"                                      \
+        "total_part=7\0"
+#endif
+
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_BLOCK_NAME "\0"        \
+        "data_block2=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block5=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block6=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block7=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=8\0"
+#else
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+#endif
+
+
+    #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_BLOCK_NAME            "gphy_firmware"
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_START_ADDR            0x80000
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock1"
+#endif
+
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0x000a0000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock2"
+#else
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0x00040000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+#endif
+
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x00120000
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock3"
+#else
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x000C0000
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+#endif
+
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00320000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock4"
+#else
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x002C0000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock3"
+#endif
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x07000000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x0700FFFF
+  #define IFX_CFG_FLASH_SYSTEM_CFG_MTDBLOCK_NAME          "/dev/mtdblock4"
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x07040000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x07040FFF
+  #define IFX_CFG_FLASH_UBOOT_CFG_MTDBLOCK_NAME           "/dev/mtdblock5"
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0x07080000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0x0708003FF
+  #define IFX_CFG_FLASH_DECT_CFG_MTDBLOCK_NAME       "/dev/mtdblock6"
+
+  #define IFX_CFG_FLASH_END_ADDR                          0x07FFFFFF
+#elif (IFX_CONFIG_FLASH_SIZE == 128) && defined(CONFIG_NAND_ECC_HW)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00100000\0"                                      \
+        "part2_begin=0x00200000\0"                                      \
+        "part3_begin=0x00400000\0"                                      \
+        "part4_begin=0x07400000\0"                                      \
+        "part5_begin=0x07500000\0"                                      \
+        "part6_begin=0x07600000\0"                                      \
+        "total_part=7\0"
+
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_BLOCK_NAME "\0"        \
+        "data_block2=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block5=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block6=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block7=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=8\0"
+#else
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+#endif
+
+    #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+#if !defined( CONFIG_AR10_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_BLOCK_NAME            "gphy_firmware"
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_START_ADDR            0x400000
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_GPHY_FIRMWARE_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock1"
+#endif
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0x00100000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+#if !defined( CONFIG_VR9_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock2"
+#else
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+#endif
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x00200000
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+#if !defined( CONFIG_VR9_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock3"
+#else
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+#endif
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00400000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+#if !defined( CONFIG_VR9_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock4"
+#else
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock3"
+#endif
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x07400000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x100000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x074FFFFF
+#if !defined( CONFIG_VR9_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_SYSTEM_CFG_MTDBLOCK_NAME          "/dev/mtdblock5"
+#else
+  #define IFX_CFG_FLASH_SYSTEM_CFG_MTDBLOCK_NAME          "/dev/mtdblock4"
+#endif
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x07500000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x10000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x075FFFFF
+#if !defined( CONFIG_VR9_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_UBOOT_CFG_MTDBLOCK_NAME           "/dev/mtdblock6"
+#else
+  #define IFX_CFG_FLASH_UBOOT_CFG_MTDBLOCK_NAME           "/dev/mtdblock5"
+#endif
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0x07600000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x10000
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0x0760FFFF
+#if !defined( CONFIG_VR9_GPHY_FW_EMBEDDED )
+  #define IFX_CFG_FLASH_DECT_CFG_MTDBLOCK_NAME       "/dev/mtdblock7"
+#else
+  #define IFX_CFG_FLASH_DECT_CFG_MTDBLOCK_NAME       "/dev/mtdblock6"
+#endif
+
+  #define IFX_CFG_FLASH_END_ADDR                          0x07FFFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 512)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00040000\0"                                      \
+        "part2_begin=0x000C0000\0"                                      \
+        "total_part=3\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0x00040000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x000C0000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x007EDFFF
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x007EE000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x10000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x007FDFFF
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x007FE000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x007FEFFF
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0x007FF000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x400
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0x007FF3FF
+  
+ 
+  #define IFX_CFG_FLASH_END_ADDR                          0x007FFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 2048)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00100000\0"                                      \
+        "part2_begin=0x00200000\0"                                      \
+        "part3_begin=0x00400000\0"                                      \
+        "part4_begin=0x07400000\0"                                      \
+        "part5_begin=0x07500000\0"                                      \
+        "part6_begin=0x07600000\0"                                      \
+        "total_part=7\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0x00100000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x00200000
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00400000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0x07000000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock3"
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x07400000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x100000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x074FFFFF
+  #define IFX_CFG_FLASH_SYSTEM_CFG_MTDBLOCK_NAME          "/dev/mtdblock4"
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x07500000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x075FFFFF
+  #define IFX_CFG_FLASH_UBOOT_CFG_MTDBLOCK_NAME           "/dev/mtdblock5"
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0x07600000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x10000
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0x076FFFFF
+  #define IFX_CFG_FLASH_DECT_CFG_MTDBLOCK_NAME       "/dev/mtdblock6"
+
+  #define IFX_CFG_FLASH_END_ADDR                          0x07FFFFFF
+
+#elif (IFX_CONFIG_FLASH_SIZE == 4096)
+#define IFX_CFG_FLASH_PARTITIONS_INFO                                   \
+        "part0_begin=0x00000000\0"                                      \
+        "part1_begin=0x00100000\0"                                      \
+        "part2_begin=0x00200000\0"                                      \
+        "part3_begin=0x00400000\0"                                      \
+        "part4_begin=0x07400000\0"                                      \
+        "part5_begin=0x07500000\0"                                      \
+        "part6_begin=0x07600000\0"                                      \
+        "total_part=7\0"
+
+#define IFX_CFG_FLASH_DATA_BLOCKS_INFO                                  \
+        "data_block0=" IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME "\0"        \
+        "data_block1=" IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME "\0"     \
+        "data_block2=" IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME "\0"       \
+        "data_block3=" IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME "\0"       \
+        "data_block4=" IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME "\0"         \
+        "data_block5=" IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME "\0"          \
+        "data_block6=" IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME "\0"      \
+        "total_db=7\0"
+
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_BLOCK_NAME            "uboot"
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_START_ADDR            0x00000000
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_SIZE                  0
+  #define IFX_CFG_FLASH_UBOOT_IMAGE_MTDBLOCK_NAME         "/dev/mtdblock0"
+
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_BLOCK_NAME         "firmware"
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_START_ADDR         0x00100000
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_SIZE               0
+  #define IFX_CFG_FLASH_FIRMWARE_IMAGE_MTDBLOCK_NAME      "/dev/mtdblock1"
+
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_BLOCK_NAME           "kernel"
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_START_ADDR           0x00200000
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_SIZE                 0
+  #define IFX_CFG_FLASH_KERNEL_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock2"
+
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_BLOCK_NAME           "rootfs"
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_START_ADDR           0x00400000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_SIZE                 0x07000000
+  #define IFX_CFG_FLASH_ROOTFS_IMAGE_MTDBLOCK_NAME        "/dev/mtdblock3"
+
+  #define IFX_CFG_FLASH_SYSTEM_CFG_BLOCK_NAME             "sysconfig"
+  #define IFX_CFG_FLASH_SYSTEM_CFG_START_ADDR             0x07400000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_SIZE                   0x100000
+  #define IFX_CFG_FLASH_SYSTEM_CFG_END_ADDR               0x074FFFFF
+  #define IFX_CFG_FLASH_SYSTEM_CFG_MTDBLOCK_NAME          "/dev/mtdblock4"
+
+  #define IFX_CFG_FLASH_UBOOT_CFG_BLOCK_NAME              "ubootconfig"
+  #define IFX_CFG_FLASH_UBOOT_CFG_START_ADDR              0x07500000
+  #define IFX_CFG_FLASH_UBOOT_CFG_SIZE                    0x1000
+  #define IFX_CFG_FLASH_UBOOT_CFG_END_ADDR                0x075FFFFF
+  #define IFX_CFG_FLASH_UBOOT_CFG_MTDBLOCK_NAME           "/dev/mtdblock5"
+
+  #define IFX_CFG_FLASH_DECT_CFG_BLOCK_NAME          "dectconfig"
+  #define IFX_CFG_FLASH_DECT_CFG_START_ADDR          0x07600000
+  #define IFX_CFG_FLASH_DECT_CFG_SIZE                0x10000
+  #define IFX_CFG_FLASH_DECT_CFG_END_ADDR            0x076FFFFF
+  #define IFX_CFG_FLASH_DECT_CFG_MTDBLOCK_NAME       "/dev/mtdblock6"
+
+  #define IFX_CFG_FLASH_END_ADDR                          0x07FFFFFF
+
+#else
+  #error "ERROR!! Define flash size first!"
+#endif
+
+#endif /*CONFIG_FIRMWARE_IN_ROOTFS*/
+
+
+#endif /*CONFIG_BOOT_FROM_SPI*/
+
+
+/* End of Board specific configurations
+ *-----------------------------------------------------------------------
+ */
+
+/*************************************************************************/
+
