diff -Naur net-snmp-5.1/Makefile.in open_snmp/Makefile.in
--- net-snmp-5.1/Makefile.in	2003-10-22 18:43:07.000000000 +0530
+++ open_snmp/Makefile.in	2009-12-16 12:59:00.000000000 +0530
@@ -4,7 +4,7 @@
 
 top_builddir	= .
 
-SUBDIRS		= snmplib @MAINSUBS@ local
+SUBDIRS		= snmplib  @MAINSUBS@ local
 TESTDIRS	= testing
 
 CPP		= @CPP@ 					        \
@@ -22,7 +22,7 @@
 INCLUDESUBDIRHEADERS2=generic.h
 INSTALLBUILTHEADERS=include/net-snmp/net-snmp-config.h
 INSTALLBINSCRIPTS=net-snmp-config
-INSTALLUCDHEADERS=ucd-snmp-config.h version.h mib_module_config.h
+#INSTALLUCDHEADERS=ucd-snmp-config.h version.h mib_module_config.h
 
 #
 # other install rules.
diff -Naur net-snmp-5.1/Makefile.rules.2MB_pkg open_snmp/Makefile.rules.2MB_pkg
--- net-snmp-5.1/Makefile.rules.2MB_pkg	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/Makefile.rules.2MB_pkg	2009-12-16 12:59:01.000000000 +0530
@@ -0,0 +1,387 @@
+
+#
+# standard target definitions.  Set appropriate variables to make use of them.
+#
+# note: the strange use of the "it" variable is for shell parsing when
+# there is no targets to install for that rule.
+#
+
+# the standard items to build: libraries, bins, and sbins
+STANDARDTARGETS     =$(INSTALLLIBS) $(INSTALLBINPROGS) $(INSTALLSBINPROGS)
+STANDARDCLEANTARGETS=$(INSTALLLIBS) $(INSTALLBINPROGS) $(INSTALLSBINPROGS) $(INSTALLUCDLIBS)
+
+standardall: subdirs $(STANDARDTARGETS)
+
+subdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making all in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) ) ; \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+#install: installlocalheaders @installucdheaders@ \
+#         installlocallibs    @installucdlibs@    \
+#         installlocalbin      installlocalsbin   \
+#        installsubdirs      $(OTHERINSTALL)
+
+install: installlocalbin     installlocalsbin   \
+         $(OTHERINSTALL)
+
+uninstall: uninstalllibs uninstallbin uninstallsbin uninstallheaders \
+           uninstallsubdirs $(OTHERUNINSTALL)
+
+installprogs: installbin installsbin
+
+#
+# headers
+#
+# set INSTALLHEADERS to a list of things to install in each makefile.
+# set INSTALLBUILTHEADERS to a list of things to install from builddir
+# set INSTALLSUBDIRHEADERS and INSTALLSUBDIR to subdirectory headers
+# set INSTALLSUBDIRHEADERS2 and INSTALLSUBDIR2 to more subdirectory headers
+# set INSTALLBUILTSUBDIRHEADERS and INSTALLBUILTSUBDIR to a list from builddir
+#
+
+#installheaders: installlocalheaders @installucdheaders@ installsubdirheaders
+
+#installlocalheaders:
+#	@if test "$(INSTALLHEADERS)" != "" ; then \
+#		echo creating directory $(includedir) ; \
+#		it="$(INSTALLHEADERS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(includedir) ; \
+#        for i in $$it ; do \
+#			$(INSTALL_DATA) $(top_srcdir)/include/net-snmp/$$i $(INSTALL_PREFIX)$(includedir) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(includedir)" ; \
+#	        done \
+#	fi
+#	@if test "$(INSTALLBUILTHEADERS)" != "" ; then \
+#		echo creating directory $(includedir) ; \
+#		it="$(INSTALLBUILTHEADERS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(includedir) ; \
+#	        for i in $$it ; do \
+#			$(INSTALL_DATA) $$i $(INSTALL_PREFIX)$(includedir) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(includedir)" ; \
+#	        done \
+#	fi
+#	@if test "$(INCLUDESUBDIRHEADERS)" != "" ; then \
+#		echo creating directory $(includedir)/$(INCLUDESUBDIR) ; \
+#		it="$(INCLUDESUBDIRHEADERS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR) ; \
+#	        for i in $$it ; do \
+#			$(INSTALL_DATA) $(top_srcdir)/include/net-snmp/$(INCLUDESUBDIR)/$$i $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR)" ; \
+#	        done \
+#	fi
+#	@if test "$(INCLUDESUBDIRHEADERS2)" != "" ; then \
+#		echo creating directory $(includedir)/$(INCLUDESUBDIR2) ; \
+#		it="$(INCLUDESUBDIRHEADERS2)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR2) ; \
+#	        for i in $$it ; do \
+#			$(INSTALL_DATA) $(top_srcdir)/include/net-snmp/$(INCLUDESUBDIR2)/$$i $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR2) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR2)" ; \
+#	        done \
+#	fi
+#	@if test "$(INSTALLBUILTSUBDIRHEADERS)" != "" ; then \
+#		echo creating directory $(includedir)/$(INSTALLBUILTSUBDIR) ; \
+#		it="$(INSTALLBUILTSUBDIRHEADERS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(includedir)/$(INSTALLBUILTSUBDIR) ; \
+#	        for i in $$it ; do \
+#			$(INSTALL_DATA) $$i $(INSTALL_PREFIX)$(includedir)/$(INSTALLBUILTSUBDIR) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(includedir)/$(INSTALLBUILTSUBDIR)" ; \
+#	        done \
+#	fi
+
+#installucdheaders:
+#	@if test "$(INSTALLUCDHEADERS)" != "" ; then \
+#		echo creating directory $(ucdincludedir) ; \
+#		it="$(INSTALLUCDHEADERS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(ucdincludedir) ; \
+#	        for i in $$it ; do \
+#			$(INSTALL_DATA) $(top_srcdir)/include/ucd-snmp/$$i $(INSTALL_PREFIX)$(ucdincludedir) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(ucdincludedir)" ; \
+#	        done \
+#	fi
+
+uninstallheaders:
+	@if test "$(INSTALLHEADERS)" != "" ; then \
+		it="$(INSTALLHEADERS)" ; \
+	        for i in $$it ; do \
+			rm -f $(INSTALL_PREFIX)$(includedir)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(includedir)" ; \
+	        done \
+	fi
+	@if test "$(INSTALLBUILTHEADERS)" != "" ; then \
+		it="$(INSTALLBUILTHEADERS)" ; \
+	        for i in $$it ; do \
+			rm -f $(INSTALL_PREFIX)$(includedir)/`basename $$i` ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(includedir)" ; \
+	        done \
+	fi
+	@if test "$(INCLUDESUBDIRHEADERS)" != "" ; then \
+		it="$(INCLUDESUBDIRHEADERS)" ; \
+	        for i in $$it ; do \
+			rm -f $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR)" ; \
+	        done \
+	fi
+	@if test "$(INCLUDESUBDIRHEADERS2)" != "" ; then \
+		it="$(INCLUDESUBDIRHEADERS2)" ; \
+	        for i in $$it ; do \
+			rm -f $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR2)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR2)" ; \
+	        done \
+	fi
+	@if test "$(INSTALLBUILTSUBDIRHEADERS)" != "" ; then \
+		it="$(INSTALLBUILTSUBDIRHEADERS)" ; \
+	        for i in $$it ; do \
+			rm -f $(INSTALL_PREFIX)$(includedir)/$(INSTALLBUILTSUBDIR)/`basename $$i` ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(includedir)/$(INSTALLBUILTSUBDIR)" ; \
+	        done \
+	fi
+
+#
+# libraries
+#
+# set INSTALLLIBS to a list of things to install in each makefile.
+#
+
+#installlibs: installlocallibs @installucdlibs@ installsubdirlibs
+
+#installlocallibs: $(INSTALLLIBS)
+#	@if test "$(INSTALLLIBS)" != ""; then \
+#		it="$(INSTALLLIBS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(libdir) ; \
+#               $(INSTALL) $(INSTALLLIBS) $(INSTALL_PREFIX)$(libdir) ;       \
+#	        for i in $$it ; do    \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(libdir)"; \
+#	                $(RANLIB) $(INSTALL_PREFIX)$(libdir)/$$i ; \
+#	        done ; \
+#		$(LIB_LDCONFIG_CMD) ; \
+#	fi
+
+#installucdlibs: $(INSTALLUCDLIBS)
+#	@if test "$(INSTALLUCDLIBS)" != ""; then \
+#		it="$(INSTALLUCDLIBS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(libdir) ; \
+#               $(INSTALL) $(INSTALLUCDLIBS) $(INSTALL_PREFIX)$(libdir) ;    \
+#	        for i in $$it ; do    \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(libdir)"; \
+#	                $(RANLIB) $(INSTALL_PREFIX)$(libdir)/$$i ; \
+#	        done ; \
+#		$(LIB_LDCONFIG_CMD) ; \
+#	fi
+
+#installsubdirlibs:
+#	@if test "$(SUBDIRS)" != ""; then \
+#		it="$(SUBDIRS)" ; \
+#		for i in $$it ; do       \
+#			echo "making installlibs in `pwd`/$$i"; \
+#	                ( cd $$i ; $(MAKE) installlibs) ;   \
+#                       if test $$? != 0 ; then \
+#				exit 1 ; \
+#			fi  \
+#	        done \
+#	fi
+
+uninstalllibs:
+	@if test "$(INSTALLLIBS)" != ""; then \
+		it="$(INSTALLLIBS)" ; \
+	        for i in $$it ; do   \
+		        $(UNINSTALL) $(INSTALL_PREFIX)$(libdir)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(libdir)"; \
+	        done \
+	fi
+
+#
+# normal bin binaries
+#
+# set INSTALLBINPROGS to a list of things to install in each makefile.
+#
+installbin: installlocalbin installsubdirbin
+
+installlocalbin: $(INSTALLBINPROGS)
+	@if test "$(INSTALLBINPROGS) $(INSTALLBINSCRIPTS)" != " "; then \
+		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(bindir) ; \
+		it="$(INSTALLBINPROGS) $(INSTALLBINSCRIPTS)" ; \
+	        $(INSTALL) $(INSTALLBINPROGS) $(INSTALLBINSCRIPTS) $(INSTALL_PREFIX)$(bindir) ;              \
+	        for i in $$it ; do   \
+	                echo "installing $$i in $(INSTALL_PREFIX)$(bindir)"; \
+	        done \
+	fi
+
+installsubdirbin:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making installbin in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) installbin) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+uninstallbin:
+	@if test "$(INSTALLBINPROGS) $(INSTALLBINSCRIPTS)" != " "; then \
+		it="$(INSTALLBINPROGS) $(INSTALLBINSCRIPTS)" ; \
+	        for i in $$it ; do   \
+		        $(UNINSTALL) $(INSTALL_PREFIX)$(bindir)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(bindir)"; \
+	        done \
+	fi
+
+#
+# sbin binaries
+#
+# set INSTALLSBINPROGS to a list of things to install in each makefile.
+#
+installsbin: installlocalsbin installsubdirsbin
+
+installlocalsbin: $(INSTALLSBINPROGS)
+	@if test "$(INSTALLSBINPROGS)" != ""; then \
+		it="$(INSTALLSBINPROGS)" ; \
+		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(sbindir) ; \
+	        $(INSTALL) $(INSTALLSBINPROGS) $(INSTALL_PREFIX)$(sbindir) ;  \
+	        for i in $$it ; do   \
+	                echo "installing $$i in $(INSTALL_PREFIX)$(sbindir)"; \
+	        done \
+	fi
+
+#installsubdirsbin:
+#	@if test "$(SUBDIRS)" != ""; then \
+#		it="$(SUBDIRS)" ; \
+#		for i in $$it ; do       \
+#			echo "making installsbin in `pwd`/$$i"; \
+
+#	                ( cd $$i ; $(MAKE) installsbin) ;   \
+#                       if test $$? != 0 ; then \
+#				exit 1 ; \
+#			fi  \
+#	        done \
+#	fi
+
+uninstallsbin:
+	@if test "$(INSTALLSBINPROGS)" != ""; then \
+		it="$(INSTALLSBINPROGS)" ; \
+	        for i in $$it ; do   \
+		        $(UNINSTALL) $(INSTALL_PREFIX)$(sbindir)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(sbindir)"; \
+	        done \
+	fi
+
+#
+# general make install target for subdirs
+#
+#installsubdirs:
+#	@if test "$(SUBDIRS)" != ""; then \
+#		it="$(SUBDIRS)" ; \
+#		for i in $$it ; do       \
+#			echo "making install in `pwd`/$$i"; \
+#	                ( cd $$i ; $(MAKE) install) ;   \
+#                       if test $$? != 0 ; then \
+#				exit 1 ; \
+#			fi  \
+#	        done \
+#	fi
+
+uninstallsubdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making uninstall in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) uninstall) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+#
+# cleaning targets
+#
+clean: cleansubdirs $(OTHERCLEANTODOS)
+	rm -f core ${OBJS} ${LOBJS} $(STANDARDCLEANTARGETS) $(OTHERCLEANTARGETS)
+	rm -rf .libs
+
+cleansubdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making clean in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) clean) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+lint:
+	lint -nhx $(CSRCS)
+
+#
+# wacky dependency building.
+#
+depend: dependdirs
+	@if test -f Makefile.depend ; then \
+		makedepend `echo $(CPPFLAGS) | sed 's/-f[-a-z]*//g'` -o .lo $(srcdir)/*.c $(srcdir)/*/*.c ; \
+	fi
+
+
+nosysdepend: nosysdependdirs
+	@if test -f Makefile.depend ; then \
+		makedepend `echo $(CPPFLAGS) | sed 's/-f[-a-z]*//g'` -o .lo $(srcdir)/*.c $(srcdir)/*/*.c ; \
+		perl -n -i.bak $(top_srcdir)/makenosysdepend.pl Makefile ; \
+	fi
+
+distdepend: nosysdepend distdependdirs
+	@if test -f Makefile.depend ; then \
+		perl $(top_srcdir)/makefileindepend.pl ; \
+	fi
+
+dependdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making depend in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) depend) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+nosysdependdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making nosysdepend in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) nosysdepend) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+distdependdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making distdepend in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) distdepend) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+# These aren't real targets, let gnu's make know that.
+.PHONY: clean cleansubdirs lint \
+	install installprogs installheaders installlibs \
+	installbin installsbin installsubdirs \
+	all subdirs standardall \
+	depend nosysdepend distdepend dependdirs nosysdependdirs distdependdirs
diff -Naur net-snmp-5.1/Makefile.rules.full open_snmp/Makefile.rules.full
--- net-snmp-5.1/Makefile.rules.full	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/Makefile.rules.full	2009-12-16 12:59:01.000000000 +0530
@@ -0,0 +1,388 @@
+
+#
+# standard target definitions.  Set appropriate variables to make use of them.
+#
+# note: the strange use of the "it" variable is for shell parsing when
+# there is no targets to install for that rule.
+#
+
+# the standard items to build: libraries, bins, and sbins
+STANDARDTARGETS     =$(INSTALLLIBS) $(INSTALLBINPROGS) $(INSTALLSBINPROGS)
+STANDARDCLEANTARGETS=$(INSTALLLIBS) $(INSTALLBINPROGS) $(INSTALLSBINPROGS) $(INSTALLUCDLIBS)
+
+standardall: subdirs $(STANDARDTARGETS)
+
+subdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making all in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) ) ; \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+#install: installlocalheaders @installucdheaders@ \
+#         installlocallibs    @installucdlibs@    \
+#         installlocalbin      installlocalsbin   \
+#        installsubdirs      $(OTHERINSTALL)
+
+install: installlocallibs     \
+		 installlocalbin     installlocalsbin   \
+         installsubdirs		$(OTHERINSTALL)
+
+uninstall: uninstalllibs uninstallbin uninstallsbin uninstallheaders \
+           uninstallsubdirs $(OTHERUNINSTALL)
+
+installprogs: installbin installsbin
+
+#
+# headers
+#
+# set INSTALLHEADERS to a list of things to install in each makefile.
+# set INSTALLBUILTHEADERS to a list of things to install from builddir
+# set INSTALLSUBDIRHEADERS and INSTALLSUBDIR to subdirectory headers
+# set INSTALLSUBDIRHEADERS2 and INSTALLSUBDIR2 to more subdirectory headers
+# set INSTALLBUILTSUBDIRHEADERS and INSTALLBUILTSUBDIR to a list from builddir
+#
+
+#installheaders: installlocalheaders @installucdheaders@ installsubdirheaders
+
+#installlocalheaders:
+#	@if test "$(INSTALLHEADERS)" != "" ; then \
+#		echo creating directory $(includedir) ; \
+#		it="$(INSTALLHEADERS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(includedir) ; \
+#        for i in $$it ; do \
+#			$(INSTALL_DATA) $(top_srcdir)/include/net-snmp/$$i $(INSTALL_PREFIX)$(includedir) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(includedir)" ; \
+#	        done \
+#	fi
+#	@if test "$(INSTALLBUILTHEADERS)" != "" ; then \
+#		echo creating directory $(includedir) ; \
+#		it="$(INSTALLBUILTHEADERS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(includedir) ; \
+#	        for i in $$it ; do \
+#			$(INSTALL_DATA) $$i $(INSTALL_PREFIX)$(includedir) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(includedir)" ; \
+#	        done \
+#	fi
+#	@if test "$(INCLUDESUBDIRHEADERS)" != "" ; then \
+#		echo creating directory $(includedir)/$(INCLUDESUBDIR) ; \
+#		it="$(INCLUDESUBDIRHEADERS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR) ; \
+#	        for i in $$it ; do \
+#			$(INSTALL_DATA) $(top_srcdir)/include/net-snmp/$(INCLUDESUBDIR)/$$i $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR)" ; \
+#	        done \
+#	fi
+#	@if test "$(INCLUDESUBDIRHEADERS2)" != "" ; then \
+#		echo creating directory $(includedir)/$(INCLUDESUBDIR2) ; \
+#		it="$(INCLUDESUBDIRHEADERS2)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR2) ; \
+#	        for i in $$it ; do \
+#			$(INSTALL_DATA) $(top_srcdir)/include/net-snmp/$(INCLUDESUBDIR2)/$$i $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR2) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR2)" ; \
+#	        done \
+#	fi
+#	@if test "$(INSTALLBUILTSUBDIRHEADERS)" != "" ; then \
+#		echo creating directory $(includedir)/$(INSTALLBUILTSUBDIR) ; \
+#		it="$(INSTALLBUILTSUBDIRHEADERS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(includedir)/$(INSTALLBUILTSUBDIR) ; \
+#	        for i in $$it ; do \
+#			$(INSTALL_DATA) $$i $(INSTALL_PREFIX)$(includedir)/$(INSTALLBUILTSUBDIR) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(includedir)/$(INSTALLBUILTSUBDIR)" ; \
+#	        done \
+#	fi
+
+#installucdheaders:
+#	@if test "$(INSTALLUCDHEADERS)" != "" ; then \
+#		echo creating directory $(ucdincludedir) ; \
+#		it="$(INSTALLUCDHEADERS)" ; \
+#		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(ucdincludedir) ; \
+#	        for i in $$it ; do \
+#			$(INSTALL_DATA) $(top_srcdir)/include/ucd-snmp/$$i $(INSTALL_PREFIX)$(ucdincludedir) ; \
+#	                echo "installing $$i in $(INSTALL_PREFIX)$(ucdincludedir)" ; \
+#	        done \
+#	fi
+
+uninstallheaders:
+	@if test "$(INSTALLHEADERS)" != "" ; then \
+		it="$(INSTALLHEADERS)" ; \
+	        for i in $$it ; do \
+			rm -f $(INSTALL_PREFIX)$(includedir)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(includedir)" ; \
+	        done \
+	fi
+	@if test "$(INSTALLBUILTHEADERS)" != "" ; then \
+		it="$(INSTALLBUILTHEADERS)" ; \
+	        for i in $$it ; do \
+			rm -f $(INSTALL_PREFIX)$(includedir)/`basename $$i` ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(includedir)" ; \
+	        done \
+	fi
+	@if test "$(INCLUDESUBDIRHEADERS)" != "" ; then \
+		it="$(INCLUDESUBDIRHEADERS)" ; \
+	        for i in $$it ; do \
+			rm -f $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR)" ; \
+	        done \
+	fi
+	@if test "$(INCLUDESUBDIRHEADERS2)" != "" ; then \
+		it="$(INCLUDESUBDIRHEADERS2)" ; \
+	        for i in $$it ; do \
+			rm -f $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR2)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(includedir)/$(INCLUDESUBDIR2)" ; \
+	        done \
+	fi
+	@if test "$(INSTALLBUILTSUBDIRHEADERS)" != "" ; then \
+		it="$(INSTALLBUILTSUBDIRHEADERS)" ; \
+	        for i in $$it ; do \
+			rm -f $(INSTALL_PREFIX)$(includedir)/$(INSTALLBUILTSUBDIR)/`basename $$i` ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(includedir)/$(INSTALLBUILTSUBDIR)" ; \
+	        done \
+	fi
+
+#
+# libraries
+#
+# set INSTALLLIBS to a list of things to install in each makefile.
+#
+
+installlibs: installlocallibs installsubdirlibs
+
+installlocallibs: $(INSTALLLIBS)
+	@if test "$(INSTALLLIBS)" != ""; then \
+		it="$(INSTALLLIBS)" ; \
+		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(libdir) ; \
+               $(INSTALL) $(INSTALLLIBS) $(INSTALL_PREFIX)$(libdir) ;       \
+	        for i in $$it ; do    \
+	                echo "installing $$i in $(INSTALL_PREFIX)$(libdir)"; \
+	                $(RANLIB) $(INSTALL_PREFIX)$(libdir)/$$i ; \
+	        done ; \
+		$(LIB_LDCONFIG_CMD) ; \
+	fi
+
+installucdlibs: $(INSTALLUCDLIBS)
+	@if test "$(INSTALLUCDLIBS)" != ""; then \
+		it="$(INSTALLUCDLIBS)" ; \
+		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(libdir) ; \
+               $(INSTALL) $(INSTALLUCDLIBS) $(INSTALL_PREFIX)$(libdir) ;    \
+	        for i in $$it ; do    \
+	                echo "installing $$i in $(INSTALL_PREFIX)$(libdir)"; \
+	                $(RANLIB) $(INSTALL_PREFIX)$(libdir)/$$i ; \
+	        done ; \
+		$(LIB_LDCONFIG_CMD) ; \
+	fi
+
+installsubdirlibs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making installlibs in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) installlibs) ;   \
+                      if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+uninstalllibs:
+	@if test "$(INSTALLLIBS)" != ""; then \
+		it="$(INSTALLLIBS)" ; \
+	        for i in $$it ; do   \
+		        $(UNINSTALL) $(INSTALL_PREFIX)$(libdir)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(libdir)"; \
+	        done \
+	fi
+
+#
+# normal bin binaries
+#
+# set INSTALLBINPROGS to a list of things to install in each makefile.
+#
+installbin: installlocalbin installsubdirbin
+
+installlocalbin: $(INSTALLBINPROGS)
+	@if test "$(INSTALLBINPROGS) $(INSTALLBINSCRIPTS)" != " "; then \
+		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(bindir) ; \
+		it="$(INSTALLBINPROGS) $(INSTALLBINSCRIPTS)" ; \
+	        $(INSTALL) $(INSTALLBINPROGS) $(INSTALLBINSCRIPTS) $(INSTALL_PREFIX)$(bindir) ;              \
+	        for i in $$it ; do   \
+	                echo "installing $$i in $(INSTALL_PREFIX)$(bindir)"; \
+	        done \
+	fi
+
+installsubdirbin:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making installbin in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) installbin) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+uninstallbin:
+	@if test "$(INSTALLBINPROGS) $(INSTALLBINSCRIPTS)" != " "; then \
+		it="$(INSTALLBINPROGS) $(INSTALLBINSCRIPTS)" ; \
+	        for i in $$it ; do   \
+		        $(UNINSTALL) $(INSTALL_PREFIX)$(bindir)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(bindir)"; \
+	        done \
+	fi
+
+#
+# sbin binaries
+#
+# set INSTALLSBINPROGS to a list of things to install in each makefile.
+#
+installsbin: installlocalsbin installsubdirsbin
+
+installlocalsbin: $(INSTALLSBINPROGS)
+	@if test "$(INSTALLSBINPROGS)" != ""; then \
+		it="$(INSTALLSBINPROGS)" ; \
+		$(SHELL) $(top_srcdir)/mkinstalldirs $(INSTALL_PREFIX)$(sbindir) ; \
+	        $(INSTALL) $(INSTALLSBINPROGS) $(INSTALL_PREFIX)$(sbindir) ;  \
+	        for i in $$it ; do   \
+	                echo "installing $$i in $(INSTALL_PREFIX)$(sbindir)"; \
+	        done \
+	fi
+
+#installsubdirsbin:
+#	@if test "$(SUBDIRS)" != ""; then \
+#		it="$(SUBDIRS)" ; \
+#		for i in $$it ; do       \
+#			echo "making installsbin in `pwd`/$$i"; \
+
+#	                ( cd $$i ; $(MAKE) installsbin) ;   \
+#                       if test $$? != 0 ; then \
+#				exit 1 ; \
+#			fi  \
+#	        done \
+#	fi
+
+uninstallsbin:
+	@if test "$(INSTALLSBINPROGS)" != ""; then \
+		it="$(INSTALLSBINPROGS)" ; \
+	        for i in $$it ; do   \
+		        $(UNINSTALL) $(INSTALL_PREFIX)$(sbindir)/$$i ; \
+	                echo "removing $$i from $(INSTALL_PREFIX)$(sbindir)"; \
+	        done \
+	fi
+
+#
+# general make install target for subdirs
+#
+installsubdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making install in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) install) ;   \
+                       if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+uninstallsubdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making uninstall in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) uninstall) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+#
+# cleaning targets
+#
+clean: cleansubdirs $(OTHERCLEANTODOS)
+	rm -f core ${OBJS} ${LOBJS} $(STANDARDCLEANTARGETS) $(OTHERCLEANTARGETS)
+	rm -rf .libs
+
+cleansubdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making clean in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) clean) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+lint:
+	lint -nhx $(CSRCS)
+
+#
+# wacky dependency building.
+#
+depend: dependdirs
+	@if test -f Makefile.depend ; then \
+		makedepend `echo $(CPPFLAGS) | sed 's/-f[-a-z]*//g'` -o .lo $(srcdir)/*.c $(srcdir)/*/*.c ; \
+	fi
+
+
+nosysdepend: nosysdependdirs
+	@if test -f Makefile.depend ; then \
+		makedepend `echo $(CPPFLAGS) | sed 's/-f[-a-z]*//g'` -o .lo $(srcdir)/*.c $(srcdir)/*/*.c ; \
+		perl -n -i.bak $(top_srcdir)/makenosysdepend.pl Makefile ; \
+	fi
+
+distdepend: nosysdepend distdependdirs
+	@if test -f Makefile.depend ; then \
+		perl $(top_srcdir)/makefileindepend.pl ; \
+	fi
+
+dependdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making depend in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) depend) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+nosysdependdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making nosysdepend in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) nosysdepend) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+distdependdirs:
+	@if test "$(SUBDIRS)" != ""; then \
+		it="$(SUBDIRS)" ; \
+		for i in $$it ; do       \
+			echo "making distdepend in `pwd`/$$i"; \
+	                ( cd $$i ; $(MAKE) distdepend) ;   \
+                        if test $$? != 0 ; then \
+				exit 1 ; \
+			fi  \
+	        done \
+	fi
+
+# These aren't real targets, let gnu's make know that.
+.PHONY: clean cleansubdirs lint \
+	install installprogs installheaders installlibs \
+	installbin installsbin installsubdirs \
+	all subdirs standardall \
+	depend nosysdepend distdepend dependdirs nosysdependdirs distdependdirs
diff -Naur net-snmp-5.1/Makefile.top open_snmp/Makefile.top
--- net-snmp-5.1/Makefile.top	2003-10-29 07:01:14.000000000 +0530
+++ open_snmp/Makefile.top	2009-12-16 12:59:01.000000000 +0530
@@ -43,9 +43,11 @@
 #
 # Compiler arguments
 #
-CFLAGS		= @CFLAGS@ @DEVFLAGS@
+#CFLAGS		= @CFLAGS@ @DEVFLAGS@ $(IFX_CFLAGS)
+CFLAGS		= @DEVFLAGS@ $(IFX_CFLAGS)
 EXTRACPPFLAGS	= @EXTRACPPFLAGS@
-LDFLAGS		= @LDFLAGS@ 
+#LDFLAGS	= @LDFLAGS@ $(IFX_LDFLAGS) -lIFXAPIs
+LDFLAGS		= $(IFX_LDFLAGS) -lIFXAPIs
 LIBTOOL		= @LIBTOOL@ @LIBTOOLFLAGS@
 EXEEXT		= @EXEEXT@
 
diff -Naur net-snmp-5.1/README.configure open_snmp/README.configure
--- net-snmp-5.1/README.configure	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/README.configure	2009-12-16 12:59:02.000000000 +0530
@@ -0,0 +1 @@
+configure-summary and config.status are for information and comparison - there may not be any difference...
diff -Naur net-snmp-5.1/acconfig.h open_snmp/acconfig.h
--- net-snmp-5.1/acconfig.h	2003-11-06 08:20:38.000000000 +0530
+++ open_snmp/acconfig.h	2009-12-16 12:59:03.000000000 +0530
@@ -4,7 +4,7 @@
 /* config.h:  a general config file */
 
 /* Default (SNMP) version number for the tools to use */
-#define DEFAULT_SNMP_VERSION 3
+#define DEFAULT_SNMP_VERSION 1
 
 /* don't change these values! */
 #define SNMPV1      0xAAAA       /* readable by anyone */
diff -Naur net-snmp-5.1/agent/Makefile.in open_snmp/agent/Makefile.in
--- net-snmp-5.1/agent/Makefile.in	2003-10-14 19:00:48.000000000 +0530
+++ open_snmp/agent/Makefile.in	2009-12-16 12:59:03.000000000 +0530
@@ -1,6 +1,7 @@
 #
 # Makefile for snmpd
 #
+# 509141:tc.chen 2005/09/14 add cpe-dsl-mib feature support
 
 top_builddir	= ..
 
@@ -66,10 +67,12 @@
 HELPERLIB	= helpers/libnetsnmphelpers.$(LIB_EXTENSION)$(LIB_VERSION)
 LOCAL_LIBS	= 
 LIBS		= ../snmplib/libnetsnmp.$(LIB_EXTENSION)$(LIB_VERSION) @AGENTLIBS@
-OUR_AGENT_LIBS	= $(INSTALLLIBS) $(HELPERLIB) @WRAPLIBS@ $(LIBS) @DLLIBS@
+IFX_COMMON_LIBS = -lIFXAPIs $(IFX_LDFLAGS)
+
+OUR_AGENT_LIBS	= $(INSTALLLIBS) $(HELPERLIB) @WRAPLIBS@ $(LIBS) $(IFX_COMMON_LIBS) @DLLIBS@
 CPPFLAGS	= -I../include -I$(top_srcdir)/include \
 		  -I.. -I$(srcdir)/.. -I$(srcdir)/../snmplib \
-		  -I$(srcdir) -I. -I$(srcdir)/mibgroup -Imibgroup @CPPFLAGS@
+		  -I$(srcdir) -I. -I$(srcdir)/mibgroup -Imibgroup $(IFX_CFLAGS) @CPPFLAGS@
 
 #
 # Objects
@@ -115,8 +118,14 @@
 getmibstat.o: mibgroup/kernel_sunos5.c
 	$(CC) $(CFLAGS) -o $@ -D_GETMIBSTAT_TEST -DDODEBUG -c $? 
 
+ifeq ($(IFX_CONFIG_CPE_DSL_MIB),1)
+snmpd$(EXEEXT):	../apps/.libs/libnetsnmptrapd.a ${LAGENTOBJS} $(USELIBS) $(HELPERLIB) $(LIBTARG) ${INSTALLLIBS}
+	$(LINK) $(CFLAGS) -o $@ ${LAGENTOBJS} $(LOCAL_LIBS) ${LDFLAGS} ${OUR_AGENT_LIBS} ../apps/.libs/libnetsnmptrapd.a 
+else
 snmpd$(EXEEXT):	${LAGENTOBJS} $(USELIBS) $(HELPERLIB) $(LIBTARG) ${INSTALLLIBS}
 	$(LINK) $(CFLAGS) -o $@ ${LAGENTOBJS} $(LOCAL_LIBS) ${LDFLAGS} ${OUR_AGENT_LIBS}
+endif
+
 
 
 libnetsnmpagent.$(LIB_EXTENSION)$(LIB_VERSION):    ${LLIBAGENTOBJS} libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION)
diff -Naur net-snmp-5.1/agent/agent_index.c open_snmp/agent/agent_index.c
--- net-snmp-5.1/agent/agent_index.c	2002-08-15 20:44:20.000000000 +0530
+++ open_snmp/agent/agent_index.c	2009-12-16 12:59:04.000000000 +0530
@@ -74,6 +74,7 @@
 
 extern netsnmp_session *main_session;
 
+#ifdef SNMP_SECMOD_USM
 /*
  * The caller is responsible for free()ing the memory returned by
  * this function.  
@@ -614,6 +615,7 @@
                        value_len * sizeof(oid));
     return (unregister_index(&varbind, FALSE, main_session));
 }
+#endif
 
 void
 dump_idx_registry(void)
@@ -679,6 +681,7 @@
     }
 }
 
+#ifdef SUBBI
 unsigned long
 count_indexes(oid * name, size_t namelen, int include_unallocated)
 {
@@ -862,3 +865,4 @@
     dump_idx_registry();
 }
 #endif
+#endif
diff -Naur net-snmp-5.1/agent/agent_trap.c open_snmp/agent/agent_trap.c
--- net-snmp-5.1/agent/agent_trap.c	2003-11-02 18:20:37.000000000 +0530
+++ open_snmp/agent/agent_trap.c	2009-12-16 12:59:04.000000000 +0530
@@ -71,19 +71,19 @@
 int             trap_version_id_len;
 
 #define SNMPV2_TRAPS_PREFIX	SNMP_OID_SNMPMODULES,1,1,5
-oid             trap_prefix[]    = { SNMPV2_TRAPS_PREFIX };
-oid             cold_start_oid[] = { SNMPV2_TRAPS_PREFIX, 1 };  /* SNMPv2-MIB */
-oid             warm_start_oid[] = { SNMPV2_TRAPS_PREFIX, 2 };  /* SNMPv2-MIB */
-oid             link_down_oid[]  = { SNMPV2_TRAPS_PREFIX, 3 };  /* IF-MIB */
-oid             link_up_oid[]    = { SNMPV2_TRAPS_PREFIX, 4 };  /* IF-MIB */
-oid             auth_fail_oid[]  = { SNMPV2_TRAPS_PREFIX, 5 };  /* SNMPv2-MIB */
-oid             egp_xxx_oid[]    = { SNMPV2_TRAPS_PREFIX, 99 }; /* ??? */
+const oid             trap_prefix[]    = { SNMPV2_TRAPS_PREFIX };
+const oid             cold_start_oid[] = { SNMPV2_TRAPS_PREFIX, 1 };  /* SNMPv2-MIB */
+const oid             warm_start_oid[] = { SNMPV2_TRAPS_PREFIX, 2 };  /* SNMPv2-MIB */
+const oid             link_down_oid[]  = { SNMPV2_TRAPS_PREFIX, 3 };  /* IF-MIB */
+const oid             link_up_oid[]    = { SNMPV2_TRAPS_PREFIX, 4 };  /* IF-MIB */
+const oid             auth_fail_oid[]  = { SNMPV2_TRAPS_PREFIX, 5 };  /* SNMPv2-MIB */
+const oid             egp_xxx_oid[]    = { SNMPV2_TRAPS_PREFIX, 99 }; /* ??? */
 
 #define SNMPV2_TRAP_OBJS_PREFIX	SNMP_OID_SNMPMODULES,1,1,4
-oid             snmptrap_oid[] = { SNMPV2_TRAP_OBJS_PREFIX, 1, 0 };
+const oid             snmptrap_oid[] = { SNMPV2_TRAP_OBJS_PREFIX, 1, 0 };
 oid             snmptrapenterprise_oid[] =
     { SNMPV2_TRAP_OBJS_PREFIX, 3, 0 };
-oid             sysuptime_oid[] = { SNMP_OID_MIB2, 1, 3, 0 };
+const oid             sysuptime_oid[] = { SNMP_OID_MIB2, 1, 3, 0 };
 size_t          snmptrap_oid_len;
 size_t          snmptrapenterprise_oid_len;
 size_t          sysuptime_oid_len;
@@ -834,7 +834,8 @@
 {
     char            tmpbuf[1024];
     char           *sp, *cp, *pp = NULL;
-    u_short         sinkport;
+  //  u_short         sinkport;
+    unsigned int   sinkport;
 
     if (!snmp_trapcommunity)
         snmp_trapcommunity = strdup("public");
@@ -865,7 +866,8 @@
 {
     char            tmpbuf[1024];
     char           *sp, *cp, *pp = NULL;
-    u_short         sinkport;
+   // u_short         sinkport;
+    unsigned int   sinkport;
 
     if (!snmp_trapcommunity)
         snmp_trapcommunity = strdup("public");
@@ -895,7 +897,8 @@
 {
     char            tmpbuf[1024];
     char           *sp, *cp, *pp = NULL;
-    u_short         sinkport;
+    //u_short         sinkport;
+    unsigned int   sinkport;
 
     if (!snmp_trapcommunity)
         snmp_trapcommunity = strdup("public");
diff -Naur net-snmp-5.1/agent/helpers/Makefile.depend open_snmp/agent/helpers/Makefile.depend
--- net-snmp-5.1/agent/helpers/Makefile.depend	2003-10-29 07:35:45.000000000 +0530
+++ open_snmp/agent/helpers/Makefile.depend	2009-12-16 12:59:05.000000000 +0530
@@ -5,103 +5,6 @@
 ./all_helpers.lo: ../../include/net-snmp/system/sysv.h
 ./all_helpers.lo: ../../include/net-snmp/system/generic.h
 ./all_helpers.lo: ../../include/net-snmp/machine/generic.h
-./baby_steps.lo: ../../include/net-snmp/net-snmp-config.h
-./baby_steps.lo: ../../include/net-snmp/system/linux.h
-./baby_steps.lo: ../../include/net-snmp/system/sysv.h
-./baby_steps.lo: ../../include/net-snmp/system/generic.h
-./baby_steps.lo: ../../include/net-snmp/machine/generic.h
-./baby_steps.lo: ../../include/net-snmp/net-snmp-includes.h
-./baby_steps.lo: ../../include/net-snmp/definitions.h
-./baby_steps.lo: ../../include/net-snmp/types.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp_api.h
-./baby_steps.lo: ../../include/net-snmp/library/asn1.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp_impl.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp-tc.h
-./baby_steps.lo: ../../include/net-snmp/utilities.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp_client.h
-./baby_steps.lo: ../../include/net-snmp/library/getopt.h
-./baby_steps.lo: ../../include/net-snmp/library/system.h
-./baby_steps.lo: ../../include/net-snmp/library/tools.h
-./baby_steps.lo: ../../include/net-snmp/library/int64.h
-./baby_steps.lo: ../../include/net-snmp/library/mt_support.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp_alarm.h
-./baby_steps.lo: ../../include/net-snmp/library/callback.h
-./baby_steps.lo: ../../include/net-snmp/library/data_list.h
-./baby_steps.lo: ../../include/net-snmp/library/oid_stash.h
-./baby_steps.lo: ../../include/net-snmp/library/check_varbind.h
-./baby_steps.lo: ../../include/net-snmp/library/container.h
-./baby_steps.lo: ../../include/net-snmp/library/factory.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp_logging.h
-./baby_steps.lo: ../../include/net-snmp/library/container_binary_array.h
-./baby_steps.lo: ../../include/net-snmp/library/container_list_ssll.h
-./baby_steps.lo: ../../include/net-snmp/library/container_iterator.h
-./baby_steps.lo: ../../include/net-snmp/library/container.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp_assert.h
-./baby_steps.lo: ../../include/net-snmp/version.h
-./baby_steps.lo: ../../include/net-snmp/session_api.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp_transport.h
-./baby_steps.lo: ../../include/net-snmp/library/snmpCallbackDomain.h
-./baby_steps.lo: ../../include/net-snmp/library/snmpUnixDomain.h
-./baby_steps.lo: ../../include/net-snmp/library/snmpUDPDomain.h
-./baby_steps.lo: ../../include/net-snmp/library/snmpTCPDomain.h
-./baby_steps.lo: ../../include/net-snmp/library/snmpUDPIPv6Domain.h
-./baby_steps.lo: ../../include/net-snmp/library/snmpTCPIPv6Domain.h
-./baby_steps.lo: ../../include/net-snmp/library/snmpIPXDomain.h
-./baby_steps.lo: ../../include/net-snmp/library/ucd_compat.h
-./baby_steps.lo: ../../include/net-snmp/pdu_api.h
-./baby_steps.lo: ../../include/net-snmp/mib_api.h
-./baby_steps.lo: ../../include/net-snmp/library/mib.h
-./baby_steps.lo: ../../include/net-snmp/library/parse.h
-./baby_steps.lo: ../../include/net-snmp/varbind_api.h
-./baby_steps.lo: ../../include/net-snmp/config_api.h
-./baby_steps.lo: ../../include/net-snmp/library/read_config.h
-./baby_steps.lo: ../../include/net-snmp/library/default_store.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp_parse_args.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp_enum.h
-./baby_steps.lo: ../../include/net-snmp/library/vacm.h
-./baby_steps.lo: ../../include/net-snmp/output_api.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp_debug.h
-./baby_steps.lo: ../../include/net-snmp/snmpv3_api.h
-./baby_steps.lo: ../../include/net-snmp/library/snmpv3.h
-./baby_steps.lo: ../../include/net-snmp/library/transform_oids.h
-./baby_steps.lo: ../../include/net-snmp/library/keytools.h
-./baby_steps.lo: ../../include/net-snmp/library/scapi.h
-./baby_steps.lo: ../../include/net-snmp/library/lcd_time.h
-./baby_steps.lo: ../../include/net-snmp/library/snmp_secmod.h
-./baby_steps.lo: ../../include/net-snmp/library/snmpv3-security-includes.h
-./baby_steps.lo: ../../include/net-snmp/library/snmpusm.h
-./baby_steps.lo: ../../include/net-snmp/agent/net-snmp-agent-includes.h
-./baby_steps.lo: ../../include/net-snmp/agent/snmp_agent.h
-./baby_steps.lo: ../../include/net-snmp/agent/snmp_vars.h
-./baby_steps.lo: ../../include/net-snmp/agent/agent_handler.h
-./baby_steps.lo: ../../include/net-snmp/agent/var_struct.h
-./baby_steps.lo: ../../include/net-snmp/agent/agent_registry.h
-./baby_steps.lo: ../../include/net-snmp/agent/ds_agent.h
-./baby_steps.lo: ../../include/net-snmp/agent/agent_read_config.h
-./baby_steps.lo: ../../include/net-snmp/agent/agent_trap.h
-./baby_steps.lo: ../../include/net-snmp/agent/all_helpers.h
-./baby_steps.lo: ../../include/net-snmp/agent/instance.h
-./baby_steps.lo: ../../include/net-snmp/agent/baby_steps.h
-./baby_steps.lo: ../../include/net-snmp/agent/scalar.h
-./baby_steps.lo: ../../include/net-snmp/agent/scalar_group.h
-./baby_steps.lo: ../../include/net-snmp/agent/multiplexer.h
-./baby_steps.lo: ../../include/net-snmp/agent/null.h
-./baby_steps.lo: ../../include/net-snmp/agent/debug_handler.h
-./baby_steps.lo: ../../include/net-snmp/agent/cache_handler.h
-./baby_steps.lo: ../../include/net-snmp/agent/old_api.h
-./baby_steps.lo: ../../include/net-snmp/agent/read_only.h
-./baby_steps.lo: ../../include/net-snmp/agent/row_merge.h
-./baby_steps.lo: ../../include/net-snmp/agent/serialize.h
-./baby_steps.lo: ../../include/net-snmp/agent/bulk_to_next.h
-./baby_steps.lo: ../../include/net-snmp/agent/mode_end_call.h
-./baby_steps.lo: ../../include/net-snmp/agent/table.h
-./baby_steps.lo: ../../include/net-snmp/agent/table_data.h
-./baby_steps.lo: ../../include/net-snmp/agent/table_dataset.h
-./baby_steps.lo: ../../include/net-snmp/agent/table_iterator.h
-./baby_steps.lo: ../../include/net-snmp/agent/table_mfd.h
-./baby_steps.lo: ../../include/net-snmp/agent/table_array.h
-./baby_steps.lo: ../../include/net-snmp/agent/mib_module_config.h
 ./bulk_to_next.lo: ../../include/net-snmp/net-snmp-config.h
 ./bulk_to_next.lo: ../../include/net-snmp/system/linux.h
 ./bulk_to_next.lo: ../../include/net-snmp/system/sysv.h
@@ -296,103 +199,6 @@
 ./cache_handler.lo: ../../include/net-snmp/agent/table_mfd.h
 ./cache_handler.lo: ../../include/net-snmp/agent/table_array.h
 ./cache_handler.lo: ../../include/net-snmp/agent/mib_module_config.h
-./debug_handler.lo: ../../include/net-snmp/net-snmp-config.h
-./debug_handler.lo: ../../include/net-snmp/system/linux.h
-./debug_handler.lo: ../../include/net-snmp/system/sysv.h
-./debug_handler.lo: ../../include/net-snmp/system/generic.h
-./debug_handler.lo: ../../include/net-snmp/machine/generic.h
-./debug_handler.lo: ../../include/net-snmp/net-snmp-includes.h
-./debug_handler.lo: ../../include/net-snmp/definitions.h
-./debug_handler.lo: ../../include/net-snmp/types.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp_api.h
-./debug_handler.lo: ../../include/net-snmp/library/asn1.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp_impl.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp-tc.h
-./debug_handler.lo: ../../include/net-snmp/utilities.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp_client.h
-./debug_handler.lo: ../../include/net-snmp/library/getopt.h
-./debug_handler.lo: ../../include/net-snmp/library/system.h
-./debug_handler.lo: ../../include/net-snmp/library/tools.h
-./debug_handler.lo: ../../include/net-snmp/library/int64.h
-./debug_handler.lo: ../../include/net-snmp/library/mt_support.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp_alarm.h
-./debug_handler.lo: ../../include/net-snmp/library/callback.h
-./debug_handler.lo: ../../include/net-snmp/library/data_list.h
-./debug_handler.lo: ../../include/net-snmp/library/oid_stash.h
-./debug_handler.lo: ../../include/net-snmp/library/check_varbind.h
-./debug_handler.lo: ../../include/net-snmp/library/container.h
-./debug_handler.lo: ../../include/net-snmp/library/factory.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp_logging.h
-./debug_handler.lo: ../../include/net-snmp/library/container_binary_array.h
-./debug_handler.lo: ../../include/net-snmp/library/container_list_ssll.h
-./debug_handler.lo: ../../include/net-snmp/library/container_iterator.h
-./debug_handler.lo: ../../include/net-snmp/library/container.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp_assert.h
-./debug_handler.lo: ../../include/net-snmp/version.h
-./debug_handler.lo: ../../include/net-snmp/session_api.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp_transport.h
-./debug_handler.lo: ../../include/net-snmp/library/snmpCallbackDomain.h
-./debug_handler.lo: ../../include/net-snmp/library/snmpUnixDomain.h
-./debug_handler.lo: ../../include/net-snmp/library/snmpUDPDomain.h
-./debug_handler.lo: ../../include/net-snmp/library/snmpTCPDomain.h
-./debug_handler.lo: ../../include/net-snmp/library/snmpUDPIPv6Domain.h
-./debug_handler.lo: ../../include/net-snmp/library/snmpTCPIPv6Domain.h
-./debug_handler.lo: ../../include/net-snmp/library/snmpIPXDomain.h
-./debug_handler.lo: ../../include/net-snmp/library/ucd_compat.h
-./debug_handler.lo: ../../include/net-snmp/pdu_api.h
-./debug_handler.lo: ../../include/net-snmp/mib_api.h
-./debug_handler.lo: ../../include/net-snmp/library/mib.h
-./debug_handler.lo: ../../include/net-snmp/library/parse.h
-./debug_handler.lo: ../../include/net-snmp/varbind_api.h
-./debug_handler.lo: ../../include/net-snmp/config_api.h
-./debug_handler.lo: ../../include/net-snmp/library/read_config.h
-./debug_handler.lo: ../../include/net-snmp/library/default_store.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp_parse_args.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp_enum.h
-./debug_handler.lo: ../../include/net-snmp/library/vacm.h
-./debug_handler.lo: ../../include/net-snmp/output_api.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp_debug.h
-./debug_handler.lo: ../../include/net-snmp/snmpv3_api.h
-./debug_handler.lo: ../../include/net-snmp/library/snmpv3.h
-./debug_handler.lo: ../../include/net-snmp/library/transform_oids.h
-./debug_handler.lo: ../../include/net-snmp/library/keytools.h
-./debug_handler.lo: ../../include/net-snmp/library/scapi.h
-./debug_handler.lo: ../../include/net-snmp/library/lcd_time.h
-./debug_handler.lo: ../../include/net-snmp/library/snmp_secmod.h
-./debug_handler.lo: ../../include/net-snmp/library/snmpv3-security-includes.h
-./debug_handler.lo: ../../include/net-snmp/library/snmpusm.h
-./debug_handler.lo: ../../include/net-snmp/agent/net-snmp-agent-includes.h
-./debug_handler.lo: ../../include/net-snmp/agent/snmp_agent.h
-./debug_handler.lo: ../../include/net-snmp/agent/snmp_vars.h
-./debug_handler.lo: ../../include/net-snmp/agent/agent_handler.h
-./debug_handler.lo: ../../include/net-snmp/agent/var_struct.h
-./debug_handler.lo: ../../include/net-snmp/agent/agent_registry.h
-./debug_handler.lo: ../../include/net-snmp/agent/ds_agent.h
-./debug_handler.lo: ../../include/net-snmp/agent/agent_read_config.h
-./debug_handler.lo: ../../include/net-snmp/agent/agent_trap.h
-./debug_handler.lo: ../../include/net-snmp/agent/all_helpers.h
-./debug_handler.lo: ../../include/net-snmp/agent/instance.h
-./debug_handler.lo: ../../include/net-snmp/agent/baby_steps.h
-./debug_handler.lo: ../../include/net-snmp/agent/scalar.h
-./debug_handler.lo: ../../include/net-snmp/agent/scalar_group.h
-./debug_handler.lo: ../../include/net-snmp/agent/multiplexer.h
-./debug_handler.lo: ../../include/net-snmp/agent/null.h
-./debug_handler.lo: ../../include/net-snmp/agent/debug_handler.h
-./debug_handler.lo: ../../include/net-snmp/agent/cache_handler.h
-./debug_handler.lo: ../../include/net-snmp/agent/old_api.h
-./debug_handler.lo: ../../include/net-snmp/agent/read_only.h
-./debug_handler.lo: ../../include/net-snmp/agent/row_merge.h
-./debug_handler.lo: ../../include/net-snmp/agent/serialize.h
-./debug_handler.lo: ../../include/net-snmp/agent/bulk_to_next.h
-./debug_handler.lo: ../../include/net-snmp/agent/mode_end_call.h
-./debug_handler.lo: ../../include/net-snmp/agent/table.h
-./debug_handler.lo: ../../include/net-snmp/agent/table_data.h
-./debug_handler.lo: ../../include/net-snmp/agent/table_dataset.h
-./debug_handler.lo: ../../include/net-snmp/agent/table_iterator.h
-./debug_handler.lo: ../../include/net-snmp/agent/table_mfd.h
-./debug_handler.lo: ../../include/net-snmp/agent/table_array.h
-./debug_handler.lo: ../../include/net-snmp/agent/mib_module_config.h
 ./instance.lo: ../../include/net-snmp/net-snmp-config.h
 ./instance.lo: ../../include/net-snmp/system/linux.h
 ./instance.lo: ../../include/net-snmp/system/sysv.h
@@ -490,200 +296,6 @@
 ./instance.lo: ../../include/net-snmp/agent/table_mfd.h
 ./instance.lo: ../../include/net-snmp/agent/table_array.h
 ./instance.lo: ../../include/net-snmp/agent/mib_module_config.h
-./mode_end_call.lo: ../../include/net-snmp/net-snmp-config.h
-./mode_end_call.lo: ../../include/net-snmp/system/linux.h
-./mode_end_call.lo: ../../include/net-snmp/system/sysv.h
-./mode_end_call.lo: ../../include/net-snmp/system/generic.h
-./mode_end_call.lo: ../../include/net-snmp/machine/generic.h
-./mode_end_call.lo: ../../include/net-snmp/net-snmp-includes.h
-./mode_end_call.lo: ../../include/net-snmp/definitions.h
-./mode_end_call.lo: ../../include/net-snmp/types.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp_api.h
-./mode_end_call.lo: ../../include/net-snmp/library/asn1.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp_impl.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp-tc.h
-./mode_end_call.lo: ../../include/net-snmp/utilities.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp_client.h
-./mode_end_call.lo: ../../include/net-snmp/library/getopt.h
-./mode_end_call.lo: ../../include/net-snmp/library/system.h
-./mode_end_call.lo: ../../include/net-snmp/library/tools.h
-./mode_end_call.lo: ../../include/net-snmp/library/int64.h
-./mode_end_call.lo: ../../include/net-snmp/library/mt_support.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp_alarm.h
-./mode_end_call.lo: ../../include/net-snmp/library/callback.h
-./mode_end_call.lo: ../../include/net-snmp/library/data_list.h
-./mode_end_call.lo: ../../include/net-snmp/library/oid_stash.h
-./mode_end_call.lo: ../../include/net-snmp/library/check_varbind.h
-./mode_end_call.lo: ../../include/net-snmp/library/container.h
-./mode_end_call.lo: ../../include/net-snmp/library/factory.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp_logging.h
-./mode_end_call.lo: ../../include/net-snmp/library/container_binary_array.h
-./mode_end_call.lo: ../../include/net-snmp/library/container_list_ssll.h
-./mode_end_call.lo: ../../include/net-snmp/library/container_iterator.h
-./mode_end_call.lo: ../../include/net-snmp/library/container.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp_assert.h
-./mode_end_call.lo: ../../include/net-snmp/version.h
-./mode_end_call.lo: ../../include/net-snmp/session_api.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp_transport.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmpCallbackDomain.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmpUnixDomain.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmpUDPDomain.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmpTCPDomain.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmpUDPIPv6Domain.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmpTCPIPv6Domain.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmpIPXDomain.h
-./mode_end_call.lo: ../../include/net-snmp/library/ucd_compat.h
-./mode_end_call.lo: ../../include/net-snmp/pdu_api.h
-./mode_end_call.lo: ../../include/net-snmp/mib_api.h
-./mode_end_call.lo: ../../include/net-snmp/library/mib.h
-./mode_end_call.lo: ../../include/net-snmp/library/parse.h
-./mode_end_call.lo: ../../include/net-snmp/varbind_api.h
-./mode_end_call.lo: ../../include/net-snmp/config_api.h
-./mode_end_call.lo: ../../include/net-snmp/library/read_config.h
-./mode_end_call.lo: ../../include/net-snmp/library/default_store.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp_parse_args.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp_enum.h
-./mode_end_call.lo: ../../include/net-snmp/library/vacm.h
-./mode_end_call.lo: ../../include/net-snmp/output_api.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp_debug.h
-./mode_end_call.lo: ../../include/net-snmp/snmpv3_api.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmpv3.h
-./mode_end_call.lo: ../../include/net-snmp/library/transform_oids.h
-./mode_end_call.lo: ../../include/net-snmp/library/keytools.h
-./mode_end_call.lo: ../../include/net-snmp/library/scapi.h
-./mode_end_call.lo: ../../include/net-snmp/library/lcd_time.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmp_secmod.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmpv3-security-includes.h
-./mode_end_call.lo: ../../include/net-snmp/library/snmpusm.h
-./mode_end_call.lo: ../../include/net-snmp/agent/net-snmp-agent-includes.h
-./mode_end_call.lo: ../../include/net-snmp/agent/snmp_agent.h
-./mode_end_call.lo: ../../include/net-snmp/agent/snmp_vars.h
-./mode_end_call.lo: ../../include/net-snmp/agent/agent_handler.h
-./mode_end_call.lo: ../../include/net-snmp/agent/var_struct.h
-./mode_end_call.lo: ../../include/net-snmp/agent/agent_registry.h
-./mode_end_call.lo: ../../include/net-snmp/agent/ds_agent.h
-./mode_end_call.lo: ../../include/net-snmp/agent/agent_read_config.h
-./mode_end_call.lo: ../../include/net-snmp/agent/agent_trap.h
-./mode_end_call.lo: ../../include/net-snmp/agent/all_helpers.h
-./mode_end_call.lo: ../../include/net-snmp/agent/instance.h
-./mode_end_call.lo: ../../include/net-snmp/agent/baby_steps.h
-./mode_end_call.lo: ../../include/net-snmp/agent/scalar.h
-./mode_end_call.lo: ../../include/net-snmp/agent/scalar_group.h
-./mode_end_call.lo: ../../include/net-snmp/agent/multiplexer.h
-./mode_end_call.lo: ../../include/net-snmp/agent/null.h
-./mode_end_call.lo: ../../include/net-snmp/agent/debug_handler.h
-./mode_end_call.lo: ../../include/net-snmp/agent/cache_handler.h
-./mode_end_call.lo: ../../include/net-snmp/agent/old_api.h
-./mode_end_call.lo: ../../include/net-snmp/agent/read_only.h
-./mode_end_call.lo: ../../include/net-snmp/agent/row_merge.h
-./mode_end_call.lo: ../../include/net-snmp/agent/serialize.h
-./mode_end_call.lo: ../../include/net-snmp/agent/bulk_to_next.h
-./mode_end_call.lo: ../../include/net-snmp/agent/mode_end_call.h
-./mode_end_call.lo: ../../include/net-snmp/agent/table.h
-./mode_end_call.lo: ../../include/net-snmp/agent/table_data.h
-./mode_end_call.lo: ../../include/net-snmp/agent/table_dataset.h
-./mode_end_call.lo: ../../include/net-snmp/agent/table_iterator.h
-./mode_end_call.lo: ../../include/net-snmp/agent/table_mfd.h
-./mode_end_call.lo: ../../include/net-snmp/agent/table_array.h
-./mode_end_call.lo: ../../include/net-snmp/agent/mib_module_config.h
-./multiplexer.lo: ../../include/net-snmp/net-snmp-config.h
-./multiplexer.lo: ../../include/net-snmp/system/linux.h
-./multiplexer.lo: ../../include/net-snmp/system/sysv.h
-./multiplexer.lo: ../../include/net-snmp/system/generic.h
-./multiplexer.lo: ../../include/net-snmp/machine/generic.h
-./multiplexer.lo: ../../include/net-snmp/net-snmp-includes.h
-./multiplexer.lo: ../../include/net-snmp/definitions.h
-./multiplexer.lo: ../../include/net-snmp/types.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp_api.h
-./multiplexer.lo: ../../include/net-snmp/library/asn1.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp_impl.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp-tc.h
-./multiplexer.lo: ../../include/net-snmp/utilities.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp_client.h
-./multiplexer.lo: ../../include/net-snmp/library/getopt.h
-./multiplexer.lo: ../../include/net-snmp/library/system.h
-./multiplexer.lo: ../../include/net-snmp/library/tools.h
-./multiplexer.lo: ../../include/net-snmp/library/int64.h
-./multiplexer.lo: ../../include/net-snmp/library/mt_support.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp_alarm.h
-./multiplexer.lo: ../../include/net-snmp/library/callback.h
-./multiplexer.lo: ../../include/net-snmp/library/data_list.h
-./multiplexer.lo: ../../include/net-snmp/library/oid_stash.h
-./multiplexer.lo: ../../include/net-snmp/library/check_varbind.h
-./multiplexer.lo: ../../include/net-snmp/library/container.h
-./multiplexer.lo: ../../include/net-snmp/library/factory.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp_logging.h
-./multiplexer.lo: ../../include/net-snmp/library/container_binary_array.h
-./multiplexer.lo: ../../include/net-snmp/library/container_list_ssll.h
-./multiplexer.lo: ../../include/net-snmp/library/container_iterator.h
-./multiplexer.lo: ../../include/net-snmp/library/container.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp_assert.h
-./multiplexer.lo: ../../include/net-snmp/version.h
-./multiplexer.lo: ../../include/net-snmp/session_api.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp_transport.h
-./multiplexer.lo: ../../include/net-snmp/library/snmpCallbackDomain.h
-./multiplexer.lo: ../../include/net-snmp/library/snmpUnixDomain.h
-./multiplexer.lo: ../../include/net-snmp/library/snmpUDPDomain.h
-./multiplexer.lo: ../../include/net-snmp/library/snmpTCPDomain.h
-./multiplexer.lo: ../../include/net-snmp/library/snmpUDPIPv6Domain.h
-./multiplexer.lo: ../../include/net-snmp/library/snmpTCPIPv6Domain.h
-./multiplexer.lo: ../../include/net-snmp/library/snmpIPXDomain.h
-./multiplexer.lo: ../../include/net-snmp/library/ucd_compat.h
-./multiplexer.lo: ../../include/net-snmp/pdu_api.h
-./multiplexer.lo: ../../include/net-snmp/mib_api.h
-./multiplexer.lo: ../../include/net-snmp/library/mib.h
-./multiplexer.lo: ../../include/net-snmp/library/parse.h
-./multiplexer.lo: ../../include/net-snmp/varbind_api.h
-./multiplexer.lo: ../../include/net-snmp/config_api.h
-./multiplexer.lo: ../../include/net-snmp/library/read_config.h
-./multiplexer.lo: ../../include/net-snmp/library/default_store.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp_parse_args.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp_enum.h
-./multiplexer.lo: ../../include/net-snmp/library/vacm.h
-./multiplexer.lo: ../../include/net-snmp/output_api.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp_debug.h
-./multiplexer.lo: ../../include/net-snmp/snmpv3_api.h
-./multiplexer.lo: ../../include/net-snmp/library/snmpv3.h
-./multiplexer.lo: ../../include/net-snmp/library/transform_oids.h
-./multiplexer.lo: ../../include/net-snmp/library/keytools.h
-./multiplexer.lo: ../../include/net-snmp/library/scapi.h
-./multiplexer.lo: ../../include/net-snmp/library/lcd_time.h
-./multiplexer.lo: ../../include/net-snmp/library/snmp_secmod.h
-./multiplexer.lo: ../../include/net-snmp/library/snmpv3-security-includes.h
-./multiplexer.lo: ../../include/net-snmp/library/snmpusm.h
-./multiplexer.lo: ../../include/net-snmp/agent/net-snmp-agent-includes.h
-./multiplexer.lo: ../../include/net-snmp/agent/snmp_agent.h
-./multiplexer.lo: ../../include/net-snmp/agent/snmp_vars.h
-./multiplexer.lo: ../../include/net-snmp/agent/agent_handler.h
-./multiplexer.lo: ../../include/net-snmp/agent/var_struct.h
-./multiplexer.lo: ../../include/net-snmp/agent/agent_registry.h
-./multiplexer.lo: ../../include/net-snmp/agent/ds_agent.h
-./multiplexer.lo: ../../include/net-snmp/agent/agent_read_config.h
-./multiplexer.lo: ../../include/net-snmp/agent/agent_trap.h
-./multiplexer.lo: ../../include/net-snmp/agent/all_helpers.h
-./multiplexer.lo: ../../include/net-snmp/agent/instance.h
-./multiplexer.lo: ../../include/net-snmp/agent/baby_steps.h
-./multiplexer.lo: ../../include/net-snmp/agent/scalar.h
-./multiplexer.lo: ../../include/net-snmp/agent/scalar_group.h
-./multiplexer.lo: ../../include/net-snmp/agent/multiplexer.h
-./multiplexer.lo: ../../include/net-snmp/agent/null.h
-./multiplexer.lo: ../../include/net-snmp/agent/debug_handler.h
-./multiplexer.lo: ../../include/net-snmp/agent/cache_handler.h
-./multiplexer.lo: ../../include/net-snmp/agent/old_api.h
-./multiplexer.lo: ../../include/net-snmp/agent/read_only.h
-./multiplexer.lo: ../../include/net-snmp/agent/row_merge.h
-./multiplexer.lo: ../../include/net-snmp/agent/serialize.h
-./multiplexer.lo: ../../include/net-snmp/agent/bulk_to_next.h
-./multiplexer.lo: ../../include/net-snmp/agent/mode_end_call.h
-./multiplexer.lo: ../../include/net-snmp/agent/table.h
-./multiplexer.lo: ../../include/net-snmp/agent/table_data.h
-./multiplexer.lo: ../../include/net-snmp/agent/table_dataset.h
-./multiplexer.lo: ../../include/net-snmp/agent/table_iterator.h
-./multiplexer.lo: ../../include/net-snmp/agent/table_mfd.h
-./multiplexer.lo: ../../include/net-snmp/agent/table_array.h
-./multiplexer.lo: ../../include/net-snmp/agent/mib_module_config.h
 ./null.lo: ../../include/net-snmp/net-snmp-config.h
 ./null.lo: ../../include/net-snmp/system/linux.h
 ./null.lo: ../../include/net-snmp/system/sysv.h
@@ -975,103 +587,6 @@
 ./read_only.lo: ../../include/net-snmp/agent/table_mfd.h
 ./read_only.lo: ../../include/net-snmp/agent/table_array.h
 ./read_only.lo: ../../include/net-snmp/agent/mib_module_config.h
-./row_merge.lo: ../../include/net-snmp/net-snmp-config.h
-./row_merge.lo: ../../include/net-snmp/system/linux.h
-./row_merge.lo: ../../include/net-snmp/system/sysv.h
-./row_merge.lo: ../../include/net-snmp/system/generic.h
-./row_merge.lo: ../../include/net-snmp/machine/generic.h
-./row_merge.lo: ../../include/net-snmp/net-snmp-includes.h
-./row_merge.lo: ../../include/net-snmp/definitions.h
-./row_merge.lo: ../../include/net-snmp/types.h
-./row_merge.lo: ../../include/net-snmp/library/snmp_api.h
-./row_merge.lo: ../../include/net-snmp/library/asn1.h
-./row_merge.lo: ../../include/net-snmp/library/snmp_impl.h
-./row_merge.lo: ../../include/net-snmp/library/snmp.h
-./row_merge.lo: ../../include/net-snmp/library/snmp-tc.h
-./row_merge.lo: ../../include/net-snmp/utilities.h
-./row_merge.lo: ../../include/net-snmp/library/snmp_client.h
-./row_merge.lo: ../../include/net-snmp/library/getopt.h
-./row_merge.lo: ../../include/net-snmp/library/system.h
-./row_merge.lo: ../../include/net-snmp/library/tools.h
-./row_merge.lo: ../../include/net-snmp/library/int64.h
-./row_merge.lo: ../../include/net-snmp/library/mt_support.h
-./row_merge.lo: ../../include/net-snmp/library/snmp_alarm.h
-./row_merge.lo: ../../include/net-snmp/library/callback.h
-./row_merge.lo: ../../include/net-snmp/library/data_list.h
-./row_merge.lo: ../../include/net-snmp/library/oid_stash.h
-./row_merge.lo: ../../include/net-snmp/library/check_varbind.h
-./row_merge.lo: ../../include/net-snmp/library/container.h
-./row_merge.lo: ../../include/net-snmp/library/factory.h
-./row_merge.lo: ../../include/net-snmp/library/snmp_logging.h
-./row_merge.lo: ../../include/net-snmp/library/container_binary_array.h
-./row_merge.lo: ../../include/net-snmp/library/container_list_ssll.h
-./row_merge.lo: ../../include/net-snmp/library/container_iterator.h
-./row_merge.lo: ../../include/net-snmp/library/container.h
-./row_merge.lo: ../../include/net-snmp/library/snmp_assert.h
-./row_merge.lo: ../../include/net-snmp/version.h
-./row_merge.lo: ../../include/net-snmp/session_api.h
-./row_merge.lo: ../../include/net-snmp/library/snmp_transport.h
-./row_merge.lo: ../../include/net-snmp/library/snmpCallbackDomain.h
-./row_merge.lo: ../../include/net-snmp/library/snmpUnixDomain.h
-./row_merge.lo: ../../include/net-snmp/library/snmpUDPDomain.h
-./row_merge.lo: ../../include/net-snmp/library/snmpTCPDomain.h
-./row_merge.lo: ../../include/net-snmp/library/snmpUDPIPv6Domain.h
-./row_merge.lo: ../../include/net-snmp/library/snmpTCPIPv6Domain.h
-./row_merge.lo: ../../include/net-snmp/library/snmpIPXDomain.h
-./row_merge.lo: ../../include/net-snmp/library/ucd_compat.h
-./row_merge.lo: ../../include/net-snmp/pdu_api.h
-./row_merge.lo: ../../include/net-snmp/mib_api.h
-./row_merge.lo: ../../include/net-snmp/library/mib.h
-./row_merge.lo: ../../include/net-snmp/library/parse.h
-./row_merge.lo: ../../include/net-snmp/varbind_api.h
-./row_merge.lo: ../../include/net-snmp/config_api.h
-./row_merge.lo: ../../include/net-snmp/library/read_config.h
-./row_merge.lo: ../../include/net-snmp/library/default_store.h
-./row_merge.lo: ../../include/net-snmp/library/snmp_parse_args.h
-./row_merge.lo: ../../include/net-snmp/library/snmp_enum.h
-./row_merge.lo: ../../include/net-snmp/library/vacm.h
-./row_merge.lo: ../../include/net-snmp/output_api.h
-./row_merge.lo: ../../include/net-snmp/library/snmp_debug.h
-./row_merge.lo: ../../include/net-snmp/snmpv3_api.h
-./row_merge.lo: ../../include/net-snmp/library/snmpv3.h
-./row_merge.lo: ../../include/net-snmp/library/transform_oids.h
-./row_merge.lo: ../../include/net-snmp/library/keytools.h
-./row_merge.lo: ../../include/net-snmp/library/scapi.h
-./row_merge.lo: ../../include/net-snmp/library/lcd_time.h
-./row_merge.lo: ../../include/net-snmp/library/snmp_secmod.h
-./row_merge.lo: ../../include/net-snmp/library/snmpv3-security-includes.h
-./row_merge.lo: ../../include/net-snmp/library/snmpusm.h
-./row_merge.lo: ../../include/net-snmp/agent/net-snmp-agent-includes.h
-./row_merge.lo: ../../include/net-snmp/agent/snmp_agent.h
-./row_merge.lo: ../../include/net-snmp/agent/snmp_vars.h
-./row_merge.lo: ../../include/net-snmp/agent/agent_handler.h
-./row_merge.lo: ../../include/net-snmp/agent/var_struct.h
-./row_merge.lo: ../../include/net-snmp/agent/agent_registry.h
-./row_merge.lo: ../../include/net-snmp/agent/ds_agent.h
-./row_merge.lo: ../../include/net-snmp/agent/agent_read_config.h
-./row_merge.lo: ../../include/net-snmp/agent/agent_trap.h
-./row_merge.lo: ../../include/net-snmp/agent/all_helpers.h
-./row_merge.lo: ../../include/net-snmp/agent/instance.h
-./row_merge.lo: ../../include/net-snmp/agent/baby_steps.h
-./row_merge.lo: ../../include/net-snmp/agent/scalar.h
-./row_merge.lo: ../../include/net-snmp/agent/scalar_group.h
-./row_merge.lo: ../../include/net-snmp/agent/multiplexer.h
-./row_merge.lo: ../../include/net-snmp/agent/null.h
-./row_merge.lo: ../../include/net-snmp/agent/debug_handler.h
-./row_merge.lo: ../../include/net-snmp/agent/cache_handler.h
-./row_merge.lo: ../../include/net-snmp/agent/old_api.h
-./row_merge.lo: ../../include/net-snmp/agent/read_only.h
-./row_merge.lo: ../../include/net-snmp/agent/row_merge.h
-./row_merge.lo: ../../include/net-snmp/agent/serialize.h
-./row_merge.lo: ../../include/net-snmp/agent/bulk_to_next.h
-./row_merge.lo: ../../include/net-snmp/agent/mode_end_call.h
-./row_merge.lo: ../../include/net-snmp/agent/table.h
-./row_merge.lo: ../../include/net-snmp/agent/table_data.h
-./row_merge.lo: ../../include/net-snmp/agent/table_dataset.h
-./row_merge.lo: ../../include/net-snmp/agent/table_iterator.h
-./row_merge.lo: ../../include/net-snmp/agent/table_mfd.h
-./row_merge.lo: ../../include/net-snmp/agent/table_array.h
-./row_merge.lo: ../../include/net-snmp/agent/mib_module_config.h
 ./scalar.lo: ../../include/net-snmp/net-snmp-config.h
 ./scalar.lo: ../../include/net-snmp/system/linux.h
 ./scalar.lo: ../../include/net-snmp/system/sysv.h
@@ -1946,198 +1461,3 @@
 ./table_iterator.lo: ../../include/net-snmp/agent/table_array.h
 ./table_iterator.lo: ../../include/net-snmp/agent/mib_module_config.h
 ./table_iterator.lo: ../../include/net-snmp/agent/stash_cache.h
-./table_mfd.lo: ../../include/net-snmp/net-snmp-config.h
-./table_mfd.lo: ../../include/net-snmp/system/linux.h
-./table_mfd.lo: ../../include/net-snmp/system/sysv.h
-./table_mfd.lo: ../../include/net-snmp/system/generic.h
-./table_mfd.lo: ../../include/net-snmp/machine/generic.h
-./table_mfd.lo: ../../include/net-snmp/net-snmp-includes.h
-./table_mfd.lo: ../../include/net-snmp/definitions.h
-./table_mfd.lo: ../../include/net-snmp/types.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp_api.h
-./table_mfd.lo: ../../include/net-snmp/library/asn1.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp_impl.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp-tc.h
-./table_mfd.lo: ../../include/net-snmp/utilities.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp_client.h
-./table_mfd.lo: ../../include/net-snmp/library/getopt.h
-./table_mfd.lo: ../../include/net-snmp/library/system.h
-./table_mfd.lo: ../../include/net-snmp/library/tools.h
-./table_mfd.lo: ../../include/net-snmp/library/int64.h
-./table_mfd.lo: ../../include/net-snmp/library/mt_support.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp_alarm.h
-./table_mfd.lo: ../../include/net-snmp/library/callback.h
-./table_mfd.lo: ../../include/net-snmp/library/data_list.h
-./table_mfd.lo: ../../include/net-snmp/library/oid_stash.h
-./table_mfd.lo: ../../include/net-snmp/library/check_varbind.h
-./table_mfd.lo: ../../include/net-snmp/library/container.h
-./table_mfd.lo: ../../include/net-snmp/library/factory.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp_logging.h
-./table_mfd.lo: ../../include/net-snmp/library/container_binary_array.h
-./table_mfd.lo: ../../include/net-snmp/library/container_list_ssll.h
-./table_mfd.lo: ../../include/net-snmp/library/container_iterator.h
-./table_mfd.lo: ../../include/net-snmp/library/container.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp_assert.h
-./table_mfd.lo: ../../include/net-snmp/version.h
-./table_mfd.lo: ../../include/net-snmp/session_api.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp_transport.h
-./table_mfd.lo: ../../include/net-snmp/library/snmpCallbackDomain.h
-./table_mfd.lo: ../../include/net-snmp/library/snmpUnixDomain.h
-./table_mfd.lo: ../../include/net-snmp/library/snmpUDPDomain.h
-./table_mfd.lo: ../../include/net-snmp/library/snmpTCPDomain.h
-./table_mfd.lo: ../../include/net-snmp/library/snmpUDPIPv6Domain.h
-./table_mfd.lo: ../../include/net-snmp/library/snmpTCPIPv6Domain.h
-./table_mfd.lo: ../../include/net-snmp/library/snmpIPXDomain.h
-./table_mfd.lo: ../../include/net-snmp/library/ucd_compat.h
-./table_mfd.lo: ../../include/net-snmp/pdu_api.h
-./table_mfd.lo: ../../include/net-snmp/mib_api.h
-./table_mfd.lo: ../../include/net-snmp/library/mib.h
-./table_mfd.lo: ../../include/net-snmp/library/parse.h
-./table_mfd.lo: ../../include/net-snmp/varbind_api.h
-./table_mfd.lo: ../../include/net-snmp/config_api.h
-./table_mfd.lo: ../../include/net-snmp/library/read_config.h
-./table_mfd.lo: ../../include/net-snmp/library/default_store.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp_parse_args.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp_enum.h
-./table_mfd.lo: ../../include/net-snmp/library/vacm.h
-./table_mfd.lo: ../../include/net-snmp/output_api.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp_debug.h
-./table_mfd.lo: ../../include/net-snmp/snmpv3_api.h
-./table_mfd.lo: ../../include/net-snmp/library/snmpv3.h
-./table_mfd.lo: ../../include/net-snmp/library/transform_oids.h
-./table_mfd.lo: ../../include/net-snmp/library/keytools.h
-./table_mfd.lo: ../../include/net-snmp/library/scapi.h
-./table_mfd.lo: ../../include/net-snmp/library/lcd_time.h
-./table_mfd.lo: ../../include/net-snmp/library/snmp_secmod.h
-./table_mfd.lo: ../../include/net-snmp/library/snmpv3-security-includes.h
-./table_mfd.lo: ../../include/net-snmp/library/snmpusm.h
-./table_mfd.lo: ../../include/net-snmp/agent/net-snmp-agent-includes.h
-./table_mfd.lo: ../../include/net-snmp/agent/snmp_agent.h
-./table_mfd.lo: ../../include/net-snmp/agent/snmp_vars.h
-./table_mfd.lo: ../../include/net-snmp/agent/agent_handler.h
-./table_mfd.lo: ../../include/net-snmp/agent/var_struct.h
-./table_mfd.lo: ../../include/net-snmp/agent/agent_registry.h
-./table_mfd.lo: ../../include/net-snmp/agent/ds_agent.h
-./table_mfd.lo: ../../include/net-snmp/agent/agent_read_config.h
-./table_mfd.lo: ../../include/net-snmp/agent/agent_trap.h
-./table_mfd.lo: ../../include/net-snmp/agent/all_helpers.h
-./table_mfd.lo: ../../include/net-snmp/agent/instance.h
-./table_mfd.lo: ../../include/net-snmp/agent/baby_steps.h
-./table_mfd.lo: ../../include/net-snmp/agent/scalar.h
-./table_mfd.lo: ../../include/net-snmp/agent/scalar_group.h
-./table_mfd.lo: ../../include/net-snmp/agent/multiplexer.h
-./table_mfd.lo: ../../include/net-snmp/agent/null.h
-./table_mfd.lo: ../../include/net-snmp/agent/debug_handler.h
-./table_mfd.lo: ../../include/net-snmp/agent/cache_handler.h
-./table_mfd.lo: ../../include/net-snmp/agent/old_api.h
-./table_mfd.lo: ../../include/net-snmp/agent/read_only.h
-./table_mfd.lo: ../../include/net-snmp/agent/row_merge.h
-./table_mfd.lo: ../../include/net-snmp/agent/serialize.h
-./table_mfd.lo: ../../include/net-snmp/agent/bulk_to_next.h
-./table_mfd.lo: ../../include/net-snmp/agent/mode_end_call.h
-./table_mfd.lo: ../../include/net-snmp/agent/table.h
-./table_mfd.lo: ../../include/net-snmp/agent/table_data.h
-./table_mfd.lo: ../../include/net-snmp/agent/table_dataset.h
-./table_mfd.lo: ../../include/net-snmp/agent/table_iterator.h
-./table_mfd.lo: ../../include/net-snmp/agent/table_mfd.h
-./table_mfd.lo: ../../include/net-snmp/agent/table_array.h
-./table_mfd.lo: ../../include/net-snmp/agent/mib_module_config.h
-./watcher.lo: ../../include/net-snmp/net-snmp-config.h
-./watcher.lo: ../../include/net-snmp/system/linux.h
-./watcher.lo: ../../include/net-snmp/system/sysv.h
-./watcher.lo: ../../include/net-snmp/system/generic.h
-./watcher.lo: ../../include/net-snmp/machine/generic.h 
-./watcher.lo: ../../include/net-snmp/net-snmp-includes.h 
-./watcher.lo: ../../include/net-snmp/definitions.h
-./watcher.lo: ../../include/net-snmp/types.h
-./watcher.lo: ../../include/net-snmp/library/snmp_api.h
-./watcher.lo: ../../include/net-snmp/library/asn1.h
-./watcher.lo: ../../include/net-snmp/library/snmp_impl.h
-./watcher.lo: ../../include/net-snmp/library/snmp.h
-./watcher.lo: ../../include/net-snmp/library/snmp-tc.h
-./watcher.lo: ../../include/net-snmp/utilities.h
-./watcher.lo: ../../include/net-snmp/library/snmp_client.h
-./watcher.lo: ../../include/net-snmp/library/getopt.h
-./watcher.lo: ../../include/net-snmp/library/system.h
-./watcher.lo: ../../include/net-snmp/library/tools.h
-./watcher.lo: ../../include/net-snmp/library/int64.h
-./watcher.lo: ../../include/net-snmp/library/mt_support.h
-./watcher.lo: ../../include/net-snmp/library/snmp_alarm.h
-./watcher.lo: ../../include/net-snmp/library/callback.h
-./watcher.lo: ../../include/net-snmp/library/data_list.h
-./watcher.lo: ../../include/net-snmp/library/oid_stash.h
-./watcher.lo: ../../include/net-snmp/library/check_varbind.h
-./watcher.lo: ../../include/net-snmp/library/container.h
-./watcher.lo: ../../include/net-snmp/library/factory.h
-./watcher.lo: ../../include/net-snmp/library/snmp_logging.h
-./watcher.lo: ../../include/net-snmp/library/container_binary_array.h
-./watcher.lo: ../../include/net-snmp/library/container_list_ssll.h
-./watcher.lo: ../../include/net-snmp/library/container_iterator.h
-./watcher.lo: ../../include/net-snmp/library/container.h
-./watcher.lo: ../../include/net-snmp/library/snmp_assert.h
-./watcher.lo: ../../include/net-snmp/version.h
-./watcher.lo: ../../include/net-snmp/session_api.h
-./watcher.lo: ../../include/net-snmp/library/snmp_transport.h
-./watcher.lo: ../../include/net-snmp/library/snmpCallbackDomain.h
-./watcher.lo: ../../include/net-snmp/library/snmpUnixDomain.h
-./watcher.lo: ../../include/net-snmp/library/snmpUDPDomain.h
-./watcher.lo: ../../include/net-snmp/library/snmpTCPDomain.h
-./watcher.lo: ../../include/net-snmp/library/snmpUDPIPv6Domain.h
-./watcher.lo: ../../include/net-snmp/library/snmpTCPIPv6Domain.h
-./watcher.lo: ../../include/net-snmp/library/snmpIPXDomain.h
-./watcher.lo: ../../include/net-snmp/library/ucd_compat.h
-./watcher.lo: ../../include/net-snmp/pdu_api.h
-./watcher.lo: ../../include/net-snmp/mib_api.h
-./watcher.lo: ../../include/net-snmp/library/mib.h
-./watcher.lo: ../../include/net-snmp/library/parse.h
-./watcher.lo: ../../include/net-snmp/varbind_api.h
-./watcher.lo: ../../include/net-snmp/config_api.h
-./watcher.lo: ../../include/net-snmp/library/read_config.h
-./watcher.lo: ../../include/net-snmp/library/default_store.h
-./watcher.lo: ../../include/net-snmp/library/snmp_parse_args.h
-./watcher.lo: ../../include/net-snmp/library/snmp_enum.h
-./watcher.lo: ../../include/net-snmp/library/vacm.h
-./watcher.lo: ../../include/net-snmp/output_api.h
-./watcher.lo: ../../include/net-snmp/library/snmp_debug.h
-./watcher.lo: ../../include/net-snmp/snmpv3_api.h
-./watcher.lo: ../../include/net-snmp/library/snmpv3.h
-./watcher.lo: ../../include/net-snmp/library/transform_oids.h
-./watcher.lo: ../../include/net-snmp/library/keytools.h
-./watcher.lo: ../../include/net-snmp/library/scapi.h
-./watcher.lo: ../../include/net-snmp/library/lcd_time.h
-./watcher.lo: ../../include/net-snmp/library/snmp_secmod.h
-./watcher.lo: ../../include/net-snmp/library/snmpv3-security-includes.h
-./watcher.lo: ../../include/net-snmp/library/snmpusm.h
-./watcher.lo: ../../include/net-snmp/agent/net-snmp-agent-includes.h
-./watcher.lo: ../../include/net-snmp/agent/snmp_agent.h
-./watcher.lo: ../../include/net-snmp/agent/snmp_vars.h
-./watcher.lo: ../../include/net-snmp/agent/agent_handler.h
-./watcher.lo: ../../include/net-snmp/agent/var_struct.h
-./watcher.lo: ../../include/net-snmp/agent/agent_registry.h
-./watcher.lo: ../../include/net-snmp/agent/ds_agent.h
-./watcher.lo: ../../include/net-snmp/agent/agent_read_config.h
-./watcher.lo: ../../include/net-snmp/agent/agent_trap.h
-./watcher.lo: ../../include/net-snmp/agent/all_helpers.h
-./watcher.lo: ../../include/net-snmp/agent/instance.h
-./watcher.lo: ../../include/net-snmp/agent/baby_steps.h
-./watcher.lo: ../../include/net-snmp/agent/scalar.h
-./watcher.lo: ../../include/net-snmp/agent/scalar_group.h
-./watcher.lo: ../../include/net-snmp/agent/multiplexer.h
-./watcher.lo: ../../include/net-snmp/agent/null.h
-./watcher.lo: ../../include/net-snmp/agent/debug_handler.h
-./watcher.lo: ../../include/net-snmp/agent/cache_handler.h
-./watcher.lo: ../../include/net-snmp/agent/old_api.h
-./watcher.lo: ../../include/net-snmp/agent/read_only.h
-./watcher.lo: ../../include/net-snmp/agent/row_merge.h
-./watcher.lo: ../../include/net-snmp/agent/serialize.h
-./watcher.lo: ../../include/net-snmp/agent/bulk_to_next.h
-./watcher.lo: ../../include/net-snmp/agent/mode_end_call.h
-./watcher.lo: ../../include/net-snmp/agent/table.h
-./watcher.lo: ../../include/net-snmp/agent/table_data.h
-./watcher.lo: ../../include/net-snmp/agent/table_dataset.h
-./watcher.lo: ../../include/net-snmp/agent/table_iterator.h
-./watcher.lo: ../../include/net-snmp/agent/table_mfd.h
-./watcher.lo: ../../include/net-snmp/agent/table_array.h
-./watcher.lo: ../../include/net-snmp/agent/mib_module_config.h
-./watcher.lo: ../../include/net-snmp/agent/watcher.h
diff -Naur net-snmp-5.1/agent/helpers/all_helpers.c open_snmp/agent/helpers/all_helpers.c
--- net-snmp-5.1/agent/helpers/all_helpers.c	2003-08-14 13:43:22.000000000 +0530
+++ open_snmp/agent/helpers/all_helpers.c	2009-12-16 12:59:05.000000000 +0530
@@ -21,7 +21,10 @@
 
 #else
 
+#if !defined(HAVE_MINIMAL_HELPERS)
+#warning CODE GETTING COMPILED
 void  netsnmp_init_debug_helper(void);
+#endif
 void  netsnmp_init_serialize(void);
 void  netsnmp_init_read_only_helper(void);
 void  netsnmp_init_bulk_to_next_helper(void);
@@ -33,7 +36,9 @@
 void
 netsnmp_init_helpers(void)
 {
+#if !defined(HAVE_MINIMAL_HELPERS)
     netsnmp_init_debug_helper();
+#endif
     netsnmp_init_serialize();
     netsnmp_init_read_only_helper();
     netsnmp_init_bulk_to_next_helper();
diff -Naur net-snmp-5.1/agent/helpers/baby_steps.c open_snmp/agent/helpers/baby_steps.c
--- net-snmp-5.1/agent/helpers/baby_steps.c	2003-10-14 21:50:31.000000000 +0530
+++ open_snmp/agent/helpers/baby_steps.c	2009-12-16 12:59:05.000000000 +0530
@@ -2,6 +2,7 @@
  * baby_steps.c
  * $Id: baby_steps.c,v 1.2 2003/10/14 16:20:31 rstory Exp $
  */
+#if !defined(HAVE_MINIMAL_HELPERS)
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
@@ -201,3 +202,4 @@
     netsnmp_register_handler_by_name("baby_steps",
                                      netsnmp_get_baby_steps_handler(BABY_STEP_ALL));
 }
+#endif 
diff -Naur net-snmp-5.1/agent/helpers/cache_handler.c open_snmp/agent/helpers/cache_handler.c
--- net-snmp-5.1/agent/helpers/cache_handler.c	2003-08-19 14:23:56.000000000 +0530
+++ open_snmp/agent/helpers/cache_handler.c	2009-12-16 12:59:05.000000000 +0530
@@ -1,3 +1,4 @@
+#ifndef HAVE_MINIMAL_HELPERS
 #include <net-snmp/net-snmp-config.h>
 
 #if HAVE_STRING_H
@@ -238,3 +239,5 @@
                             0, release_cached_resources, NULL);
     }
 }
+
+#endif /* HAVE_MINIMAL_HELPERS */
diff -Naur net-snmp-5.1/agent/helpers/debug_handler.c open_snmp/agent/helpers/debug_handler.c
--- net-snmp-5.1/agent/helpers/debug_handler.c	2003-10-28 23:46:22.000000000 +0530
+++ open_snmp/agent/helpers/debug_handler.c	2009-12-16 12:59:06.000000000 +0530
@@ -8,6 +8,7 @@
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
+#if !defined(HAVE_MINIMAL_HELPERS)
 #include <net-snmp/net-snmp-config.h>
 
 #if HAVE_STRING_H
@@ -159,3 +160,4 @@
 {
     netsnmp_register_handler_by_name("debug", netsnmp_get_debug_handler());
 }
+#endif
diff -Naur net-snmp-5.1/agent/helpers/mode_end_call.c open_snmp/agent/helpers/mode_end_call.c
--- net-snmp-5.1/agent/helpers/mode_end_call.c	2003-08-14 13:43:22.000000000 +0530
+++ open_snmp/agent/helpers/mode_end_call.c	2009-12-16 12:59:06.000000000 +0530
@@ -1,3 +1,4 @@
+#if !defined(HAVE_MINIMAL_HELPERS)
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
@@ -106,3 +107,4 @@
     
     return ret2;
 }
+#endif
diff -Naur net-snmp-5.1/agent/helpers/multiplexer.c open_snmp/agent/helpers/multiplexer.c
--- net-snmp-5.1/agent/helpers/multiplexer.c	2003-08-14 13:43:22.000000000 +0530
+++ open_snmp/agent/helpers/multiplexer.c	2009-12-16 12:59:06.000000000 +0530
@@ -1,3 +1,4 @@
+#if !defined(HAVE_MINIMAL_HELPERS)
 #include <net-snmp/net-snmp-config.h>
 
 #include <sys/types.h>
@@ -126,3 +127,4 @@
     }
     return netsnmp_call_handler(handler, reginfo, reqinfo, requests);
 }
+#endif
diff -Naur net-snmp-5.1/agent/helpers/row_merge.c open_snmp/agent/helpers/row_merge.c
--- net-snmp-5.1/agent/helpers/row_merge.c	2003-08-18 03:32:52.000000000 +0530
+++ open_snmp/agent/helpers/row_merge.c	2009-12-16 12:59:07.000000000 +0530
@@ -1,3 +1,4 @@
+#if !defined(HAVE_MINIMAL_HELPERS)
 #include <net-snmp/net-snmp-config.h>
 
 #if HAVE_STRING_H
@@ -190,3 +191,4 @@
     netsnmp_register_handler_by_name("row_merge",
                                      netsnmp_get_row_merge_handler(-1));
 }
+#endif
diff -Naur net-snmp-5.1/agent/helpers/table_mfd.c open_snmp/agent/helpers/table_mfd.c
--- net-snmp-5.1/agent/helpers/table_mfd.c	2003-10-14 22:15:06.000000000 +0530
+++ open_snmp/agent/helpers/table_mfd.c	2009-12-16 12:59:09.000000000 +0530
@@ -4,6 +4,7 @@
 /*
  * standard Net-SNMP includes 
  */
+#if !defined(HAVE_MINIMAL_HELPERS)
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
@@ -506,4 +507,5 @@
     
     return rgroup;
 }
+#endif
 
diff -Naur net-snmp-5.1/agent/helpers/watcher.c open_snmp/agent/helpers/watcher.c
--- net-snmp-5.1/agent/helpers/watcher.c	2003-08-14 13:43:22.000000000 +0530
+++ open_snmp/agent/helpers/watcher.c	2009-12-16 12:59:09.000000000 +0530
@@ -1,3 +1,4 @@
+#if !defined(HAVE_MINIMAL_HELPERS)
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdlib.h>
@@ -324,3 +325,4 @@
                                          requests);
     return SNMP_ERR_NOERROR;
 }
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/atmVclTable/atmVclTable.c open_snmp/agent/mibgroup/CPE-DSL-MIB/atmVclTable/atmVclTable.c
--- net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/atmVclTable/atmVclTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/CPE-DSL-MIB/atmVclTable/atmVclTable.c	2009-12-16 12:59:10.000000000 +0530
@@ -0,0 +1,234 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+// 509141:tc.chen 2005/09/14 added cpe-dsl-mib feature support
+//509141:tc.chen added start
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "atmVclTable.h"
+
+int atmVclTable_size = 0;
+
+void init_atmVclTable(void)
+{
+    oid atmVclTable_oid[] = 
+    { SNMP_OID_ATMVCLTABLE };
+    netsnmp_iterator_info           *iinfo;
+    netsnmp_handler_registration    *reginfo;
+    netsnmp_table_registration_info *table_info;
+
+
+    snmp_log(LOG_INFO, "init_cpe_mibs\n");
+     DEBUGMSGTL((   "CPE_atmVclTable", "init_cpe_mibs\n"));
+    /*
+     * Create the table data structure, and define the indexing....
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    if (!table_info) {
+        return;
+    }
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+						 ASN_INTEGER,
+                                                 ASN_INTEGER, 0);
+    table_info->min_column = ATMVCLVPI;
+    table_info->max_column = ATMVCLVCI;
+
+    /*
+     * .... and iteration information ....
+     */
+    iinfo      = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+    if (!iinfo) {
+        return;
+    }
+    iinfo->get_first_data_point = atmVclTable_first_entry;
+    iinfo->get_next_data_point  = atmVclTable_next_entry;
+    iinfo->table_reginfo        = table_info;
+    /*
+     * .... and register the table with the agent.
+     */
+    reginfo = netsnmp_create_handler_registration("atmVclTable",
+            atmVclTable_handler,
+            atmVclTable_oid, OID_LENGTH(atmVclTable_oid),
+            HANDLER_CAN_RWRITE),
+    netsnmp_register_table_iterator(reginfo, iinfo);
+}
+
+int
+atmVclTable_handler(netsnmp_mib_handler          *handler,
+                 netsnmp_handler_registration *reginfo,
+                 netsnmp_agent_request_info   *reqinfo,
+                 netsnmp_request_info         *requests)
+{
+    netsnmp_request_info  *request;
+    netsnmp_variable_list *requestvb;
+    netsnmp_table_request_info *table_info;
+    oid      subid;
+    long     data;
+    ATMVCLTABLE_ENTRY_TYPE *entry;
+
+
+    DEBUGMSGTL(("CPE_atmVclTable", "Handler - mode %s\n",
+                    se_find_label_in_slist("agent_mode", reqinfo->mode)));
+    switch (reqinfo->mode) {
+    case MODE_GET:
+        for (request=requests; request; request=request->next) {
+            requestvb = request->requestvb;
+            DEBUGMSGTL(( "CPE_atmVclTable", "oid: "));
+            DEBUGMSGOID(("CPE_atmVclTable", requestvb->name,
+                                           requestvb->name_length));
+            DEBUGMSG((   "CPE_atmVclTable", "\n"));
+
+            entry = (ATMVCLTABLE_ENTRY_TYPE *)netsnmp_extract_iterator_context(request);
+            if (entry== NULL)
+                continue;
+            table_info = netsnmp_extract_table_info(request);
+            subid      = table_info->colnum;
+
+            switch (subid) {
+            case ATMVCLVPI:
+                data = ntohs(entry->atmVclVpi);
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            case ATMVCLVCI:
+                data = ntohs(entry->atmVclVci);
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            }
+        }
+	atmVclTable_free();
+        break;
+
+    case MODE_GETNEXT:
+    case MODE_GETBULK:
+    case MODE_SET_RESERVE1:
+    case MODE_SET_RESERVE2:
+    case MODE_SET_ACTION:
+    case MODE_SET_COMMIT:
+    case MODE_SET_FREE:
+    case MODE_SET_UNDO:
+        snmp_log(LOG_WARNING, "atmMIB/atmVclTable: Unsupported mode (%d)\n",
+                               reqinfo->mode);
+        break;
+    default:
+        snmp_log(LOG_WARNING, "atmMib/atmVclTable: Unrecongnised mode (%d)\n",
+                               reqinfo->mode);
+        break;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+ATMVCLTABLE_ENTRY_TYPE *atmVclTable_head  = NULL;
+
+void
+atmVclTable_free(void)
+{
+    ATMVCLTABLE_ENTRY_TYPE *p;
+    while (atmVclTable_head) {
+        p = atmVclTable_head;
+        atmVclTable_head = atmVclTable_head->next;
+        free(p);
+    	atmVclTable_size --;
+    }
+    atmVclTable_head = NULL;
+}
+
+int atmVclTable_load(void)
+{
+    ATMVCLTABLE_ENTRY_TYPE *p;
+    
+    atmVclTable_size =0;
+    while(atmVclTable_size < 5)
+    {
+    	p = malloc(sizeof (ATMVCLTABLE_ENTRY_TYPE));
+	p->atmVclVpi = 0;
+	p->atmVclVci = 33 + atmVclTable_size;
+    	p->ifIndex = atmVclTable_size;
+    	p->next = atmVclTable_head;
+    	atmVclTable_head = p;
+    	atmVclTable_size ++;
+    }
+    return 0;
+}
+
+netsnmp_variable_list *
+atmVclTable_first_entry(void **loop_context,
+                     void **data_context,
+                     netsnmp_variable_list *index,
+                     netsnmp_iterator_info *data)
+{
+    /*
+     * XXX - How can we tell if the cache is valid?
+     *       No access to 'reqinfo'
+     */
+     DEBUGMSGTL((   "CPE_atmVclTable", "first_entry\n"));
+
+    atmVclTable_load();
+
+    if (atmVclTable_head == NULL)
+        return NULL;
+
+    /*
+     * Point to the first entry, and use the
+     * 'next_entry' hook to retrieve this row
+     */
+    *loop_context = atmVclTable_head;
+    return atmVclTable_next_entry( loop_context, data_context, index, data );
+}
+
+netsnmp_variable_list *
+atmVclTable_next_entry( void **loop_context,
+                     void **data_context,
+                     netsnmp_variable_list *index,
+                     netsnmp_iterator_info *data)
+{
+    ATMVCLTABLE_ENTRY_TYPE *patmVclTable = (ATMVCLTABLE_ENTRY_TYPE *)*loop_context;
+    long data;
+    netsnmp_variable_list *idx;
+
+     DEBUGMSGTL((   "CPE_atmVclTable", "next_entry\n"));
+    if (*loop_context == NULL)
+        return NULL;
+
+    //memset(&atmVclTable_data[i],0,sizeof(ATMVCLTABLE_ENTRY_TYPE));
+    /*
+     * Set up the indexing for the specified row...
+     */
+   // ifIndex
+    idx = index;
+    data = ntohs(patmVclTable->ifIndex);
+    snmp_set_var_value(idx, (u_char*)&data, sizeof(data));
+
+    // vclVPI
+    idx = idx->next_variable;
+    data = ntohs(patmVclTable->atmVclVpi);
+    snmp_set_var_value(idx, (u_char*)&data, sizeof(data));
+
+   // vclVCI
+    idx = idx->next_variable;
+    data = ntohs(patmVclTable->atmVclVci);
+    snmp_set_var_value(idx, (u_char*)&data, sizeof(data));
+    /*
+     * ... return the data structure for this row,
+     * and update the loop context ready for the next one.
+     */
+    *data_context = patmVclTable;
+    *loop_context = patmVclTable->next;
+    return index;
+}
+//509141:tc.chen added end
diff -Naur net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/atmVclTable/atmVclTable.h open_snmp/agent/mibgroup/CPE-DSL-MIB/atmVclTable/atmVclTable.h
--- net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/atmVclTable/atmVclTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/CPE-DSL-MIB/atmVclTable/atmVclTable.h	2009-12-16 12:59:11.000000000 +0530
@@ -0,0 +1,54 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+// 509141:tc.chen 2005/09/14 added cpe-dsl-mib feature support
+//509141:tc.chen added start
+#ifndef ATMVCLTABLE_H
+#define ATMVCLTABLE_H
+#define ATMVCLVPI 1
+#define ATMVCLVCI 2
+
+
+struct atmVclTableEntry 
+{
+	struct atmVclTableEntry *next;
+	int ifIndex;
+	int atmVclVpi;
+	int atmVclVci;
+	int atmVclAdminStatus;
+	int atmVclOperStatus;
+	int atmVclLastChange;
+	int atmVclReceiveTrafficDescrIndex;
+	int atmVclTransmitTrafficDescrIndex;
+	int atmVclAalType;
+	int atmVclAal5CpcsTransmitSduSize;
+	int atmVclAal5CpcsReceiveSduSize;
+	int atmVclAal5EncapsType;
+	int atmVclCrossConnectIdentifier;
+	int atmVclRowStatus;
+	int atmVclCastType;
+	int atmVclConnKind;
+};
+
+#define SNMP_OID_ATMVCLTABLE SNMP_OID_MIB2, 37, 1, 7
+#define ATMVCLTABLE_ENTRY_TYPE struct atmVclTableEntry
+
+extern void init_atmVclTable(void);
+extern Netsnmp_Node_Handler atmVclTable_handler;
+extern Netsnmp_First_Data_Point atmVclTable_first_entry;
+extern Netsnmp_Next_Data_Point  atmVclTable_next_entry;
+
+#endif
+//509141:tc.chen added end
diff -Naur net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpeConfig.h open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpeConfig.h
--- net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpeConfig.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpeConfig.h	2009-12-16 12:59:11.000000000 +0530
@@ -0,0 +1,31 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+// 509141:tc.chen 2005/09/14 added cpe-dsl-mib feature support
+//509141:tc.chen added start
+#ifndef CPECONFIG_H
+#define CPECONFIG_H
+#include "../cpeDSL.h"
+
+#define SNMP_OID_CPESYSTEM		SNMP_OID_CPECONFIG, 1
+#define SNMP_OID_CPECONFIGADSLLINE	SNMP_OID_CPECONFIG, 2
+#define SNMP_OID_CPEPVCTABLE		SNMP_OID_CPECONFIG, 3
+#define SNMP_OID_CPEPPPTABLE		SNMP_OID_CPECONFIG, 4
+#define SNMP_OID_CPEIPTABLE		SNMP_OID_CPECONFIG, 5
+#define SNMP_OID_CPEDHCP		SNMP_OID_CPECONFIG, 6
+#define SNMP_OID_CPEDNS			SNMP_OID_CPECONFIG, 7
+
+#endif
+//509141:tc.chen added end
diff -Naur net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpePvcTable/cpePvcTable.c open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpePvcTable/cpePvcTable.c
--- net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpePvcTable/cpePvcTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpePvcTable/cpePvcTable.c	2009-12-16 12:59:11.000000000 +0530
@@ -0,0 +1,809 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+// 509141:tc.chen 2005/09/14 added cpe-dsl-mib feature support
+//509141:tc.chen added start
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "../../cpeDSL.h"
+#include "cpePvcTable.h"
+
+#define FILE_RC_CONF "/flash/rc.conf"
+#define TAG_PVC_TABLE "pvcTable"
+#define TAG_PVC_ENTRY "pvcEntry"
+#define MAX_DATA_LEN 1024
+
+#undef CPEPVCTABLE_DEBUG
+//#define CPEPVCTABLE_DEBUG
+
+int cpePvcTableSize=0; 
+int cpePvcTable_cnt=0; 
+
+CPEPVCTABLE_ENTRY_TYPE *cpePvcTable_head  = NULL;
+
+void init_cpePvcTable(void)
+{
+    oid cpePvcTable_oid[] = { SNMP_OID_CPEPVCTABLE };
+    netsnmp_iterator_info           *iinfo;
+    netsnmp_handler_registration    *reginfo;
+    netsnmp_table_registration_info *table_info;
+
+
+#ifdef CPEPVCTABLE_DEBUG
+   DEBUGMSGTL(("cpeDSL/cpeConfig/cpePvcTable", "init cpePvcTable\n"));
+#endif
+    /*
+     * Create the table data structure, and define the indexing....
+     */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    if (!table_info) {
+        return;
+    }
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+						 ASN_INTEGER,
+                                                 ASN_INTEGER, 0);
+    table_info->min_column = CPEPVCID;
+    table_info->max_column = CPEPVCNATMODE;
+
+    //cpePvcTable_load();
+
+    /*
+     * .... and iteration information ....
+     */
+    iinfo      = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+    if (!iinfo) {
+        return;
+    }
+    iinfo->get_first_data_point = cpePvcTable_first_entry;
+    iinfo->get_next_data_point  = cpePvcTable_next_entry;
+    iinfo->table_reginfo        = table_info;
+    /*
+     * .... and register the table with the agent.
+     */
+    reginfo = netsnmp_create_handler_registration("cpePvcTable",
+            cpePvcTable_handler,
+            cpePvcTable_oid, OID_LENGTH(cpePvcTable_oid),
+            HANDLER_CAN_RWRITE),
+    netsnmp_register_table_iterator(reginfo, iinfo);
+
+}
+
+int find_vcl (u_long ifIndex, u_long atmVciVpi, u_long atmVclVci)
+{
+	return 1; //found
+	return 0; //no found
+}
+
+CPEPVCTABLE_ENTRY_TYPE *cpePvcTable_Entry_Search( CPEPVCTABLE_ENTRY_TYPE *head,u_long ifindex, u_long vpi, u_long vci)
+{
+	while(head!=NULL)
+	{
+		if (head->atmVclVpi == vpi && head->atmVclVci == vci)
+		{
+			return head;
+		}
+		head=head->next;
+	}
+	return NULL;
+}
+
+int cpePvcTable_Store( CPEPVCTABLE_ENTRY_TYPE *table)
+{
+	char *table_buffer,*entry_buffer;
+	int table_idx = 1;
+
+	table_buffer=malloc(1024*5);
+	memset(table_buffer,0,1024*5);
+	entry_buffer=malloc(1024);
+	while(table)
+	{
+		sprintf(entry_buffer,"atmVclVpi%d=\"%d\"\n",table_idx,table->atmVclVpi);
+		strcat(table_buffer,entry_buffer);
+		sprintf(entry_buffer,"atmVclVci%d=\"%d\"\n",table_idx,table->atmVclVci);
+		strcat(table_buffer,entry_buffer);
+		sprintf(entry_buffer,"cpePvcId%d=\"%d\"\n",table_idx,table->cpePvcId);
+		strcat(table_buffer,entry_buffer);
+		sprintf(entry_buffer,"cpePvcIfIndex%d=\"%d\"\n",table_idx,table->cpePvcIfIndex);
+		strcat(table_buffer,entry_buffer);
+		sprintf(entry_buffer,"cpePvcUpperEncapsulation%d=\"%d\"\n",table_idx,table->cpePvcUpperEncapsulation);
+		strcat(table_buffer,entry_buffer);
+		sprintf(entry_buffer,"cpePvcBridgeMode%d=\"%d\"\n",table_idx,table->cpePvcBridgeMode);
+		strcat(table_buffer,entry_buffer);
+		sprintf(entry_buffer,"cpePvcMacLearnMode%d=\"%d\"\n",table_idx,table->cpePvcMacLearnMode);
+		strcat(table_buffer,entry_buffer);
+		sprintf(entry_buffer,"cpePvcIgmpMode%d=\"%d\"\n",table_idx,table->cpePvcIgmpMode);
+		strcat(table_buffer,entry_buffer);
+		sprintf(entry_buffer,"cpePvcDhcpClientMode%d=\"%d\"\n",table_idx,table->cpePvcDhcpClientMode);
+		strcat(table_buffer,entry_buffer);
+		sprintf(entry_buffer,"cpePvcNatMode%d=\"%d\"\n",table_idx,table->cpePvcNatMode);
+		strcat(table_buffer,entry_buffer);
+		table_idx++;
+		table = table->next;
+	}
+
+	ifx_SetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, 1, table_buffer);
+	sprintf(entry_buffer,"cpePvcTableSize=\"%d\"\n",table_idx-1);
+	table_idx = ifx_SetCfgData(FILE_RC_CONF, TAG_PVC_TABLE, 1, entry_buffer);
+	free(entry_buffer);
+	free(table_buffer);
+	return 0; 
+}
+
+int
+cpePvcTable_handler(netsnmp_mib_handler       *handler,
+                 netsnmp_handler_registration *reginfo,
+                 netsnmp_agent_request_info   *reqinfo,
+                 netsnmp_request_info         *requests)
+{
+    netsnmp_request_info  *request;
+    netsnmp_variable_list *requestvb;
+    netsnmp_table_request_info *table_info;
+    oid      subid;
+    long     data;
+    CPEPVCTABLE_ENTRY_TYPE *entry;
+    long entry_idx;
+    int need2update_flag=0;
+    char sValue[MAX_DATA_LEN],tag_name[MAX_DATA_LEN];
+
+
+#ifdef CPEPVCTABLE_DEBUG
+    DEBUGMSGTL(("cpeDSL/cpeConfig/cpePvcTable", "Handler - mode %s\n",
+                    se_find_label_in_slist("agent_mode", reqinfo->mode)));
+#endif
+    for (request=requests; request; request=request->next) {
+        requestvb = request->requestvb;
+#if 0
+        if (request->processed != 0)
+            continue;
+#endif
+        entry_idx = (long)netsnmp_extract_iterator_context(request);
+        if ( entry_idx == 0 && reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+	}
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        subid      = table_info->colnum;
+
+    	switch (reqinfo->mode) {
+    	case MODE_GET:
+#ifdef CPEPVCTABLE_DEBUG
+            DEBUGMSGTL(( "cpeDSL/cpeConfig/cpePvcTable", "oid: "));
+            DEBUGMSGOID(("cpeDSL/cpeConfig/cpePvcTable", requestvb->name,
+                                           requestvb->name_length));
+            DEBUGMSG((   "cpeDSL/cpeConfig/cpePvcTable", "\n"));
+#endif
+
+            switch (subid) {
+            case CPEPVCID:
+                //data = ntohs(entry->cpePvcId);
+    		sprintf(tag_name,"cpePvcId%d",entry_idx);
+    		if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, tag_name, sValue)==1)
+		{
+			data = atoi(sValue);
+		}else
+		{
+			//error
+		}
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            case CPEPVCIFINDEX:
+                //data = ntohs(entry->cpePvcIfIndex);
+    		sprintf(tag_name,"cpePvcIfIndex%d",entry_idx);
+    		if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, tag_name, sValue)==1)
+		{
+			data = atoi(sValue);
+		}else
+		{
+			//error
+		}
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            case CPEPVCUPPERENCAPSULATION:
+    		sprintf(tag_name,"cpePvcUpperEncapsulation%d",entry_idx);
+    		if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, tag_name, sValue)==1)
+		{
+			data = atoi(sValue);
+		}else
+		{
+			//error
+		}
+                //data = ntohs(entry->cpePvcUpperEncapsulation);
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            case CPEPVCADMINSTATUS:
+    		sprintf(tag_name,"cpePvcAdminStatus%d",entry_idx);
+    		if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, tag_name, sValue)==1)
+		{
+			data = atoi(sValue);
+		}else
+		{
+			//error
+		}
+                //data = ntohs(entry->cpePvcAdminStatus);
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            case CPEPVCOPERSTATUS:
+                data = ntohs(1); // need to update
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            case CPEPVCBRIDGEMODE:
+    		sprintf(tag_name,"cpePvcBridgeMode%d",entry_idx);
+    		if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, tag_name, sValue)==1)
+		{
+			data = atoi(sValue);
+		}else
+		{
+			//error
+		}
+                //data = ntohs(entry->cpePvcBridgeMode);
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            case CPEPVCMACLEARNMODE:
+    		sprintf(tag_name,"cpePvcMacLearnMode%d",entry_idx);
+    		if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, tag_name, sValue)==1)
+		{
+			data = atoi(sValue);
+		}else
+		{
+			//error
+		}
+                //data = ntohs(entry->cpePvcMacLearnMode);
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            case CPEPVCIGMPMODE:
+    		sprintf(tag_name,"cpePvcIgmpMode%d",entry_idx);
+    		if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, tag_name, sValue)==1)
+		{
+			data = atoi(sValue);
+		}else
+		{
+			//error
+		}
+                //data = ntohs(entry->cpePvcIgmpMode);
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            case CPEPVCDHCPCLIENTMODE:
+    		sprintf(tag_name,"cpePvcDhcpClientMode%d",entry_idx);
+    		if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, tag_name, sValue)==1)
+		{
+			data = atoi(sValue);
+		}else
+		{
+			//error
+		}
+                //data = ntohs(entry->cpePvcDhcpClientMode);
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            case CPEPVCNATMODE:
+    		sprintf(tag_name,"cpePvcNatMode%d",entry_idx);
+    		if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, tag_name, sValue)==1)
+		{
+			data = atoi(sValue);
+		}else
+		{
+			//error
+		}
+                //data = ntohs(entry->cpePvcNatMode);
+            	snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+                                 (u_char *)&data, sizeof(data));
+                break;
+            }
+
+            break;
+
+    	case MODE_SET_RESERVE1:
+	    if ( entry == NULL )
+	    {
+		if (find_vcl(requestvb->name[11],requestvb->name[12],requestvb->name[13]) == 0)
+		{
+		    netsnmp_set_request_error(reqinfo, requests, SNMPERR_UNKNOWN_OBJID);
+		    break;
+	  	}
+	    }
+	    if (request->requestvb->type != ASN_INTEGER )         
+	    {
+		netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
+		break;
+	    }
+            switch (subid) {
+            case CPEPVCID:
+            case CPEPVCIFINDEX:
+            case CPEPVCOPERSTATUS:
+		netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_READONLY);
+		break;
+            case CPEPVCUPPERENCAPSULATION:
+	    	if ( entry_idx == 0 )
+		{
+	    	    if (*(request->requestvb->val.integer) < CPEPVCUPPERENCAPSULATION_PPPOA ||
+		      ( *(request->requestvb->val.integer) > CPEPVCUPPERENCAPSULATION_ILMI && 
+		       *(request->requestvb->val.integer) != CPEPVCUPPERENCAPSULATION_OTHER ) )        
+		        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
+		}else
+		{
+		    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_READONLY);
+		}
+		break;
+            case CPEPVCADMINSTATUS:
+	    	if (*(request->requestvb->val.integer) < CPEPVCOPERSTATUS_UP || 
+		   *(request->requestvb->val.integer) > CPEPVCOPERSTATUS_DOWN )         
+		    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
+		break;
+            case CPEPVCBRIDGEMODE:
+            case CPEPVCMACLEARNMODE:
+            case CPEPVCIGMPMODE:
+            case CPEPVCDHCPCLIENTMODE:
+            case CPEPVCNATMODE:
+	    	if (*(request->requestvb->val.integer) < ENABLEADMIN_ENABLE || 
+		   *(request->requestvb->val.integer) > ENABLEADMIN_DISABLE )         
+		    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
+		break;
+	    default:
+		break;
+	    }
+	    break;
+    	case MODE_SET_RESERVE2:
+#if 0
+            switch (subid) {
+            case CPEPVCID:
+		break;
+            case CPEPVCIFINDEX:
+		break;
+            case CPEPVCUPPERENCAPSULATION:
+		break;
+            case CPEPVCADMINSTATUS:
+		break;
+            case CPEPVCOPERSTATUS:
+		break;
+            case CPEPVCBRIDGEMODE:
+		break;
+            case CPEPVCMACLEARNMODE:
+		break;
+            case CPEPVCIGMPMODE:
+		break;
+            case CPEPVCDHCPCLIENTMODE:
+		break;
+            case CPEPVCNATMODE:
+		break;
+	    }
+#endif
+	    break;
+    	case MODE_SET_ACTION:
+#ifdef CPEPVCTABLE_DEBUG
+            DEBUGMSGTL(( "cpeDSL/cpeConfig/cpePvcTable", "oid: "));
+            DEBUGMSGOID(("cpeDSL/cpeConfig/cpePvcTable", requestvb->name,
+                                           requestvb->name_length));
+            DEBUGMSG((   "cpeDSL/cpeConfig/cpePvcTable", "\n"));
+#endif
+	    cpePvcTable_load(&cpePvcTable_head);
+	    if ( entry_idx == 0 )
+	    {
+		entry = cpePvcTable_Entry_Search(cpePvcTable_head,requestvb->name[11],requestvb->name[12],requestvb->name[13]);
+		if (entry == NULL)
+		{
+            		DEBUGMSG((   "cpeDSL/cpeConfig/cpePvcTable", "cpePvcTable_Entry_create\n"));
+			cpePvcTable_Entry_create(&cpePvcTable_head,&entry);
+			entry->ifIndex = requestvb->name[11];
+			entry->atmVclVpi = requestvb->name[12];
+			entry->atmVclVci = requestvb->name[13];
+		}
+	    }else
+	    {
+		int temp_idx=1;
+		entry = cpePvcTable_head;
+		for (temp_idx = 1 ;temp_idx < entry_idx;temp_idx++)
+		{
+			if (entry->next)
+			{
+				entry=entry->next;
+			}else
+			{
+				// error
+			}
+		}
+	    }
+
+            switch (subid) {
+            case CPEPVCUPPERENCAPSULATION:
+		entry->cpePvcUpperEncapsulation = *(request->requestvb->val.integer);
+		break;
+            case CPEPVCADMINSTATUS:
+		entry->cpePvcAdminStatus = *(request->requestvb->val.integer);
+		break;
+            case CPEPVCBRIDGEMODE:
+		entry->cpePvcBridgeMode = *(request->requestvb->val.integer);
+		break;
+            case CPEPVCMACLEARNMODE:
+		entry->cpePvcMacLearnMode = *(request->requestvb->val.integer);
+		break;
+            case CPEPVCIGMPMODE:
+		entry->cpePvcIgmpMode = *(request->requestvb->val.integer);
+		break;
+            case CPEPVCDHCPCLIENTMODE:
+		entry->cpePvcDhcpClientMode = *(request->requestvb->val.integer);
+		break;
+            case CPEPVCNATMODE:
+		entry->cpePvcNatMode = *(request->requestvb->val.integer);
+		break;
+	    }
+	    need2update_flag=1;
+	    break;
+    	case MODE_SET_UNDO:
+    	    cpePvcTable_free(&cpePvcTable_head);
+	    need2update_flag=0;
+	    break;
+    	case MODE_SET_COMMIT:
+	    //break;
+    	case MODE_GETNEXT:
+    	case MODE_GETBULK:
+    	case MODE_SET_FREE:
+#ifdef CPEPVCTABLE_DEBUG
+            snmp_log(LOG_WARNING, "cpeDSL/cpeConfig/cpePvcTable: Unsupported mode (%d)\n",
+                    reqinfo->mode);
+#endif
+            break;
+    	default:
+#ifdef CPEPVCTABLE_DEBUG
+            snmp_log(LOG_WARNING, "cpeDSL/cpeConfig/cpePvcTable: Unrecongnised mode (%d)\n",
+                    reqinfo->mode);
+#endif
+            break;
+    	}
+    }
+    	    if (need2update_flag)
+    	    { 
+		cpePvcTable_Store(cpePvcTable_head);
+    	    	cpePvcTable_free(&cpePvcTable_head);
+		need2update_flag = 0;
+    	    }
+    //cpePvcTable_free();
+    return SNMP_ERR_NOERROR;
+}
+
+void
+cpePvcTable_free(CPEPVCTABLE_ENTRY_TYPE **head)
+{
+    CPEPVCTABLE_ENTRY_TYPE *p;
+
+    while (*head) {
+       	p = *head;
+       	*head = (*head)->next;
+       	free(p);
+     }
+     *head = NULL;
+}
+
+void list_append(CPEPVCTABLE_ENTRY_TYPE **head,CPEPVCTABLE_ENTRY_TYPE *entry)
+{
+	CPEPVCTABLE_ENTRY_TYPE *p = *head;
+	if ( p != NULL)
+	{
+		while ( p->next)
+		{
+			p = p->next;
+		}
+		p->next=entry;
+	}else
+	{
+	    *head = entry;
+	}
+}
+
+// should move to common api
+int get_next_unused_cpePvcNO(int TYPE)
+{
+	char sValue[MAX_DATA_LEN];
+	char entry_tag[MAX_DATA_LEN];
+	int idx=1,table_size = 0 ,prev_value;
+
+    //send_adsl_line_up_message();
+	switch(TYPE)
+	{
+		case CPEPVCID:
+			prev_value = -1;
+			break;
+		case CPEPVCIFINDEX:
+			prev_value = 150000 - 1;
+			break;
+		default:
+			return -1;
+	}
+	if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_TABLE, "cpePvcTableSize", sValue)== 1)
+		table_size = atoi(sValue);
+	else
+		table_size = 0;
+
+	for(idx=1; idx<=table_size; idx++)
+	{
+		switch(TYPE)
+		{
+			case CPEPVCID:
+				sprintf(entry_tag,"cpePvcId%d",idx);
+				break;
+			case CPEPVCIFINDEX:
+				sprintf(entry_tag,"cpePvcIfIndex%d",idx);
+				break;
+			default:
+			return -1;
+		}
+		ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, entry_tag, sValue);
+		if ( atoi(sValue) - 1 >prev_value)
+		{
+			return prev_value+1;
+		}else
+		{
+			prev_value = atoi(sValue);
+		}	
+	}
+	return prev_value+1;
+}
+
+int cpePvcTable_Entry_create(CPEPVCTABLE_ENTRY_TYPE **head,CPEPVCTABLE_ENTRY_TYPE **p)
+{
+    CPEPVCTABLE_ENTRY_TYPE *entry;
+    entry = malloc(sizeof (CPEPVCTABLE_ENTRY_TYPE));
+    memset(entry,0,sizeof(CPEPVCTABLE_ENTRY_TYPE));
+    entry->cpePvcId = get_next_unused_cpePvcNO(CPEPVCID);
+    entry->cpePvcIfIndex = get_next_unused_cpePvcNO(CPEPVCIFINDEX);
+    entry->cpePvcUpperEncapsulation = CPEPVCUPPERENCAPSULATION_OTHER;
+    entry->cpePvcOperStatus = CPEPVCOPERSTATUS_DOWN;
+    entry->cpePvcBridgeMode = ENABLEADMIN_DISABLE;
+    entry->cpePvcMacLearnMode = ENABLEADMIN_DISABLE;
+    entry->cpePvcIgmpMode = ENABLEADMIN_DISABLE;
+    entry->cpePvcDhcpClientMode = ENABLEADMIN_DISABLE;
+    entry->cpePvcNatMode = ENABLEADMIN_DISABLE;
+
+    list_append(head,entry);
+    *p = entry;
+}
+
+int cpePvcTable_load_entry(int idx,CPEPVCTABLE_ENTRY_TYPE **entry)
+{
+    CPEPVCTABLE_ENTRY_TYPE *p;
+    char sValue[MAX_DATA_LEN];
+    char entry_tag[MAX_DATA_LEN];
+
+    p = malloc(sizeof (CPEPVCTABLE_ENTRY_TYPE));
+    memset(p,0,sizeof(CPEPVCTABLE_ENTRY_TYPE));
+
+    p->ifIndex = 2;
+
+    sprintf(entry_tag,"atmVclVpi%d",idx);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, entry_tag, sValue)==1)
+    	p->atmVclVpi = atoi(sValue);
+    else 
+	goto error_exit;
+    sprintf(entry_tag,"atmVclVci%d",idx);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, entry_tag, sValue)==1)
+    	p->atmVclVci = atoi(sValue);
+    else 
+	goto error_exit;
+    sprintf(entry_tag,"cpePvcId%d",idx);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, entry_tag, sValue)==1)
+    	p->cpePvcId = atoi(sValue);
+    else 
+	goto error_exit;
+    sprintf(entry_tag,"cpePvcIfIndex%d",idx);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, entry_tag, sValue)==1)
+    	p->cpePvcIfIndex = atoi(sValue);
+    else 
+	goto error_exit;
+    sprintf(entry_tag,"cpePvcUpperEncapsulation%d",idx);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, entry_tag, sValue)==1)
+    	p->cpePvcUpperEncapsulation = atoi(sValue);
+    else 
+	goto error_exit;
+
+    p->cpePvcOperStatus = cpePvcTableSize %2; // need to update
+
+    sprintf(entry_tag,"cpePvcBridgeMode%d",idx);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, entry_tag, sValue)==1)
+    	p->cpePvcBridgeMode = atoi(sValue);
+    else 
+	goto error_exit;
+
+    sprintf(entry_tag,"cpePvcMacLearnMode%d",idx);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, entry_tag, sValue)==1)
+    	p->cpePvcMacLearnMode = atoi(sValue);
+    else 
+	goto error_exit;
+
+    sprintf(entry_tag,"cpePvcIgmpMode%d",idx);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, entry_tag, sValue)==1)
+    	p->cpePvcIgmpMode = atoi(sValue);
+    else 
+	goto error_exit;
+
+    sprintf(entry_tag,"cpePvcDhcpClientMode%d",idx);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, entry_tag, sValue)==1)
+    	p->cpePvcDhcpClientMode = atoi(sValue);
+    else 
+	goto error_exit;
+
+    sprintf(entry_tag,"cpePvcNatMode%d",idx);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, entry_tag, sValue)==1)
+    	p->cpePvcNatMode = atoi(sValue);
+    else 
+	goto error_exit;
+
+    *entry = p;
+    return 0;
+
+error_exit:
+	free(p);
+	return -1;
+}
+
+int cpePvcTable_load(CPEPVCTABLE_ENTRY_TYPE **head)
+{
+    CPEPVCTABLE_ENTRY_TYPE *p ;
+    char sValue[MAX_DATA_LEN];
+    int idx=1;
+
+    if (*head == NULL)
+    {
+	if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_TABLE, "cpePvcTableSize", sValue)!=1)
+	{
+		cpePvcTableSize = 0;
+		goto error_exit;
+	}
+	else
+	{
+		cpePvcTableSize = atoi(sValue);
+	}
+	for (idx=1; idx<=cpePvcTableSize; idx++)
+	{
+		if (cpePvcTable_load_entry(idx,&p)!=0)
+			goto error_free_exit;
+		list_append(head,p);
+	}
+     }
+    return 0;
+
+error_free_exit:
+    cpePvcTable_free(head);
+error_exit:
+    return -1;
+}
+
+netsnmp_variable_list *
+cpePvcTable_first_entry(void **loop_context,
+                     void **data_context,
+                     netsnmp_variable_list *index,
+                     netsnmp_iterator_info *data)
+{
+    char sValue[MAX_DATA_LEN];
+    /*
+     * XXX - How can we tell if the cache is valid?
+     *       No access to 'reqinfo'
+     */
+#ifdef CPEPVCTABLE_DEBUG
+    DEBUGMSGTL((   "cpeDSL/cpeConfig/cpePvcTable", "first_entry\n"));
+#endif
+
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_TABLE, "cpePvcTableSize", sValue)== 1)
+    {
+	cpePvcTableSize=atoi(sValue);
+    }
+    else
+    {
+	cpePvcTableSize = 0;
+    }
+
+    if (cpePvcTableSize == 0)
+        return NULL;
+
+
+    /*
+     * Point to the first entry, and use the
+     * 'next_entry' hook to retrieve this row
+     */
+    //*loop_context = cpePvcTable_head;
+    *loop_context = 1;
+    return cpePvcTable_next_entry( loop_context, data_context, index, data );
+}
+
+
+netsnmp_variable_list *
+cpePvcTable_next_entry( void **loop_context,
+                     void **data_context,
+                     netsnmp_variable_list *index,
+                     netsnmp_iterator_info *data)
+{
+    //CPEPVCTABLE_ENTRY_TYPE *pcpePvcTable = (CPEPVCTABLE_ENTRY_TYPE *)*loop_context;
+    long data;
+    netsnmp_variable_list *idx;
+    char sValue[MAX_DATA_LEN];
+    char tag_name[MAX_DATA_LEN];
+
+
+#if 0
+    if (pcpePvcTable == NULL)
+	return NULL;
+#else
+    if ( *loop_context > cpePvcTableSize )
+	return NULL;
+#endif
+
+#ifdef CPEPVCTABLE_DEBUG
+    DEBUGMSGTL((   "cpeDSL/cpeConfig/cpePvcTable", "next_entry *loop_context=%d\n",*loop_context));
+#endif
+    /*
+     * Set up the indexing for the specified row...
+     */
+   // ifIndex
+    idx = index;
+    data = ntohs(2);
+    //data = ntohs(pcpePvcTable->ifIndex);
+    snmp_set_var_value(idx, (u_char*)&data, sizeof(data));
+    
+    // vclVPI
+    idx = idx->next_variable;
+    //data = ntohs(pcpePvcTable->atmVclVpi);
+    sprintf(tag_name,"atmVclVpi%d",*loop_context);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, tag_name,sValue)== 1)
+    	data = ntohs(atoi(sValue));
+    else
+    {
+	return NULL;
+    }
+    snmp_set_var_value(idx, (u_char*)&data, sizeof(data));
+
+   // vclVCI
+    idx = idx->next_variable;
+    //data = ntohs(pcpePvcTable->atmVclVci);
+    sprintf(tag_name,"atmVclVci%d",*loop_context);
+    if (ifx_GetCfgData(FILE_RC_CONF, TAG_PVC_ENTRY, tag_name,sValue)== 1)
+    	data = ntohs(atoi(sValue));
+    else
+    {
+	return NULL;
+    }
+
+    snmp_set_var_value(idx, (u_char*)&data, sizeof(data));
+    /*
+     * ... return the data structure for this row,
+     * and update the loop context ready for the next one.
+     */
+    //*data_context = pcpePvcTable;
+    //*loop_context = pcpePvcTable->next;
+    *data_context = *loop_context;
+    *loop_context = *loop_context+1;
+    return index;
+}
+
+
+//509141:tc.chen added end
diff -Naur net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpePvcTable/cpePvcTable.h open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpePvcTable/cpePvcTable.h
--- net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpePvcTable/cpePvcTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeConfig/cpePvcTable/cpePvcTable.h	2009-12-16 12:59:11.000000000 +0530
@@ -0,0 +1,76 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+// 509141:tc.chen 2005/09/14 added cpe-dsl-mib feature support
+//509141:tc.chen added start
+#ifndef CPEPVCTABLE_H
+#define CPEPVCTABLE_H
+
+#include "../cpeConfig.h"
+
+
+// 
+#define CPEPVCID 			1
+#define CPEPVCIFINDEX 			3
+#define CPEPVCUPPERENCAPSULATION 	4
+#define CPEPVCADMINSTATUS		5
+#define CPEPVCOPERSTATUS		6
+#define CPEPVCBRIDGEMODE		7
+#define CPEPVCMACLEARNMODE		8
+#define CPEPVCIGMPMODE			9
+#define CPEPVCDHCPCLIENTMODE		10
+#define CPEPVCNATMODE			11
+
+#define CPEPVCOPERSTATUS_UP		1
+#define CPEPVCOPERSTATUS_DOWN		2
+
+#define CPEPVCUPPERENCAPSULATION_PPPOA			1
+#define CPEPVCUPPERENCAPSULATION_PPPOE			2
+#define CPEPVCUPPERENCAPSULATION_ROUTER1483		3
+#define CPEPVCUPPERENCAPSULATION_PUREBFIDTE1483		4
+#define CPEPVCUPPERENCAPSULATION_BRIDGE1483PLUSIP	5
+#define CPEPVCUPPERENCAPSULATION_ILMI			7
+#define CPEPVCUPPERENCAPSULATION_OTHER			255
+
+
+struct cpePvcTableEntry 
+{
+	struct cpePvcTableEntry *next;
+	int	ifIndex;
+	int 	atmVclVpi;
+	int	atmVclVci;
+	int	cpePvcId;
+	int	cpePvcIfIndex;
+	int	cpePvcUpperEncapsulation;
+	int	cpePvcAdminStatus;
+	int	cpePvcOperStatus;
+	int	cpePvcBridgeMode;
+	int	cpePvcMacLearnMode;
+	int	cpePvcIgmpMode;
+	int	cpePvcDhcpClientMode;
+	int	cpePvcNatMode;
+};
+
+#define CPEPVCTABLE_ENTRY_TYPE	struct cpePvcTableEntry
+
+void   init_cpePvcTable(void);
+extern Netsnmp_Node_Handler cpePvcTable_handler;
+extern Netsnmp_First_Data_Point cpePvcTable_first_entry;
+extern Netsnmp_Next_Data_Point  cpePvcTable_next_entry;
+void cpePvcTable_free(CPEPVCTABLE_ENTRY_TYPE **);
+int cpePvcTable_load(CPEPVCTABLE_ENTRY_TYPE **);
+
+#endif
+//509141:tc.chen added end
diff -Naur net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeDSL.h open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeDSL.h
--- net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeDSL.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeDSL.h	2009-12-16 12:59:11.000000000 +0530
@@ -0,0 +1,33 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+// 509141:tc.chen 2005/09/14 added cpe-dsl-mib feature support
+//509141:tc.chen added start
+#ifndef CPEDSL_H
+#define CPEDSL_H
+
+#define SNMP_OID_CPEDSL 	SNMP_OID_ENTERPRISES, 16972 
+#define SNMP_OID_CPESYSINFO	SNMP_OID_CPEDSL, 1
+#define SNMP_OID_CPECONFIG	SNMP_OID_CPEDSL, 2
+#define SNMP_OID_CPESYSLOG	SNMP_OID_CPEDSL, 3
+#define SNMP_OID_CPEFTP		SNMP_OID_CPEDSL, 4
+#define SNMP_OID_CPEDIAGNOSE	SNMP_OID_CPEDSL, 5
+#define SNMP_OID_CPETRAP	SNMP_OID_CPEDSL, 6
+
+#define ENABLEADMIN_ENABLE 	1
+#define ENABLEADMIN_DISABLE 	2
+
+#endif
+//509141:tc.chen added end
diff -Naur net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeTrap/cpeBootTrap.c open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeTrap/cpeBootTrap.c
--- net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeTrap/cpeBootTrap.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeTrap/cpeBootTrap.c	2009-12-16 12:59:11.000000000 +0530
@@ -0,0 +1,315 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+// 509141:tc.chen 2005/09/14 added cpe-dsl-mib feature support
+//509141:tc.chen added start
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#include <signal.h>
+
+#include "../../../../apps/snmptrapd_handlers.h"
+
+#include "../cpeConfig/cpeConfig.h"
+#include "cpeBootTrap.h"
+#define MAX_DATA_LEN 1024
+#define ADSL_UP_BOOTTRAP_RESPONSE_WAITING_TIME 10 // wait 30 seconds 
+#define ADSL_UP_BOOTTRAP_RETRY_TIMES 2 // retry 2 times to send adsl up message if server does not response in 30 seconds
+
+int fill_SysInfoFirmwareVersion(netsnmp_variable_list **notification_vars)
+{
+	oid notification_oid[] = { SNMP_OID_CPESYSINFOFIRMWAREVERSION };
+	size_t notification_oid_len = OID_LENGTH(notification_oid);
+	char message[MAX_DATA_LEN] = "FirmwareVersion";
+
+	snmp_varlist_add_variable(notification_vars,notification_oid,notification_oid_len , ASN_OCTET_STR, message, strlen(message));
+}
+
+int fill_SysInfoSystemVersion(netsnmp_variable_list **notification_vars)
+{
+	oid notification_oid[] = { SNMP_OID_CPESYSINFOSYSTEMVERSION };
+	size_t notification_oid_len = OID_LENGTH(notification_oid);
+	char message[MAX_DATA_LEN] = "SystemVersion";
+
+	snmp_varlist_add_variable(notification_vars,notification_oid,notification_oid_len , ASN_OCTET_STR, message, strlen( message ));
+}
+
+int fill_SysInfoProductId(netsnmp_variable_list **notification_vars)
+{
+	oid notification_oid[] = { SNMP_OID_CPESYSINFOPRODUCTID };
+	size_t notification_oid_len = OID_LENGTH(notification_oid);
+	char message[MAX_DATA_LEN] = "ProductId";
+
+	snmp_varlist_add_variable(notification_vars,notification_oid,notification_oid_len , ASN_OCTET_STR, message, strlen( message ));
+}
+
+int fill_SysInfoVendorId(netsnmp_variable_list **notification_vars)
+{
+	oid notification_oid[] = { SNMP_OID_CPESYSINFOVENDORID };
+	size_t notification_oid_len = OID_LENGTH(notification_oid);
+	char message[MAX_DATA_LEN] = "VendorId";
+
+	snmp_varlist_add_variable(notification_vars,notification_oid,notification_oid_len , ASN_OCTET_STR, message, strlen( message ));
+}
+
+int fill_SysInfoManufacturerOui(netsnmp_variable_list **notification_vars)
+{
+	oid notification_oid[] = { SNMP_OID_CPESYSINFOMANUFACTUREROUI };
+	size_t notification_oid_len = OID_LENGTH(notification_oid);
+	char message[MAX_DATA_LEN];
+	memset(message,0,sizeof(message));
+	message[0]=0xaa;
+	message[1]=0xbb;
+	message[2]=0xcc;
+	message[3]=0x11;
+
+	snmp_varlist_add_variable(notification_vars,notification_oid,notification_oid_len , ASN_OCTET_STR, message, 4);
+}
+
+int fill_SysInfoConfigId(netsnmp_variable_list **notification_vars)
+{
+	oid notification_oid[] = { SNMP_OID_CPESYSINFOCONFIGID };
+	size_t notification_oid_len = OID_LENGTH(notification_oid);
+	char message[MAX_DATA_LEN] ;
+	memset(message,0,sizeof(message));
+	message[0]=0xaa;
+	message[1]=0xbb;
+	message[2]=0xcc;
+	message[3]=0x11;
+
+	snmp_varlist_add_variable(notification_vars,notification_oid,notification_oid_len , ASN_OCTET_STR, message, 4 );
+}
+
+int fill_SysInfoWorkMode(netsnmp_variable_list **notification_vars)
+{
+	oid notification_oid[] = { SNMP_OID_CPESYSINFOWORKMODE };
+	size_t notification_oid_len = OID_LENGTH(notification_oid);
+	long message = 0;
+
+	message = ntohs(2);
+	snmp_varlist_add_variable(notification_vars,notification_oid,notification_oid_len , ASN_INTEGER, (u_char *)&message, sizeof( message ));
+}
+
+int fill_SysInfoMibVersion(netsnmp_variable_list **notification_vars)
+{
+	oid notification_oid[] = { SNMP_OID_CPESYSINFOMIBVERSION };
+	size_t notification_oid_len = OID_LENGTH(notification_oid);
+	char message[MAX_DATA_LEN] = "V1.00";
+
+	snmp_varlist_add_variable(notification_vars,notification_oid,notification_oid_len , ASN_OCTET_STR, message, strlen( message ));
+}
+
+int fill_SysInfoSerialNumber(netsnmp_variable_list **notification_vars)
+{
+	oid notification_oid[] = { SNMP_OID_CPESYSINFOSERIALNUMBER };
+	size_t notification_oid_len = OID_LENGTH(notification_oid);
+	char message[MAX_DATA_LEN] = "1122233aabbee";
+
+	snmp_varlist_add_variable(notification_vars,notification_oid,notification_oid_len , ASN_OCTET_STR, message, strlen( message ));
+}
+
+int fill_BootTrap_message(netsnmp_variable_list **notification_vars)
+{
+    oid    notification_oid[] = { SNMP_OID_CPEBOOTTRAP, 0};
+    size_t notification_oid_len = OID_LENGTH(notification_oid);
+    oid    objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
+    size_t objid_snmptrap_len = OID_LENGTH(objid_snmptrap);
+
+    snmp_varlist_add_variable(notification_vars,objid_snmptrap,objid_snmptrap_len,ASN_OBJECT_ID,(u_char *)notification_oid,notification_oid_len * sizeof(oid));
+}
+
+int fill_SysInfo_message(netsnmp_variable_list **notification_vars)
+{
+
+    fill_BootTrap_message(notification_vars);
+    fill_SysInfoConfigId(notification_vars);
+    fill_SysInfoFirmwareVersion(notification_vars);
+    fill_SysInfoProductId(notification_vars);
+    fill_SysInfoVendorId(notification_vars);
+    fill_SysInfoManufacturerOui(notification_vars);
+    fill_SysInfoSystemVersion(notification_vars);
+    fill_SysInfoWorkMode(notification_vars);
+    fill_SysInfoMibVersion(notification_vars);
+    fill_SysInfoSerialNumber(notification_vars);
+}
+
+int send_BootTrapResponse(int response)
+{
+    netsnmp_variable_list *notification_vars = NULL;
+    oid notification_oid[] = { SNMP_OID_CPEBOOTTRAPRESPONSE };
+    size_t notification_oid_len = OID_LENGTH(notification_oid);
+    long message = 0;
+
+    if (response > 4 || response < 1)
+    {	
+	snmp_log(LOG_ERR, "send_BootTrapResponse: send wrong response %d\n", response);
+	return -1;
+    }
+    fill_BootTrap_message(&notification_vars);
+    message = ntohs(response);
+    snmp_varlist_add_variable(&notification_vars,notification_oid,notification_oid_len , ASN_INTEGER, (u_char *)&message, sizeof( message ));
+    send_v2trap(notification_vars);
+    snmp_free_varbind(notification_vars);
+    return 0;
+}
+
+u_char retry_count = 0;
+u_char server_response = 0;
+unsigned int adsl_up_alarm_register_clientreg=0;
+
+void send_adsl_line_up_message(unsigned int clientreg, void *clientarg)
+{
+	netsnmp_variable_list *notification_vars = NULL;
+
+        DEBUGMSGTL(( "snmptrapd", "send_adsl_lin_up_message server_response:%d retry_count:%d\n",server_response,retry_count));
+	adsl_up_alarm_register_clientreg = 0;
+	fill_SysInfo_message(&notification_vars);
+	send_v2trap(notification_vars);
+	snmp_free_varbind(notification_vars);
+
+	if ( !server_response && retry_count < ADSL_UP_BOOTTRAP_RETRY_TIMES)
+	{
+		adsl_up_alarm_register_clientreg = snmp_alarm_register(ADSL_UP_BOOTTRAP_RESPONSE_WAITING_TIME,0,send_adsl_line_up_message,NULL);
+        	DEBUGMSGTL(( "snmptrapd", "snmp_alarm_register again %d",adsl_up_alarm_register_clientreg));
+		retry_count ++;
+	}
+}
+
+extern int send_boottrap_signal;
+void
+adsl_line_up_BootTrap(int data)
+{
+	unsigned int timer;
+	
+   	DEBUGMSGTL(( "snmptrapd", "adsl_line_up_BootTrap"));
+    if(adsl_up_alarm_register_clientreg)
+    {
+    	DEBUGMSGTL(( "snmptrapd", "unregister snmp alarm"));
+	snmp_alarm_unregister(adsl_up_alarm_register_clientreg);
+	adsl_up_alarm_register_clientreg = 0;
+    }
+    retry_count = 0;
+    server_response = 0;
+
+	srand((int)time(0));
+	timer = 1+abs((int)(rand()/((RAND_MAX + 1)/10)));
+	adsl_up_alarm_register_clientreg = snmp_alarm_register(timer,0,send_adsl_line_up_message,NULL);
+   	DEBUGMSGTL(( "snmptrapd", "cpeBootTrap_timer = %d clientreg=%d\n",timer,adsl_up_alarm_register_clientreg));
+	send_boottrap_signal = 1;
+}
+
+int cpeSysInfo_event_input(netsnmp_variable_list *vp)
+{
+	switch (vp->name[8])
+	{
+		case CPESYSINFOUPTIME: // no used
+		break;
+		case CPESYSINFOCONFIGID:
+		break;
+		case CPESYSINFOFIRMWAREVERSION:
+		break;
+		case CPESYSINFOPRODUCTID:
+		break;
+		case CPESYSINFOVENDORID:
+		break;
+		case CPESYSINFOSYSTEMVERSION:
+		break;
+		case CPESYSINFOWORKMODE:
+		break;
+		case CPESYSINFOMIBVERSION:
+		break;
+		case CPESYSINFOSERIALNUMBER:
+		break;
+		case CPESYSINFOMANUFACTUREROUI:
+		break;
+		default:
+		return -1;
+	}
+	return 0;
+}
+
+int cpeBootTrapResponse_event_input(netsnmp_variable_list *vp)
+{
+	if (vp->val_len != sizeof(int))
+	{
+    		DEBUGMSGTL(( "snmptrapd", "cpeBootTrap_event_input len != var_len\n"));
+		return -1;
+	}
+	if (vp->type != ASN_INTEGER)
+	{
+    		DEBUGMSGTL(( "snmptrapd", "cpeBootTrap_event_input wrong type\n"));
+		return -1;
+	}
+    	DEBUGMSGTL(( "snmptrapd", "cpeBootTrap_event_input cpeBootTrapResponse = %d\n",*((long *)(vp->val.integer))));
+	server_response = *((long *)(vp->val.integer));
+	if(adsl_up_alarm_register_clientreg)
+	{
+    		DEBUGMSGTL(( "snmptrapd", "unregister snmp alarm"));
+		snmp_alarm_unregister(adsl_up_alarm_register_clientreg);
+		adsl_up_alarm_register_clientreg = 0;
+	}
+	return 0;
+}
+
+int cpeBootTrap_event_input(netsnmp_variable_list * vp)
+{
+	oid cpeBootTrapResponse_oid[] = { SNMP_OID_CPEBOOTTRAPRESPONSE };
+	oid cpeSysInfo_oid[] = { SNMP_OID_CPESYSINFO };
+	int cpeBootTrapResponse = 0;
+
+	while (vp )
+	{
+		if (!memcmp(vp->name, cpeBootTrapResponse_oid, sizeof(cpeBootTrapResponse_oid)))
+		{
+			cpeBootTrapResponse_event_input(vp);	
+		}
+		else if (!memcmp(vp->name, cpeSysInfo_oid, sizeof(cpeSysInfo_oid)))
+		{
+			cpeSysInfo_event_input(vp);	
+			cpeBootTrapResponse = 1;
+		}
+		vp = vp->next_variable;
+	}
+	if (cpeBootTrapResponse != 0)
+		send_BootTrapResponse(cpeBootTrapResponse);
+	return 0;
+}
+
+int cpeBootTrap_handler ( 
+	netsnmp_pdu *pdu, 
+	netsnmp_transport *transport, 
+	netsnmp_trapd_handler *handler)
+{
+    DEBUGMSGTL(( "snmptrapd", "cpeBootTrap_handler_handler\n"));
+    cpeBootTrap_event_input(pdu->variables);
+    return NETSNMPTRAPD_HANDLER_OK;
+}
+
+int init_cpeBootTrap(void)
+{
+    oid  oid_cpeBootTrap[] = { SNMP_OID_CPEBOOTTRAP, 0, 0 };
+    netsnmp_add_traphandler(cpeBootTrap_handler, oid_cpeBootTrap, OID_LENGTH(oid_cpeBootTrap));
+    struct sigaction act;
+
+    DEBUGMSGTL(("snmptrapd", "registering SIGUSR2 signal handler\n"));
+    signal(SIGUSR2,adsl_line_up_BootTrap);
+}
+
+//509141:tc.chen added end
diff -Naur net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeTrap/cpeBootTrap.h open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeTrap/cpeBootTrap.h
--- net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB/cpeTrap/cpeBootTrap.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/CPE-DSL-MIB/cpeTrap/cpeBootTrap.h	2009-12-16 12:59:11.000000000 +0530
@@ -0,0 +1,51 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+// 509141:tc.chen 2005/09/14 added cpe-dsl-mib feature support
+//509141:tc.chen added start
+#ifndef CPEBOOTTRAP_H
+#define CPEBOOTTRAP_H
+
+#define SNMP_OID_CPETRAPS 			SNMP_OID_CPETRAP, 0
+
+#define SNMP_OID_CPEBOOTTRAP 			SNMP_OID_CPETRAPS, 1
+
+#define CPESYSINFOUPTIME			1
+#define CPESYSINFOCONFIGID			2
+#define CPESYSINFOFIRMWAREVERSION		3
+#define CPESYSINFOPRODUCTID			4
+#define CPESYSINFOVENDORID			5
+#define CPESYSINFOSYSTEMVERSION			6
+#define CPESYSINFOWORKMODE			7
+#define CPESYSINFOMIBVERSION			8
+#define CPESYSINFOSERIALNUMBER			9
+#define CPESYSINFOMANUFACTUREROUI		10
+
+#define SNMP_OID_CPESYSINFOUPTIME		SNMP_OID_CPESYSINFO, CPESYSINFOUPTIME
+#define SNMP_OID_CPESYSINFOCONFIGID		SNMP_OID_CPESYSINFO, CPESYSINFOCONFIGID
+#define SNMP_OID_CPESYSINFOFIRMWAREVERSION	SNMP_OID_CPESYSINFO, CPESYSINFOFIRMWAREVERSION
+#define SNMP_OID_CPESYSINFOPRODUCTID		SNMP_OID_CPESYSINFO, CPESYSINFOPRODUCTID
+#define SNMP_OID_CPESYSINFOVENDORID		SNMP_OID_CPESYSINFO, CPESYSINFOVENDORID
+#define SNMP_OID_CPESYSINFOSYSTEMVERSION	SNMP_OID_CPESYSINFO, CPESYSINFOSYSTEMVERSION
+#define SNMP_OID_CPESYSINFOWORKMODE		SNMP_OID_CPESYSINFO, CPESYSINFOWORKMODE
+#define SNMP_OID_CPESYSINFOMIBVERSION		SNMP_OID_CPESYSINFO, CPESYSINFOMIBVERSION
+#define SNMP_OID_CPESYSINFOSERIALNUMBER		SNMP_OID_CPESYSINFO, CPESYSINFOSERIALNUMBER
+#define SNMP_OID_CPESYSINFOMANUFACTUREROUI	SNMP_OID_CPESYSINFO, CPESYSINFOMANUFACTUREROUI
+
+#define SNMP_OID_CPEBOOTTRAPRESPONSE		SNMP_OID_CPESYSTEM, 5
+
+#endif
+
+//509141:tc.chen added end
diff -Naur net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB.h open_snmp/agent/mibgroup/CPE-DSL-MIB.h
--- net-snmp-5.1/agent/mibgroup/CPE-DSL-MIB.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/CPE-DSL-MIB.h	2009-12-16 12:59:11.000000000 +0530
@@ -0,0 +1,30 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+// 509141:tc.chen 2005/09/14 added cpe-dsl-mib feature support
+//509141:tc.chen added start
+// This file is included in the mibgroup directory to add the various modules
+// of adsl
+
+config_require(CPE-DSL-MIB/atmVclTable/atmVclTable)
+config_require(CPE-DSL-MIB/cpeConfig/cpePvcTable/cpePvcTable)
+
+config_require(CPE-DSL-MIB/cpeTrap/cpeBootTrap)
+
+config_require(CPE-DSL-MIB)
+
+config_add_mib(CPE-DSL-MIB)
+
+//509141:tc.chen added end
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable.c open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable.c	2009-12-16 12:59:15.000000000 +0530
@@ -0,0 +1,448 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAlarmConfProfileExtTable.c
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslAlarmConfProfileExtTable module
+ *               2) Handling requests for the adslAlarmConfProfileExtTable
+ *                  table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAlarmConfProfileExtTable.h"
+#include "adslAlarmConfProfileExtTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL DEFINITIONS
+ * ===========================================================================
+*/
+
+static netsnmp_oid_stash_node *undoStorage = NULL;
+static netsnmp_oid_stash_node *commitStorage = NULL;
+
+struct undoInfo {
+    void           *ptr;
+    size_t          len;
+};
+
+struct commitInfo {
+    void           *data_context;
+    int             have_committed;
+    int             new_row;
+};
+
+void
+adslAlarmConfProfileExtTable_free_undoInfo(void *vptr)
+{
+    struct undoInfo *ui = vptr;
+    if (!ui)
+        return;
+    SNMP_FREE(ui->ptr);
+    SNMP_FREE(ui);
+}
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** Initialize the adslAlarmConfProfileExtTable table by defining its contents
+	and how it's structured */
+void
+initialize_table_adslAlarmConfProfileExtTable(void)
+{
+    static oid      adslAlarmConfProfileExtTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 3, 1, 23 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+       netsnmp_create_handler_registration("adslAlarmConfProfileExtTable",
+                                           adslAlarmConfProfileExtTable_handler,
+                                            adslAlarmConfProfileExtTable_oid,
+                                            OID_LENGTH
+                                            (adslAlarmConfProfileExtTable_oid),
+                                            HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo) {
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+
+        snmp_log(LOG_ERR,
+           "malloc failed in initialize_table_adslAlarmConfProfileExtTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_OCTET_STR,
+                                   /** index: adslLineAlarmConfProfileName */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 5;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAlarmConfProfileExtTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        adslAlarmConfProfileExtTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAlarmConfProfileExtTable_context_convert_function;
+    iinfo->free_data_context = adslAlarmConfProfileExtTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAlarmConfProfileExtTable_loop_free;
+    iinfo->free_loop_context_at_end =
+        adslAlarmConfProfileExtTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAlarmConfProfileExtTable",
+    "Registering table adslAlarmConfProfileExtTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAlarmConfProfileExtTable module */
+void
+init_adslAlarmConfProfileExtTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAlarmConfProfileExtTable();
+}
+
+/** handles requests for the adslAlarmConfProfileExtTable table, if anything
+    else needs to be done */
+int
+adslAlarmConfProfileExtTable_handler(netsnmp_mib_handler *handler,
+                                     netsnmp_handler_registration *reginfo,
+                                     netsnmp_agent_request_info *reqinfo,
+                                     netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+    oid            *suffix;
+    size_t          suffix_len;
+
+    /** column and row index encoded portion */
+    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
+    suffix_len = requests->requestvb->name_length -
+        (reginfo->rootoid_len + 1);
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+        case MODE_SET_RESERVE1:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+            break;
+
+        default:               /* == the other SET modes */
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+            break;
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_ADSLATUCTHRESHOLD15MINFAILEDFASTR:
+            case COLUMN_ADSLATUCTHRESHOLD15MINSESL:
+            case COLUMN_ADSLATUCTHRESHOLD15MINUASL:
+            case COLUMN_ADSLATURTHRESHOLD15MINSESL:
+            case COLUMN_ADSLATURTHRESHOLD15MINUASL:
+                {
+                    u_int32           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslExtThresholdValues(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+ "problem encountered in adslAlarmConfProfileExtTable_handler:unknown colmn\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+
+            if (!ci) {
+                    /** create the commit storage info */
+                ci = SNMP_MALLOC_STRUCT(commitInfo);
+                if (!data_context) {
+                    ci->data_context =
+                        adslAlarmConfProfileExtTable_create_data_context
+                        (table_info->indexes);
+                    ci->new_row = 1;
+                } else {
+                    ci->data_context = data_context;
+                }
+                netsnmp_oid_stash_add_data(&commitStorage,
+                                           suffix + 1, suffix_len - 1, ci);
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            switch (table_info->colnum) {
+            case COLUMN_ADSLATUCTHRESHOLD15MINFAILEDFASTR:
+            case COLUMN_ADSLATUCTHRESHOLD15MINSESL:
+            case COLUMN_ADSLATUCTHRESHOLD15MINUASL:
+            case COLUMN_ADSLATURTHRESHOLD15MINSESL:
+            case COLUMN_ADSLATURTHRESHOLD15MINUASL:
+                {
+                    u_int32           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslExtThresholdValues(ci->data_context, &retval_len,
+					table_info->colnum);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslExtThresholdValues(request->
+                                                     requestvb->
+                                                     type,
+                                                     (long *)
+                                                     request->
+                                                     requestvb->
+                                                     val.string,
+                                                     request->
+                                                     requestvb->
+                                                     val_len,
+                                                     (long *) retval,
+                                                     retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslAlarmConfProfileExtTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+
+            default:
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_ERR_NOTWRITABLE);
+                break;
+            }
+            break;
+
+        case MODE_SET_ACTION:
+            /** save a variable copy */
+            switch (table_info->colnum) {
+            case COLUMN_ADSLATUCTHRESHOLD15MINFAILEDFASTR:
+            case COLUMN_ADSLATUCTHRESHOLD15MINSESL:
+            case COLUMN_ADSLATUCTHRESHOLD15MINUASL:
+            case COLUMN_ADSLATURTHRESHOLD15MINSESL:
+            case COLUMN_ADSLATURTHRESHOLD15MINUASL:
+                {
+                    int             ret;
+                    ret =
+                        set_adslExtThresholdValues(ci->data_context,
+                                            (long *) request->requestvb->val.string,
+                                            request->requestvb->val_len,
+					    table_info->colnum);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+		break;
+
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            if (!ci->have_committed) {
+                    /** do this once per row only */
+                adslAlarmConfProfileExtTable_commit_row(&ci->data_context,
+                                                        ci->new_row);
+                ci->have_committed = 1;
+            }
+            break;
+
+        case MODE_SET_UNDO:
+             /** save a variable copy */
+            switch (table_info->colnum) {
+            case COLUMN_ADSLATUCTHRESHOLD15MINFAILEDFASTR:
+            case COLUMN_ADSLATUCTHRESHOLD15MINSESL:
+            case COLUMN_ADSLATUCTHRESHOLD15MINUASL:
+            case COLUMN_ADSLATURTHRESHOLD15MINSESL:
+            case COLUMN_ADSLATURTHRESHOLD15MINUASL:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslExtThresholdValues(ci->data_context,
+                                                   ui->ptr, ui->len,
+						   table_info->colnum);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+
+            }
+            break;
+
+        case MODE_SET_FREE:
+            break;
+
+        default:
+            snmp_log(LOG_ERR,
+ "prob encountered in adslAlarmConfProfileExtTable_handler:unsupported mode\n");
+        }
+    }
+
+    /** clean up after all requset processing has ended */
+    switch (reqinfo->mode) {
+    case MODE_SET_UNDO:
+    case MODE_SET_FREE:
+    case MODE_SET_COMMIT:
+        /** clear out the undo cache */
+        netsnmp_oid_stash_free(&undoStorage,
+                               adslAlarmConfProfileExtTable_free_undoInfo);
+        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable.h open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable.h	2009-12-16 12:59:15.000000000 +0530
@@ -0,0 +1,90 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAlarmConfProfileExtTable.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                1) Include files
+ *                2) Init Function proto-types for
+ *					 adslAlarmConfProfileExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLALARMCONFPROFILEEXTTABLE_H
+#define ADSLALARMCONFPROFILEEXTTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/** other required module components */
+config_require(adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_access)
+	
+/*
+ * column number definitions for table adslAlarmConfProfileExtTable
+ */
+#include "adslAlarmConfProfileExtTable_columns.h"
+
+/*
+ * enum definions
+ */
+#include "adslAlarmConfProfileExtTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+    /*
+     * function declarations
+     */
+     void            init_adslAlarmConfProfileExtTable(void);
+     void            initialize_table_adslAlarmConfProfileExtTable(void);
+     Netsnmp_Node_Handler adslAlarmConfProfileExtTable_handler;
+
+
+
+
+#endif /** ADSLALARMCONFPROFILEEXTTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_access.c	2009-12-16 12:59:15.000000000 +0530
@@ -0,0 +1,447 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAlarmConfProfileExtTable_access.c
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) for data
+ *                  in table adslAlarmConfProfileExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAlarmConfProfileExtTable_access.h"
+#include "adslAlarmConfProfileExtTable_enums.h"
+
+/* column number definitions for table adslAlarmConfProfileExtTable */
+#include "adslAlarmConfProfileExtTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+/* Global decalarations */
+static u_int32 long_ret;
+
+#ifndef ENABLE_DRIVER_CALL
+
+  u_int32 adslAtucThreshold15MinFailedFastR = 20;
+  u_int32 adslAtucThreshold15MinSesL = 30;
+  u_int32 adslAtucThreshold15MinUasL = 40;
+  u_int32 adslAturThreshold15MinSesL = 50;
+  u_int32 adslAturThreshold15MinUasL = 60;
+
+#endif
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** returns the first data point within the adslAlarmConfProfileExtTable
+	table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAlarmConfProfileExtTable_get_first_data_point(void **my_loop_context,
+                                                  void **my_data_context,
+                                                  netsnmp_variable_list *
+                                                  put_index_data,
+                                                  netsnmp_iterator_info
+                                                  *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+        "Get-First: adslAlarmConfProfileExtTable: malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslAlarmTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAlarmConfProfileExtTable_get_first_data_point,
+    but my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAlarmConfProfileExtTable_get_next_data_point(void **my_loop_context,
+                                                 void **my_data_context,
+                                                 netsnmp_variable_list *
+                                                 put_index_data,
+                                                 netsnmp_iterator_info
+                                                 *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+        "Get-Next: adslAlarmConfProfileExtTable: malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslAlarmTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** Create a data_context for non-existent rows that SETs are performed on.
+ *  return a void * pointer which will be passed to subsequent get_XXX
+ *  and set_XXX functions for data retrival and modification during
+ *  this SET request.
+ *
+ *  The indexs are encoded (in order) into the index_data pointer if it
+ *  would be helpful to use that information.
+ */
+void           *
+adslAlarmConfProfileExtTable_create_data_context(netsnmp_variable_list *
+                                                 index_data)
+{
+    return NULL;            /* XXX: you likely want to return a real pointer */
+}
+
+/** If the implemented set_* functions don't operate directly on the
+   real-live data (which is actually recommended), then this function
+   can be used to take a given my_data_context pointer and "commit" it
+   to whereever the modified data needs to be put back to.  For
+   example, if this was a routing table you could publish the modified
+   routes back into the kernel at this point.
+
+   new_or_del will be set to 1 if new, or -1 if it should be deleted
+   or 0 if it is just a modification of an existing row.
+
+   If you free the data yourself, make sure to *my_data_context = NULL */
+int
+adslAlarmConfProfileExtTable_commit_row(void **my_data_context,
+                                        int new_or_del)
+{
+    /** Add any necessary commit code here */
+
+
+    /*
+     * return no errors.  And there shouldn't be any!!!  Ever!!!  You
+     * should have checked the values long before this.
+     */
+    return SNMP_ERR_NOERROR;
+}
+
+
+/** Decides if an incoming value for the adslAtucThreshold15MinFailedFastR
+    mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslExtThresholdValues(int type, long *val,
+                             size_t val_len, long *old_val,
+                             size_t old_val_len)
+{
+
+    /** Check to see that we were called legally */
+    if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+    if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+    if (!(*val >= 0 && *val <= 900))
+	return SNMP_ERR_WRONGVALUE;
+
+    /** looks ok, */
+        return SNMP_ERR_NOERROR;
+
+}
+
+
+
+u_int32           *
+get_adslExtThresholdValues(void *data_context, size_t * ret_len, 
+				unsigned int var)
+{
+    unsigned int flags = 0;
+    struct adslLineAlarmConfProfileExtEntry adslLineAlarmConfProExtStruct;
+    memset(&adslLineAlarmConfProExtStruct, 0, sizeof(adslLineAlarmConfProExtStruct));
+    strcpy(adslLineAlarmConfProExtStruct.adslLineAlarmConfProfileExtName, (char *)data_context);
+
+    switch (var) {
+
+            case COLUMN_ADSLATUCTHRESHOLD15MINFAILEDFASTR:
+		flags = ATUC_THRESH_15MIN_FAILED_FASTR_FLAG;
+		break;
+		
+            case COLUMN_ADSLATUCTHRESHOLD15MINSESL:
+		flags = ATUC_THRESH_15MIN_SESL_FLAG;
+		break;
+		
+            case COLUMN_ADSLATUCTHRESHOLD15MINUASL:
+		flags = ATUC_THRESH_15MIN_UASL_FLAG;
+		break;
+		
+            case COLUMN_ADSLATURTHRESHOLD15MINSESL:
+		flags = ATUR_THRESH_15MIN_SESL_FLAG;
+		break;
+		
+            case COLUMN_ADSLATURTHRESHOLD15MINUASL:
+		flags = ATUR_THRESH_15MIN_UASL_FLAG;
+		break;
+
+	    default:
+     		DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     		break;
+    }
+
+    SET_FLAG(&adslLineAlarmConfProExtStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+   adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF_EXT,
+   			(void *) &adslLineAlarmConfProExtStruct);
+#else
+    adslLineAlarmConfProfileExtTable(Fd, GET_ADSL_ALRM_CONF_PROF_EXT,
+            		(void *) &adslLineAlarmConfProExtStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProExtStruct.flags, flags) == 0)
+     	DEBUGMSGTL(("adslMIB-Line", "adslLineAlarmConfProfileExtTable GET- %x CMV fail\n", flags));
+    
+    switch (flags)  {
+	    
+     case ATUC_THRESH_15MIN_FAILED_FASTR_FLAG:
+        long_ret = adslLineAlarmConfProExtStruct.adslAtucThreshold15MinFailedFastR;
+	break;
+	
+     case ATUC_THRESH_15MIN_SESL_FLAG:
+        long_ret = adslLineAlarmConfProExtStruct.adslAtucThreshold15MinSesL;
+	break;
+	
+     case ATUC_THRESH_15MIN_UASL_FLAG:
+        long_ret = adslLineAlarmConfProExtStruct.adslAtucThreshold15MinUasL;
+	break;
+
+     case ATUR_THRESH_15MIN_SESL_FLAG:
+        long_ret = adslLineAlarmConfProExtStruct.adslAturThreshold15MinSesL;
+	break;
+
+     case ATUR_THRESH_15MIN_UASL_FLAG:
+        long_ret = adslLineAlarmConfProExtStruct.adslAturThreshold15MinUasL;
+	break;
+	
+     default:
+     DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     return NULL;
+   }
+  
+    CLR_FLAG(&adslLineAlarmConfProExtStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+
+int 
+set_adslExtThresholdValues(void *data_context, long *val, 
+		size_t val_len, unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslLineAlarmConfProfileExtEntry adslLineAlarmConfProExtStruct;
+  memset(&adslLineAlarmConfProExtStruct, 0, sizeof(adslLineAlarmConfProExtStruct));
+  strcpy(adslLineAlarmConfProExtStruct.adslLineAlarmConfProfileExtName, (char *)data_context);
+    
+  switch (var) {
+     case COLUMN_ADSLATUCTHRESHOLD15MINFAILEDFASTR:
+    	flags = ATUC_THRESH_15MIN_FAILED_FASTR_FLAG;
+    	adslLineAlarmConfProExtStruct.adslAtucThreshold15MinFailedFastR = *val;
+	break;
+	
+     case COLUMN_ADSLATUCTHRESHOLD15MINSESL:
+    	flags =  ATUC_THRESH_15MIN_SESL_FLAG;
+    	adslLineAlarmConfProExtStruct.adslAtucThreshold15MinSesL = *val;
+	break;
+	
+     case COLUMN_ADSLATUCTHRESHOLD15MINUASL:
+    	flags =  ATUC_THRESH_15MIN_UASL_FLAG;
+    	adslLineAlarmConfProExtStruct.adslAtucThreshold15MinUasL = *val;
+	break;
+
+     case COLUMN_ADSLATURTHRESHOLD15MINSESL:
+        flags = ATUR_THRESH_15MIN_SESL_FLAG;
+    	adslLineAlarmConfProExtStruct.adslAturThreshold15MinSesL = *val;
+	break;
+
+     case COLUMN_ADSLATURTHRESHOLD15MINUASL:
+        flags = ATUR_THRESH_15MIN_UASL_FLAG;
+    	adslLineAlarmConfProExtStruct.adslAturThreshold15MinUasL = *val;
+	break;
+
+     default:
+     	DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	return SNMP_ERR_NOSUCHNAME;
+   }
+  
+   SET_FLAG(&adslLineAlarmConfProExtStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+   adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF_EXT,
+   			(void *) &adslLineAlarmConfProExtStruct);
+#else
+    adslLineAlarmConfProfileExtTable(Fd, SET_ADSL_ALRM_CONF_PROF_EXT,
+            		(void *) &adslLineAlarmConfProExtStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProExtStruct.flags, flags) == 0) {
+     	DEBUGMSGTL(("adslMIB-Line", "adslLineAlarmConfProfileExtTable SET- %x CMV fail\n", flags));
+    	CLR_FLAG(&adslLineAlarmConfProExtStruct.flags, flags);
+        return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+    	CLR_FLAG(&adslLineAlarmConfProExtStruct.flags, flags);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+
+#ifndef ENABLE_DRIVER_CALL
+int adslLineAlarmConfProfileExtTable(int Fd2, int ADSL_ALRM_CONF_PROF2,
+            void *adslLineAlarmExtStruct)
+{
+    struct adslLineAlarmConfProfileExtEntry *adslLineAlarmExtValue;
+   adslLineAlarmExtValue = (adslLineAlarmConfProfileExtEntry *)
+   										adslLineAlarmExtStruct;
+    if (ADSL_ALRM_CONF_PROF2 == GET_ADSL_ALRM_CONF_PROF_EXT)
+    {
+
+    adslLineAlarmExtValue->adslAtucThreshold15MinFailedFastR =
+    adslAtucThreshold15MinFailedFastR;
+    adslLineAlarmExtValue->adslAtucThreshold15MinSesL =
+    adslAtucThreshold15MinSesL;
+    adslLineAlarmExtValue->adslAtucThreshold15MinUasL =
+    adslAtucThreshold15MinUasL;
+    adslLineAlarmExtValue->adslAturThreshold15MinSesL =
+    adslAturThreshold15MinSesL;
+    adslLineAlarmExtValue->adslAturThreshold15MinUasL =
+    adslAturThreshold15MinUasL;
+
+    }
+    else if (ADSL_ALRM_CONF_PROF2 == SET_ADSL_ALRM_CONF_PROF_EXT) {
+
+   if (IS_FLAG_SET(&adslLineAlarmExtValue->flags,
+   ATUC_THRESH_15MIN_FAILED_FASTR_FLAG ) != 0)
+   adslAtucThreshold15MinFailedFastR = adslLineAlarmExtValue->
+   adslAtucThreshold15MinFailedFastR;
+
+   if (IS_FLAG_SET(&adslLineAlarmExtValue->flags,
+   ATUC_THRESH_15MIN_SESL_FLAG) != 0)
+   adslAtucThreshold15MinSesL = adslLineAlarmExtValue->
+   adslAtucThreshold15MinSesL;
+
+   if (IS_FLAG_SET(&adslLineAlarmExtValue->flags,
+   ATUC_THRESH_15MIN_UASL_FLAG) != 0)
+   adslAtucThreshold15MinUasL = adslLineAlarmExtValue->
+   adslAtucThreshold15MinUasL;
+
+  if (IS_FLAG_SET(&adslLineAlarmExtValue->flags,
+  ATUR_THRESH_15MIN_SESL_FLAG) != 0)
+  adslAturThreshold15MinSesL  = adslLineAlarmExtValue->
+  adslAturThreshold15MinSesL ;
+
+  if (IS_FLAG_SET(&adslLineAlarmExtValue->flags,
+  ATUR_THRESH_15MIN_UASL_FLAG) != 0)
+  adslAturThreshold15MinUasL = adslLineAlarmExtValue->
+  adslAturThreshold15MinUasL;
+
+ }
+
+return 0;
+}
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_access.h	2009-12-16 12:59:15.000000000 +0530
@@ -0,0 +1,125 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAlarmConfProfileExtTable_access.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *              1)  Include files
+ *              2)  User defined data types
+ *              3)  Function proto-types for adslAlarmConfProfileExtTable
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+#ifndef ADSLALARMCONFPROFILEEXTTABLE_ACCESS_H
+#define ADSLALARMCONFPROFILEEXTTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+
+#ifdef STUB_IOCTL
+/* Data structures */
+
+typedef struct adslLineAlarmConfProfileExtEntry
+ {
+  unsigned char adslLineAlarmConfProfileExtName[32];
+  u_int32 adslAtucThreshold15MinFailedFastR;
+  u_int32 adslAtucThreshold15MinSesL;
+  u_int32 adslAtucThreshold15MinUasL;
+  u_int32 adslAturThreshold15MinSesL;
+  u_int32 adslAturThreshold15MinUasL;
+  u_int32	flags;
+} adslLineAlarmConfProfileExtEntry;
+
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/** User-defined data access functions for data in table
+    adslAlarmConfProfileExtTable */
+
+/** row level accessors */
+Netsnmp_First_Data_Point adslAlarmConfProfileExtTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAlarmConfProfileExtTable_get_next_data_point;
+
+int             adslAlarmConfProfileExtTable_commit_row(void
+                                                        **my_data_context,
+                                                        int new_or_del);
+void
+    *adslAlarmConfProfileExtTable_create_data_context(netsnmp_variable_list
+                                                      * index_data);
+
+/** column accessors */
+int
+check_adslExtThresholdValues(int type, long *val,
+                             size_t val_len, long *old_val,
+                             size_t old_val_len);
+
+u_int32           *
+get_adslExtThresholdValues(void *data_context, size_t * ret_len, 
+				unsigned int var);
+
+int 
+set_adslExtThresholdValues(void *data_context, long *val, 
+		size_t val_len, unsigned int var);
+
+
+#ifndef ENABLE_DRIVER_CALL
+int adslLineAlarmConfProfileExtTable(int Fd2, int ADSL_ALRM_CONF_PROF2,
+            void *adslLineAlarmExtStruct);
+#endif
+
+#endif                          /* ADSLALARMCONFPROFILEEXTTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_columns.h	2009-12-16 12:59:15.000000000 +0530
@@ -0,0 +1,62 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAlarmConfProfileExtTable_columns.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:  column number definitions for
+ *            adslAlarmConfProfileExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLALARMCONFPROFILEEXTTABLE_COLUMNS_H
+#define ADSLALARMCONFPROFILEEXTTABLE_COLUMNS_H
+
+/*
+ * column number definitions for table adslAlarmConfProfileExtTable
+ */
+#define COLUMN_ADSLATUCTHRESHOLD15MINFAILEDFASTR		1
+#define COLUMN_ADSLATUCTHRESHOLD15MINSESL		2
+#define COLUMN_ADSLATUCTHRESHOLD15MINUASL		3
+#define COLUMN_ADSLATURTHRESHOLD15MINSESL		4
+#define COLUMN_ADSLATURTHRESHOLD15MINUASL		5
+#endif                          /* ADSLALARMCONFPROFILEEXTTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable_enums.h	2009-12-16 12:59:15.000000000 +0530
@@ -0,0 +1,70 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAlarmConfProfileExtTable_enums.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:  Constant definitions for table adslAlarmConfProfileExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLALARMCONFPROFILEEXTTABLE_ENUMS_H
+#define ADSLALARMCONFPROFILEEXTTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+
+/* adslAlarmConfProfileExtTable constants */
+#define GET_ADSL_ALRM_CONF_PROF_EXT 235
+#define SET_ADSL_ALRM_CONF_PROF_EXT 236
+
+
+/* adslAlarmConfProfileExtTable */
+#define ATUC_THRESH_15MIN_FAILED_FASTR_FLAG 0X1/* BIT 0th position */
+#define ATUC_THRESH_15MIN_SESL_FLAG		 0X2 /* BIT 1 */
+#define ATUC_THRESH_15MIN_UASL_FLAG		 0X4 /* BIT 2 */
+#define ATUR_THRESH_15MIN_SESL_FLAG		 0X8 /* BIT 3 */
+#define ATUR_THRESH_15MIN_UASL_FLAG		 0X10 /* BIT 4 */
+
+
+#endif
+
+#endif                          /* ADSLALARMCONFPROFILEEXTTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable.c open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable.c	2009-12-16 12:59:16.000000000 +0530
@@ -0,0 +1,317 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanIntervalTable.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslAtucChanIntervalTable module
+ *               2) Handling requests for the adslAtucChanIntervalTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *  subramani: Changed the COLUMN_ADSLATUCCHANINTERVALVALIDDATA data type from
+ *             long to int
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucChanIntervalTable.h"
+#include "adslAtucChanIntervalTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+/** Initialize the adslAtucChanIntervalTable table by defining its contents and
+    how it's structured */
+void
+initialize_table_adslAtucChanIntervalTable(void)
+{
+    static oid      adslAtucChanIntervalTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 12 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAtucChanIntervalTable",
+                                            adslAtucChanIntervalTable_handler,
+                                            adslAtucChanIntervalTable_oid,
+                                            OID_LENGTH
+                                            (adslAtucChanIntervalTable_oid),
+                                            HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,\
+                 "malloc failed in initialize_table_adslAtucChanIntervalTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     ASN_INTEGER,
+                                       /** index: adslAtucChanIntervalNumber */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 2;
+    table_info->max_column = 6;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAtucChanIntervalTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        adslAtucChanIntervalTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAtucChanIntervalTable_context_convert_function;
+    iinfo->free_data_context = adslAtucChanIntervalTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAtucChanIntervalTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAtucChanIntervalTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAtucChanIntervalTable",\
+          "Registering table adslAtucChanIntervalTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAtucChanIntervalTable module */
+void
+init_adslAtucChanIntervalTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAtucChanIntervalTable();
+}
+
+/** handles requests for the adslAtucChanIntervalTable table, if anything else
+    needs to be done */
+int
+adslAtucChanIntervalTable_handler(netsnmp_mib_handler *handler,
+                                  netsnmp_handler_registration *reginfo,
+                                  netsnmp_agent_request_info *reqinfo,
+                                  netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+     long IntervalNum = 0;
+     struct commitInfo *ci = NULL;
+     void           *data_context = NULL;
+
+    IntervalNum = *(requests->requestvb->name + reginfo->rootoid_len + 3);
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+
+            case COLUMN_ADSLATUCCHANINTERVALRECEIVEDBLKS:
+            case COLUMN_ADSLATUCCHANINTERVALTRANSMITTEDBLKS:
+            case COLUMN_ADSLATUCCHANINTERVALCORRECTEDBLKS:
+            case COLUMN_ADSLATUCCHANINTERVALUNCORRECTBLKS:
+                {
+                    u_int32 *retval;
+                    size_t  retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucChanIntervalData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                        (const u_char *) retval, retval_len);
+                }
+                break;
+#else
+            case COLUMN_ADSLATUCCHANINTERVALRECEIVEDBLKS:
+                {
+                    u_int32  *retval;
+                    size_t   retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucChanIntervalReceivedBlks(data_context,
+                                                             &retval_len);
+              snmp_set_var_typed_value(var, ASN_GAUGE, (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANINTERVALTRANSMITTEDBLKS:
+                {
+                    u_int32  *retval;
+                    size_t   retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucChanIntervalTransmittedBlks
+                        (data_context, &retval_len);
+              snmp_set_var_typed_value(var, ASN_GAUGE, (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANINTERVALCORRECTEDBLKS:
+                {
+                    u_int32  *retval;
+                    size_t   retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucChanIntervalCorrectedBlks(data_context,
+                                                              &retval_len);
+              snmp_set_var_typed_value(var, ASN_GAUGE, (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANINTERVALUNCORRECTBLKS:
+                {
+                    u_int32  *retval;
+                    size_t  retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucChanIntervalUncorrectBlks(data_context,
+                                                              &retval_len);
+               snmp_set_var_typed_value(var, ASN_GAUGE, (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+#endif
+            case COLUMN_ADSLATUCCHANINTERVALVALIDDATA:
+                {
+                      int           *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucChanIntervalValidData(data_context,
+                                                          &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,\
+                    "adslAtucChanIntervalTable_handler: unknown column\n");
+            }
+            break;
+
+        default:
+            snmp_log(LOG_ERR,\
+                     " adslAtucChanIntervalTable_handler: unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable.h	2009-12-16 12:59:16.000000000 +0530
@@ -0,0 +1,84 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanIntervalTable.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                    1) Include files
+ *                    2) Init Function proto-types for adslAtucIntervalTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATUCCHANINTERVALTABLE_H
+#define ADSLATUCCHANINTERVALTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/** other required module components */
+config_require(adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_access)
+
+/* column number definitions for table adslAtucChanIntervalTable */
+#include "adslAtucChanIntervalTable_columns.h"
+
+/* enum definions */
+#include "adslAtucChanIntervalTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/* function declarations */
+ void            init_adslAtucChanIntervalTable(void);
+ void            initialize_table_adslAtucChanIntervalTable(void);
+ Netsnmp_Node_Handler adslAtucChanIntervalTable_handler;
+
+
+
+
+#endif /** ADSLATUCCHANINTERVALTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_access.c	2009-12-16 12:59:16.000000000 +0530
@@ -0,0 +1,428 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanIntervalTable_access.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) for data
+ *                  in table adslAtucChanIntervalTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *  Subramani:1) Changed the COLUMN_ADSLATUCCHANINTERVALVALIDDATA return type
+ *            from long to int
+ *            2) Chnaged the data type of static variable long_ret from long
+ *               to u_int32
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucChanIntervalTable_access.h"
+#include "adslAtucChanIntervalTable_enums.h"
+
+/* column number definitions for table adslAtucChanIntervalTable */
+#include "adslAtucChanIntervalTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+// *** Global variable definitions
+static u_int32 long_ret;
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** returns the first data point within the adslAtucChanIntervalTable table
+    data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAtucChanIntervalTable_get_first_data_point(void **my_loop_context,
+                                               void **my_data_context,
+                                               netsnmp_variable_list *
+                                               put_index_data,
+                                               netsnmp_iterator_info
+                                               *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-First: adslAtucChanIntervalTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAtucChanIntervalTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAtucChanIntervalTable_get_next_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-Next: adslAtucChanIntervalTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+/*
+ * User-defined data access functions (per column) for data in table
+ * adslAtucChanIntervalTable
+ */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+#if defined(HAVE_OPTIMIZED_CODE)
+
+u_int32  *
+get_adslAtucChanIntervalData(void *data_context, size_t * ret_len, 
+		unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslAtucChanIntvlInfo adslAtucChanIntvlStruct;
+  memset(&adslAtucChanIntvlStruct,0,sizeof(adslAtucChanIntvlInfo));
+  adslAtucChanIntvlStruct.ifIndex= (*(int *)data_context);
+  adslAtucChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+   
+  switch (var) {
+
+    case COLUMN_ADSLATUCCHANINTERVALRECEIVEDBLKS:
+  	flags = ATUC_CHAN_INTVL_RECV_BLK_FLAG;
+        break;
+	
+    case COLUMN_ADSLATUCCHANINTERVALTRANSMITTEDBLKS:
+	flags = ATUC_CHAN_INTVL_TX_BLK_FLAG;
+	break;
+	
+    case COLUMN_ADSLATUCCHANINTERVALCORRECTEDBLKS:
+	flags = ATUC_CHAN_INTVL_CORR_BLK_FLAG;
+	break;
+	
+    case COLUMN_ADSLATUCCHANINTERVALUNCORRECTBLKS:
+	flags = ATUC_CHAN_INTVL_UNCORR_BLK_FLAG;
+	break;
+
+    default:
+        DEBUGMSGTL(("Unknown MIB variable requested!","\n"));
+        return NULL;
+  }
+
+  SET_FLAG(&adslAtucChanIntvlStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+  adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO, &adslAtucChanIntvlStruct);
+#else
+  get_adslAtucChanIntervalTable(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO,
+        (void *) &adslAtucChanIntvlStruct);
+#endif
+  if (IS_FLAG_SET(&adslAtucChanIntvlStruct.flags,flags) == 0) 
+    DEBUGMSGTL(("adslMIB-ATUC", "ChanIntervalTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+
+	 case ATUC_CHAN_INTVL_RECV_BLK_FLAG:
+    	    long_ret = adslAtucChanIntvlStruct.chanIntervalRecvdBlks;
+            break;
+	 
+	 case ATUC_CHAN_INTVL_TX_BLK_FLAG:
+    	    long_ret = adslAtucChanIntvlStruct.chanIntervalXmitBlks;
+	    break;
+	  
+	 case ATUC_CHAN_INTVL_CORR_BLK_FLAG:
+    	    long_ret = adslAtucChanIntvlStruct.chanIntervalCorrectedBlks;
+	    break;
+	  
+	 case ATUC_CHAN_INTVL_UNCORR_BLK_FLAG:
+    	    long_ret = adslAtucChanIntvlStruct.chanIntervalUncorrectBlks;
+	    break;
+	  
+         default:
+            DEBUGMSGTL(("Unknown MIB variable requested!","\n"));
+            return NULL;
+     }
+
+    CLR_FLAG(&adslAtucChanIntvlStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+#else
+
+/** XXX:return a data pointer to the data for the
+    adslAtucChanIntervalReceivedBlks column and set ret_len to its proper size
+    in bytes. */
+u_int32  *
+get_adslAtucChanIntervalReceivedBlks(void *data_context, size_t * ret_len)
+{
+    struct adslAtucChanIntvlInfo adslAtucChanIntvlStruct;
+
+    memset(&adslAtucChanIntvlStruct,0,sizeof(adslAtucChanIntvlInfo));
+    adslAtucChanIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAtucChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_RECV_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO, &adslAtucChanIntvlStruct);
+#else
+    get_adslAtucChanIntervalTable(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO,
+    (void *) &adslAtucChanIntvlStruct);
+#endif
+
+  if (IS_FLAG_SET(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_RECV_BLK_FLAG)) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanIntvlRecvBlk CMV fail\n"));
+  
+  CLR_FLAG(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_RECV_BLK_FLAG);
+  long_ret = adslAtucChanIntvlStruct.chanIntervalRecvdBlks;
+  *ret_len = sizeof(adslAtucChanIntvlStruct.chanIntervalRecvdBlks);
+  return (u_int32 *) &long_ret;
+}
+
+/** XXX:return a data pointer to the data for the
+    adslAtucChanIntervalTransmittedBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32  *
+get_adslAtucChanIntervalTransmittedBlks(void *data_context,
+                                         size_t * ret_len)
+{
+    struct adslAtucChanIntvlInfo adslAtucChanIntvlStruct;
+
+    memset(&adslAtucChanIntvlStruct,0,sizeof(adslAtucChanIntvlInfo));
+    adslAtucChanIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAtucChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_TX_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO, &adslAtucChanIntvlStruct);
+#else
+    get_adslAtucChanIntervalTable(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO,(void *) &
+    adslAtucChanIntvlStruct);
+#endif
+
+   if (IS_FLAG_SET(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_TX_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanIntvlTxBlk CMV fail\n"));
+
+    CLR_FLAG(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_TX_BLK_FLAG);
+    long_ret = adslAtucChanIntvlStruct.chanIntervalXmitBlks;
+    *ret_len = sizeof(adslAtucChanIntvlStruct.chanIntervalXmitBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanIntervalCorrectedBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32  *
+get_adslAtucChanIntervalCorrectedBlks(void *data_context,
+                                       size_t * ret_len)
+{
+    struct adslAtucChanIntvlInfo adslAtucChanIntvlStruct;
+
+    memset(&adslAtucChanIntvlStruct,0,sizeof(adslAtucChanIntvlInfo));
+    adslAtucChanIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAtucChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_CORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO, &adslAtucChanIntvlStruct);
+#else
+    get_adslAtucChanIntervalTable(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO,(void *) &
+    adslAtucChanIntvlStruct);
+#endif
+
+    if (IS_FLAG_SET(&adslAtucChanIntvlStruct.flags,
+    	ATUC_CHAN_INTVL_CORR_BLK_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanIntvlCorrBlk CMV fail\n"));
+
+
+    CLR_FLAG(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_CORR_BLK_FLAG);
+    long_ret = adslAtucChanIntvlStruct.chanIntervalCorrectedBlks;
+    *ret_len = sizeof(adslAtucChanIntvlStruct.chanIntervalCorrectedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanIntervalUncorrectBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32  *
+get_adslAtucChanIntervalUncorrectBlks(void *data_context,
+                                       size_t * ret_len)
+{
+    struct adslAtucChanIntvlInfo adslAtucChanIntvlStruct;
+
+    memset(&adslAtucChanIntvlStruct,0,sizeof(adslAtucChanIntvlInfo));
+    adslAtucChanIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAtucChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_UNCORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO, &adslAtucChanIntvlStruct);
+#else
+    get_adslAtucChanIntervalTable(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO,(void *) &
+    adslAtucChanIntvlStruct);
+#endif
+
+    if (IS_FLAG_SET(&adslAtucChanIntvlStruct.flags,
+    	ATUC_CHAN_INTVL_UNCORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanIntvlUnCorrBlk CMV fail\n"));
+
+
+    CLR_FLAG(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_UNCORR_BLK_FLAG);
+    long_ret = adslAtucChanIntvlStruct.chanIntervalUncorrectBlks;
+    *ret_len = sizeof(adslAtucChanIntvlStruct.chanIntervalUncorrectBlks);
+    return (u_int32 *) &long_ret;
+}
+
+#endif
+
+/** XXX: return a data pointer to the data for the adslAtucChanIntervalValidData
+    column and set ret_len to its proper size in bytes. */
+int     *
+get_adslAtucChanIntervalValidData(void *data_context, size_t * ret_len)
+{
+    struct adslAtucChanIntvlInfo adslAtucChanIntvlStruct;
+
+    memset(&adslAtucChanIntvlStruct,0,sizeof(adslAtucChanIntvlInfo));
+    adslAtucChanIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAtucChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_VALID_DATA_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO, &adslAtucChanIntvlStruct);
+#else
+    get_adslAtucChanIntervalTable(Fd, GET_ADSL_ATUC_CHAN_INTVL_INFO,(void *) &
+    adslAtucChanIntvlStruct);
+#endif
+
+    if (IS_FLAG_SET(&adslAtucChanIntvlStruct.flags,
+    	ATUC_CHAN_INTVL_VALID_DATA_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanIntvlValidData CMV fail\n"));
+
+    CLR_FLAG(&adslAtucChanIntvlStruct.flags, ATUC_CHAN_INTVL_VALID_DATA_FLAG);
+    long_ret = adslAtucChanIntvlStruct.intervalValidData;
+    *ret_len = sizeof(adslAtucChanIntvlStruct.intervalValidData);
+    return (int *) &long_ret;
+}
+
+
+#ifndef ENABLE_DRIVER_CALL
+int  get_adslAtucChanIntervalTable(int Fd2,int GET_ADSL_atuc_CHAN_INTVL_INFO,
+      void *adslAtucChanIntvlTable)
+{
+    struct adslAtucChanIntvlInfo *adslAtucChanIntvlValue;
+    adslAtucChanIntvlValue = (adslAtucChanIntvlInfo *)adslAtucChanIntvlTable;
+    adslAtucChanIntvlValue->chanIntervalRecvdBlks = 10;
+    adslAtucChanIntvlValue->chanIntervalXmitBlks = 20;
+    adslAtucChanIntvlValue->chanIntervalCorrectedBlks = 30;
+    adslAtucChanIntvlValue->chanIntervalUncorrectBlks = 5;
+    adslAtucChanIntvlValue->intervalValidData = 1;
+    return 0;
+}
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_access.h	2009-12-16 12:59:16.000000000 +0530
@@ -0,0 +1,125 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanIntervalTable_access.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *              1)  Include files
+ *              2)  User defined data types
+ *              3)  Function proto-types for adslAtucChanIntervalTable_access
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+#ifndef ADSLATUCCHANINTERVALTABLE_ACCESS_H
+#define ADSLATUCCHANINTERVALTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+#include <adslMIB/adslTable_access.h>
+
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslAtucIntervalTable **/
+
+typedef u_int32 PerfIntervalCount;
+
+typedef struct adslAtucChanIntvlInfo {
+    int ifIndex;
+    int IntervalNumber;
+    PerfIntervalCount chanIntervalRecvdBlks;
+    PerfIntervalCount chanIntervalXmitBlks;
+    PerfIntervalCount chanIntervalCorrectedBlks;
+    PerfIntervalCount chanIntervalUncorrectBlks;
+    int intervalValidData;
+    u_char flags;
+} adslAtucChanIntvlInfo;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/** User-defined data access functions for data in table
+    adslAtucChanIntervalTable */
+
+/** row level accessors */
+Netsnmp_First_Data_Point adslAtucChanIntervalTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAtucChanIntervalTable_get_next_data_point;
+
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+u_int32  *
+get_adslAtucChanIntervalData(void *data_context, size_t * ret_len, 
+		unsigned int var);
+#else
+u_int32  *get_adslAtucChanIntervalReceivedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanIntervalTransmittedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanIntervalCorrectedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanIntervalUncorrectBlks(void *data_context,
+            size_t * ret_len);
+#endif
+
+int     *get_adslAtucChanIntervalValidData(void *data_context,
+            size_t * ret_len);
+
+#ifndef ENABLE_DRIVER_CALL
+int  get_adslAtucChanIntervalTable(int Fd2,int GET_ADSL_atuc_CHAN_INTVL_INFO,
+     void *adslAtucChanIntvlTable);
+#endif
+
+#endif                          /* ADSLATUCCHANINTERVALTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_columns.h	2009-12-16 12:59:16.000000000 +0530
@@ -0,0 +1,61 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanIntervalTable_columns.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: column number definitions for table adslAtucChanIntervalTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATUCCHANINTERVALTABLE_COLUMNS_H
+#define ADSLATUCCHANINTERVALTABLE_COLUMNS_H
+
+/*
+ * column number definitions for table adslAtucChanIntervalTable
+ */
+#define COLUMN_ADSLATUCCHANINTERVALNUMBER       1
+#define COLUMN_ADSLATUCCHANINTERVALRECEIVEDBLKS     2
+#define COLUMN_ADSLATUCCHANINTERVALTRANSMITTEDBLKS      3
+#define COLUMN_ADSLATUCCHANINTERVALCORRECTEDBLKS        4
+#define COLUMN_ADSLATUCCHANINTERVALUNCORRECTBLKS        5
+#define COLUMN_ADSLATUCCHANINTERVALVALIDDATA        6
+#endif                          /* ADSLATUCCHANINTERVALTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable_enums.h	2009-12-16 12:59:16.000000000 +0530
@@ -0,0 +1,69 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanIntervalTable_enums.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:  Constant definitions for table adslAtucChanIntervalTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATUCCHANINTERVALTABLE_ENUMS_H
+#define ADSLATUCCHANINTERVALTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAtucChanIntervalTable constants */
+#define GET_ADSL_ATUC_CHAN_INTVL_INFO   110
+
+/* adslAtucChanIntervalTable Flags */
+#define ATUC_CHAN_INTVL_NUM_FLAG            0x1     /* BIT 0th position */
+#define ATUC_CHAN_INTVL_RECV_BLK_FLAG       0x2     /* BIT 1 */
+#define ATUC_CHAN_INTVL_TX_BLK_FLAG         0x4     /* BIT 2 */
+#define ATUC_CHAN_INTVL_CORR_BLK_FLAG       0x8     /* BIT 3 */
+#define ATUC_CHAN_INTVL_UNCORR_BLK_FLAG     0x10    /* BIT 4 */
+#define ATUC_CHAN_INTVL_VALID_DATA_FLAG     0x20    /* BIT 5 */
+#endif
+
+/** enums for column adslAtucChanIntervalValidData **/
+#define ADSLATUCCHANINTERVALVALIDDATA_TRUE      1
+#define ADSLATUCCHANINTERVALVALIDDATA_FALSE     2
+
+#endif                          /* ADSLATUCCHANINTERVALTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable.c open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable.c	2009-12-16 12:59:16.000000000 +0530
@@ -0,0 +1,568 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanPerfDataTable.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslAtucChanPerfDataTable module
+ *               2) Handling requests for the adslAtucChanPerfDataTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *  Subramani: Data types of adslAtucChanPerfValidIntervals,
+ *  adslAtucChanPerfInvalidIntervals and adslAtucChanPerfPrev1DayMoniSecs are
+ *  changed from long to int
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucChanPerfDataTable.h"
+#include "adslAtucChanPerfDataTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+/** Initialize the adslAtucChanPerfDataTable table by defining its contents and
+     how it's structured */
+void
+initialize_table_adslAtucChanPerfDataTable(void)
+{
+    static oid      adslAtucChanPerfDataTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 10 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAtucChanPerfDataTable",
+                                            adslAtucChanPerfDataTable_handler,
+                                            adslAtucChanPerfDataTable_oid,
+                                            OID_LENGTH
+                                            (adslAtucChanPerfDataTable_oid),
+                                            HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,\
+                 "malloc failed in initialize_table_adslAtucChanPerfDataTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 21;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAtucChanPerfDataTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        adslAtucChanPerfDataTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAtucChanPerfDataTable_context_convert_function;
+    iinfo->free_data_context = adslAtucChanPerfDataTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAtucChanPerfDataTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAtucChanPerfDataTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAtucChanPerfDataTable",\
+    "Registering table adslAtucChanPerfDataTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAtucChanPerfDataTable module */
+void
+init_adslAtucChanPerfDataTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAtucChanPerfDataTable();
+}
+
+/** handles requests for the adslAtucChanPerfDataTable table, if anything else
+    needs to be done */
+int
+adslAtucChanPerfDataTable_handler(netsnmp_mib_handler *handler,
+                                  netsnmp_handler_registration *reginfo,
+                                  netsnmp_agent_request_info *reqinfo,
+                                  netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+	    case COLUMN_ADSLATUCCHANRECEIVEDBLKS:
+	    case COLUMN_ADSLATUCCHANTRANSMITTEDBLKS:
+	    case COLUMN_ADSLATUCCHANCORRECTEDBLKS:
+	    case COLUMN_ADSLATUCCHANUNCORRECTBLKS:
+		{
+                    u_int32         *retval;
+		    size_t          retval_len = 0;
+		    retval =
+		        get_adslAtucChanBlksData(data_context, &retval_len,
+		                        table_info->colnum);
+		    snmp_set_var_typed_value(var, ASN_COUNTER,												                            (const u_char *) retval, retval_len);
+		}
+		break;
+
+	    case COLUMN_ADSLATUCCHANPERFVALIDINTERVALS:
+	    case COLUMN_ADSLATUCCHANPERFINVALIDINTERVALS:
+	    case COLUMN_ADSLATUCCHANPERFPREV1DAYMONISECS:
+                {
+                    int           *retval;
+                    size_t         retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfIntervalData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                       (const u_char *) retval, retval_len);
+                }
+		break;
+
+	    case COLUMN_ADSLATUCCHANPERFCURR15MINTIMEELAPSED:
+	    case COLUMN_ADSLATUCCHANPERFCURR15MINRECEIVEDBLKS:
+	    case COLUMN_ADSLATUCCHANPERFCURR15MINTRANSMITTEDBLKS:
+	    case COLUMN_ADSLATUCCHANPERFCURR15MINCORRECTEDBLKS:
+	    case COLUMN_ADSLATUCCHANPERFCURR15MINUNCORRECTBLKS:
+	    case COLUMN_ADSLATUCCHANPERFCURR1DAYTIMEELAPSED:
+	    case COLUMN_ADSLATUCCHANPERFCURR1DAYRECEIVEDBLKS:
+	    case COLUMN_ADSLATUCCHANPERFCURR1DAYTRANSMITTEDBLKS:
+	    case COLUMN_ADSLATUCCHANPERFCURR1DAYCORRECTEDBLKS:
+	    case COLUMN_ADSLATUCCHANPERFCURR1DAYUNCORRECTBLKS:
+	    case COLUMN_ADSLATUCCHANPERFPREV1DAYRECEIVEDBLKS:
+	    case COLUMN_ADSLATUCCHANPERFPREV1DAYTRANSMITTEDBLKS:
+	    case COLUMN_ADSLATUCCHANPERFPREV1DAYCORRECTEDBLKS:
+	    case COLUMN_ADSLATUCCHANPERFPREV1DAYUNCORRECTBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfStatsData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                       (const u_char *) retval, retval_len);
+                }
+                break;
+
+#else
+            case COLUMN_ADSLATUCCHANRECEIVEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanReceivedBlks(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANTRANSMITTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanTransmittedBlks(data_context,
+                                                        &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANCORRECTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanCorrectedBlks(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANUNCORRECTBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanUncorrectBlks(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFVALIDINTERVALS:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfValidIntervals(data_context,
+                                                           &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFINVALIDINTERVALS:
+                {
+                     int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfInvalidIntervals(data_context,
+                                                             &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFCURR15MINTIMEELAPSED:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfCurr15MinTimeElapsed
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFCURR15MINRECEIVEDBLKS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfCurr15MinReceivedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                                (const u_char *) retval,
+                                                  retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFCURR15MINTRANSMITTEDBLKS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfCurr15MinTransmittedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                                (const u_char *) retval,
+                                                 retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFCURR15MINCORRECTEDBLKS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfCurr15MinCorrectedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                                (const u_char *) retval,
+                                                    retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFCURR15MINUNCORRECTBLKS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfCurr15MinUncorrectBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                                (const u_char *) retval,
+                                                  retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFCURR1DAYTIMEELAPSED:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfCurr1DayTimeElapsed
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFCURR1DAYRECEIVEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfCurr1DayReceivedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFCURR1DAYTRANSMITTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfCurr1DayTransmittedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFCURR1DAYCORRECTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfCurr1DayCorrectedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFCURR1DAYUNCORRECTBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfCurr1DayUncorrectBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFPREV1DAYMONISECS:
+                {
+                     int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfPrev1DayMoniSecs(data_context,
+                                                             &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFPREV1DAYRECEIVEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfPrev1DayReceivedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFPREV1DAYTRANSMITTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfPrev1DayTransmittedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFPREV1DAYCORRECTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfPrev1DayCorrectedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPERFPREV1DAYUNCORRECTBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPerfPrev1DayUncorrectBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+#endif
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                         "problem encountered in\
+                         adslAtucChanPerfDataTable_handler: unknown column\n");
+            }
+            break;
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in adslAtucChanPerfDataTable_handler:\
+                      unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable.h	2009-12-16 12:59:17.000000000 +0530
@@ -0,0 +1,83 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanPerfDataTable.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                    1) Include files
+ *                    2) Init Function proto-types for adslAtucChanPerfDataTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATUCCHANPERFDATATABLE_H
+#define ADSLATUCCHANPERFDATATABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/** other required module components */
+config_require(adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_access)
+
+/* column number definitions for table adslAtucChanPerfDataTable */
+#include "adslAtucChanPerfDataTable_columns.h"
+
+/* enum definions */
+#include "adslAtucChanPerfDataTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/* function declarations   */
+void            init_adslAtucChanPerfDataTable(void);
+void            initialize_table_adslAtucChanPerfDataTable(void);
+Netsnmp_Node_Handler adslAtucChanPerfDataTable_handler;
+
+
+
+
+#endif /** ADSLATUCCHANPERFDATATABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_access.c	2009-12-16 12:59:17.000000000 +0530
@@ -0,0 +1,1144 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanPerfDataTable_access.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) for data
+ *                  in table adslAtucChanPerfDataTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *  Subramani: Return types of get_adslAtucChanPerfValidIntervals,
+ *  get_adslAtucChanPerfInvalidIntervals and
+ *  get_adslAtucChanPerfPrev1DayMoniSecs are changed from long to int
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucChanPerfDataTable_access.h"
+#ifdef STUB_IOCTL
+#include "adslAtucChanPerfDataTable_enums.h"
+#endif
+
+/* column number definitions for table adslAtucChanPerfDataTable */
+#include "adslAtucChanPerfDataTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+// *** Global variable definitions
+static u_int32 long_ret;
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** returns the first data point within the adslAtucChanPerfDataTable table
+    data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAtucChanPerfDataTable_get_first_data_point(void **my_loop_context,
+                                               void **my_data_context,
+                                               netsnmp_variable_list *
+                                               put_index_data,
+                                               netsnmp_iterator_info
+                                               *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-First: adslAtucChanPerDataTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAtucChanPerfDataTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAtucChanPerfDataTable_get_next_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-Next: adslAtucChanPerDataTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+/*
+ * User-defined data access functions (per column) for data in table
+    adslAtucChanPerfDataTable
+ */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+#if defined(HAVE_OPTIMIZED_CODE)
+
+u_int32  *
+get_adslAtucChanBlksData(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+  memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+  atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+  
+  switch (var)  {
+
+        case COLUMN_ADSLATUCCHANRECEIVEDBLKS:
+	   flags = ATUC_CHAN_RECV_BLK_FLAG;
+	   break;
+
+        case COLUMN_ADSLATUCCHANTRANSMITTEDBLKS:
+	   flags = ATUC_CHAN_TX_BLK_FLAG;
+	   break;
+
+        case COLUMN_ADSLATUCCHANCORRECTEDBLKS:
+	   flags = ATUC_CHAN_CORR_BLK_FLAG;
+	   break;
+
+        case COLUMN_ADSLATUCCHANUNCORRECTBLKS:
+	   flags = ATUC_CHAN_UNCORR_BLK_FLAG;
+	   break;
+
+     	default:
+           DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  }
+
+  SET_FLAG(&atucChannelPerfDataStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags, flags) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfDataTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUC_CHAN_RECV_BLK_FLAG:
+    	   long_ret = atucChannelPerfDataStruct.adslAtucChanReceivedBlks;
+	   break;
+
+	case ATUC_CHAN_TX_BLK_FLAG:
+    	   long_ret = atucChannelPerfDataStruct.adslAtucChanTransmittedBlks;
+	   break;
+
+	case ATUC_CHAN_CORR_BLK_FLAG:
+    	   long_ret = atucChannelPerfDataStruct.adslAtucChanCorrectedBlks;
+	   break;
+
+	case ATUC_CHAN_UNCORR_BLK_FLAG:
+    	   long_ret = atucChannelPerfDataStruct.adslAtucChanUncorrectBlks;
+	   break;
+		
+        default:
+            DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+    
+    CLR_FLAG(&atucChannelPerfDataStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+
+int *
+get_adslAtucChanPerfIntervalData(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+  memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+  atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+      case COLUMN_ADSLATUCCHANPERFVALIDINTERVALS:
+	 flags = ATUC_CHAN_PERF_VALID_INTVL_FLAG;
+	 break;
+	 
+      case COLUMN_ADSLATUCCHANPERFINVALIDINTERVALS:
+	 flags = ATUC_CHAN_PERF_INVALID_INTVL_FLAG;
+	 break;
+
+      case COLUMN_ADSLATUCCHANPERFPREV1DAYMONISECS:
+	 flags = ATUC_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG;
+	 break;
+	 
+      default:
+     	 DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	 return NULL;
+ }
+  
+ SET_FLAG(&atucChannelPerfDataStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags, flags) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfDataTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUC_CHAN_PERF_VALID_INTVL_FLAG:
+    	   long_ret = atucChannelPerfDataStruct.adslAtucChanPerfValidIntervals;
+	   break;
+
+	case ATUC_CHAN_PERF_INVALID_INTVL_FLAG:
+    	   long_ret = atucChannelPerfDataStruct.adslAtucChanPerfInvalidIntervals;
+	   break;
+
+	case ATUC_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG:
+    	   long_ret = atucChannelPerfDataStruct.adslAtucChanPerfPrev1DayMoniSecs;
+	   break;
+
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+    
+    CLR_FLAG(&atucChannelPerfDataStruct.flags, flags);
+    *ret_len = sizeof(int);
+    return (int *) &long_ret;
+}
+
+
+u_int32  *
+get_adslAtucChanPerfStatsData(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+  memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+  atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+      case COLUMN_ADSLATUCCHANPERFCURR15MINTIMEELAPSED:
+	 flags = ATUC_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG; 
+         break;
+	 
+      case COLUMN_ADSLATUCCHANPERFCURR15MINRECEIVEDBLKS:
+	 flags = ATUC_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFCURR15MINTRANSMITTEDBLKS:
+	 flags = ATUC_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFCURR15MINCORRECTEDBLKS:
+	 flags = ATUC_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFCURR15MINUNCORRECTBLKS:
+	 flags = ATUC_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFCURR1DAYTIMEELAPSED:
+	 flags = ATUC_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFCURR1DAYRECEIVEDBLKS:
+	 flags = ATUC_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFCURR1DAYTRANSMITTEDBLKS:
+	 flags = ATUC_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFCURR1DAYCORRECTEDBLKS:
+	 flags = ATUC_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFCURR1DAYUNCORRECTBLKS:
+	 flags = ATUC_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFPREV1DAYRECEIVEDBLKS:
+	 flags = ATUC_CHAN_PERF_PREV_1DAY_RECV_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFPREV1DAYTRANSMITTEDBLKS:
+	 flags = ATUC_CHAN_PERF_PREV_1DAY_TX_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFPREV1DAYCORRECTEDBLKS:
+	 flags = ATUC_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCCHANPERFPREV1DAYUNCORRECTBLKS:
+	 flags = ATUC_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG;
+	 break;
+	 
+      default:
+     	 DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+         return NULL;
+     }
+
+ SET_FLAG(&atucChannelPerfDataStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+     adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+     get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+			         (void *) &atucChannelPerfDataStruct);
+#endif
+     if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags, flags) == 0)
+            DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfDataTable: GET- %x CMV fail\n", flags));
+
+     switch (flags)  {
+
+	 case ATUC_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfCurr15MinTimeElapsed;		 
+            break;
+	 
+	 case ATUC_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfCurr15MinReceivedBlks;
+	    break;
+	  
+	 case ATUC_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfCurr15MinTransmittedBlks;
+	    break;
+	  
+	 case ATUC_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfCurr15MinCorrectedBlks;
+	    break;
+	  
+	 case ATUC_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfCurr15MinUncorrectBlks;
+	    break;
+	  
+	 case ATUC_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfCurr1DayTimeElapsed;
+	    break;
+	  
+	 case ATUC_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfCurr1DayReceivedBlks;
+	    break;
+	  
+	 case ATUC_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfCurr1DayTransmittedBlks;
+	    break;
+	  
+	 case ATUC_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfCurr1DayCorrectedBlks;
+            break;
+	  
+	 case ATUC_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfCurr1DayUncorrectBlks;
+	    break;
+	  
+	 case ATUC_CHAN_PERF_PREV_1DAY_RECV_BLK_FLAG:
+	   long_ret = atucChannelPerfDataStruct.adslAtucChanPerfPrev1DayReceivedBlks; 
+	    break;
+	  
+	 case ATUC_CHAN_PERF_PREV_1DAY_TX_BLK_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfPrev1DayTransmittedBlks;
+	    break;
+	  
+	 case ATUC_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG:
+            long_ret = atucChannelPerfDataStruct.adslAtucChanPerfPrev1DayCorrectedBlks;
+	    break;
+	  
+	 case ATUC_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG:
+	    long_ret = atucChannelPerfDataStruct.adslAtucChanPerfPrev1DayUncorrectBlks;
+	    break;
+	 
+         default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+     }
+     
+    CLR_FLAG(&atucChannelPerfDataStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+#else
+
+/** XXX: return a data pointer to the data for the adslAtucChanReceivedBlks
+    column and set ret_len to its proper size in bytes. */
+
+u_int32         *
+get_adslAtucChanReceivedBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_RECV_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+    (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+                        ATUC_CHAN_RECV_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfRecvBlk CMV fail\n"));
+	
+    CLR_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_RECV_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanReceivedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.adslAtucChanReceivedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucChanTransmittedBlks
+    column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanTransmittedBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_TX_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+    (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+                        ATUC_CHAN_TX_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfTxBlk CMV fail\n"));
+    
+    CLR_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_TX_BLK_FLAG);
+     long_ret=atucChannelPerfDataStruct.adslAtucChanTransmittedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.adslAtucChanTransmittedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucChanCorrectedBlks
+    column and set ret_len to its proper size in bytes. */
+
+u_int32         *
+get_adslAtucChanCorrectedBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_CORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+    (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+                        ATUC_CHAN_CORR_BLK_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_CORR_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanCorrectedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.adslAtucChanCorrectedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucChanUncorrectBlks
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanUncorrectBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_UNCORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+    (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+             ATUC_CHAN_UNCORR_BLK_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfUnCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_UNCORR_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanUncorrectBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.adslAtucChanUncorrectBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfValidIntervals column and set
+         ret_len to its proper size in bytes. */
+int           *
+get_adslAtucChanPerfValidIntervals(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_PERF_VALID_INTVL_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+    (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+                     ATUC_CHAN_PERF_VALID_INTVL_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfValidIntvl CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_PERF_VALID_INTVL_FLAG);
+     long_ret=atucChannelPerfDataStruct.adslAtucChanPerfValidIntervals;
+    *ret_len = sizeof(atucChannelPerfDataStruct.adslAtucChanPerfValidIntervals);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfInvalidIntervals column and set
+         ret_len to its proper size in bytes. */
+int           *
+get_adslAtucChanPerfInvalidIntervals(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_PERF_INVALID_INTVL_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+    (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+                ATUC_CHAN_PERF_INVALID_INTVL_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfInvalidIntvl CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags, ATUC_CHAN_PERF_INVALID_INTVL_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfInvalidIntervals;
+  *ret_len = sizeof(atucChannelPerfDataStruct.adslAtucChanPerfInvalidIntervals);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfCurr15MinTimeElapsed column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanPerfCurr15MinTimeElapsed(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+    (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfCurr15Min CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG);
+     long_ret=atucChannelPerfDataStruct.adslAtucChanPerfCurr15MinTimeElapsed;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+                    adslAtucChanPerfCurr15MinTimeElapsed);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfCurr15MinReceivedBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAtucChanPerfCurr15MinReceivedBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfCurr15MinRecvBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfCurr15MinReceivedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+                adslAtucChanPerfCurr15MinReceivedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfCurr15MinTransmittedBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAtucChanPerfCurr15MinTransmittedBlks(void *data_context,
+    size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfCurr15MinTxBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfCurr15MinTransmittedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+            adslAtucChanPerfCurr15MinTransmittedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfCurr15MinCorrectedBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAtucChanPerfCurr15MinCorrectedBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfCurr15MinCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfCurr15MinCorrectedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+            adslAtucChanPerfCurr15MinCorrectedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfCurr15MinUncorrectBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAtucChanPerfCurr15MinUncorrectBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfCurr15MinUnCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfCurr15MinUncorrectBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+            adslAtucChanPerfCurr15MinUncorrectBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfCurr1DayTimeElapsed column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanPerfCurr1DayTimeElapsed(void *data_context,
+                                        size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,(void *) &
+        atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfCurr1Day CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfCurr1DayTimeElapsed;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+            adslAtucChanPerfCurr1DayTimeElapsed);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfCurr1DayReceivedBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanPerfCurr1DayReceivedBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfCurr1DayRecvBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfCurr1DayReceivedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+                adslAtucChanPerfCurr1DayReceivedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfCurr1DayTransmittedBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanPerfCurr1DayTransmittedBlks(void *data_context,
+     size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG);
+    printf("\n Flags = %0x \n", atucChannelPerfDataStruct.flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfCurr1DayTxBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfCurr1DayTransmittedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+                adslAtucChanPerfCurr1DayTransmittedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfCurr1DayCorrectedBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanPerfCurr1DayCorrectedBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfCurr1DayCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfCurr1DayCorrectedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+            adslAtucChanPerfCurr1DayCorrectedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfCurr1DayUncorrectBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanPerfCurr1DayUncorrectBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+         ATUC_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfCurr1DayUnCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfCurr1DayUncorrectBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+            adslAtucChanPerfCurr1DayUncorrectBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfPrev1DayMoniSecs column and set
+         ret_len to its proper size in bytes. */
+int           *
+get_adslAtucChanPerfPrev1DayMoniSecs(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfPrev1DayMonSec CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfPrev1DayMoniSecs;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+                adslAtucChanPerfPrev1DayMoniSecs);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfPrev1DayReceivedBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanPerfPrev1DayReceivedBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_PREV_1DAY_RECV_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_PREV_1DAY_RECV_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfPrev1DayRecvBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfPrev1DayReceivedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+            adslAtucChanPerfPrev1DayReceivedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfPrev1DayTransmittedBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanPerfPrev1DayTransmittedBlks(void *data_context,
+    size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_PREV_1DAY_TX_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_PREV_1DAY_TX_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfPrev1DayTxBlk CMV fail\n"));
+
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_PREV_1DAY_TX_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfPrev1DayTransmittedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+            adslAtucChanPerfPrev1DayTransmittedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfPrev1DayCorrectedBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanPerfPrev1DayCorrectedBlks(void *data_context, size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfPrev1DayCorrBlk CMV fail\n"));
+       
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfPrev1DayCorrectedBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+            adslAtucChanPerfPrev1DayCorrectedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucChanPerfPrev1DayUncorrectBlks column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanPerfPrev1DayUncorrectBlks(void *data_context,
+                                          size_t * ret_len)
+{
+    struct atucChannelPerfDataEntry atucChannelPerfDataStruct;
+
+    memset(&atucChannelPerfDataStruct,0,sizeof(atucChannelPerfDataEntry));
+    atucChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA, &atucChannelPerfDataStruct);
+#else
+    get_adslAtucChanPerfDataTable(Fd, GET_ADSL_ATUC_CHAN_PERF_DATA,
+        (void *) &atucChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&atucChannelPerfDataStruct.flags,
+            ATUC_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPerfPrev1DayUnCorrBlk CMV fail\n"));
+       
+    CLR_FLAG(&atucChannelPerfDataStruct.flags,
+        ATUC_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG);
+    long_ret=atucChannelPerfDataStruct.adslAtucChanPerfPrev1DayUncorrectBlks;
+    *ret_len = sizeof(atucChannelPerfDataStruct.
+                adslAtucChanPerfPrev1DayUncorrectBlks);
+    return (u_int32 *) &long_ret;
+}
+
+#endif
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAtucChanPerfDataTable(int Fd2,int GET_adsl_ATUC_CHAN_PERF_DATA2,
+                        void *atucChanPerfDataValue)
+{
+
+    struct atucChannelPerfDataEntry *atucChanPerfData;
+    atucChanPerfData = (atucChannelPerfDataEntry *) atucChanPerfDataValue;
+    atucChanPerfData->adslAtucChanReceivedBlks = 10;
+    atucChanPerfData->adslAtucChanTransmittedBlks = 20;
+    atucChanPerfData->adslAtucChanCorrectedBlks = 30;
+    atucChanPerfData->adslAtucChanUncorrectBlks = 40;
+    atucChanPerfData->adslAtucChanPerfValidIntervals = 10;
+    atucChanPerfData->adslAtucChanPerfInvalidIntervals = 20;
+    atucChanPerfData->adslAtucChanPerfCurr15MinTimeElapsed = 10;
+    atucChanPerfData->adslAtucChanPerfCurr15MinReceivedBlks = 15;
+    atucChanPerfData->adslAtucChanPerfCurr15MinTransmittedBlks = 20;
+    atucChanPerfData->adslAtucChanPerfCurr15MinCorrectedBlks = 25;
+    atucChanPerfData->adslAtucChanPerfCurr15MinUncorrectBlks = 30;
+    atucChanPerfData->adslAtucChanPerfCurr1DayTimeElapsed = 20;
+    atucChanPerfData->adslAtucChanPerfCurr1DayReceivedBlks = 30;
+    atucChanPerfData->adslAtucChanPerfCurr1DayTransmittedBlks = 20;
+    atucChanPerfData->adslAtucChanPerfCurr1DayCorrectedBlks = 30;
+    atucChanPerfData->adslAtucChanPerfCurr1DayUncorrectBlks = 70;
+    atucChanPerfData->adslAtucChanPerfPrev1DayMoniSecs = 80;
+    atucChanPerfData->adslAtucChanPerfPrev1DayReceivedBlks = 85;
+    atucChanPerfData->adslAtucChanPerfPrev1DayTransmittedBlks = 90;
+    atucChanPerfData->adslAtucChanPerfPrev1DayCorrectedBlks = 95;
+    atucChanPerfData->adslAtucChanPerfPrev1DayUncorrectBlks = 10;
+
+    return 0;
+
+}
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_access.h	2009-12-16 12:59:17.000000000 +0530
@@ -0,0 +1,185 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanPerfDataTable_access.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *              1)  Include files
+ *              2)  User defined data types
+ *              3)  Function proto-types for adslAtucChanPerfDataTable_access
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *  Subramani: Return types of get_adslAtucChanPerfValidIntervals,
+ *  get_adslAtucChanPerfInvalidIntervals and
+ *  get_adslAtucChanPerfPrev1DayMoniSecs are changed from long to int
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+//#include <adslMIBincl.h>
+
+
+#ifndef ADSLATUCCHANPERFDATATABLE_ACCESS_H
+#define ADSLATUCCHANPERFDATATABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslAtucChanPerfDataTable **/
+
+#define AdslPerfTimeElapsed u_int32
+#define PerfCurrentCount u_int32
+#define AdslPerfCurrDayCount u_int32
+#define AdslPerfPrevDayCount u_int32
+
+typedef struct atucChannelPerfDataEntry
+{
+   int          ifIndex;
+   u_int32          adslAtucChanReceivedBlks;
+   u_int32          adslAtucChanTransmittedBlks;
+   u_int32          adslAtucChanCorrectedBlks;
+   u_int32          adslAtucChanUncorrectBlks;
+   int              adslAtucChanPerfValidIntervals;
+   int              adslAtucChanPerfInvalidIntervals;
+   AdslPerfTimeElapsed  adslAtucChanPerfCurr15MinTimeElapsed;
+   PerfCurrentCount     adslAtucChanPerfCurr15MinReceivedBlks;
+   PerfCurrentCount     adslAtucChanPerfCurr15MinTransmittedBlks;
+   PerfCurrentCount     adslAtucChanPerfCurr15MinCorrectedBlks;
+   PerfCurrentCount     adslAtucChanPerfCurr15MinUncorrectBlks;
+   AdslPerfTimeElapsed  adslAtucChanPerfCurr1DayTimeElapsed;
+   AdslPerfCurrDayCount adslAtucChanPerfCurr1DayReceivedBlks;
+   AdslPerfCurrDayCount adslAtucChanPerfCurr1DayTransmittedBlks;
+   AdslPerfCurrDayCount adslAtucChanPerfCurr1DayCorrectedBlks;
+   AdslPerfCurrDayCount adslAtucChanPerfCurr1DayUncorrectBlks;
+   int                  adslAtucChanPerfPrev1DayMoniSecs;
+   AdslPerfPrevDayCount adslAtucChanPerfPrev1DayReceivedBlks;
+   AdslPerfPrevDayCount adslAtucChanPerfPrev1DayTransmittedBlks;
+   AdslPerfPrevDayCount adslAtucChanPerfPrev1DayCorrectedBlks;
+   AdslPerfPrevDayCount adslAtucChanPerfPrev1DayUncorrectBlks;
+   u_int32          flags;
+}atucChannelPerfDataEntry;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/** User-defined data access functions for data in table
+    adslAtucChanPerfDataTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAtucChanPerfDataTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAtucChanPerfDataTable_get_next_data_point;
+
+
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+u_int32  *
+get_adslAtucChanBlksData(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+int *
+get_adslAtucChanPerfIntervalData(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+u_int32  *
+get_adslAtucChanPerfStatsData(void *data_context, size_t * ret_len,
+			unsigned int var);
+#else
+u_int32  *get_adslAtucChanReceivedBlks(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucChanTransmittedBlks(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucChanCorrectedBlks(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucChanUncorrectBlks(void *data_context, size_t * ret_len);
+int     *get_adslAtucChanPerfValidIntervals(void *data_context,
+            size_t * ret_len);
+int     *get_adslAtucChanPerfInvalidIntervals(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanPerfCurr15MinTimeElapsed(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanPerfCurr15MinReceivedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanPerfCurr15MinTransmittedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanPerfCurr15MinCorrectedBlks(void *data_context,
+             size_t * ret_len);
+u_int32  *get_adslAtucChanPerfCurr15MinUncorrectBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanPerfCurr1DayTimeElapsed(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanPerfCurr1DayReceivedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanPerfCurr1DayTransmittedBlks(void *data_context,
+            size_t *ret_len);
+u_int32  *get_adslAtucChanPerfCurr1DayCorrectedBlks(void *data_context,
+            size_t *ret_len);
+u_int32  *get_adslAtucChanPerfCurr1DayUncorrectBlks(void *data_context,
+            size_t *ret_len);
+int     *get_adslAtucChanPerfPrev1DayMoniSecs(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanPerfPrev1DayReceivedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucChanPerfPrev1DayTransmittedBlks(void *data_context,
+            size_t *ret_len);
+u_int32  *get_adslAtucChanPerfPrev1DayCorrectedBlks(void *data_context,
+            size_t *ret_len);
+u_int32  *get_adslAtucChanPerfPrev1DayUncorrectBlks(void *data_context,
+            size_t *ret_len);
+#endif
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAtucChanPerfDataTable(int Fd2,int GET_adsl_ATUC_CHAN_PERF_DATA2,
+            void *atucChanPerfDataValue);
+#endif
+
+#endif                          /* ADSLATUCCHANPERFDATATABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_columns.h	2009-12-16 12:59:17.000000000 +0530
@@ -0,0 +1,77 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanPerfDataTable_columns.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: column number definitions for table adslAtucChanPerfDataTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATUCCHANPERFDATATABLE_COLUMNS_H
+#define ADSLATUCCHANPERFDATATABLE_COLUMNS_H
+
+/*
+ * column number definitions for table adslAtucChanPerfDataTable
+ */
+#define COLUMN_ADSLATUCCHANRECEIVEDBLKS     1
+#define COLUMN_ADSLATUCCHANTRANSMITTEDBLKS      2
+#define COLUMN_ADSLATUCCHANCORRECTEDBLKS        3
+#define COLUMN_ADSLATUCCHANUNCORRECTBLKS        4
+#define COLUMN_ADSLATUCCHANPERFVALIDINTERVALS       5
+#define COLUMN_ADSLATUCCHANPERFINVALIDINTERVALS     6
+#define COLUMN_ADSLATUCCHANPERFCURR15MINTIMEELAPSED     7
+#define COLUMN_ADSLATUCCHANPERFCURR15MINRECEIVEDBLKS        8
+#define COLUMN_ADSLATUCCHANPERFCURR15MINTRANSMITTEDBLKS     9
+#define COLUMN_ADSLATUCCHANPERFCURR15MINCORRECTEDBLKS       10
+#define COLUMN_ADSLATUCCHANPERFCURR15MINUNCORRECTBLKS       11
+#define COLUMN_ADSLATUCCHANPERFCURR1DAYTIMEELAPSED      12
+#define COLUMN_ADSLATUCCHANPERFCURR1DAYRECEIVEDBLKS     13
+#define COLUMN_ADSLATUCCHANPERFCURR1DAYTRANSMITTEDBLKS      14
+#define COLUMN_ADSLATUCCHANPERFCURR1DAYCORRECTEDBLKS        15
+#define COLUMN_ADSLATUCCHANPERFCURR1DAYUNCORRECTBLKS        16
+#define COLUMN_ADSLATUCCHANPERFPREV1DAYMONISECS     17
+#define COLUMN_ADSLATUCCHANPERFPREV1DAYRECEIVEDBLKS     18
+#define COLUMN_ADSLATUCCHANPERFPREV1DAYTRANSMITTEDBLKS      19
+#define COLUMN_ADSLATUCCHANPERFPREV1DAYCORRECTEDBLKS        20
+#define COLUMN_ADSLATUCCHANPERFPREV1DAYUNCORRECTBLKS        21
+#endif                          /* ADSLATUCCHANPERFDATATABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable_enums.h	2009-12-16 12:59:17.000000000 +0530
@@ -0,0 +1,81 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanPerfDataTable_enums.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: Constant definitions for table adslAtucChanPerfDataTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATUCCHANPERFDATATABLE_ENUMS_H
+#define ADSLATUCCHANPERFDATATABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAtucChanPerfDataTable constants */
+#define GET_ADSL_ATUC_CHAN_PERF_DATA    70
+
+/* adslAtucChanPerfDataTable Flags */
+#define ATUC_CHAN_RECV_BLK_FLAG 0x01    /* BIT 0th position */
+#define ATUC_CHAN_TX_BLK_FLAG   0x02    /* BIT 1 */
+#define ATUC_CHAN_CORR_BLK_FLAG 0x04    /* BIT 2 */
+#define ATUC_CHAN_UNCORR_BLK_FLAG 0x08  /* BIT 3 */
+#define ATUC_CHAN_PERF_VALID_INTVL_FLAG 0x10 /* BIT 4 */
+#define ATUC_CHAN_PERF_INVALID_INTVL_FLAG 0x20 /* BIT 5 */
+#define ATUC_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG 0x40 /* BIT 6 */
+#define ATUC_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG 0x80 /* BIT 7 */
+#define ATUC_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG 0x100 /* BIT 8 */
+#define ATUC_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG 0x200 /* BIT 9 */
+#define ATUC_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG 0x400 /* BIT 10 */
+#define ATUC_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG 0x800 /* BIT 11*/
+#define ATUC_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG 0x1000 /* BIT 12 */
+#define ATUC_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG 0x2000 /* BIT 13 */
+#define ATUC_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG 0x4000 /* BIT 14 */
+#define ATUC_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG 0x8000 /* BIT 15 */
+#define ATUC_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG 0x10000 /* BIT 16 */
+#define ATUC_CHAN_PERF_PREV_1DAY_RECV_BLK_FLAG 0x20000 /* BIT 17 */
+#define ATUC_CHAN_PERF_PREV_1DAY_TX_BLK_FLAG 0x40000 /* BIT 18 */
+#define ATUC_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG 0x80000 /* BIT 19 */
+#define ATUC_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG 0x100000 /* BIT 20 */
+#endif
+
+
+#endif                          /* ADSLATUCCHANPERFDATATABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable.c open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable.c	2009-12-16 12:59:17.000000000 +0530
@@ -0,0 +1,293 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanTable.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslAtucChanTable module
+ *               2) Handling requests for the adslAtucChanTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucChanTable.h"
+#include "adslAtucChanTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+
+/** Initialize the adslAtucChanTable table by defining its contents and how
+    it's structured */
+void
+initialize_table_adslAtucChanTable(void)
+{
+    static oid      adslAtucChanTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 4 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler = netsnmp_create_handler_registration("adslAtucChanTable",
+                                                     adslAtucChanTable_handler,
+                                                     adslAtucChanTable_oid,
+                                                     OID_LENGTH
+                                                     (adslAtucChanTable_oid),
+                                                     HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,\
+                 "malloc failed in initialize_table_adslAtucChanTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 4;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point = adslAtucChanTable_get_first_data_point;
+    iinfo->get_next_data_point = adslAtucChanTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context = adslAtucChanTable_context_convert_function;
+    iinfo->free_data_context = adslAtucChanTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAtucChanTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAtucChanTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAtucChanTable",\
+                "Registering table adslAtucChanTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAtucChanTable module */
+void
+init_adslAtucChanTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAtucChanTable();
+}
+
+/** handles requests for the adslAtucChanTable table, if anything else needs
+    to be done */
+int
+adslAtucChanTable_handler(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+		    
+            case COLUMN_ADSLATUCCHANINTERLEAVEDELAY:
+            case COLUMN_ADSLATUCCHANCURRTXRATE:
+            case COLUMN_ADSLATUCCHANPREVTXRATE:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanInfo(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+#else		    
+            case COLUMN_ADSLATUCCHANINTERLEAVEDELAY:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanInterleaveDelay(data_context,
+                                                        &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANCURRTXRATE:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanCurrTxRate(data_context,
+                                                   &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCHANPREVTXRATE:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucChanPrevTxRate(data_context,
+                                                   &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+#endif
+
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                         "problem encountered in adslAtucChanTable_handler:\
+                          unknown column\n");
+            }
+            break;
+
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in adslAtucChanTable_handler:\
+                      unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable.h	2009-12-16 12:59:18.000000000 +0530
@@ -0,0 +1,83 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanTable.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                    1) Include files
+ *                    2) Init Function proto-types for adslAtucChanTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATUCCHANTABLE_H
+#define ADSLATUCCHANTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/** other required module components */
+config_require(adslMIB/adslAtucChanTable/adslAtucChanTable_access)
+
+/* column number definitions for table adslAtucChanTable  */
+#include "adslAtucChanTable_columns.h"
+
+/* enum definions */
+#include "adslAtucChanTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/* function declarations  */
+void            init_adslAtucChanTable(void);
+void            initialize_table_adslAtucChanTable(void);
+Netsnmp_Node_Handler adslAtucChanTable_handler;
+
+
+
+
+#endif /** ADSLATUCCHANTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_access.c	2009-12-16 12:59:18.000000000 +0530
@@ -0,0 +1,343 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanTable_access.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) for data
+ *                  in table adslAtucChanTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *   Subramani: Data type for long_ret is changed from long to u_int32
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#include "adslAtucChanTable_access.h"
+
+#ifdef STUB_IOCTL
+#include "adslAtucChanTable_enums.h"
+#endif
+
+/* column number definitions for table adslAtucChanTable */
+#include "adslAtucChanTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+// *** Global variable definitions
+//static long long_ret;
+static u_int32 long_ret;
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** returns the first data point within the adslAtucChanTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAtucChanTable_get_first_data_point(void **my_loop_context,
+                                       void **my_data_context,
+                                       netsnmp_variable_list *
+                                       put_index_data,
+                                       netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-First: adslAtucChanTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAtucChanTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAtucChanTable_get_next_data_point(void **my_loop_context,
+                                      void **my_data_context,
+                                      netsnmp_variable_list *
+                                      put_index_data,
+                                      netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-Next: adslAtucChanTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+/*
+ * User-defined data access functions (per column) for data in table
+ * adslAtucChanTable
+ */
+
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+#if defined(HAVE_OPTIMIZED_CODE)
+
+u_int32         *
+get_adslAtucChanInfo(void *data_context, size_t * ret_len,
+		unsigned int var)
+{
+  unsigned int flags = 0;	
+  struct adslAtucChanInfo adslAtucChanStruct;
+  memset(&adslAtucChanStruct,0,sizeof(adslAtucChanInfo));
+  adslAtucChanStruct.ifIndex= (*(int *)data_context);
+
+  switch (var)  {
+
+        case COLUMN_ADSLATUCCHANINTERLEAVEDELAY:
+	   flags = ATUC_CHAN_INTLV_DELAY_FLAG;
+	   break;
+
+        case COLUMN_ADSLATUCCHANCURRTXRATE:
+	   flags = ATUC_CHAN_CURR_TX_RATE_FLAG;
+	   break;
+
+        case COLUMN_ADSLATUCCHANPREVTXRATE:
+	   flags = ATUC_CHAN_PREV_TX_RATE_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  }
+
+  SET_FLAG(&adslAtucChanStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_INFO, &adslAtucChanStruct);
+#else
+    get_adslAtucChanTable(Fd, GET_ADSL_ATUC_CHAN_INFO,
+        (void *) &adslAtucChanStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucChanStruct.flags, flags) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUC_CHAN_INTLV_DELAY_FLAG:
+    	   long_ret = adslAtucChanStruct.interleaveDelay;
+	   break;
+
+	case ATUC_CHAN_CURR_TX_RATE_FLAG:
+     	   long_ret = adslAtucChanStruct.currTxRate;
+	   break;
+
+	case ATUC_CHAN_PREV_TX_RATE_FLAG:
+    	   long_ret = adslAtucChanStruct.prevTxRate;
+	   break;
+
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+    
+    CLR_FLAG(&adslAtucChanStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+#else
+
+/** XXX: return a data pointer to the data for the adslAtucChanInterleaveDelay
+    column and set ret_len to its proper size in bytes. */
+
+u_int32         *
+get_adslAtucChanInterleaveDelay(void *data_context, size_t * ret_len)
+{
+    struct adslAtucChanInfo adslAtucChanStruct;
+
+    memset(&adslAtucChanStruct,0,sizeof(adslAtucChanInfo));
+    adslAtucChanStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAtucChanStruct.flags, ATUC_CHAN_INTLV_DELAY_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_INFO, &adslAtucChanStruct);
+#else
+    get_adslAtucChanTable(Fd, GET_ADSL_ATUC_CHAN_INFO,
+        (void *) &adslAtucChanStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucChanStruct.flags, ATUC_CHAN_INTLV_DELAY_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanIntlvDelay CMV fail\n"));
+
+    CLR_FLAG(&adslAtucChanStruct.flags, ATUC_CHAN_INTLV_DELAY_FLAG);
+    long_ret=adslAtucChanStruct.interleaveDelay;
+    *ret_len = sizeof(adslAtucChanStruct.interleaveDelay);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucChanCurrTxRate column
+    and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucChanCurrTxRate(void *data_context, size_t * ret_len)
+{
+    struct adslAtucChanInfo adslAtucChanStruct;
+
+    memset(&adslAtucChanStruct,0,sizeof(adslAtucChanInfo));
+    adslAtucChanStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAtucChanStruct.flags, ATUC_CHAN_CURR_TX_RATE_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_INFO, &adslAtucChanStruct);
+#else
+    get_adslAtucChanTable(Fd, GET_ADSL_ATUC_CHAN_INFO,
+        (void *) &adslAtucChanStruct);
+#endif
+   if (IS_FLAG_SET(&adslAtucChanStruct.flags, ATUC_CHAN_CURR_TX_RATE_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanCurrTxRate CMV fail\n"));
+
+    CLR_FLAG(&adslAtucChanStruct.flags, ATUC_CHAN_CURR_TX_RATE_FLAG);
+     long_ret=adslAtucChanStruct.currTxRate;
+    *ret_len = sizeof(adslAtucChanStruct.currTxRate);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucChanPrevTxRate column
+    and set ret_len to its proper size in bytes. */
+
+u_int32         *
+get_adslAtucChanPrevTxRate(void *data_context, size_t * ret_len)
+{
+    struct adslAtucChanInfo adslAtucChanStruct;
+
+    memset(&adslAtucChanStruct,0,sizeof(adslAtucChanInfo));
+    adslAtucChanStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAtucChanStruct.flags, ATUC_CHAN_PREV_TX_RATE_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_CHAN_INFO, &adslAtucChanStruct);
+#else
+    get_adslAtucChanTable(Fd, GET_ADSL_ATUC_CHAN_INFO,
+        (void *) &adslAtucChanStruct);
+#endif
+   if (IS_FLAG_SET(&adslAtucChanStruct.flags, ATUC_CHAN_PREV_TX_RATE_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanPrevTxRate CMV fail\n"));
+
+    CLR_FLAG(&adslAtucChanStruct.flags, ATUC_CHAN_PREV_TX_RATE_FLAG);
+    long_ret=adslAtucChanStruct.prevTxRate;
+    *ret_len = sizeof(adslAtucChanStruct.prevTxRate);
+    return (u_int32 *) &long_ret;
+}
+
+#endif
+
+
+#ifndef ENABLE_DRIVER_CALL
+int  get_adslAtucChanTable(int Fd2,int GET_ADSL_atuc_CHAN_INFO,
+        void *adslAtucChanTable)
+{
+    struct adslAtucChanInfo *adslAtucChanValue;
+    adslAtucChanValue=(adslAtucChanInfo *)adslAtucChanTable;
+    adslAtucChanValue->interleaveDelay=30;
+    adslAtucChanValue->currTxRate=30;
+    adslAtucChanValue->prevTxRate=30;
+    return 0;
+}
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_access.h	2009-12-16 12:59:18.000000000 +0530
@@ -0,0 +1,107 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanTable_access.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:   This file contains :
+ *                  1)  Include files
+ *                  2)  User defined data types
+ *                  3)  Function proto-types for adslAtucChanTable_access
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+//#include <adslMIBincl.h>
+
+
+#ifndef ADSLATUCCHANTABLE_ACCESS_H
+#define ADSLATUCCHANTABLE_ACCESS_H
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslAtucChanTable **/
+typedef struct adslAtucChanInfo {
+    int ifIndex;
+    u_int32 interleaveDelay;
+    u_int32 currTxRate;
+    u_int32 prevTxRate;
+    u_char flags;
+} adslAtucChanInfo;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/** User-defined data access functions for data in table adslAtucChanTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAtucChanTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAtucChanTable_get_next_data_point;
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+u_int32         *
+get_adslAtucChanInfo(void *data_context, size_t * ret_len,
+		unsigned int var);
+#else
+u_int32 *get_adslAtucChanInterleaveDelay(void *data_context, size_t * ret_len);
+u_int32 *get_adslAtucChanCurrTxRate(void *data_context, size_t * ret_len);
+u_int32 *get_adslAtucChanPrevTxRate(void *data_context, size_t * ret_len);
+#endif
+
+#ifndef ENABLE_DRIVER_CALL
+int  get_adslAtucChanTable(int Fd2,int GET_ADSL_atuc_CHAN_INFO,
+        void *adslAtucChanTable);
+#endif
+
+#endif                          /* ADSLATUCCHANTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_columns.h	2009-12-16 12:59:18.000000000 +0530
@@ -0,0 +1,59 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanTable_columns.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: column number definitions for table adslAtucChanTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATUCCHANTABLE_COLUMNS_H
+#define ADSLATUCCHANTABLE_COLUMNS_H
+
+/*
+ * column number definitions for table adslAtucChanTable
+ */
+#define COLUMN_ADSLATUCCHANINTERLEAVEDELAY  1
+#define COLUMN_ADSLATUCCHANCURRTXRATE       2
+#define COLUMN_ADSLATUCCHANPREVTXRATE       3
+#define COLUMN_ADSLATUCCHANCRCBLOCKLENGTH   4
+#endif                          /* ADSLATUCCHANTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucChanTable/adslAtucChanTable_enums.h	2009-12-16 12:59:18.000000000 +0530
@@ -0,0 +1,61 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanTable_enums.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: Constant definitions for table adslAtucChanTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATUCCHANTABLE_ENUMS_H
+#define ADSLATUCCHANTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAtucChanTable constants */
+#define GET_ADSL_ATUC_CHAN_INFO     15
+
+/* adslAtucChanTable Flags */
+#define ATUC_CHAN_INTLV_DELAY_FLAG  0x1 /* BIT 0th position */
+#define ATUC_CHAN_CURR_TX_RATE_FLAG 0x2 /* BIT 1 */
+#define ATUC_CHAN_PREV_TX_RATE_FLAG 0x4 /* BIT 2 */
+#endif
+
+#endif                          /* ADSLATUCCHANTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable.c open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable.c	2009-12-16 12:59:18.000000000 +0530
@@ -0,0 +1,254 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucIntervalExtTable.c
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslAtucIntervalExtTable module
+ *               2) Handling requests for the adslAtucIntervalExtTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucIntervalExtTable.h"
+#include "adslAtucIntervalExtTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** Initialize the adslAtucIntervalExtTable table by defining its contents
+	and how it's structured */
+
+void initialize_table_adslAtucIntervalExtTable(void)
+{
+    static oid  adslAtucIntervalExtTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 3, 1, 19 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAtucIntervalExtTable",
+                                            adslAtucIntervalExtTable_handler,
+                                            adslAtucIntervalExtTable_oid,
+                                            OID_LENGTH
+                                            (adslAtucIntervalExtTable_oid),
+                                            HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+        snmp_log(LOG_ERR, \
+                 "malloc failed in initialize_table_adslAtucIntervalExtTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     ASN_INTEGER,
+                                       /** index: adslAtucIntervalNumber */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 4;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAtucIntervalExtTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        adslAtucIntervalExtTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAtucIntervalExtTable_context_convert_function;
+    iinfo->free_data_context = adslAtucIntervalExtTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAtucIntervalExtTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAtucIntervalExtTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAtucIntervalExtTable",  \
+          "Registering table adslAtucIntervalExtTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAtucIntervalExtTable module */
+void
+init_adslAtucIntervalExtTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAtucIntervalExtTable();
+}
+
+/** handles requests for the adslAtucIntervalExtTable table, if anything else
+    needs to be done */
+int
+adslAtucIntervalExtTable_handler(netsnmp_mib_handler *handler,
+                                 netsnmp_handler_registration *reginfo,
+                                 netsnmp_agent_request_info *reqinfo,
+                                 netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+    long IntervalNum = 0;
+
+    void           *data_context = NULL;
+
+    IntervalNum = *(requests->requestvb->name + reginfo->rootoid_len + 3);
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_ADSLATUCINTERVALFASTR:
+            case COLUMN_ADSLATUCINTERVALFAILEDFASTR:
+            case COLUMN_ADSLATUCINTERVALSESL:
+            case COLUMN_ADSLATUCINTERVALUASL:
+                {
+                    u_int32	    *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucIntervaExtStats(data_context, &retval_len, 
+				   table_info->colnum);
+                    snmp_set_var_typed_value(var,ASN_GAUGE,
+                    (const u_char *) retval,retval_len);
+                }
+                break;
+
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+  "problem encountered in adslAtucIntervalExtTable_handler: unknown column\n");
+            }
+            break;
+
+         default:
+            snmp_log(LOG_ERR,
+ "problem encountered in adslAtucIntervalExtTable_handler: unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable.h open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable.h	2009-12-16 12:59:18.000000000 +0530
@@ -0,0 +1,92 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucIntervalExtTable.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                    1) Include files
+ *                    2) Init Function proto-types for adslAtucIntervalExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATUCINTERVALEXTTABLE_H
+#define ADSLATUCINTERVALEXTTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+
+/** other required module components */
+config_require(adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_access)
+
+/*
+ * column number definitions for table adslAtucIntervalExtTable
+ */
+#include "adslAtucIntervalExtTable_columns.h"
+
+/*
+ * enum definions
+ */
+#include "adslAtucIntervalExtTable_enums.h"
+
+
+
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/*
+ * function declarations
+ */
+ void            init_adslAtucIntervalExtTable(void);
+ void            initialize_table_adslAtucIntervalExtTable(void);
+ Netsnmp_Node_Handler adslAtucIntervalExtTable_handler;
+
+
+
+
+#endif /** ADSLATUCINTERVALEXTTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_access.c	2009-12-16 12:59:18.000000000 +0530
@@ -0,0 +1,262 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucIntervalExtTable_access.c
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) for data
+ *                  in table adslAtucIntervalExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucIntervalExtTable_access.h"
+#include "adslAtucIntervalExtTable_enums.h"
+
+/* column number definitions for table adslAtucIntervalExtTable */
+#include "adslAtucIntervalExtTable_columns.h"
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+// *** Global variable definitions
+static u_int32 long_ret;
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+
+/** returns the first data point within the adslAtucIntervalExtTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAtucIntervalExtTable_get_first_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+        "Get-First: adslAtucIntervalExtTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAtucIntervalExtTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAtucIntervalExtTable_get_next_data_point(void **my_loop_context,
+                                             void **my_data_context,
+                                             netsnmp_variable_list *
+                                             put_index_data,
+                                             netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+        "Get-Next: adslAtucIntervalExtTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+
+/*
+ * User-defined data access functions (per column) for data in table adslAtucIntervalExtTable
+ */
+u_int32		*
+get_adslAtucIntervaExtStats(void *data_context, size_t * ret_len,
+		unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslAtucInvtlExtInfo adslAtucInvtlExtStruct;
+  memset(&adslAtucInvtlExtStruct,0,sizeof(adslAtucInvtlExtStruct));
+  adslAtucInvtlExtStruct.ifIndex= (*(int *)data_context);
+  adslAtucInvtlExtStruct.IntervalNumber= (*(int *)ret_len);
+  
+  switch (var) {
+
+    case COLUMN_ADSLATUCINTERVALFASTR:
+  	flags = ATUC_INTERVAL_FASTR_FLAG;
+        break;
+	
+    case COLUMN_ADSLATUCINTERVALFAILEDFASTR:
+	flags = ATUC_INTERVAL_FAILED_FASTR_FLAG;
+	break;
+	
+    case COLUMN_ADSLATUCINTERVALSESL:
+	flags = ATUC_INTERVAL_SESL_FLAG;
+	break;
+	
+    case COLUMN_ADSLATUCINTERVALUASL:
+	flags = ATUC_INTERVAL_UASL_FLAG;
+	break;
+
+    default:
+        DEBUGMSGTL(("Unknown MIB variable requested!","\n"));
+        return NULL;
+  }
+    
+    SET_FLAG(&adslAtucInvtlExtStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_INTVL_EXT_INFO , &adslAtucInvtlExtStruct);
+#else
+    get_adslAtucIntervalExtTable(Fd, GET_ADSL_ATUC_INTVL_EXT_INFO ,
+        (void *) &adslAtucInvtlExtStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucInvtlExtStruct.flags, flags) == 0)
+    	DEBUGMSGTL(("adslMIB-ATUC", "IntervalExtTable: GET- %x CMV fail\n", flags));
+    
+    switch (flags)  {
+
+	 case ATUC_INTERVAL_FASTR_FLAG:
+    	    long_ret = adslAtucInvtlExtStruct.adslAtucIntervalFastR;
+            break;
+	 
+	 case ATUC_INTERVAL_FAILED_FASTR_FLAG:
+    	    long_ret = adslAtucInvtlExtStruct.adslAtucIntervalFailedFastR;
+	    break;
+	  
+	 case ATUC_INTERVAL_SESL_FLAG:
+    	    long_ret = adslAtucInvtlExtStruct.adslAtucIntervalSesL;
+	    break;
+	  
+	 case ATUC_INTERVAL_UASL_FLAG:
+    	    long_ret = adslAtucInvtlExtStruct.adslAtucIntervalUasL;
+	    break;
+	  
+         default:
+            DEBUGMSGTL(("Unknown MIB variable requested!","\n"));
+            return NULL;
+     }
+
+    CLR_FLAG(&adslAtucInvtlExtStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAtucIntervalExtTable(int Fd2,int GET_adsl_ATUC_INTVL_INFO2,
+        void *adslAtucInvtlExtTable)
+{
+        struct adslAtucInvtlExtInfo *adslAtucInvtlExtValue;
+        adslAtucInvtlExtValue = (adslAtucInvtlExtInfo *)adslAtucInvtlExtTable;
+        adslAtucInvtlExtValue->adslAtucIntervalFastR = 10;
+        adslAtucInvtlExtValue->adslAtucIntervalFailedFastR = 20;
+        adslAtucInvtlExtValue->adslAtucIntervalSesL = 30;
+        adslAtucInvtlExtValue->adslAtucIntervalUasL = 40;
+
+        return 0;
+}
+
+#endif
+
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_access.h	2009-12-16 12:59:19.000000000 +0530
@@ -0,0 +1,104 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucIntervalExtTable_access.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:    This file contains :
+ *              1)  Include files
+ *              2)  User defined data types
+ *              3)  Function proto-types for adslAtucIntervalExtTable_access
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+#ifndef ADSLATUCINTERVALEXTTABLE_ACCESS_H
+#define ADSLATUCINTERVALEXTTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+#include <adslMIB/adslTable_access.h>
+
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+#ifdef STUB_IOCTL
+
+typedef struct adslAtucInvtlExtInfo
+{
+  int ifIndex;
+  int IntervalNumber;
+  u_int32 adslAtucIntervalFastR;
+  u_int32 adslAtucIntervalFailedFastR;
+  u_int32 adslAtucIntervalSesL;
+  u_int32 adslAtucIntervalUasL;
+  u_int32	flags;
+} adslAtucInvtlExtInfo;
+#endif
+
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/** User-defined data access functions for data in table
+    adslAtucIntervalExtTable */
+
+/** row level accessors */
+Netsnmp_First_Data_Point adslAtucIntervalExtTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAtucIntervalExtTable_get_next_data_point;
+
+/** column accessors */
+u_int32		*get_adslAtucIntervaExtStats(void *data_context, size_t * ret_len, 
+				unsigned int var);
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAtucIntervalExtTable(int Fd2,int GET_adsl_ATUC_INTVL_INFO2,
+        void *adslAtucInvtlExtTable);
+#endif
+
+#endif                          /* ADSLATUCINTERVALEXTTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_columns.h	2009-12-16 12:59:19.000000000 +0530
@@ -0,0 +1,57 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucIntervalExtTable_columns.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: column number definitions for table adslAtucIntervalExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATUCINTERVALEXTTABLE_COLUMNS_H
+#define ADSLATUCINTERVALEXTTABLE_COLUMNS_H
+
+/*
+ * column number definitions for table adslAtucIntervalExtTable
+ */
+#define COLUMN_ADSLATUCINTERVALFASTR		1
+#define COLUMN_ADSLATUCINTERVALFAILEDFASTR		2
+#define COLUMN_ADSLATUCINTERVALSESL		3
+#define COLUMN_ADSLATUCINTERVALUASL		4
+#endif                          /* ADSLATUCINTERVALEXTTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable_enums.h	2009-12-16 12:59:19.000000000 +0530
@@ -0,0 +1,67 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucIntervalExtTable_enums.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: Constant definitions for table adslAtucIntervalExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATUCINTERVALEXTTABLE_ENUMS_H
+#define ADSLATUCINTERVALEXTTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+
+/* adslAtucIntervalExtTable constants */
+#define GET_ADSL_ATUC_INTVL_EXT_INFO 221
+
+/* adslAtucIntervalExtTable flags */
+#define ATUC_INTERVAL_FASTR_FLAG		0X1 /* BIT 0th position */
+#define ATUC_INTERVAL_FAILED_FASTR_FLAG	0X2 /* BIT 1 */
+#define ATUC_INTERVAL_SESL_FLAG			0X4 /* BIT 2 */
+#define ATUC_INTERVAL_UASL_FLAG			0X8 /* BIT 3 */
+
+#endif
+
+
+#endif                          /* ADSLATUCINTERVALEXTTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable.c open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable.c	2009-12-16 12:59:19.000000000 +0530
@@ -0,0 +1,320 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucIntervalTable.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslAtucIntervalTable module
+ *               2) Handling requests for the adslAtucIntervalTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Data type for adslAtucIntervalValidData changed from long
+ *   to int
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucIntervalTable.h"
+#include "adslAtucIntervalTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** Initialize the adslAtucIntervalTable table by defining its contents and how
+    it's structured */
+void
+initialize_table_adslAtucIntervalTable(void)
+{
+    static oid      adslAtucIntervalTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 8 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAtucIntervalTable",
+                                            adslAtucIntervalTable_handler,
+                                            adslAtucIntervalTable_oid,
+                                            OID_LENGTH
+                                            (adslAtucIntervalTable_oid),
+                                            HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,\
+                 "malloc failed in initialize_table_adslAtucIntervalTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     ASN_INTEGER,
+                                           /** index: adslAtucIntervalNumber */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 2;
+    table_info->max_column = 8;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAtucIntervalTable_get_first_data_point;
+    iinfo->get_next_data_point = adslAtucIntervalTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAtucIntervalTable_context_convert_function;
+    iinfo->free_data_context = adslAtucIntervalTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAtucIntervalTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAtucIntervalTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAtucIntervalTable",\
+             "Registering table adslAtucIntervalTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAtucIntervalTable module */
+void
+init_adslAtucIntervalTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAtucIntervalTable();
+}
+
+/** handles requests for the adslAtucIntervalTable table, if anything else
+    needs to be done */
+int
+adslAtucIntervalTable_handler(netsnmp_mib_handler *handler,
+                              netsnmp_handler_registration *reginfo,
+                              netsnmp_agent_request_info *reqinfo,
+                              netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    long IntervalNum = 1;
+    struct commitInfo *ci = NULL;
+    void           *data_context = NULL;
+
+ IntervalNum = *(requests->requestvb->name + reginfo->rootoid_len + 3);
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+		    
+            case COLUMN_ADSLATUCINTERVALLOFS:
+            case COLUMN_ADSLATUCINTERVALLOSS:
+            case COLUMN_ADSLATUCINTERVALESS:
+            case COLUMN_ADSLATUCINTERVALINITS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucIntervalData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                            (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+#else
+            case COLUMN_ADSLATUCINTERVALLOFS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucIntervalLofs(data_context,
+                                                 &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                            (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCINTERVALLOSS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucIntervalLoss(data_context,
+                                                 &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                            (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCINTERVALESS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucIntervalESs(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                            (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCINTERVALINITS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucIntervalInits(data_context,
+                                                  &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                            (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+#endif
+            case COLUMN_ADSLATUCINTERVALVALIDDATA:
+                {
+                      int           *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAtucIntervalValidData(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,\
+                         "adslAtucIntervalTable_handler: unknown column\n");
+            }
+            break;
+
+        default:
+            snmp_log(LOG_ERR,\
+                     "adslAtucIntervalTable_handler: unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable.h open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable.h	2009-12-16 12:59:19.000000000 +0530
@@ -0,0 +1,83 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucChanIntervalTable.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                    1) Include files
+ *                    2) Init Function proto-types for adslAtucIntervalTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATUCINTERVALTABLE_H
+#define ADSLATUCINTERVALTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/** other required module components */
+config_require(adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_access)
+
+/* column number definitions for table adslAtucIntervalTable  */
+#include "adslAtucIntervalTable_columns.h"
+
+/* enum definions  */
+#include "adslAtucIntervalTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/* function declarations */
+void            init_adslAtucIntervalTable(void);
+void            initialize_table_adslAtucIntervalTable(void);
+Netsnmp_Node_Handler adslAtucIntervalTable_handler;
+
+
+
+
+#endif /** ADSLATUCINTERVALTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_access.c	2009-12-16 12:59:19.000000000 +0530
@@ -0,0 +1,405 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucIntervalTable_access.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) for data
+ *                  in table adslAtucIntervalTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Return type for get_adslAtucIntervalValidData changed from long
+ *   to int
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucIntervalTable_access.h"
+#include "adslAtucIntervalTable_enums.h"
+
+/** column number definitions for table adslAtucIntervalTable **/
+#include "adslAtucIntervalTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+// *** Global variable definitions
+static u_int32 long_ret;
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** returns the first data point within the adslAtucIntervalTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAtucIntervalTable_get_first_data_point(void **my_loop_context,
+                                           void **my_data_context,
+                                           netsnmp_variable_list *
+                                           put_index_data,
+                                           netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-First: adslAtucIntervalTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAtucIntervalTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAtucIntervalTable_get_next_data_point(void **my_loop_context,
+                                          void **my_data_context,
+                                          netsnmp_variable_list *
+                                          put_index_data,
+                                          netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-Next: adslAtucIntervalTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/*
+ * User-defined data access functions (per column) for data in table
+ * adslAtucIntervalTable
+ */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+#if defined(HAVE_OPTIMIZED_CODE)
+
+u_int32      *
+get_adslAtucIntervalData(void *data_context, size_t * ret_len, 
+		unsigned int var)
+{
+   unsigned int flags = 0;
+   struct adslAtucIntvlInfo adslAtucIntvlStruct;
+   memset(&adslAtucIntvlStruct,0,sizeof(adslAtucIntvlInfo));
+   adslAtucIntvlStruct.ifIndex= (*(int *)data_context);
+   adslAtucIntvlStruct.IntervalNumber= (*(int *)ret_len);
+  
+  switch (var) {
+
+    case COLUMN_ADSLATUCINTERVALLOFS:
+  	flags = ATUC_INTVL_LOF_FLAG;
+        break;
+	
+    case COLUMN_ADSLATUCINTERVALLOSS:
+	flags = ATUC_INTVL_LOS_FLAG;
+	break;
+	
+    case COLUMN_ADSLATUCINTERVALESS:
+	flags = ATUC_INTVL_ESS_FLAG;
+	break;
+
+    case COLUMN_ADSLATUCINTERVALINITS:
+	flags = ATUC_INTVL_INIT_FLAG;
+	break;
+	
+    default:
+     	DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+        return NULL;
+  }
+
+  SET_FLAG(&adslAtucIntvlStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_INTVL_INFO, &adslAtucIntvlStruct);
+#else
+    get_adslAtucIntervalTable(Fd, GET_ADSL_ATUC_INTVL_INFO,
+        (void *) &adslAtucIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucIntvlStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "IntervalTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+
+	 case ATUC_INTVL_LOF_FLAG:
+    	    long_ret = adslAtucIntvlStruct.intervalLOF;
+            break;
+	 
+	 case ATUC_INTVL_LOS_FLAG:
+    	    long_ret = adslAtucIntvlStruct.intervalLOS;
+	    break;
+	  
+	 case ATUC_INTVL_ESS_FLAG:
+    	    long_ret = adslAtucIntvlStruct.intervalES;
+	    break;
+	  
+	 case ATUC_INTVL_INIT_FLAG:
+    	    long_ret = adslAtucIntvlStruct.intervalInits;
+	    break;
+
+         default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+     }
+     
+    CLR_FLAG(&adslAtucIntvlStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+#else
+/** XXX: return a data pointer to the data for the adslAtucIntervalLofs
+    column and set ret_len to its proper size in bytes. */
+
+u_int32      *
+get_adslAtucIntervalLofs(void *data_context, size_t * ret_len)
+{
+    struct adslAtucIntvlInfo adslAtucIntvlStruct;
+
+    memset(&adslAtucIntvlStruct,0,sizeof(adslAtucIntvlInfo));
+    adslAtucIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAtucIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAtucIntvlStruct.flags, ATUC_INTVL_LOF_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_INTVL_INFO, &adslAtucIntvlStruct);
+#else
+    get_adslAtucIntervalTable(Fd, GET_ADSL_ATUC_INTVL_INFO,
+        (void *) &adslAtucIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucIntvlStruct.flags, ATUC_INTVL_LOF_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanIntvlLOF CMV fail\n"));
+
+    CLR_FLAG(&adslAtucIntvlStruct.flags, ATUC_INTVL_LOF_FLAG);
+    long_ret = adslAtucIntvlStruct.intervalLOF;
+    *ret_len = sizeof(adslAtucIntvlStruct.intervalLOF);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucIntervalLoss column
+    and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAtucIntervalLoss(void *data_context, size_t * ret_len)
+{
+        struct adslAtucIntvlInfo adslAtucIntvlStruct;
+
+        memset(&adslAtucIntvlStruct,0,sizeof(adslAtucIntvlInfo));
+    adslAtucIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAtucIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAtucIntvlStruct.flags, ATUC_INTVL_LOS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_INTVL_INFO, &adslAtucIntvlStruct);
+#else
+    get_adslAtucIntervalTable(Fd, GET_ADSL_ATUC_INTVL_INFO,
+        (void *) &adslAtucIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucIntvlStruct.flags, ATUC_INTVL_LOS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanIntvlLOS CMV fail\n"));
+
+    CLR_FLAG(&adslAtucIntvlStruct.flags, ATUC_INTVL_LOS_FLAG);
+    long_ret = adslAtucIntvlStruct.intervalLOS;
+    *ret_len = sizeof(adslAtucIntvlStruct.intervalLOS);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucIntervalESs column
+    and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAtucIntervalESs(void *data_context, size_t * ret_len)
+{
+    struct adslAtucIntvlInfo adslAtucIntvlStruct;
+
+    memset(&adslAtucIntvlStruct,0,sizeof(adslAtucIntvlInfo));
+    adslAtucIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAtucIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAtucIntvlStruct.flags, ATUC_INTVL_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_INTVL_INFO, &adslAtucIntvlStruct);
+#else
+    get_adslAtucIntervalTable(Fd, GET_ADSL_ATUC_INTVL_INFO,
+        (void *) &adslAtucIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucIntvlStruct.flags, ATUC_INTVL_ESS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanIntvlESS CMV fail\n"));
+
+    CLR_FLAG(&adslAtucIntvlStruct.flags, ATUC_INTVL_ESS_FLAG);
+    long_ret = adslAtucIntvlStruct.intervalES;
+    *ret_len = sizeof(adslAtucIntvlStruct.intervalES);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucIntervalInits column
+    and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAtucIntervalInits(void *data_context, size_t * ret_len)
+{
+    struct adslAtucIntvlInfo adslAtucIntvlStruct;
+
+    memset(&adslAtucIntvlStruct,0,sizeof(adslAtucIntvlInfo));
+    adslAtucIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAtucIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAtucIntvlStruct.flags, ATUC_INTVL_INIT_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_INTVL_INFO, &adslAtucIntvlStruct);
+#else
+    get_adslAtucIntervalTable(Fd, GET_ADSL_ATUC_INTVL_INFO,
+        (void *) &adslAtucIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucIntvlStruct.flags, ATUC_INTVL_INIT_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanIntvlInit CMV fail\n"));
+       
+    CLR_FLAG(&adslAtucIntvlStruct.flags, ATUC_INTVL_INIT_FLAG);
+    long_ret = adslAtucIntvlStruct.intervalInits;
+    *ret_len = sizeof(adslAtucIntvlStruct.intervalInits);
+    return (u_int32 *) &long_ret;
+}
+
+#endif
+
+/** XXX: return a data pointer to the data for the adslAtucIntervalValidData
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAtucIntervalValidData(void *data_context, size_t * ret_len)
+{
+    struct adslAtucIntvlInfo adslAtucIntvlStruct;
+
+    memset(&adslAtucIntvlStruct,0,sizeof(adslAtucIntvlInfo));
+    adslAtucIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAtucIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAtucIntvlStruct.flags, ATUC_INTVL_VALID_DATA_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_INTVL_INFO, &adslAtucIntvlStruct);
+#else
+    get_adslAtucIntervalTable(Fd, GET_ADSL_ATUC_INTVL_INFO,
+        (void *) &adslAtucIntvlStruct);
+#endif
+   if (IS_FLAG_SET(&adslAtucIntvlStruct.flags, ATUC_INTVL_VALID_DATA_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "ChanIntvlValidData CMV fail\n"));
+
+    CLR_FLAG(&adslAtucIntvlStruct.flags, ATUC_INTVL_VALID_DATA_FLAG);
+    long_ret = adslAtucIntvlStruct.intervalValidData;
+    *ret_len = sizeof(adslAtucIntvlStruct.intervalValidData);
+    return (int *) &long_ret;
+}
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAtucIntervalTable(int Fd2,int GET_adsl_ATUC_INTVL_INFO2,
+        void *adslAtucInvtlTable)
+{
+        struct adslAtucIntvlInfo *adslAtucInvtlValue;
+        adslAtucInvtlValue = (adslAtucIntvlInfo *)adslAtucInvtlTable;
+        adslAtucInvtlValue->intervalLOF = 10;
+        adslAtucInvtlValue->intervalLOS = 20;
+        adslAtucInvtlValue->intervalES = 30;
+        adslAtucInvtlValue->intervalInits = 40;
+        adslAtucInvtlValue->intervalValidData = 1;
+        return 0;
+}
+
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_access.h	2009-12-16 12:59:19.000000000 +0530
@@ -0,0 +1,118 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucIntervalTable_access.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:    This file contains :
+ *              1)  Include files
+ *              2)  User defined data types
+ *              3)  Function proto-types for adslAtucIntervalTable_access
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Return type for get_adslAtucIntervalValidData changed from long
+ *   to int
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+//#include <adslMIBincl.h>
+
+#ifndef ADSLATUCINTERVALTABLE_ACCESS_H
+#define ADSLATUCINTERVALTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+#include <adslMIB/adslTable_access.h>
+
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+
+/** User-defined data structure for accessing adslAtucIntervalTable **/
+
+#ifdef STUB_IOCTL
+#define PerfIntervalCount u_int32
+
+typedef struct adslAtucIntvlInfo {
+    int ifIndex;
+    int IntervalNumber;
+    PerfIntervalCount intervalLOF;
+    PerfIntervalCount intervalLOS;
+    PerfIntervalCount intervalES;
+    PerfIntervalCount intervalInits;
+    int intervalValidData;
+    u_char flags;
+} adslAtucIntvlInfo;
+#endif
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/**User-defined data access functions for data in table adslAtucIntervalTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAtucIntervalTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAtucIntervalTable_get_next_data_point;
+
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+u_int32      *
+get_adslAtucIntervalData(void *data_context, size_t * ret_len, 
+		unsigned int var);
+#else
+u_int32    *get_adslAtucIntervalLofs(void *data_context, size_t * ret_len);
+u_int32    *get_adslAtucIntervalLoss(void *data_context, size_t * ret_len);
+u_int32    *get_adslAtucIntervalESs(void *data_context, size_t * ret_len);
+u_int32    *get_adslAtucIntervalInits(void *data_context, size_t * ret_len);
+#endif
+
+int       *get_adslAtucIntervalValidData(void *data_context, size_t * ret_len);
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAtucIntervalTable(int Fd2,int GET_adsl_ATUC_INTVL_INFO2,
+                void *adslAtucInvtlTable);
+#endif
+
+#endif                          /* ADSLATUCINTERVALTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_columns.h	2009-12-16 12:59:19.000000000 +0530
@@ -0,0 +1,61 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucIntervalTable_columns.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: column number definitions for table adslAtucIntervalTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATUCINTERVALTABLE_COLUMNS_H
+#define ADSLATUCINTERVALTABLE_COLUMNS_H
+
+/** column number definitions for table adslAtucIntervalTable **/
+#define COLUMN_ADSLATUCINTERVALNUMBER  1
+#define COLUMN_ADSLATUCINTERVALLOFS    2
+#define COLUMN_ADSLATUCINTERVALLOSS    3
+#define COLUMN_ADSLATUCINTERVALLOLS    4
+#define COLUMN_ADSLATUCINTERVALLPRS    5
+#define COLUMN_ADSLATUCINTERVALESS     6
+#define COLUMN_ADSLATUCINTERVALINITS   7
+#define COLUMN_ADSLATUCINTERVALVALIDDATA 8
+
+#endif                          /* ADSLATUCINTERVALTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucIntervalTable/adslAtucIntervalTable_enums.h	2009-12-16 12:59:19.000000000 +0530
@@ -0,0 +1,69 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucIntervalTable_enums.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: Constant definitions for table adslAtucIntervalTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATUCINTERVALTABLE_ENUMS_H
+#define ADSLATUCINTERVALTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAtucIntervalTable constants */
+#define GET_ADSL_ATUC_INTVL_INFO    60
+
+/* adslAtucIntervalTable Flags */
+#define ATUC_INTVL_LOF_FLAG     0x1     /* BIT 0th position */
+#define ATUC_INTVL_LOS_FLAG     0x2     /* BIT 1 */
+#define ATUC_INTVL_ESS_FLAG     0x4     /* BIT 2 */
+#define ATUC_INTVL_INIT_FLAG    0x8     /* BIT 3 */
+#define ATUC_INTVL_VALID_DATA_FLAG 0x10 /* BIT 4 */
+#endif
+
+/** enums for column adslAtucIntervalValidData **/
+#define ADSLATUCINTERVALVALIDDATA_TRUE      1
+#define ADSLATUCINTERVALVALIDDATA_FALSE     2
+
+#endif                          /* ADSLATUCINTERVALTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable.c open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable.c	2009-12-16 12:59:20.000000000 +0530
@@ -0,0 +1,270 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataExtTable.c
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslAtucPerfDataExtTable module
+ *               2) Handling requests for the adslAtucPerfDataExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucPerfDataExtTable.h"
+#include "adslAtucPerfDataExtTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** Initialize the adslAtucPerfDataExtTable table by defining its contents and how it's structured */
+void
+initialize_table_adslAtucPerfDataExtTable(void)
+{
+    static oid      adslAtucPerfDataExtTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 3, 1, 18 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAtucPerfDataExtTable",
+                                            adslAtucPerfDataExtTable_handler,
+                                            adslAtucPerfDataExtTable_oid,
+                                            OID_LENGTH
+                                            (adslAtucPerfDataExtTable_oid),
+                                            HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo) {
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_adslAtucPerfDataExtTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 16;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAtucPerfDataExtTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        adslAtucPerfDataExtTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAtucPerfDataExtTable_context_convert_function;
+    iinfo->free_data_context = adslAtucPerfDataExtTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAtucPerfDataExtTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAtucPerfDataExtTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAtucPerfDataExtTable",
+                "Registering table adslAtucPerfDataExtTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAtucPerfDataExtTable module */
+void
+init_adslAtucPerfDataExtTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAtucPerfDataExtTable();
+}
+
+/** handles requests for the adslAtucPerfDataExtTable table, if anything else needs to be done */
+int
+adslAtucPerfDataExtTable_handler(netsnmp_mib_handler *handler,
+                                 netsnmp_handler_registration *reginfo,
+                                 netsnmp_agent_request_info *reqinfo,
+                                 netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+
+
+    void           *data_context = NULL;
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_ADSLATUCPERFSTATFASTR:
+            case COLUMN_ADSLATUCPERFSTATFAILEDFASTR:
+            case COLUMN_ADSLATUCPERFSTATSESL:
+            case COLUMN_ADSLATUCPERFSTATUASL:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfStatSeconds(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFCURR15MINFASTR:
+            case COLUMN_ADSLATUCPERFCURR15MINFAILEDFASTR:
+            case COLUMN_ADSLATUCPERFCURR15MINSESL:
+            case COLUMN_ADSLATUCPERFCURR15MINUASL:
+            case COLUMN_ADSLATUCPERFCURR1DAYFASTR:
+            case COLUMN_ADSLATUCPERFCURR1DAYFAILEDFASTR:
+            case COLUMN_ADSLATUCPERFCURR1DAYSESL:
+            case COLUMN_ADSLATUCPERFCURR1DAYUASL:
+            case COLUMN_ADSLATUCPERFPREV1DAYFASTR:
+            case COLUMN_ADSLATUCPERFPREV1DAYFAILEDFASTR:
+            case COLUMN_ADSLATUCPERFPREV1DAYSESL:
+            case COLUMN_ADSLATUCPERFPREV1DAYUASL:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfIntervalSeconds(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+		
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+   "problem encountered in adslAtucPerfDataExtTable_handler: unknown column\n");
+            }
+            break;
+
+        default:
+            snmp_log(LOG_ERR,
+  "problem encountered in adslAtucPerfDataExtTable_handler:unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable.h open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable.h	2009-12-16 12:59:20.000000000 +0530
@@ -0,0 +1,90 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataExtTable.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                    1) Include files
+ *                    2) Init Function proto-types for adslAtucPerfDataExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATUCPERFDATAEXTTABLE_H
+#define ADSLATUCPERFDATAEXTTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/** other required module components */
+config_require(adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_access)
+
+/*
+ * column number definitions for table adslAtucPerfDataExtTable
+ */
+#include "adslAtucPerfDataExtTable_columns.h"
+
+/*
+ * enum definions
+ */
+#include "adslAtucPerfDataExtTable_enums.h"
+
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+    /*
+     * function declarations
+     */
+     void            init_adslAtucPerfDataExtTable(void);
+     void            initialize_table_adslAtucPerfDataExtTable(void);
+     Netsnmp_Node_Handler adslAtucPerfDataExtTable_handler;
+
+
+#endif /** ADSLATUCPERFDATAEXTTABLE_H */
+
+
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_access.c	2009-12-16 12:59:20.000000000 +0530
@@ -0,0 +1,420 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataExtTable_access.c
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) to get
+ *                     data for the table adslAtucPerfDataExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucPerfDataExtTable_access.h"
+#include "adslAtucPerfDataExtTable_enums.h"
+
+/* column number definitions for table adslAtucPerfDataExtTable */
+#include "adslAtucPerfDataExtTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+// *** Global variable definitions
+static u_int32 long_ret;
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** returns the first data point within the adslAtucPerfDataExtTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAtucPerfDataExtTable_get_first_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+        "Get-First: adslAtucPerfDataExtTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAtucPerfDataExtTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAtucPerfDataExtTable_get_next_data_point(void **my_loop_context,
+                                             void **my_data_context,
+                                             netsnmp_variable_list *
+                                             put_index_data,
+                                             netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+       "Get-Next: adslAtucPerfDataExtTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+/*
+ * User-defined data access functions (per column) for data in table
+ * adslAtucPerfDataExtTable
+ */
+
+u_int32  *get_adslAtucPerfStatSeconds(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct atucPerfDataExtEntry atucPerfDataExtEntryStruct;
+  memset(&atucPerfDataExtEntryStruct,0,sizeof(atucPerfDataExtEntry));
+  atucPerfDataExtEntryStruct.ifIndex= (*(int *)data_context);
+ 
+  switch (var)  {
+
+	case COLUMN_ADSLATUCPERFSTATFASTR:
+	   flags = ATUC_PERF_STAT_FASTR_FLAG;
+	   break;
+
+	case COLUMN_ADSLATUCPERFSTATFAILEDFASTR:
+	   flags = ATUC_PERF_STAT_FAILED_FASTR_FLAG;
+	   break;
+
+	case COLUMN_ADSLATUCPERFSTATSESL:
+	   flags = ATUC_PERF_STAT_SESL_FLAG;
+	   break;
+	   
+	case COLUMN_ADSLATUCPERFSTATUASL:
+	   flags = ATUC_PERF_STAT_UASL_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  }
+
+  SET_FLAG(&atucPerfDataExtEntryStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+  adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA_EXT , (void *) &atucPerfDataExtEntryStruct);
+#else
+  get_adslAtucPerfDataExtTable(Fd, GET_ADSL_ATUC_PERF_DATA_EXT, (void *) &atucPerfDataExtEntryStruct);
+#endif
+  if (IS_FLAG_SET(&atucPerfDataExtEntryStruct.flags, flags) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataExtTable: GET- %x CMV fail\n", flags));
+  
+    switch (flags)  {
+	    
+	case ATUC_PERF_STAT_FASTR_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfStatFastR;
+	   break;
+
+	case ATUC_PERF_STAT_FAILED_FASTR_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfStatFailedFastR;
+	   break;
+
+	case ATUC_PERF_STAT_SESL_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfStatSesL;
+	   break;
+		
+	case ATUC_PERF_STAT_UASL_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfStatUasL;
+	   break;
+
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+
+    CLR_FLAG(&atucPerfDataExtEntryStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+
+u_int32  *get_adslAtucPerfIntervalSeconds(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct atucPerfDataExtEntry atucPerfDataExtEntryStruct;
+  memset(&atucPerfDataExtEntryStruct,0,sizeof(atucPerfDataExtEntry));
+  atucPerfDataExtEntryStruct.ifIndex= (*(int *)data_context);
+ 
+  switch (var)  {
+
+	case COLUMN_ADSLATUCPERFCURR15MINFASTR:
+	   flags = ATUC_PERF_CURR_15MIN_FASTR_FLAG;
+	   break;
+
+	case COLUMN_ADSLATUCPERFCURR15MINFAILEDFASTR:
+	   flags = ATUC_PERF_CURR_15MIN_FAILED_FASTR_FLAG;
+	   break;
+
+	case COLUMN_ADSLATUCPERFCURR15MINSESL:
+	   flags = ATUC_PERF_CURR_15MIN_SESL_FLAG;
+	   break;
+	   
+	case COLUMN_ADSLATUCPERFCURR15MINUASL:
+	   flags = ATUC_PERF_CURR_15MIN_UASL_FLAG;
+	   break;
+
+	case COLUMN_ADSLATUCPERFCURR1DAYFASTR:
+	   flags = ATUC_PERF_CURR_1DAY_FASTR_FLAG;
+	   break;
+	   
+	case COLUMN_ADSLATUCPERFCURR1DAYFAILEDFASTR:
+	   flags = ATUC_PERF_CURR_1DAY_FAILED_FASTR_FLAG;
+	   break;
+	   
+	case COLUMN_ADSLATUCPERFCURR1DAYSESL:
+	   flags = ATUC_PERF_CURR_1DAY_SESL_FLAG;
+	   break;
+	   
+	case COLUMN_ADSLATUCPERFCURR1DAYUASL:
+	   flags = ATUC_PERF_CURR_1DAY_UASL_FLAG;
+	   break;
+
+	case COLUMN_ADSLATUCPERFPREV1DAYFASTR:
+	   flags = ATUC_PERF_PREV_1DAY_FASTR_FLAG;
+	   break;
+	   
+	case COLUMN_ADSLATUCPERFPREV1DAYFAILEDFASTR:
+	   flags = ATUC_PERF_PREV_1DAY_FAILED_FASTR_FLAG;
+	   break;
+	   
+	case COLUMN_ADSLATUCPERFPREV1DAYSESL:
+	   flags = ATUC_PERF_PREV_1DAY_SESL_FLAG;
+	   break;
+	   
+	case COLUMN_ADSLATUCPERFPREV1DAYUASL:
+	   flags = ATUC_PERF_PREV_1DAY_UASL_FLAG;
+	   break;
+	   
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  }
+
+  SET_FLAG(&atucPerfDataExtEntryStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+  adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA_EXT , (void *) &atucPerfDataExtEntryStruct);
+#else
+  get_adslAtucPerfDataExtTable(Fd, GET_ADSL_ATUC_PERF_DATA_EXT, (void *) &atucPerfDataExtEntryStruct);
+#endif
+  if (IS_FLAG_SET(&atucPerfDataExtEntryStruct.flags, flags) == 0)
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataExtTable: GET- %x CMV fail\n", flags));
+  
+    switch (flags)  {
+	    
+	case ATUC_PERF_CURR_15MIN_FASTR_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfCurr15MinFastR;
+	   break;
+
+	case ATUC_PERF_CURR_15MIN_FAILED_FASTR_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfCurr15MinFailedFastR;
+	   break;
+
+	case ATUC_PERF_CURR_15MIN_SESL_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfCurr15MinSesL;
+	   break;
+		
+	case ATUC_PERF_CURR_15MIN_UASL_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfCurr15MinUasL;
+	   break;
+
+	case ATUC_PERF_CURR_1DAY_FASTR_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfCurr1DayFastR;
+	   break;
+
+	case ATUC_PERF_CURR_1DAY_FAILED_FASTR_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfCurr1DayFailedFastR;
+	   break;
+
+	case ATUC_PERF_CURR_1DAY_SESL_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfCurr1DaySesL;
+	   break;
+
+	case ATUC_PERF_CURR_1DAY_UASL_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfCurr1DayUasL;
+	   break;
+	   
+	case ATUC_PERF_PREV_1DAY_FASTR_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfPrev1DayFastR;
+	   break;
+
+	case ATUC_PERF_PREV_1DAY_FAILED_FASTR_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfPrev1DayFailedFastR;
+	   break;
+
+	case ATUC_PERF_PREV_1DAY_SESL_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfPrev1DaySesL;
+	   break;
+
+	case ATUC_PERF_PREV_1DAY_UASL_FLAG:
+    	   long_ret = atucPerfDataExtEntryStruct.adslAtucPerfPrev1DayUasL;
+	   break;
+
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+
+    CLR_FLAG(&atucPerfDataExtEntryStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAtucPerfDataExtTable(int Fd2,int GET_adsl_ATUC_PERF_DATA2,
+        void *atucPerfDataValue)
+{
+
+    struct atucPerfDataExtEntry *atucPerfData;
+    atucPerfData = (atucPerfDataExtEntry *) atucPerfDataValue;
+
+    atucPerfData->adslAtucPerfStatFastR = 10;
+
+    atucPerfData->adslAtucPerfStatFailedFastR = 20;
+
+    atucPerfData->adslAtucPerfStatSesL = 30;
+
+    atucPerfData->adslAtucPerfStatUasL = 40;
+
+    atucPerfData->adslAtucPerfCurr15MinFastR = 10;
+
+    atucPerfData->adslAtucPerfCurr15MinFailedFastR = 20;
+
+    atucPerfData->adslAtucPerfCurr15MinSesL = 10;
+
+    atucPerfData->adslAtucPerfCurr15MinUasL = 15;
+
+    atucPerfData->adslAtucPerfCurr1DayFastR = 20;
+
+    atucPerfData->adslAtucPerfCurr1DayFailedFastR = 25;
+
+    atucPerfData->adslAtucPerfCurr1DaySesL = 30;
+
+    atucPerfData->adslAtucPerfCurr1DayUasL = 40;
+
+    atucPerfData->adslAtucPerfPrev1DayFastR = 50;
+
+    atucPerfData->adslAtucPerfPrev1DayFailedFastR = 60;
+
+    atucPerfData->adslAtucPerfPrev1DaySesL = 65;
+
+    atucPerfData->adslAtucPerfPrev1DayUasL = 70;
+
+    return 0;
+}
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_access.h	2009-12-16 12:59:20.000000000 +0530
@@ -0,0 +1,120 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataExtTable_access.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *              1)  Include files
+ *              2)  User defined data types
+ *              3)  Function proto-types for adslAtucPerfDataExtTable_access
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+#ifndef ADSLATUCPERFDATAEXTTABLE_ACCESS_H
+#define ADSLATUCPERFDATAEXTTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslAtucPerfDataExtTable **/
+
+typedef struct atucPerfDataExtEntry
+ {
+  int ifIndex;
+  u_int32 adslAtucPerfStatFastR;
+  u_int32 adslAtucPerfStatFailedFastR;
+  u_int32 adslAtucPerfStatSesL;
+  u_int32 adslAtucPerfStatUasL;
+  u_int32 adslAtucPerfCurr15MinFastR;
+  u_int32 adslAtucPerfCurr15MinFailedFastR;
+  u_int32 adslAtucPerfCurr15MinSesL;
+  u_int32 adslAtucPerfCurr15MinUasL;
+  u_int32 adslAtucPerfCurr1DayFastR;
+  u_int32 adslAtucPerfCurr1DayFailedFastR;
+  u_int32 adslAtucPerfCurr1DaySesL;
+  u_int32 adslAtucPerfCurr1DayUasL;
+  u_int32 adslAtucPerfPrev1DayFastR;
+  u_int32 adslAtucPerfPrev1DayFailedFastR;
+  u_int32 adslAtucPerfPrev1DaySesL;
+  u_int32 adslAtucPerfPrev1DayUasL;
+  u_int32	flags;
+} atucPerfDataExtEntry;
+
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+
+/** User-defined data access functions for data in table
+    adslAtucPerfDataExtTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAtucPerfDataExtTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAtucPerfDataExtTable_get_next_data_point;
+
+u_int32         *get_adslAtucPerfStatSeconds(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+u_int32         *get_adslAtucPerfIntervalSeconds(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+
+#ifndef ENABLE_DRIVER_CALL
+
+int get_adslAtucPerfDataExtTable(int Fd2,int GET_adsl_ATUC_PERF_DATA2,
+					void *atucPerfDataValue);
+#endif
+
+
+#endif                          /* ADSLATUCPERFDATAEXTTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_columns.h	2009-12-16 12:59:20.000000000 +0530
@@ -0,0 +1,72 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataExtTable_columns.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:  column number definitions for table adslAtucPerfDataExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATUCPERFDATAEXTTABLE_COLUMNS_H
+#define ADSLATUCPERFDATAEXTTABLE_COLUMNS_H
+
+/*
+ * column number definitions for table adslAtucPerfDataExtTable
+ */
+#define COLUMN_ADSLATUCPERFSTATFASTR		1
+#define COLUMN_ADSLATUCPERFSTATFAILEDFASTR		2
+#define COLUMN_ADSLATUCPERFSTATSESL		3
+#define COLUMN_ADSLATUCPERFSTATUASL		4
+#define COLUMN_ADSLATUCPERFCURR15MINFASTR		5
+#define COLUMN_ADSLATUCPERFCURR15MINFAILEDFASTR		6
+#define COLUMN_ADSLATUCPERFCURR15MINSESL		7
+#define COLUMN_ADSLATUCPERFCURR15MINUASL		8
+#define COLUMN_ADSLATUCPERFCURR1DAYFASTR		9
+#define COLUMN_ADSLATUCPERFCURR1DAYFAILEDFASTR		10
+#define COLUMN_ADSLATUCPERFCURR1DAYSESL		11
+#define COLUMN_ADSLATUCPERFCURR1DAYUASL		12
+#define COLUMN_ADSLATUCPERFPREV1DAYFASTR		13
+#define COLUMN_ADSLATUCPERFPREV1DAYFAILEDFASTR		14
+#define COLUMN_ADSLATUCPERFPREV1DAYSESL		15
+#define COLUMN_ADSLATUCPERFPREV1DAYUASL		16
+#endif                          /* ADSLATUCPERFDATAEXTTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable_enums.h	2009-12-16 12:59:20.000000000 +0530
@@ -0,0 +1,78 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataExtTable_enums.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: Constant definitions for table adslAtucPerfDataExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATUCPERFDATAEXTTABLE_ENUMS_H
+#define ADSLATUCPERFDATAEXTTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+
+/* adslAtucPerfDataExtTable constants */
+#define GET_ADSL_ATUC_PERF_DATA_EXT 205
+
+/* adslAtucPerfDataExtTable flags */
+#define ATUC_PERF_STAT_FASTR_FLAG	   0x1 /* BIT 0th position */
+#define ATUC_PERF_STAT_FAILED_FASTR_FLAG 0x2 /* BIT 1 */
+#define ATUC_PERF_STAT_SESL_FLAG 	   0X4	/* BIT 2 */
+#define ATUC_PERF_STAT_UASL_FLAG		   0X8	/* BIT 3 */
+#define ATUC_PERF_CURR_15MIN_FASTR_FLAG	   0X10	/* BIT 4 */
+#define ATUC_PERF_CURR_15MIN_FAILED_FASTR_FLAG 0X20	/* BIT 5 */
+#define ATUC_PERF_CURR_15MIN_SESL_FLAG	         0X40	/* BIT 6 */
+#define ATUC_PERF_CURR_15MIN_UASL_FLAG		    0X80	/* BIT 7 */
+#define ATUC_PERF_CURR_1DAY_FASTR_FLAG		    0X100	/* BIT 8 */
+#define ATUC_PERF_CURR_1DAY_FAILED_FASTR_FLAG	0X200	/* BIT 9 */
+#define ATUC_PERF_CURR_1DAY_SESL_FLAG			0X400	/* BIT 10 */
+#define ATUC_PERF_CURR_1DAY_UASL_FLAG			0X800	/* BIT 11 */
+#define ATUC_PERF_PREV_1DAY_FASTR_FLAG		     0X1000 /* BIT 12 */
+#define ATUC_PERF_PREV_1DAY_FAILED_FASTR_FLAG	0X2000 /* BIT 13 */
+#define ATUC_PERF_PREV_1DAY_SESL_FLAG			0X4000 /* BIT 14 */
+#define ATUC_PERF_PREV_1DAY_UASL_FLAG			0X8000 /* BIT 15 */
+
+#endif
+
+#endif                          /* ADSLATUCPERFDATAEXTTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable.c open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable.c	2009-12-16 12:59:20.000000000 +0530
@@ -0,0 +1,560 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataTable.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslAtucPerfDataTable module
+ *               2) Handling requests for the adslAtucPerfDataTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:Data type of adslAtucPerfValidIntervals ,
+ * adslAtucPerfInvalidIntervals and   adslAtucPerfPrev1DayMoniSecs changed
+ * from long to int
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucPerfDataTable.h"
+#include "adslAtucPerfDataTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** Initialize the adslAtucPerfDataTable table by defining its contents
+    and how it's structured */
+void
+initialize_table_adslAtucPerfDataTable(void)
+{
+    static oid      adslAtucPerfDataTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 6 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAtucPerfDataTable",
+                                            adslAtucPerfDataTable_handler,
+                                            adslAtucPerfDataTable_oid,
+                                            OID_LENGTH
+                                            (adslAtucPerfDataTable_oid),
+                                            HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,\
+                 "malloc failed in initialize_table_adslAtucPerfDataTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 29;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAtucPerfDataTable_get_first_data_point;
+    iinfo->get_next_data_point = adslAtucPerfDataTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAtucPerfDataTable_context_convert_function;
+    iinfo->free_data_context = adslAtucPerfDataTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAtucPerfDataTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAtucPerfDataTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAtucPerfDataTable",\
+              "Registering table adslAtucPerfDataTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAtucPerfDataTable module */
+void
+init_adslAtucPerfDataTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAtucPerfDataTable();
+}
+
+/** handles requests for the adslAtucPerfDataTable table, if anything else
+    needs to be done */
+int
+adslAtucPerfDataTable_handler(netsnmp_mib_handler *handler,
+                              netsnmp_handler_registration *reginfo,
+                              netsnmp_agent_request_info *reqinfo,
+                              netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+	    case COLUMN_ADSLATUCPERFLOFS:
+	    case COLUMN_ADSLATUCPERFLOSS:
+	    case COLUMN_ADSLATUCPERFESS:
+	    case COLUMN_ADSLATUCPERFINITS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfDataLoss(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                       (const u_char *) retval, retval_len);
+                }
+		break;
+
+	    case COLUMN_ADSLATUCPERFVALIDINTERVALS:
+	    case COLUMN_ADSLATUCPERFINVALIDINTERVALS:
+	    case COLUMN_ADSLATUCPERFPREV1DAYMONISECS:
+                {
+                    int           *retval;
+                    size_t         retval_len = 0;
+                    retval =
+                        get_adslAtucPerfIntervalData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                       (const u_char *) retval, retval_len);
+                }
+		break;
+
+	    case COLUMN_ADSLATUCPERFCURR15MINTIMEELAPSED:
+	    case COLUMN_ADSLATUCPERFCURR15MINLOFS:
+	    case COLUMN_ADSLATUCPERFCURR15MINLOSS:
+	    case COLUMN_ADSLATUCPERFCURR15MINESS:
+	    case COLUMN_ADSLATUCPERFCURR15MININITS:
+	    case COLUMN_ADSLATUCPERFCURR1DAYTIMEELAPSED:
+	    case COLUMN_ADSLATUCPERFCURR1DAYLOFS:
+	    case COLUMN_ADSLATUCPERFCURR1DAYLOSS:
+	    case COLUMN_ADSLATUCPERFCURR1DAYESS:
+	    case COLUMN_ADSLATUCPERFCURR1DAYINITS:
+	    case COLUMN_ADSLATUCPERFPREV1DAYLOFS:
+	    case COLUMN_ADSLATUCPERFPREV1DAYLOSS:
+	    case COLUMN_ADSLATUCPERFPREV1DAYESS:
+	    case COLUMN_ADSLATUCPERFPREV1DAYINITS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfDataStats(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                       (const u_char *) retval, retval_len);
+                }
+                break;
+
+#else
+            case COLUMN_ADSLATUCPERFLOFS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfLofs(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFLOSS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfLoss(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFESS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfESs(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFINITS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfInits(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFVALIDINTERVALS:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfValidIntervals(data_context,
+                                                       &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFINVALIDINTERVALS:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfInvalidIntervals(data_context,
+                                                         &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFCURR15MINTIMEELAPSED:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfCurr15MinTimeElapsed(data_context,
+                                                             &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFCURR15MINLOFS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfCurr15MinLofs(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                            (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFCURR15MINLOSS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfCurr15MinLoss(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                            (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFCURR15MINESS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfCurr15MinESs(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFCURR15MININITS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfCurr15MinInits(data_context,
+                                                       &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                            (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFCURR1DAYTIMEELAPSED:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfCurr1DayTimeElapsed(data_context,
+                                                            &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFCURR1DAYLOFS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfCurr1DayLofs(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFCURR1DAYLOSS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfCurr1DayLoss(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+             case COLUMN_ADSLATUCPERFCURR1DAYESS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfCurr1DayESs(data_context,
+                                                    &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFCURR1DAYINITS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfCurr1DayInits(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFPREV1DAYMONISECS:
+                {
+                     int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfPrev1DayMoniSecs(data_context,
+                                                         &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFPREV1DAYLOFS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfPrev1DayLofs(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFPREV1DAYLOSS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfPrev1DayLoss(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFPREV1DAYESS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfPrev1DayESs(data_context,
+                                                    &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCPERFPREV1DAYINITS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucPerfPrev1DayInits(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+#endif
+	    default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,\
+                         "adslAtucPerfDataTable_handler: unknown column\n");
+            }
+            break;
+
+        default:
+            snmp_log(LOG_ERR,\
+                     "adslAtucPerfDataTable_handler: unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable.h open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable.h	2009-12-16 12:59:21.000000000 +0530
@@ -0,0 +1,83 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataTable.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                    1) Include files
+ *                    2) Init Function proto-types for adslAtucPerfDataTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATUCPERFDATATABLE_H
+#define ADSLATUCPERFDATATABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/** other required module components */
+config_require(adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_access)
+
+/* column number definitions for table adslAtucPerfDataTable */
+#include "adslAtucPerfDataTable_columns.h"
+
+/* enum definions */
+#include "adslAtucPerfDataTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/* function declarations */
+void            init_adslAtucPerfDataTable(void);
+void            initialize_table_adslAtucPerfDataTable(void);
+Netsnmp_Node_Handler adslAtucPerfDataTable_handler;
+
+
+
+
+#endif /** ADSLATUCPERFDATATABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_access.c	2009-12-16 12:59:21.000000000 +0530
@@ -0,0 +1,1077 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataTable_access.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) for data
+ *                  in table adslAtucPerfDataTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:1)Return type of get_adslAtucPerfValidIntervals ,
+ * get_adslAtucPerfInvalidIntervals and get_adslAtucPerfPrev1DayMoniSecs
+ * changed from long to int
+ *       2) Data type of Static variable long_ret changed from long to u_int32
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucPerfDataTable_access.h"
+#ifdef STUB_IOCTL
+#include "adslAtucPerfDataTable_enums.h"
+#endif
+
+
+/* column number definitions for table adslAtucPerfDataTable */
+#include "adslAtucPerfDataTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+// *** Global variable definitions
+static u_int32 long_ret;
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** returns the first data point within the adslAtucPerfDataTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAtucPerfDataTable_get_first_data_point(void **my_loop_context,
+                                           void **my_data_context,
+                                           netsnmp_variable_list *
+                                           put_index_data,
+                                           netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-First: adslAtucPerfDataTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAtucPerfDataTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAtucPerfDataTable_get_next_data_point(void **my_loop_context,
+                                          void **my_data_context,
+                                          netsnmp_variable_list *
+                                          put_index_data,
+                                          netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-Next: adslAtucPerfDataTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/*
+ * User-defined data access functions (per column) for data in table
+ * adslAtucPerfDataTable
+ */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+#if defined(HAVE_OPTIMIZED_CODE)
+
+u_int32  *
+get_adslAtucPerfDataLoss(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct atucPerfDataEntry atucPerfDataEntryStruct;
+  memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+  atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+  
+  switch (var)  {
+
+	case COLUMN_ADSLATUCPERFLOFS:
+	   flags = ATUC_PERF_LOFS_FLAG;
+	   break;
+
+	case COLUMN_ADSLATUCPERFLOSS:
+	   flags = ATUC_PERF_LOSS_FLAG;
+	   break;
+
+	case COLUMN_ADSLATUCPERFESS:
+	   flags = ATUC_PERF_ESS_FLAG;
+	   break;
+	   
+	case COLUMN_ADSLATUCPERFINITS:
+	   flags = ATUC_PERF_INITS_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  }
+
+  SET_FLAG(&atucPerfDataEntryStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+            (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUC_PERF_LOFS_FLAG:
+    	   long_ret = atucPerfDataEntryStruct.adslAtucPerfLofs;
+	   break;
+
+	case ATUC_PERF_LOSS_FLAG:
+    	   long_ret = atucPerfDataEntryStruct.adslAtucPerfLoss;
+	   break;
+
+	case ATUC_PERF_ESS_FLAG:
+    	   long_ret = atucPerfDataEntryStruct.adslAtucPerfESs;
+	   break;
+		
+	case ATUC_PERF_INITS_FLAG:
+    	   long_ret = atucPerfDataEntryStruct.adslAtucPerfInits;
+	   break;
+
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+    
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+
+int *
+get_adslAtucPerfIntervalData(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct atucPerfDataEntry atucPerfDataEntryStruct;
+  memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+  atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+      case COLUMN_ADSLATUCPERFVALIDINTERVALS:
+	 flags = ATUC_PERF_VALID_INTVLS_FLAG;
+	 break;
+	 
+      case COLUMN_ADSLATUCPERFINVALIDINTERVALS:
+	 flags = ATUC_PERF_INVALID_INTVLS_FLAG;
+	 break;
+
+      case COLUMN_ADSLATUCPERFPREV1DAYMONISECS:
+	 flags = ATUC_PERF_PREV_1DAY_MON_SEC_FLAG;
+	 break;
+	 
+      default:
+     	 DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	 return NULL;
+ }
+  
+  SET_FLAG(&atucPerfDataEntryStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+            (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUC_PERF_VALID_INTVLS_FLAG:
+    	   long_ret = atucPerfDataEntryStruct.adslAtucPerfValidIntervals;
+	   break;
+
+	case ATUC_PERF_INVALID_INTVLS_FLAG:
+    	   long_ret = atucPerfDataEntryStruct.adslAtucPerfInvalidIntervals;
+	   break;
+
+	case ATUC_PERF_PREV_1DAY_MON_SEC_FLAG:
+    	   long_ret = atucPerfDataEntryStruct.adslAtucPerfPrev1DayMoniSecs;
+	   break;
+
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+    
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, flags);
+    *ret_len = sizeof(int);
+    return (int *) &long_ret;
+}
+
+
+u_int32  *
+get_adslAtucPerfDataStats(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct atucPerfDataEntry atucPerfDataEntryStruct;
+  memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+  atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+      case COLUMN_ADSLATUCPERFCURR15MINTIMEELAPSED:
+	 flags = ATUC_PERF_CURR_15MIN_TIME_ELAPSED_FLAG; 
+         break;
+	 
+      case COLUMN_ADSLATUCPERFCURR15MINLOFS:
+	 flags = ATUC_PERF_CURR_15MIN_LOFS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCPERFCURR15MINLOSS:
+	 flags = ATUC_PERF_CURR_15MIN_LOSS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCPERFCURR15MINESS:
+	 flags = ATUC_PERF_CURR_15MIN_ESS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCPERFCURR15MININITS:
+	 flags = ATUC_PERF_CURR_15MIN_INIT_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCPERFCURR1DAYTIMEELAPSED:
+	 flags = ATUC_PERF_CURR_1DAY_TIME_ELAPSED_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCPERFCURR1DAYLOFS:
+	 flags = ATUC_PERF_CURR_1DAY_LOFS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCPERFCURR1DAYLOSS:
+	 flags = ATUC_PERF_CURR_1DAY_LOSS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCPERFCURR1DAYESS:
+	 flags = ATUC_PERF_CURR_1DAY_ESS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCPERFCURR1DAYINITS:
+	 flags = ATUC_PERF_CURR_1DAY_INIT_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCPERFPREV1DAYLOFS:
+	 flags = ATUC_PERF_PREV_1DAY_LOFS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCPERFPREV1DAYLOSS:
+	 flags = ATUC_PERF_PREV_1DAY_LOSS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATUCPERFPREV1DAYESS:
+	 flags = ATUC_PERF_PREV_1DAY_ESS_FLAG;
+	 break;
+	 
+      case COLUMN_ADSLATUCPERFPREV1DAYINITS:
+	 flags = ATUC_PERF_PREV_1DAY_INITS_FLAG;
+	 break;
+	  
+      default:
+     	 DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+         return NULL;
+      }
+
+  SET_FLAG(&atucPerfDataEntryStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+            (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataTable: GET- %x CMV fail\n", flags));
+
+     switch (flags)  {
+
+	 case ATUC_PERF_CURR_15MIN_TIME_ELAPSED_FLAG:
+	    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr15MinTimeElapsed;
+            break;
+	 
+	 case ATUC_PERF_CURR_15MIN_LOFS_FLAG:
+	    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr15MinLofs;
+	    break;
+	  
+	 case ATUC_PERF_CURR_15MIN_LOSS_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr15MinLoss;
+	    break;
+	  
+	 case ATUC_PERF_CURR_15MIN_ESS_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr15MinESs;
+	    break;
+	  
+	 case ATUC_PERF_CURR_15MIN_INIT_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr15MinInits;
+	    break;
+	  
+	 case ATUC_PERF_CURR_1DAY_TIME_ELAPSED_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr1DayTimeElapsed;
+	    break;
+	  
+	 case ATUC_PERF_CURR_1DAY_LOFS_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr1DayLofs;
+	    break;
+	  
+	 case ATUC_PERF_CURR_1DAY_LOSS_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr1DayLoss;
+	    break;
+	  
+	 case ATUC_PERF_CURR_1DAY_ESS_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr1DayESs;
+	    break;
+	  
+	 case ATUC_PERF_CURR_1DAY_INIT_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr1DayInits;
+            break;
+	  
+	 case ATUC_PERF_PREV_1DAY_LOFS_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfPrev1DayLofs;
+	    break;
+	  
+	 case ATUC_PERF_PREV_1DAY_LOSS_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfPrev1DayLoss;
+	    break;
+	  
+	 case ATUC_PERF_PREV_1DAY_ESS_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfPrev1DayESs;
+	    break;
+	 
+	 case ATUC_PERF_PREV_1DAY_INITS_FLAG:
+    	    long_ret = atucPerfDataEntryStruct.adslAtucPerfPrev1DayInits;
+	    break;
+	  
+         default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+     }
+     
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+#else
+
+/** XXX: return a data pointer to the data for the adslAtucPerfLofs column
+    and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfLofs(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags, ATUC_PERF_LOFS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataLOFS CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_LOFS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfLofs;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfLofs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfLoss column
+    and set ret_len to its proper size in bytes. */
+
+u_int32         *
+get_adslAtucPerfLoss(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags, ATUC_PERF_LOSS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataLOSS CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_LOSS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfLoss;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfLoss);
+    return (u_int32 *) &long_ret;
+}
+
+
+/** XXX: return a data pointer to the data for the adslAtucPerfESs column and
+    set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfESs(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags, ATUC_PERF_ESS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataESS CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_ESS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfESs;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfESs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfInits column
+    and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfInits(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_INITS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if(IS_FLAG_SET(&atucPerfDataEntryStruct.flags, ATUC_PERF_INITS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataInit CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_INITS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfInits;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfInits);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfValidIntervals
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAtucPerfValidIntervals(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_VALID_INTVLS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+             ATUC_PERF_VALID_INTVLS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataValidIntvl CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_VALID_INTVLS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfValidIntervals;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfValidIntervals);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfInvalidIntervals
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAtucPerfInvalidIntervals(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_INVALID_INTVLS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+            ATUC_PERF_INVALID_INTVLS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataInvalidIntvl CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_INVALID_INTVLS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfInvalidIntervals;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfInvalidIntervals);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucPerfCurr15MinTimeElapsed column and set ret_len to its proper size
+    in bytes. */
+u_int32         *
+get_adslAtucPerfCurr15MinTimeElapsed(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_CURR_15MIN_TIME_ELAPSED_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+            ATUC_PERF_CURR_15MIN_TIME_ELAPSED_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataCurr15Min CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags,
+            ATUC_PERF_CURR_15MIN_TIME_ELAPSED_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr15MinTimeElapsed;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfCurr15MinTimeElapsed);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfCurr15MinLofs
+    column and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAtucPerfCurr15MinLofs(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_15MIN_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_CURR_15MIN_LOFS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataCurr15MinLOF CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_15MIN_LOFS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr15MinLofs;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfCurr15MinLofs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfCurr15MinLoss
+    column and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAtucPerfCurr15MinLoss(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_15MIN_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_CURR_15MIN_LOSS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataCurr15MinLOSS CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_15MIN_LOSS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr15MinLoss;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfCurr15MinLoss);
+    return (u_int32 *) &long_ret;
+}
+
+
+/** XXX: return a data pointer to the data for the adslAtucPerfCurr15MinESs
+    column and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAtucPerfCurr15MinESs(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_15MIN_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+            ATUC_PERF_CURR_15MIN_ESS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataCurr15MinESS CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_15MIN_ESS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr15MinESs;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfCurr15MinESs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfCurr15MinInits
+    column and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAtucPerfCurr15MinInits(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_15MIN_INIT_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_CURR_15MIN_INIT_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataCurr15MinInits CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_15MIN_INIT_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr15MinInits;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfCurr15MinInits);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucPerfCurr1DayTimeElapsed column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfCurr1DayTimeElapsed(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_CURR_1DAY_TIME_ELAPSED_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_CURR_1DAY_TIME_ELAPSED_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataCurr1DayElapse CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_CURR_1DAY_TIME_ELAPSED_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr1DayTimeElapsed;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfCurr1DayTimeElapsed);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfCurr1DayLofs
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfCurr1DayLofs(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_1DAY_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_CURR_1DAY_LOFS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataCurr1DayLOF CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_1DAY_LOFS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr1DayLofs;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfCurr1DayLofs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfCurr1DayLoss
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfCurr1DayLoss(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_1DAY_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_CURR_1DAY_LOSS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataCurr1DayLOSS CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_1DAY_LOSS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr1DayLoss;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfCurr1DayLoss);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfCurr1DayESs
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfCurr1DayESs(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_1DAY_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+         ATUC_PERF_CURR_1DAY_ESS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataCurr1DayESS CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_1DAY_ESS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr1DayESs;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfCurr1DayESs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfCurr1DayInits
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfCurr1DayInits(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_1DAY_INIT_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_CURR_1DAY_INIT_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataCurr1DayInit CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_CURR_1DAY_INIT_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfCurr1DayInits;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfCurr1DayInits);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfPrev1DayMoniSecs
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAtucPerfPrev1DayMoniSecs(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_PREV_1DAY_MON_SEC_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+            ATUC_PERF_PREV_1DAY_MON_SEC_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataPrev1DayMonSec CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_PREV_1DAY_MON_SEC_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfPrev1DayMoniSecs;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfPrev1DayMoniSecs);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfPrev1DayLofs
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfPrev1DayLofs(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_PREV_1DAY_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+            ATUC_PERF_PREV_1DAY_LOFS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataPrev1DayLOF CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_PREV_1DAY_LOFS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfPrev1DayLofs;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfPrev1DayLofs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfPrev1DayLoss
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfPrev1DayLoss(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_PREV_1DAY_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_PREV_1DAY_LOSS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataPrev1DayLOSS CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_PREV_1DAY_LOSS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfPrev1DayLoss;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfPrev1DayLoss);
+    return (u_int32 *) &long_ret;
+}
+
+
+/** XXX: return a data pointer to the data for the adslAtucPerfPrev1DayESs
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfPrev1DayESs(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_PREV_1DAY_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+         ATUC_PERF_PREV_1DAY_ESS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataPrev1DayESS CMV fail\n"));
+       
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_PREV_1DAY_ESS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfPrev1DayESs;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfPrev1DayESs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucPerfPrev1DayInits
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucPerfPrev1DayInits(void *data_context, size_t * ret_len)
+{
+    struct atucPerfDataEntry atucPerfDataEntryStruct;
+
+    memset(&atucPerfDataEntryStruct,0,sizeof(atucPerfDataEntry));
+    atucPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_PREV_1DAY_INITS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PERF_DATA, (void *) &atucPerfDataEntryStruct);
+#else
+    get_adslAtucPerfDataTable(Fd, GET_ADSL_ATUC_PERF_DATA,
+        (void *) &atucPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&atucPerfDataEntryStruct.flags,
+        ATUC_PERF_PREV_1DAY_INITS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PerfDataPrev1DayInit CMV fail\n"));
+
+    CLR_FLAG(&atucPerfDataEntryStruct.flags, ATUC_PERF_PREV_1DAY_INITS_FLAG);
+    long_ret = atucPerfDataEntryStruct.adslAtucPerfPrev1DayInits;
+    *ret_len = sizeof(atucPerfDataEntryStruct.adslAtucPerfPrev1DayInits);
+    return (u_int32 *) &long_ret;
+}
+#endif
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAtucPerfDataTable(int Fd2,int GET_adsl_ATUC_PERF_DATA2,
+        void *atucPerfDataValue)
+{
+
+    struct atucPerfDataEntry *atucPerfData;
+    atucPerfData = (atucPerfDataEntry *) atucPerfDataValue;
+    atucPerfData->adslAtucPerfLofs = 10;
+    atucPerfData->adslAtucPerfLoss = 20;
+    atucPerfData->adslAtucPerfESs = 30;
+    atucPerfData->adslAtucPerfInits = 40;
+    atucPerfData->adslAtucPerfValidIntervals = 10;
+    atucPerfData->adslAtucPerfInvalidIntervals = 20;
+    atucPerfData->adslAtucPerfCurr15MinTimeElapsed = 10;
+    atucPerfData->adslAtucPerfCurr15MinLofs = 15;
+    atucPerfData->adslAtucPerfCurr15MinLoss = 20;
+    atucPerfData->adslAtucPerfCurr15MinESs = 25;
+    atucPerfData->adslAtucPerfCurr15MinInits = 30;
+    atucPerfData->adslAtucPerfCurr1DayTimeElapsed = 40;
+    atucPerfData->adslAtucPerfCurr1DayLofs = 50;
+    atucPerfData->adslAtucPerfCurr1DayLoss = 60;
+    atucPerfData->adslAtucPerfCurr1DayESs = 65;
+    atucPerfData->adslAtucPerfCurr1DayInits = 70;
+    atucPerfData->adslAtucPerfPrev1DayMoniSecs = 80;
+    atucPerfData->adslAtucPerfPrev1DayLofs = 85;
+    atucPerfData->adslAtucPerfPrev1DayLoss = 90;
+    atucPerfData->adslAtucPerfPrev1DayESs = 95;
+    atucPerfData->adslAtucPerfPrev1DayInits = 100;
+
+    return 0;
+}
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_access.h	2009-12-16 12:59:21.000000000 +0530
@@ -0,0 +1,166 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataTable_access.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *              1)  Include files
+ *              2)  User defined data types
+ *              3)  Function proto-types for adslAtucPerfDataTable_access
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:1)Return type of get_adslAtucPerfValidIntervals ,
+ * get_adslAtucPerfInvalidIntervals and get_adslAtucPerfPrev1DayMoniSecs
+ * changed from long to int
+ * $Log$
+ * ===========================================================================
+s*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+//#include <adslMIBincl.h>
+
+
+#ifndef ADSLATUCPERFDATATABLE_ACCESS_H
+#define ADSLATUCPERFDATATABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslAtucPerfDataTable **/
+
+#define AdslPerfTimeElapsed u_int32
+#define PerfCurrentCount u_int32
+#define AdslPerfCurrDayCount u_int32
+#define AdslPerfPrevDayCount u_int32
+
+typedef struct atucPerfDataEntry
+{
+   int          ifIndex;
+   u_int32          adslAtucPerfLofs;
+   u_int32          adslAtucPerfLoss;
+   u_int32          adslAtucPerfESs;
+   u_int32          adslAtucPerfInits;
+   int              adslAtucPerfValidIntervals;
+   int              adslAtucPerfInvalidIntervals;
+   AdslPerfTimeElapsed  adslAtucPerfCurr15MinTimeElapsed;
+   PerfCurrentCount     adslAtucPerfCurr15MinLofs;
+   PerfCurrentCount     adslAtucPerfCurr15MinLoss;
+   PerfCurrentCount     adslAtucPerfCurr15MinESs;
+   PerfCurrentCount     adslAtucPerfCurr15MinInits;
+   AdslPerfTimeElapsed  adslAtucPerfCurr1DayTimeElapsed;
+   AdslPerfCurrDayCount adslAtucPerfCurr1DayLofs;
+   AdslPerfCurrDayCount adslAtucPerfCurr1DayLoss;
+   AdslPerfCurrDayCount adslAtucPerfCurr1DayESs;
+   AdslPerfCurrDayCount adslAtucPerfCurr1DayInits;
+   int              adslAtucPerfPrev1DayMoniSecs;
+   AdslPerfPrevDayCount adslAtucPerfPrev1DayLofs;
+   AdslPerfPrevDayCount adslAtucPerfPrev1DayLoss;
+   AdslPerfPrevDayCount adslAtucPerfPrev1DayESs;
+   AdslPerfPrevDayCount adslAtucPerfPrev1DayInits;
+   u_int32          flags;
+} atucPerfDataEntry;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/** User-defined data access functions for data in table
+    adslAtucPerfDataTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAtucPerfDataTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAtucPerfDataTable_get_next_data_point;
+
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+u_int32  *
+get_adslAtucPerfDataLoss(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+
+int *
+get_adslAtucPerfIntervalData(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+u_int32  *
+get_adslAtucPerfDataStats(void *data_context, size_t * ret_len,
+			unsigned int var);
+#else
+u_int32  *get_adslAtucPerfLofs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfLoss(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfESs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfInits(void *data_context, size_t * ret_len);
+int   *get_adslAtucPerfValidIntervals(void *data_context, size_t * ret_len);
+int   *get_adslAtucPerfInvalidIntervals(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfCurr15MinTimeElapsed(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAtucPerfCurr15MinLofs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfCurr15MinLoss(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfCurr15MinESs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfCurr15MinInits(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfCurr1DayTimeElapsed(void *data_context,
+            size_t *ret_len);
+u_int32  *get_adslAtucPerfCurr1DayLofs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfCurr1DayLoss(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfCurr1DayESs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfCurr1DayInits(void *data_context, size_t * ret_len);
+int     *get_adslAtucPerfPrev1DayMoniSecs(void *data_context,size_t * ret_len);
+u_int32  *get_adslAtucPerfPrev1DayLofs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfPrev1DayLoss(void *data_context, size_t * ret_len);
+u_int32  *get_adslAtucPerfPrev1DayESs(void *data_context,  size_t * ret_len);
+u_int32  *get_adslAtucPerfPrev1DayInits(void *data_context, size_t * ret_len);
+#endif
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAtucPerfDataTable(int Fd2,int GET_adsl_ATUC_PERF_DATA2,void *atucPerfDataValue);
+#endif
+
+#endif                          /* ADSLATUCPERFDATATABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_columns.h	2009-12-16 12:59:21.000000000 +0530
@@ -0,0 +1,82 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataTable_columns.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:  column number definitions for table adslAtucPerfDataTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATUCPERFDATATABLE_COLUMNS_H
+#define ADSLATUCPERFDATATABLE_COLUMNS_H
+
+/** column number definitions for table adslAtucPerfDataTable **/
+#define COLUMN_ADSLATUCPERFLOFS                 1
+#define COLUMN_ADSLATUCPERFLOSS                 2
+#define COLUMN_ADSLATUCPERFLOLS                 3
+#define COLUMN_ADSLATUCPERFLPRS                 4
+#define COLUMN_ADSLATUCPERFESS                  5
+#define COLUMN_ADSLATUCPERFINITS                6
+#define COLUMN_ADSLATUCPERFVALIDINTERVALS       7
+#define COLUMN_ADSLATUCPERFINVALIDINTERVALS     8
+#define COLUMN_ADSLATUCPERFCURR15MINTIMEELAPSED 9
+#define COLUMN_ADSLATUCPERFCURR15MINLOFS        10
+#define COLUMN_ADSLATUCPERFCURR15MINLOSS        11
+#define COLUMN_ADSLATUCPERFCURR15MINLOLS        12
+#define COLUMN_ADSLATUCPERFCURR15MINLPRS        13
+#define COLUMN_ADSLATUCPERFCURR15MINESS         14
+#define COLUMN_ADSLATUCPERFCURR15MININITS       15
+#define COLUMN_ADSLATUCPERFCURR1DAYTIMEELAPSED  16
+#define COLUMN_ADSLATUCPERFCURR1DAYLOFS         17
+#define COLUMN_ADSLATUCPERFCURR1DAYLOSS         18
+#define COLUMN_ADSLATUCPERFCURR1DAYLOLS         19
+#define COLUMN_ADSLATUCPERFCURR1DAYLPRS         20
+#define COLUMN_ADSLATUCPERFCURR1DAYESS          21
+#define COLUMN_ADSLATUCPERFCURR1DAYINITS        22
+#define COLUMN_ADSLATUCPERFPREV1DAYMONISECS     23
+#define COLUMN_ADSLATUCPERFPREV1DAYLOFS         24
+#define COLUMN_ADSLATUCPERFPREV1DAYLOSS         25
+#define COLUMN_ADSLATUCPERFPREV1DAYLOLS         26
+#define COLUMN_ADSLATUCPERFPREV1DAYLPRS         27
+#define COLUMN_ADSLATUCPERFPREV1DAYESS          28
+#define COLUMN_ADSLATUCPERFPREV1DAYINITS        29
+#endif                          /* ADSLATUCPERFDATATABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable_enums.h	2009-12-16 12:59:21.000000000 +0530
@@ -0,0 +1,80 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPerfDataTable_enums.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: Constant definitions for table adslAtucPerfDataTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATUCPERFDATATABLE_ENUMS_H
+#define ADSLATUCPERFDATATABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAtucPerfDataTable constants */
+#define GET_ADSL_ATUC_PERF_DATA 21
+
+/* adslAtucPerfDataTable Flags */
+#define ATUC_PERF_LOFS_FLAG     0x1         /* BIT 0th position */
+#define ATUC_PERF_LOSS_FLAG     0x2         /* BIT 1 */
+#define ATUC_PERF_ESS_FLAG      0x4 /* BIT 2 */
+#define ATUC_PERF_INITS_FLAG    0x8 /* BIT 3 */
+#define ATUC_PERF_VALID_INTVLS_FLAG 0x10 /* BIT 4 */
+#define ATUC_PERF_INVALID_INTVLS_FLAG   0x20        /* BIT 5 */
+#define ATUC_PERF_CURR_15MIN_TIME_ELAPSED_FLAG  0x40 /* BIT 6 */
+#define ATUC_PERF_CURR_15MIN_LOFS_FLAG      0x80     /* BIT 7 */
+#define ATUC_PERF_CURR_15MIN_LOSS_FLAG      0x100   /* BIT 8 */
+#define ATUC_PERF_CURR_15MIN_ESS_FLAG       0x200   /* BIT 9 */
+#define ATUC_PERF_CURR_15MIN_INIT_FLAG      0x400   /* BIT 10 */
+#define ATUC_PERF_CURR_1DAY_TIME_ELAPSED_FLAG 0x800 /* BIT 11 */
+#define ATUC_PERF_CURR_1DAY_LOFS_FLAG       0x1000  /* BIT 12 */
+#define ATUC_PERF_CURR_1DAY_LOSS_FLAG       0x2000  /* BIT 13 */
+#define ATUC_PERF_CURR_1DAY_ESS_FLAG        0x4000  /* BIT 14 */
+#define ATUC_PERF_CURR_1DAY_INIT_FLAG       0x8000  /* BIT 15 */
+#define ATUC_PERF_PREV_1DAY_MON_SEC_FLAG    0x10000 /* BIT 16 */
+#define ATUC_PERF_PREV_1DAY_LOFS_FLAG       0x20000 /* BIT 17 */
+#define ATUC_PERF_PREV_1DAY_LOSS_FLAG       0x40000 /* BIT 18 */
+#define ATUC_PERF_PREV_1DAY_ESS_FLAG        0x80000 /* BIT 19 */
+#define ATUC_PERF_PREV_1DAY_INITS_FLAG      0x100000 /* BIT 20 */
+#endif
+
+#endif                          /* ADSLATUCPERFDATATABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable.c open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable.c	2009-12-16 12:59:21.000000000 +0530
@@ -0,0 +1,326 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPhysTable.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslAtucPhysTable module
+ *               2) Handling requests for the adslAtucPhysTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:  24-Jun04 Changed the data types for ADSLATUCCURROUTPUTPWR and
+ *      ADSLATUCCURRATTAINABLERATE
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAtucPhysTable.h"
+#include "adslAtucPhysTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** Initialize the adslAtucPhysTable table by defining its contents and how
+    it's structured */
+void
+initialize_table_adslAtucPhysTable(void)
+{
+    static oid      adslAtucPhysTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 2 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler = netsnmp_create_handler_registration("adslAtucPhysTable",
+                                                     adslAtucPhysTable_handler,
+                                                     adslAtucPhysTable_oid,
+                                                     OID_LENGTH
+                                                     (adslAtucPhysTable_oid),
+                                                     HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,\
+                 "malloc failed in initialize_table_adslAtucPhysTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 8;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point = adslAtucPhysTable_get_first_data_point;
+    iinfo->get_next_data_point = adslAtucPhysTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context = adslAtucPhysTable_context_convert_function;
+    iinfo->free_data_context = adslAtucPhysTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAtucPhysTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAtucPhysTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAtucPhysTable",\
+                "Registering table adslAtucPhysTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAtucPhysTable module */
+void
+init_adslAtucPhysTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAtucPhysTable();
+}
+
+/** handles requests for the adslAtucPhysTable table, if anything else needs
+    to be done */
+int
+adslAtucPhysTable_handler(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+
+	    case COLUMN_ADSLATUCINVSERIALNUMBER:
+	    case COLUMN_ADSLATUCINVVENDORID:
+	    case COLUMN_ADSLATUCINVVERSIONNUMBER:
+                {
+                    char           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucInvData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                      (const u_char *) retval, retval_len);
+                }
+		break;
+
+#else
+            case COLUMN_ADSLATUCINVSERIALNUMBER:
+                {
+                    char           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucInvSerialNumber(data_context,
+                                                    &retval_len);
+                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCINVVENDORID:
+                {
+                    char           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucInvVendorID(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCINVVERSIONNUMBER:
+                {
+                    char           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucInvVersionNumber(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+#endif
+            case COLUMN_ADSLATUCCURRSTATUS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucCurrStatus(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCURROUTPUTPWR:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucCurrOutputPwr(data_context,
+                                                  &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCCURRATTAINABLERATE:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucCurrAttainableRate(data_context,
+                                                       &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,\
+                         "adslAtucPhysTable_handler: unknown column\n");
+            }
+            break;
+
+
+        default:
+            snmp_log(LOG_ERR,\
+                     "adslAtucPhysTable_handler: unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable.h open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable.h	2009-12-16 12:59:21.000000000 +0530
@@ -0,0 +1,82 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPhysTable.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                    1) Include files
+ *                    2) Init Function proto-types for adslAtucPhysTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATUCPHYSTABLE_H
+#define ADSLATUCPHYSTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/** other required module components */
+config_require(adslMIB/adslAtucPhysTable/adslAtucPhysTable_access)
+
+/* column number definitions for table adslAtucPhysTable */
+#include "adslAtucPhysTable_columns.h"
+
+/* enum definions */
+#include "adslAtucPhysTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/* function declarations */
+void            init_adslAtucPhysTable(void);
+void            initialize_table_adslAtucPhysTable(void);
+Netsnmp_Node_Handler adslAtucPhysTable_handler;
+
+
+
+
+#endif /** ADSLATUCPHYSTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_access.c	2009-12-16 12:59:21.000000000 +0530
@@ -0,0 +1,428 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPhysTable_access.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) for data
+ *                  in table adslAtucPhysTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:  24-Jun04 Changed the return types for get_adslAtucCurrOutputPwr
+ * and  get_adslAtucCurrAttainableRate
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#include "adslAtucPhysTable_access.h"
+#include "adslAtucPhysTable_enums.h"
+
+/* column number definitions for table adslAtucPhysTable */
+#include "adslAtucPhysTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+// *** Global variable definitions
+static u_int32 long_ret;
+static char sys_info[32]= "";
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** returns the first data point within the adslAtucPhysTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAtucPhysTable_get_first_data_point(void **my_loop_context,
+                                       void **my_data_context,
+                                       netsnmp_variable_list *
+                                       put_index_data,
+                                       netsnmp_iterator_info *mydata)
+{
+
+   int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-First: adslAtucPhysTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAtucPhysTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAtucPhysTable_get_next_data_point(void **my_loop_context,
+                                      void **my_data_context,
+                                      netsnmp_variable_list *
+                                      put_index_data,
+                                      netsnmp_iterator_info *mydata)
+{
+
+   int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-Next: adslAtucPhysTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/*
+ * User-defined data access functions (per column) for data in table
+ * adslAtucPhysTable
+ */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+#if defined(HAVE_OPTIMIZED_CODE)
+
+char  *
+get_adslAtucInvData(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslAtucPhysEntry adslAtucPhysStruct;
+  memset(&adslAtucPhysStruct,0,sizeof(adslAtucPhysEntry));
+  memset(sys_info,0,sizeof(sys_info));
+  adslAtucPhysStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+        case COLUMN_ADSLATUCINVSERIALNUMBER:
+	   flags = ATUC_PHY_SER_NUM_FLAG;
+	   break;
+
+        case COLUMN_ADSLATUCINVVENDORID:
+	   flags = ATUC_PHY_VENDOR_ID_FLAG;
+	   break;
+
+        case COLUMN_ADSLATUCINVVERSIONNUMBER:
+	   flags = ATUC_PHY_VER_NUM_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  	}
+  
+    SET_FLAG(&adslAtucPhysStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PHY,(void *) &adslAtucPhysStruct);
+#else
+    get_adslAtucPhysTable1(Fd, GET_ADSL_ATUC_PHY,(void *) &adslAtucPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucPhysStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "PhysTable: GET- %x CMV fail\n", flags));
+    
+    switch (flags)  {
+	    
+	case ATUC_PHY_SER_NUM_FLAG:
+    	   strcpy(sys_info,adslAtucPhysStruct.serial_no);
+    	   *ret_len = strlen(adslAtucPhysStruct.serial_no);
+	   break;
+
+	case ATUC_PHY_VENDOR_ID_FLAG:
+    	   strcpy(sys_info,adslAtucPhysStruct.vendor_id.vendor_id);
+           *ret_len = strlen(adslAtucPhysStruct.vendor_id.vendor_id);
+	   break;
+
+	case ATUC_PHY_VER_NUM_FLAG:
+    	   strcpy(sys_info,adslAtucPhysStruct.version_no);
+           *ret_len = strlen(adslAtucPhysStruct.version_no);
+	   break;
+	   
+        default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+           return NULL;
+	}
+
+    CLR_FLAG(&adslAtucPhysStruct.flags, flags);
+    return (char *) sys_info;
+}
+
+#else
+/** XXX: return a data pointer to the data for the adslAtucInvSerialNumber
+    column and set ret_len to its proper size in bytes. */
+char           *
+get_adslAtucInvSerialNumber(void *data_context, size_t * ret_len)
+{
+
+    struct adslAtucPhysEntry adslAtucPhysStruct;
+    memset(&adslAtucPhysStruct,0,sizeof(adslAtucPhysEntry));
+    adslAtucPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAtucPhysStruct.flags,ATUC_PHY_SER_NUM_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PHY, (void *)&adslAtucPhysStruct);
+#else
+    get_adslAtucPhysTable1(Fd, GET_ADSL_ATUC_PHY,(void *)&adslAtucPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucPhysStruct.flags, ATUC_PHY_SER_NUM_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "SerNum CMV fail\n"));
+       
+    CLR_FLAG(&adslAtucPhysStruct.flags, ATUC_PHY_SER_NUM_FLAG);
+    memset(sys_info,0,sizeof(sys_info));
+    strcpy(sys_info,adslAtucPhysStruct.serial_no);
+
+    *ret_len = strlen(adslAtucPhysStruct.serial_no);
+    return (char *) sys_info;
+}
+
+/** XXX: return a data pointer to the data for the adslAtucInvVendorID column
+    and set ret_len to its proper size in bytes. */
+char           *
+get_adslAtucInvVendorID(void *data_context, size_t * ret_len)
+{
+    struct adslAtucPhysEntry adslAtucPhysStruct;
+
+    memset(&adslAtucPhysStruct,0,sizeof(adslAtucPhysEntry));
+    adslAtucPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAtucPhysStruct.flags,ATUC_PHY_VENDOR_ID_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PHY,(void *) &adslAtucPhysStruct);
+#else
+    get_adslAtucPhysTable1(Fd, GET_ADSL_ATUC_PHY,(void *) &adslAtucPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucPhysStruct.flags, ATUC_PHY_VENDOR_ID_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "VendorID CMV fail\n"));
+
+    CLR_FLAG(&adslAtucPhysStruct.flags, ATUC_PHY_VENDOR_ID_FLAG);
+
+    memset(sys_info,0,sizeof(sys_info));
+    strcpy(sys_info,adslAtucPhysStruct.vendor_id.vendor_id);
+
+    *ret_len = strlen(adslAtucPhysStruct.vendor_id.vendor_id);
+    return (char *) sys_info;
+
+}
+
+/** XXX: return a data pointer to the data for the adslAtucInvVersionNumber
+    column and set ret_len to its proper size in bytes. */
+
+char           *
+get_adslAtucInvVersionNumber(void *data_context, size_t * ret_len)
+{
+    struct adslAtucPhysEntry adslAtucPhysStruct;
+
+    memset(&adslAtucPhysStruct,0,sizeof(adslAtucPhysEntry));
+    adslAtucPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAtucPhysStruct.flags,ATUC_PHY_VER_NUM_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PHY,(void *) &adslAtucPhysStruct);
+#else
+    get_adslAtucPhysTable1(Fd, GET_ADSL_ATUC_PHY,(void *) &adslAtucPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucPhysStruct.flags, ATUC_PHY_VER_NUM_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "VersionNum CMV fail\n"));
+
+    CLR_FLAG(&adslAtucPhysStruct.flags, ATUC_PHY_VER_NUM_FLAG);
+
+    memset(sys_info,0,sizeof(sys_info));
+    strcpy(sys_info,adslAtucPhysStruct.version_no);
+
+    *ret_len = strlen(adslAtucPhysStruct.version_no);
+    return (char *) sys_info;
+
+}
+#endif
+
+
+/** XXX: return a data pointer to the data for the adslAtucCurrStatus column and
+    set ret_len to its proper size in bytes. */
+
+u_int32           *
+get_adslAtucCurrStatus(void *data_context, size_t * ret_len)
+{
+    struct adslAtucPhysEntry adslAtucPhysStruct;
+
+    memset(&adslAtucPhysStruct,0,sizeof(adslAtucPhysEntry));
+    adslAtucPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAtucPhysStruct.flags,ATUC_CURR_STAT_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PHY,(void *) &adslAtucPhysStruct);
+#else
+    get_adslAtucPhysTable1(Fd, GET_ADSL_ATUC_PHY,(void *) &adslAtucPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucPhysStruct.flags, ATUC_CURR_STAT_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "CurrStatus CMV fail\n"));
+
+    CLR_FLAG(&adslAtucPhysStruct.flags, ATUC_CURR_STAT_FLAG);
+    long_ret = adslAtucPhysStruct.status;
+    *ret_len = sizeof(adslAtucPhysStruct.status);
+    return (u_int32 *) (&long_ret);
+}
+
+/** XXX: return a data pointer to the data for the adslAtucCurrOutputPwr column
+    and set ret_len to its proper size in bytes. */
+int           *
+get_adslAtucCurrOutputPwr(void *data_context, size_t * ret_len)
+{
+    struct adslAtucPhysEntry adslAtucPhysStruct;
+
+    memset(&adslAtucPhysStruct,0,sizeof(adslAtucPhysEntry));
+    adslAtucPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAtucPhysStruct.flags,ATUC_CURR_OUT_PWR_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PHY,(void *) &adslAtucPhysStruct);
+#else
+    get_adslAtucPhysTable1(Fd, GET_ADSL_ATUC_PHY,(void *) &adslAtucPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucPhysStruct.flags, ATUC_CURR_OUT_PWR_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "CurrOutPwr CMV fail\n"));
+
+    CLR_FLAG(&adslAtucPhysStruct.flags, ATUC_CURR_OUT_PWR_FLAG);
+    long_ret = adslAtucPhysStruct.outputPwr;
+    *ret_len = sizeof(adslAtucPhysStruct.outputPwr);
+    return (int *) (&long_ret);
+}
+
+/** XXX: return a data pointer to the data for the adslAtucCurrAttainableRate
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucCurrAttainableRate(void *data_context, size_t * ret_len)
+{
+    struct adslAtucPhysEntry adslAtucPhysStruct;
+
+    memset(&adslAtucPhysStruct,0,sizeof(adslAtucPhysEntry));
+    adslAtucPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAtucPhysStruct.flags,ATUC_CURR_ATTR_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUC_PHY, (void *)&adslAtucPhysStruct);
+#else
+    get_adslAtucPhysTable1(Fd, GET_ADSL_ATUC_PHY,(void *) &adslAtucPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAtucPhysStruct.flags, ATUC_CURR_ATTR_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUC", "CurrAttrRate CMV fail\n"));
+       
+    CLR_FLAG(&adslAtucPhysStruct.flags, ATUC_CURR_ATTR_FLAG);
+     long_ret = adslAtucPhysStruct.attainableRate;
+    *ret_len = sizeof(adslAtucPhysStruct.attainableRate);
+    return (u_int32 *) (&long_ret);
+}
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAtucPhysTable1(int Fd2, int GET_adsl_ATUC_PHY2,
+                void *adslAtucPhysTable)
+{
+    struct adslAtucPhysEntry *adslAtucPhysValue;
+    unsigned char temp[12]="Get Value";
+    adslAtucPhysValue = (adslAtucPhysEntry *)adslAtucPhysTable;
+    strcpy(adslAtucPhysValue->serial_no,temp);
+    strcpy(adslAtucPhysValue->vendor_id.vendor_id,temp);
+    strcpy(adslAtucPhysValue->version_no,temp);
+    adslAtucPhysValue->status=ADSLATUCCURRSTATUS_NODEFECT;
+    adslAtucPhysValue->outputPwr=10;
+    adslAtucPhysValue->attainableRate=10;
+
+    return 0;
+}
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_access.h	2009-12-16 12:59:22.000000000 +0530
@@ -0,0 +1,120 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPhysTable_access.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *              1)  Include files
+ *              2)  User defined data types
+ *              3)  Function proto-types for adslAtucPhysTable_access
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:  24-Jun04 Changed the return types for get_adslAtucCurrOutputPwr
+ * and  get_adslAtucCurrAttainableRate
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+//#include <adslMIBincl.h>
+
+#ifndef ADSLATUCPHYSTABLE_ACCESS_H
+#define ADSLATUCPHYSTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+
+/** User-defined data structure for accessing AtucPhysTable **/
+
+#ifdef STUB_IOCTL
+typedef struct adslAtucPhysEntry {
+    int ifIndex;
+    char serial_no[32];
+    char vendor_id[16];
+    char version_no[16];
+    u_int32 status;
+    int outputPwr;
+    u_int32 attainableRate;
+    u_char flags;
+} adslAtucPhysEntry;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/** User-defined data access functions for data in table adslAtucPhysTable */
+/** row level accessors */
+
+Netsnmp_First_Data_Point adslAtucPhysTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAtucPhysTable_get_next_data_point;
+
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+char  *
+get_adslAtucInvData(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+#else
+char       *get_adslAtucInvSerialNumber(void *data_context, size_t * ret_len);
+char       *get_adslAtucInvVendorID(void *data_context, size_t * ret_len);
+char       *get_adslAtucInvVersionNumber(void *data_context, size_t * ret_len);
+#endif
+
+u_int32        *get_adslAtucCurrStatus(void *data_context, size_t * ret_len);
+int           *get_adslAtucCurrOutputPwr(void *data_context, size_t * ret_len);
+u_int32   *get_adslAtucCurrAttainableRate(void *data_context, size_t * ret_len);
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAtucPhysTable1(int Fd2, int GET_adsl_ATUC_PHY2,
+                        void *adslAtucPhysTable);
+#endif
+
+#endif                          /* ADSLATUCPHYSTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_columns.h	2009-12-16 12:59:22.000000000 +0530
@@ -0,0 +1,67 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPhysTable_columns.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: Column number definitions for table adslAtucPhysTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATUCPHYSTABLE_COLUMNS_H
+#define ADSLATUCPHYSTABLE_COLUMNS_H
+
+/* column number definitions for table adslAtucPhysTable */
+#define COLUMN_ADSLATUCINVSERIALNUMBER      1
+#define COLUMN_ADSLATUCINVVENDORID          2
+#define COLUMN_ADSLATUCINVVERSIONNUMBER     3
+#if 1 /* XXX: Check ?? */
+#define COLUMN_ADSLATUCCURRSTATUS           6
+#define COLUMN_ADSLATUCCURROUTPUTPWR        7
+#define COLUMN_ADSLATUCCURRATTAINABLERATE   8
+#else
+#define COLUMN_ADSLATUCCURRSTATUS           4
+#define COLUMN_ADSLATUCCURROUTPUTPWR        5
+#define COLUMN_ADSLATUCCURRATTAINABLERATE   6
+#endif
+
+#endif                          /* ADSLATUCPHYSTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAtucPhysTable/adslAtucPhysTable_enums.h	2009-12-16 12:59:22.000000000 +0530
@@ -0,0 +1,77 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAtucPhysTable_enums.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: Constant definitions for table adslAtucPhysTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATUCPHYSTABLE_ENUMS_H
+#define ADSLATUCPHYSTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAtucPhysTable constants */
+#define GET_ADSL_ATUC_PHY       4
+
+/* adslAtucPhysTable Flags */
+#define ATUC_PHY_SER_NUM_FLAG   0x1     /* BIT 0th position */
+#define ATUC_PHY_VENDOR_ID_FLAG 0x2     /* BIT 1 */
+#define ATUC_PHY_VER_NUM_FLAG   0x4     /* BIT 2 */
+#define ATUC_CURR_STAT_FLAG     0x8     /* BIT 3 */
+#define ATUC_CURR_OUT_PWR_FLAG  0x10    /* BIT 4 */
+#define ATUC_CURR_ATTR_FLAG     0x20    /* BIT 5 */
+#endif
+
+/* enums for column adslAtucCurrStatus */
+#define ADSLATUCCURRSTATUS_NODEFECT             0
+#define ADSLATUCCURRSTATUS_LOSSOFFRAMING        1
+#define ADSLATUCCURRSTATUS_LOSSOFSIGNAL         2
+#define ADSLATUCCURRSTATUS_LOSSOFPOWER          3
+#define ADSLATUCCURRSTATUS_LOSSOFSIGNALQUALITY  4
+#define ADSLATUCCURRSTATUS_LOSSOFLINK           5
+#define ADSLATUCCURRSTATUS_DATAINITFAILURE      6
+#define ADSLATUCCURRSTATUS_CONFIGINITFAILURE    7
+#define ADSLATUCCURRSTATUS_PROTOCOLINITFAILURE  8
+#define ADSLATUCCURRSTATUS_NOPEERATUPRESENT     9
+
+#endif                          /* ADSLATUCPHYSTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable.c open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable.c	2009-12-16 12:59:22.000000000 +0530
@@ -0,0 +1,320 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanIntervalTable.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Initializing the adslAturChanIntervalTable module
+ *                 2) Handling requests for the adslAturChanIntervalTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:  29-Jun04 Changed the data type for intervalValidData
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturChanIntervalTable.h"
+#include "adslAturChanIntervalTable_access.h"
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+/** Initialize the adslAturChanIntervalTable table by defining its contents and how it's structured */
+void
+initialize_table_adslAturChanIntervalTable(void)
+{
+    static oid      adslAturChanIntervalTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 13 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAturChanIntervalTable",
+                                            adslAturChanIntervalTable_handler,
+                                            adslAturChanIntervalTable_oid,
+                                            OID_LENGTH
+                                            (adslAturChanIntervalTable_oid),
+                                            HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,\
+                 "malloc failed in initialize_table_adslAturChanIntervalTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     ASN_INTEGER,
+                                        /** index: adslAturChanIntervalNumber */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 2;
+    table_info->max_column = 6;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAturChanIntervalTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        adslAturChanIntervalTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAturChanIntervalTable_context_convert_function;
+    iinfo->free_data_context = adslAturChanIntervalTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAturChanIntervalTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAturChanIntervalTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAturChanIntervalTable", \
+                "Registering table adslAturChanIntervalTable as \
+                a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAturChanIntervalTable module */
+void
+init_adslAturChanIntervalTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAturChanIntervalTable();
+}
+
+/** handles requests for the adslAturChanIntervalTable table, if anything else
+    needs to be done */
+int
+adslAturChanIntervalTable_handler(netsnmp_mib_handler *handler,
+                                  netsnmp_handler_registration *reginfo,
+                                  netsnmp_agent_request_info *reqinfo,
+                                  netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    long IntervalNum = 0;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+
+    IntervalNum = *(requests->requestvb->name + reginfo->rootoid_len + 3);
+
+
+     printf("Interval Number = %l\n", IntervalNum);
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+
+            case COLUMN_ADSLATURCHANINTERVALRECEIVEDBLKS:
+            case COLUMN_ADSLATURCHANINTERVALTRANSMITTEDBLKS:
+            case COLUMN_ADSLATURCHANINTERVALCORRECTEDBLKS:
+            case COLUMN_ADSLATURCHANINTERVALUNCORRECTBLKS:
+                {
+                    u_int32 *retval;
+                    size_t  retval_len = IntervalNum;
+                    retval =
+                        get_adslAturChanIntervalData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                        (const u_char *) retval, retval_len);
+                }
+                break;
+#else
+            case COLUMN_ADSLATURCHANINTERVALRECEIVEDBLKS:
+                {
+                    u_int32 *retval;
+                    size_t  retval_len = IntervalNum;
+                    retval =
+                        get_adslAturChanIntervalReceivedBlks(data_context,
+                                                             &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                        (const u_char *) retval, retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANINTERVALTRANSMITTEDBLKS:
+                {
+                    u_int32 *retval;
+                    size_t  retval_len = IntervalNum;
+                    retval =
+                        get_adslAturChanIntervalTransmittedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                        (const u_char *) retval, retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANINTERVALCORRECTEDBLKS:
+                {
+                    u_int32 *retval;
+                    size_t  retval_len = IntervalNum;
+                    retval =
+                        get_adslAturChanIntervalCorrectedBlks(data_context,
+                                                              &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                        (const u_char *) retval, retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANINTERVALUNCORRECTBLKS:
+                {
+                    u_int32 *retval;
+                    size_t  retval_len = IntervalNum;
+                    retval =
+                        get_adslAturChanIntervalUncorrectBlks(data_context,
+                                                              &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                            (const u_char *) retval, retval_len);
+                }
+                break;
+#endif
+            case COLUMN_ADSLATURCHANINTERVALVALIDDATA:
+                {
+                       int           *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAturChanIntervalValidData(data_context,
+                                                          &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                       "problem encountered in \
+                       adslAturChanIntervalTable_handler: unknown column\n");
+            }
+            break;
+
+
+        default:
+            snmp_log(LOG_ERR,
+                   "problem encountered in adslAturChanIntervalTable_handler: \
+                   unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable.h open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable.h	2009-12-16 12:59:22.000000000 +0530
@@ -0,0 +1,78 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanIntervalTable.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) Include files
+ *                 2) Init Function proto-types
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATURCHANINTERVALTABLE_H
+#define ADSLATURCHANINTERVALTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+/** other required module components */
+config_require(adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_access)
+
+/* column number definitions for table adslAturChanIntervalTable */
+#include "adslAturChanIntervalTable_columns.h"
+
+/* enum definions */
+#include "adslAturChanIntervalTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+    /* function declarations */
+void    init_adslAturChanIntervalTable(void);
+void    initialize_table_adslAturChanIntervalTable(void);
+Netsnmp_Node_Handler adslAturChanIntervalTable_handler;
+
+
+#endif /** ADSLATURCHANINTERVALTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_access.c	2009-12-16 12:59:22.000000000 +0530
@@ -0,0 +1,410 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanIntervalTable_access.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Getting the data context pointer & loop context pointer
+ *                 2) User-defined data access functions (per column) for data
+ *                    in table adslAturChanIntervalTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:  29-Jun04 Changed the return type for intervalValidData
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturChanIntervalTable_access.h"
+#include "adslAturChanIntervalTable_enums.h"
+
+/* column number definitions for table adslAturChanIntervalTable */
+#include "adslAturChanIntervalTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                           GLOBAL DEFINITIONS
+ * ===========================================================================
+ */
+// *** Global variable definitions
+static long long_ret;
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+/* returns the first data point within the adslAturChanIntervalTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAturChanIntervalTable_get_first_data_point(void **my_loop_context,
+                                               void **my_data_context,
+                                               netsnmp_variable_list *
+                                               put_index_data,
+                                               netsnmp_iterator_info
+                                               *mydata)
+{
+
+   int *My_Data_Context;
+   My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+   if (!My_Data_Context) {
+      put_index_data = NULL;
+      snmp_log(LOG_ERR, "Get-First: adslAturChanIntervalTable: My_Data_Context malloc failed\n");
+      return put_index_data;
+   }
+   *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+   *my_data_context=My_Data_Context;
+
+   put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAturChanIntervalTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAturChanIntervalTable_get_next_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+      put_index_data = NULL;
+      snmp_log(LOG_ERR, "Get-Next: adslAturChanIntervalTable: My_Data_Context malloc failed\n");
+      return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+/*
+ *  User-defined data access functions (per column) for data in table
+    adslAturChanIntervalTable */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+#if defined(HAVE_OPTIMIZED_CODE)
+
+u_int32  *
+get_adslAturChanIntervalData(void *data_context, size_t * ret_len, 
+		unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslAturChanIntvlInfo adslAturChanIntvlStruct;
+  memset(&adslAturChanIntvlStruct,0,sizeof(adslAturChanIntvlInfo));
+  adslAturChanIntvlStruct.ifIndex= (*(int *)data_context);
+  adslAturChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+   
+  switch (var) {
+
+    case COLUMN_ADSLATURCHANINTERVALRECEIVEDBLKS:
+  	flags = ATUR_CHAN_INTVL_RECV_BLK_FLAG;
+        break;
+	
+    case COLUMN_ADSLATURCHANINTERVALTRANSMITTEDBLKS:
+	flags = ATUR_CHAN_INTVL_TX_BLK_FLAG;
+	break;
+	
+    case COLUMN_ADSLATURCHANINTERVALCORRECTEDBLKS:
+	flags = ATUR_CHAN_INTVL_CORR_BLK_FLAG;
+	break;
+	
+    case COLUMN_ADSLATURCHANINTERVALUNCORRECTBLKS:
+	flags = ATUR_CHAN_INTVL_UNCORR_BLK_FLAG;
+	break;
+
+    default:
+     	DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+        return NULL;
+  }
+
+  SET_FLAG(&adslAturChanIntvlStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+  adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO, &adslAturChanIntvlStruct);
+#else
+  get_adslAturChanIntervalTable(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO,
+        (void *) &adslAturChanIntvlStruct);
+#endif
+  if (IS_FLAG_SET(&adslAturChanIntvlStruct.flags,flags) == 0) 
+    DEBUGMSGTL(("adslMIB-ATUR", "ChanIntervalTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+
+	 case ATUR_CHAN_INTVL_RECV_BLK_FLAG:
+    	    long_ret = adslAturChanIntvlStruct.chanIntervalRecvdBlks;
+            break;
+	 
+	 case ATUR_CHAN_INTVL_TX_BLK_FLAG:
+    	    long_ret = adslAturChanIntvlStruct.chanIntervalXmitBlks;
+	    break;
+	  
+	 case ATUR_CHAN_INTVL_CORR_BLK_FLAG:
+    	    long_ret = adslAturChanIntvlStruct.chanIntervalCorrectedBlks;
+	    break;
+	  
+	 case ATUR_CHAN_INTVL_UNCORR_BLK_FLAG:
+    	    long_ret = adslAturChanIntvlStruct.chanIntervalUncorrectBlks;
+	    break;
+	  
+         default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+     }
+
+    CLR_FLAG(&adslAturChanIntvlStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+#else
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanIntervalReceivedBlks column and set ret_len to its
+    proper size in bytes. */
+u_int32  *
+get_adslAturChanIntervalReceivedBlks(void *data_context, size_t * ret_len)
+{
+    struct adslAturChanIntvlInfo adslAturChanIntvlStruct;
+
+    memset(&adslAturChanIntvlStruct,0,sizeof(adslAturChanIntvlInfo));
+    adslAturChanIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAturChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAturChanIntvlStruct.flags, ATUR_CHAN_INTVL_RECV_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO, &adslAturChanIntvlStruct);
+#else
+    get_adslAturChanIntervalTable(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO,
+        (void *) &adslAturChanIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturChanIntvlStruct.flags,
+        ATUR_CHAN_INTVL_RECV_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanIntvlRecvBlk CMV fail\n"));
+
+    CLR_FLAG(&adslAturChanIntvlStruct.flags, ATUR_CHAN_INTVL_RECV_BLK_FLAG);
+    long_ret = adslAturChanIntvlStruct.chanIntervalRecvdBlks;
+    *ret_len = sizeof(adslAturChanIntvlStruct.chanIntervalRecvdBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanIntervalTransmittedBlks column and set ret_len to its
+    proper size in bytes. */
+u_int32  *
+get_adslAturChanIntervalTransmittedBlks(void *data_context,
+                                         size_t * ret_len)
+{
+    struct adslAturChanIntvlInfo adslAturChanIntvlStruct;
+
+    memset(&adslAturChanIntvlStruct,0,sizeof(adslAturChanIntvlInfo));
+    adslAturChanIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAturChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAturChanIntvlStruct.flags, ATUR_CHAN_INTVL_TX_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO, &adslAturChanIntvlStruct);
+#else
+    get_adslAturChanIntervalTable(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO,
+        (void *) &adslAturChanIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturChanIntvlStruct.flags,
+            ATUR_CHAN_INTVL_TX_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanIntvlTxBlk CMV fail\n"));
+
+    CLR_FLAG(&adslAturChanIntvlStruct.flags, ATUR_CHAN_INTVL_TX_BLK_FLAG);
+    long_ret = adslAturChanIntvlStruct.chanIntervalXmitBlks;
+    *ret_len = sizeof(adslAturChanIntvlStruct.chanIntervalXmitBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanIntervalCorrectedBlks column and set ret_len to its
+    proper size in bytes. */
+u_int32  *
+get_adslAturChanIntervalCorrectedBlks(void *data_context,
+                                       size_t * ret_len)
+{
+    struct adslAturChanIntvlInfo adslAturChanIntvlStruct;
+
+    memset(&adslAturChanIntvlStruct,0,sizeof(adslAturChanIntvlInfo));
+    adslAturChanIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAturChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAturChanIntvlStruct.flags, ATUR_CHAN_INTVL_CORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO, &adslAturChanIntvlStruct);
+#else
+    get_adslAturChanIntervalTable(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO,
+        (void *) &adslAturChanIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturChanIntvlStruct.flags,
+        ATUR_CHAN_INTVL_CORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanIntvlCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&adslAturChanIntvlStruct.flags, ATUR_CHAN_INTVL_CORR_BLK_FLAG);
+    long_ret = adslAturChanIntvlStruct.chanIntervalCorrectedBlks;
+    *ret_len = sizeof(adslAturChanIntvlStruct.chanIntervalCorrectedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanIntervalUncorrectBlks column and set ret_len to its
+    proper size in bytes. */
+u_int32  *
+get_adslAturChanIntervalUncorrectBlks(void *data_context,
+                                       size_t * ret_len)
+{
+    struct adslAturChanIntvlInfo adslAturChanIntvlStruct;
+
+    memset(&adslAturChanIntvlStruct,0,sizeof(adslAturChanIntvlInfo));
+    adslAturChanIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAturChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAturChanIntvlStruct.flags, ATUR_CHAN_INTVL_UNCORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO, &adslAturChanIntvlStruct);
+#else
+    get_adslAturChanIntervalTable(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO,
+        (void *) &adslAturChanIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturChanIntvlStruct.flags,
+        ATUR_CHAN_INTVL_UNCORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanIntvlUnCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&adslAturChanIntvlStruct.flags, ATUR_CHAN_INTVL_UNCORR_BLK_FLAG);
+    long_ret = adslAturChanIntvlStruct.chanIntervalUncorrectBlks;
+    *ret_len = sizeof(adslAturChanIntvlStruct.chanIntervalUncorrectBlks);
+    return (u_int32 *) &long_ret;
+}
+
+#endif
+
+/** XXX: return a data pointer to the data for the adslAturChanIntervalValidData
+    column and set ret_len to its proper size in bytes. */
+int    *
+get_adslAturChanIntervalValidData(void *data_context, size_t * ret_len)
+{
+    struct adslAturChanIntvlInfo adslAturChanIntvlStruct;
+
+    memset(&adslAturChanIntvlStruct,0,sizeof(adslAturChanIntvlInfo));
+    adslAturChanIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAturChanIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAturChanIntvlStruct.flags, ATUR_CHAN_INTVL_VALID_DATA_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO, &adslAturChanIntvlStruct);
+#else
+    get_adslAturChanIntervalTable(Fd, GET_ADSL_ATUR_CHAN_INTVL_INFO,
+        (void *) &adslAturChanIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturChanIntvlStruct.flags,
+        ATUR_CHAN_INTVL_VALID_DATA_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanIntvlValidData CMV fail\n"));
+
+    CLR_FLAG(&adslAturChanIntvlStruct.flags, ATUR_CHAN_INTVL_VALID_DATA_FLAG);
+    long_ret = adslAturChanIntvlStruct.intervalValidData;
+    *ret_len = sizeof(adslAturChanIntvlStruct.intervalValidData);
+    return (int *) &long_ret;
+}
+
+#ifndef ENABLE_DRIVER_CALL
+int  get_adslAturChanIntervalTable(int Fd2, int GET_ADSL_atur_CHAN_INTVL_INFO,
+            void *adslAturChanIntvlTable)
+{
+    struct adslAturChanIntvlInfo *adslAturChanIntvlValue;
+    adslAturChanIntvlValue = (adslAturChanIntvlInfo *)adslAturChanIntvlTable;
+    adslAturChanIntvlValue->chanIntervalRecvdBlks = 100;
+    adslAturChanIntvlValue->chanIntervalXmitBlks = 200;
+    adslAturChanIntvlValue->chanIntervalCorrectedBlks = 300;
+    adslAturChanIntvlValue->chanIntervalUncorrectBlks = 50;
+    adslAturChanIntvlValue->intervalValidData = 2;
+    return 0;
+}
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_access.h	2009-12-16 12:59:22.000000000 +0530
@@ -0,0 +1,120 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanIntervalTable_access.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) User-defined data structure for accessing
+ *                    adslAturChanIntervalTable
+ *                 2) User-defined data access functions for data in table
+ *                    adslAturChanIntervalTable
+ *                 3) Column accessors functions
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:  29-Jun04 Changed the return type for intervalValidData
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+#ifndef ADSLATURCHANINTERVALTABLE_ACCESS_H
+#define ADSLATURCHANINTERVALTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                           USER-DEFINED DATA TYPES
+ * ===========================================================================
+ */
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslAturChanIntervalTable **/
+#define PerfIntervalCount u_int32
+
+typedef struct adslAturChanIntvlInfo {
+    int ifIndex;
+    int IntervalNumber;
+    PerfIntervalCount chanIntervalRecvdBlks;
+    PerfIntervalCount chanIntervalXmitBlks;
+    PerfIntervalCount chanIntervalCorrectedBlks;
+    PerfIntervalCount chanIntervalUncorrectBlks;
+    int intervalValidData;
+u_char flags;
+} adslAturChanIntvlInfo;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+/** User-defined data access functions for data in table
+    adslAturChanIntervalTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAturChanIntervalTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAturChanIntervalTable_get_next_data_point;
+
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+u_int32  *
+get_adslAturChanIntervalData(void *data_context, size_t * ret_len, 
+		unsigned int var);
+#else
+u_int32 *get_adslAturChanIntervalReceivedBlks(void *data_context,
+            size_t * ret_len);
+u_int32 *get_adslAturChanIntervalTransmittedBlks(void *data_context,
+            size_t * ret_len);
+u_int32 *get_adslAturChanIntervalCorrectedBlks(void *data_context,
+            size_t * ret_len);
+u_int32 *get_adslAturChanIntervalUncorrectBlks(void *data_context,
+            size_t * ret_len);
+#endif
+
+int    *get_adslAturChanIntervalValidData(void *data_context,
+            size_t * ret_len);
+
+#ifndef ENABLE_DRIVER_CALL
+int  get_adslAturChanIntervalTable(int Fd2,int GET_ADSL_atur_CHAN_INTVL_INFO,
+            void *adslAturChanIntvlTable);
+#endif
+
+#endif                          /* ADSLATURCHANINTERVALTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_columns.h	2009-12-16 12:59:23.000000000 +0530
@@ -0,0 +1,58 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanIntervalTable_columns.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) column number definitions for table
+ *                    adslAturChanIntervalTable
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATURCHANINTERVALTABLE_COLUMNS_H
+#define ADSLATURCHANINTERVALTABLE_COLUMNS_H
+
+/* column number definitions for table adslAturChanIntervalTable */
+#define COLUMN_ADSLATURCHANINTERVALNUMBER          1
+#define COLUMN_ADSLATURCHANINTERVALRECEIVEDBLKS    2
+#define COLUMN_ADSLATURCHANINTERVALTRANSMITTEDBLKS 3
+#define COLUMN_ADSLATURCHANINTERVALCORRECTEDBLKS   4
+#define COLUMN_ADSLATURCHANINTERVALUNCORRECTBLKS   5
+#define COLUMN_ADSLATURCHANINTERVALVALIDDATA       6
+#endif                          /* ADSLATURCHANINTERVALTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable_enums.h	2009-12-16 12:59:23.000000000 +0530
@@ -0,0 +1,70 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanIntervalTable_enums.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) adslAturChanIntervalTable constants
+ *                 2) adslAturChanIntervalTablee Flags
+ *                 3) enums for column adslAturChanIntervalValidData
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATURCHANINTERVALTABLE_ENUMS_H
+#define ADSLATURCHANINTERVALTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAturChanIntervalTable constants */
+#define GET_ADSL_ATUR_CHAN_INTVL_INFO   115
+
+/* adslAturChanIntervalTable Flags */
+#define ATUR_CHAN_INTVL_NUM_FLAG        0x1     /* BIT 0th Position */
+#define ATUR_CHAN_INTVL_RECV_BLK_FLAG   0x2     /* BIT 1 */
+#define ATUR_CHAN_INTVL_TX_BLK_FLAG     0x4     /* BIT 2 */
+#define ATUR_CHAN_INTVL_CORR_BLK_FLAG   0x8     /* BIT 3 */
+#define ATUR_CHAN_INTVL_UNCORR_BLK_FLAG 0x10    /* BIT 4 */
+#define ATUR_CHAN_INTVL_VALID_DATA_FLAG 0x20    /* BIT 5 */
+#endif
+
+/** enums for column adslAturChanIntervalValidData **/
+#define ADSLATURCHANINTERVALVALIDDATA_TRUE      1
+#define ADSLATURCHANINTERVALVALIDDATA_FALSE     2
+
+#endif                          /* ADSLATURCHANINTERVALTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable.c open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable.c	2009-12-16 12:59:23.000000000 +0530
@@ -0,0 +1,558 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanPerfDataTable.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Initializing the adslAturChanPerfDataTable module
+ *                 2) Handling requests for the adslAturChanPerfDataTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:Changed the data types of adslAturChanPerfValidIntervals,
+ * adslAturChanPerfInvalidIntervals and adslAturChanPerfPrev1DayMoniSecs
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturChanPerfDataTable.h"
+#include "adslAturChanPerfDataTable_access.h"
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+/** Initialize the adslAturChanPerfDataTable table by defining its contents
+    and how it's structured */
+void
+initialize_table_adslAturChanPerfDataTable(void)
+{
+    static oid      adslAturChanPerfDataTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 11 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAturChanPerfDataTable",
+                                            adslAturChanPerfDataTable_handler,
+                                            adslAturChanPerfDataTable_oid,
+                                            OID_LENGTH
+                                            (adslAturChanPerfDataTable_oid),
+                                            HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_adslAturChanPerfDataTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 21;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAturChanPerfDataTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        adslAturChanPerfDataTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAturChanPerfDataTable_context_convert_function;
+    iinfo->free_data_context = adslAturChanPerfDataTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAturChanPerfDataTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAturChanPerfDataTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAturChanPerfDataTable",
+                "Registering table adslAturChanPerfDataTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAturChanPerfDataTable module */
+void
+init_adslAturChanPerfDataTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAturChanPerfDataTable();
+}
+
+/** handles requests for the adslAturChanPerfDataTable table, if anything else needs to be done */
+int
+adslAturChanPerfDataTable_handler(netsnmp_mib_handler *handler,
+                                  netsnmp_handler_registration *reginfo,
+                                  netsnmp_agent_request_info *reqinfo,
+                                  netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+            case COLUMN_ADSLATURCHANRECEIVEDBLKS:
+            case COLUMN_ADSLATURCHANTRANSMITTEDBLKS:
+            case COLUMN_ADSLATURCHANCORRECTEDBLKS:
+            case COLUMN_ADSLATURCHANUNCORRECTBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanBlksData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                       (const u_char *) retval, retval_len);
+                }
+		break;
+
+            case COLUMN_ADSLATURCHANPERFVALIDINTERVALS:
+            case COLUMN_ADSLATURCHANPERFINVALIDINTERVALS:
+            case COLUMN_ADSLATURCHANPERFPREV1DAYMONISECS:
+                {
+                     int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfIntervalData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                       (const u_char *) retval, retval_len);
+                }
+		break;
+
+            case COLUMN_ADSLATURCHANPERFCURR15MINTIMEELAPSED:
+            case COLUMN_ADSLATURCHANPERFCURR15MINRECEIVEDBLKS:
+            case COLUMN_ADSLATURCHANPERFCURR15MINTRANSMITTEDBLKS:
+            case COLUMN_ADSLATURCHANPERFCURR15MINCORRECTEDBLKS:
+            case COLUMN_ADSLATURCHANPERFCURR15MINUNCORRECTBLKS:
+            case COLUMN_ADSLATURCHANPERFCURR1DAYTIMEELAPSED:
+            case COLUMN_ADSLATURCHANPERFCURR1DAYRECEIVEDBLKS:
+            case COLUMN_ADSLATURCHANPERFCURR1DAYTRANSMITTEDBLKS:
+            case COLUMN_ADSLATURCHANPERFCURR1DAYCORRECTEDBLKS:
+            case COLUMN_ADSLATURCHANPERFCURR1DAYUNCORRECTBLKS:
+            case COLUMN_ADSLATURCHANPERFPREV1DAYRECEIVEDBLKS:
+            case COLUMN_ADSLATURCHANPERFPREV1DAYTRANSMITTEDBLKS:
+            case COLUMN_ADSLATURCHANPERFPREV1DAYCORRECTEDBLKS:
+            case COLUMN_ADSLATURCHANPERFPREV1DAYUNCORRECTBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfStatsData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                       (const u_char *) retval, retval_len);
+                }
+                break;
+#else
+            case COLUMN_ADSLATURCHANRECEIVEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanReceivedBlks(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANTRANSMITTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanTransmittedBlks(data_context,
+                                                        &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANCORRECTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanCorrectedBlks(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANUNCORRECTBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanUncorrectBlks(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFVALIDINTERVALS:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfValidIntervals(data_context,
+                                                           &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFINVALIDINTERVALS:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfInvalidIntervals(data_context,
+                                                             &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFCURR15MINTIMEELAPSED:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfCurr15MinTimeElapsed
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFCURR15MINRECEIVEDBLKS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfCurr15MinReceivedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                            (const u_char *) retval, retval_len);
+               }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFCURR15MINTRANSMITTEDBLKS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfCurr15MinTransmittedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                            (const u_char *) retval, retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFCURR15MINCORRECTEDBLKS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfCurr15MinCorrectedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                            (const u_char *) retval, retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFCURR15MINUNCORRECTBLKS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfCurr15MinUncorrectBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                            (const u_char *) retval, retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFCURR1DAYTIMEELAPSED:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfCurr1DayTimeElapsed
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFCURR1DAYRECEIVEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfCurr1DayReceivedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFCURR1DAYTRANSMITTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfCurr1DayTransmittedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFCURR1DAYCORRECTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfCurr1DayCorrectedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFCURR1DAYUNCORRECTBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfCurr1DayUncorrectBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFPREV1DAYMONISECS:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfPrev1DayMoniSecs(data_context,
+                                                             &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFPREV1DAYRECEIVEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfPrev1DayReceivedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFPREV1DAYTRANSMITTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfPrev1DayTransmittedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFPREV1DAYCORRECTEDBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfPrev1DayCorrectedBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPERFPREV1DAYUNCORRECTBLKS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPerfPrev1DayUncorrectBlks
+                        (data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+#endif
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                         "problem encountered in \
+                         adslAturChanPerfDataTable_handler: unknown column\n");
+            }
+            break;
+
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in adslAturChanPerfDataTable_handler:\
+                      unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable.h open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable.h	2009-12-16 12:59:23.000000000 +0530
@@ -0,0 +1,78 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanPerfDataTable.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) Include files
+ *                 2) Init Function proto-types
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATURCHANPERFDATATABLE_H
+#define ADSLATURCHANPERFDATATABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+
+/** other required module components */
+config_require(adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_access)
+
+/* column number definitions for table adslAturChanPerfDataTable */
+#include "adslAturChanPerfDataTable_columns.h"
+
+/* enum definions */
+#include "adslAturChanPerfDataTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+    /* function declarations */
+void    init_adslAturChanPerfDataTable(void);
+void    initialize_table_adslAturChanPerfDataTable(void);
+Netsnmp_Node_Handler adslAturChanPerfDataTable_handler;
+
+#endif /** ADSLATURCHANPERFDATATABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_access.c	2009-12-16 12:59:23.000000000 +0530
@@ -0,0 +1,1133 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanPerfDataTable_access.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Getting the data context pointer & loop context pointer
+ *                 2) User-defined data access functions (per column) for data
+ *                    in table adslAturChanPerfDataTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:Changed the return types of adslAturChanPerfValidIntervals,
+ * adslAturChanPerfInvalidIntervals and adslAturChanPerfPrev1DayMoniSecs
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturChanPerfDataTable_access.h"
+#ifdef STUB_IOCTL
+#include "adslAturChanPerfDataTable_enums.h"
+#endif
+
+/* column number definitions for table adslAturChanPerfDataTable */
+#include "adslAturChanPerfDataTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                           GLOBAL DEFINITIONS
+ * ===========================================================================
+ */
+// *** Global variable definitions
+static long long_ret;
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+/** returns the first data point within the adslAturChanPerfDataTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAturChanPerfDataTable_get_first_data_point(void **my_loop_context,
+                                               void **my_data_context,
+                                               netsnmp_variable_list *
+                                               put_index_data,
+                                               netsnmp_iterator_info
+                                               *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+       put_index_data = NULL;
+       snmp_log(LOG_ERR, "Get-First: adslAturChanPerDataTable: My_Data_Context malloc failed\n");
+       return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+
+}
+
+/** functionally the same as adslAturChanPerfDataTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAturChanPerfDataTable_get_next_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+       put_index_data = NULL;
+       snmp_log(LOG_ERR, "Get-Next: adslAturChanPerDataTable: My_Data_Context malloc failed\n");
+       return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+/*
+ *  User-defined data access functions (per column) for data in table
+    adslAturChanPerfDataTable
+ */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+#if defined(HAVE_OPTIMIZED_CODE)
+
+u_int32  *
+get_adslAturChanBlksData(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+  memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+  aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+  
+  switch (var)  {
+
+        case COLUMN_ADSLATURCHANRECEIVEDBLKS:
+	   flags = ATUR_CHAN_RECV_BLK_FLAG;
+	   break;
+
+        case COLUMN_ADSLATURCHANTRANSMITTEDBLKS:
+	   flags = ATUR_CHAN_TX_BLK_FLAG;
+	   break;
+
+        case COLUMN_ADSLATURCHANCORRECTEDBLKS:
+	   flags = ATUR_CHAN_CORR_BLK_FLAG;
+	   break;
+
+        case COLUMN_ADSLATURCHANUNCORRECTBLKS:
+	   flags = ATUR_CHAN_UNCORR_BLK_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  }
+
+  SET_FLAG(&aturChannelPerfDataStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags, flags) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfDataTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUR_CHAN_RECV_BLK_FLAG:
+    	   long_ret = aturChannelPerfDataStruct.adslAturChanReceivedBlks;
+	   break;
+
+	case ATUR_CHAN_TX_BLK_FLAG:
+    	   long_ret = aturChannelPerfDataStruct.adslAturChanTransmittedBlks;
+	   break;
+
+	case ATUR_CHAN_CORR_BLK_FLAG:
+    	   long_ret = aturChannelPerfDataStruct.adslAturChanCorrectedBlks;
+	   break;
+
+	case ATUR_CHAN_UNCORR_BLK_FLAG:
+    	   long_ret = aturChannelPerfDataStruct.adslAturChanUncorrectBlks;
+	   break;
+		
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+    
+    CLR_FLAG(&aturChannelPerfDataStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+
+int *
+get_adslAturChanPerfIntervalData(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+  memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+  aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+      case COLUMN_ADSLATURCHANPERFVALIDINTERVALS:
+	 flags = ATUR_CHAN_PERF_VALID_INTVL_FLAG;
+	 break;
+	 
+      case COLUMN_ADSLATURCHANPERFINVALIDINTERVALS:
+	 flags = ATUR_CHAN_PERF_INVALID_INTVL_FLAG;
+	 break;
+
+      case COLUMN_ADSLATURCHANPERFPREV1DAYMONISECS:
+	 flags = ATUR_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG;
+	 break;
+	 
+      default:
+     	 DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	 return NULL;
+ }
+  
+ SET_FLAG(&aturChannelPerfDataStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags, flags) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfDataTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUR_CHAN_PERF_VALID_INTVL_FLAG:
+    	   long_ret = aturChannelPerfDataStruct.adslAturChanPerfValidIntervals;
+	   break;
+
+	case ATUR_CHAN_PERF_INVALID_INTVL_FLAG:
+    	   long_ret = aturChannelPerfDataStruct.adslAturChanPerfInvalidIntervals;
+	   break;
+
+	case ATUR_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG:
+    	   long_ret = aturChannelPerfDataStruct.adslAturChanPerfPrev1DayMoniSecs;
+	   break;
+
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+    
+    CLR_FLAG(&aturChannelPerfDataStruct.flags, flags);
+    *ret_len = sizeof(int);
+    return (int *) &long_ret;
+}
+
+
+u_int32  *
+get_adslAturChanPerfStatsData(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+  memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+  aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+      case COLUMN_ADSLATURCHANPERFCURR15MINTIMEELAPSED:
+	 flags = ATUR_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG; 
+         break;
+	 
+      case COLUMN_ADSLATURCHANPERFCURR15MINRECEIVEDBLKS:
+	 flags = ATUR_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFCURR15MINTRANSMITTEDBLKS:
+	 flags = ATUR_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFCURR15MINCORRECTEDBLKS:
+	 flags = ATUR_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFCURR15MINUNCORRECTBLKS:
+	 flags = ATUR_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFCURR1DAYTIMEELAPSED:
+	 flags = ATUR_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFCURR1DAYRECEIVEDBLKS:
+	 flags = ATUR_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFCURR1DAYTRANSMITTEDBLKS:
+	 flags = ATUR_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFCURR1DAYCORRECTEDBLKS:
+	 flags = ATUR_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFCURR1DAYUNCORRECTBLKS:
+	 flags = ATUR_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFPREV1DAYRECEIVEDBLKS:
+	 flags = ATUR_CHAN_PERF_PREV_1DAY_RECV_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFPREV1DAYTRANSMITTEDBLKS:
+	 flags = ATUR_CHAN_PERF_PREV_1DAY_TRANS_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFPREV1DAYCORRECTEDBLKS:
+	 flags = ATUR_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURCHANPERFPREV1DAYUNCORRECTBLKS:
+	 flags = ATUR_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG;
+	 break;
+	 
+      default:
+     	 DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+         return NULL;
+ }
+
+ SET_FLAG(&aturChannelPerfDataStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+     adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+     get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+			         (void *) &aturChannelPerfDataStruct);
+#endif
+     if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags, flags) == 0)
+            DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfDataTable: GET- %x CMV fail\n", flags));
+
+     switch (flags)  {
+
+	 case ATUR_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr15MinTimeElapsed;		 
+            break;
+	 
+	 case ATUR_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr15MinReceivedBlks;
+	    break;
+	  
+	 case ATUR_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr15MinTransmittedBlks;
+	    break;
+	  
+	 case ATUR_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr15MinCorrectedBlks;
+	    break;
+	  
+	 case ATUR_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr15MinUncorrectBlks;
+	    break;
+	  
+	 case ATUR_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr1DayTimeElapsed;
+	    break;
+	  
+	 case ATUR_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr1DayReceivedBlks;
+	    break;
+	  
+	 case ATUR_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr1DayTransmittedBlks;
+	    break;
+	  
+	 case ATUR_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr1DayCorrectedBlks;
+            break;
+	  
+	 case ATUR_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr1DayUncorrectBlks;
+	    break;
+	  
+	 case ATUR_CHAN_PERF_PREV_1DAY_RECV_BLK_FLAG:
+	   long_ret = aturChannelPerfDataStruct.adslAturChanPerfPrev1DayReceivedBlks; 
+	    break;
+	  
+	 case ATUR_CHAN_PERF_PREV_1DAY_TRANS_BLK_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfPrev1DayTransmittedBlks;
+	    break;
+	  
+	 case ATUR_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG:
+            long_ret = aturChannelPerfDataStruct.adslAturChanPerfPrev1DayCorrectedBlks;
+	    break;
+	  
+	 case ATUR_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG:
+	    long_ret = aturChannelPerfDataStruct.adslAturChanPerfPrev1DayUncorrectBlks;
+	    break;
+	 
+         default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+     }
+     
+    CLR_FLAG(&aturChannelPerfDataStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+#else
+
+/** XXX: return a data pointer to the data for the adslAturChanReceivedBlks
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturChanReceivedBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags, ATUR_CHAN_RECV_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_RECV_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfRecvBlk CMV fail\n"));
+       
+    CLR_FLAG(&aturChannelPerfDataStruct.flags, ATUR_CHAN_RECV_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanReceivedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.adslAturChanReceivedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturChanTransmittedBlks
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturChanTransmittedBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags, ATUR_CHAN_TX_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_TX_BLK_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfTxBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags, ATUR_CHAN_TX_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanTransmittedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.adslAturChanTransmittedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturChanCorrectedBlks
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturChanCorrectedBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+   memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags, ATUR_CHAN_CORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_CORR_BLK_FLAG) == 0) 
+      DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags, ATUR_CHAN_CORR_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanCorrectedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.adslAturChanCorrectedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturChanUncorrectBlks
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturChanUncorrectBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags, ATUR_CHAN_UNCORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags, 
+			ATUR_CHAN_UNCORR_BLK_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfUnCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags, ATUR_CHAN_UNCORR_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanUncorrectBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.adslAturChanUncorrectBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfValidIntervals column and set ret_len to its proper size
+    in bytes. */
+int           *
+get_adslAturChanPerfValidIntervals(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags, ATUR_CHAN_PERF_VALID_INTVL_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_VALID_INTVL_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfValidIntvl CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags, ATUR_CHAN_PERF_VALID_INTVL_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfValidIntervals;
+    *ret_len = sizeof(aturChannelPerfDataStruct.adslAturChanPerfValidIntervals);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfInvalidIntervals column and set ret_len to its
+    proper size in bytes. */
+int           *
+get_adslAturChanPerfInvalidIntervals(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_INVALID_INTVL_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_INVALID_INTVL_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfInvalidIntvl CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_INVALID_INTVL_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfInvalidIntervals;
+  *ret_len = sizeof(aturChannelPerfDataStruct.adslAturChanPerfInvalidIntervals);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfCurr15MinTimeElapsed column and set ret_len to its
+    proper size in bytes. */
+u_int32         *
+get_adslAturChanPerfCurr15MinTimeElapsed(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfCurr15Min CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr15MinTimeElapsed;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+            adslAturChanPerfCurr15MinTimeElapsed);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfCurr15MinReceivedBlks column and set ret_len to its
+    proper size in bytes. */
+u_int32       *
+get_adslAturChanPerfCurr15MinReceivedBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfCurr15MinRecvBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr15MinReceivedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+            adslAturChanPerfCurr15MinReceivedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfCurr15MinTransmittedBlks column and set ret_len to
+    its proper size in bytes. */
+u_int32      *
+get_adslAturChanPerfCurr15MinTransmittedBlks(void *data_context,
+    size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG) == 0)
+      DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfCurr15MinTxBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG);
+    long_ret =
+            aturChannelPerfDataStruct.adslAturChanPerfCurr15MinTransmittedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+            adslAturChanPerfCurr15MinTransmittedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfCurr15MinCorrectedBlks column and set ret_len to
+    its proper size in bytes. */
+u_int32      *
+get_adslAturChanPerfCurr15MinCorrectedBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfCurr15MinCorrBlk CMV fail\n"));
+       
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr15MinCorrectedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+                      adslAturChanPerfCurr15MinCorrectedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfCurr15MinUncorrectBlks column and set ret_len to its
+    proper size in bytes. */
+u_int32      *
+get_adslAturChanPerfCurr15MinUncorrectBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfCurr15MinUnCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr15MinUncorrectBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+            adslAturChanPerfCurr15MinUncorrectBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfCurr1DayTimeElapsed column and set ret_len to its
+    proper size in bytes. */
+u_int32         *
+get_adslAturChanPerfCurr1DayTimeElapsed(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfCurr1Day CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr1DayTimeElapsed;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+                adslAturChanPerfCurr1DayTimeElapsed);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfCurr1DayReceivedBlks column and set ret_len to its
+    proper size in bytes. */
+u_int32         *
+get_adslAturChanPerfCurr1DayReceivedBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG) == 0)
+     DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfCurr1DayRecvBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr1DayReceivedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+                    adslAturChanPerfCurr1DayReceivedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfCurr1DayTransmittedBlks column and set ret_len to
+    its proper size in bytes. */
+u_int32         *
+get_adslAturChanPerfCurr1DayTransmittedBlks(void *data_context,
+    size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfCurr1DayTxBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG);
+   long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr1DayTransmittedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+            adslAturChanPerfCurr1DayTransmittedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfCurr1DayCorrectedBlks column and set ret_len to its
+    proper size in bytes. */
+u_int32         *
+get_adslAturChanPerfCurr1DayCorrectedBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfCurr1DayCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr1DayCorrectedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+            adslAturChanPerfCurr1DayCorrectedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfCurr1DayUncorrectBlks column and set ret_len to
+    its proper size in bytes. */
+u_int32         *
+get_adslAturChanPerfCurr1DayUncorrectBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG) == 0)
+     DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfCurr1DayUnCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfCurr1DayUncorrectBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+                    adslAturChanPerfCurr1DayUncorrectBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfPrev1DayMoniSecs column and set ret_len to its
+    proper size in bytes. */
+int           *
+get_adslAturChanPerfPrev1DayMoniSecs(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+            (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfPrev1DayMonSec CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfPrev1DayMoniSecs;
+  *ret_len = sizeof(aturChannelPerfDataStruct.adslAturChanPerfPrev1DayMoniSecs);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfPrev1DayReceivedBlks column and set ret_len to its
+    proper size in bytes. */
+u_int32         *
+get_adslAturChanPerfPrev1DayReceivedBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_PREV_1DAY_RECV_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_PREV_1DAY_RECV_BLK_FLAG) == 0)
+      DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfPrev1DayRecvBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfPrev1DayReceivedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+                    adslAturChanPerfPrev1DayReceivedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfPrev1DayTransmittedBlks column and set ret_len to
+    its proper size in bytes. */
+u_int32 *
+get_adslAturChanPerfPrev1DayTransmittedBlks(void *data_context,
+        size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_PREV_1DAY_TRANS_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+        (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_PREV_1DAY_TRANS_BLK_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfPrev1DayTxBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_PREV_1DAY_TRANS_BLK_FLAG);
+   long_ret = aturChannelPerfDataStruct.adslAturChanPerfPrev1DayTransmittedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+            adslAturChanPerfPrev1DayTransmittedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfPrev1DayCorrectedBlks column and set ret_len to
+    its proper size in bytes. */
+u_int32         *
+get_adslAturChanPerfPrev1DayCorrectedBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+            (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+            ATUR_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfPrev1DayCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfPrev1DayCorrectedBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+                        adslAturChanPerfPrev1DayCorrectedBlks);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturChanPerfPrev1DayUncorrectBlks column and set ret_len to
+    its proper size in bytes. */
+u_int32         *
+get_adslAturChanPerfPrev1DayUncorrectBlks(void *data_context, size_t * ret_len)
+{
+    struct aturChannelPerfDataEntry aturChannelPerfDataStruct;
+
+    memset(&aturChannelPerfDataStruct,0,sizeof(aturChannelPerfDataEntry));
+    aturChannelPerfDataStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturChannelPerfDataStruct.flags,
+            ATUR_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA, &aturChannelPerfDataStruct);
+#else
+    get_adslAturChanPerfDataTable(Fd, GET_ADSL_ATUR_CHAN_PERF_DATA,
+            (void *) &aturChannelPerfDataStruct);
+#endif
+    if (IS_FLAG_SET(&aturChannelPerfDataStruct.flags,
+            ATUR_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanPerfPrev1DayUnCorrBlk CMV fail\n"));
+
+    CLR_FLAG(&aturChannelPerfDataStruct.flags,
+        ATUR_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG);
+    long_ret = aturChannelPerfDataStruct.adslAturChanPerfPrev1DayUncorrectBlks;
+    *ret_len = sizeof(aturChannelPerfDataStruct.
+                        adslAturChanPerfPrev1DayUncorrectBlks);
+    return (u_int32 *) &long_ret;
+}
+
+#endif
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAturChanPerfDataTable(int Fd2,int GET_adsl_ATUR_CHAN_PERF_DATA2,
+        void *aturChanPerfDataValue)
+{
+
+    struct aturChannelPerfDataEntry *aturChanPerfData;
+    aturChanPerfData = (aturChannelPerfDataEntry *) aturChanPerfDataValue;
+    aturChanPerfData->adslAturChanReceivedBlks = 110;
+    aturChanPerfData->adslAturChanTransmittedBlks = 120;
+    aturChanPerfData->adslAturChanCorrectedBlks = 130;
+    aturChanPerfData->adslAturChanUncorrectBlks = 140;
+    aturChanPerfData->adslAturChanPerfValidIntervals = 80;
+    aturChanPerfData->adslAturChanPerfInvalidIntervals = 90;
+    aturChanPerfData->adslAturChanPerfCurr15MinTimeElapsed = 110;
+    aturChanPerfData->adslAturChanPerfCurr15MinReceivedBlks = 115;
+    aturChanPerfData->adslAturChanPerfCurr15MinTransmittedBlks = 120;
+    aturChanPerfData->adslAturChanPerfCurr15MinCorrectedBlks = 125;
+    aturChanPerfData->adslAturChanPerfCurr15MinUncorrectBlks = 130;
+    aturChanPerfData->adslAturChanPerfCurr1DayTimeElapsed = 210;
+    aturChanPerfData->adslAturChanPerfCurr1DayReceivedBlks = 320;
+    aturChanPerfData->adslAturChanPerfCurr1DayTransmittedBlks = 240;
+    aturChanPerfData->adslAturChanPerfCurr1DayCorrectedBlks = 360;
+    aturChanPerfData->adslAturChanPerfCurr1DayUncorrectBlks = 470;
+    aturChanPerfData->adslAturChanPerfPrev1DayMoniSecs = 580;
+    aturChanPerfData->adslAturChanPerfPrev1DayReceivedBlks = 685;
+    aturChanPerfData->adslAturChanPerfPrev1DayTransmittedBlks = 790;
+    aturChanPerfData->adslAturChanPerfPrev1DayCorrectedBlks = 895;
+    aturChanPerfData->adslAturChanPerfPrev1DayUncorrectBlks = 910;
+
+    return 0;
+
+}
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_access.h	2009-12-16 12:59:23.000000000 +0530
@@ -0,0 +1,173 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanPerfDataTable_access.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) User-defined data structure for accessing
+ *                    adslAturChanPerfDataTable
+ *                 2) User-defined data access functions for data in table
+ *                    adslAturChanPerfDataTable
+ *                 3) Column accessors functions
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani:Changed the return types of adslAturChanPerfValidIntervals,
+ * adslAturChanPerfInvalidIntervals and adslAturChanPerfPrev1DayMoniSecs
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+#ifndef ADSLATURCHANPERFDATATABLE_ACCESS_H
+#define ADSLATURCHANPERFDATATABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                           USER-DEFINED DATA TYPES
+ * ===========================================================================
+ */
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslAturChanPerfDataTable **/
+#define AdslPerfTimeElapsed u_int32
+#define PerfCurrentCount u_int32
+#define AdslPerfCurrDayCount u_int32
+#define AdslPerfPrevDayCount u_int32
+
+typedef struct aturChannelPerfDataEntry
+{
+   int          ifIndex;
+   u_int32          adslAturChanReceivedBlks;
+   u_int32          adslAturChanTransmittedBlks;
+   u_int32          adslAturChanCorrectedBlks;
+   u_int32          adslAturChanUncorrectBlks;
+   int              adslAturChanPerfValidIntervals;
+   int              adslAturChanPerfInvalidIntervals;
+   AdslPerfTimeElapsed  adslAturChanPerfCurr15MinTimeElapsed;
+   PerfCurrentCount     adslAturChanPerfCurr15MinReceivedBlks;
+   PerfCurrentCount     adslAturChanPerfCurr15MinTransmittedBlks;
+   PerfCurrentCount     adslAturChanPerfCurr15MinCorrectedBlks;
+   PerfCurrentCount     adslAturChanPerfCurr15MinUncorrectBlks;
+   AdslPerfTimeElapsed  adslAturChanPerfCurr1DayTimeElapsed;
+   AdslPerfCurrDayCount adslAturChanPerfCurr1DayReceivedBlks;
+   AdslPerfCurrDayCount adslAturChanPerfCurr1DayTransmittedBlks;
+   AdslPerfCurrDayCount adslAturChanPerfCurr1DayCorrectedBlks;
+   AdslPerfCurrDayCount adslAturChanPerfCurr1DayUncorrectBlks;
+   int                  adslAturChanPerfPrev1DayMoniSecs;
+   AdslPerfPrevDayCount adslAturChanPerfPrev1DayReceivedBlks;
+   AdslPerfPrevDayCount adslAturChanPerfPrev1DayTransmittedBlks;
+   AdslPerfPrevDayCount adslAturChanPerfPrev1DayCorrectedBlks;
+   AdslPerfPrevDayCount adslAturChanPerfPrev1DayUncorrectBlks;
+   u_int32          flags;
+} aturChannelPerfDataEntry;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+/** User-defined data access functions for data in table
+    adslAturChanPerfDataTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAturChanPerfDataTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAturChanPerfDataTable_get_next_data_point;
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+u_int32  *
+get_adslAturChanBlksData(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+int *
+get_adslAturChanPerfIntervalData(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+u_int32  *
+get_adslAturChanPerfStatsData(void *data_context, size_t * ret_len,
+			unsigned int var);
+#else
+u_int32  *get_adslAturChanReceivedBlks(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturChanTransmittedBlks(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturChanCorrectedBlks(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturChanUncorrectBlks(void *data_context, size_t * ret_len);
+int     *get_adslAturChanPerfValidIntervals(void *data_context,
+            size_t * ret_len);
+int     *get_adslAturChanPerfInvalidIntervals(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturChanPerfCurr15MinTimeElapsed(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturChanPerfCurr15MinReceivedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturChanPerfCurr15MinTransmittedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturChanPerfCurr15MinCorrectedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturChanPerfCurr15MinUncorrectBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturChanPerfCurr1DayTimeElapsed(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturChanPerfCurr1DayReceivedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturChanPerfCurr1DayTransmittedBlks(void *data_context,
+            size_t *ret_len);
+u_int32  *get_adslAturChanPerfCurr1DayCorrectedBlks(void *data_context,
+            size_t *ret_len);
+u_int32  *get_adslAturChanPerfCurr1DayUncorrectBlks(void *data_context,
+            size_t *ret_len);
+int     *get_adslAturChanPerfPrev1DayMoniSecs(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturChanPerfPrev1DayReceivedBlks(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturChanPerfPrev1DayTransmittedBlks(void *data_context,
+            size_t *ret_len);
+u_int32  *get_adslAturChanPerfPrev1DayCorrectedBlks(void *data_context,
+            size_t *ret_len);
+u_int32  *get_adslAturChanPerfPrev1DayUncorrectBlks(void *data_context,
+            size_t *ret_len);
+#endif
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAturChanPerfDataTable(int Fd2,int GET_adsl_ATUR_CHAN_PERF_DATA2,void *aturChanPerfDataValue);
+#endif
+
+#endif                                   /* ADSLATURCHANPERFDATATABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_columns.h	2009-12-16 12:59:23.000000000 +0530
@@ -0,0 +1,74 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanPerfDataTable_columns.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) column number definitions for table
+ *                    adslAturChanPerfDataTable
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATURCHANPERFDATATABLE_COLUMNS_H
+#define ADSLATURCHANPERFDATATABLE_COLUMNS_H
+
+/* column number definitions for table adslAturChanPerfDataTable */
+#define COLUMN_ADSLATURCHANRECEIVEDBLKS                 1
+#define COLUMN_ADSLATURCHANTRANSMITTEDBLKS              2
+#define COLUMN_ADSLATURCHANCORRECTEDBLKS                3
+#define COLUMN_ADSLATURCHANUNCORRECTBLKS                4
+#define COLUMN_ADSLATURCHANPERFVALIDINTERVALS           5
+#define COLUMN_ADSLATURCHANPERFINVALIDINTERVALS         6
+#define COLUMN_ADSLATURCHANPERFCURR15MINTIMEELAPSED     7
+#define COLUMN_ADSLATURCHANPERFCURR15MINRECEIVEDBLKS    8
+#define COLUMN_ADSLATURCHANPERFCURR15MINTRANSMITTEDBLKS 9
+#define COLUMN_ADSLATURCHANPERFCURR15MINCORRECTEDBLKS   10
+#define COLUMN_ADSLATURCHANPERFCURR15MINUNCORRECTBLKS   11
+#define COLUMN_ADSLATURCHANPERFCURR1DAYTIMEELAPSED      12
+#define COLUMN_ADSLATURCHANPERFCURR1DAYRECEIVEDBLKS     13
+#define COLUMN_ADSLATURCHANPERFCURR1DAYTRANSMITTEDBLKS  14
+#define COLUMN_ADSLATURCHANPERFCURR1DAYCORRECTEDBLKS    15
+#define COLUMN_ADSLATURCHANPERFCURR1DAYUNCORRECTBLKS    16
+#define COLUMN_ADSLATURCHANPERFPREV1DAYMONISECS         17
+#define COLUMN_ADSLATURCHANPERFPREV1DAYRECEIVEDBLKS     18
+#define COLUMN_ADSLATURCHANPERFPREV1DAYTRANSMITTEDBLKS  19
+#define COLUMN_ADSLATURCHANPERFPREV1DAYCORRECTEDBLKS    20
+#define COLUMN_ADSLATURCHANPERFPREV1DAYUNCORRECTBLKS    21
+
+#endif                          /* ADSLATURCHANPERFDATATABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable_enums.h	2009-12-16 12:59:23.000000000 +0530
@@ -0,0 +1,80 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanPerfDataTable_enums.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) adslAturChanPerfDataTable constants
+ *                 2) adslAturChanPerfDataTable Flags
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATURCHANPERFDATATABLE_ENUMS_H
+#define ADSLATURCHANPERFDATATABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAturChanPerfDataTable constants */
+#define GET_ADSL_ATUR_CHAN_PERF_DATA    90
+
+/* adslAturChanPerfDataTable Flags */
+#define ATUR_CHAN_RECV_BLK_FLAG   0x01  /* BIT 0th position */
+#define ATUR_CHAN_TX_BLK_FLAG     0x02  /* BIT 1 */
+#define ATUR_CHAN_CORR_BLK_FLAG   0x04  /* BIT 2 */
+#define ATUR_CHAN_UNCORR_BLK_FLAG 0x08      /* BIT 3 */
+#define ATUR_CHAN_PERF_VALID_INTVL_FLAG   0x10  /* BIT 4 */
+#define ATUR_CHAN_PERF_INVALID_INTVL_FLAG 0x20  /* BIT 5 */
+#define ATUR_CHAN_PERF_CURR_15MIN_TIME_ELAPSED_FLAG 0x40 /* BIT 6 */
+#define ATUR_CHAN_PERF_CURR_15MIN_RECV_BLK_FLAG    0x80   /* BIT 7 */
+#define ATUR_CHAN_PERF_CURR_15MIN_TX_BLK_FLAG      0x100 /* BIT 8 */
+#define ATUR_CHAN_PERF_CURR_15MIN_CORR_BLK_FLAG    0x200 /* BIT 9 */
+#define ATUR_CHAN_PERF_CURR_15MIN_UNCORR_BLK_FLAG 0x400 /* BIT 10 */
+#define ATUR_CHAN_PERF_CURR_1DAY_TIME_ELAPSED_FLAG 0x800 /* BIT 11 */
+#define ATUR_CHAN_PERF_CURR_1DAY_RECV_BLK_FLAG     0x1000 /* BIT 12 */
+#define ATUR_CHAN_PERF_CURR_1DAY_TX_BLK_FLAG       0x2000 /* BIT 13 */
+#define ATUR_CHAN_PERF_CURR_1DAY_CORR_BLK_FLAG     0x4000 /* BIT 14 */
+#define ATUR_CHAN_PERF_CURR_1DAY_UNCORR_BLK_FLAG   0x8000 /* BIT 15 */
+#define ATUR_CHAN_PERF_PREV_1DAY_MONI_SEC_FLAG     0x10000 /* BIT 16 */
+#define ATUR_CHAN_PERF_PREV_1DAY_RECV_BLK_FLAG     0x20000 /* BIT 17 */
+#define ATUR_CHAN_PERF_PREV_1DAY_TRANS_BLK_FLAG    0x40000 /* BIT 18 */
+#define ATUR_CHAN_PERF_PREV_1DAY_CORR_BLK_FLAG        0x80000 /* BIT 19 */
+#define ATUR_CHAN_PERF_PREV_1DAY_UNCORR_BLK_FLAG   0x100000 /* BIT 20 */
+#endif
+
+#endif                          /* ADSLATURCHANPERFDATATABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable.c open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable.c	2009-12-16 12:59:23.000000000 +0530
@@ -0,0 +1,301 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanTable.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Initializing the adslAturChanTable module
+ *                 2) Handling requests for the adslAturChanTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturChanTable.h"
+#include "adslAturChanTable_access.h"
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+/** Initialize the adslAturChanTable table by defining its contents and how
+    it's structured */
+void
+initialize_table_adslAturChanTable(void)
+{
+    static oid      adslAturChanTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 5 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler = netsnmp_create_handler_registration("adslAturChanTable",
+                                                     adslAturChanTable_handler,
+                                                     adslAturChanTable_oid,
+                                                     OID_LENGTH
+                                                     (adslAturChanTable_oid),
+                                                     HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_adslAturChanTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 4;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point = adslAturChanTable_get_first_data_point;
+    iinfo->get_next_data_point = adslAturChanTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context = adslAturChanTable_context_convert_function;
+    iinfo->free_data_context = adslAturChanTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAturChanTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAturChanTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAturChanTable",
+                "Registering table adslAturChanTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAturChanTable module */
+void
+init_adslAturChanTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAturChanTable();
+}
+
+/** handles requests for the adslAturChanTable table, if anything else needs
+    to be done */
+int
+adslAturChanTable_handler(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+		    
+            case COLUMN_ADSLATURCHANINTERLEAVEDELAY:
+            case COLUMN_ADSLATURCHANCURRTXRATE:
+            case COLUMN_ADSLATURCHANPREVTXRATE:
+            case COLUMN_ADSLATURCHANCRCBLOCKLENGTH:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanInfo(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+#else		    
+            case COLUMN_ADSLATURCHANINTERLEAVEDELAY:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanInterleaveDelay(data_context,
+                                                        &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANCURRTXRATE:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanCurrTxRate(data_context,
+                                                   &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANPREVTXRATE:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanPrevTxRate(data_context,
+                                                   &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCHANCRCBLOCKLENGTH:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturChanCrcBlockLength(data_context,
+                                                       &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+#endif
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                         "problem encountered in adslAturChanTable_handler: \
+                            unknown column\n");
+            }
+            break;
+
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in adslAturChanTable_handler: \
+                        unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable.h open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable.h	2009-12-16 12:59:24.000000000 +0530
@@ -0,0 +1,78 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanTable.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) Include files
+ *                 2) Init Function proto-types
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATURCHANTABLE_H
+#define ADSLATURCHANTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+
+/** other required module components */
+config_require(adslMIB/adslAturChanTable/adslAturChanTable_access)
+
+/* column number definitions for table adslAturChanTable */
+#include "adslAturChanTable_columns.h"
+
+/* enum definions */
+#include "adslAturChanTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+    /* function declarations */
+void    init_adslAturChanTable(void);
+void    initialize_table_adslAturChanTable(void);
+Netsnmp_Node_Handler adslAturChanTable_handler;
+
+#endif /** ADSLATURCHANTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_access.c	2009-12-16 12:59:24.000000000 +0530
@@ -0,0 +1,365 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanTable_access.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Getting the data context pointer & loop context pointer
+ *                 2) User-defined data access functions (per column) for data
+ *                    in table adslAturChanTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturChanTable_access.h"
+#ifdef STUB_IOCTL
+#include "adslAturChanTable_enums.h"
+#endif
+
+/* column number definitions for table adslAturChanTable */
+#include "adslAturChanTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                           GLOBAL DEFINITIONS
+ * ===========================================================================
+ */
+// *** Global variable definitions
+static long long_ret;
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+/** returns the first data point within the adslAturChanTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAturChanTable_get_first_data_point(void **my_loop_context,
+                                       void **my_data_context,
+                                       netsnmp_variable_list *
+                                       put_index_data,
+                                       netsnmp_iterator_info *mydata)
+{
+
+   int *My_Data_Context;
+   My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+   if (!My_Data_Context) {
+       put_index_data = NULL;
+       snmp_log(LOG_ERR, "Get-First: adslAturChanTable: My_Data_Context malloc failed\n");
+       return put_index_data;
+   }
+   *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+   *my_data_context=My_Data_Context;
+
+   put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAturChanTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAturChanTable_get_next_data_point(void **my_loop_context,
+                                      void **my_data_context,
+                                      netsnmp_variable_list *
+                                      put_index_data,
+                                      netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+       put_index_data = NULL;
+       snmp_log(LOG_ERR, "Get-Next: adslAturChanTable: My_Data_Context malloc failed\n");
+       return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL_FAST_INTERLEAVE;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+/*
+ *  User-defined data access functions (per column) for data in table
+    adslAturChanTable */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+
+#if defined(HAVE_OPTIMIZED_CODE)
+
+u_int32         *
+get_adslAturChanInfo(void *data_context, size_t * ret_len,
+		unsigned int var)
+{
+  unsigned int flags = 0;	
+  struct adslAturChanInfo adslAturChanStruct;
+  memset(&adslAturChanStruct,0,sizeof(adslAturChanInfo));
+  adslAturChanStruct.ifIndex= (*(int *)data_context);
+
+  switch (var)  {
+
+        case COLUMN_ADSLATURCHANINTERLEAVEDELAY:
+	   flags = ATUR_CHAN_INTLV_DELAY_FLAG;
+	   break;
+
+        case COLUMN_ADSLATURCHANCURRTXRATE:
+	   flags = ATUR_CHAN_CURR_TX_RATE_FLAG;
+	   break;
+
+        case COLUMN_ADSLATURCHANPREVTXRATE:
+	   flags = ATUR_CHAN_PREV_TX_RATE_FLAG;
+	   break;
+
+        case COLUMN_ADSLATURCHANCRCBLOCKLENGTH:
+	   flags = ATUR_CHAN_CRC_BLK_LEN_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  }
+
+  SET_FLAG(&adslAturChanStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_INFO, &adslAturChanStruct);
+#else
+    get_adslAturChanTable(Fd, GET_ADSL_ATUR_CHAN_INFO,
+        (void *) &adslAturChanStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturChanStruct.flags, flags) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUR_CHAN_INTLV_DELAY_FLAG:
+    	   long_ret = adslAturChanStruct.interleaveDelay;
+	   break;
+
+	case ATUR_CHAN_CURR_TX_RATE_FLAG:
+     	   long_ret = adslAturChanStruct.currTxRate;
+	   break;
+
+	case ATUR_CHAN_PREV_TX_RATE_FLAG:
+    	   long_ret = adslAturChanStruct.prevTxRate;
+	   break;
+
+	case ATUR_CHAN_CRC_BLK_LEN_FLAG:
+    	   long_ret = adslAturChanStruct.crcBlkLen;
+	   break;
+
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+    
+    CLR_FLAG(&adslAturChanStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+#else
+
+/** XXX: return a data pointer to the data for the adslAturChanInterleaveDelay
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturChanInterleaveDelay(void *data_context, size_t * ret_len)
+{
+    struct adslAturChanInfo adslAturChanStruct;
+
+    memset(&adslAturChanStruct,0,sizeof(adslAturChanInfo));
+    adslAturChanStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturChanStruct.flags, ATUR_CHAN_INTLV_DELAY_FLAG);
+    
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_INFO, &adslAturChanStruct);
+#else
+    get_adslAturChanTable(Fd, GET_ADSL_ATUR_CHAN_INFO,
+        (void *) &adslAturChanStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturChanStruct.flags, ATUR_CHAN_INTLV_DELAY_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanIntlvDelay CMV fail\n"));
+
+    CLR_FLAG(&adslAturChanStruct.flags, ATUR_CHAN_INTLV_DELAY_FLAG);
+    long_ret = adslAturChanStruct.interleaveDelay;
+    *ret_len = sizeof(adslAturChanStruct.interleaveDelay);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturChanCurrTxRate column
+    and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturChanCurrTxRate(void *data_context, size_t * ret_len)
+{
+    struct adslAturChanInfo adslAturChanStruct;
+
+    memset(&adslAturChanStruct,0,sizeof(adslAturChanInfo));
+    adslAturChanStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturChanStruct.flags, ATUR_CHAN_CURR_TX_RATE_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_INFO, &adslAturChanStruct);
+#else
+    get_adslAturChanTable(Fd, GET_ADSL_ATUR_CHAN_INFO,
+        (void *) &adslAturChanStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturChanStruct.flags, ATUR_CHAN_CURR_TX_RATE_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanCurrTxRate CMV fail\n"));
+
+    CLR_FLAG(&adslAturChanStruct.flags, ATUR_CHAN_CURR_TX_RATE_FLAG);
+    long_ret = adslAturChanStruct.currTxRate;
+    *ret_len = sizeof(adslAturChanStruct.currTxRate);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturChanPrevTxRate column
+    and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturChanPrevTxRate(void *data_context, size_t * ret_len)
+{
+    struct adslAturChanInfo adslAturChanStruct;
+
+    memset(&adslAturChanStruct,0,sizeof(adslAturChanInfo));
+    adslAturChanStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturChanStruct.flags, ATUR_CHAN_PREV_TX_RATE_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_INFO, &adslAturChanStruct);
+#else
+    get_adslAturChanTable(Fd, GET_ADSL_ATUR_CHAN_INFO,
+        (void *) &adslAturChanStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturChanStruct.flags, ATUR_CHAN_PREV_TX_RATE_FLAG) == 0) 
+        DEBUGMSGTL(("adslMIB-ATUR", "ChanPrevTxRate CMV fail\n"));
+
+    CLR_FLAG(&adslAturChanStruct.flags, ATUR_CHAN_PREV_TX_RATE_FLAG);
+    long_ret = adslAturChanStruct.prevTxRate;
+    *ret_len = sizeof(adslAturChanStruct.prevTxRate);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturChanCrcBlockLength
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturChanCrcBlockLength(void *data_context, size_t * ret_len)
+{
+    struct adslAturChanInfo adslAturChanStruct;
+
+    memset(&adslAturChanStruct,0,sizeof(adslAturChanInfo));
+    adslAturChanStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturChanStruct.flags, ATUR_CHAN_CRC_BLK_LEN_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_CHAN_INFO, &adslAturChanStruct);
+#else
+    get_adslAturChanTable(Fd, GET_ADSL_ATUR_CHAN_INFO,
+        (void *) &adslAturChanStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturChanStruct.flags, ATUR_CHAN_CRC_BLK_LEN_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "ChanCRCBlkLen CMV fail\n"));
+
+    CLR_FLAG(&adslAturChanStruct.flags, ATUR_CHAN_CRC_BLK_LEN_FLAG);
+    long_ret = adslAturChanStruct.crcBlkLen;
+    *ret_len = sizeof(adslAturChanStruct.crcBlkLen);
+    return (u_int32 *) &long_ret;
+}
+#endif
+
+
+#ifndef ENABLE_DRIVER_CALL
+int  get_adslAturChanTable(int Fd2,int GET_ADSL_atur_CHAN_INFO,
+            void *adslAturChanTable)
+{
+    adslAturChanInfo *adslAturChanValue;
+    adslAturChanValue=(adslAturChanInfo *)adslAturChanTable;
+    adslAturChanValue->interleaveDelay = 40;
+    adslAturChanValue->currTxRate = 40;
+    adslAturChanValue->prevTxRate = 40;
+    adslAturChanValue->crcBlkLen = 10;
+    return 0;
+}
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_access.h	2009-12-16 12:59:24.000000000 +0530
@@ -0,0 +1,107 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanTable_access.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) User-defined data structure for accessing
+ *                    adslAturChanTable
+ *                 2) User-defined data access functions for data in table
+ *                    adslAturChanTable
+ *                 3) Column accessors functions
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+#ifndef ADSLATURCHANTABLE_ACCESS_H
+#define ADSLATURCHANTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                           USER-DEFINED DATA TYPES
+ * ===========================================================================
+ */
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslAturChanTable **/
+typedef struct adslAturChanInfo {
+    int ifIndex;
+    u_int32 interleaveDelay;
+    u_int32 currTxRate;
+    u_int32 prevTxRate;
+    u_int32 crcBlkLen;
+    u_char flags;
+} adslAturChanInfo;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+/** User-defined data access functions for data in table adslAturChanTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAturChanTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAturChanTable_get_next_data_point;
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+u_int32         *
+get_adslAturChanInfo(void *data_context, size_t * ret_len,
+		unsigned int var);
+#else
+u_int32 *get_adslAturChanInterleaveDelay(void *data_context, size_t * ret_len);
+u_int32 *get_adslAturChanCurrTxRate(void *data_context, size_t * ret_len);
+u_int32 *get_adslAturChanPrevTxRate(void *data_context, size_t * ret_len);
+u_int32 *get_adslAturChanCrcBlockLength(void *data_context, size_t * ret_len);
+#endif
+
+#ifndef ENABLE_DRIVER_CALL
+int  get_adslAturChanTable(int Fd2,int GET_ADSL_atur_CHAN_INFO,
+            void *adslAturChanTable);
+#endif
+
+#endif                          /* ADSLATURCHANTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_columns.h	2009-12-16 12:59:24.000000000 +0530
@@ -0,0 +1,57 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanTable_columns.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) column number definitions for table adslAturChanTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATURCHANTABLE_COLUMNS_H
+#define ADSLATURCHANTABLE_COLUMNS_H
+
+/* column number definitions for table adslAturChanTable */
+#define COLUMN_ADSLATURCHANINTERLEAVEDELAY  1
+#define COLUMN_ADSLATURCHANCURRTXRATE       2
+#define COLUMN_ADSLATURCHANPREVTXRATE       3
+#define COLUMN_ADSLATURCHANCRCBLOCKLENGTH   4
+
+#endif                          /* ADSLATURCHANTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturChanTable/adslAturChanTable_enums.h	2009-12-16 12:59:24.000000000 +0530
@@ -0,0 +1,64 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturChanTable_enums.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) adslAturChanTable constants
+ *                 2) adslAturChanTable Flags
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATURCHANTABLE_ENUMS_H
+#define ADSLATURCHANTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAturChanTable constants */
+#define GET_ADSL_ATUR_CHAN_INFO 18
+
+/* adslAturChanTable Flags */
+#define ATUR_CHAN_INTLV_DELAY_FLAG  0x1 /* BIT 0th position */
+#define ATUR_CHAN_CURR_TX_RATE_FLAG 0x2 /* BIT 1 */
+#define ATUR_CHAN_PREV_TX_RATE_FLAG 0x4 /* BIT 2 */
+#define ATUR_CHAN_CRC_BLK_LEN_FLAG  0x8 /* BIT 3 */
+#endif
+
+
+#endif                          /* ADSLATURCHANTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable.c open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable.c	2009-12-16 12:59:24.000000000 +0530
@@ -0,0 +1,249 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturIntervalExtTable.c
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslAturIntervalExtTable module
+ *               2) Handling requests for the adslAturIntervalExtTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturIntervalExtTable.h"
+#include "adslAturIntervalExtTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** Initialize the adslAturIntervalExtTable table by defining its contents and
+    how it's structured */
+void
+initialize_table_adslAturIntervalExtTable(void)
+{
+    static oid      adslAturIntervalExtTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 3, 1, 21 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAturIntervalExtTable",
+                                            adslAturIntervalExtTable_handler,
+                                            adslAturIntervalExtTable_oid,
+                                            OID_LENGTH
+                                            (adslAturIntervalExtTable_oid),
+                                            HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo) {
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_adslAturIntervalExtTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     ASN_INTEGER,
+                                          /** index: adslAturIntervalNumber */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 2;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAturIntervalExtTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        adslAturIntervalExtTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAturIntervalExtTable_context_convert_function;
+    iinfo->free_data_context = adslAturIntervalExtTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAturIntervalExtTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAturIntervalExtTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAturIntervalExtTable",
+                "Registering table adslAturIntervalExtTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAturIntervalExtTable module */
+void
+init_adslAturIntervalExtTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAturIntervalExtTable();
+}
+
+/** handles requests for the adslAturIntervalExtTable table, if anything else needs to be done */
+int
+adslAturIntervalExtTable_handler(netsnmp_mib_handler *handler,
+                                 netsnmp_handler_registration *reginfo,
+                                 netsnmp_agent_request_info *reqinfo,
+                                 netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+    long IntervalNum = 0;
+    void           *data_context = NULL;
+
+     IntervalNum = *(requests->requestvb->name + reginfo->rootoid_len + 3);
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_ADSLATURINTERVALSESL:
+            case COLUMN_ADSLATURINTERVALUASL:
+                {
+                    u_int32	*retval;
+                    size_t      retval_len = IntervalNum;
+                    retval =
+                        get_adslAturIntervalSeconds(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var,ASN_GAUGE,
+                    	(const u_char *) retval, retval_len);
+                }
+                break;
+		
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+  "problem encountered in adslAturIntervalExtTable_handler: unknown column\n");
+            }
+            break;
+
+
+        default:
+            snmp_log(LOG_ERR,
+ "problem encountered in adslAturIntervalExtTable_handler: unsupported mode\n");
+        }
+    }
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable.h open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable.h	2009-12-16 12:59:24.000000000 +0530
@@ -0,0 +1,90 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturIntervalExtTable.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                    1) Include files
+ *                    2) Init Function proto-types for adslAturIntervalExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATURINTERVALEXTTABLE_H
+#define ADSLATURINTERVALEXTTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+
+/** other required module components */
+config_require(adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_access)
+
+/*
+ * column number definitions for table adslAturIntervalExtTable
+ */
+#include "adslAturIntervalExtTable_columns.h"
+
+/*
+ * enum definions
+ */
+#include "adslAturIntervalExtTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/*
+ * function declarations
+ */
+ void            init_adslAturIntervalExtTable(void);
+ void            initialize_table_adslAturIntervalExtTable(void);
+ Netsnmp_Node_Handler adslAturIntervalExtTable_handler;
+
+
+
+
+#endif /** ADSLATURINTERVALEXTTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_access.c	2009-12-16 12:59:25.000000000 +0530
@@ -0,0 +1,238 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturIntervalExtTable_access.c
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) for data
+ *                  in table adslAturIntervalExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturIntervalExtTable_access.h"
+#include "adslAturIntervalExtTable_enums.h"
+
+/* column number definitions for table adslAturIntervalExtTable */
+#include "adslAturIntervalExtTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+// *** Global variable definitions
+static u_int32 long_ret;
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** returns the first data point within the adslAturIntervalExtTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAturIntervalExtTable_get_first_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+        "Get-First: adslAturIntervalExtTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAturIntervalExtTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAturIntervalExtTable_get_next_data_point(void **my_loop_context,
+                                             void **my_data_context,
+                                             netsnmp_variable_list *
+                                             put_index_data,
+                                             netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+        "Get-Next: adslAturIntervalExtTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+u_int32		*
+get_adslAturIntervalSeconds(void *data_context, size_t * ret_len, 
+		unsigned int var)
+{
+   unsigned int flags = 0;
+   struct adslAturInvtlExtInfo adslAturInvtlExtStruct;
+   memset(&adslAturInvtlExtStruct,0,sizeof(adslAturInvtlExtStruct));
+   adslAturInvtlExtStruct.ifIndex= (*(int *)data_context);
+   adslAturInvtlExtStruct.IntervalNumber= (*(int *)ret_len);
+
+   switch (var) {
+
+    case COLUMN_ADSLATURINTERVALSESL:
+  	flags = ATUR_INTERVAL_SESL_FLAG;
+        break;
+	
+    case COLUMN_ADSLATURINTERVALUASL:
+	flags = ATUR_INTERVAL_UASL_FLAG;
+	break;
+	
+    default:
+     	DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+        return NULL;
+   }
+   
+   SET_FLAG(&adslAturInvtlExtStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_INTVL_EXT_INFO , &adslAturInvtlExtStruct);
+#else
+    get_adslAturIntervalExtTable(Fd, GET_ADSL_ATUR_INTVL_EXT_INFO ,
+        (void *) &adslAturInvtlExtStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturInvtlExtStruct.flags, flags) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "IntervalExtTable: GET- %x CMV fail\n", flags));
+    
+    switch (flags)  {
+
+	 case ATUR_INTERVAL_SESL_FLAG:
+    	    long_ret = adslAturInvtlExtStruct.adslAturIntervalSesL;
+            break;
+	 
+	 case ATUR_INTERVAL_UASL_FLAG:
+    	    long_ret = adslAturInvtlExtStruct.adslAturIntervalUasL;
+	    break;
+	  
+         default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+     }
+
+    CLR_FLAG(&adslAturInvtlExtStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAturIntervalExtTable(int Fd2,int GET_adsl_ATUC_INTVL_INFO2,
+        void *adslAturInvtlExtTable)
+{
+        struct adslAturInvtlExtInfo *adslAturInvtlExtValue;
+        adslAturInvtlExtValue = (adslAturInvtlExtInfo *)adslAturInvtlExtTable;
+
+        adslAturInvtlExtValue->adslAturIntervalSesL = 30;
+        adslAturInvtlExtValue->adslAturIntervalUasL = 40;
+
+        return 0;
+}
+
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_access.h	2009-12-16 12:59:25.000000000 +0530
@@ -0,0 +1,103 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturIntervalExtTable_access.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:    This file contains :
+ *              1)  Include files
+ *              2)  User defined data types
+ *              3)  Function proto-types for adslAturIntervalExtTable_access
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+#ifndef ADSLATURINTERVALEXTTABLE_ACCESS_H
+#define ADSLATURINTERVALEXTTABLE_ACCESS_H
+
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+#include <adslMIB/adslTable_access.h>
+
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+#ifdef STUB_IOCTL
+
+typedef struct adslAturInvtlExtInfo
+{
+  int ifIndex;
+  int IntervalNumber;
+  u_int32 adslAturIntervalSesL;
+  u_int32 adslAturIntervalUasL;
+  u_int32	flags;
+} adslAturInvtlExtInfo;
+#endif
+
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+
+/** User-defined data access functions for data in table
+	adslAturIntervalExtTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAturIntervalExtTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAturIntervalExtTable_get_next_data_point;
+
+/** column accessors */
+u_int32	*get_adslAturIntervalSeconds(void *data_context, size_t * ret_len, unsigned int var);
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAturIntervalExtTable(int Fd2,int GET_adsl_ATUC_INTVL_INFO2,
+        void *adslAturInvtlExtTable);
+#endif
+
+#endif                          /* ADSLATURINTERVALEXTTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_columns.h	2009-12-16 12:59:25.000000000 +0530
@@ -0,0 +1,55 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturIntervalExtTable_columns.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: column number definitions for table adslAturIntervalExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATURINTERVALEXTTABLE_COLUMNS_H
+#define ADSLATURINTERVALEXTTABLE_COLUMNS_H
+
+/*
+ * column number definitions for table adslAturIntervalExtTable
+ */
+#define COLUMN_ADSLATURINTERVALSESL		1
+#define COLUMN_ADSLATURINTERVALUASL		2
+#endif                          /* ADSLATURINTERVALEXTTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable_enums.h	2009-12-16 12:59:25.000000000 +0530
@@ -0,0 +1,65 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturIntervalExtTable_enums.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: Constant definitions for table adslAturIntervalExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATURINTERVALEXTTABLE_ENUMS_H
+#define ADSLATURINTERVALEXTTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+
+/* adslAturIntervalExtTable constants */
+#define GET_ADSL_ATUR_INTVL_EXT_INFO 223
+
+/* adslAturIntervalExtTable flags */
+
+#define ATUR_INTERVAL_SESL_FLAG			0X1 /* BIT 0th position */
+#define ATUR_INTERVAL_UASL_FLAG			0X2 /* BIT 1 */
+
+#endif
+
+#endif                          /* ADSLATURINTERVALEXTTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable.c open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable.c	2009-12-16 12:59:25.000000000 +0530
@@ -0,0 +1,323 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturIntervalTable.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Initializing the adslAturIntervalTable module
+ *                 2) Handling requests for the adslAturIntervalTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Changed the data types of adslAturIntervalValidData
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturIntervalTable.h"
+#include "adslAturIntervalTable_access.h"
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+/** Initialize the adslAturIntervalTable table by defining its contents and how
+    it's structured */
+void
+initialize_table_adslAturIntervalTable(void)
+{
+    static oid      adslAturIntervalTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 9 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAturIntervalTable",
+                                            adslAturIntervalTable_handler,
+                                            adslAturIntervalTable_oid,
+                                            OID_LENGTH
+                                            (adslAturIntervalTable_oid),
+                                            HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_adslAturIntervalTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                             /** index: ifIndex */
+                                     ASN_INTEGER,
+                                           /** index: adslAturIntervalNumber */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 2;
+    table_info->max_column = 6;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAturIntervalTable_get_first_data_point;
+    iinfo->get_next_data_point = adslAturIntervalTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAturIntervalTable_context_convert_function;
+    iinfo->free_data_context = adslAturIntervalTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAturIntervalTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAturIntervalTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAturIntervalTable",
+                "Registering table adslAturIntervalTable as a \
+                table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAturIntervalTable module */
+void
+init_adslAturIntervalTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAturIntervalTable();
+}
+
+/** handles requests for the adslAturIntervalTable table, if anything else
+    needs to be done */
+int
+adslAturIntervalTable_handler(netsnmp_mib_handler *handler,
+                              netsnmp_handler_registration *reginfo,
+                              netsnmp_agent_request_info *reqinfo,
+                              netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    long IntervalNum = 0;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+   IntervalNum = *(requests->requestvb->name + reginfo->rootoid_len + 3);
+
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            data_context = netsnmp_extract_iterator_context(request);
+
+           if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+		    
+            case COLUMN_ADSLATURINTERVALLOFS:
+            case COLUMN_ADSLATURINTERVALLOSS:
+            case COLUMN_ADSLATURINTERVALLPRS:
+            case COLUMN_ADSLATURINTERVALESS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAturIntervalData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                    (const u_char *) retval,
+                                    retval_len);
+                }
+                break;
+#else
+            case COLUMN_ADSLATURINTERVALLOFS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAturIntervalLofs(data_context,
+                                                 &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                    (const u_char *) retval,
+                                    retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURINTERVALLOSS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAturIntervalLoss(data_context,
+                                                 &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                    (const u_char *) retval,
+                                    retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURINTERVALLPRS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAturIntervalLprs(data_context,
+                                                 &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                    (const u_char *) retval,
+                                    retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURINTERVALESS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAturIntervalESs(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                    (const u_char *) retval,
+                                    retval_len);
+                }
+                break;
+#endif
+
+            case COLUMN_ADSLATURINTERVALVALIDDATA:
+                {
+                      int            *retval;
+                    size_t          retval_len = IntervalNum;
+                    retval =
+                        get_adslAturIntervalValidData(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                         "problem encountered in adslAturIntervalTable_handler:\
+                          unknown column\n");
+            }
+            break;
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in adslAturIntervalTable_handler: \
+                     unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable.h open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable.h	2009-12-16 12:59:25.000000000 +0530
@@ -0,0 +1,78 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturIntervalTable.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) Include files
+ *                 2) Init Function proto-types
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATURINTERVALTABLE_H
+#define ADSLATURINTERVALTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+
+/** other required module components */
+config_require(adslMIB/adslAturIntervalTable/adslAturIntervalTable_access)
+
+/* column number definitions for table adslAturIntervalTable */
+#include "adslAturIntervalTable_columns.h"
+
+/* enum definions */
+#include "adslAturIntervalTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+ /* function declarations  */
+void    init_adslAturIntervalTable(void);
+void    initialize_table_adslAturIntervalTable(void);
+Netsnmp_Node_Handler adslAturIntervalTable_handler;
+
+#endif /** ADSLATURINTERVALTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_access.c	2009-12-16 12:59:25.000000000 +0530
@@ -0,0 +1,426 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturIntervalTable_access.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Getting the data context pointer & loop context pointer
+ *                 2) User-defined data access functions (per column) for data
+ *                    in table adslAturIntervalTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Changed the return types of get_adslAturIntervalValidData
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturIntervalTable_access.h"
+#include "adslAturIntervalTable_enums.h"
+
+/** column number definitions for table adslAturIntervalTable **/
+#include "adslAturIntervalTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                           GLOBAL DEFINITIONS
+ * ===========================================================================
+ */
+// *** Global variable definitions
+static long long_ret;
+
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+/** returns the first data point within the adslAturIntervalTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAturIntervalTable_get_first_data_point(void **my_loop_context,
+                                           void **my_data_context,
+                                           netsnmp_variable_list *
+                                           put_index_data,
+                                           netsnmp_iterator_info *mydata)
+{
+
+   int *My_Data_Context;
+   My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+   if (!My_Data_Context) {
+       put_index_data = NULL;
+       snmp_log(LOG_ERR, "adslAturIntervalTable: My_Data_Context malloc \
+                    failed\n");
+       return put_index_data;
+   }
+   *My_Data_Context=IFTYPE_ADSL;
+   *my_data_context=My_Data_Context;
+
+   put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAturIntervalTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAturIntervalTable_get_next_data_point(void **my_loop_context,
+                                          void **my_data_context,
+                                          netsnmp_variable_list *
+                                          put_index_data,
+                                          netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+       put_index_data = NULL;
+       snmp_log(LOG_ERR, "adslAturIntervalTable: My_Data_Context malloc \
+                    failed\n");
+       return put_index_data;
+   }
+   *My_Data_Context=IFTYPE_ADSL;
+   *my_data_context=My_Data_Context;
+
+   put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+   SNMP_FREE(My_Data_Context);
+   return put_index_data;
+}
+
+
+/*  User-defined data access functions (per column) for data in table
+    adslAturIntervalTable */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+#if defined(HAVE_OPTIMIZED_CODE)
+
+u_int32      *
+get_adslAturIntervalData(void *data_context, size_t * ret_len, 
+		unsigned int var)
+{
+   unsigned int flags = 0;
+   struct adslAturIntvlInfo adslAturIntvlStruct;
+   memset(&adslAturIntvlStruct,0,sizeof(adslAturIntvlInfo));
+   adslAturIntvlStruct.ifIndex= (*(int *)data_context);
+   adslAturIntvlStruct.IntervalNumber= (*(int *)ret_len);
+  
+  switch (var) {
+
+    case COLUMN_ADSLATURINTERVALLOFS:
+  	flags = ATUR_INTVL_LOF_FLAG;
+        break;
+	
+    case COLUMN_ADSLATURINTERVALLOSS:
+	flags = ATUR_INTVL_LOS_FLAG;
+	break;
+	
+    case COLUMN_ADSLATURINTERVALLPRS:
+	flags = ATUR_INTVL_LPR_FLAG;
+	break;
+	
+    case COLUMN_ADSLATURINTERVALESS:
+	flags = ATUR_INTVL_ESS_FLAG;
+	break;
+
+    default:
+     	DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+        return NULL;
+  }
+
+  SET_FLAG(&adslAturIntvlStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_INTVL_INFO, &adslAturIntvlStruct);
+#else
+    get_adslAturIntervalTable(Fd, GET_ADSL_ATUR_INTVL_INFO,
+        (void *) &adslAturIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturIntvlStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "IntervalTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+
+	 case ATUR_INTVL_LOF_FLAG:
+    	    long_ret = adslAturIntvlStruct.intervalLOF;
+            break;
+	 
+	 case ATUR_INTVL_LOS_FLAG:
+    	    long_ret = adslAturIntvlStruct.intervalLOS;
+	    break;
+	  
+	 case ATUR_INTVL_LPR_FLAG:
+    	    long_ret = adslAturIntvlStruct.intervalLPR;
+	    break;
+	  
+	 case ATUR_INTVL_ESS_FLAG:
+    	    long_ret = adslAturIntvlStruct.intervalES;
+	    break;
+	  
+         default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+     }
+     
+    CLR_FLAG(&adslAturIntvlStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+#else
+
+/** XXX: return a data pointer to the data for the adslAturIntervalLofs column
+    and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAturIntervalLofs(void *data_context, size_t * ret_len)
+{
+    struct adslAturIntvlInfo adslAturIntvlStruct;
+
+    memset(&adslAturIntvlStruct,0,sizeof(adslAturIntvlInfo));
+    adslAturIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAturIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAturIntvlStruct.flags, ATUR_INTVL_LOF_FLAG);
+    printf("\n Flags = %0x \n", adslAturIntvlStruct.flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_INTVL_INFO, &adslAturIntvlStruct);
+#else
+    get_adslAturIntervalTable(Fd, GET_ADSL_ATUR_INTVL_INFO,
+            (void *) &adslAturIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturIntvlStruct.flags, ATUR_INTVL_LOF_FLAG) == 0) {
+        printf ("\n The adsl_atur_intvl_Lofs could not return correct value\n");
+    }
+    else {
+        printf ("\n The adsl_atur_intvl_Lofs value = %d\n",
+            adslAturIntvlStruct.intervalLOF);
+    }
+    CLR_FLAG(&adslAturIntvlStruct.flags, ATUR_INTVL_LOF_FLAG);
+    long_ret = adslAturIntvlStruct.intervalLOF;
+    *ret_len = sizeof(adslAturIntvlStruct.intervalLOF);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturIntervalLoss column
+    and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAturIntervalLoss(void *data_context, size_t * ret_len)
+{
+    struct adslAturIntvlInfo adslAturIntvlStruct;
+
+    memset(&adslAturIntvlStruct,0,sizeof(adslAturIntvlInfo));
+    adslAturIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAturIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAturIntvlStruct.flags, ATUR_INTVL_LOS_FLAG);
+    printf("\n Flags = %0x \n", adslAturIntvlStruct.flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_INTVL_INFO, &adslAturIntvlStruct);
+#else
+    get_adslAturIntervalTable(Fd, GET_ADSL_ATUR_INTVL_INFO,
+            (void *) &adslAturIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturIntvlStruct.flags, ATUR_INTVL_LOS_FLAG) == 0) {
+        printf ("\n The adsl_atur_intvl_Loss could not return correct value\n");
+    }
+    else {
+        printf ("\n The adsl_atur_intvl_Loss value = %d\n",
+            adslAturIntvlStruct.intervalLOS);
+    }
+    CLR_FLAG(&adslAturIntvlStruct.flags, ATUR_INTVL_LOS_FLAG);
+    long_ret = adslAturIntvlStruct.intervalLOS;
+    *ret_len = sizeof(adslAturIntvlStruct.intervalLOS);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturIntervalLprs column
+    and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAturIntervalLprs(void *data_context, size_t * ret_len)
+{
+    struct adslAturIntvlInfo adslAturIntvlStruct;
+
+    memset(&adslAturIntvlStruct,0,sizeof(adslAturIntvlInfo));
+    adslAturIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAturIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAturIntvlStruct.flags, ATUR_INTVL_LPR_FLAG);
+    printf("\n Flags = %0x \n", adslAturIntvlStruct.flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_INTVL_INFO, &adslAturIntvlStruct);
+#else
+    get_adslAturIntervalTable(Fd, GET_ADSL_ATUR_INTVL_INFO,
+        (void *) &adslAturIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturIntvlStruct.flags, ATUR_INTVL_LPR_FLAG) == 0) {
+        printf ("\n The adsl_atur_intvl_Lprs could not return correct value\n");
+    }
+    else {
+        printf ("\n The adsl_atur_intvl_Lprs value = %d\n",
+            adslAturIntvlStruct.intervalLPR);
+    }
+    CLR_FLAG(&adslAturIntvlStruct.flags, ATUR_INTVL_LPR_FLAG);
+    long_ret = adslAturIntvlStruct.intervalLPR;
+    *ret_len = sizeof(adslAturIntvlStruct.intervalLPR);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturIntervalESs column
+    and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAturIntervalESs(void *data_context, size_t * ret_len)
+{
+    struct adslAturIntvlInfo adslAturIntvlStruct;
+
+    memset(&adslAturIntvlStruct,0,sizeof(adslAturIntvlInfo));
+    adslAturIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAturIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAturIntvlStruct.flags, ATUR_INTVL_ESS_FLAG);
+    printf("\n Flags = %0x \n", adslAturIntvlStruct.flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_INTVL_INFO, &adslAturIntvlStruct);
+#else
+    get_adslAturIntervalTable(Fd, GET_ADSL_ATUR_INTVL_INFO,
+        (void *) &adslAturIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturIntvlStruct.flags, ATUR_INTVL_ESS_FLAG) == 0) {
+        printf ("\n The adsl_atur_intvl_ESs could not return correct value\n");
+    }
+    else {
+        printf ("\n The adsl_atur_intvl_ESs value = %d\n",
+                adslAturIntvlStruct.intervalES);
+    }
+    CLR_FLAG(&adslAturIntvlStruct.flags, ATUR_INTVL_ESS_FLAG);
+    long_ret = adslAturIntvlStruct.intervalES;
+    *ret_len = sizeof(adslAturIntvlStruct.intervalES);
+    return (u_int32 *) &long_ret;
+}
+
+#endif
+
+/** XXX: return a data pointer to the data for the adslAturIntervalValidData
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAturIntervalValidData(void *data_context, size_t * ret_len)
+{
+    struct adslAturIntvlInfo adslAturIntvlStruct;
+
+    memset(&adslAturIntvlStruct,0,sizeof(adslAturIntvlInfo));
+    adslAturIntvlStruct.ifIndex= (*(int *)data_context);
+    adslAturIntvlStruct.IntervalNumber= (*(int *)ret_len);
+    SET_FLAG(&adslAturIntvlStruct.flags, ATUR_INTVL_VALID_DATA_FLAG);
+    printf("\n Flags = %0x \n", adslAturIntvlStruct.flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_INTVL_INFO, &adslAturIntvlStruct);
+#else
+    get_adslAturIntervalTable(Fd, GET_ADSL_ATUR_INTVL_INFO,
+        (void *) &adslAturIntvlStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturIntvlStruct.flags, ATUR_INTVL_VALID_DATA_FLAG)
+            == 0) {
+        printf ("\n The adsl_atur_intvl_valid_data could not return correct \
+            value\n");
+    }
+    else {
+        printf ("\n The adsl_atur_intvl_valid_data value = %d\n",
+            adslAturIntvlStruct.intervalValidData);
+    }
+    CLR_FLAG(&adslAturIntvlStruct.flags, ATUR_INTVL_VALID_DATA_FLAG);
+    long_ret = adslAturIntvlStruct.intervalValidData;
+    *ret_len = sizeof(adslAturIntvlStruct.intervalValidData);
+    return (int *) &long_ret;
+}
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAturIntervalTable(int Fd2,int GET_adsl_ATUR_INTVL_INFO2,
+            void *adslAturInvtlTable)
+{
+    struct adslAturIntvlInfo *adslAturInvtlValue;
+    adslAturInvtlValue = (adslAturIntvlInfo *)adslAturInvtlTable;
+    printf ("\n File Descriptor fd = %d \n", Fd2);
+    printf ("\n Ifindex  = %d \n", adslAturInvtlValue->ifIndex);
+    printf ("\n GET_adsl_ATUR_INTVL_INFO2 = %d \n", GET_adsl_ATUR_INTVL_INFO2);
+
+    adslAturInvtlValue->intervalLOF = 100;
+    adslAturInvtlValue->intervalLOS = 200;
+    adslAturInvtlValue->intervalLPR = 300;
+    adslAturInvtlValue->intervalES = 400;
+    adslAturInvtlValue->intervalValidData = 2;
+    printf("\n Flags = %0x \n", adslAturInvtlValue->flags);
+    return 0;
+}
+
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_access.h	2009-12-16 12:59:25.000000000 +0530
@@ -0,0 +1,113 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturIntervalTable_access.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) User-defined data structure for accessing
+ *                    adslAturIntervalTable
+ *                 2) User-defined data access functions for data in table
+ *                    adslAturIntervalTable
+ *                 3) Column accessors functions
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Changed the return types of get_adslAturIntervalValidData
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+#ifndef ADSLATURINTERVALTABLE_ACCESS_H
+#define ADSLATURINTERVALTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                           USER-DEFINED DATA TYPES
+ * ===========================================================================
+ */
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslAturIntervalTable **/
+#define PerfIntervalCount u_int32
+
+typedef struct adslAturIntvlInfo {
+    int ifIndex;
+    int IntervalNumber;
+    PerfIntervalCount intervalLOF;
+    PerfIntervalCount intervalLOS;
+    PerfIntervalCount intervalLPR;
+    PerfIntervalCount intervalES;
+    int intervalValidData;
+    u_char flags;
+} adslAturIntvlInfo;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+/* User-defined data access functions for data in table adslAturIntervalTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAturIntervalTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAturIntervalTable_get_next_data_point;
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+u_int32      *
+get_adslAturIntervalData(void *data_context, size_t * ret_len, 
+		unsigned int var);
+#else
+u_int32 *get_adslAturIntervalLofs(void *data_context, size_t * ret_len);
+u_int32 *get_adslAturIntervalLoss(void *data_context, size_t * ret_len);
+u_int32 *get_adslAturIntervalLprs(void *data_context, size_t * ret_len);
+u_int32 *get_adslAturIntervalESs(void *data_context, size_t * ret_len);
+#endif
+int    *get_adslAturIntervalValidData(void *data_context, size_t * ret_len);
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAturIntervalTable(int Fd2,int GET_adsl_ATUR_INTVL_INFO2,
+            void *adslAturInvtlTable);
+#endif
+
+#endif                          /* ADSLATURINTERVALTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_columns.h	2009-12-16 12:59:25.000000000 +0530
@@ -0,0 +1,59 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturIntervalTable_columns.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) column number definitions for table adslAturIntervalTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATURINTERVALTABLE_COLUMNS_H
+#define ADSLATURINTERVALTABLE_COLUMNS_H
+
+/* column number definitions for table adslAturIntervalTable */
+#define COLUMN_ADSLATURINTERVALNUMBER       1
+#define COLUMN_ADSLATURINTERVALLOFS         2
+#define COLUMN_ADSLATURINTERVALLOSS         3
+#define COLUMN_ADSLATURINTERVALLPRS         4
+#define COLUMN_ADSLATURINTERVALESS          5
+#define COLUMN_ADSLATURINTERVALVALIDDATA    6
+
+#endif                          /* ADSLATURINTERVALTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturIntervalTable/adslAturIntervalTable_enums.h	2009-12-16 12:59:25.000000000 +0530
@@ -0,0 +1,69 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturIntervalTable_enums.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) adslAturIntervalTable constants
+ *                 2) adslAturIntervalTable Flags
+ *                 3) enums for column adslAturIntervalValidData
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATURINTERVALTABLE_ENUMS_H
+#define ADSLATURINTERVALTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAturIntervalTable constants */
+#define GET_ADSL_ATUR_INTVL_INFO    65
+
+/* adslAturIntervalTable Flags */
+#define ATUR_INTVL_LOF_FLAG     0x1     /* BIT 0th position */
+#define ATUR_INTVL_LOS_FLAG     0x2     /* BIT 1 */
+#define ATUR_INTVL_LPR_FLAG     0x4     /* BIT 2 */
+#define ATUR_INTVL_ESS_FLAG     0x8     /* BIT 3 */
+#define ATUR_INTVL_VALID_DATA_FLAG 0x10 /* BIT 4 */
+#endif
+
+/** enums for column adslAturIntervalValidData **/
+#define ADSLATURINTERVALVALIDDATA_TRUE      1
+#define ADSLATURINTERVALVALIDDATA_FALSE     2
+
+#endif                          /* ADSLATURINTERVALTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable.c open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable.c	2009-12-16 12:59:26.000000000 +0530
@@ -0,0 +1,262 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturPerfDataExtTable.c
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslAturPerfDataExtTable module
+ *               2) Handling requests for the adslAturPerfDataExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturPerfDataExtTable.h"
+#include "adslAturPerfDataExtTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** Initialize the adslAturPerfDataExtTable table by defining its contents and
+    how it's structured */
+void
+initialize_table_adslAturPerfDataExtTable(void)
+{
+    static oid      adslAturPerfDataExtTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 3, 1, 20 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAturPerfDataExtTable",
+                                            adslAturPerfDataExtTable_handler,
+                                            adslAturPerfDataExtTable_oid,
+                                            OID_LENGTH
+                                            (adslAturPerfDataExtTable_oid),
+                                            HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo) {
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_adslAturPerfDataExtTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 8;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAturPerfDataExtTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        adslAturPerfDataExtTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAturPerfDataExtTable_context_convert_function;
+    iinfo->free_data_context = adslAturPerfDataExtTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAturPerfDataExtTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAturPerfDataExtTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAturPerfDataExtTable",
+                "Registering table adslAturPerfDataExtTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAturPerfDataExtTable module */
+void
+init_adslAturPerfDataExtTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAturPerfDataExtTable();
+}
+
+/** handles requests for the adslAturPerfDataExtTable table, if anything else needs to be done */
+int
+adslAturPerfDataExtTable_handler(netsnmp_mib_handler *handler,
+                                 netsnmp_handler_registration *reginfo,
+                                 netsnmp_agent_request_info *reqinfo,
+                                 netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+
+
+    void           *data_context = NULL;
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+   for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_ADSLATURPERFSTATSESL:
+            case COLUMN_ADSLATURPERFSTATUASL:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfStatSeconds(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+		break;
+
+            case COLUMN_ADSLATURPERFCURR15MINSESL:
+            case COLUMN_ADSLATURPERFCURR15MINUASL:
+            case COLUMN_ADSLATURPERFCURR1DAYSESL:
+            case COLUMN_ADSLATURPERFCURR1DAYUASL:
+            case COLUMN_ADSLATURPERFPREV1DAYSESL:
+            case COLUMN_ADSLATURPERFPREV1DAYUASL:
+                {
+                    u_int32			*retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfIntervalSeconds(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                             (const u_char *) retval, retval_len);
+                }
+                break;
+		    
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+   "problem encountered in adslAturPerfDataExtTable_handler: unknown column\n");
+            }
+            break;
+
+            default:
+            snmp_log(LOG_ERR,
+  "problem encountered in adslAturPerfDataExtTable_handler:unsupported mode\n");
+
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable.h open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable.h	2009-12-16 12:59:26.000000000 +0530
@@ -0,0 +1,89 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturPerfDataExtTable.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                    1) Include files
+ *                    2) Init Function proto-types for adslAturPerfDataExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATURPERFDATAEXTTABLE_H
+#define ADSLATURPERFDATAEXTTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+ /** other required module components */
+config_require(adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_access)
+
+ /*
+ * column number definitions for table adslAturPerfDataExtTable
+ */
+#include "adslAturPerfDataExtTable_columns.h"
+
+/*
+ * enum definions
+ */
+#include "adslAturPerfDataExtTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+    /*
+     * function declarations
+     */
+     void            init_adslAturPerfDataExtTable(void);
+     void            initialize_table_adslAturPerfDataExtTable(void);
+     Netsnmp_Node_Handler adslAturPerfDataExtTable_handler;
+
+
+
+
+#endif /** ADSLATURPERFDATAEXTTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_access.c	2009-12-16 12:59:26.000000000 +0530
@@ -0,0 +1,342 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturPerfDataExtTable_access.c
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) to get
+ *                     data for the table adslAturPerfDataExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturPerfDataExtTable_access.h"
+#ifdef STUB_IOCTL
+#include "adslAturPerfDataExtTable_enums.h"
+#endif
+
+/* column number definitions for table adslAturPerfDataExtTable */
+#include "adslAturPerfDataExtTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+// *** Global variable definitions
+static u_int32 long_ret;
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** returns the first data point within the adslAturPerfDataExtTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAturPerfDataExtTable_get_first_data_point(void **my_loop_context,
+                                              void **my_data_context,
+                                              netsnmp_variable_list *
+                                              put_index_data,
+                                              netsnmp_iterator_info
+                                              *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+     "Get-First: adslAturPerfDataExtTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAturPerfDataExtTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAturPerfDataExtTable_get_next_data_point(void **my_loop_context,
+                                             void **my_data_context,
+                                             netsnmp_variable_list *
+                                             put_index_data,
+                                             netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+    "Get-Next: adslAturPerfDataExtTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+/*
+ * User-defined data access functions (per column) for data in table
+ * adslAturPerfDataExtTabl
+ */
+u_int32         *
+get_adslAturPerfStatSeconds(void *data_context, size_t * ret_len, unsigned int var)
+{
+  unsigned int flags = 0;
+  struct aturPerfDataExtEntry aturPerfDataExtEntryStruct;
+  memset(&aturPerfDataExtEntryStruct,0,sizeof(aturPerfDataExtEntry));
+  aturPerfDataExtEntryStruct.ifIndex= (*(int *)data_context);
+
+  switch (var)  {
+
+	case COLUMN_ADSLATURPERFSTATSESL:
+	   flags = ATUR_PERF_STAT_SESL_FLAG;
+	   break;
+
+	case COLUMN_ADSLATURPERFSTATUASL:
+	   flags = ATUR_PERF_STAT_UASL_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  }
+
+  SET_FLAG(&aturPerfDataExtEntryStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA_EXT, (void *) &aturPerfDataExtEntryStruct);
+#else
+    get_adslAturPerfDataExtTable(Fd, GET_ADSL_ATUR_PERF_DATA_EXT, (void *) &aturPerfDataExtEntryStruct);
+#endif
+   if (IS_FLAG_SET(&aturPerfDataExtEntryStruct.flags, flags) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataExtTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUR_PERF_STAT_SESL_FLAG:
+           long_ret = aturPerfDataExtEntryStruct.adslAturPerfStatSesL;
+	   break;
+
+	case ATUR_PERF_STAT_UASL_FLAG:
+    	   long_ret = aturPerfDataExtEntryStruct.adslAturPerfStatUasL;
+	   break;
+
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+
+    CLR_FLAG(&aturPerfDataExtEntryStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+
+u_int32         *
+get_adslAturPerfIntervalSeconds(void *data_context, size_t * ret_len, unsigned int var)
+{
+  unsigned int flags = 0;
+  struct aturPerfDataExtEntry aturPerfDataExtEntryStruct;
+  memset(&aturPerfDataExtEntryStruct,0,sizeof(aturPerfDataExtEntry));
+  aturPerfDataExtEntryStruct.ifIndex= (*(int *)data_context);
+
+  switch (var)  {
+
+	case COLUMN_ADSLATURPERFCURR15MINSESL:
+	   flags = ATUR_PERF_CURR_15MIN_SESL_FLAG;
+	   break;
+
+	case COLUMN_ADSLATURPERFCURR15MINUASL:
+	   flags = ATUR_PERF_CURR_15MIN_UASL_FLAG;
+	   break;
+	   
+        case COLUMN_ADSLATURPERFCURR1DAYSESL:
+	   flags = ATUR_PERF_CURR_1DAY_SESL_FLAG;
+	   break;
+	   
+        case COLUMN_ADSLATURPERFCURR1DAYUASL:
+	   flags = ATUR_PERF_CURR_1DAY_UASL_FLAG;
+	   break;
+	   
+        case COLUMN_ADSLATURPERFPREV1DAYSESL:
+	   flags = ATUR_PERF_PREV_1DAY_SESL_FLAG;
+	   break;
+	   
+        case COLUMN_ADSLATURPERFPREV1DAYUASL:
+	   flags = ATUR_PERF_PREV_1DAY_UASL_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  }
+
+  SET_FLAG(&aturPerfDataExtEntryStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA_EXT  , (void *) &aturPerfDataExtEntryStruct);
+#else
+    get_adslAturPerfDataExtTable(Fd, GET_ADSL_ATUR_PERF_DATA_EXT, (void *) &aturPerfDataExtEntryStruct);
+#endif
+   if (IS_FLAG_SET(&aturPerfDataExtEntryStruct.flags, flags) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataExtTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUR_PERF_CURR_15MIN_SESL_FLAG:
+    	   long_ret = aturPerfDataExtEntryStruct.adslAturPerfCurr15MinSesL;
+	   break;
+
+	case ATUR_PERF_CURR_15MIN_UASL_FLAG:
+    	   long_ret = aturPerfDataExtEntryStruct.adslAturPerfCurr15MinUasL;
+	   break;
+
+	case ATUR_PERF_CURR_1DAY_SESL_FLAG:
+    	   long_ret = aturPerfDataExtEntryStruct.adslAturPerfCurr1DaySesL;
+	   break;
+	   
+	case ATUR_PERF_CURR_1DAY_UASL_FLAG:
+    	   long_ret = aturPerfDataExtEntryStruct.adslAturPerfCurr1DayUasL;
+	   break;
+	   
+	case ATUR_PERF_PREV_1DAY_SESL_FLAG:
+           long_ret = aturPerfDataExtEntryStruct.adslAturPerfPrev1DaySesL;
+	   break;
+	   
+	case ATUR_PERF_PREV_1DAY_UASL_FLAG:
+    	   long_ret = aturPerfDataExtEntryStruct.adslAturPerfPrev1DayUasL;
+	   break;
+
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+
+    CLR_FLAG(&aturPerfDataExtEntryStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAturPerfDataExtTable(int Fd2,int GET_adsl_ATUC_PERF_DATA2,
+        void *aturPerfDataValue)
+{
+
+    struct aturPerfDataExtEntry *aturPerfData;
+    aturPerfData = (aturPerfDataExtEntry *) aturPerfDataValue;
+
+
+
+    aturPerfData->adslAturPerfStatSesL = 30;
+
+    aturPerfData->adslAturPerfStatUasL = 40;
+
+    aturPerfData->adslAturPerfCurr15MinSesL = 10;
+
+    aturPerfData->adslAturPerfCurr15MinUasL = 15;
+
+    aturPerfData->adslAturPerfCurr1DaySesL = 30;
+
+    aturPerfData->adslAturPerfCurr1DayUasL = 40;
+
+    aturPerfData->adslAturPerfPrev1DaySesL = 65;
+
+    aturPerfData->adslAturPerfPrev1DayUasL = 70;
+
+    return 0;
+}
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_access.h	2009-12-16 12:59:26.000000000 +0530
@@ -0,0 +1,113 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturPerfDataExtTable_access.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *              1)  Include files
+ *              2)  User defined data types
+ *              3)  Function proto-types for adslAturPerfDataExtTable_access
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+#ifndef ADSLATURPERFDATAEXTTABLE_ACCESS_H
+#define ADSLATURPERFDATAEXTTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+#include <adslMIB/adslTable_access.h>
+
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslAturPerfDataExtTable **/
+
+typedef struct aturPerfDataExtEntry
+ {
+  int ifIndex;
+  u_int32 adslAturPerfStatSesL;
+  u_int32 adslAturPerfStatUasL;
+  u_int32 adslAturPerfCurr15MinSesL;
+  u_int32 adslAturPerfCurr15MinUasL;
+  u_int32 adslAturPerfCurr1DaySesL;
+  u_int32 adslAturPerfCurr1DayUasL;
+  u_int32 adslAturPerfPrev1DaySesL;
+  u_int32 adslAturPerfPrev1DayUasL;
+  u_int32	flags;
+} aturPerfDataExtEntry;
+
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/** User-defined data access functions for data in table
+    adslAturPerfDataExtTable */
+
+/** row level accessors */
+Netsnmp_First_Data_Point adslAturPerfDataExtTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAturPerfDataExtTable_get_next_data_point;
+
+u_int32         *
+get_adslAturPerfStatSeconds(void *data_context, size_t * ret_len, unsigned int var);
+
+u_int32         *
+get_adslAturPerfIntervalSeconds(void *data_context, size_t * ret_len, unsigned int var);
+
+
+#ifndef ENABLE_DRIVER_CALL
+
+int get_adslAturPerfDataExtTable(int Fd2,int GET_adsl_ATUC_PERF_DATA2,
+					void *atucPerfDataValue);
+#endif
+
+
+#endif                          /* ADSLATURPERFDATAEXTTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_columns.h	2009-12-16 12:59:26.000000000 +0530
@@ -0,0 +1,64 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturPerfDataExtTable_columns.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:  column number definitions for table adslAturPerfDataExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATURPERFDATAEXTTABLE_COLUMNS_H
+#define ADSLATURPERFDATAEXTTABLE_COLUMNS_H
+
+/*
+ * column number definitions for table adslAturPerfDataExtTable
+ */
+#define COLUMN_ADSLATURPERFSTATSESL		1
+#define COLUMN_ADSLATURPERFSTATUASL		2
+#define COLUMN_ADSLATURPERFCURR15MINSESL		3
+#define COLUMN_ADSLATURPERFCURR15MINUASL		4
+#define COLUMN_ADSLATURPERFCURR1DAYSESL		5
+#define COLUMN_ADSLATURPERFCURR1DAYUASL		6
+#define COLUMN_ADSLATURPERFPREV1DAYSESL		7
+#define COLUMN_ADSLATURPERFPREV1DAYUASL		8
+#endif                          /* ADSLATURPERFDATAEXTTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable_enums.h	2009-12-16 12:59:26.000000000 +0530
@@ -0,0 +1,71 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslAturPerfDataExtTable_enums.h
+ * Author       :   Subramani
+ * Date         :   11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: Constant definitions for table adslAturPerfDataExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATURPERFDATAEXTTABLE_ENUMS_H
+#define ADSLATURPERFDATAEXTTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+
+/* adslAturPerfDataExtTable constants */
+#define GET_ADSL_ATUR_PERF_DATA_EXT 225
+
+/* adslAturPerfDataExtTable */
+#define ATUR_PERF_STAT_SESL_FLAG		0X1 /* BIT 0th position */
+#define ATUR_PERF_STAT_UASL_FLAG		0X2 /* BIT 1 */
+#define ATUR_PERF_CURR_15MIN_SESL_FLAG		0X4 /* BIT 2 */
+#define ATUR_PERF_CURR_15MIN_UASL_FLAG		0X8 /* BIT 3 */
+#define ATUR_PERF_CURR_1DAY_SESL_FLAG		0X10 /* BIT 4 */
+#define ATUR_PERF_CURR_1DAY_UASL_FLAG		0X20 /* BIT 5 */
+#define ATUR_PERF_PREV_1DAY_SESL_FLAG		0X40 /* BIT 6 */
+#define ATUR_PERF_PREV_1DAY_UASL_FLAG		0X80 /* BIT 7 */
+
+
+#endif
+
+#endif                          /* ADSLATURPERFDATAEXTTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable.c open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable.c	2009-12-16 12:59:26.000000000 +0530
@@ -0,0 +1,557 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPerfDataTable.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Initializing the adslAturPerfDataTable module
+ *                 2) Handling requests for the adslAturPerfDataTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * subramani: Changed the data types for adslAturPerfValidIntervals,
+ * adslAturPerfInvalidIntervals and adslAturPerfPrev1DayMoniSecs
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturPerfDataTable.h"
+#include "adslAturPerfDataTable_access.h"
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+/** Initialize the adslAturPerfDataTable table by defining its contents and how
+    it's structured */
+void
+initialize_table_adslAturPerfDataTable(void)
+{
+    static oid      adslAturPerfDataTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 7 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration("adslAturPerfDataTable",
+                                            adslAturPerfDataTable_handler,
+                                            adslAturPerfDataTable_oid,
+                                            OID_LENGTH
+                                            (adslAturPerfDataTable_oid),
+                                            HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_adslAturPerfDataTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 21;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslAturPerfDataTable_get_first_data_point;
+    iinfo->get_next_data_point = adslAturPerfDataTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslAturPerfDataTable_context_convert_function;
+    iinfo->free_data_context = adslAturPerfDataTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAturPerfDataTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAturPerfDataTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAturPerfDataTable",
+                "Registering table adslAturPerfDataTable as a \
+                table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAturPerfDataTable module */
+void
+init_adslAturPerfDataTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAturPerfDataTable();
+}
+
+/** handles requests for the adslAturPerfDataTable table, if anything else
+    needs to be done */
+int
+adslAturPerfDataTable_handler(netsnmp_mib_handler *handler,
+                              netsnmp_handler_registration *reginfo,
+                              netsnmp_agent_request_info *reqinfo,
+                              netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+    void *data_context = NULL;
+
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+	    case COLUMN_ADSLATURPERFLOFS:
+	    case COLUMN_ADSLATURPERFLOSS:
+	    case COLUMN_ADSLATURPERFLPRS:
+	    case COLUMN_ADSLATURPERFESS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfDataLoss(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                       (const u_char *) retval, retval_len);
+                }
+		break;
+
+	    case COLUMN_ADSLATURPERFVALIDINTERVALS:
+	    case COLUMN_ADSLATURPERFINVALIDINTERVALS:
+	    case COLUMN_ADSLATURPERFPREV1DAYMONISECS:
+                {
+                    int           *retval;
+                    size_t         retval_len = 0;
+                    retval =
+                        get_adslAturPerfIntervalData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                       (const u_char *) retval, retval_len);
+                }
+		break;
+
+	    case COLUMN_ADSLATURPERFCURR15MINTIMEELAPSED:
+	    case COLUMN_ADSLATURPERFCURR15MINLOFS:
+	    case COLUMN_ADSLATURPERFCURR15MINLOSS:
+	    case COLUMN_ADSLATURPERFCURR15MINLPRS:
+	    case COLUMN_ADSLATURPERFCURR15MINESS:
+	    case COLUMN_ADSLATURPERFCURR1DAYTIMEELAPSED:
+	    case COLUMN_ADSLATURPERFCURR1DAYLOFS:
+	    case COLUMN_ADSLATURPERFCURR1DAYLOSS:
+	    case COLUMN_ADSLATURPERFCURR1DAYLPRS:
+	    case COLUMN_ADSLATURPERFCURR1DAYESS:
+	    case COLUMN_ADSLATURPERFPREV1DAYLOFS:
+	    case COLUMN_ADSLATURPERFPREV1DAYLOSS:
+	    case COLUMN_ADSLATURPERFPREV1DAYLPRS:
+	    case COLUMN_ADSLATURPERFPREV1DAYESS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfDataStats(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                       (const u_char *) retval, retval_len);
+                }
+                break;
+
+#else
+            case COLUMN_ADSLATURPERFLOFS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfLofs(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFLOSS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfLoss(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFLPRS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfLprs(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFESS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfESs(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFVALIDINTERVALS:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfValidIntervals(data_context,
+                                                       &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFINVALIDINTERVALS:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfInvalidIntervals(data_context,
+                                                         &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFCURR15MINTIMEELAPSED:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfCurr15MinTimeElapsed(data_context,
+                                                             &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFCURR15MINLOFS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfCurr15MinLofs(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                (const u_char *) retval,
+                                retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFCURR15MINLOSS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfCurr15MinLoss(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                (const u_char *) retval,
+                                retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFCURR15MINLPRS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfCurr15MinLprs(data_context,
+                                                      &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                (const u_char *) retval,
+                                retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFCURR15MINESS:
+                {
+                    u_int32          *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfCurr15MinESs(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                (const u_char *) retval,
+                                retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFCURR1DAYTIMEELAPSED:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfCurr1DayTimeElapsed(data_context,
+                                                            &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFCURR1DAYLOFS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfCurr1DayLofs(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFCURR1DAYLOSS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfCurr1DayLoss(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFCURR1DAYLPRS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfCurr1DayLprs(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFCURR1DAYESS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfCurr1DayESs(data_context,
+                                                    &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFPREV1DAYMONISECS:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfPrev1DayMoniSecs(data_context,
+                                                         &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFPREV1DAYLOFS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfPrev1DayLofs(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFPREV1DAYLOSS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfPrev1DayLoss(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFPREV1DAYLPRS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfPrev1DayLprs(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURPERFPREV1DAYESS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturPerfPrev1DayESs(data_context,
+                                                    &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+#endif
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                         "problem encountered in adslAturPerfDataTable_handler:\
+                          unknown column\n");
+            }
+            break;
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in adslAturPerfDataTable_handler: \
+                     unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable.h open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable.h	2009-12-16 12:59:26.000000000 +0530
@@ -0,0 +1,78 @@
+/* Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPerfDataTable.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) Include files
+ *                 2) Init Function proto-types
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATURPERFDATATABLE_H
+#define ADSLATURPERFDATATABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+
+ /** other required module components */
+config_require(adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_access)
+
+/* column number definitions for table adslAturPerfDataTable */
+#include "adslAturPerfDataTable_columns.h"
+
+/* enum definions */
+#include "adslAturPerfDataTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+    /* function declarations */
+void  init_adslAturPerfDataTable(void);
+void  initialize_table_adslAturPerfDataTable(void);
+Netsnmp_Node_Handler adslAturPerfDataTable_handler;
+
+#endif /** ADSLATURPERFDATATABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_access.c	2009-12-16 12:59:27.000000000 +0530
@@ -0,0 +1,1067 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPerfDataTable_access.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Getting the data context pointer & loop context pointer
+ *                 2) User-defined data access functions (per column) for data
+ *                    in table adslAturPerfDataTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * subramani: Changed the return types for get_adslAturPerfValidIntervals,
+ * get_adslAturPerfInvalidIntervals and get_adslAturPerfPrev1DayMoniSecs
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturPerfDataTable_access.h"
+#ifdef STUB_IOCTL
+#include "adslAturPerfDataTable_enums.h"
+#endif
+
+
+/* column number definitions for table adslAturPerfDataTable */
+#include "adslAturPerfDataTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                           GLOBAL DEFINITIONS
+ * ===========================================================================
+ */
+// *** Global variable definitions
+static long long_ret;
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+
+/** returns the first data point within the adslAturPerfDataTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAturPerfDataTable_get_first_data_point(void **my_loop_context,
+                                           void **my_data_context,
+                                           netsnmp_variable_list *
+                                           put_index_data,
+                                           netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-First: adslAturPerfDataTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAturPerfDataTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAturPerfDataTable_get_next_data_point(void **my_loop_context,
+                                          void **my_data_context,
+                                          netsnmp_variable_list *
+                                          put_index_data,
+                                          netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-Next: adslAtucPerfDataTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/*
+ * User-defined data access functions (per column) for data in table
+   adslAturPerfDataTable */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+#if defined(HAVE_OPTIMIZED_CODE)
+
+u_int32  *
+get_adslAturPerfDataLoss(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct aturPerfDataEntry aturPerfDataEntryStruct;
+  memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+  aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+  
+  switch (var)  {
+
+	case COLUMN_ADSLATURPERFLOFS:
+	   flags = ATUR_PERF_LOFS_FLAG;
+	   break;
+
+	case COLUMN_ADSLATURPERFLOSS:
+	   flags = ATUR_PERF_LOSS_FLAG;
+	   break;
+
+	case COLUMN_ADSLATURPERFLPRS:
+	   flags = ATUR_PERF_LPR_FLAG;
+	   break;
+
+	case COLUMN_ADSLATURPERFESS:
+	   flags = ATUR_PERF_ESS_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  }
+
+  SET_FLAG(&aturPerfDataEntryStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+            (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUR_PERF_LOFS_FLAG:
+    	   long_ret = aturPerfDataEntryStruct.adslAturPerfLofs;
+	   break;
+
+	case ATUR_PERF_LOSS_FLAG:
+    	   long_ret = aturPerfDataEntryStruct.adslAturPerfLoss;
+	   break;
+
+	case ATUR_PERF_LPR_FLAG:
+    	   long_ret = aturPerfDataEntryStruct.adslAturPerfLprs;
+	   break;
+
+	case ATUR_PERF_ESS_FLAG:
+    	   long_ret = aturPerfDataEntryStruct.adslAturPerfESs;
+	   break;
+		
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+    
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+
+int *
+get_adslAturPerfIntervalData(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct aturPerfDataEntry aturPerfDataEntryStruct;
+  memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+  aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+      case COLUMN_ADSLATURPERFVALIDINTERVALS:
+	 flags = ATUR_PERF_VALID_INTVLS_FLAG;
+	 break;
+	 
+      case COLUMN_ADSLATURPERFINVALIDINTERVALS:
+	 flags = ATUR_PERF_INVALID_INTVLS_FLAG;
+	 break;
+
+      case COLUMN_ADSLATURPERFPREV1DAYMONISECS:
+	 flags = ATUR_PERF_PREV_1DAY_MON_SEC_FLAG;
+	 break;
+	 
+      default:
+     	 DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	 return NULL;
+ }
+  
+  SET_FLAG(&aturPerfDataEntryStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+            (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataTable: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+	    
+	case ATUR_PERF_VALID_INTVLS_FLAG:
+    	   long_ret = aturPerfDataEntryStruct.adslAturPerfValidIntervals;
+	   break;
+
+	case ATUR_PERF_INVALID_INTVLS_FLAG:
+    	   long_ret = aturPerfDataEntryStruct.adslAturPerfInvalidIntervals;
+	   break;
+
+	case ATUR_PERF_PREV_1DAY_MON_SEC_FLAG:
+    	   long_ret = aturPerfDataEntryStruct.adslAturPerfPrev1DayMoniSecs;
+	   break;
+
+        default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+    }
+    
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, flags);
+    *ret_len = sizeof(int);
+    return (int *) &long_ret;
+}
+
+
+u_int32  *
+get_adslAturPerfDataStats(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct aturPerfDataEntry aturPerfDataEntryStruct;
+  memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+  aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+      case COLUMN_ADSLATURPERFCURR15MINTIMEELAPSED:
+	 flags = ATUR_PERF_CURR_15MIN_TIME_ELAPSED_FLAG; 
+         break;
+	 
+      case COLUMN_ADSLATURPERFCURR15MINLOFS:
+	 flags = ATUR_PERF_CURR_15MIN_LOFS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFCURR15MINLOSS:
+	 flags = ATUR_PERF_CURR_15MIN_LOSS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFCURR15MINLPRS:
+	 flags = ATUR_PERF_CURR_15MIN_LPR_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFCURR15MINESS:
+	 flags = ATUR_PERF_CURR_15MIN_ESS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFCURR1DAYTIMEELAPSED:
+	 flags = ATUR_PERF_CURR_1DAY_TIME_ELAPSED_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFCURR1DAYLOFS:
+	 flags = ATUR_PERF_CURR_1DAY_LOFS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFCURR1DAYLOSS:
+	 flags = ATUR_PERF_CURR_1DAY_LOSS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFCURR1DAYLPRS:
+	 flags = ATUR_PERF_CURR_1DAY_LPR_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFCURR1DAYESS:
+	 flags = ATUR_PERF_CURR_1DAY_ESS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFPREV1DAYLOFS:
+	 flags = ATUR_PERF_PREV_1DAY_LOFS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFPREV1DAYLOSS:
+	 flags = ATUR_PERF_PREV_1DAY_LOSS_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFPREV1DAYLPRS:
+	 flags = ATUR_PERF_PREV_1DAY_LPR_FLAG;
+	 break;
+	  
+      case COLUMN_ADSLATURPERFPREV1DAYESS:
+	 flags = ATUR_PERF_PREV_1DAY_ESS_FLAG;
+	 break;
+	 
+      default:
+     	 DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+         return NULL;
+ }
+
+  SET_FLAG(&aturPerfDataEntryStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+            (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataTable: GET- %x CMV fail\n", flags));
+
+     switch (flags)  {
+
+	 case ATUR_PERF_CURR_15MIN_TIME_ELAPSED_FLAG:
+	    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr15MinTimeElapsed;
+            break;
+	 
+	 case ATUR_PERF_CURR_15MIN_LOFS_FLAG:
+	    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr15MinLofs;
+	    break;
+	  
+	 case ATUR_PERF_CURR_15MIN_LOSS_FLAG:
+    	    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr15MinLoss;
+	    break;
+	  
+	 case ATUR_PERF_CURR_15MIN_LPR_FLAG:
+    	    long_ret =  aturPerfDataEntryStruct.adslAturPerfCurr15MinLprs;
+	    break;
+	  
+	 case ATUR_PERF_CURR_15MIN_ESS_FLAG:
+    	    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr15MinESs;
+	    break;
+	  
+	 case ATUR_PERF_CURR_1DAY_TIME_ELAPSED_FLAG:
+    	    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr1DayTimeElapsed;
+	    break;
+	  
+	 case ATUR_PERF_CURR_1DAY_LOFS_FLAG:
+    	    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr1DayLofs;
+	    break;
+	  
+	 case ATUR_PERF_CURR_1DAY_LOSS_FLAG:
+    	    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr1DayLoss;
+	    break;
+	  
+	 case ATUR_PERF_CURR_1DAY_LPR_FLAG:
+    	    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr1DayLprs;
+            break;
+	  
+	 case ATUR_PERF_CURR_1DAY_ESS_FLAG:
+    	    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr1DayESs;
+	    break;
+	  
+	 case ATUR_PERF_PREV_1DAY_LOFS_FLAG:
+    	    long_ret = aturPerfDataEntryStruct.adslAturPerfPrev1DayLofs;
+	    break;
+	  
+	 case ATUR_PERF_PREV_1DAY_LOSS_FLAG:
+    	    long_ret = aturPerfDataEntryStruct.adslAturPerfPrev1DayLoss;
+	    break;
+	  
+	 case ATUR_PERF_PREV_1DAY_LPR_FLAG:
+    	    long_ret = aturPerfDataEntryStruct.adslAturPerfPrev1DayLprs;
+	    break;
+	  
+	 case ATUR_PERF_PREV_1DAY_ESS_FLAG:
+    	    long_ret = aturPerfDataEntryStruct.adslAturPerfPrev1DayESs;
+	    break;
+	 
+         default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+     }
+     
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+#else
+
+/** XXX: return a data pointer to the data for the adslAturPerfLofs column
+    and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfLofs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+                (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags, ATUR_PERF_LOFS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataLOFS CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_LOFS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfLofs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfLofs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfLoss column and
+    set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfLoss(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+                (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags, ATUR_PERF_LOSS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataLOSS CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_LOSS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfLoss;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfLoss);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfLprs column and
+    set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfLprs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_LPR_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+                (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags, ATUR_PERF_LPR_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataLPRS CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_LPR_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfLprs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfLprs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfESs column and
+    set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfESs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+            (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags, ATUR_PERF_ESS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataESS CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_ESS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfESs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfESs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfValidIntervals
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAturPerfValidIntervals(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_VALID_INTVLS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+            (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+            ATUR_PERF_VALID_INTVLS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataValidIntvl CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_VALID_INTVLS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfValidIntervals;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfValidIntervals);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfInvalidIntervals
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAturPerfInvalidIntervals(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_INVALID_INTVLS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+            (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+            ATUR_PERF_INVALID_INTVLS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataInvalidIntvl CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_INVALID_INTVLS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfInvalidIntervals;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfInvalidIntervals);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturPerfCurr15MinTimeElapsed column and set ret_len to its proper size
+    in bytes. */
+u_int32         *
+get_adslAturPerfCurr15MinTimeElapsed(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+   memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags,
+        ATUR_PERF_CURR_15MIN_TIME_ELAPSED_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+                (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+            ATUR_PERF_CURR_15MIN_TIME_ELAPSED_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataCurr15Min CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags,
+            ATUR_PERF_CURR_15MIN_TIME_ELAPSED_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr15MinTimeElapsed;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfCurr15MinTimeElapsed);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfCurr15MinLofs
+    column and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAturPerfCurr15MinLofs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_15MIN_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+            (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+            ATUR_PERF_CURR_15MIN_LOFS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataCurr15MinLOF CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_15MIN_LOFS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr15MinLofs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfCurr15MinLofs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfCurr15MinLoss
+    column and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAturPerfCurr15MinLoss(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_15MIN_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+            (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+            ATUR_PERF_CURR_15MIN_LOSS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataCurr15MinLOSS CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_15MIN_LOSS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr15MinLoss;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfCurr15MinLoss);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfCurr15MinLprs
+    column and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAturPerfCurr15MinLprs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_15MIN_LPR_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+           ATUR_PERF_CURR_15MIN_LPR_FLAG) == 0) 
+      DEBUGMSGTL(("adslMIB-ATUR", "PerfDataCurr15MinLOSS CMV fail\n"));
+    
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_15MIN_LPR_FLAG);
+    long_ret =  aturPerfDataEntryStruct.adslAturPerfCurr15MinLprs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfCurr15MinLprs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfCurr15MinESs
+    column and set ret_len to its proper size in bytes. */
+u_int32      *
+get_adslAturPerfCurr15MinESs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_15MIN_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+        ATUR_PERF_CURR_15MIN_ESS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataCurr15MinESS CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_15MIN_ESS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr15MinESs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfCurr15MinESs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturPerfCurr1DayTimeElapsed column and set ret_len to its proper
+    size in bytes. */
+u_int32         *
+get_adslAturPerfCurr1DayTimeElapsed(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags,
+        ATUR_PERF_CURR_1DAY_TIME_ELAPSED_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+        ATUR_PERF_CURR_1DAY_TIME_ELAPSED_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataCurr1DayElapse CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags,
+        ATUR_PERF_CURR_1DAY_TIME_ELAPSED_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr1DayTimeElapsed;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfCurr1DayTimeElapsed);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfCurr1DayLofs
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfCurr1DayLofs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_1DAY_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+        ATUR_PERF_CURR_1DAY_LOFS_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-ATUR", "PerfDataCurr1DayLOF CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_1DAY_LOFS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr1DayLofs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfCurr1DayLofs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfCurr1DayLoss
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfCurr1DayLoss(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_1DAY_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+        ATUR_PERF_CURR_1DAY_LOSS_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-ATUR", "PerfDataCurr1DayLOSS CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_1DAY_LOSS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr1DayLoss;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfCurr1DayLoss);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfCurr1DayLprs
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfCurr1DayLprs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_1DAY_LPR_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+            ATUR_PERF_CURR_1DAY_LPR_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataCurr1DayLPR CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_1DAY_LPR_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr1DayLprs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfCurr1DayLprs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfCurr1DayESs
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfCurr1DayESs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_1DAY_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+                ATUR_PERF_CURR_1DAY_ESS_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-ATUR", "PerfDataCurr1DayESS CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_CURR_1DAY_ESS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfCurr1DayESs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfCurr1DayESs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfPrev1DayMoniSecs
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAturPerfPrev1DayMoniSecs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_PREV_1DAY_MON_SEC_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+        ATUR_PERF_PREV_1DAY_MON_SEC_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataPrev1DayMonSec CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_PREV_1DAY_MON_SEC_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfPrev1DayMoniSecs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfPrev1DayMoniSecs);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfPrev1DayLofs
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfPrev1DayLofs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_PREV_1DAY_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+        ATUR_PERF_PREV_1DAY_LOFS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PerfDataPrev1DayLOF CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_PREV_1DAY_LOFS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfPrev1DayLofs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfPrev1DayLofs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfPrev1DayLoss
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfPrev1DayLoss(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_PREV_1DAY_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+        ATUR_PERF_PREV_1DAY_LOSS_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-ATUR", "PerfDataPrev1DayLOSS CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_PREV_1DAY_LOSS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfPrev1DayLoss;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfPrev1DayLoss);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfPrev1DayLprs
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfPrev1DayLprs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_PREV_1DAY_LPR_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+            ATUR_PERF_PREV_1DAY_LPR_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-ATUR", "PerfDataPrev1DayLPR CMV fail\n"));
+
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_PREV_1DAY_LPR_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfPrev1DayLprs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfPrev1DayLprs);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturPerfPrev1DayESs
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturPerfPrev1DayESs(void *data_context, size_t * ret_len)
+{
+    struct aturPerfDataEntry aturPerfDataEntryStruct;
+
+    memset(&aturPerfDataEntryStruct,0,sizeof(aturPerfDataEntry));
+    aturPerfDataEntryStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_PREV_1DAY_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PERF_DATA, (void *) &aturPerfDataEntryStruct);
+#else
+    get_adslAturPerfDataTable(Fd, GET_ADSL_ATUR_PERF_DATA,
+        (void *) &aturPerfDataEntryStruct);
+#endif
+    if (IS_FLAG_SET(&aturPerfDataEntryStruct.flags,
+                ATUR_PERF_PREV_1DAY_ESS_FLAG) == 0) 
+      DEBUGMSGTL(("adslMIB-ATUR", "PerfDataPrev1DayESS CMV fail\n"));
+     
+    CLR_FLAG(&aturPerfDataEntryStruct.flags, ATUR_PERF_PREV_1DAY_ESS_FLAG);
+    long_ret = aturPerfDataEntryStruct.adslAturPerfPrev1DayESs;
+    *ret_len = sizeof(aturPerfDataEntryStruct.adslAturPerfPrev1DayESs);
+    return (u_int32 *) &long_ret;
+}
+#endif
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAturPerfDataTable(int Fd2,int GET_adsl_ATUR_PERF_DATA2,
+                void *aturPerfDataValue)
+{
+
+    struct aturPerfDataEntry *aturPerfData;
+    aturPerfData = (aturPerfDataEntry *) aturPerfDataValue;
+    aturPerfData->adslAturPerfLofs = 10;
+    aturPerfData->adslAturPerfLoss = 20;
+    aturPerfData->adslAturPerfLprs = 30;
+    aturPerfData->adslAturPerfESs = 40;
+    aturPerfData->adslAturPerfValidIntervals = 10;
+    aturPerfData->adslAturPerfInvalidIntervals = 20;
+    aturPerfData->adslAturPerfCurr15MinTimeElapsed = 10;
+    aturPerfData->adslAturPerfCurr15MinLofs = 15;
+    aturPerfData->adslAturPerfCurr15MinLoss = 20;
+    aturPerfData->adslAturPerfCurr15MinLprs = 25;
+    aturPerfData->adslAturPerfCurr15MinESs = 30;
+    aturPerfData->adslAturPerfCurr1DayTimeElapsed = 40;
+    aturPerfData->adslAturPerfCurr1DayLofs = 50;
+    aturPerfData->adslAturPerfCurr1DayLoss = 60;
+    aturPerfData->adslAturPerfCurr1DayLprs = 65;
+    aturPerfData->adslAturPerfCurr1DayESs = 70;
+    aturPerfData->adslAturPerfPrev1DayMoniSecs = 80;
+    aturPerfData->adslAturPerfPrev1DayLofs = 85;
+    aturPerfData->adslAturPerfPrev1DayLoss = 90;
+    aturPerfData->adslAturPerfPrev1DayLprs = 95;
+    aturPerfData->adslAturPerfPrev1DayESs = 100;
+
+    return 0;
+}
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_access.h	2009-12-16 12:59:27.000000000 +0530
@@ -0,0 +1,165 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPerfDataTable_access.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) User-defined data structure for accessing
+ *                    adslAturPerfDataTable
+ *                 2) User-defined data access functions for data in table
+ *                    adslAturPerfDataTable
+ *                 3) Column accessors functions
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+/* ===========================================================================
+ * Revision History:
+ * subramani: Changed the return types for get_adslAturPerfValidIntervals,
+ * get_adslAturPerfInvalidIntervals and get_adslAturPerfPrev1DayMoniSecs
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+#ifndef ADSLATURPERFDATATABLE_ACCESS_H
+#define ADSLATURPERFDATATABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                           USER-DEFINED DATA TYPES
+ * ===========================================================================
+ */
+
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslAturPerfDataTable **/
+#define AdslPerfTimeElapsed u_int32
+#define PerfCurrentCount u_int32
+#define AdslPerfCurrDayCount u_int32
+#define AdslPerfPrevDayCount u_int32
+
+typedef struct aturPerfDataEntry
+{
+   int          ifIndex;
+   u_int32          adslAturPerfLofs;
+   u_int32          adslAturPerfLoss;
+   u_int32          adslAturPerfLprs;
+   u_int32          adslAturPerfESs;
+   int              adslAturPerfValidIntervals;
+   int              adslAturPerfInvalidIntervals;
+   AdslPerfTimeElapsed  adslAturPerfCurr15MinTimeElapsed;
+   PerfCurrentCount     adslAturPerfCurr15MinLofs;
+   PerfCurrentCount     adslAturPerfCurr15MinLoss;
+   PerfCurrentCount     adslAturPerfCurr15MinLprs;
+   PerfCurrentCount     adslAturPerfCurr15MinESs;
+   AdslPerfTimeElapsed  adslAturPerfCurr1DayTimeElapsed;
+   AdslPerfCurrDayCount adslAturPerfCurr1DayLofs;
+   AdslPerfCurrDayCount adslAturPerfCurr1DayLoss;
+   AdslPerfCurrDayCount adslAturPerfCurr1DayLprs;
+   AdslPerfCurrDayCount adslAturPerfCurr1DayESs;
+   int              adslAturPerfPrev1DayMoniSecs;
+   AdslPerfPrevDayCount adslAturPerfPrev1DayLofs;
+   AdslPerfPrevDayCount adslAturPerfPrev1DayLoss;
+   AdslPerfPrevDayCount adslAturPerfPrev1DayLprs;
+   AdslPerfPrevDayCount adslAturPerfPrev1DayESs;
+   u_int32          flags;
+} aturPerfDataEntry;
+#endif
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+/* User-defined data access functions for data in table adslAturPerfDataTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAturPerfDataTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAturPerfDataTable_get_next_data_point;
+
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+u_int32  *
+get_adslAturPerfDataLoss(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+
+int *
+get_adslAturPerfIntervalData(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+u_int32  *
+get_adslAturPerfDataStats(void *data_context, size_t * ret_len,
+			unsigned int var);
+#else
+u_int32  *get_adslAturPerfLofs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfLoss(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfLprs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfESs(void *data_context, size_t * ret_len);
+int     *get_adslAturPerfValidIntervals(void *data_context, size_t * ret_len);
+int     *get_adslAturPerfInvalidIntervals(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturPerfCurr15MinTimeElapsed(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturPerfCurr15MinLofs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfCurr15MinLoss(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfCurr15MinLprs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfCurr15MinESs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfCurr1DayTimeElapsed(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturPerfCurr1DayLofs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfCurr1DayLoss(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfCurr1DayLprs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfCurr1DayESs(void *data_context, size_t * ret_len);
+int     *get_adslAturPerfPrev1DayMoniSecs(void *data_context,
+            size_t * ret_len);
+u_int32  *get_adslAturPerfPrev1DayLofs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfPrev1DayLoss(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfPrev1DayLprs(void *data_context, size_t * ret_len);
+u_int32  *get_adslAturPerfPrev1DayESs(void *data_context, size_t * ret_len);
+#endif
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAturPerfDataTable(int Fd2,int GET_adsl_ATUR_PERF_DATA2,
+        void *atucPerfDataValue);
+#endif
+
+#endif                          /* ADSLATURPERFDATATABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_columns.h	2009-12-16 12:59:27.000000000 +0530
@@ -0,0 +1,74 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPerfDataTable_columns.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) column number definitions for table adslAturPerfDataTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATURPERFDATATABLE_COLUMNS_H
+#define ADSLATURPERFDATATABLE_COLUMNS_H
+
+/* column number definitions for table adslAturPerfDataTable */
+#define COLUMN_ADSLATURPERFLOFS     1
+#define COLUMN_ADSLATURPERFLOSS     2
+#define COLUMN_ADSLATURPERFLPRS     3
+#define COLUMN_ADSLATURPERFESS      4
+#define COLUMN_ADSLATURPERFVALIDINTERVALS       5
+#define COLUMN_ADSLATURPERFINVALIDINTERVALS     6
+#define COLUMN_ADSLATURPERFCURR15MINTIMEELAPSED 7
+#define COLUMN_ADSLATURPERFCURR15MINLOFS        8
+#define COLUMN_ADSLATURPERFCURR15MINLOSS        9
+#define COLUMN_ADSLATURPERFCURR15MINLPRS        10
+#define COLUMN_ADSLATURPERFCURR15MINESS         11
+#define COLUMN_ADSLATURPERFCURR1DAYTIMEELAPSED  12
+#define COLUMN_ADSLATURPERFCURR1DAYLOFS         13
+#define COLUMN_ADSLATURPERFCURR1DAYLOSS         14
+#define COLUMN_ADSLATURPERFCURR1DAYLPRS         15
+#define COLUMN_ADSLATURPERFCURR1DAYESS          16
+#define COLUMN_ADSLATURPERFPREV1DAYMONISECS     17
+#define COLUMN_ADSLATURPERFPREV1DAYLOFS         18
+#define COLUMN_ADSLATURPERFPREV1DAYLOSS         19
+#define COLUMN_ADSLATURPERFPREV1DAYLPRS         20
+#define COLUMN_ADSLATURPERFPREV1DAYESS          21
+
+#endif                          /* ADSLATURPERFDATATABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPerfDataTable/adslAturPerfDataTable_enums.h	2009-12-16 12:59:27.000000000 +0530
@@ -0,0 +1,80 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPerfDataTable_enums.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) adslAturPerfDataTable constants
+ *                 2) adslAturPerfDataTable Flags
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATURPERFDATATABLE_ENUMS_H
+#define ADSLATURPERFDATATABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAturPerfDataTable constants */
+#define GET_ADSL_ATUR_PERF_DATA 40
+
+/* adslAturPerfDataTable Flags */
+#define ATUR_PERF_LOFS_FLAG     0x1 /* BIT 0th position */
+#define ATUR_PERF_LOSS_FLAG     0x2 /* BIT 1 */
+#define ATUR_PERF_LPR_FLAG      0x4 /* BIT 2 */
+#define ATUR_PERF_ESS_FLAG      0x8 /* BIT 3 */
+#define ATUR_PERF_VALID_INTVLS_FLAG 0x10 /* BIT 4 */
+#define ATUR_PERF_INVALID_INTVLS_FLAG   0x20 /* BIT 5 */
+#define ATUR_PERF_CURR_15MIN_TIME_ELAPSED_FLAG  0x40 /* BIT 6 */
+#define ATUR_PERF_CURR_15MIN_LOFS_FLAG      0x80     /* BIT 7 */
+#define ATUR_PERF_CURR_15MIN_LOSS_FLAG      0x100 /* BIT 8 */
+#define ATUR_PERF_CURR_15MIN_LPR_FLAG       0x200 /* BIT 9 */
+#define ATUR_PERF_CURR_15MIN_ESS_FLAG       0x400   /* BIT 10 */
+#define ATUR_PERF_CURR_1DAY_TIME_ELAPSED_FLAG 0x800 /* BIT 11 */
+#define ATUR_PERF_CURR_1DAY_LOFS_FLAG       0x1000 /* BIT 12 */
+#define ATUR_PERF_CURR_1DAY_LOSS_FLAG       0x2000 /* BIT 13 */
+#define ATUR_PERF_CURR_1DAY_LPR_FLAG        0x4000 /* BIT 14 */
+#define ATUR_PERF_CURR_1DAY_ESS_FLAG        0x8000 /* BIT 15 */
+#define ATUR_PERF_PREV_1DAY_MON_SEC_FLAG    0x10000 /* BIT 16 */
+#define ATUR_PERF_PREV_1DAY_LOFS_FLAG       0x20000 /* BIT 17 */
+#define ATUR_PERF_PREV_1DAY_LOSS_FLAG       0x40000 /* BIT 18 */
+#define ATUR_PERF_PREV_1DAY_LPR_FLAG        0x80000 /* BIT 19 */
+#define ATUR_PERF_PREV_1DAY_ESS_FLAG        0x100000 /* BIT 20 */
+#endif
+
+#endif                          /* ADSLATURPERFDATATABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable.c open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable.c	2009-12-16 12:59:27.000000000 +0530
@@ -0,0 +1,378 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPhysTable.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Initializing the adslAturPhysTable module
+ *                 2) Handling requests for the adslAturPhysTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Changes made to data types of SnrMgn,status and outputPwr
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+ /*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslAturPhysTable.h"
+#include "adslAturPhysTable_access.h"
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+/** Initialize the adslAturPhysTable table by defining its contents and how
+    it's structured */
+void
+initialize_table_adslAturPhysTable(void)
+{
+    static oid      adslAturPhysTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 3 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler = netsnmp_create_handler_registration("adslAturPhysTable",
+                                                     adslAturPhysTable_handler,
+                                                     adslAturPhysTable_oid,
+                                                     OID_LENGTH
+                                                     (adslAturPhysTable_oid),
+                                                     HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_adslAturPhysTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 8;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point = adslAturPhysTable_get_first_data_point;
+    iinfo->get_next_data_point = adslAturPhysTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context = adslAturPhysTable_context_convert_function;
+    iinfo->free_data_context = adslAturPhysTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslAturPhysTable_loop_free;
+    iinfo->free_loop_context_at_end = adslAturPhysTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslAturPhysTable",
+                "Registering table adslAturPhysTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslAturPhysTable module */
+void
+init_adslAturPhysTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslAturPhysTable();
+}
+
+/** handles requests for the adslAturPhysTable table, if anything else needs
+    to be done */
+int
+adslAturPhysTable_handler(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+
+	    case COLUMN_ADSLATURINVSERIALNUMBER:
+	    case COLUMN_ADSLATURINVVENDORID:
+	    case COLUMN_ADSLATURINVVERSIONNUMBER:
+                {
+                    char           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturInvData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                      (const u_char *) retval, retval_len);
+                }
+		break;
+
+            case COLUMN_ADSLATURCURRSNRMGN:
+            case COLUMN_ADSLATURCURROUTPUTPWR:
+                {
+                    int           *retval;
+                    size_t        retval_len = 0;
+                    retval =
+                        get_adslAturCurrSNROutputPwr(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCURRATN:
+            case COLUMN_ADSLATURCURRATTAINABLERATE:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturCurrAtnAttainableRate(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+#else
+            case COLUMN_ADSLATURINVSERIALNUMBER:
+                {
+                    char           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturInvSerialNumber(data_context,
+                                                    &retval_len);
+                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURINVVENDORID:
+                {
+                    char           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturInvVendorID(data_context,
+                                        &retval_len);
+                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURINVVERSIONNUMBER:
+                {
+                    char           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturInvVersionNumber(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCURRSNRMGN:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturCurrSnrMgn(data_context,
+                                        &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCURRATN:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturCurrAtn(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCURROUTPUTPWR:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturCurrOutputPwr(data_context,
+                                                  &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURCURRATTAINABLERATE:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturCurrAttainableRate(data_context,
+                                                       &retval_len);
+                    snmp_set_var_typed_value(var, ASN_GAUGE,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+#endif
+
+            case COLUMN_ADSLATURCURRSTATUS:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturCurrStatus(data_context,
+                                            &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            default:
+                /** We shouldn't get here */
+               snmp_log(LOG_ERR,
+                 "adslAturPhysTable_handler: unknown column\n");
+            }
+            break;
+
+
+        default:
+            snmp_log(LOG_ERR,
+                     "adslAturPhysTable_handler: unsupported mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable.h open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable.h	2009-12-16 12:59:27.000000000 +0530
@@ -0,0 +1,78 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPhysTable.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) Include files
+ *                 2) Init Function proto-types
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLATURPHYSTABLE_H
+#define ADSLATURPHYSTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+
+/* other required module components */
+config_require(adslMIB/adslAturPhysTable/adslAturPhysTable_access)
+
+/* column number definitions for table adslAturPhysTable */
+#include "adslAturPhysTable_columns.h"
+
+/* enum definions */
+#include "adslAturPhysTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+    /* function declarations */
+void    init_adslAturPhysTable(void);
+void    initialize_table_adslAturPhysTable(void);
+Netsnmp_Node_Handler adslAturPhysTable_handler;
+
+#endif /** ADSLATURPHYSTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_access.c open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_access.c	2009-12-16 12:59:27.000000000 +0530
@@ -0,0 +1,583 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPhysTable_access.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Getting the data context pointer & loop context pointer
+ *                 2) User-defined data access functions (per column) for data
+ *                    in table adslAturPhysTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Changes made to return types of get_adslAturCurrSnrMgn
+ * get_adslAturCurrStatus and get_adslAturCurrOutputPwr
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#include "adslAturPhysTable_access.h"
+#include "adslAturPhysTable_enums.h"
+
+/* column number definitions for table adslAturPhysTable */
+#include "adslAturPhysTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                           GLOBAL DEFINITIONS
+ * ===========================================================================
+ */
+// *** Global variable definitions
+static long long_ret;
+static char sys_info[32]= "";
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+/** returns the first data point within the adslAturPhysTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslAturPhysTable_get_first_data_point(void **my_loop_context,
+                                       void **my_data_context,
+                                       netsnmp_variable_list *
+                                       put_index_data,
+                                       netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-First: adslAturPhysTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslAturPhysTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslAturPhysTable_get_next_data_point(void **my_loop_context,
+                                      void **my_data_context,
+                                      netsnmp_variable_list *
+                                      put_index_data,
+                                      netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-Next: adslAturPhysTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+/*
+ * User-defined data access functions (per column) for data in table
+ * adslAturPhysTable */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+#if defined(HAVE_OPTIMIZED_CODE)
+
+char  *
+get_adslAturInvData(void *data_context, size_t * ret_len,
+			unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslAturPhysEntry adslAturPhysStruct;
+  memset(&adslAturPhysStruct,0,sizeof(adslAturPhysEntry));
+  memset(sys_info,0,sizeof(sys_info));
+  adslAturPhysStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+        case COLUMN_ADSLATURINVSERIALNUMBER:
+	   flags = ATUR_PHY_SER_NUM_FLAG;
+	   break;
+
+        case COLUMN_ADSLATURINVVENDORID:
+	   flags = ATUR_PHY_VENDOR_ID_FLAG;
+	   break;
+
+        case COLUMN_ADSLATURINVVERSIONNUMBER:
+	   flags = ATUR_PHY_VER_NUM_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  	}
+  
+    SET_FLAG(&adslAturPhysStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#else
+    get_adslAturPhysTable1(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturPhysStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PhysTable: GET- %x CMV fail\n", flags));
+    
+    switch (flags)  {
+	    
+	case ATUR_PHY_SER_NUM_FLAG:
+    	   strcpy(sys_info,adslAturPhysStruct.serial_no);
+    	   *ret_len = strlen(adslAturPhysStruct.serial_no);
+	   break;
+
+	case ATUR_PHY_VENDOR_ID_FLAG:
+    	   strcpy(sys_info,adslAturPhysStruct.vendor_id.vendor_id);
+           *ret_len = strlen(adslAturPhysStruct.vendor_id.vendor_id);
+	   break;
+
+	case ATUR_PHY_VER_NUM_FLAG:
+    	   strcpy(sys_info,adslAturPhysStruct.version_no);
+           *ret_len = strlen(adslAturPhysStruct.version_no);
+	   break;
+	   
+        default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+           return NULL;
+	}
+
+    CLR_FLAG(&adslAturPhysStruct.flags, flags);
+    return (char *) sys_info;
+}
+
+
+int *
+get_adslAturCurrSNROutputPwr(void *data_context, size_t *ret_len,
+				unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslAturPhysEntry adslAturPhysStruct;
+  memset(&adslAturPhysStruct,0,sizeof(adslAturPhysEntry));
+  adslAturPhysStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+        case COLUMN_ADSLATURCURRSNRMGN:
+	   flags = ATUR_SNRMGN_FLAG;
+	   break;
+
+        case COLUMN_ADSLATURCURROUTPUTPWR:
+	   flags = ATUR_CURR_OUT_PWR_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  	}
+  
+    SET_FLAG(&adslAturPhysStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#else
+    get_adslAturPhysTable1(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturPhysStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PhysTable: GET- %x CMV fail\n", flags));
+    
+    switch (flags)  {
+	    
+	case ATUR_SNRMGN_FLAG:
+    	   long_ret = adslAturPhysStruct.SnrMgn;
+	   break;
+
+	case ATUR_CURR_OUT_PWR_FLAG:
+    	   long_ret = adslAturPhysStruct.outputPwr;
+	   break;
+
+        default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+           return NULL;
+	}
+
+    CLR_FLAG(&adslAturPhysStruct.flags, flags);
+    *ret_len = sizeof(int);
+    return (int *) &long_ret;
+}
+
+
+u_int32 *
+get_adslAturCurrAtnAttainableRate(void *data_context, size_t *ret_len,
+				unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslAturPhysEntry adslAturPhysStruct;
+  memset(&adslAturPhysStruct,0,sizeof(adslAturPhysEntry));
+  adslAturPhysStruct.ifIndex= (*(int *)data_context);
+
+  switch (var) {
+
+        case COLUMN_ADSLATURCURRATN:
+	   flags = ATUR_ATTN_FLAG;
+	   break;
+
+        case COLUMN_ADSLATURCURRATTAINABLERATE:
+	   flags = ATUR_CURR_ATTR_FLAG;
+	   break;
+
+     	default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     	   return NULL;
+  	}
+  
+    SET_FLAG(&adslAturPhysStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#else
+    get_adslAturPhysTable1(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturPhysStruct.flags, flags) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "PhysTable: GET- %x CMV fail\n", flags));
+    
+    switch (flags)  {
+	    
+	case ATUR_ATTN_FLAG:
+    	   long_ret = adslAturPhysStruct.Attn;
+	   break;
+
+	case ATUR_CURR_ATTR_FLAG:
+    	   long_ret = adslAturPhysStruct.attainableRate;
+	   break;
+
+        default:
+     	   DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+           return NULL;
+	}
+
+    CLR_FLAG(&adslAturPhysStruct.flags, flags);
+    *ret_len = sizeof(u_int32);
+    return (u_int32 *) &long_ret;
+}
+
+#else
+
+/** XXX: return a data pointer to the data for the adslAturInvSerialNumber
+ *  column and set ret_len to its proper size in bytes. */
+char           *
+get_adslAturInvSerialNumber(void *data_context, size_t * ret_len)
+{
+    struct adslAturPhysEntry adslAturPhysStruct;
+
+    memset(&adslAturPhysStruct,0,sizeof(adslAturPhysEntry));
+    adslAturPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturPhysStruct.flags,ATUR_PHY_SER_NUM_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PHY, (void *)&adslAturPhysStruct);
+#else
+    get_adslAturPhysTable1(Fd, GET_ADSL_ATUR_PHY,(void *)&adslAturPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturPhysStruct.flags, ATUR_PHY_SER_NUM_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "SerNum CMV fail\n"));
+
+    CLR_FLAG(&adslAturPhysStruct.flags, ATUR_PHY_SER_NUM_FLAG);
+    memset(sys_info,0,sizeof(sys_info));
+    strcpy(sys_info,adslAturPhysStruct.serial_no);
+
+    *ret_len = strlen(adslAturPhysStruct.serial_no);
+    return (char *) sys_info;
+
+}
+
+/** XXX: return a data pointer to the data for the adslAturInvVendorID column
+ *  and set ret_len to its proper size in bytes. */
+char           *
+get_adslAturInvVendorID(void *data_context, size_t * ret_len)
+{
+    struct adslAturPhysEntry adslAturPhysStruct;
+
+    memset(&adslAturPhysStruct,0,sizeof(adslAturPhysEntry));
+    adslAturPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturPhysStruct.flags,ATUR_PHY_VENDOR_ID_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#else
+    get_adslAturPhysTable1(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturPhysStruct.flags, ATUR_PHY_VENDOR_ID_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "VendorID CMV fail\n"));
+	    
+    CLR_FLAG(&adslAturPhysStruct.flags, ATUR_PHY_VENDOR_ID_FLAG);
+    memset(sys_info,0,sizeof(sys_info));
+    strcpy(sys_info,adslAturPhysStruct.vendor_id.vendor_id);
+
+    *ret_len = strlen(adslAturPhysStruct.vendor_id.vendor_id);
+    return (char *) sys_info;
+
+}
+
+/** XXX: return a data pointer to the data for the adslAturInvVersionNumber
+ *  column and set ret_len to its proper size in bytes. */
+char           *
+get_adslAturInvVersionNumber(void *data_context, size_t * ret_len)
+{
+    struct adslAturPhysEntry adslAturPhysStruct;
+
+    memset(&adslAturPhysStruct,0,sizeof(adslAturPhysEntry));
+    adslAturPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturPhysStruct.flags,ATUR_PHY_VER_NUM_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#else
+    get_adslAturPhysTable1(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturPhysStruct.flags, ATUR_PHY_VER_NUM_FLAG) == 0)
+      DEBUGMSGTL(("adslMIB-ATUR", "VersionNum CMV fail\n"));
+	    
+    CLR_FLAG(&adslAturPhysStruct.flags, ATUR_PHY_VER_NUM_FLAG);
+    memset(sys_info,0,sizeof(sys_info));
+    strcpy(sys_info,adslAturPhysStruct.version_no);
+
+    *ret_len = strlen(adslAturPhysStruct.version_no);
+    return (char *) sys_info;
+
+}
+
+/** XXX: return a data pointer to the data for the adslAturCurrSnrMgn column
+ *  and set ret_len to its proper size in bytes. */
+int           *
+get_adslAturCurrSnrMgn(void *data_context, size_t * ret_len)
+{
+    struct adslAturPhysEntry adslAturPhysStruct;
+
+    memset(&adslAturPhysStruct,0,sizeof(adslAturPhysEntry));
+    adslAturPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturPhysStruct.flags, ATUR_SNRMGN_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#else
+    get_adslAturPhysTable1(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturPhysStruct.flags, ATUR_SNRMGN_FLAG) == 0)
+       DEBUGMSGTL(("adslMIB-ATUR", "CurrSNRMGN CMV fail\n"));
+
+    CLR_FLAG(&adslAturPhysStruct.flags, ATUR_SNRMGN_FLAG);
+    long_ret = adslAturPhysStruct.SnrMgn;
+    *ret_len = sizeof(adslAturPhysStruct.SnrMgn);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturCurrAtn column and
+ *  set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturCurrAtn(void *data_context, size_t * ret_len)
+{
+    struct adslAturPhysEntry adslAturPhysStruct;
+
+    memset(&adslAturPhysStruct,0,sizeof(adslAturPhysEntry));
+    adslAturPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturPhysStruct.flags, ATUR_ATTN_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#else
+    get_adslAturPhysTable1(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturPhysStruct.flags, ATUR_ATTN_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "CurrAttn CMV fail\n"));
+
+    CLR_FLAG(&adslAturPhysStruct.flags, ATUR_ATTN_FLAG);
+    long_ret = adslAturPhysStruct.Attn;
+    *ret_len = sizeof(adslAturPhysStruct.Attn);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturCurrOutputPwr column
+ *  and set ret_len to its proper size in bytes. */
+int           *
+get_adslAturCurrOutputPwr(void *data_context, size_t * ret_len)
+{
+    struct adslAturPhysEntry adslAturPhysStruct;
+
+    memset(&adslAturPhysStruct,0,sizeof(adslAturPhysEntry));
+    adslAturPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturPhysStruct.flags, ATUR_CURR_OUT_PWR_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#else
+    get_adslAturPhysTable1(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturPhysStruct.flags, ATUR_CURR_OUT_PWR_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "CurrOutPwr CMV fail\n"));
+
+    CLR_FLAG(&adslAturPhysStruct.flags, ATUR_CURR_OUT_PWR_FLAG);
+    long_ret = adslAturPhysStruct.outputPwr;
+    *ret_len = sizeof(adslAturPhysStruct.outputPwr);
+    return (int *) &long_ret;
+}
+
+/** XXX: return a data pointer to the data for the adslAturCurrAttainableRate
+ *  column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturCurrAttainableRate(void *data_context, size_t * ret_len)
+{
+    struct adslAturPhysEntry adslAturPhysStruct;
+
+    memset(&adslAturPhysStruct,0,sizeof(adslAturPhysEntry));
+    adslAturPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturPhysStruct.flags, ATUR_CURR_ATTR_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#else
+    get_adslAturPhysTable1(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturPhysStruct.flags, ATUR_CURR_ATTR_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "CurrAttrRate CMV fail\n"));
+
+    CLR_FLAG(&adslAturPhysStruct.flags, ATUR_CURR_ATTR_FLAG);
+    long_ret = adslAturPhysStruct.attainableRate;
+    *ret_len = sizeof(adslAturPhysStruct.attainableRate);
+    return (u_int32 *) &long_ret;
+}
+
+#endif
+
+/** XXX: return a data pointer to the data for the adslAturCurrStatus column
+ *  and set ret_len to its proper size in bytes. */
+u_int32           *
+get_adslAturCurrStatus(void *data_context, size_t * ret_len)
+{
+    struct adslAturPhysEntry adslAturPhysStruct;
+
+    memset(&adslAturPhysStruct,0,sizeof(adslAturPhysEntry));
+    adslAturPhysStruct.ifIndex= (*(int *)data_context);
+    SET_FLAG(&adslAturPhysStruct.flags, ATUR_CURR_STAT_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#else
+    get_adslAturPhysTable1(Fd, GET_ADSL_ATUR_PHY,(void *) &adslAturPhysStruct);
+#endif
+    if (IS_FLAG_SET(&adslAturPhysStruct.flags, ATUR_CURR_STAT_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-ATUR", "CurrStatus CMV fail\n"));
+
+    CLR_FLAG(&adslAturPhysStruct.flags, ATUR_CURR_STAT_FLAG);
+    long_ret = adslAturPhysStruct.status;
+    *ret_len = sizeof(adslAturPhysStruct.status);
+    return (u_int32 *) &long_ret;
+}
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAturPhysTable1(int Fd2, int GET_adsl_ATUR_PHY2,
+            void *adslAturPhysTable)
+{
+    struct adslAturPhysEntry *adslAturPhysValue;
+    unsigned char temp[12]="Get Value";
+    adslAturPhysValue = (adslAturPhysEntry *)adslAturPhysTable;
+    strcpy(adslAturPhysValue->serial_no,temp);
+    strcpy(adslAturPhysValue->vendor_id.vendor_id,temp);
+    strcpy(adslAturPhysValue->version_no,temp);
+    adslAturPhysValue->SnrMgn = 300;
+    adslAturPhysValue->Attn = 310;
+    adslAturPhysValue->status = ADSLATURCURRSTATUS_LOSSOFSIGNAL;
+    adslAturPhysValue->outputPwr=10;
+    adslAturPhysValue->attainableRate=10;
+
+    return 0;
+}
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_access.h open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_access.h	2009-12-16 12:59:27.000000000 +0530
@@ -0,0 +1,132 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPhysTable_access.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) User-defined data structure for accessing AturPhysTable
+ *                 2) User-defined data access functions for data in table
+ *                    adslAturPhysTable
+ *                 3) Column accessors functions
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Changes made to return types of get_adslAturCurrSnrMgn
+ * get_adslAturCurrStatus and get_adslAturCurrOutputPwr
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+#ifndef ADSLATURPHYSTABLE_ACCESS_H
+#define ADSLATURPHYSTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                           USER-DEFINED DATA TYPES
+ * ===========================================================================
+ */
+
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing AturPhysTable **/
+typedef struct adslAturPhysEntry {
+    int ifIndex;
+    char serial_no[32];
+    char vendor_id[16];
+    char version_no[16];
+    int SnrMgn;
+    u_int32 Attn;
+    u_int32 status;
+    int outputPwr;
+    u_int32 attainableRate;
+    u_char flags;
+} adslAturPhysEntry;
+#endif
+
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+/** User-defined data access functions for data in table adslAturPhysTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslAturPhysTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslAturPhysTable_get_next_data_point;
+
+
+/** column accessors */
+#if defined(HAVE_OPTIMIZED_CODE)
+
+char  *
+get_adslAturInvData(void *data_context, size_t * ret_len,
+			unsigned int var);
+
+int *
+get_adslAturCurrSNROutputPwr(void *data_context, size_t *ret_len,
+				unsigned int var);
+
+u_int32 *
+get_adslAturCurrAtnAttainableRate(void *data_context, size_t *ret_len,
+				unsigned int var);
+#else
+char    *get_adslAturInvSerialNumber(void *data_context, size_t * ret_len);
+char    *get_adslAturInvVendorID(void *data_context, size_t * ret_len);
+char    *get_adslAturInvVersionNumber(void *data_context, size_t * ret_len);
+int    *get_adslAturCurrSnrMgn(void *data_context, size_t * ret_len);
+u_int32 *get_adslAturCurrAtn(void *data_context, size_t * ret_len);
+int    *get_adslAturCurrOutputPwr(void *data_context, size_t * ret_len);
+u_int32 *get_adslAturCurrAttainableRate(void *data_context, size_t * ret_len);
+
+#endif
+
+u_int32 *get_adslAturCurrStatus(void *data_context, size_t * ret_len);
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslAturPhysTable1(int Fd2, int GET_adsl_ATUR_PHY2,
+                        void *adslAturPhysTable);
+#endif
+
+#endif                          /* ADSLATURPHYSTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_columns.h	2009-12-16 12:59:28.000000000 +0530
@@ -0,0 +1,61 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPhysTable_columns.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) column number definitions for table adslAturPhysTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLATURPHYSTABLE_COLUMNS_H
+#define ADSLATURPHYSTABLE_COLUMNS_H
+
+/* column number definitions for table adslAturPhysTable */
+#define COLUMN_ADSLATURINVSERIALNUMBER      1
+#define COLUMN_ADSLATURINVVENDORID          2
+#define COLUMN_ADSLATURINVVERSIONNUMBER     3
+#define COLUMN_ADSLATURCURRSNRMGN           4
+#define COLUMN_ADSLATURCURRATN              5
+#define COLUMN_ADSLATURCURRSTATUS           6
+#define COLUMN_ADSLATURCURROUTPUTPWR        7
+#define COLUMN_ADSLATURCURRATTAINABLERATE   8
+
+#endif                          /* ADSLATURPHYSTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslAturPhysTable/adslAturPhysTable_enums.h	2009-12-16 12:59:28.000000000 +0530
@@ -0,0 +1,75 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslAturPhysTable_enums.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) adslAturPhysTable constants
+ *                 2) adslAturPhysTable Flags
+ *                 3) enums for column adslAturCurrStatus
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLATURPHYSTABLE_ENUMS_H
+#define ADSLATURPHYSTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslAturPhysTable constants */
+#define GET_ADSL_ATUR_PHY       10
+
+/* adslAturPhysTable Flags */
+#define ATUR_PHY_SER_NUM_FLAG       0x1     /* BIT 0th position */
+#define ATUR_PHY_VENDOR_ID_FLAG     0x2     /* BIT 1 */
+#define ATUR_PHY_VER_NUM_FLAG       0x4     /* BIT 2 */
+#define ATUR_SNRMGN_FLAG   	    0x8     /* BIT 3 */
+#define ATUR_ATTN_FLAG              0x10    /* BIT 4 */
+#define ATUR_CURR_STAT_FLAG         0x20    /* BIT 5 */
+#define ATUR_CURR_OUT_PWR_FLAG      0x40    /* BIT 6 */
+#define ATUR_CURR_ATTR_FLAG         0x80    /* BIT 7 */
+#endif
+
+/* enums for column adslAturCurrStatus */
+#define ADSLATURCURRSTATUS_NODEFECT             0
+#define ADSLATURCURRSTATUS_LOSSOFFRAMING        1
+#define ADSLATURCURRSTATUS_LOSSOFSIGNAL         2
+#define ADSLATURCURRSTATUS_LOSSOFPOWER          3
+#define ADSLATURCURRSTATUS_LOSSOFSIGNALQUALITY  4
+
+#endif                          /* ADSLATURPHYSTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslExtTraps/adslExtTraps.c open_snmp/agent/mibgroup/adslMIB/adslExtTraps/adslExtTraps.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslExtTraps/adslExtTraps.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslExtTraps/adslExtTraps.c	2009-12-16 12:59:28.000000000 +0530
@@ -0,0 +1,282 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslExtTraps.c
+ * Author       : Subramani
+ * Date         : 11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Initializing the adslExtTraps module
+ *                 2) Handling adslExtTraps generation
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/** adslTraps.c
+ *  This file shows how to send a notification from inside the
+ *  agent.  In this case we simply sleep for 30 seconds and send it,
+ *  then we sleep for 30 more and send it again.
+ *  We do this through the snmp_alarm mechanisms. Normally, you would
+ *  probably want to do something to test whether or not to send an alarm,
+ *  based on the type of mib module you were creating.
+ *
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/** This files contains Trap includes & prototypes **/
+#include "adslExtTraps.h"
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+#ifndef ENABLE_DRIVER_CALL
+    int ext_stub_ioctl(int fd, int cmd, unsigned short *flags);
+#endif
+
+/** Our Trap initialization routine **/
+void
+init_adslExtTraps(void)
+{
+    DEBUGMSGTL(("adsl-Ext-Traps",
+                "initializing (setting callback alarm)\n"));
+    snmp_alarm_register(30,     /* seconds */
+                        SA_REPEAT,      /* repeat (every 30 seconds). */
+                        send_adsl_ext_notification,      /* our callback */
+                        NULL    /* no callback data needed */
+        );
+}
+
+/** here we send an SNMP trap to all trapsinks **/
+void
+send_adsl_ext_notification(unsigned int clientreg, void *clientarg)
+{
+    unsigned short flags = 0;
+    unsigned short test_flags = 0;
+    size_t notification_oid_len = 0;
+
+    /* Assign our notification OID to the snmpTrapOID.0 object */
+    oid objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
+    size_t objid_snmptrap_len = OID_LENGTH(objid_snmptrap);
+
+    /* define the OIDs for the notification we're going to send */
+
+    /* ADSL-LINE-EXT-MIB::AtucFailedFastRThreshTrap */
+    oid AtucFailedFastRThreshTrap_oid[] =
+    				{ SNMP_ADSL_ATUC_EXT_TRAPS_PREFIX,0,1 };
+
+    /* ADSL-LINE-EXT-MIB::adslAtucThreshold15MinSesL */
+    oid AtucThreshold15MinSesL_oid[] = { SNMP_ADSL_ATUC_EXT_TRAPS_PREFIX,0,2 };
+
+    /* ADSL-LINE-EXT-MIB::adslAtucThreshold15MinUasL */
+    oid AtucThreshold15MinUasL_oid[]  = { SNMP_ADSL_ATUC_EXT_TRAPS_PREFIX,0,3 };
+
+    /* ADSL-LINE-EXT-MIB::adslAturThreshold15MinSesL */
+    oid AturThreshold15MinSesL_oid[] = { SNMP_ADSL_ATUR_EXT_TRAPS_PREFIX,0,1 };
+
+    /* ADSL-LINE-EXT-MIB::adslAturThreshold15MinUasL */
+    oid AturThreshold15MinUasL_oid[] = { SNMP_ADSL_ATUR_EXT_TRAPS_PREFIX,0,2 };
+
+    netsnmp_variable_list *notification_vars = NULL;
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return;
+    }
+    ioctl(Fd, ADSL_ATUR_EXT_TRAPS, &flags);
+#else
+    ext_stub_ioctl(3, ADSL_ATUR_EXT_TRAPS, &flags);
+#endif
+
+     /* Check which flags have been Set */
+     /* Generate Traps for those flags */
+     /* Do I need to clear the flag_bit once I send out a Trap ?? */
+
+      test_flags = 256;
+      while (test_flags) {
+      notification_vars = NULL;
+      switch (IS_FLAG_SET(&flags, test_flags)) {
+        case  ATUC_15MIN_FAILED_FASTR_TRAP_FLAG:
+        {
+               notification_oid_len = OID_LENGTH(AtucFailedFastRThreshTrap_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AtucFailedFastRThreshTrap_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Ext-Traps",
+                    	"sending AtucFailedFastRThreshTrap \n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUC_15MIN_FAILED_FASTR_TRAP_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUC_15MIN_SESL_TRAP_FLAG:
+        {
+                notification_oid_len = OID_LENGTH(AtucThreshold15MinSesL_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AtucThreshold15MinSesL_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Ext-Traps",
+                   	 "sending AtucThreshold15MinSesL trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUC_15MIN_SESL_TRAP_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUC_15MIN_UASL_TRAP_FLAG:
+        {
+                 notification_oid_len = OID_LENGTH(AtucThreshold15MinUasL_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AtucThreshold15MinUasL_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Ext-Traps",
+                    	"sending AtucThreshold15MinUasL trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUC_15MIN_UASL_TRAP_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUR_15MIN_SESL_TRAP_FLAG:
+        {
+                 notification_oid_len = OID_LENGTH(AturThreshold15MinSesL_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AturThreshold15MinSesL_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Ext-Traps",
+                    	"sending AturThreshold15MinSesL trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUR_15MIN_SESL_TRAP_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUR_15MIN_UASL_TRAP_FLAG:
+        {
+                 notification_oid_len = OID_LENGTH(AturThreshold15MinUasL_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AturThreshold15MinUasL_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Ext-Traps",
+                    	"sending AturThreshold15MinUasL trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUR_15MIN_UASL_TRAP_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        default:
+                break;
+     }
+     test_flags = (test_flags >> 1);
+
+#ifdef ENABLE_DRIVER_CALL
+    close(Fd);
+#endif
+     }
+}
+
+#ifndef ENABLE_DRIVER_CALL
+/* This function is part of the MEI driver which Bing Tao's team is supposed to
+   provide us with. This function basically checks & compares the threshold
+   values and on exceeding the configured threshold, sets the appropriate
+   Threshold flag
+*/
+
+int ext_stub_ioctl(int fd, int cmd, unsigned short *flags)
+{
+
+ switch (cmd) {
+    case ADSL_ATUR_EXT_TRAPS:
+            SET_FLAG(flags, ATUC_15MIN_FAILED_FASTR_TRAP_FLAG);
+            SET_FLAG(flags, ATUC_15MIN_SESL_TRAP_FLAG);
+            SET_FLAG(flags, ATUR_15MIN_UASL_TRAP_FLAG);
+            //CLR_FLAG(flags, ATUR_RATE_CHANGE_FLAG);
+        break;
+    }
+    return 0;
+}
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslExtTraps/adslExtTraps.h open_snmp/agent/mibgroup/adslMIB/adslExtTraps/adslExtTraps.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslExtTraps/adslExtTraps.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslExtTraps/adslExtTraps.h	2009-12-16 12:59:28.000000000 +0530
@@ -0,0 +1,90 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslExtTraps.h
+ * Author       : Subramani
+ * Date         : 11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) Include files
+ *                 2) Definitions
+ *                 2) Init Function proto-types
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+#ifndef ADSLEXTTRAPS_H
+#define ADSLEXTTRAPS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <adslMIB/adslTable_access.h>
+/*
+ * ===========================================================================
+ *                           DEFINITIONS
+ * ===========================================================================
+ */
+
+#ifdef STUB_IOCTL
+/* adslAturExtTrap constants */
+#define ADSL_ATUR_EXT_TRAPS		240
+
+
+/* adslAturExtTraps */
+#define ATUC_15MIN_FAILED_FASTR_TRAP_FLAG 	0X1 /* BIT 0th position */
+#define ATUC_15MIN_SESL_TRAP_FLAG		 0X2 /* BIT 1 */
+#define ATUC_15MIN_UASL_TRAP_FLAG		 0X4 /* BIT 2 */
+#define ATUR_15MIN_SESL_TRAP_FLAG		 0X8 /* BIT 3 */
+#define ATUR_15MIN_UASL_TRAP_FLAG		 0X10 /* BIT 4 */
+
+#endif
+
+/* Constants */
+#define SNMP_ADSL_EXT_TRAPS_PREFIX          1,3,6,1,2,1,10,94,3,1,24
+#define SNMP_ADSL_ATUC_EXT_TRAPS_PREFIX     SNMP_ADSL_EXT_TRAPS_PREFIX,1
+#define SNMP_ADSL_ATUR_EXT_TRAPS_PREFIX     SNMP_ADSL_EXT_TRAPS_PREFIX,2
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+/* prototypes for the Traps */
+void init_adslExtTraps(void);
+SNMPAlarmCallback send_adsl_ext_notification;
+
+#endif /* ADSLTRAPS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable.c open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable.c	2009-12-16 12:59:28.000000000 +0530
@@ -0,0 +1,2086 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslLineAlarmConfProfileTable.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) Initializing the adslLineAlarmConfProfileTable module
+ *               2) Handling requests for the adslLineAlarmConfProfileTable
+ *                  table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Changed data types as per Rfc-2662
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslLineAlarmConfProfileTable.h"
+#include "adslLineAlarmConfProfileTable_checkfns.h"
+#include "adslLineAlarmConfProfileTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+static netsnmp_oid_stash_node *undoStorage = NULL;
+static netsnmp_oid_stash_node *commitStorage = NULL;
+
+/*
+ * ===========================================================================
+ *                          LOCAL DEFINITIONS
+ * ===========================================================================
+*/
+
+struct undoInfo {
+    void           *ptr;
+    size_t          len;
+};
+
+struct commitInfo {
+    void           *data_context;
+    int             have_committed;
+    int             new_row;
+};
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+void
+adslLineAlarmConfProfileTable_free_undoInfo(void *vptr)
+{
+    struct undoInfo *ui = vptr;
+    if (!ui)
+        return;
+    SNMP_FREE(ui->ptr);
+    SNMP_FREE(ui);
+}
+
+
+/** Initialize the adslLineAlarmConfProfileTable table by defining its
+    contents and how it's structured */
+void
+initialize_table_adslLineAlarmConfProfileTable(void)
+{
+    static oid      adslLineAlarmConfProfileTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 15 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler =
+        netsnmp_create_handler_registration
+        ("adslLineAlarmConfProfileTable",
+         adslLineAlarmConfProfileTable_handler,
+         adslLineAlarmConfProfileTable_oid,
+         OID_LENGTH(adslLineAlarmConfProfileTable_oid),
+         HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,
+                 "malloc failed in\
+                 initialize_table_adslLineAlarmConfProfileTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_OCTET_STR,
+                                    /** index:adslLineAlarmConfProfileName */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 2;
+    table_info->max_column = 20;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point =
+        adslLineAlarmConfProfileTable_get_first_data_point;
+    iinfo->get_next_data_point =
+        adslLineAlarmConfProfileTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context =
+        adslLineAlarmConfProfileTable_context_convert_function;
+    iinfo->free_data_context = adslLineAlarmConfProfileTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslLineAlarmConfProfileTable_loop_free;
+    iinfo->free_loop_context_at_end =
+        adslLineAlarmConfProfileTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslLineAlarmConfProfileTable",\
+                 "Registering table adslLineAlarmConfProfileTable as a table\
+                 iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslLineAlarmConfProfileTable module */
+void
+init_adslLineAlarmConfProfileTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslLineAlarmConfProfileTable();
+}
+
+/** handles requests for the adslLineAlarmConfProfileTable table, if
+    anything else needs to be done */
+int
+adslLineAlarmConfProfileTable_handler(netsnmp_mib_handler *handler,
+                                      netsnmp_handler_registration
+                                      *reginfo,
+                                      netsnmp_agent_request_info *reqinfo,
+                                      netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+    oid            *suffix;
+    size_t          suffix_len;
+
+    /** column and row index encoded portion */
+    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
+    suffix_len = requests->requestvb->name_length -
+        (reginfo->rootoid_len + 1);
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+        case MODE_SET_RESERVE1:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+            break;
+
+        default:               /* == the other SET modes */
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+            break;
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+            case COLUMN_ADSLATUCTHRESH15MINLOFS:
+            case COLUMN_ADSLATUCTHRESH15MINLOSS:
+            case COLUMN_ADSLATUCTHRESH15MINESS:
+            case COLUMN_ADSLATURTHRESH15MINLOFS:
+            case COLUMN_ADSLATURTHRESH15MINLOSS:
+            case COLUMN_ADSLATURTHRESH15MINLPRS:
+            case COLUMN_ADSLATURTHRESH15MINESS:
+            case COLUMN_ADSLATUCINITFAILURETRAPENABLE:
+            case COLUMN_ADSLLINEALARMCONFPROFILEROWSTATUS:
+		 {
+		    int 	*retval;
+		    size_t	retval_len=0;
+		    retval = 
+			get_adslThresh15MinVal(data_context, &retval_len, table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+		 }
+		 break;
+
+            case COLUMN_ADSLATUCTHRESHFASTRATEUP:
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP:
+            case COLUMN_ADSLATUCTHRESHFASTRATEDOWN:
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN:
+            case COLUMN_ADSLATURTHRESHFASTRATEUP:
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEUP:
+            case COLUMN_ADSLATURTHRESHFASTRATEDOWN:
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+			get_adslThreshChanVal(data_context, &retval_len, table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+		 }
+		 break;
+#else
+            case COLUMN_ADSLATUCTHRESH15MINLOFS:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucThresh15MinLofs(data_context,
+                                                    &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCTHRESH15MINLOSS:
+                {
+                     int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucThresh15MinLoss(data_context,
+                                                    &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+
+            case COLUMN_ADSLATUCTHRESH15MINESS:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucThresh15MinESs(data_context,
+                                                   &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCTHRESHFASTRATEUP:
+                {
+                     u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucThreshFastRateUp(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucThreshInterleaveRateUp(data_context,
+                                                           &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCTHRESHFASTRATEDOWN:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucThreshFastRateDown(data_context,
+                                                       &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucThreshInterleaveRateDown(data_context,
+                                                             &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATUCINITFAILURETRAPENABLE:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAtucInitFailureTrapEnable(data_context,
+                                                          &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURTHRESH15MINLOFS:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturThresh15MinLofs(data_context,
+                                                    &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURTHRESH15MINLOSS:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturThresh15MinLoss(data_context,
+                                                    &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURTHRESH15MINLPRS:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturThresh15MinLprs(data_context,
+                                                    &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURTHRESH15MINESS:
+                {
+                     int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturThresh15MinESs(data_context,
+                                                   &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURTHRESHFASTRATEUP:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturThreshFastRateUp(data_context,
+                                                     &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEUP:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturThreshInterleaveRateUp(data_context,
+                                                           &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURTHRESHFASTRATEDOWN:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturThreshFastRateDown(data_context,
+                                                       &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslAturThreshInterleaveRateDown(data_context,
+                                                             &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_ADSLLINEALARMCONFPROFILEROWSTATUS:
+                {
+                      int           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_adslLineAlarmConfProfileRowStatus(data_context,
+                                                              &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+#endif
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                    "adslLineAlarmConfProfileTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+
+            if (!ci) {
+                    /** create the commit storage info */
+                ci = SNMP_MALLOC_STRUCT(commitInfo);
+                if (!data_context) {
+                    ci->data_context =
+                        adslLineAlarmConfProfileTable_create_data_context
+                        (table_info->indexes);
+                    ci->new_row = 1;
+                } else {
+                    ci->data_context = data_context;
+                }
+                netsnmp_oid_stash_add_data(&commitStorage,
+                                           suffix + 1, suffix_len - 1, ci);
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+            case COLUMN_ADSLATUCTHRESH15MINLOFS:
+            case COLUMN_ADSLATUCTHRESH15MINLOSS:
+            case COLUMN_ADSLATUCTHRESH15MINESS:
+            case COLUMN_ADSLATURTHRESH15MINLOFS:
+            case COLUMN_ADSLATURTHRESH15MINLOSS:
+            case COLUMN_ADSLATURTHRESH15MINLPRS:
+            case COLUMN_ADSLATURTHRESH15MINESS:
+            case COLUMN_ADSLATUCINITFAILURETRAPENABLE:
+                {
+                    int            *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+			get_adslThresh15MinVal(ci->data_context, &retval_len, table_info->colnum);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+		    if (table_info->colnum == COLUMN_ADSLATUCINITFAILURETRAPENABLE)   {
+                      ret =
+                        check_adslAtucInitFailureTrapEnable(request->
+                                                            requestvb->
+                                                            type,
+                                                            (long *)
+                                                            request->
+                                                            requestvb->val.
+                                                            string,
+                                                            request->
+                                                            requestvb->
+                                                            val_len,
+                                                            (long *) retval,
+                                                            retval_len);
+		    }
+		    else { 
+			
+                    	ret =
+                       	  check_adslThresh15MinVal(request->requestvb->
+                                                      type,
+                                                      (long *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len, (long *) retval,
+                                                      retval_len);
+		    }
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+		
+            case COLUMN_ADSLATUCTHRESHFASTRATEUP:
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP:
+            case COLUMN_ADSLATUCTHRESHFASTRATEDOWN:
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN:
+            case COLUMN_ADSLATURTHRESHFASTRATEUP:
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEUP:
+            case COLUMN_ADSLATURTHRESHFASTRATEDOWN:
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+			get_adslThreshChanVal(ci->data_context, &retval_len, table_info->colnum);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslThreshChanVal(request->requestvb->
+                                                       type,
+                                                       (u_long *) request->
+                                                       requestvb->val.
+                                                       string,
+                                                       request->requestvb->
+                                                       val_len, (long *) retval,
+                                                       retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+		break;
+#else
+            case COLUMN_ADSLATUCTHRESH15MINLOFS:
+                {
+                     int           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAtucThresh15MinLofs(ci->data_context,
+                                                    &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAtucThresh15MinLofs(request->requestvb->
+                                                      type,
+                                                      (long *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len, (long *) retval,
+                                                      retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESH15MINLOSS:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAtucThresh15MinLoss(ci->data_context,
+                                                    &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAtucThresh15MinLoss(request->requestvb->
+                                                      type,
+                                                      (long *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len, (long *) retval,
+                                                      retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+
+            case COLUMN_ADSLATUCTHRESH15MINESS:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAtucThresh15MinESs(ci->data_context,
+                                                   &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAtucThresh15MinESs(request->requestvb->
+                                                     type,
+                                                     (long *) request->
+                                                     requestvb->val.string,
+                                                     request->requestvb->
+                                                     val_len, (long *) retval,
+                                                     retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHFASTRATEUP:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAtucThreshFastRateUp(ci->data_context,
+                                                     &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAtucThreshFastRateUp(request->requestvb->
+                                                       type,
+                                                       (u_long *) request->
+                                                       requestvb->val.
+                                                       string,
+                                                       request->requestvb->
+                                                       val_len, (long *) retval,
+                                                       retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAtucThreshInterleaveRateUp(ci->
+                                                           data_context,
+                                                           &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAtucThreshInterleaveRateUp(request->
+                                                             requestvb->
+                                                             type,
+                                                             (u_long *)
+                                                             request->
+                                                             requestvb->
+                                                             val.string,
+                                                             request->
+                                                             requestvb->
+                                                             val_len,
+                                                            (long *) retval,
+                                                             retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHFASTRATEDOWN:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAtucThreshFastRateDown(ci->data_context,
+                                                       &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAtucThreshFastRateDown(request->
+                                                         requestvb->type,
+                                                         (u_long *)
+                                                         request->
+                                                         requestvb->val.
+                                                         string,
+                                                         request->
+                                                         requestvb->
+                                                         val_len,(long *)retval,
+                                                         retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAtucThreshInterleaveRateDown(ci->
+                                                             data_context,
+                                                             &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAtucThreshInterleaveRateDown(request->
+                                                               requestvb->
+                                                               type,
+                                                               (u_long *)
+                                                               request->
+                                                               requestvb->
+                                                               val.string,
+                                                               request->
+                                                               requestvb->
+                                                               val_len,
+                                                               (long *)retval,
+                                                               retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATUCINITFAILURETRAPENABLE:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAtucInitFailureTrapEnable(ci->data_context,
+                                                          &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAtucInitFailureTrapEnable(request->
+                                                            requestvb->
+                                                            type,
+                                                            (long *)
+                                                            request->
+                                                            requestvb->val.
+                                                            string,
+                                                            request->
+                                                            requestvb->
+                                                            val_len,
+                                                            (long *) retval,
+                                                            retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINLOFS:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAturThresh15MinLofs(ci->data_context,
+                                                    &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAturThresh15MinLofs(request->requestvb->
+                                                      type,
+                                                      (long *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len, (long *) retval,
+                                                      retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINLOSS:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAturThresh15MinLoss(ci->data_context,
+                                                    &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAturThresh15MinLoss(request->requestvb->
+                                                      type,
+                                                      (long *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len, (long *)retval,
+                                                      retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINLPRS:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAturThresh15MinLprs(ci->data_context,
+                                                    &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAturThresh15MinLprs(request->requestvb->
+                                                      type,
+                                                      (long *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len, (long *)retval,
+                                                      retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINESS:
+                {
+                   int           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAturThresh15MinESs(ci->data_context,
+                                                   &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAturThresh15MinESs(request->requestvb->
+                                                     type,
+                                                     (long *) request->
+                                                     requestvb->val.string,
+                                                     request->requestvb->
+                                                     val_len, (long *)retval,
+                                                     retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHFASTRATEUP:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAturThreshFastRateUp(ci->data_context,
+                                                     &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAturThreshFastRateUp(request->requestvb->
+                                                       type,
+                                                       (u_long *) request->
+                                                       requestvb->val.
+                                                       string,
+                                                       request->requestvb->
+                                                       val_len, (long *)retval,
+                                                       retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEUP:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAturThreshInterleaveRateUp(ci->
+                                                           data_context,
+                                                           &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAturThreshInterleaveRateUp(request->
+                                                             requestvb->
+                                                             type,
+                                                             (u_long *)
+                                                             request->
+                                                             requestvb->
+                                                             val.string,
+                                                             request->
+                                                             requestvb->
+                                                             val_len,
+                                                             (long *)retval,
+                                                             retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHFASTRATEDOWN:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAturThreshFastRateDown(ci->data_context,
+                                                       &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAturThreshFastRateDown(request->
+                                                         requestvb->type,
+                                                         (u_long *)
+                                                         request->
+                                                         requestvb->val.
+                                                         string,
+                                                         request->
+                                                         requestvb->
+                                                        val_len, (long *)retval,
+                                                         retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN:
+                {
+                    u_int32         *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslAturThreshInterleaveRateDown(ci->
+                                                             data_context,
+                                                             &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_adslAturThreshInterleaveRateDown(request->
+                                                               requestvb->
+                                                               type,
+                                                               (u_long *)
+                                                               request->
+                                                               requestvb->
+                                                               val.string,
+                                                               request->
+                                                               requestvb->
+                                                               val_len,
+                                                               (long *)retval,
+                                                               retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+          // *** This part is commented since rowstatus can't
+          // *** be modified by the user for static profiles
+
+       /*     case COLUMN_ADSLLINEALARMCONFPROFILEROWSTATUS:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    //** first, get the old value
+                    retval =
+                        get_adslLineAlarmConfProfileRowStatus(ci->
+                                                              data_context,
+                                                              &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    //** check the new value, possibly against the
+                    //    older value for a valid state transition
+                    ret =
+                        check_adslLineAlarmConfProfileRowStatus(request->
+                                                                requestvb->
+                                                                type,
+                                                                (long *)
+                                                                request->
+                                                                requestvb->
+                                                                val.string,
+                                                                request->
+                                                                requestvb->
+                                                                val_len,
+                                                                retval,
+                                                                retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineAlarmConfProfileTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        //** remember information for undo purposes later
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+          */
+#endif
+            default:
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_ERR_NOTWRITABLE);
+                break;
+            }
+            break;
+
+        case MODE_SET_UNDO:
+            /** save a variable copy */
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+            case COLUMN_ADSLATUCTHRESH15MINLOFS:
+            case COLUMN_ADSLATUCTHRESH15MINLOSS:
+            case COLUMN_ADSLATUCTHRESH15MINESS:
+            case COLUMN_ADSLATURTHRESH15MINLOFS:
+            case COLUMN_ADSLATURTHRESH15MINLOSS:
+            case COLUMN_ADSLATURTHRESH15MINLPRS:
+            case COLUMN_ADSLATURTHRESH15MINESS:
+            case COLUMN_ADSLATUCINITFAILURETRAPENABLE:
+                {
+                    int  retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                    	set_adslThresh15MinVal(ci->data_context,
+                                       ui->ptr, ui->len, table_info->colnum);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+		break;
+
+            case COLUMN_ADSLATUCTHRESHFASTRATEUP:
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP:
+            case COLUMN_ADSLATUCTHRESHFASTRATEDOWN:
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN:
+            case COLUMN_ADSLATURTHRESHFASTRATEUP:
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEUP:
+            case COLUMN_ADSLATURTHRESHFASTRATEDOWN:
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN:
+                {
+                    int  retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                    	set_adslThreshChanVal(ci->data_context,
+                                       ui->ptr, ui->len, table_info->colnum);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+#else
+            case COLUMN_ADSLATUCTHRESH15MINLOFS:
+                {
+                    int             ret;
+                    ret = set_adslAtucThresh15MinLofs(ci->data_context,
+                                                      (long *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESH15MINLOSS:
+                {
+                    int             ret;
+                    ret = set_adslAtucThresh15MinLoss(ci->data_context,
+                                                      (long *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESH15MINESS:
+                {
+                    int             ret;
+                    ret = set_adslAtucThresh15MinESs(ci->data_context,
+                                                     (long *) request->
+                                                     requestvb->val.string,
+                                                     request->requestvb->
+                                                     val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHFASTRATEUP:
+                {
+                    int             ret;
+                    ret = set_adslAtucThreshFastRateUp(ci->data_context,
+                                                       (u_long *) request->
+                                                       requestvb->val.
+                                                       string,
+                                                       request->requestvb->
+                                                       val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP:
+                {
+                    int             ret;
+                    ret =
+                        set_adslAtucThreshInterleaveRateUp(ci->
+                                                           data_context,
+                                                           (u_long *)
+                                                           request->
+                                                           requestvb->val.
+                                                           string,
+                                                           request->
+                                                           requestvb->
+                                                           val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHFASTRATEDOWN:
+                {
+                    int             ret;
+                    ret = set_adslAtucThreshFastRateDown(ci->data_context,
+                                                         (u_long *)
+                                                         request->
+                                                         requestvb->val.
+                                                         string,
+                                                         request->
+                                                         requestvb->
+                                                         val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN:
+                {
+                    int             ret;
+                    ret =
+                        set_adslAtucThreshInterleaveRateDown(ci->
+                                                             data_context,
+                                                             (u_long *)
+                                                             request->
+                                                             requestvb->
+                                                             val.string,
+                                                             request->
+                                                             requestvb->
+                                                             val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCINITFAILURETRAPENABLE:
+                {
+                    int             ret;
+                    ret =
+                        set_adslAtucInitFailureTrapEnable(ci->data_context,
+                                                          (long *)
+                                                          request->
+                                                          requestvb->val.
+                                                          string,
+                                                          request->
+                                                          requestvb->
+                                                          val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINLOFS:
+                {
+                    int             ret;
+                    ret = set_adslAturThresh15MinLofs(ci->data_context,
+                                                      (long *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINLOSS:
+                {
+                    int             ret;
+                    ret = set_adslAturThresh15MinLoss(ci->data_context,
+                                                      (long *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINLPRS:
+                {
+                    int             ret;
+                    ret = set_adslAturThresh15MinLprs(ci->data_context,
+                                                      (long *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINESS:
+                {
+                    int             ret;
+                    ret = set_adslAturThresh15MinESs(ci->data_context,
+                                                     (long *) request->
+                                                     requestvb->val.string,
+                                                     request->requestvb->
+                                                     val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHFASTRATEUP:
+                {
+                    int             ret;
+                    ret = set_adslAturThreshFastRateUp(ci->data_context,
+                                                       (u_long *) request->
+                                                       requestvb->val.
+                                                       string,
+                                                       request->requestvb->
+                                                       val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEUP:
+                {
+                    int             ret;
+                    ret =
+                        set_adslAturThreshInterleaveRateUp(ci->
+                                                           data_context,
+                                                           (u_long *)
+                                                           request->
+                                                           requestvb->val.
+                                                           string,
+                                                           request->
+                                                           requestvb->
+                                                           val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHFASTRATEDOWN:
+                {
+                    int             ret;
+                    ret = set_adslAturThreshFastRateDown(ci->data_context,
+                                                         (u_long *)
+                                                         request->
+                                                         requestvb->val.
+                                                         string,
+                                                         request->
+                                                         requestvb->
+                                                         val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN:
+                {
+                    int             ret;
+                    ret =
+                        set_adslAturThreshInterleaveRateDown(ci->
+                                                             data_context,
+                                                             (u_long *)
+                                                             request->
+                                                             requestvb->
+                                                             val.string,
+                                                             request->
+                                                             requestvb->
+                                                             val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+        // *** This part is commented since rowstatus can't
+      // *** be modified by the user for static profiles
+
+        /*    case COLUMN_ADSLLINEALARMCONFPROFILEROWSTATUS:
+                {
+                    int             ret;
+                    ret =
+                        set_adslLineAlarmConfProfileRowStatus(ci->
+                                                              data_context,
+                                                              (long *)
+                                                              request->
+                                                              requestvb->
+                                                              val.string,
+                                                              request->
+                                                              requestvb->
+                                                              val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                    if (*request->requestvb->val.integer == RS_DESTROY) {
+                        ci->new_row = -1;
+                    }
+                }
+                break;
+        */
+#endif
+	default:
+            netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_ERR_NOTWRITABLE);
+                break;
+		
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            if (!ci->have_committed) {
+                    /** do this once per row only */
+                adslLineAlarmConfProfileTable_commit_row(&ci->data_context,
+                                                         ci->new_row);
+                ci->have_committed = 1;
+            }
+            break;
+
+        case MODE_SET_ACTION:
+             /** save a variable copy */
+            switch (table_info->colnum) {
+#if defined(HAVE_OPTIMIZED_CODE)
+            case COLUMN_ADSLATUCTHRESH15MINLOFS:
+            case COLUMN_ADSLATUCTHRESH15MINLOSS:
+            case COLUMN_ADSLATUCTHRESH15MINESS:
+            case COLUMN_ADSLATURTHRESH15MINLOFS:
+            case COLUMN_ADSLATURTHRESH15MINLOSS:
+            case COLUMN_ADSLATURTHRESH15MINLPRS:
+            case COLUMN_ADSLATURTHRESH15MINESS:
+            case COLUMN_ADSLATUCINITFAILURETRAPENABLE:
+                {
+                    int   ret;
+                    ret = set_adslThresh15MinVal(ci->data_context,
+                                            (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len, table_info->colnum);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+		break;
+
+            case COLUMN_ADSLATUCTHRESHFASTRATEUP:
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP:
+            case COLUMN_ADSLATUCTHRESHFASTRATEDOWN:
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN:
+            case COLUMN_ADSLATURTHRESHFASTRATEUP:
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEUP:
+            case COLUMN_ADSLATURTHRESHFASTRATEDOWN:
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN:
+                {
+                    int  ret;
+                    ret = set_adslThreshChanVal(ci->data_context,
+                                            (long *) request->requestvb->val.string,
+                                             request->requestvb->val_len, table_info->colnum);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+#else
+            case COLUMN_ADSLATUCTHRESH15MINLOFS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAtucThresh15MinLofs(ci->data_context,
+                                                    ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESH15MINLOSS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAtucThresh15MinLoss(ci->data_context,
+                                                    ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+
+            case COLUMN_ADSLATUCTHRESH15MINESS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAtucThresh15MinESs(ci->data_context,
+                                                   ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHFASTRATEUP:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAtucThreshFastRateUp(ci->data_context,
+                                                     ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAtucThreshInterleaveRateUp(ci->
+                                                           data_context,
+                                                           ui->ptr,
+                                                           ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHFASTRATEDOWN:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAtucThreshFastRateDown(ci->data_context,
+                                                       ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAtucThreshInterleaveRateDown(ci->
+                                                             data_context,
+                                                             ui->ptr,
+                                                             ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATUCINITFAILURETRAPENABLE:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAtucInitFailureTrapEnable(ci->data_context,
+                                                          ui->ptr,
+                                                          ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINLOFS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAturThresh15MinLofs(ci->data_context,
+                                                    ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINLOSS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAturThresh15MinLoss(ci->data_context,
+                                                    ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINLPRS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAturThresh15MinLprs(ci->data_context,
+                                                    ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESH15MINESS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAturThresh15MinESs(ci->data_context,
+                                                   ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHFASTRATEUP:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAturThreshFastRateUp(ci->data_context,
+                                                     ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEUP:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAturThreshInterleaveRateUp(ci->
+                                                           data_context,
+                                                           ui->ptr,
+                                                           ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHFASTRATEDOWN:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAturThreshFastRateDown(ci->data_context,
+                                                       ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslAturThreshInterleaveRateDown(ci->
+                                                             data_context,
+                                                             ui->ptr,
+                                                             ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+      // *** This part is commented since rowstatus can't
+      // *** be modified by the user for static profiles
+
+     /*       case COLUMN_ADSLLINEALARMCONFPROFILEROWSTATUS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslLineAlarmConfProfileRowStatus(ci->
+                                                              data_context,
+                                                              ui->ptr,
+                                                              ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+      */
+#endif
+            default:
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_ERR_NOTWRITABLE);
+                break;
+            }
+            break;
+
+        case MODE_SET_FREE:
+            break;
+
+        default:
+            snmp_log(LOG_ERR,\
+                "adslLineAlarmConfProfileTable_handler: unsupported mode\n");
+        }
+    }
+
+    /** clean up after all requset processing has ended */
+    switch (reqinfo->mode) {
+    case MODE_SET_UNDO:
+    case MODE_SET_FREE:
+    case MODE_SET_COMMIT:
+        /** clear out the undo cache */
+        netsnmp_oid_stash_free(&undoStorage,
+                               adslLineAlarmConfProfileTable_free_undoInfo);
+        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable.h open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable.h	2009-12-16 12:59:28.000000000 +0530
@@ -0,0 +1,84 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslLineAlarmConfProfileTable.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                1) Include files
+ *                2) Init Function proto-types for adslLineAlarmConfProfileTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLLINEALARMCONFPROFILETABLE_H
+#define ADSLLINEALARMCONFPROFILETABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/** other required module components */
+config_require(adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_access)
+    config_require(adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns)
+
+/* column number definitions for table adslLineAlarmConfProfileTable */
+#include "adslLineAlarmConfProfileTable_columns.h"
+
+/* enum definions */
+#include "adslLineAlarmConfProfileTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/* function declarations */
+void            init_adslLineAlarmConfProfileTable(void);
+void            initialize_table_adslLineAlarmConfProfileTable(void);
+Netsnmp_Node_Handler adslLineAlarmConfProfileTable_handler;
+
+
+
+
+#endif /** ADSLLINEALARMCONFPROFILETABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_access.c open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_access.c	2009-12-16 12:59:28.000000000 +0530
@@ -0,0 +1,1745 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslLineAlarmConfProfileTable_access.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                  1) Getting the data context pointer & loop context
+ *                  pointer
+ *                  2) User-defined data access functions (per column) for data
+ *                  in table adslLineAlarmConfProfileTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Changed data types as per Rfc-2662
+ *
+ * $Log$
+ * ===========================================================================
+ */
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslLineAlarmConfProfileTable_access.h"
+#include "adslLineAlarmConfProfileTable_enums.h"
+
+/* column number definitions for table adslLineAlarmConfProfileTable */
+#include "adslLineAlarmConfProfileTable_columns.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+*/
+
+/* Global decalarations */
+static u_int32 long_ret;
+
+#ifndef ENABLE_DRIVER_CALL
+
+static int     adslAtucTh15MinLofs=10;
+static int     adslAtucTh15MinLoss=20;
+static int     adslAtucTh15MinESs=30;
+static u_int32     adslAtucThFastRateUp=40;
+static u_int32     adslAtucThInterleaveRateUp=50;
+static u_int32     adslAtucThFastRateDown=60;
+static u_int32     adslAtucThInterleaveRateDown=70;
+static int     adslAtucInitFailTrapEnable=80;
+static int     adslAturTh15MinLofs=90;
+static int     adslAturTh15MinLoss=100;
+static int     adslAturTh15MinLprs=110;
+static int     adslAturTh15MinESs=120;
+static u_int32     adslAturThFastRateUp=130;
+static u_int32     adslAturThInterleaveRateUp=140;
+static u_int32     adslAturThFastRateDown=150;
+static u_int32     adslAturThInterleaveRateDown=160;
+static int     adslLineAlarmConfProfRowStatus=1;
+
+#endif
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** returns the first data point within the adslLineAlarmConfProfileTable
+    table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslLineAlarmConfProfileTable_get_first_data_point(void **my_loop_context,
+                                                   void **my_data_context,
+                                                   netsnmp_variable_list *
+                                                   put_index_data,
+                                                   netsnmp_iterator_info
+                                                   *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-First: adslLineAlarmConfProfileTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslAlarmTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslLineAlarmConfProfileTable_get_first_data_point
+   , but my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslLineAlarmConfProfileTable_get_next_data_point(void **my_loop_context,
+                                                  void **my_data_context,
+                                                  netsnmp_variable_list *
+                                                  put_index_data,
+                                                  netsnmp_iterator_info
+                                                  *mydata)
+{
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-Next: adslLineAlarmConfProfileTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslAlarmTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** Create a data_context for non-existent rows that SETs are performed on.
+ *  return a void * pointer which will be passed to subsequent get_XXX
+ *  and set_XXX functions for data retrival and modification during
+ *  this SET request.
+ *
+ *  The indexs are encoded (in order) into the index_data pointer if it
+ *  would be helpful to use that information.
+ */
+void           *
+adslLineAlarmConfProfileTable_create_data_context(netsnmp_variable_list *
+                                                  index_data)
+{
+    return NULL;            /* XXX: you likely want to return a real pointer */
+}
+
+/** If the implemented set_* functions don't operate directly on the
+   real-live data (which is actually recommended), then this function
+   can be used to take a given my_data_context pointer and "commit" it
+   to whereever the modified data needs to be put back to.  For
+   example, if this was a routing table you could publish the modified
+   routes back into the kernel at this point.
+
+   new_or_del will be set to 1 if new, or -1 if it should be deleted
+   or 0 if it is just a modification of an existing row.
+
+   If you free the data yourself, make sure to *my_data_context = NULL */
+int
+adslLineAlarmConfProfileTable_commit_row(void **my_data_context,
+                                         int new_or_del)
+{
+    /** Add any necessary commit code here */
+    /*
+     */
+
+    /*
+     * return no errors.  And there shouldn't be any!!!  Ever!!!  You
+     * should have checked the values long before this.
+     */
+    return SNMP_ERR_NOERROR;
+}
+
+
+/*
+ * User-defined data access functions (per column) for data in table
+ adslLineAlarmConfProfileTable
+ */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+/** XXX: return a data pointer to the data for the adslAtucThresh15MinLofs
+     column and set ret_len to its proper size in bytes. */
+#if defined(HAVE_OPTIMIZED_CODE)
+int *
+get_adslThresh15MinVal(void *data_context, size_t *ret_len, unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+  memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+  strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+          (char *)data_context);
+  switch (var)
+  {
+     case COLUMN_ADSLATUCTHRESH15MINLOFS:
+    	flags = ATUC_THRESH_15MIN_LOFS_FLAG;
+	break;
+	
+     case COLUMN_ADSLATUCTHRESH15MINLOSS:
+    	flags =  ATUC_THRESH_15MIN_LOSS_FLAG;
+	break;
+	
+     case COLUMN_ADSLATUCTHRESH15MINESS:
+    	flags =  ATUC_THRESH_15MIN_ESS_FLAG;
+	break;
+
+     case COLUMN_ADSLATURTHRESH15MINLOFS:
+        flags = ATUR_THRESH_15MIN_LOFS_FLAG;
+	break;
+
+     case COLUMN_ADSLATURTHRESH15MINLOSS:
+    	flags =  ATUR_THRESH_15MIN_LOSS_FLAG;
+	break;
+
+     case COLUMN_ADSLATURTHRESH15MINLPRS:
+    	flags =  ATUR_THRESH_15MIN_LPRS_FLAG;
+	break;
+
+     case COLUMN_ADSLATURTHRESH15MINESS:
+    	flags =  ATUR_THRESH_15MIN_ESS_FLAG;
+	break;
+
+     case COLUMN_ADSLATUCINITFAILURETRAPENABLE:
+    	flags =  ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG;
+	break;
+	
+     case COLUMN_ADSLLINEALARMCONFPROFILEROWSTATUS:
+    	flags = LINE_ALARM_CONF_PROFILE_ROWSTATUS_FLAG;
+	break;
+    
+     default:
+     DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     break;
+   }
+
+   SET_FLAG(&adslLineAlarmConfProStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags, flags) == 0) 
+     DEBUGMSGTL(("adslMIB-Line", "GET- %x CMV fail\n", flags));
+
+  switch (flags)
+  {
+     case ATUC_THRESH_15MIN_LOFS_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAtucThresh15MinLofs;
+	break;
+	
+     case ATUC_THRESH_15MIN_LOSS_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAtucThresh15MinLoss;
+	break;
+	
+     case ATUC_THRESH_15MIN_ESS_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAtucThresh15MinESs;
+	break;
+
+     case ATUR_THRESH_15MIN_LOFS_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAturThresh15MinLofs;
+	break;
+
+     case ATUR_THRESH_15MIN_LOSS_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAturThresh15MinLoss;
+	break;
+
+     case ATUR_THRESH_15MIN_LPRS_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAturThresh15MinLprs;
+	break;
+
+     case ATUR_THRESH_15MIN_ESS_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAturThresh15MinESs;
+	break;
+
+     case ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAtucInitFailureTrapEnable;
+	break;
+	
+     case LINE_ALARM_CONF_PROFILE_ROWSTATUS_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslLineAlarmConfProfileRowStatus;
+	break;
+    
+     default:
+     DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     return NULL;
+   }
+  
+   CLR_FLAG(&adslLineAlarmConfProStruct.flags, flags);
+   *ret_len = sizeof(int);
+   return (int *) &long_ret;
+}
+
+
+int 
+set_adslThresh15MinVal(void *data_context, long *val, 
+		size_t val_len, unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+  memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+  strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+          (char *)data_context);
+  switch (var)
+  {
+     case COLUMN_ADSLATUCTHRESH15MINLOFS:
+    	flags = ATUC_THRESH_15MIN_LOFS_FLAG;
+    	adslLineAlarmConfProStruct.adslAtucThresh15MinLofs = *val;
+	break;
+	
+     case COLUMN_ADSLATUCTHRESH15MINLOSS:
+    	flags =  ATUC_THRESH_15MIN_LOSS_FLAG;
+    	adslLineAlarmConfProStruct.adslAtucThresh15MinLoss = *val;
+	break;
+	
+     case COLUMN_ADSLATUCTHRESH15MINESS:
+    	flags =  ATUC_THRESH_15MIN_ESS_FLAG;
+    	adslLineAlarmConfProStruct.adslAtucThresh15MinESs = *val;
+	break;
+
+     case COLUMN_ADSLATURTHRESH15MINLOFS:
+        flags = ATUR_THRESH_15MIN_LOFS_FLAG;
+    	adslLineAlarmConfProStruct.adslAturThresh15MinLofs = *val;
+	break;
+
+     case COLUMN_ADSLATURTHRESH15MINLOSS:
+    	flags =  ATUR_THRESH_15MIN_LOSS_FLAG;
+    	adslLineAlarmConfProStruct.adslAturThresh15MinLoss = *val;
+	break;
+
+     case COLUMN_ADSLATURTHRESH15MINLPRS:
+    	flags =  ATUR_THRESH_15MIN_LPRS_FLAG;
+    	adslLineAlarmConfProStruct.adslAturThresh15MinLprs=*val;
+	break;
+
+     case COLUMN_ADSLATURTHRESH15MINESS:
+    	flags =  ATUR_THRESH_15MIN_ESS_FLAG;
+    	adslLineAlarmConfProStruct.adslAturThresh15MinESs=*val;
+	break;
+
+     case COLUMN_ADSLATUCINITFAILURETRAPENABLE:
+    	flags =  ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG;
+    	adslLineAlarmConfProStruct.adslAtucInitFailureTrapEnable=*val;
+	break;
+	
+     case COLUMN_ADSLLINEALARMCONFPROFILEROWSTATUS:
+    	return SNMP_ERR_NOTWRITABLE;      /** XXX: change if an error occurs */
+    
+     default:
+     DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     return SNMP_ERR_NOSUCHNAME;
+
+   }
+   SET_FLAG(&adslLineAlarmConfProStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags, flags) == 0) {
+      	DEBUGMSGTL(("adslMIB-Line", "SET- %d CMV fail\n", flags));
+     	CLR_FLAG(&adslLineAlarmConfProStruct.flags, flags);
+        return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags, flags);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+
+u_int32         *
+get_adslThreshChanVal(void *data_context, size_t *ret_len, unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+  memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+  strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+          (char *)data_context);
+  switch (var)
+  {
+     case COLUMN_ADSLATUCTHRESHFASTRATEUP:
+    	flags = ATUC_THRESH_FAST_RATEUP_FLAG;
+	break;
+	
+     case COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP:
+    	flags = ATUC_THRESH_INTERLEAVE_RATEUP_FLAG;
+	break;
+	
+     case COLUMN_ADSLATUCTHRESHFASTRATEDOWN:
+    	flags = ATUC_THRESH_FAST_RATEDOWN_FLAG;
+	break;
+
+     case COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN:
+        flags = ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG;
+	break;
+
+     case COLUMN_ADSLATURTHRESHFASTRATEUP:
+    	flags = ATUR_THRESH_FAST_RATEUP_FLAG;
+	break;
+
+     case COLUMN_ADSLATURTHRESHINTERLEAVERATEUP:
+    	flags = ATUR_THRESH_INTERLEAVE_RATEUP_FLAG;
+	break;
+
+     case COLUMN_ADSLATURTHRESHFASTRATEDOWN:
+    	flags = ATUR_THRESH_FAST_RATEDOWN_FLAG;
+	break;
+
+     case COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN:
+        flags = ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG;
+	break;
+	
+     default:
+     DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     return NULL;
+
+   }
+  
+   SET_FLAG(&adslLineAlarmConfProStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+   if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,flags) == 0) 
+      DEBUGMSGTL(("adslMIB-Line", "LineAlarmConfProf: GET- %x CMV fail\n", flags));
+
+  switch (flags)
+  {
+     case ATUC_THRESH_FAST_RATEUP_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAtucThreshFastRateUp;
+	break;
+	
+     case ATUC_THRESH_INTERLEAVE_RATEUP_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAtucThreshInterleaveRateUp;
+	break;
+	
+     case ATUC_THRESH_FAST_RATEDOWN_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAtucThreshFastRateDown;
+	break;
+
+     case ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAtucThreshInterleaveRateDown;
+	break;
+
+     case ATUR_THRESH_FAST_RATEUP_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAturThreshFastRateUp;
+	break;
+
+     case ATUR_THRESH_INTERLEAVE_RATEUP_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAturThreshInterleaveRateUp;
+	break;
+	
+     case ATUR_THRESH_FAST_RATEDOWN_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAturThreshFastRateDown;
+	break;
+
+     case ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG:
+    	long_ret = adslLineAlarmConfProStruct.adslAturThreshInterleaveRateDown;
+	break;
+
+     default:
+     DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     return NULL;
+   }
+
+   CLR_FLAG(&adslLineAlarmConfProStruct.flags, flags);
+   *ret_len = sizeof(u_int32);
+   return (u_int32 *) &long_ret;
+}
+
+
+int 
+set_adslThreshChanVal(void *data_context, long *val, 
+		size_t val_len, unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+  memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+  strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+          (char *)data_context);
+  switch (var)
+  {
+     case COLUMN_ADSLATUCTHRESHFASTRATEUP:
+    	flags = ATUC_THRESH_FAST_RATEUP_FLAG;
+    	adslLineAlarmConfProStruct.adslAtucThreshFastRateUp=*val;
+	break;
+	
+     case COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP:
+    	flags = ATUC_THRESH_INTERLEAVE_RATEUP_FLAG;
+    	adslLineAlarmConfProStruct.adslAtucThreshInterleaveRateUp=*val;
+	break;
+	
+     case COLUMN_ADSLATUCTHRESHFASTRATEDOWN:
+    	flags = ATUC_THRESH_FAST_RATEDOWN_FLAG;
+    	adslLineAlarmConfProStruct.adslAtucThreshFastRateDown=*val;
+	break;
+
+     case COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN:
+        flags = ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG;
+    	adslLineAlarmConfProStruct.adslAtucThreshInterleaveRateDown=*val;
+	break;
+
+     case COLUMN_ADSLATURTHRESHFASTRATEUP:
+    	flags = ATUR_THRESH_FAST_RATEUP_FLAG;
+    	adslLineAlarmConfProStruct.adslAturThreshFastRateUp=*val;
+	break;
+
+     case COLUMN_ADSLATURTHRESHINTERLEAVERATEUP:
+    	flags = ATUR_THRESH_INTERLEAVE_RATEUP_FLAG;
+    	adslLineAlarmConfProStruct.adslAturThreshInterleaveRateUp=*val;
+	break;
+
+     case COLUMN_ADSLATURTHRESHFASTRATEDOWN:
+    	flags = ATUR_THRESH_FAST_RATEDOWN_FLAG;
+    	adslLineAlarmConfProStruct.adslAturThreshFastRateDown=*val;
+	break;
+
+     case COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN:
+        flags = ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG;
+    	adslLineAlarmConfProStruct.adslAturThreshInterleaveRateDown=*val;
+	break;
+	
+     default:
+     DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+     return SNMP_ERR_NOSUCHNAME;
+
+   }
+   SET_FLAG(&adslLineAlarmConfProStruct.flags, flags);
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags, flags) == 0) {
+      	DEBUGMSGTL(("adslMIB-Line", "SET- %d CMV fail\n", flags));
+     	CLR_FLAG(&adslLineAlarmConfProStruct.flags, flags);
+        return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags, flags);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+#else
+
+int           *
+get_adslAtucThresh15MinLofs(void *data_context, size_t * ret_len)
+{
+
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+            (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+            (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+            ATUC_THRESH_15MIN_LOFS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-Line", "GET- AtucThresh15MinLOF CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_LOFS_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAtucThresh15MinLofs;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAtucThresh15MinLofs);
+    return (int *) &long_ret;
+}
+/** XXX: Set the value of the adslAtucThresh15MinLofs column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAtucThresh15MinLofs(void *data_context, long *val, size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+            (char *)data_context);
+    adslLineAlarmConfProStruct.adslAtucThresh15MinLofs=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+            (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+            ATUC_THRESH_15MIN_LOFS_FLAG) == 0) {
+      DEBUGMSGTL(("adslMIB-Line", "SET- AtucThresh15MinLOF CMV fail\n"));
+      CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_LOFS_FLAG);
+      return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_LOFS_FLAG);
+        return SNMP_ERR_NOERROR;
+   }
+
+}
+
+/** XXX: return a data pointer to the data for the adslAtucThresh15MinLoss
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAtucThresh15MinLoss(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUC_THRESH_15MIN_LOSS_FLAG) == 0) 
+      DEBUGMSGTL(("adslMIB-Line", "GET- AtucThresh15MinLOSS CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_LOSS_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAtucThresh15MinLoss;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAtucThresh15MinLoss);
+    return (int *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAtucThresh15MinLoss column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAtucThresh15MinLoss(void *data_context, long *val, size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+            (char *)data_context);
+    adslLineAlarmConfProStruct.adslAtucThresh15MinLoss=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+            ATUC_THRESH_15MIN_LOSS_FLAG) == 0) {
+      DEBUGMSGTL(("adslMIB-Line", "SET- AtucThresh15MinLOSS CMV fail\n"));
+      CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_LOSS_FLAG);
+      return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+      CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_LOSS_FLAG);
+      return SNMP_ERR_NOERROR;
+    }
+
+
+}
+
+/** XXX: return a data pointer to the data for the adslAtucThresh15MinESs column
+     and set ret_len to its proper size in bytes. */
+int           *
+get_adslAtucThresh15MinESs(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUC_THRESH_15MIN_ESS_FLAG) == 0) 
+      DEBUGMSGTL(("adslMIB-Line", "GET- AtucThresh15MinESS CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_ESS_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAtucThresh15MinESs;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAtucThresh15MinESs);
+    return (int *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAtucThresh15MinESs column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAtucThresh15MinESs(void *data_context, long *val, size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAtucThresh15MinESs=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+            ATUC_THRESH_15MIN_ESS_FLAG) == 0) {
+      DEBUGMSGTL(("adslMIB-Line", "SET- AtucThresh15MinESS CMV fail\n"));
+      CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_ESS_FLAG);
+      return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_15MIN_ESS_FLAG);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the adslAtucThreshFastRateUp
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucThreshFastRateUp(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_FAST_RATEUP_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUC_THRESH_FAST_RATEUP_FLAG) == 0) 
+      DEBUGMSGTL(("adslMIB-Line", "GET- AtucThreshRateUp CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_FAST_RATEUP_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAtucThreshFastRateUp;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAtucThreshFastRateUp);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAtucThreshFastRateUp column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAtucThreshFastRateUp(void *data_context, u_long * val,
+                             size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAtucThreshFastRateUp=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_FAST_RATEUP_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+    	ATUC_THRESH_FAST_RATEUP_FLAG) == 0) {
+     DEBUGMSGTL(("adslMIB-Line", "SET- AtucThreshRateUp CMV fail\n"));
+     CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_FAST_RATEUP_FLAG);
+     return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+       CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_FAST_RATEUP_FLAG);
+       return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucThreshInterleaveRateUp column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucThreshInterleaveRateUp(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags,
+    	ATUC_THRESH_INTERLEAVE_RATEUP_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+    	ATUC_THRESH_INTERLEAVE_RATEUP_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-Line", "GET- AtucThreshIntlvRateUp CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+    ATUC_THRESH_INTERLEAVE_RATEUP_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAtucThreshInterleaveRateUp;
+   *ret_len = sizeof(adslLineAlarmConfProStruct.adslAtucThreshInterleaveRateUp);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAtucThreshInterleaveRateUp column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAtucThreshInterleaveRateUp(void *data_context, u_long * val,
+                                   size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAtucThreshInterleaveRateUp=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags,
+    ATUC_THRESH_INTERLEAVE_RATEUP_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+    		ATUC_THRESH_INTERLEAVE_RATEUP_FLAG) == 0) {
+     	DEBUGMSGTL(("adslMIB-Line", "SET- AtucThreshIntlvRateUp CMV fail\n"));
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUC_THRESH_INTERLEAVE_RATEUP_FLAG);
+    	return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUC_THRESH_INTERLEAVE_RATEUP_FLAG);
+    	return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the adslAtucThreshFastRateDown
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucThreshFastRateDown(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_FAST_RATEDOWN_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+    	ATUC_THRESH_FAST_RATEDOWN_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-Line", "GET- AtucThreshRateDown CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_FAST_RATEDOWN_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAtucThreshFastRateDown;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAtucThreshFastRateDown);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAtucThreshFastRateDown column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAtucThreshFastRateDown(void *data_context, u_long * val,
+                               size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAtucThreshFastRateDown=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUC_THRESH_FAST_RATEDOWN_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+    		ATUC_THRESH_FAST_RATEDOWN_FLAG) == 0)  {
+       DEBUGMSGTL(("adslMIB-Line", "SET- AtucThreshRateDown CMV fail\n"));
+       CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+             ATUC_THRESH_FAST_RATEDOWN_FLAG);
+       return SNMP_ERR_COMMITFAILED;
+    } 
+    else {
+          CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+              ATUC_THRESH_FAST_RATEDOWN_FLAG);
+          return SNMP_ERR_NOERROR;
+     }
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAtucThreshInterleaveRateDown column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAtucThreshInterleaveRateDown(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags,
+            ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+            ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-Line", "GET- AtucThreshIntlvRateDown CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+            ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAtucThreshInterleaveRateDown;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.
+                    adslAtucThreshInterleaveRateDown);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAtucThreshInterleaveRateDown column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAtucThreshInterleaveRateDown(void *data_context, u_long * val,
+                                     size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAtucThreshInterleaveRateDown=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG) == 0) {
+     	DEBUGMSGTL(("adslMIB-Line", "SET- AtucThreshIntlvRateDown CMV fail\n"));
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+            ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG);
+        return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+            ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the adslAtucInitFailureTrapEnable
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAtucInitFailureTrapEnable(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-Line", "GET- AtucInitFailTrap CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAtucInitFailureTrapEnable;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAtucInitFailureTrapEnable);
+    return (int *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAtucInitFailureTrapEnable column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAtucInitFailureTrapEnable(void *data_context, long *val,
+                                  size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAtucInitFailureTrapEnable=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+            ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG) == 0) {
+        DEBUGMSGTL(("adslMIB-Line", "SET- AtucInitFailTrap CMV fail\n"));
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+            ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG);
+        return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+            ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the adslAturThresh15MinLofs
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAturThresh15MinLofs(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_15MIN_LOFS_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-Line", "GET- AturThresh15MinLOF CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LOFS_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAturThresh15MinLofs;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAturThresh15MinLofs);
+    return (int *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAturThresh15MinLofs column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAturThresh15MinLofs(void *data_context, long *val, size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAturThresh15MinLofs=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LOFS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        	ATUR_THRESH_15MIN_LOFS_FLAG) == 0) {
+       DEBUGMSGTL(("adslMIB-Line", "SET- AturThresh15MinLOF CMV fail\n"));
+       CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LOFS_FLAG);
+       return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+     	CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LOFS_FLAG);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the adslAturThresh15MinLoss
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAturThresh15MinLoss(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_15MIN_LOSS_FLAG) == 0) 
+      DEBUGMSGTL(("adslMIB-Line", "GET- AturThresh15MinLOSS CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LOSS_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAturThresh15MinLoss;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAturThresh15MinLoss);
+    return (int *) &long_ret;
+
+}
+
+/** XXX: Set the value of the adslAturThresh15MinLoss column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAturThresh15MinLoss(void *data_context, long *val, size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAturThresh15MinLoss=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LOSS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        	ATUR_THRESH_15MIN_LOSS_FLAG) == 0) {
+      	DEBUGMSGTL(("adslMIB-Line", "SET- AturThresh15MinLOSS CMV fail\n"));
+     	CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LOSS_FLAG);
+        return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+     	CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LOSS_FLAG);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the adslAturThresh15MinLprs
+    column and set ret_len to its proper size in bytes. */
+int           *
+get_adslAturThresh15MinLprs(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+            (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LPRS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_15MIN_LPRS_FLAG) == 0) 
+      DEBUGMSGTL(("adslMIB-Line", "GET- AturThresh15MinLPR CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LPRS_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAturThresh15MinLprs;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAturThresh15MinLprs);
+    return (int *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAturThresh15MinLprs column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAturThresh15MinLprs(void *data_context, long *val, size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAturThresh15MinLprs=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LPRS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        	ATUR_THRESH_15MIN_LPRS_FLAG) == 0) {
+      	DEBUGMSGTL(("adslMIB-Line", "SET- AturThresh15MinLPR CMV fail\n"));
+     	CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LPRS_FLAG);
+        return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+      	CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_LPRS_FLAG);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the adslAturThresh15MinESs column
+    and set ret_len to its proper size in bytes. */
+int           *
+get_adslAturThresh15MinESs(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_15MIN_ESS_FLAG) == 0) 
+      DEBUGMSGTL(("adslMIB-Line", "GET- AturThresh15MinESS CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_ESS_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAturThresh15MinESs;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAturThresh15MinESs);
+    return (int *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAturThresh15MinESs column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAturThresh15MinESs(void *data_context, long *val, size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAturThresh15MinESs=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_ESS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        	ATUR_THRESH_15MIN_ESS_FLAG) == 0) {
+      	DEBUGMSGTL(("adslMIB-Line", "SET- AturThresh15MinESS CMV fail\n"));
+     	CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_ESS_FLAG);
+        return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_15MIN_ESS_FLAG);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the adslAturThreshFastRateUp
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturThreshFastRateUp(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_FAST_RATEUP_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_FAST_RATEUP_FLAG) == 0) 
+      DEBUGMSGTL(("adslMIB-Line", "GET- AturThreshRateUp CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_FAST_RATEUP_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAturThreshFastRateUp;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAturThreshFastRateUp);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAturThreshFastRateUp column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAturThreshFastRateUp(void *data_context, u_long * val,
+                             size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAturThreshFastRateUp=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_FAST_RATEUP_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        	ATUR_THRESH_FAST_RATEUP_FLAG) == 0) {
+     	DEBUGMSGTL(("adslMIB-Line", "SET- AturThreshRateUp CMV fail\n"));
+    	CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_FAST_RATEUP_FLAG);
+        return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+     	CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_FAST_RATEUP_FLAG);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturThreshInterleaveRateUp column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturThreshInterleaveRateUp(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_INTERLEAVE_RATEUP_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_INTERLEAVE_RATEUP_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-Line", "GET- AturThreshIntlvRateUp CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_INTERLEAVE_RATEUP_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAturThreshInterleaveRateUp;
+   *ret_len = sizeof(adslLineAlarmConfProStruct.adslAturThreshInterleaveRateUp);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAturThreshInterleaveRateUp column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAturThreshInterleaveRateUp(void *data_context, u_long * val,
+                                   size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAturThreshInterleaveRateUp=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_INTERLEAVE_RATEUP_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        	ATUR_THRESH_INTERLEAVE_RATEUP_FLAG) == 0) {
+     	DEBUGMSGTL(("adslMIB-Line", "SET- AturThreshIntlvRateUp CMV fail\n"));
+      CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+           ATUR_THRESH_INTERLEAVE_RATEUP_FLAG);
+      return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+            ATUR_THRESH_INTERLEAVE_RATEUP_FLAG);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the adslAturThreshFastRateDown
+    column and set ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturThreshFastRateDown(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_FAST_RATEDOWN_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        	ATUR_THRESH_FAST_RATEDOWN_FLAG) == 0) 
+       DEBUGMSGTL(("adslMIB-Line", "GET- AturThreshRateDown CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_FAST_RATEDOWN_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAturThreshFastRateDown;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.adslAturThreshFastRateDown);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAturThreshFastRateDown column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAturThreshFastRateDown(void *data_context, u_long * val,
+                               size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAturThreshFastRateDown=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags, ATUR_THRESH_FAST_RATEDOWN_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_FAST_RATEDOWN_FLAG) == 0) {
+       DEBUGMSGTL(("adslMIB-Line", "SET- AturThreshRateDown CMV fail\n"));
+       CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+            ATUR_THRESH_FAST_RATEDOWN_FLAG);
+        return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+            ATUR_THRESH_FAST_RATEDOWN_FLAG);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the
+    adslAturThreshInterleaveRateDown column and set
+         ret_len to its proper size in bytes. */
+u_int32         *
+get_adslAturThreshInterleaveRateDown(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-Line", "GET- AturThreshIntlvRateDown CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslAturThreshInterleaveRateDown;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.
+                    adslAturThreshInterleaveRateDown);
+    return (u_int32 *) &long_ret;
+}
+
+/** XXX: Set the value of the adslAturThreshInterleaveRateDown column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslAturThreshInterleaveRateDown(void *data_context, u_long * val,
+                                     size_t val_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    adslLineAlarmConfProStruct.adslAturThreshInterleaveRateDown=*val;
+    SET_FLAG(&adslLineAlarmConfProStruct.flags,
+        ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, SET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        	ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG) == 0) {
+     	DEBUGMSGTL(("adslMIB-Line", "SET- AturThreshIntlvRateDown CMV fail\n"));
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+            ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG);
+        return SNMP_ERR_COMMITFAILED;
+    }
+    else {
+        CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+            ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG);
+        return SNMP_ERR_NOERROR;
+    }
+}
+
+/** XXX: return a data pointer to the data for the
+    adslLineAlarmConfProfileRowStatus column and set
+         ret_len to its proper size in bytes. */
+int           *
+get_adslLineAlarmConfProfileRowStatus(void *data_context, size_t * ret_len)
+{
+    struct adslLineAlarmConfProfileEntry adslLineAlarmConfProStruct;
+    memset(&adslLineAlarmConfProStruct,0,sizeof(adslLineAlarmConfProfileEntry));
+    strcpy(adslLineAlarmConfProStruct.adslLineAlarmConfProfileName,
+        (char *)data_context);
+    SET_FLAG(&adslLineAlarmConfProStruct.flags,
+        LINE_ALARM_CONF_PROFILE_ROWSTATUS_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, GET_ADSL_ALRM_CONF_PROF,(void *) &adslLineAlarmConfProStruct);
+#else
+    adslLineAlarmConfProfileTable(Fd, GET_ADSL_ALRM_CONF_PROF,
+        (void *) &adslLineAlarmConfProStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineAlarmConfProStruct.flags,
+        LINE_ALARM_CONF_PROFILE_ROWSTATUS_FLAG) == 0) 
+     DEBUGMSGTL(("adslMIB-Line", "GET- ProfileRowStat CMV fail\n"));
+
+    CLR_FLAG(&adslLineAlarmConfProStruct.flags,
+        LINE_ALARM_CONF_PROFILE_ROWSTATUS_FLAG);
+    long_ret = adslLineAlarmConfProStruct.adslLineAlarmConfProfileRowStatus;
+    *ret_len = sizeof(adslLineAlarmConfProStruct.
+                        adslLineAlarmConfProfileRowStatus);
+    return (int *) &long_ret;
+}
+
+/** XXX: Set the value of the adslLineAlarmConfProfileRowStatus column and
+    return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslLineAlarmConfProfileRowStatus(void *data_context, long *val,
+                                      size_t val_len)
+{
+    return SNMP_ERR_NOTWRITABLE;      /** XXX: change if an error occurs */
+}
+#endif /* HAVE_OPTIMIZED_CODE */
+
+
+#ifndef ENABLE_DRIVER_CALL
+int adslLineAlarmConfProfileTable(int Fd2, int ADSL_ALRM_CONF_PROF2,
+            void *adslLineAlarmStruct)
+{
+    struct adslLineAlarmConfProfileEntry *adslLineAlarmValue;
+    adslLineAlarmValue = (adslLineAlarmConfProfileEntry *)adslLineAlarmStruct;
+    if (ADSL_ALRM_CONF_PROF2 == GET_ADSL_ALRM_CONF_PROF)
+    {
+
+    adslLineAlarmValue->adslAtucThresh15MinLofs = adslAtucTh15MinLofs;
+    adslLineAlarmValue->adslAtucThresh15MinLoss = adslAtucTh15MinLoss;
+    adslLineAlarmValue->adslAtucThresh15MinESs = adslAtucTh15MinESs;
+    adslLineAlarmValue->adslAtucThreshFastRateUp = adslAtucThFastRateUp;
+    adslLineAlarmValue->adslAtucThreshInterleaveRateUp =
+    adslAtucThInterleaveRateUp;
+    adslLineAlarmValue->adslAtucThreshFastRateDown = adslAtucThFastRateDown;
+    adslLineAlarmValue->adslAtucThreshInterleaveRateDown =
+    adslAtucThInterleaveRateDown;
+    adslLineAlarmValue->adslAtucInitFailureTrapEnable =
+    adslAtucInitFailTrapEnable;
+    adslLineAlarmValue->adslAturThresh15MinLofs = adslAturTh15MinLofs;
+    adslLineAlarmValue->adslAturThresh15MinLoss = adslAturTh15MinLoss;
+    adslLineAlarmValue->adslAturThresh15MinLprs = adslAturTh15MinLprs;
+    adslLineAlarmValue->adslAturThresh15MinESs = adslAturTh15MinESs;
+    adslLineAlarmValue->adslAturThreshFastRateUp = adslAturThFastRateUp;
+    adslLineAlarmValue->adslAturThreshInterleaveRateUp =
+    adslAturThInterleaveRateUp;
+    adslLineAlarmValue->adslAturThreshFastRateDown = adslAturThFastRateDown;
+    adslLineAlarmValue->adslAturThreshInterleaveRateDown =
+    adslAturThInterleaveRateDown;
+    adslLineAlarmValue->adslLineAlarmConfProfileRowStatus =
+    adslLineAlarmConfProfRowStatus;
+
+    }
+    else if (ADSL_ALRM_CONF_PROF2 == SET_ADSL_ALRM_CONF_PROF) {
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUC_THRESH_15MIN_LOFS_FLAG) != 0)
+    adslAtucTh15MinLofs = adslLineAlarmValue->adslAtucThresh15MinLofs;
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUC_THRESH_15MIN_LOSS_FLAG) != 0)
+    adslAtucTh15MinLoss = adslLineAlarmValue->adslAtucThresh15MinLoss;
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUC_THRESH_15MIN_ESS_FLAG) != 0)
+   adslAtucTh15MinESs = adslLineAlarmValue->adslAtucThresh15MinESs;
+
+  if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUC_THRESH_FAST_RATEUP_FLAG) != 0)
+   adslAtucThFastRateUp  = adslLineAlarmValue->adslAtucThreshFastRateUp ;
+
+  if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUC_THRESH_INTERLEAVE_RATEUP_FLAG)
+   != 0)
+   adslAtucThInterleaveRateUp = adslLineAlarmValue->
+   adslAtucThreshInterleaveRateUp;
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUC_THRESH_FAST_RATEDOWN_FLAG) !=
+    0)
+   adslAtucThFastRateDown = adslLineAlarmValue->adslAtucThreshFastRateDown;
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,
+         ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG) != 0)
+       adslAtucThInterleaveRateDown = adslLineAlarmValue->
+            adslAtucThreshInterleaveRateDown;
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG
+   ) != 0)
+  adslAtucInitFailTrapEnable =adslLineAlarmValue->adslAtucInitFailureTrapEnable;
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUR_THRESH_15MIN_LOFS_FLAG) != 0)
+   adslAturTh15MinLofs= adslLineAlarmValue->adslAturThresh15MinLofs;
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUR_THRESH_15MIN_LOSS_FLAG) != 0)
+   adslAturTh15MinLoss =adslLineAlarmValue->adslAturThresh15MinLoss;
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUR_THRESH_15MIN_LPRS_FLAG) != 0)
+   adslAturTh15MinLprs= adslLineAlarmValue->adslAturThresh15MinLprs;
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUR_THRESH_15MIN_ESS_FLAG) != 0)
+   adslAturTh15MinESs= adslLineAlarmValue->adslAturThresh15MinESs;
+
+  if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUR_THRESH_FAST_RATEUP_FLAG) != 0)
+   adslAturThFastRateUp =adslLineAlarmValue->adslAturThreshFastRateUp;
+
+  if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUR_THRESH_INTERLEAVE_RATEUP_FLAG)
+   != 0)
+   adslAturThInterleaveRateUp =adslLineAlarmValue->
+        adslAturThreshInterleaveRateUp;
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,ATUR_THRESH_FAST_RATEDOWN_FLAG) !=
+    0)
+   adslAturThFastRateDown =adslLineAlarmValue->adslAturThreshFastRateDown;
+
+   if (IS_FLAG_SET(&adslLineAlarmValue->flags,
+            ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG) != 0)
+       adslAturThInterleaveRateDown =adslLineAlarmValue->
+                adslAturThreshInterleaveRateDown;
+    }
+
+    return 0;
+}
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_access.h open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_access.h	2009-12-16 12:59:29.000000000 +0530
@@ -0,0 +1,219 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslLineAlarmConfProfileTable_access.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *              1)  Include files
+ *              2)  User defined data types
+ *              3)  Function proto-types for adslLineAlarmConfProfileTable
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ * Subramani: Changed data types as per Rfc-2662
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+#ifndef ADSLLINEALARMCONFPROFILETABLE_ACCESS_H
+#define ADSLLINEALARMCONFPROFILETABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                        USER-DEFINED DATA TYPES
+ * ===========================================================================
+*/
+
+#ifdef STUB_IOCTL
+/* Data structures */
+
+typedef struct  adslLineAlarmConfProfileEntry
+ {
+  unsigned char adslLineAlarmConfProfileName[32];
+    int     adslAtucThresh15MinLofs;
+    int     adslAtucThresh15MinLoss;
+    int     adslAtucThresh15MinESs;
+    u_int32     adslAtucThreshFastRateUp;
+    u_int32     adslAtucThreshInterleaveRateUp;
+    u_int32     adslAtucThreshFastRateDown;
+    u_int32     adslAtucThreshInterleaveRateDown;
+    int     adslAtucInitFailureTrapEnable;
+    int     adslAturThresh15MinLofs;
+    int     adslAturThresh15MinLoss;
+    int     adslAturThresh15MinLprs;
+    int     adslAturThresh15MinESs;
+    u_int32     adslAturThreshFastRateUp;
+    u_int32     adslAturThreshInterleaveRateUp;
+    u_int32     adslAturThreshFastRateDown;
+    u_int32     adslAturThreshInterleaveRateDown;
+    int     adslLineAlarmConfProfileRowStatus;
+    u_int32 flags;
+} adslLineAlarmConfProfileEntry;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+
+/** User-defined data access functions for data in table
+    adslLineAlarmConfProfileTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslLineAlarmConfProfileTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslLineAlarmConfProfileTable_get_next_data_point;
+
+int             adslLineAlarmConfProfileTable_commit_row(void
+                                                         **my_data_context,
+                                                         int new_or_del);
+void
+    *adslLineAlarmConfProfileTable_create_data_context
+    (netsnmp_variable_list * index_data);
+
+/** column accessors */
+  
+#if defined(HAVE_OPTIMIZED_CODE)
+int *
+get_adslThresh15MinVal(void *data_context, size_t *ret_len, unsigned int var);
+
+int 
+set_adslThresh15MinVal(void *data_context, long *val, 
+		size_t val_len, unsigned int var);
+
+u_int32         *
+get_adslThreshChanVal(void *data_context, size_t *ret_len, unsigned int var);
+
+int 
+set_adslThreshChanVal(void *data_context, long *val, 
+		size_t val_len, unsigned int var);
+#else
+
+int           *get_adslAtucThresh15MinLofs(void *data_context,
+                                            size_t * ret_len);
+int             set_adslAtucThresh15MinLofs(void *data_context, long *val,
+                                            size_t val_len);
+int           *get_adslAtucThresh15MinLoss(void *data_context,
+                                            size_t * ret_len);
+int             set_adslAtucThresh15MinLoss(void *data_context, long *val,
+                                            size_t val_len);
+
+int           *get_adslAtucThresh15MinESs(void *data_context,
+                                           size_t * ret_len);
+int             set_adslAtucThresh15MinESs(void *data_context, long *val,
+                                           size_t val_len);
+u_int32         *get_adslAtucThreshFastRateUp(void *data_context,
+                                             size_t * ret_len);
+int             set_adslAtucThreshFastRateUp(void *data_context,
+                                             u_long * val, size_t val_len);
+u_int32         *get_adslAtucThreshInterleaveRateUp(void *data_context,
+                                                   size_t * ret_len);
+int             set_adslAtucThreshInterleaveRateUp(void *data_context,
+                                                   u_long * val,
+                                                   size_t val_len);
+u_int32         *get_adslAtucThreshFastRateDown(void *data_context,
+                                               size_t * ret_len);
+int             set_adslAtucThreshFastRateDown(void *data_context,
+                                               u_long * val,
+                                               size_t val_len);
+u_int32         *get_adslAtucThreshInterleaveRateDown(void *data_context,
+                                                     size_t * ret_len);
+int             set_adslAtucThreshInterleaveRateDown(void *data_context,
+                                                     u_long * val,
+                                                     size_t val_len);
+int           *get_adslAtucInitFailureTrapEnable(void *data_context,
+                                                  size_t * ret_len);
+int             set_adslAtucInitFailureTrapEnable(void *data_context,
+                                                  long *val,
+                                                  size_t val_len);
+int           *get_adslAturThresh15MinLofs(void *data_context,
+                                            size_t * ret_len);
+int             set_adslAturThresh15MinLofs(void *data_context, long *val,
+                                            size_t val_len);
+int           *get_adslAturThresh15MinLoss(void *data_context,
+                                            size_t * ret_len);
+int             set_adslAturThresh15MinLoss(void *data_context, long *val,
+                                            size_t val_len);
+int           *get_adslAturThresh15MinLprs(void *data_context,
+                                            size_t * ret_len);
+int             set_adslAturThresh15MinLprs(void *data_context, long *val,
+                                            size_t val_len);
+int           *get_adslAturThresh15MinESs(void *data_context,
+                                           size_t * ret_len);
+int             set_adslAturThresh15MinESs(void *data_context, long *val,
+                                           size_t val_len);
+u_int32         *get_adslAturThreshFastRateUp(void *data_context,
+                                             size_t * ret_len);
+int             set_adslAturThreshFastRateUp(void *data_context,
+                                             u_long * val, size_t val_len);
+u_int32         *get_adslAturThreshInterleaveRateUp(void *data_context,
+                                                   size_t * ret_len);
+int             set_adslAturThreshInterleaveRateUp(void *data_context,
+                                                   u_long * val,
+                                                   size_t val_len);
+u_int32         *get_adslAturThreshFastRateDown(void *data_context,
+                                               size_t * ret_len);
+int             set_adslAturThreshFastRateDown(void *data_context,
+                                               u_long * val,
+                                               size_t val_len);
+u_int32         *get_adslAturThreshInterleaveRateDown(void *data_context,
+                                                     size_t * ret_len);
+int             set_adslAturThreshInterleaveRateDown(void *data_context,
+                                                     u_long * val,
+                                                     size_t val_len);
+int           *get_adslLineAlarmConfProfileRowStatus(void *data_context,
+                                                      size_t * ret_len);
+int             set_adslLineAlarmConfProfileRowStatus(void *data_context,
+                                                      long *val,
+                                                      size_t val_len);
+#endif
+
+#ifndef ENABLE_DRIVER_CALL
+int adslLineAlarmConfProfileTable(int Fd2, int ADSL_ALRM_CONF_PROF2,
+                    void *adslLineAlarmStruct);
+#endif
+
+
+#endif                          /* ADSLLINEALARMCONFPROFILETABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns.c open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns.c	2009-12-16 12:59:29.000000000 +0530
@@ -0,0 +1,613 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslLineAlarmConfProfileTable_checkfns.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:    This file is auto-generated and SHOULD NOT BE EDITED by hand.
+ *              Modify the adslLineAlarmConfProfileTable_checkfns_local.[ch]
+ *              files insead so that you can regenerate this one as mib2c
+ *              improvements are made.
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.check_values.conf,v 1.6 2003/06/13 18:18:04 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/* standard headers */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include "adslLineAlarmConfProfileTable_checkfns.h"
+#include "adslLineAlarmConfProfileTable_checkfns_local.h"
+#include "adslLineAlarmConfProfileTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+#if defined(HAVE_OPTIMIZED_CODE)
+int
+check_adslThresh15MinVal(int type, long *val, size_t val_len,
+                              long *old_val, size_t old_val_len)
+{
+
+    int             ret;
+
+    /** Check to see that we were called legally */
+    if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+    if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+    ret = SNMP_ERR_NOERROR;
+    /** Check the ranges of the passed value for legality */
+    if (!((*val >= 0) && (*val <= 900)))
+    return SNMP_ERR_WRONGVALUE;
+    
+    return SNMP_ERR_NOERROR;
+}
+
+
+int
+check_adslThreshChanVal(int type, u_long * val,
+                               size_t val_len, u_long * old_val,
+                               size_t old_val_len)
+{
+
+   int ret;
+    
+   /** Check to see that we were called legally */
+   if (!val)
+     return SNMP_ERR_GENERR;
+   
+    /** Check the incoming type for correctness */
+   if (type != ASN_UNSIGNED)
+     return SNMP_ERR_WRONGTYPE;
+    /** looks ok, call the local version of the same function. */
+    return SNMP_ERR_NOERROR;
+}
+#else
+/** Decides if an incoming value for the adslAtucThresh15MinLofs mib node is
+    legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAtucThresh15MinLofs(int type, long *val, size_t val_len,
+                              long *old_val, size_t old_val_len)
+{
+
+    int             ret;
+
+    /** Check to see that we were called legally */
+    if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+    if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+    ret = SNMP_ERR_NOERROR;
+    /** Check the ranges of the passed value for legality */
+    if (!((*val >= 0) && (*val <= 900)))
+    return SNMP_ERR_WRONGVALUE;
+    
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAtucThresh15MinLoss mib node is
+    legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+        int
+        check_adslAtucThresh15MinLoss(int type, long *val, size_t val_len,
+                                      long *old_val, size_t old_val_len) {
+
+        int ret;
+    /** Check to see that we were called legally */
+        if (!val)
+        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+        if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE; ret = SNMP_ERR_NOERROR;
+    /** Check the ranges of the passed value for legality */
+        if (!((*val >= 0) && (*val <= 900)))
+        return SNMP_ERR_WRONGVALUE;
+
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAtucThresh15MinESs mib node is
+    legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                    int
+                    check_adslAtucThresh15MinESs(int type, long *val,
+                                                 size_t val_len,
+                                                 long *old_val,
+                                                 size_t old_val_len) {
+
+                    int ret;
+    /** Check to see that we were called legally */
+                    if (!val)
+                    return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                    if (type != ASN_INTEGER)
+                    return SNMP_ERR_WRONGTYPE; ret = SNMP_ERR_NOERROR;
+    /** Check the ranges of the passed value for legality */
+                   if (!((*val >= 0) && (*val <= 900)))
+        return SNMP_ERR_WRONGVALUE;
+
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAtucThreshFastRateUp mib node is
+     legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                        int
+                        check_adslAtucThreshFastRateUp(int type,
+                                                       u_long * val,
+                                                       size_t val_len,
+                                                       u_long * old_val,
+                                                       size_t old_val_len)
+                        {
+
+                        int ret;
+    /** Check to see that we were called legally */
+                        if (!val)
+                        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                        if (type != ASN_UNSIGNED)
+                        return SNMP_ERR_WRONGTYPE;
+    /** looks ok, call the local version of the same function. */
+    return SNMP_ERR_NOERROR;
+}
+
+                              
+/** Decides if an incoming value for the adslAtucThreshInterleaveRateUp mib
+    node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                        int
+                        check_adslAtucThreshInterleaveRateUp(int type,
+                                                             u_long * val,
+                                                             size_t
+                                                             val_len,
+                                                             u_long *
+                                                             old_val,
+                                                             size_t
+                                                             old_val_len) {
+
+                        int ret;
+    /** Check to see that we were called legally */
+                        if (!val)
+                        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                        if (type != ASN_UNSIGNED)
+                        return SNMP_ERR_WRONGTYPE;
+    return SNMP_ERR_NOERROR;
+}
+
+
+/** Decides if an incoming value for the adslAtucThreshFastRateDown mib node
+    is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                        int
+                        check_adslAtucThreshFastRateDown(int type,
+                                                         u_long * val,
+                                                         size_t val_len,
+                                                         u_long * old_val,
+                                                         size_t
+                                                         old_val_len) {
+
+                        int ret;
+    /** Check to see that we were called legally */
+                        if (!val)
+                        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                        if (type != ASN_UNSIGNED)
+                        return SNMP_ERR_WRONGTYPE;
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAtucThreshInterleaveRateDown mib
+    node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                        int
+                        check_adslAtucThreshInterleaveRateDown(int type,
+                                                               u_long *
+                                                               val,
+                                                               size_t
+                                                               val_len,
+                                                               u_long *
+                                                               old_val,
+                                                               size_t
+                                                               old_val_len)
+                        {
+
+                        int ret;
+    /** Check to see that we were called legally */
+                        if (!val)
+                        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                        if (type != ASN_UNSIGNED)
+                        return SNMP_ERR_WRONGTYPE;
+
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThresh15MinLofs mib node is
+    legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                        int
+                        check_adslAturThresh15MinLofs(int type, long *val,
+                                                      size_t val_len,
+                                                      long *old_val,
+                                                      size_t old_val_len) {
+
+                        int ret;
+    /** Check to see that we were called legally */
+                        if (!val)
+                        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                        if (type != ASN_INTEGER)
+                        return SNMP_ERR_WRONGTYPE; ret = SNMP_ERR_NOERROR;
+    /** Check the ranges of the passed value for legality */
+                       if (!((*val >= 0) && (*val <= 900)))
+        return SNMP_ERR_WRONGVALUE;
+
+    return SNMP_ERR_NOERROR;
+}
+
+
+/** Decides if an incoming value for the adslAturThresh15MinLoss mib node is
+    legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                            int
+                            check_adslAturThresh15MinLoss(int type,
+                                                          long *val,
+                                                          size_t val_len,
+                                                          long *old_val,
+                                                          size_t
+                                                          old_val_len) {
+
+                            int ret;
+    /** Check to see that we were called legally */
+                            if (!val)
+                            return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                            if (type != ASN_INTEGER)
+                            return SNMP_ERR_WRONGTYPE;
+                            ret = SNMP_ERR_NOERROR;
+    /** Check the ranges of the passed value for legality */
+                           if (!((*val >= 0) && (*val <= 900)))
+        return SNMP_ERR_WRONGVALUE;
+
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThresh15MinLprs mib node is
+    legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                                int
+                                check_adslAturThresh15MinLprs(int type,
+                                                              long *val,
+                                                              size_t
+                                                              val_len,
+                                                              long
+                                                              *old_val,
+                                                              size_t
+                                                              old_val_len)
+                                {
+
+                                int ret;
+    /** Check to see that we were called legally */
+                                if (!val)
+                                return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                                if (type != ASN_INTEGER)
+                                return SNMP_ERR_WRONGTYPE;
+                                ret = SNMP_ERR_NOERROR;
+    /** Check the ranges of the passed value for legality */
+                               if (!((*val >= 0) && (*val <= 900)))
+        return SNMP_ERR_WRONGVALUE;
+
+    return SNMP_ERR_NOERROR;
+}
+
+
+/** Decides if an incoming value for the adslAturThresh15MinESs mib node is
+    legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                                    int
+                                    check_adslAturThresh15MinESs(int type,
+                                                                 long *val,
+                                                                 size_t
+                                                                 val_len,
+                                                                 long
+                                                                 *old_val,
+                                                                 size_t
+                                                                 old_val_len)
+                                    {
+
+                                    int ret;
+    /** Check to see that we were called legally */
+                                    if (!val)
+                                    return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                                    if (type != ASN_INTEGER)
+                                    return SNMP_ERR_WRONGTYPE;
+                                    ret = SNMP_ERR_NOERROR;
+    /** Check the ranges of the passed value for legality */
+                                   if (!((*val >= 0) && (*val <= 900)))
+        return SNMP_ERR_WRONGVALUE;
+
+    return SNMP_ERR_NOERROR;
+}
+
+
+/** Decides if an incoming value for the adslAturThreshFastRateUp mib node is
+    legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                                        int
+                                        check_adslAturThreshFastRateUp(int
+                                                                       type,
+                                                                       u_long
+                                                                       *
+                                                                       val,
+                                                                       size_t
+                                                                       val_len,
+                                                                       u_long
+                                                                       *
+                                                                       old_val,
+                                                                       size_t
+                                                                    old_val_len)
+                                        {
+
+                                        int ret;
+    /** Check to see that we were called legally */
+                                        if (!val)
+                                        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                                        if (type != ASN_UNSIGNED)
+                                        return SNMP_ERR_WRONGTYPE;
+
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThreshInterleaveRateUp mib node
+     is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                                        int
+                                        check_adslAturThreshInterleaveRateUp
+                                        (int type, u_long * val,
+                                         size_t val_len, u_long * old_val,
+                                         size_t old_val_len) {
+
+                                        int ret;
+    /** Check to see that we were called legally */
+                                        if (!val)
+                                        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                                        if (type != ASN_UNSIGNED)
+                                        return SNMP_ERR_WRONGTYPE;
+
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThreshFastRateDown mib node is
+    legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                                        int
+                                        check_adslAturThreshFastRateDown
+                                        (int type, u_long * val,
+                                         size_t val_len, u_long * old_val,
+                                         size_t old_val_len) {
+
+                                        int ret;
+    /** Check to see that we were called legally */
+                                        if (!val)
+                                        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                                        if (type != ASN_UNSIGNED)
+                                        return SNMP_ERR_WRONGTYPE;
+
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThreshInterleaveRateDown mib
+    node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                                        int
+                                        check_adslAturThreshInterleaveRateDown
+                                        (int type, u_long * val,
+                                         size_t val_len, u_long * old_val,
+                                         size_t old_val_len) {
+
+                                        int ret;
+    /** Check to see that we were called legally */
+                                        if (!val)
+                                        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                                        if (type != ASN_UNSIGNED)
+                                        return SNMP_ERR_WRONGTYPE;
+
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslLineAlarmConfProfileRowStatus mib
+    node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                                        int
+                                        check_adslLineAlarmConfProfileRowStatus
+                                        (int type, long *val,
+                                         size_t val_len, long *old_val,
+                                         size_t old_val_len) {
+
+                                        int ret;
+    /** Check to see that we were called legally */
+                                        if (!val)
+                                        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                                        if (type != ASN_INTEGER)
+                                        return SNMP_ERR_WRONGTYPE;
+    /** Check the enums.  Legal values will continue, others return error. */
+                                        switch (*val) {
+case ADSLLINEALARMCONFPROFILEROWSTATUS_ACTIVE:
+case ADSLLINEALARMCONFPROFILEROWSTATUS_NOTINSERVICE:
+case ADSLLINEALARMCONFPROFILEROWSTATUS_NOTREADY:
+case ADSLLINEALARMCONFPROFILEROWSTATUS_CREATEANDGO:
+case ADSLLINEALARMCONFPROFILEROWSTATUS_CREATEANDWAIT:
+case ADSLLINEALARMCONFPROFILEROWSTATUS_DESTROY:
+                                        break;
+    /** not a legal enum value.  return an error */
+default:
+                                        return SNMP_ERR_INCONSISTENTVALUE;}
+                                        ret = SNMP_ERR_NOERROR;
+                                        if (ret =
+                                          check_rowstatus_transition((old_val) ?
+                                           *old_val : RS_NONEXISTENT, *val))
+                                        return ret;
+}
+#endif
+
+/** Decides if an incoming value for the adslAtucInitFailureTrapEnable mib node
+    is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+                        int
+                        check_adslAtucInitFailureTrapEnable(int type,
+                                                            long *val,
+                                                            size_t val_len,
+                                                            long *old_val,
+                                                            size_t
+                                                            old_val_len) {
+
+                        int ret;
+    /** Check to see that we were called legally */
+                        if (!val)
+                        return SNMP_ERR_GENERR;
+    /** Check the incoming type for correctness */
+                        if (type != ASN_INTEGER)
+                        return SNMP_ERR_WRONGTYPE;
+    		/** Check the enums.  Legal values will continue, others return error. */
+                        switch (*val) {
+			  case ADSLATUCINITFAILURETRAPENABLE_ENABLE:
+			  case ADSLATUCINITFAILURETRAPENABLE_DISABLE:
+                            break;
+    		/** not a legal enum value.  return an error */
+			  default:
+                        	return SNMP_ERR_INCONSISTENTVALUE;
+			}
+                  	return SNMP_ERR_NOERROR;
+}
+
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns.h open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns.h	2009-12-16 12:59:29.000000000 +0530
@@ -0,0 +1,179 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslLineAlarmConfProfileTable_checkfns.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains :
+ *                1) Include files
+ *                2) Init Function proto-types for
+ *                   adslLineAlarmConfProfileTable_checkfns
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.6 2003/02/20 00:52:07 hardaker Exp $
+ */
+
+/***********************************************************************
+ *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
+ *   Modify the adslLineAlarmConfProfileTable_checkfns_local.[ch] files insead.
+ *   (so that you can regenerate this one as mib2c improvements are made)
+ ***********************************************************************/
+#ifndef ADSLLINEALARMCONFPROFILETABLE_CHECKFNS_H
+#define ADSLLINEALARMCONFPROFILETABLE_CHECKFNS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/** make sure we load the functions that you can modify */
+//config_require(adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns_local)
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+ /*
+  * these functions are designed to check incoming values for
+  * columns in the adslLineAlarmConfProfileTable table for legality with
+  * respect to datatype and value.
+ */
+#if defined(HAVE_OPTIMIZED_CODE)
+int
+check_adslThresh15MinVal(int type, long *val, size_t val_len,
+                              long *old_val, size_t old_val_len);
+
+
+int
+check_adslThreshChanVal(int type, u_long * val,
+                               size_t val_len, u_long * old_val,
+                               size_t old_val_len);
+
+#else
+     int             check_adslAtucThresh15MinLofs(int type, long *val,
+                                                   size_t val_len,
+                                                   long *old_val,
+                                                   size_t old_val_len);
+     int             check_adslAtucThresh15MinLoss(int type, long *val,
+                                                   size_t val_len,
+                                                   long *old_val,
+                                                   size_t old_val_len);
+
+     int             check_adslAtucThresh15MinESs(int type, long *val,
+                                                  size_t val_len,
+                                                  long *old_val,
+                                                  size_t old_val_len);
+     int             check_adslAtucThreshFastRateUp(int type, u_long * val,
+                                                    size_t val_len,
+                                                    u_long * old_val,
+                                                    size_t old_val_len);
+     int             check_adslAtucThreshInterleaveRateUp(int type,
+                                                          u_long * val,
+                                                          size_t val_len,
+                                                          u_long * old_val,
+                                                          size_t
+                                                          old_val_len);
+     int             check_adslAtucThreshFastRateDown(int type,
+                                                      u_long * val,
+                                                      size_t val_len,
+                                                      u_long * old_val,
+                                                      size_t old_val_len);
+     int             check_adslAtucThreshInterleaveRateDown(int type,
+                                                            u_long * val,
+                                                            size_t val_len,
+                                                            u_long *
+                                                            old_val,
+                                                            size_t
+                                                            old_val_len);
+     int             check_adslAturThresh15MinLofs(int type, long *val,
+                                                   size_t val_len,
+                                                   long *old_val,
+                                                   size_t old_val_len);
+     int             check_adslAturThresh15MinLoss(int type, long *val,
+                                                   size_t val_len,
+                                                   long *old_val,
+                                                   size_t old_val_len);
+     int             check_adslAturThresh15MinLprs(int type, long *val,
+                                                   size_t val_len,
+                                                   long *old_val,
+                                                   size_t old_val_len);
+     int             check_adslAturThresh15MinESs(int type, long *val,
+                                                  size_t val_len,
+                                                  long *old_val,
+                                                  size_t old_val_len);
+     int             check_adslAturThreshFastRateUp(int type, u_long * val,
+                                                    size_t val_len,
+                                                    u_long * old_val,
+                                                    size_t old_val_len);
+     int             check_adslAturThreshInterleaveRateUp(int type,
+                                                          u_long * val,
+                                                          size_t val_len,
+                                                          u_long * old_val,
+                                                          size_t
+                                                          old_val_len);
+     int             check_adslAturThreshFastRateDown(int type,
+                                                      u_long * val,
+                                                      size_t val_len,
+                                                      u_long * old_val,
+                                                      size_t old_val_len);
+     int             check_adslAturThreshInterleaveRateDown(int type,
+                                                            u_long * val,
+                                                            size_t val_len,
+                                                            u_long *
+                                                            old_val,
+                                                            size_t
+                                                            old_val_len);
+     int             check_adslLineAlarmConfProfileRowStatus(int type,
+                                                             long *val,
+                                                             size_t
+                                                             val_len,
+                                                             long *old_val,
+                                                             size_t
+                                                             old_val_len);
+#endif
+int
+check_adslAtucInitFailureTrapEnable(int type, long *val,
+                               size_t val_len, long *old_val,
+                               size_t old_val_len);
+
+#endif                          /* ADSLLINEALARMCONFPROFILETABLE_CHECKFNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns_local.c open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns_local.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns_local.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns_local.c	2009-12-16 12:59:29.000000000 +0530
@@ -0,0 +1,478 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslLineAlarmConfProfileTable_checkfns_local.c
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *               1) checking the dependency with other variables
+ *               2) Checking diff range and type checks other than the standard
+ *                  ones
+ *               3) User defined checks.These functions can be modified by the
+ *                  user.
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.check_values_local.conf,v 5.1 2003/05/30 23:53:15 hardaker Exp
+ * $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+/* standard headers */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include "adslLineAlarmConfProfileTable_checkfns.h"
+#include "adslLineAlarmConfProfileTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                          LOCAL FUNCTIONS
+ * ===========================================================================
+*/
+
+/** Decides if an incoming value for the adslAtucThresh15MinLofs mib node is
+ *  legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAtucThresh15MinLofs_local(int type, long *val, size_t val_len,
+                                    long *old_val, size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAtucThresh15MinLoss mib node is
+    legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAtucThresh15MinLoss_local(int type, long *val, size_t val_len,
+                                    long *old_val, size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+
+/** Decides if an incoming value for the adslAtucThresh15MinESs mib node is
+    legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAtucThresh15MinESs_local(int type, long *val, size_t val_len,
+                                   long *old_val, size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAtucThreshFastRateUp mib node is
+     legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAtucThreshFastRateUp_local(int type, u_long * val,
+                                     size_t val_len, u_long * old_val,
+                                     size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAtucThreshInterleaveRateUp mib
+    node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAtucThreshInterleaveRateUp_local(int type, u_long * val,
+                                           size_t val_len,
+                                           u_long * old_val,
+                                           size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAtucThreshFastRateDown mib node is
+    legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAtucThreshFastRateDown_local(int type, u_long * val,
+                                       size_t val_len, u_long * old_val,
+                                       size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAtucThreshInterleaveRateDown mib
+    node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAtucThreshInterleaveRateDown_local(int type, u_long * val,
+                                             size_t val_len,
+                                             u_long * old_val,
+                                             size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAtucInitFailureTrapEnable mib node
+    is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAtucInitFailureTrapEnable_local(int type, long *val,
+                                          size_t val_len, long *old_val,
+                                          size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThresh15MinLofs mib node is
+    legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAturThresh15MinLofs_local(int type, long *val, size_t val_len,
+                                    long *old_val, size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThresh15MinLoss mib node is
+    legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAturThresh15MinLoss_local(int type, long *val, size_t val_len,
+                                    long *old_val, size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThresh15MinLprs mib node is
+    legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAturThresh15MinLprs_local(int type, long *val, size_t val_len,
+                                    long *old_val, size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThresh15MinESs mib node is
+    legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAturThresh15MinESs_local(int type, long *val, size_t val_len,
+                                   long *old_val, size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThreshFastRateUp mib node is
+    legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAturThreshFastRateUp_local(int type, u_long * val,
+                                     size_t val_len, u_long * old_val,
+                                     size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThreshInterleaveRateUp mib node
+    is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAturThreshInterleaveRateUp_local(int type, u_long * val,
+                                           size_t val_len,
+                                           u_long * old_val,
+                                           size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThreshFastRateDown mib node is
+    legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAturThreshFastRateDown_local(int type, u_long * val,
+                                       size_t val_len, u_long * old_val,
+                                       size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslAturThreshInterleaveRateDown mib
+    node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslAturThreshInterleaveRateDown_local(int type, u_long * val,
+                                             size_t val_len,
+                                             u_long * old_val,
+                                             size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the adslLineAlarmConfProfileRowStatus mib
+    node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_adslLineAlarmConfProfileRowStatus_local(int type, long *val,
+                                              size_t val_len,
+                                              long *old_val,
+                                              size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns_local.h open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns_local.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns_local.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_checkfns_local.h	2009-12-16 12:59:29.000000000 +0530
@@ -0,0 +1,108 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslLineAlarmConfProfileTable_checkfns_local.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains prototypes for:
+ *               1) adslLineAlarmConfProfileTable_checkfns_local module
+ *
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : : mib2c.check_values_local.conf,v 5.1 2003/05/30 23:53:15 hardaker
+ * Exp $
+ *
+ */
+#ifndef ADSLLINEALARMCONFPROFILETABLE_CHECKFNS_H
+#define ADSLLINEALARMCONFPROFILETABLE_CHECKFNS_H
+
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+/*
+ * these functions are designed to check incoming values for
+ * columns in the adslLineAlarmConfProfileTable table for legality with respect
+ * to datatype and value according to local conventions.  You should modify
+ * them as appropriate.  They will be called from parent check_value
+ * functions that are auto-generated using mib2c and the parent functions
+ * should NOT be modified.
+ */
+
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+int             check_(int type, u_long * val, size_t val_len,
+                       u_long * old_val, size_t old_val_len);
+int             check_(int type, u_long * val, size_t val_len,
+                       u_long * old_val, size_t old_val_len);
+int             check_(int type, u_long * val, size_t val_len,
+                       u_long * old_val, size_t old_val_len);
+int             check_(int type, u_long * val, size_t val_len,
+                       u_long * old_val, size_t old_val_len);
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+int             check_(int type, u_long * val, size_t val_len,
+                       u_long * old_val, size_t old_val_len);
+int             check_(int type, u_long * val, size_t val_len,
+                       u_long * old_val, size_t old_val_len);
+int             check_(int type, u_long * val, size_t val_len,
+                       u_long * old_val, size_t old_val_len);
+int             check_(int type, u_long * val, size_t val_len,
+                       u_long * old_val, size_t old_val_len);
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+
+#endif                          /* ADSLLINEALARMCONFPROFILETABLE_CHECKFNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_columns.h	2009-12-16 12:59:29.000000000 +0530
@@ -0,0 +1,75 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslLineAlarmConfProfileTable_columns.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:  column number definitions for table adslLineAlarmConfProfileTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLLINEALARMCONFPROFILETABLE_COLUMNS_H
+#define ADSLLINEALARMCONFPROFILETABLE_COLUMNS_H
+
+/*
+ * column number definitions for table adslLineAlarmConfProfileTable
+ */
+#define COLUMN_ADSLLINEALARMCONFPROFILENAME     1
+#define COLUMN_ADSLATUCTHRESH15MINLOFS      2
+#define COLUMN_ADSLATUCTHRESH15MINLOSS      3
+#define COLUMN_ADSLATUCTHRESH15MINLOLS      4
+#define COLUMN_ADSLATUCTHRESH15MINLPRS      5
+#define COLUMN_ADSLATUCTHRESH15MINESS       6
+#define COLUMN_ADSLATUCTHRESHFASTRATEUP     7
+#define COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP       8
+#define COLUMN_ADSLATUCTHRESHFASTRATEDOWN       9
+#define COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN     10
+#define COLUMN_ADSLATUCINITFAILURETRAPENABLE        11
+#define COLUMN_ADSLATURTHRESH15MINLOFS      12
+#define COLUMN_ADSLATURTHRESH15MINLOSS      13
+#define COLUMN_ADSLATURTHRESH15MINLPRS      14
+#define COLUMN_ADSLATURTHRESH15MINESS       15
+#define COLUMN_ADSLATURTHRESHFASTRATEUP     16
+#define COLUMN_ADSLATURTHRESHINTERLEAVERATEUP       17
+#define COLUMN_ADSLATURTHRESHFASTRATEDOWN       18
+#define COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN     19
+#define COLUMN_ADSLLINEALARMCONFPROFILEROWSTATUS        20
+#endif                          /* ADSLLINEALARMCONFPROFILETABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable_enums.h	2009-12-16 12:59:29.000000000 +0530
@@ -0,0 +1,94 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslLineAlarmConfProfileTable_enums.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:  Constant definitions for table adslLineAlarmConfProfileTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLLINEALARMCONFPROFILETABLE_ENUMS_H
+#define ADSLLINEALARMCONFPROFILETABLE_ENUMS_H
+
+/*
+ * enums for column adslAtucInitFailureTrapEnable
+ */
+#define ADSLATUCINITFAILURETRAPENABLE_ENABLE        1
+#define ADSLATUCINITFAILURETRAPENABLE_DISABLE       2
+
+#ifdef STUB_IOCTL
+/* adslLineAlarmConfProfileTable constants */
+#define GET_ADSL_ALRM_CONF_PROF      120
+#define SET_ADSL_ALRM_CONF_PROF      121
+
+/* adslLineAlarmConfProfileTable Flags */
+#define ATUC_THRESH_15MIN_LOFS_FLAG         0x01   /* BIT 0th position */
+#define ATUC_THRESH_15MIN_LOSS_FLAG         0x02   /* BIT 1 */
+#define ATUC_THRESH_15MIN_ESS_FLAG          0x04   /* BIT 2 */
+#define ATUC_THRESH_FAST_RATEUP_FLAG        0x08   /* BIT 3 */
+#define ATUC_THRESH_INTERLEAVE_RATEUP_FLAG  0x10   /* BIT 4 */
+#define ATUC_THRESH_FAST_RATEDOWN_FLAG      0x20     /* BIT 5 */
+#define ATUC_THRESH_INTERLEAVE_RATEDOWN_FLAG  0x40 /* BIT 6 */
+#define ATUC_INIT_FAILURE_TRAP_ENABLE_FLAG  0x80    /* BIT 7 */
+#define ATUR_THRESH_15MIN_LOFS_FLAG         0x100   /* BIT 8 */
+#define ATUR_THRESH_15MIN_LOSS_FLAG         0x200   /* BIT 9 */
+#define ATUR_THRESH_15MIN_LPRS_FLAG         0x400   /* BIT 10 */
+#define ATUR_THRESH_15MIN_ESS_FLAG          0x800       /* BIT 11 */
+#define ATUR_THRESH_FAST_RATEUP_FLAG        0x1000      /* BIT 12 */
+#define ATUR_THRESH_INTERLEAVE_RATEUP_FLAG  0x2000      /* BIT 13 */
+#define ATUR_THRESH_FAST_RATEDOWN_FLAG      0x4000  /* BIT 14 */
+#define ATUR_THRESH_INTERLEAVE_RATEDOWN_FLAG    0x8000      /* BIT 15 */
+#define LINE_ALARM_CONF_PROFILE_ROWSTATUS_FLAG      0x10000     /* BIT 16 */
+#endif
+
+
+/*
+ * enums for column adslLineAlarmConfProfileRowStatus
+ */
+#define ADSLLINEALARMCONFPROFILEROWSTATUS_ACTIVE        1
+#define ADSLLINEALARMCONFPROFILEROWSTATUS_NOTINSERVICE      2
+#define ADSLLINEALARMCONFPROFILEROWSTATUS_NOTREADY      3
+#define ADSLLINEALARMCONFPROFILEROWSTATUS_CREATEANDGO       4
+#define ADSLLINEALARMCONFPROFILEROWSTATUS_CREATEANDWAIT     5
+#define ADSLLINEALARMCONFPROFILEROWSTATUS_DESTROY       6
+
+#endif                          /* ADSLLINEALARMCONFPROFILETABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable.c open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable.c	2009-12-16 12:59:29.000000000 +0530
@@ -0,0 +1,417 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineExtTable.c
+ * Author       : Subramani
+ * Date         : 11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Initializing the adslLineExtTable module
+ *                 2) Handling requests for the adslLineExtTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslLineExtTable.h"
+#include "adslLineExtTable_access.h"
+
+/*
+ * ===========================================================================
+ *                          GLOBAL DEFINITIONS
+ * ===========================================================================
+ */
+
+static netsnmp_oid_stash_node *undoStorage = NULL;
+static netsnmp_oid_stash_node *commitStorage = NULL;
+
+struct undoInfo {
+    void           *ptr;
+    size_t          len;
+};
+
+struct commitInfo {
+    void           *data_context;
+    int             have_committed;
+    int             new_row;
+};
+
+void
+adslLineExtTable_free_undoInfo(void *vptr)
+{
+    struct undoInfo *ui = vptr;
+    if (!ui)
+        return;
+    SNMP_FREE(ui->ptr);
+    SNMP_FREE(ui);
+}
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+/** Initialize the adslLineExtTable table by defining its contents and how
+    it's structured */
+void
+initialize_table_adslLineExtTable(void)
+{
+    static oid      adslLineExtTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 3, 1, 17 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler = netsnmp_create_handler_registration("adslLineExtTable",
+                                                     adslLineExtTable_handler,
+                                                     adslLineExtTable_oid,
+                                                     OID_LENGTH
+                                                     (adslLineExtTable_oid),
+                                                     HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo) {
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_adslLineExtTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 5;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point = adslLineExtTable_get_first_data_point;
+    iinfo->get_next_data_point = adslLineExtTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context = adslLineExtTable_context_convert_function;
+    iinfo->free_data_context = adslLineExtTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslLineExtTable_loop_free;
+    iinfo->free_loop_context_at_end = adslLineExtTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslLineExtTable",
+                "Registering table adslLineExtTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslLineExtTable module */
+void
+init_adslLineExtTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslLineExtTable();
+}
+
+/** handles requests for the adslLineExtTable table, if anything else needs to
+     be done */
+int
+adslLineExtTable_handler(netsnmp_mib_handler *handler,
+                         netsnmp_handler_registration *reginfo,
+                         netsnmp_agent_request_info *reqinfo,
+                         netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+    oid            *suffix;
+    size_t          suffix_len;
+
+    /** column and row index encoded portion */
+    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
+    suffix_len = requests->requestvb->name_length -
+        (reginfo->rootoid_len + 1);
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+        case MODE_SET_RESERVE1:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+            break;
+
+        default:               /* == the other SET modes */
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+            break;
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+    	    case COLUMN_ADSLLINETRANSATUCCAP:
+    	    case COLUMN_ADSLLINETRANSATUCCONFIG:
+    	    case COLUMN_ADSLLINETRANSATUCACTUAL:
+    	    case COLUMN_ADSLLINEGLITEPOWERSTATE:
+                {
+                    int           *retval;
+                    size_t         retval_len = 0;
+                    retval =
+                        get_adslLineExtData(data_context, &retval_len,
+					table_info->colnum);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+
+           default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+        "problem encountered in adslLineExtTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+
+            if (!ci) {
+                    /** create the commit storage info */
+                ci = SNMP_MALLOC_STRUCT(commitInfo);
+                if (!data_context) {
+                    ci->data_context =
+                        adslLineExtTable_create_data_context(table_info->
+                                                             indexes);
+                    ci->new_row = 1;
+                } else {
+                    ci->data_context = data_context;
+                }
+                netsnmp_oid_stash_add_data(&commitStorage,
+                                           suffix + 1, suffix_len - 1, ci);
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            switch (table_info->colnum) {
+            case COLUMN_ADSLLINETRANSATUCCONFIG:
+                {
+                    int           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_adslLineExtData(ci->data_context, &retval_len,
+					table_info->colnum);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+		if ((char *) request->requestvb->val.string == NULL)
+			ret = SNMP_ERR_GENERR;
+		else if (request->requestvb->type != ASN_INTEGER)
+			ret = SNMP_ERR_WRONGTYPE;
+		else
+			ret = SNMP_ERR_NOERROR;	
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        adslLineExtTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+
+            default:
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_ERR_NOTWRITABLE);
+                break;
+            }
+            break;
+
+        case MODE_SET_ACTION:
+            /** save a variable copy */
+            switch (table_info->colnum) {
+            case COLUMN_ADSLLINETRANSATUCCONFIG:
+                {
+                    int             ret;
+                    ret = set_adslLineTransAtucConfig(ci->data_context,
+                                                      (char *) request->
+                                                      requestvb->val.
+                                                      string,
+                                                      request->requestvb->
+                                                      val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            if (!ci->have_committed) {
+                    /** do this once per row only */
+                adslLineExtTable_commit_row(&ci->data_context,
+                                            ci->new_row);
+                ci->have_committed = 1;
+            }
+            break;
+
+        case MODE_SET_UNDO:
+             /** save a variable copy */
+            switch (table_info->colnum) {
+            case COLUMN_ADSLLINETRANSATUCCONFIG:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_adslLineTransAtucConfig(ci->data_context,
+                                                    ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+
+            }
+            break;
+
+        case MODE_SET_FREE:
+            break;
+
+        default:
+            snmp_log(LOG_ERR,
+    "problem encountered in adslLineExtTable_handler: unsupported mode\n");
+        }
+    }
+
+    /** clean up after all requset processing has ended */
+    switch (reqinfo->mode) {
+    case MODE_SET_UNDO:
+    case MODE_SET_FREE:
+    case MODE_SET_COMMIT:
+        /** clear out the undo cache */
+        netsnmp_oid_stash_free(&undoStorage,
+                               adslLineExtTable_free_undoInfo);
+        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable.h open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable.h	2009-12-16 12:59:30.000000000 +0530
@@ -0,0 +1,78 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineExtTable.h
+ * Author       : Subramani
+ * Date         : 11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) Include files
+ *                 2) Init Function proto-types
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLLINEEXTTABLE_H
+#define ADSLLINEEXTTABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+
+/** other required module components */
+config_require(adslMIB/adslLineExtTable/adslLineExtTable_access)
+
+/*
+ * column number definitions for table adslLineExtTable
+ */
+#include "adslLineExtTable_columns.h"
+
+/*
+ * enum definions
+ */
+#include "adslLineExtTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+*/
+
+    /*
+     * function declarations
+     */
+     void            init_adslLineExtTable(void);
+     void            initialize_table_adslLineExtTable(void);
+     Netsnmp_Node_Handler adslLineExtTable_handler;
+
+
+#endif /** ADSLLINEEXTTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_access.c open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_access.c	2009-12-16 12:59:30.000000000 +0530
@@ -0,0 +1,353 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineExtTable_access.c
+ * Author       : Subramani
+ * Date         : 11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Getting the data context pointer & loop context pointer
+ *                 2) User-defined data access functions (per column) for data
+ *                    in table adslLineExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslLineExtTable_access.h"
+#include "adslLineExtTable_enums.h"
+
+/* column number definitions for table adslLineExtTable */
+#include "adslLineExtTable_columns.h"
+/*
+ * ===========================================================================
+ *                           GLOBAL DEFINITIONS
+ * ===========================================================================
+ */
+// *** Global variable definitions
+static long long_ret;
+
+//typedef struct adslLineExtTableEntry adslLineTableExtEntry; 
+//struct adslLineExtTableEntry adslLineTableExt;
+ 
+#ifndef ENABLE_DRIVER_CALL
+
+static int adslLineTransAtucCap = 2;
+static int adslLineTransAtucConfig = 4;
+static int adslLineTransAtucActual = 6;
+static int adslLineGlitePowerState = 8;
+
+#endif
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+
+/** returns the first data point within the adslLineExtTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslLineExtTable_get_first_data_point(void **my_loop_context,
+                                      void **my_data_context,
+                                      netsnmp_variable_list *
+                                      put_index_data,
+                                      netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+        "Get-First: adslLineExtTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** functionally the same as adslLineExtTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslLineExtTable_get_next_data_point(void **my_loop_context,
+                                     void **my_data_context,
+                                     netsnmp_variable_list *
+                                     put_index_data,
+                                     netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR,
+        "Get-Next: adslLineExtTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+/** Create a data_context for non-existent rows that SETs are performed on.
+ *  return a void * pointer which will be passed to subsequent get_XXX
+ *  and set_XXX functions for data retrival and modification during
+ *  this SET request.
+ *
+ *  The indexs are encoded (in order) into the index_data pointer if it
+ *  would be helpful to use that information.
+ */
+void           *
+adslLineExtTable_create_data_context(netsnmp_variable_list * index_data)
+{
+    return NULL;            /* XXX: you likely want to return a real pointer */
+}
+
+/** If the implemented set_* functions don't operate directly on the
+   real-live data (which is actually recommended), then this function
+   can be used to take a given my_data_context pointer and "commit" it
+   to whereever the modified data needs to be put back to.  For
+   example, if this was a routing table you could publish the modified
+   routes back into the kernel at this point.
+
+   new_or_del will be set to 1 if new, or -1 if it should be deleted
+   or 0 if it is just a modification of an existing row.
+
+   If you free the data yourself, make sure to *my_data_context = NULL */
+int
+adslLineExtTable_commit_row(void **my_data_context, int new_or_del)
+{
+    /** Add any necessary commit code here */
+    /**/
+
+    /*
+     * return no errors.  And there shouldn't be any!!!  Ever!!!  You
+     * should have checked the values long before this.
+     */
+    return SNMP_ERR_NOERROR;
+}
+
+
+/*
+ * User-defined data access functions (per column) for data in table
+   adslLineExtTable  */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+/** XXX: return a data pointer to the data for the adslLineTransAtucCap column
+    and set ret_len to its proper size in bytes. */
+
+int           *
+get_adslLineExtData(void *data_context, size_t * ret_len,
+		unsigned int var)
+{
+  unsigned int flags = 0;
+  struct adslLineExtTableEntry adslLineTableExtStruct;
+  memset(&adslLineTableExtStruct,0,sizeof(adslLineTableExtStruct));
+  adslLineTableExtStruct.ifIndex=*((int *)data_context);
+   
+  switch (var) {
+
+    case COLUMN_ADSLLINETRANSATUCCAP:
+  	flags = ATUC_LINE_TRANS_CAP_FLAG;
+        break;
+	
+    case COLUMN_ADSLLINETRANSATUCCONFIG:
+	flags = ATUC_LINE_TRANS_CONFIG_FLAG;
+	break;
+	
+    case COLUMN_ADSLLINETRANSATUCACTUAL:
+	flags = ATUC_LINE_TRANS_ACTUAL_FLAG;
+	break;
+	
+    case COLUMN_ADSLLINEGLITEPOWERSTATE:
+	flags = LINE_GLITE_POWER_STATE_FLAG;
+	break;
+
+    default:
+     	DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+        return NULL;
+  }
+
+  SET_FLAG(&adslLineTableExtStruct.flags, flags);
+
+#ifdef ENABLE_DRIVER_CALL
+  adsl_ioctl(Fd, GET_ADSL_ATUC_LINE_EXT , (void *)&adslLineTableExtStruct);
+#else
+     get_adslLineExtTable(Fd, GET_ADSL_ATUC_LINE_EXT ,
+     			(void *)&adslLineTableExtStruct);
+#endif
+  if (IS_FLAG_SET(&adslLineTableExtStruct.flags,flags) == 0) 
+    DEBUGMSGTL(("adslMIB-Line", "Line-Ext-Table: GET- %x CMV fail\n", flags));
+
+    switch (flags)  {
+
+	 case ATUC_LINE_TRANS_CAP_FLAG:
+    	    long_ret = adslLineTableExtStruct.adslLineTransAtucCap;
+            break;
+	 
+	 case ATUC_LINE_TRANS_CONFIG_FLAG:
+    	    long_ret = adslLineTableExtStruct.adslLineTransAtucConfig;
+	    break;
+	  
+	 case ATUC_LINE_TRANS_ACTUAL_FLAG:
+    	    long_ret = adslLineTableExtStruct.adslLineTransAtucActual;
+	    break;
+	  
+	 case LINE_GLITE_POWER_STATE_FLAG:
+    	    long_ret = adslLineTableExtStruct.adslLineGlitePowerState;
+	    break;
+	  
+         default:
+     	    DEBUGMSGTL(("Unknown MIB variable requested!", "\n"));
+            return NULL;
+     }
+
+    CLR_FLAG(&adslLineTableExtStruct.flags, flags);
+    *ret_len = sizeof(int);
+    return (int *) &long_ret;
+}
+
+
+/** XXX: Set the value of the adslLineTransAtucConfig column and return
+         SNMPERR_SUCCESS on success
+         SNMPERR_XXX     for SNMP deterministic error codes
+         SNMPERR_GENERR  on generic failures (a last result response). */
+int
+set_adslLineTransAtucConfig(void *data_context, char *val, size_t val_len)
+{
+    struct adslLineExtTableEntry adslLineTableExtStruct;
+    memset(&adslLineTableExtStruct,0,sizeof(adslLineTableExtStruct));
+    adslLineTableExtStruct.ifIndex=*((int *)data_context);
+    adslLineTableExtStruct.adslLineTransAtucConfig =*val;
+    SET_FLAG(&adslLineTableExtStruct.flags,ATUC_LINE_TRANS_CONFIG_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+    adsl_ioctl(Fd, SET_ADSL_ATUC_LINE_EXT, (void *)&adslLineTableExtStruct);
+#else
+    set_adslLineExtTable(Fd, SET_ADSL_ATUC_LINE_EXT,
+    			(void *)&adslLineTableExtStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineTableExtStruct.flags,
+    			ATUC_LINE_TRANS_CONFIG_FLAG) == 0) {
+	CLR_FLAG(&adslLineTableExtStruct.flags, ATUC_LINE_TRANS_CONFIG_FLAG);
+        DEBUGMSGTL(("adslMIB-Line", "Set adslLineTransAtucConfig CMV fail\n"));
+        return SNMP_ERR_COMMITFAILED;
+     } 
+     else {
+	CLR_FLAG(&adslLineTableExtStruct.flags, ATUC_LINE_TRANS_CONFIG_FLAG);
+	 return SNMP_ERR_NOERROR;
+     }
+}
+
+
+#ifndef ENABLE_DRIVER_CALL
+
+int get_adslLineExtTable(int Fd2, int Adsl_Line_CODE,void *adslLineExtTable)
+{
+   struct adslLineExtTableEntry *adslLineTableExtValue;
+   adslLineTableExtValue = (adslLineTableExtEntry *)adslLineExtTable;
+   adslLineTableExtValue->adslLineTransAtucCap = adslLineTransAtucCap;
+   adslLineTableExtValue->adslLineTransAtucConfig = adslLineTransAtucConfig;
+   adslLineTableExtValue->adslLineTransAtucActual = adslLineTransAtucActual;
+   adslLineTableExtValue->adslLineGlitePowerState = adslLineGlitePowerState;
+   return 0;
+ }
+
+
+int set_adslLineExtTable(int Fd2, int Adsl_Line_CODE,void *adslLineExtTable)
+{
+   struct adslLineExtTableEntry *adslLineTableExtValue;
+   adslLineTableExtValue = (adslLineTableExtEntry *)adslLineExtTable;
+
+   adslLineTransAtucConfig = adslLineTableExtValue->adslLineTransAtucConfig;
+   return 0;
+ }
+#endif
+
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_access.h open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_access.h	2009-12-16 12:59:30.000000000 +0530
@@ -0,0 +1,109 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineExtTable_access.h
+ * Author       : Subramani
+ * Date         : 11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) User-defined data structure for accessing adslLineExtTable
+ *                 2) User-defined data access functions for data in table
+ *                    adslLineExtTable
+ *                 3) Column accessors functions
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+#ifndef ADSLLINEEXTTABLE_ACCESS_H
+#define ADSLLINEEXTTABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                           USER-DEFINED DATA TYPES
+ * ===========================================================================
+ */
+
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslLineExtTable **/
+typedef struct adslLineExtTableEntry {
+
+  int ifIndex;
+  int adslLineTransAtucCap;
+  int adslLineTransAtucConfig;
+  int adslLineTransAtucActual;
+  int adslLineGlitePowerState;
+  u_int32	 flags;
+
+} adslLineExtTableEntry;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+/** User-defined data access functions for data in table adslLineExtTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslLineExtTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslLineExtTable_get_next_data_point;
+
+int             adslLineExtTable_commit_row(void **my_data_context,
+                                            int new_or_del);
+void           *adslLineExtTable_create_data_context(netsnmp_variable_list
+                                                     * index_data);
+int           *get_adslLineExtData(void *data_context, size_t *ret_len,
+				unsigned int var);
+
+int           set_adslLineTransAtucConfig(void *data_context, char *val,
+                                            size_t val_len);
+#ifndef ENABLE_DRIVER_CALL
+
+int get_adslLineExtTable(int Fd2, int Adsl_Line_CODE,void *adslLineExtTable);
+
+int set_adslLineExtTable(int Fd2, int Adsl_Line_CODE,void *adslLineExtTable);
+
+#endif
+#endif                          /* ADSLLINEEXTTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_columns.h	2009-12-16 12:59:30.000000000 +0530
@@ -0,0 +1,60 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineExtTable_columns.h
+ * Author       : Subramani
+ * Date         : 11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) column number definitions for table adslLineExtTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLLINEEXTTABLE_COLUMNS_H
+#define ADSLLINEEXTTABLE_COLUMNS_H
+
+/*
+ * column number definitions for table adslLineExtTable
+ */
+#define COLUMN_ADSLLINETRANSATUCCAP		1
+#define COLUMN_ADSLLINETRANSATUCCONFIG		2
+#define COLUMN_ADSLLINETRANSATUCACTUAL		3
+#define COLUMN_ADSLLINEGLITEPOWERSTATE		4
+#define COLUMN_ADSLLINECONFPROFILEDUALLITE		5
+#endif                          /* ADSLLINEEXTTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineExtTable/adslLineExtTable_enums.h	2009-12-16 12:59:30.000000000 +0530
@@ -0,0 +1,127 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineExtTable_enums.h
+ * Author       : Subramani
+ * Date         : 11-Oct-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) adslLineExtTable constants
+ *                 2) adslLineExtTable Flags
+ *                 3) enums for adslLineExtTable
+ *
+ * ===========================================================================
+ * References: RFC 3440
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLLINEEXTTABLE_ENUMS_H
+#define ADSLLINEEXTTABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+
+/* adslLineExtTable constants */
+#define GET_ADSL_ATUC_LINE_EXT 201
+#define SET_ADSL_ATUC_LINE_EXT 203
+
+
+/* adslLineExtTable flags */
+#define ATUC_LINE_TRANS_CAP_FLAG	 	0x1	/* BIT 0th position */
+#define ATUC_LINE_TRANS_CONFIG_FLAG	 	0x2		/* BIT 1 */
+#define ATUC_LINE_TRANS_ACTUAL_FLAG	 	0x4		/* BIT 2 */
+#define LINE_GLITE_POWER_STATE_FLAG 	0x8		/* BIT 3 */
+
+
+#endif
+
+/*
+ * enums for column adslLineTransAtucCap
+ */
+#define ADSLLINETRANSATUCCAP_ANSIT1413		0
+#define ADSLLINETRANSATUCCAP_ETSI		1
+#define ADSLLINETRANSATUCCAP_Q9921POTSNONOVERLAPPED		2
+#define ADSLLINETRANSATUCCAP_Q9921POTSOVERLAPPED		3
+#define ADSLLINETRANSATUCCAP_Q9921ISDNNONOVERLAPPED		4
+#define ADSLLINETRANSATUCCAP_Q9921ISDNOVERLAPPED		5
+#define ADSLLINETRANSATUCCAP_Q9921TCMISDNNONOVERLAPPED		6
+#define ADSLLINETRANSATUCCAP_Q9921TCMISDNOVERLAPPED		7
+#define ADSLLINETRANSATUCCAP_Q9922POTSNONOVERLAPEED		8
+#define ADSLLINETRANSATUCCAP_Q9922POTSOVERLAPPED		9
+#define ADSLLINETRANSATUCCAP_Q9922TCMISDNNONOVERLAPPED		10
+#define ADSLLINETRANSATUCCAP_Q9922TCMISDNOVERLAPPED		11
+#define ADSLLINETRANSATUCCAP_Q9921TCMISDNSYMMETRIC		12
+
+/*
+ * enums for column adslLineTransAtucConfig
+ */
+#define ADSLLINETRANSATUCCONFIG_ANSIT1413		0
+#define ADSLLINETRANSATUCCONFIG_ETSI		1
+#define ADSLLINETRANSATUCCONFIG_Q9921POTSNONOVERLAPPED		2
+#define ADSLLINETRANSATUCCONFIG_Q9921POTSOVERLAPPED		3
+#define ADSLLINETRANSATUCCONFIG_Q9921ISDNNONOVERLAPPED		4
+#define ADSLLINETRANSATUCCONFIG_Q9921ISDNOVERLAPPED		5
+#define ADSLLINETRANSATUCCONFIG_Q9921TCMISDNNONOVERLAPPED		6
+#define ADSLLINETRANSATUCCONFIG_Q9921TCMISDNOVERLAPPED		7
+#define ADSLLINETRANSATUCCONFIG_Q9922POTSNONOVERLAPEED		8
+#define ADSLLINETRANSATUCCONFIG_Q9922POTSOVERLAPPED		9
+#define ADSLLINETRANSATUCCONFIG_Q9922TCMISDNNONOVERLAPPED		10
+#define ADSLLINETRANSATUCCONFIG_Q9922TCMISDNOVERLAPPED		11
+#define ADSLLINETRANSATUCCONFIG_Q9921TCMISDNSYMMETRIC		12
+
+/*
+ * enums for column adslLineTransAtucActual
+ */
+#define ADSLLINETRANSATUCACTUAL_ANSIT1413		0
+#define ADSLLINETRANSATUCACTUAL_ETSI		1
+#define ADSLLINETRANSATUCACTUAL_Q9921POTSNONOVERLAPPED		2
+#define ADSLLINETRANSATUCACTUAL_Q9921POTSOVERLAPPED		3
+#define ADSLLINETRANSATUCACTUAL_Q9921ISDNNONOVERLAPPED		4
+#define ADSLLINETRANSATUCACTUAL_Q9921ISDNOVERLAPPED		5
+#define ADSLLINETRANSATUCACTUAL_Q9921TCMISDNNONOVERLAPPED		6
+#define ADSLLINETRANSATUCACTUAL_Q9921TCMISDNOVERLAPPED		7
+#define ADSLLINETRANSATUCACTUAL_Q9922POTSNONOVERLAPEED		8
+#define ADSLLINETRANSATUCACTUAL_Q9922POTSOVERLAPPED		9
+#define ADSLLINETRANSATUCACTUAL_Q9922TCMISDNNONOVERLAPPED		10
+#define ADSLLINETRANSATUCACTUAL_Q9922TCMISDNOVERLAPPED		11
+#define ADSLLINETRANSATUCACTUAL_Q9921TCMISDNSYMMETRIC		12
+
+/*
+ * enums for column adslLineGlitePowerState
+ */
+#define ADSLLINEGLITEPOWERSTATE_NONE		1
+#define ADSLLINEGLITEPOWERSTATE_L0		2
+#define ADSLLINEGLITEPOWERSTATE_L1		3
+#define ADSLLINEGLITEPOWERSTATE_L3		4
+
+#endif                          /* ADSLLINEEXTTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable.c open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable.c	2009-12-16 12:59:30.000000000 +0530
@@ -0,0 +1,236 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineTable.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Initializing the adslLineTable module
+ *                 2) Handling requests for the adslLineTable table
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslLineTable.h"
+#include "adslLineTable_access.h"
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+/** Initialize the adslLineTable table by defining its contents and how
+    it's structured */
+void
+initialize_table_adslLineTable(void)
+{
+    static oid      adslLineTable_oid[] =
+        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 1 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler = netsnmp_create_handler_registration("adslLineTable",
+                                                     adslLineTable_handler,
+                                                     adslLineTable_oid,
+                                                     OID_LENGTH
+                                                     (adslLineTable_oid),
+                                                     HANDLER_CAN_RONLY);
+
+    if (!my_handler || !table_info || !iinfo) {
+
+#ifdef ADSL_MIB_MEM_LEAK_FIX
+         if (my_handler)
+            SNMP_FREE(my_handler);
+         if (table_info)
+            SNMP_FREE(table_info);
+          if (iinfo)
+            SNMP_FREE(iinfo);
+#endif
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_adslLineTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 1;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point = adslLineTable_get_first_data_point;
+    iinfo->get_next_data_point = adslLineTable_get_next_data_point;
+
+    /** you may wish to set these as well */
+#ifdef MAYBE_USE_THESE
+    iinfo->make_data_context = adslLineTable_context_convert_function;
+    iinfo->free_data_context = adslLineTable_data_free;
+
+    /** pick *only* one of these if you use them */
+    iinfo->free_loop_context = adslLineTable_loop_free;
+    iinfo->free_loop_context_at_end = adslLineTable_loop_free;
+#endif
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_adslLineTable",
+                "Registering table adslLineTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the adslLineTable module */
+void
+init_adslLineTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_adslLineTable();
+}
+
+/** handles requests for the adslLineTable table, if anything else
+    needs to be done */
+int
+adslLineTable_handler(netsnmp_mib_handler *handler,
+                      netsnmp_handler_registration *reginfo,
+                      netsnmp_agent_request_info *reqinfo,
+                      netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+    void *data_context = NULL;
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = dev_open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return SNMP_ERR_GENERR;
+    }
+#endif
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_ADSLLINECODING:
+                {
+                      int           *retval1;
+                    size_t          retval_len = 0;
+                    retval1 = get_adslLineCoding(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval1,
+                                             retval_len);
+                }
+                break;
+
+        default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                         "problem encountered in adslLineTable_handler: \
+                          unknown column\n");
+            }
+            break;
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in adslLineTable_handler: unsupported\
+                      mode\n");
+        }
+    }
+
+#ifdef ENABLE_DRIVER_CALL
+    dev_close(Fd);
+#endif
+
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable.h open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable.h	2009-12-16 12:59:30.000000000 +0530
@@ -0,0 +1,76 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineTable.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) Include files
+ *                 2) Init Function proto-types
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef ADSLLINETABLE_H
+#define ADSLLINETABLE_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+
+/** other required module components */
+config_require(adslMIB/adslLineTable/adslLineTable_access)
+
+/* column number definitions for table adslLineTable */
+#include "adslLineTable_columns.h"
+
+/*enum definions */
+#include "adslLineTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+   /* function declarations */
+void    init_adslLineTable(void);
+void    initialize_table_adslLineTable(void);
+Netsnmp_Node_Handler adslLineTable_handler;
+
+#endif /** ADSLLINETABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_access.c open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_access.c	2009-12-16 12:59:30.000000000 +0530
@@ -0,0 +1,204 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineTable_access.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Getting the data context pointer & loop context pointer
+ *                 2) User-defined data access functions (per column) for data
+ *                    in table adslLineTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslLineTable_access.h"
+#include "adslLineTable_enums.h"
+
+/*
+ * ===========================================================================
+ *                           GLOBAL DEFINITIONS
+ * ===========================================================================
+ */
+// *** Global variable definitions
+static long long_ret;
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+
+/** returns the first data point within the adslLineTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslLineTable_get_first_data_point(void **my_loop_context,
+                                   void **my_data_context,
+                                   netsnmp_variable_list * put_index_data,
+                                   netsnmp_iterator_info *mydata)
+{
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-First: adslLineTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+    put_index_data = adslTable_get_first_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+
+}
+
+/** functionally the same as adslLineTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslLineTable_get_next_data_point(void **my_loop_context,
+                                  void **my_data_context,
+                                  netsnmp_variable_list * put_index_data,
+                                  netsnmp_iterator_info *mydata)
+{
+
+/* Go the data point where the my_loop_context pointer points to
+   Search for the next adsl entry in the IfTable
+   Update the put_index_data,loop_context and data_context pointers
+*/
+
+    int *My_Data_Context;
+    My_Data_Context = SNMP_MALLOC_TYPEDEF(int);
+    if (!My_Data_Context) {
+        put_index_data = NULL;
+        snmp_log(LOG_ERR, "Get-Next: adslLineTable: My_Data_Context malloc failed\n");
+        return put_index_data;
+    }
+    *My_Data_Context=IFTYPE_ADSL;
+    *my_data_context=My_Data_Context;
+
+     put_index_data = adslTable_get_next_data_point(my_loop_context,
+                                   my_data_context,
+                                   put_index_data,
+                                   mydata);
+
+    SNMP_FREE(My_Data_Context);
+    return put_index_data;
+}
+
+
+/*  User-defined data access functions (per column) for data in table
+    adslLineTable */
+/*
+ * NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+/** XXX: return a data pointer to the data for the adslLineCoding column and set
+         ret_len to its proper size in bytes. */
+int           *
+get_adslLineCoding(void *data_context, size_t * ret_len)
+{
+
+    struct adslLineTableEntry adslLineTableStruct;
+    memset(&adslLineTableStruct,0,sizeof(adslLineTableEntry));
+    adslLineTableStruct.ifIndex=*((int *)data_context);
+    SET_FLAG(&adslLineTableStruct.flags,LINE_CODE_FLAG);
+
+#ifdef ENABLE_DRIVER_CALL
+     adsl_ioctl(Fd, GET_ADSL_LINE_CODE, (void *)&adslLineTableStruct);
+#else
+     get_adslLineTable(Fd, GET_ADSL_LINE_CODE,(void *)&adslLineTableStruct);
+#endif
+    if (IS_FLAG_SET(&adslLineTableStruct.flags, LINE_CODE_FLAG) == 0)
+        DEBUGMSGTL(("adslMIB-Line", "LineCode CMV fail\n"));
+
+    CLR_FLAG(&adslLineTableStruct.flags, LINE_CODE_FLAG);
+    long_ret = adslLineTableStruct.adslLineCode;
+    *ret_len = sizeof(adslLineTableStruct.adslLineCode);
+    return (int *) &long_ret;
+}
+
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslLineTable(int Fd2, int Adsl_Line_CODE,void *adslLineTable)
+{
+   struct adslLineTableEntry *adslLineTableValue;
+   adslLineTableValue = (adslLineTableEntry *)adslLineTable;
+   adslLineTableValue->adslLineCode = 2;
+   return 0;
+ }
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_access.h open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_access.h	2009-12-16 12:59:30.000000000 +0530
@@ -0,0 +1,94 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineTable_access.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) User-defined data structure for accessing adslLineTable
+ *                 2) User-defined data access functions for data in table
+ *                    adslLineTable
+ *                 3) Column accessors functions
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+#ifndef ADSLLINETABLE_ACCESS_H
+#define ADSLLINETABLE_ACCESS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                           USER-DEFINED DATA TYPES
+ * ===========================================================================
+ */
+
+#ifdef STUB_IOCTL
+/** User-defined data structure for accessing adslLineTable **/
+typedef struct adslLineTableEntry {
+    int ifIndex;
+    int adslLineCode;
+    u_char flags;
+} adslLineTableEntry;
+#endif
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+/** User-defined data access functions for data in table adslLineTable */
+/** row level accessors */
+Netsnmp_First_Data_Point adslLineTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslLineTable_get_next_data_point;
+
+/** column accessors */
+int  *get_adslLineCoding(void *data_context, size_t * ret_len);
+
+#ifndef ENABLE_DRIVER_CALL
+int get_adslLineTable(int Fd2, int Adsl_Line_CODE,void *adslLineTable);
+#endif
+
+#endif                          /* ADSLLINETABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_columns.h open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_columns.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_columns.h	2009-12-16 12:59:31.000000000 +0530
@@ -0,0 +1,57 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineTable_columns.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) column number definitions for table adslLineTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef ADSLLINETABLE_COLUMNS_H
+#define ADSLLINETABLE_COLUMNS_H
+
+/* column number definitions for table adslLineTable */
+#define COLUMN_ADSLLINECODING       1
+#define COLUMN_ADSLLINETYPE         2
+#define COLUMN_ADSLLINESPECIFIC     3
+#define COLUMN_ADSLLINECONFPROFILE  4
+#define COLUMN_ADSLLINEALARMCONFPROFILE     5
+#endif                          /* ADSLLINETABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_enums.h open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_enums.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslLineTable/adslLineTable_enums.h	2009-12-16 12:59:31.000000000 +0530
@@ -0,0 +1,72 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslLineTable_enums.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) adslLineTable constants
+ *                 2) adslLineCode Flags
+ *                 3) enums for column adslLineType and adslLineCoding
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef ADSLLINETABLE_ENUMS_H
+#define ADSLLINETABLE_ENUMS_H
+
+#ifdef STUB_IOCTL
+/* adslLineTable constants */
+#define GET_ADSL_LINE_CODE      1
+
+/* adslLineCode Flags */
+#define LINE_CODE_FLAG      0x1 /* BIT 0th position */
+#endif
+
+/* enums for column adslLineCoding */
+#define ADSLLINECODING_OTHER    1
+#define ADSLLINECODING_DMT      2
+#define ADSLLINECODING_CAP      3
+#define ADSLLINECODING_QAM      4
+
+/* enums for column adslLineType */
+#define ADSLLINETYPE_NOCHANNEL          1
+#define ADSLLINETYPE_FASTONLY           2
+#define ADSLLINETYPE_INTERLEAVEDONLY    3
+#define ADSLLINETYPE_FASTORINTERLEAVED  4
+#define ADSLLINETYPE_FASTANDINTERLEAVED 5
+
+#endif                          /* ADSLLINETABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslTable_access.c open_snmp/agent/mibgroup/adslMIB/adslTable_access.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslTable_access.c	2009-12-16 12:59:31.000000000 +0530
@@ -0,0 +1,588 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslTable_access.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Getting the data context pointer & loop context pointer
+ *                 2) Return the IfType of an IfEntry in the IfTable
+ *                 3) Return the Number of interfaces in the IfTable
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+/************************* Important Points *************/
+/* There will be two interfaces registered in the interface table of
+*  Kernel by adslDriver one as interface type "adsl" other as "Fast"
+*  We will be always getting the IfIndex based on interface name
+*  This logic is not suitable for multiple adsl Interfaces
+*/
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "adslTable_access.h"
+#include <linux/socket.h>
+#include <linux/if.h>
+#include <linux/sockios.h>
+
+/*
+ * ===========================================================================
+ *                           GLOBAL DEFINITIONS
+ * ===========================================================================
+ */
+// *** Global variable definitions
+
+/*
+ * ===========================================================================
+ *                           EXPORTED FUNCTIONS
+ * ===========================================================================
+ */
+
+/* This is used, because the ADSL-MIB augments ifTable */
+extern unsigned char *var_ifEntry(struct variable *,
+                                  oid *, size_t *,
+                                  int, size_t *, WriteMethod **);
+extern  unsigned char *var_interfaces(struct variable * ,
+                                oid * ,size_t * ,
+                                int , size_t * , WriteMethod ** );
+
+
+/*
+ * ===========================================================================
+ *                           GLOBAL FUNCTIONS
+ * ===========================================================================
+ */
+/** returns the first data point within the adslLineTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+adslTable_get_first_data_point(void **my_loop_context,
+                                   void **my_data_context,
+                                   netsnmp_variable_list *put_index_data,
+                                   netsnmp_iterator_info *mydata)
+{
+
+/*  Find the Total No. of entries in IfTable
+    Find the first adsl Entry in the IfTable
+    Update loop_context,data_context and put_index_data variables
+*/
+
+
+    int i , p ,interface_count,incr_position;
+	int adsl_if_available = 0;
+
+    netsnmp_variable_list *vptr;
+    interface_count = i = p = 0;
+
+     if (!position) {
+        position = SNMP_MALLOC_TYPEDEF(int);
+        if (!position)
+            return NULL;
+     }
+
+     if (!Data_Context) {
+        Data_Context = SNMP_MALLOC_TYPEDEF(int);
+        if (!Data_Context) {
+           SNMP_FREE(position);
+           return NULL;
+	}
+     }
+
+    interface_count = GetNoInterfaces();
+    *position = 0;
+    if(!interface_count) {
+        SNMP_FREE(position);
+        SNMP_FREE(Data_Context);
+        return NULL;
+    }
+
+    // Check wether Interfaces start with 0 or 1
+    for (i=1;i<= interface_count;i++) {
+         p = GetType(i);
+         if (p != 0 && (p == (*(int *)(*my_data_context))))  {
+			    adsl_if_available = 1;
+                *Data_Context = i;
+                *my_loop_context = position;
+                *my_data_context = Data_Context;
+                 break;
+          } 
+	  else if (p != 0 && (IFTYPE_ADSL_FAST_INTERLEAVE ==
+                             (*(int *)(*my_data_context))))   {
+               	if(p == IFTYPE_ADSL_INTERLEAVE ||
+                       	p == IFTYPE_ADSL_FAST )  {
+			        adsl_if_available = 1;
+                  	*Data_Context = i;
+                  	*my_loop_context = position;
+                  	*my_data_context = Data_Context;
+                     break;
+                }
+          }
+    }
+
+	if (!adsl_if_available)
+	 return NULL;
+
+    vptr = put_index_data;
+    snmp_set_var_value(vptr, (u_char *) Data_Context ,sizeof (*Data_Context));
+    return put_index_data;
+}
+
+
+/* For adslLineAlarmConfProfileTable to get first data point */
+netsnmp_variable_list *
+adslAlarmTable_get_first_data_point(void **my_loop_context,
+                                   void **my_data_context,
+                                   netsnmp_variable_list *put_index_data,
+                                   netsnmp_iterator_info *mydata)
+{
+
+/*  Find the Total No. of entries in IfTable
+    Find the first adsl Entry in the IfTable
+    Update loop_context,data_context and put_index_data variables
+*/
+
+
+    int i , p ,interface_count,incr_position;
+	int adsl_if_available = 0;
+
+    netsnmp_variable_list *vptr;
+    interface_count = i = p = 0;
+
+    if (!position) {
+        position = SNMP_MALLOC_TYPEDEF(int);
+        if (!position)
+          return NULL;
+    }
+    if (!Alarm_Data_Context) {
+        Alarm_Data_Context = malloc(ALARM_PROF_NAME_STR_LENGTH);
+        if (!Alarm_Data_Context) {
+             SNMP_FREE(position);
+             return NULL;
+	}
+    }
+    interface_count = GetNoInterfaces();
+    *position = 0;
+    if(!interface_count) {
+        SNMP_FREE(position);
+        SNMP_FREE(Alarm_Data_Context);
+        return NULL;
+    }
+
+    // Check wether Interfaces start with 0 or 1
+    for (i=1;i<= interface_count;i++) {
+         p = GetType(i);
+         if (p != 0 && (p == (*(int *)(*my_data_context)))) {
+			   adsl_if_available = 1;
+               sprintf(Alarm_Data_Context, "%010d", i);
+               *my_loop_context = position;
+               *my_data_context = Alarm_Data_Context;
+                 break;
+          }
+	  else if (p != 0 && (IFTYPE_ADSL_FAST_INTERLEAVE ==
+                                (*(int *)(*my_data_context)))) {
+                  if(p == IFTYPE_ADSL_INTERLEAVE ||
+                        p == IFTYPE_ADSL_FAST) {
+			  		  adsl_if_available = 1;
+                      sprintf(Alarm_Data_Context, "%010d", i);
+                      *my_loop_context = position;
+                      *my_data_context = Alarm_Data_Context;
+                      break;
+                  }
+          }
+   }
+	
+	if (!adsl_if_available)
+	 return NULL;
+
+   vptr = put_index_data;
+   snmp_set_var_value(vptr, (u_char *) Alarm_Data_Context , strlen(Alarm_Data_Context));
+   return put_index_data;
+}
+
+
+/** functionally the same as adslLineTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+adslTable_get_next_data_point(void **my_loop_context,
+                                  void **my_data_context,
+                                  netsnmp_variable_list *put_index_data,
+                                  netsnmp_iterator_info *mydata)
+{
+
+/* Go the data point where the my_loop_context pointer points to
+   Search for the next adsl entry in the IfTable
+   Update the put_index_data,loop_context and data_context pointers
+*/
+
+
+
+    int interface_count , i , p , search_for_nextentry ;
+	int adsl_if_available = 0;
+
+    netsnmp_variable_list *vptr;
+    interface_count = i = p = search_for_nextentry = 0;
+
+    if (!Data_Context) {
+        Data_Context = SNMP_MALLOC_TYPEDEF(int);
+        if (!Data_Context)
+             return NULL;
+    }
+
+    position=(int *)(*my_loop_context);
+    if (position == NULL) {
+        position = SNMP_MALLOC_TYPEDEF(int);
+        if (!position) {
+           SNMP_FREE(Data_Context);
+           return NULL;
+        }
+    }
+
+    interface_count = GetNoInterfaces();
+    if(!interface_count) {
+        SNMP_FREE(position);
+        SNMP_FREE(Data_Context);
+        return NULL;
+     }
+
+     // Check wether Interfaces start with 0 or 1
+     for (i=1;i<= interface_count;i++) {
+         p = GetType(i); //GetType
+
+         if (p != 0 && (IFTYPE_ADSL_FAST_INTERLEAVE ==
+                (*(int *)(*my_data_context))) &&
+                 (search_for_nextentry==0) &&
+                  (*position == (*(int *)(*my_loop_context))))  {
+
+               if (p == IFTYPE_ADSL_INTERLEAVE || p == IFTYPE_ADSL_FAST)  {
+
+                   /* The following three lines of code were added to handle 
+		    * the case if there is only one interface in the box
+		    */
+			        adsl_if_available = 1;
+                    *Data_Context = i;
+                    *my_loop_context = position;
+                    *my_data_context = Data_Context;
+                    search_for_nextentry =1;
+                    continue;
+               }
+           }
+	   else if (p != 0 && (IFTYPE_ADSL_FAST_INTERLEAVE ==
+                  (*(int *)(*my_data_context))) && (search_for_nextentry==1)) {
+
+               if (p == IFTYPE_ADSL_INTERLEAVE || 
+			p == IFTYPE_ADSL_FAST) {
+			        adsl_if_available = 1;
+               	    *Data_Context = i;
+               	    *my_loop_context = position;
+               	    *my_data_context = Data_Context;
+               	    vptr = put_index_data;
+               	    snmp_set_var_value(vptr, (u_char *) Data_Context ,
+               	    sizeof (*Data_Context));
+               	    return put_index_data;
+              	}
+           }
+
+           if (p != 0 && (p == (*(int *)(*my_data_context))) &&
+                               (search_for_nextentry==0) &&
+                             (*position == (*(int *)(*my_loop_context))))   {
+
+         // The following three lines of code were added to handle the case
+         // if there is only one interface in the box
+			    adsl_if_available = 1;
+                *Data_Context = i;
+                *my_loop_context = position;
+                *my_data_context = Data_Context;
+                 search_for_nextentry =1;
+                 continue;
+           } 
+	   else if (p != 0 && (p == (*(int *)(*my_data_context)))
+                           && (search_for_nextentry==1)) {
+			    adsl_if_available = 1;
+                *Data_Context = i;
+                *my_loop_context = position;
+                *my_data_context = Data_Context;
+           }
+           (*position)++;
+     }
+
+     if (*position > interface_count) {
+        SNMP_FREE(position);
+        SNMP_FREE(Data_Context);
+        *my_loop_context = NULL;
+        *my_data_context = NULL;
+        return NULL;
+     }
+
+	if (!adsl_if_available)
+	 return NULL;
+
+     vptr = put_index_data;
+     snmp_set_var_value(vptr, (u_char *) Data_Context ,sizeof (*Data_Context));
+     return put_index_data;
+}
+
+
+/* For adslLineAlarmConfProfileTable to get next data point */
+
+netsnmp_variable_list *
+adslAlarmTable_get_next_data_point(void **my_loop_context,
+                                  void **my_data_context,
+                                  netsnmp_variable_list *put_index_data,
+                                  netsnmp_iterator_info *mydata)
+{
+
+/* Go the data point where the my_loop_context pointer points to
+   Search for the next adsl entry in the IfTable
+   Update the put_index_data,loop_context and data_context pointers
+*/
+
+
+
+    int interface_count , i , p , search_for_nextentry ;
+	int adsl_if_available = 0;
+
+    netsnmp_variable_list *vptr;
+    interface_count = i = p = search_for_nextentry = 0;
+
+
+    if (!Alarm_Data_Context) {
+
+        Alarm_Data_Context = malloc(ALARM_PROF_NAME_STR_LENGTH);
+        if (!Alarm_Data_Context)
+           return NULL;
+    }
+
+    position=(int *)(*my_loop_context);
+    if (position == NULL)
+    {
+        position = SNMP_MALLOC_TYPEDEF(int);
+        if (!position) {
+           SNMP_FREE(Alarm_Data_Context);
+           return NULL;
+        }
+    }
+
+    interface_count = GetNoInterfaces();
+    if(!interface_count)  {
+        SNMP_FREE(position);
+        SNMP_FREE(Alarm_Data_Context);
+        return NULL;
+    }
+
+     // Check wether Interfaces start with 0 or 1
+    for (i=1;i<= interface_count;i++) {
+         p = GetType(i); //GetType
+
+         if (p != 0 && (IFTYPE_ADSL_FAST_INTERLEAVE == (*(int *)
+                        (*my_data_context))) &&
+                        (search_for_nextentry==0) &&
+                        (*position == (*(int *)(*my_loop_context))))  {
+
+               if (p == IFTYPE_ADSL_INTERLEAVE || p == IFTYPE_ADSL_FAST) {
+
+             // The following three lines of code were added to handle the case
+             // if there is only one interface in the box
+
+
+			    adsl_if_available = 1;
+                sprintf(Alarm_Data_Context, "%010d", i);
+                *my_loop_context = position;
+                *my_data_context = Alarm_Data_Context;
+                 search_for_nextentry =1;
+                 continue;
+               }
+           } 
+	   else if (p != 0 && (IFTYPE_ADSL_FAST_INTERLEAVE ==
+                  (*(int *)(*my_data_context))) && (search_for_nextentry==1)) {
+
+  	     if (p == IFTYPE_ADSL_INTERLEAVE || p == IFTYPE_ADSL_FAST) {
+
+			    adsl_if_available = 1;
+                 sprintf(Alarm_Data_Context, "%010d", i);
+                *my_loop_context = position;
+                *my_data_context = Alarm_Data_Context;
+
+                 vptr = put_index_data;
+                 snmp_set_var_value(vptr, (u_char *) Alarm_Data_Context ,
+                 sizeof (*Alarm_Data_Context));
+                 return put_index_data;
+              }
+           }
+
+           if (p != 0 && (p == (*(int *)(*my_data_context))) &&
+                            (search_for_nextentry==0) &&
+                            (*position == (*(int *)(*my_loop_context))))  {
+
+         // The following three lines of code were added to handle the case
+         // if there is only one interface in the box
+
+			    adsl_if_available = 1;
+                sprintf(Alarm_Data_Context, "%010d", i);
+                *my_loop_context = position;
+                *my_data_context = Alarm_Data_Context;
+                 search_for_nextentry =1;
+                 continue;
+            } 
+	    else if (p != 0 && (p == (*(int *)(*my_data_context)))
+                            && (search_for_nextentry==1)) {
+
+			    adsl_if_available = 1;
+                sprintf(Alarm_Data_Context, "%010d", i);
+                *my_loop_context = position;
+                *my_data_context = Alarm_Data_Context;
+           }
+           (*position)++;
+        }
+
+        if (*position > interface_count) {
+           SNMP_FREE(position);
+           SNMP_FREE(Alarm_Data_Context);
+           *my_loop_context = NULL;
+           *my_data_context = NULL;
+           return NULL;
+        }
+
+	if (!adsl_if_available)
+	 return NULL;
+
+        vptr = put_index_data;
+        snmp_set_var_value(vptr, (u_char *) Alarm_Data_Context ,strlen(Alarm_Data_Context));
+        return put_index_data;
+}
+
+
+int adsl_ioctl(int fd, int cmd, void *structptr)
+{
+  return (ioctl(fd, cmd, structptr));
+}
+
+
+int dev_open(const char *pathname, int flags)
+{
+  return (open(pathname, flags));
+}
+
+
+int dev_close(int fd)
+{
+  return (close(fd));
+}
+
+
+/*** XXX Return the IfType of an IfEntry in the IfTable XXX ***/
+static int
+GetType(int index)
+{
+    oid             name[MAX_OID_LEN] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 3 };
+    size_t          length = 10;
+    struct variable ifType_variable =
+        { 3, ASN_INTEGER, RONLY, var_ifEntry, 10,
+        {1, 3, 6, 1, 2, 1, 2, 2, 1, 3}
+    };
+    unsigned char  *p;
+    size_t          var_len;
+    WriteMethod    *write_method;
+
+    name[length] = index;
+    length++;
+
+    p = var_ifEntry(&ifType_variable,
+                    name, &length,
+                    1 /* exact */ , &var_len, &write_method);
+    if (!p)
+        return 0;
+
+    return *(int *) p;
+}
+
+
+/*** XXX Return the Number of interfaces in the IfTable XXX ***/
+static int
+GetNoInterfaces()
+{
+    oid             name[MAX_OID_LEN] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 0 };
+    size_t          length = 10;
+    struct variable ifType_variable =
+        { 0, ASN_INTEGER, RONLY, var_ifEntry, 10,
+        {1, 3, 6, 1, 2, 1, 2, 2, 1, 0}
+    };
+    unsigned char  *p;
+    size_t          var_len;
+    WriteMethod    *write_method;
+
+    name[length] = 0;
+    length++;
+
+    p = var_interfaces(&ifType_variable,
+                    name, &length,
+                    1 /* exact */ , &var_len, &write_method);
+    if (!p)
+        return 0;
+
+    return *(int *) p;
+}
+
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslTable_access.h open_snmp/agent/mibgroup/adslMIB/adslTable_access.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslTable_access.h	2009-12-16 12:59:31.000000000 +0530
@@ -0,0 +1,144 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslTable_access.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) User-defined constants which can be accessed globally
+ *                 2) Macro definitions for Setting & Testing the flags
+ *                 3) Data access functions
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+*/
+#include <fcntl.h>
+
+#ifndef STUB_IOCTL
+#ifdef CPU_AMAZON
+#include <asm/amazon/amazon_mei_app_ioctl.h>
+#define ENABLE_DRIVER_CALL
+#define ADSL_DEV_PATH "/dev/amazon/mei"
+#else
+#include "asm/danube/danube_mei_app_ioctl.h"
+#define ENABLE_DRIVER_CALL
+#define ADSL_DEV_PATH "/dev/danube/mei"
+#endif // CPU_AMAZON
+#endif
+/*
+ * ===========================================================================
+ *                          DEFINITIONS
+ * ===========================================================================
+ */
+#define  u_int32 unsigned int
+//#define  u_int16 unsigned short
+#define ADSL_MIB_MEM_LEAK_FIX
+#define ALARM_PROF_NAME_STR_LENGTH 11
+
+/* Interface Type */
+#define IFTYPE_ADSL 94
+#define IFTYPE_ADSL_INTERLEAVE 124
+#define IFTYPE_ADSL_FAST 125
+#define IFTYPE_ADSL_FAST_INTERLEAVE 5678
+
+#ifdef STUB_IOCTL
+//****** Macro Definitions - FLAG Setting & Testing
+// -- This macro sets the flags with the flag_val. Here flags is passed as a
+// pointer
+#define SET_FLAG(flags, flag_val)   ((*(flags)) = ((*(flags)) | (flag_val)))
+
+//-- This macro verifies whether test_flag has been set in flags.
+//   Here flags is passed as a pointer
+#define IS_FLAG_SET(flags, test_flag) (((*(flags) & (test_flag)) == \
+                                        (test_flag))? test_flag : 0)
+
+/*Ex: Say we want to get the value of adslAtucInvSerialNumber from the
+adslAtucPhysTable.For this we first set the ATUC_PHY_SER_NUM_FLAG, using the
+macro SET_FLAG(flags, ATUC_PHY_SER_NUM_FLAG).Once the driver API is called it
+checks for which variable has been requested by invoking the macro IS_FLAG_SET(
+flags, ATUC_PHY_SER_NUM_FLAG) and then sending the response for that variable!
+If the requested variable cannot be retrieved or modified, then the flag will be
+reset by the driver. On receiving the response from the driver at the user
+application NET-SNMP), if the requested flag is reset by the driver then we
+raise an SNMP_GENERROR else we pass the returned value to the application.
+*/
+
+// -- This macro resets the specified flag_bit in the flags.
+//    Here flags is passed as a pointer
+#define CLR_FLAG(flags, flag_bit)   ((*flags) = ((*(flags)) & (~(flag_bit))))
+#endif
+
+
+//Global Definitions
+/**** File Pointer to the device ******/
+int Fd;
+
+
+int *position;
+int *Data_Context;
+char *Alarm_Data_Context;
+
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+// functions prototype
+
+Netsnmp_First_Data_Point adslTable_get_first_data_point;
+Netsnmp_Next_Data_Point adslTable_get_next_data_point;
+
+Netsnmp_First_Data_Point adslAlarmTable_get_first_data_point;
+Netsnmp_First_Data_Point adslAlarmTable_get_next_data_point;
+
+int adsl_ioctl(int fd, int cmd, void *structptr);
+
+int dev_open(const char *pathname, int flags);
+
+int dev_close(int fd);
+
+static int GetType(int index);
+
+static int GetNoInterfaces();
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslTraps/adslTraps.c open_snmp/agent/mibgroup/adslMIB/adslTraps/adslTraps.c
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslTraps/adslTraps.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslTraps/adslTraps.c	2009-12-16 12:59:31.000000000 +0530
@@ -0,0 +1,387 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslTraps.c
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions for:
+ *                 1) Initializing the adslTraps module
+ *                 2) Handling adslTraps generation
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+/** adslTraps.c
+ *  This file shows how to send a notification from inside the
+ *  agent.  In this case we simply sleep for 30 seconds and send it,
+ *  then we sleep for 30 more and send it again.
+ *  We do this through the snmp_alarm mechanisms. Normally, you would
+ *  probably want to do something to test whether or not to send an alarm,
+ *  based on the type of mib module you were creating.
+ *
+ */
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+/** This files contains Trap includes & prototypes **/
+#include "adslTraps.h"
+
+/*
+ * ===========================================================================
+ *                           LOCAL FUNCTIONS
+ * ===========================================================================
+ */
+#ifndef ENABLE_DRIVER_CALL
+    int stub_ioctl(int fd, int cmd, unsigned short *flags);
+#endif
+
+/** Our Trap initialization routine **/
+void
+init_adslTraps(void)
+{
+    DEBUGMSGTL(("adsl-Traps",
+                "initializing (setting callback alarm)\n"));
+    snmp_alarm_register(30,     /* seconds */
+                        SA_REPEAT,      /* repeat (every 30 seconds). */
+                        send_adsl_notification,      /* our callback */
+                        NULL    /* no callback data needed */
+        );
+}
+
+/** here we send an SNMP trap to all trapsinks **/
+void
+send_adsl_notification(unsigned int clientreg, void *clientarg)
+{
+    unsigned short flags = 0;
+    unsigned short test_flags = 0;
+    size_t notification_oid_len = 0;
+
+    /* Assign our notification OID to the snmpTrapOID.0 object */
+    oid objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
+    size_t objid_snmptrap_len = OID_LENGTH(objid_snmptrap);
+
+    /* define the OIDs for the notification we're going to send */
+
+    /* ADSL-LINE-MIB::adslAtucPerfLofsThreshTrap */
+    oid AtucPerfLofs_oid[] = { SNMP_ADSL_ATUC_TRAPS_PREFIX,0,1 };
+
+    /* ADSL-LINE-MIB::adslAtucPerfLossThreshTrap */
+    oid AtucPerfLoss_oid[] = { SNMP_ADSL_ATUC_TRAPS_PREFIX,0,2 };
+
+    /* ADSL-LINE-MIB::adslAtucPerfESsThreshTrap */
+    oid AtucPerfESs_oid[]  = { SNMP_ADSL_ATUC_TRAPS_PREFIX,0,4 };
+
+    /* ADSL-LINE-MIB::adslAtucRateChangeTrap */
+    oid AtucRateChange_oid[] = { SNMP_ADSL_ATUC_TRAPS_PREFIX,0,5 };
+
+    /* ADSL-LINE-MIB::adslAturPerfLofsThreshTrap */
+    oid AturPerfLofs_oid[] = { SNMP_ADSL_ATUR_TRAPS_PREFIX,0,1 };
+
+    /* ADSL-LINE-MIB::adslAturPerfLossThreshTrap */
+    oid AturPerfLoss_oid[] = { SNMP_ADSL_ATUR_TRAPS_PREFIX,0,2 };
+
+    /* ADSL-LINE-MIB::adslAturPerfLprsThreshTrap */
+    oid AturPerfLprs_oid[] = { SNMP_ADSL_ATUR_TRAPS_PREFIX,0,3 };
+
+    /* ADSL-LINE-MIB::adslAturPerfESsThreshTrap */
+    oid AturPerfESs_oid[] = { SNMP_ADSL_ATUR_TRAPS_PREFIX,0,4 };
+
+    /* ADSL-LINE-MIB::adslAturRateChangeTrap */
+    oid AturRateChange_oid[] = { SNMP_ADSL_ATUR_TRAPS_PREFIX,0,5 };
+
+    /* Create the variables which might be needed to be sent in the trap */
+    /* Here we don't send any notifictaion variables */
+    netsnmp_variable_list *notification_vars = NULL;
+
+    /*  Here we invoke the driver function which checks whether
+     *  any Thresholds have exceeded the configured values and
+     *  thereby set the appropriate Trap flags
+     */
+
+#ifdef ENABLE_DRIVER_CALL
+    Fd = open(ADSL_DEV_PATH, O_RDONLY);
+    if (Fd <=0) {
+        snmp_log (LOG_ERR, "Unable to open the device... exiting!\n");
+        return;
+    }
+    ioctl(Fd, ADSL_ATUR_TRAPS, &flags);
+#else
+    stub_ioctl(3, ADSL_ATUR_TRAPS, &flags);
+#endif
+
+     /* Check which flags have been Set */
+     /* Generate Traps for those flags */
+     /* Do I need to clear the flag_bit once I send out a Trap ?? */
+
+      test_flags = 256;
+      while (test_flags) {
+      notification_vars = NULL;
+      switch (IS_FLAG_SET(&flags, test_flags)) {
+        case  ATUC_PERF_LOFS_THRESH_FLAG:
+        {
+                notification_oid_len = OID_LENGTH(AtucPerfLofs_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AtucPerfLofs_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Traps",
+                    	"sending AtucPerfLofsThresh trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUC_PERF_LOFS_THRESH_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUC_PERF_LOSS_THRESH_FLAG:
+        {
+                notification_oid_len = OID_LENGTH(AtucPerfLoss_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AtucPerfLoss_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Traps",
+                   	 "sending AtucPerfLossThresh trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUC_PERF_LOSS_THRESH_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUC_PERF_ESS_THRESH_FLAG:
+        {
+                    notification_oid_len = OID_LENGTH(AtucPerfESs_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AtucPerfESs_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Traps",
+                    	"sending AtucPerfESsThresh trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUC_PERF_ESS_THRESH_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUC_RATE_CHANGE_FLAG:
+        {
+                    notification_oid_len = OID_LENGTH(AtucRateChange_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AtucRateChange_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Traps",
+                    	"sending AtucRateChange trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUC_RATE_CHANGE_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUR_PERF_LOFS_THRESH_FLAG:
+        {
+                    notification_oid_len = OID_LENGTH(AturPerfLofs_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AturPerfLofs_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Traps",
+                    	"sending AturPerfLofsThresh trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUR_PERF_LOFS_THRESH_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUR_PERF_LOSS_THRESH_FLAG:
+        {
+                    notification_oid_len = OID_LENGTH(AturPerfLoss_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AturPerfLoss_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Traps",
+                    	"sending AturPerfLossThresh trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUR_PERF_LOSS_THRESH_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUR_PERF_LPRS_THRESH_FLAG:
+        {
+                    notification_oid_len = OID_LENGTH(AturPerfLprs_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AturPerfLprs_oid,
+                                    notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Traps",
+                    	"sending AturPerfLprsThresh trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUR_PERF_LPRS_THRESH_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUR_PERF_ESS_THRESH_FLAG:
+        {
+                    notification_oid_len = OID_LENGTH(AturPerfESs_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AturPerfESs_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Traps",
+                    	"sending AturPerfESsThresh trap\n"));
+                    send_v2trap(notification_vars);
+
+                /* clear this bit in flags */
+                CLR_FLAG(&flags, ATUR_PERF_ESS_THRESH_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+
+        case  ATUR_RATE_CHANGE_FLAG:
+        {
+                    notification_oid_len = OID_LENGTH(AturRateChange_oid);
+
+                /* add in the trap definition object */
+                    snmp_varlist_add_variable(&notification_vars,
+                                    objid_snmptrap, objid_snmptrap_len,
+                                    ASN_OBJECT_ID,
+                                    (u_char *) AturRateChange_oid,
+                                     notification_oid_len * sizeof(oid));
+
+                /* send the trap out to all registered receivers */
+                    DEBUGMSGTL(("adsl-Traps",
+	                "sending AturRateChange trap\n"));
+                    send_v2trap(notification_vars);
+
+        	/*free the created notification variable list */
+                CLR_FLAG(&flags, ATUR_RATE_CHANGE_FLAG);
+        	snmp_free_varbind(notification_vars);
+                break;
+        }
+        default:
+                break;
+     }
+     test_flags = (test_flags >> 1);
+
+#ifdef ENABLE_DRIVER_CALL
+    close(Fd);
+#endif
+     }
+}
+
+#ifndef ENABLE_DRIVER_CALL
+/* This function is part of the MEI driver which Bing Tao's team is supposed to
+   provide us with. This function basically checks & compares the threshold
+   values and on exceeding the configured threshold, sets the appropriate
+   Threshold flag
+*/
+
+int stub_ioctl(int fd, int cmd, unsigned short *flags)
+{
+
+ switch (cmd) {
+    case ADSL_ATUR_TRAPS:
+            SET_FLAG(flags, ATUC_PERF_LOSS_THRESH_FLAG);
+            SET_FLAG(flags, ATUC_RATE_CHANGE_FLAG);
+            SET_FLAG(flags, ATUR_PERF_ESS_THRESH_FLAG);
+            CLR_FLAG(flags, ATUR_RATE_CHANGE_FLAG);
+        break;
+    }
+    return 0;
+}
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB/adslTraps/adslTraps.h open_snmp/agent/mibgroup/adslMIB/adslTraps/adslTraps.h
--- net-snmp-5.1/agent/mibgroup/adslMIB/adslTraps/adslTraps.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB/adslTraps/adslTraps.h	2009-12-16 12:59:31.000000000 +0530
@@ -0,0 +1,93 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : adslTraps.h
+ * Author       : Subbi
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains:
+ *                 1) Include files
+ *                 2) Definitions
+ *                 2) Init Function proto-types
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+#ifndef ADSLTRAPS_H
+#define ADSLTRAPS_H
+
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
+#include <adslMIB/adslTable_access.h>
+
+/*
+ * ===========================================================================
+ *                           DEFINITIONS
+ * ===========================================================================
+ */
+
+#ifdef STUB_IOCTL
+/* adslAturTrap constants */
+#define ADSL_ATUR_TRAPS             135
+
+/* adslAturTraps Flags */
+#define ATUC_PERF_LOFS_THRESH_FLAG      0x1     /* BIT 0th position */
+#define ATUC_PERF_LOSS_THRESH_FLAG      0x2     /* BIT 1 */
+#define ATUC_PERF_ESS_THRESH_FLAG       0x4     /* BIT 2 */
+#define ATUC_RATE_CHANGE_FLAG           0x8     /* BIT 3 */
+#define ATUR_PERF_LOFS_THRESH_FLAG      0x10    /* BIT 4 */
+#define ATUR_PERF_LOSS_THRESH_FLAG      0x20    /* BIT 5 */
+#define ATUR_PERF_LPRS_THRESH_FLAG      0x40    /* BIT 6 */
+#define ATUR_PERF_ESS_THRESH_FLAG       0x80    /* BIT 7 */
+#define ATUR_RATE_CHANGE_FLAG           0x100   /* BIT 8 */
+#endif
+
+/* Constants */
+#define SNMP_ADSL_TRAPS_PREFIX          1,3,6,1,2,1,10,94,1,2
+#define SNMP_ADSL_ATUC_TRAPS_PREFIX     SNMP_ADSL_TRAPS_PREFIX,1
+#define SNMP_ADSL_ATUR_TRAPS_PREFIX     SNMP_ADSL_TRAPS_PREFIX,2
+
+/*
+ * ===========================================================================
+ *                           FUNCTION PROTOTYPES
+ * ===========================================================================
+ */
+
+/* prototypes for the Traps */
+void init_adslTraps(void);
+SNMPAlarmCallback send_adsl_notification;
+
+#endif /* ADSLTRAPS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/adslMIB.h open_snmp/agent/mibgroup/adslMIB.h
--- net-snmp-5.1/agent/mibgroup/adslMIB.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/adslMIB.h	2009-12-16 12:59:31.000000000 +0530
@@ -0,0 +1,89 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    :   adslMIB.h
+ * Author       :   Subramani
+ * Date         :   17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      :   Amazon
+ * Block        :   ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents:  This file contains the command 'config_require' and module names
+ *            which will be used the configure script to generate a Makefile.
+ *            This file is used by the configure script to load the different
+ *            modules under adslMIB directory for compilation.
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+*/
+
+// This file is included in the mibgroup directory to add the various modules
+// of adsl
+
+config_require(adslMIB/adslTable_access)
+
+config_require(adslMIB/adslLineTable/adslLineTable)
+config_require(adslMIB/adslAtucChanIntervalTable/adslAtucChanIntervalTable)
+config_require(adslMIB/adslAtucChanPerfDataTable/adslAtucChanPerfDataTable)
+config_require(adslMIB/adslAtucChanTable/adslAtucChanTable)
+config_require(adslMIB/adslAtucIntervalTable/adslAtucIntervalTable)
+config_require(adslMIB/adslAtucPerfDataTable/adslAtucPerfDataTable)
+config_require(adslMIB/adslAtucPhysTable/adslAtucPhysTable)
+
+config_require(adslMIB/adslAturChanIntervalTable/adslAturChanIntervalTable)
+config_require(adslMIB/adslAturChanPerfDataTable/adslAturChanPerfDataTable)
+config_require(adslMIB/adslAturChanTable/adslAturChanTable)
+config_require(adslMIB/adslAturIntervalTable/adslAturIntervalTable)
+config_require(adslMIB/adslAturPerfDataTable/adslAturPerfDataTable)
+config_require(adslMIB/adslAturPhysTable/adslAturPhysTable)
+
+config_require(adslMIB/adslLineAlarmConfProfileTable/adslLineAlarmConfProfileTable)
+
+config_require(adslMIB/adslTraps/adslTraps)
+
+config_add_mib(ADSL-LINE-MIB)
+
+
+/* RFC 3440 ADSL LINE EXTENSION MIB */
+config_require(adslMIB/adslLineExtTable/adslLineExtTable)
+
+config_require(adslMIB/adslAtucPerfDataExtTable/adslAtucPerfDataExtTable)
+config_require(adslMIB/adslAtucIntervalExtTable/adslAtucIntervalExtTable)
+
+config_require(adslMIB/adslAturIntervalExtTable/adslAturIntervalExtTable)
+config_require(adslMIB/adslAturPerfDataExtTable/adslAturPerfDataExtTable)
+
+config_require(adslMIB/adslAlarmConfProfileExtTable/adslAlarmConfProfileExtTable)
+
+config_require(adslMIB/adslExtTraps/adslExtTraps)
+
+config_add_mib(ADSL-LINE-EXT-MIB)
+
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable.c open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable.c
--- net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable.c	2009-12-16 12:59:35.000000000 +0530
@@ -0,0 +1,1166 @@
+#include "debug.h"
+#ifdef USING_EXAMPLE_CODE
+#else
+#endif
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.4 2003/07/01 00:15:11 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "atmVclTable.h"
+#include "atmVclTable_checkfns.h"
+#include "atmVclTable_access.h"
+
+static netsnmp_oid_stash_node *undoStorage = NULL;
+static netsnmp_oid_stash_node *commitStorage = NULL;
+
+struct undoInfo {
+    void           *ptr;
+    size_t          len;
+};
+
+struct commitInfo {
+    void           *data_context;
+    int             have_committed;
+    int             new_row;
+};
+
+void
+atmVclTable_free_undoInfo(void *vptr)
+{
+    struct undoInfo *ui = vptr;
+    if (!ui)
+        return;
+    SNMP_FREE(ui->ptr);
+    SNMP_FREE(ui);
+}
+
+/** Initialize the atmVclTable table by defining its contents and how it's structured */
+void
+initialize_table_atmVclTable(void)
+{
+#ifdef USING_EXAMPLE_CODE
+    static oid      atmVclTable_oid[] =
+        { 1, 3, 6, 1, 4, 1, 8072, 2, 2, 2 };
+#else		
+    static oid      atmVclTable_oid[] =
+	    { 1, 3, 6, 1, 2, 1, 37, 1, 7 };
+#endif
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler = netsnmp_create_handler_registration("atmVclTable",
+                                                     atmVclTable_handler,
+                                                     atmVclTable_oid,
+                                                     OID_LENGTH
+                                                     (atmVclTable_oid),
+                                                     HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo) {
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_atmVclTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+#ifdef USING_EXAMPLE_CODE
+    netsnmp_table_helper_add_indexes(table_info, ASN_OCTET_STR,
+                                                 /** index: netSnmpHostName */
+                                     0);
+#else
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
+                                               /** index: ifIndex */
+                                     ASN_INTEGER,
+                                               /** index: atmVclVpi */
+                                     ASN_INTEGER,
+                                               /** index: atmVclVci */
+                                     0);
+#endif
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+#ifdef USING_EXAMPLE_CODE
+    table_info->min_column = 2;
+    table_info->max_column = 5;
+#else
+    table_info->min_column = 3;
+    table_info->max_column = 15;
+#endif
+
+    /** iterator access routines */
+    iinfo->get_first_data_point = atmVclTable_get_first_data_point;
+    iinfo->get_next_data_point = atmVclTable_get_next_data_point;
+
+#ifdef USING_EXAMPLE_CODE
+    /** you may wish to set these as well */
+    iinfo->make_data_context = atmVclTable_context_convert_function;
+    iinfo->free_data_context = atmVclTable_data_free;
+    iinfo->free_loop_context_at_end = atmVclTable_loop_free;
+#endif
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_atmVclTable",
+                "Registering table atmVclTable as a table iterator><\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the atmVclTable module */
+void
+init_atmVclTable(void)
+{
+
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_atmVclTable();
+}
+
+/** handles requests for the atmVclTable table, if anything else needs to be done */
+int
+atmVclTable_handler(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info *reqinfo,
+                          netsnmp_request_info *requests)
+{
+
+#ifdef USING_EXAMPLE_CODE
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+    oid            *suffix;
+    size_t          suffix_len;
+
+    /** column and row index encoded portion */
+    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
+    suffix_len = requests->requestvb->name_length -
+        (reginfo->rootoid_len + 1);
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+        case MODE_SET_RESERVE1:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+            break;
+
+        default:               /* == the other SET modes */
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+            break;
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+            case COLUMN_NETSNMPHOSTADDRESSTYPE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_netSnmpHostAddressType(data_context,
+                                                   &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_NETSNMPHOSTADDRESS:
+                {
+                    char           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_netSnmpHostAddress(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_NETSNMPHOSTSTORAGE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_netSnmpHostStorage(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_NETSNMPHOSTROWSTATUS:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_netSnmpHostRowStatus(data_context,
+                                                 &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                         "problem encountered in atmVclTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+
+            if (!ci) {
+                    /** create the commit storage info */
+                ci = SNMP_MALLOC_STRUCT(commitInfo);
+                if (!data_context) {
+                    ci->data_context =
+                        atmVclTable_create_data_context(table_info->
+                                                              indexes);
+                    ci->new_row = 1;
+                } else {
+                    ci->data_context = data_context;
+                }
+                netsnmp_oid_stash_add_data(&commitStorage,
+                                           suffix + 1, suffix_len - 1, ci);
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            switch (table_info->colnum) {
+            case COLUMN_NETSNMPHOSTADDRESSTYPE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_netSnmpHostAddressType(ci->data_context,
+                                                   &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_netSnmpHostAddressType(request->requestvb->
+                                                     type,
+                                                     (long *) request->
+                                                     requestvb->val.string,
+                                                     request->requestvb->
+                                                     val_len, retval,
+                                                     retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        atmVclTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_NETSNMPHOSTADDRESS:
+                {
+                    char           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_netSnmpHostAddress(ci->data_context,
+                                               &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_netSnmpHostAddress(request->requestvb->type,
+                                                 (char *) request->
+                                                 requestvb->val.string,
+                                                 request->requestvb->
+                                                 val_len, retval,
+                                                 retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        atmVclTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_NETSNMPHOSTSTORAGE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_netSnmpHostStorage(ci->data_context,
+                                               &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_netSnmpHostStorage(request->requestvb->type,
+                                                 (long *) request->
+                                                 requestvb->val.string,
+                                                 request->requestvb->
+                                                 val_len, retval,
+                                                 retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        atmVclTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_NETSNMPHOSTROWSTATUS:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_netSnmpHostRowStatus(ci->data_context,
+                                                 &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_netSnmpHostRowStatus(request->requestvb->
+                                                   type,
+                                                   (long *) request->
+                                                   requestvb->val.string,
+                                                   request->requestvb->
+                                                   val_len, retval,
+                                                   retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        atmVclTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            default:
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_ERR_NOTWRITABLE);
+                break;
+            }
+            break;
+
+        case MODE_SET_ACTION:
+            /** save a variable copy */
+            switch (table_info->colnum) {
+            case COLUMN_NETSNMPHOSTADDRESSTYPE:
+                {
+                    int             ret;
+                    ret = set_netSnmpHostAddressType(ci->data_context,
+                                                     (long *) request->
+                                                     requestvb->val.string,
+                                                     request->requestvb->
+                                                     val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTADDRESS:
+                {
+                    int             ret;
+                    ret = set_netSnmpHostAddress(ci->data_context,
+                                                 (char *) request->
+                                                 requestvb->val.string,
+                                                 request->requestvb->
+                                                 val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTSTORAGE:
+                {
+                    int             ret;
+                    ret = set_netSnmpHostStorage(ci->data_context,
+                                                 (long *) request->
+                                                 requestvb->val.string,
+                                                 request->requestvb->
+                                                 val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTROWSTATUS:
+                {
+                    int             ret;
+                    ret = set_netSnmpHostRowStatus(ci->data_context,
+                                                   (long *) request->
+                                                   requestvb->val.string,
+                                                   request->requestvb->
+                                                   val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                    if (*request->requestvb->val.integer == RS_DESTROY) {
+                        ci->new_row = -1;
+                    }
+                }
+                break;
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            if (!ci->have_committed) {
+                    /** do this once per row only */
+                atmVclTable_commit_row(&ci->data_context,
+                                             ci->new_row);
+                ci->have_committed = 1;
+            }
+            break;
+
+        case MODE_SET_UNDO:
+             /** save a variable copy */
+            switch (table_info->colnum) {
+            case COLUMN_NETSNMPHOSTADDRESSTYPE:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_netSnmpHostAddressType(ci->data_context,
+                                                   ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTADDRESS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_netSnmpHostAddress(ci->data_context, ui->ptr,
+                                               ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTSTORAGE:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_netSnmpHostStorage(ci->data_context, ui->ptr,
+                                               ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTROWSTATUS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_netSnmpHostRowStatus(ci->data_context, ui->ptr,
+                                                 ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            }
+            break;
+
+        case MODE_SET_FREE:
+            break;
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in atmVclTable_handler: unsupported mode\n");
+        }
+    }
+
+    /** clean up after all requset processing has ended */
+    switch (reqinfo->mode) {
+    case MODE_SET_UNDO:
+    case MODE_SET_FREE:
+    case MODE_SET_COMMIT:
+        /** clear out the undo cache */
+        netsnmp_oid_stash_free(&undoStorage,
+                               atmVclTable_free_undoInfo);
+        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
+    }
+
+
+    return SNMP_ERR_NOERROR;
+#else
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+    oid            *suffix;
+    size_t          suffix_len;
+
+    /** column and row index encoded portion */
+    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
+    suffix_len = requests->requestvb->name_length -
+        (reginfo->rootoid_len + 1);
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+        case MODE_SET_RESERVE1:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+            break;
+
+        default:               /* == the other SET modes */
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+            break;
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+
+            switch (table_info->colnum) {
+            case COLUMN_ATMVCLADMINSTATUS://
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVclAdminStatus(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+            case COLUMN_ATMVCLOPERSTATUS:
+                 {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVclOperStatus(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+           case COLUMN_ATMVCLLASTCHANGE:
+                 {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVclLastChange(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+           case COLUMN_ATMVCLRECEIVETRAFFICDESCRINDEX:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVclReceiveTrafficDescrIndex(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+ 
+           case COLUMN_ATMVCLTRANSMITTRAFFICDESCRINDEX:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVclTransmitTrafficDescrIndex(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+           case COLUMN_ATMVCCAALTYPE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVccAalType(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+           case COLUMN_ATMVCCAAL5CPCSTRANSMITSDUSIZE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVccAal5CpcsTransmitSduSize(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+           case COLUMN_ATMVCCAAL5CPCSRECEIVESDUSIZE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVccAal5CpcsReceiveSduSize(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+           case COLUMN_ATMVCCAAL5ENCAPSTYPE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVccAal5EncapType(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+           case COLUMN_ATMVCLCROSSCONNECTIDENTIFIER:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVclCrossConnectIdentifier(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+           case COLUMN_ATMVCLROWSTATUS:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVclRowStatus(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+           case COLUMN_ATMVCLCASTTYPE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVclCastType(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+           case COLUMN_ATMVCLCONNKIND:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval =
+                        get_atmVclConnkind(data_context,
+                                                   &retval_len);//
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+           default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                         "problem encountered in atmVclTable_handler: unknown column\n");
+            }
+            break;
+#if 0 
+        case MODE_SET_RESERVE1:
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+
+            if (!ci) {
+                    /** create the commit storage info */
+                ci = SNMP_MALLOC_STRUCT(commitInfo);
+                if (!data_context) {
+                    ci->data_context =
+                        atmVclTable_create_data_context(table_info->
+                                                              indexes);
+                    ci->new_row = 1;
+                } else {
+                    ci->data_context = data_context;
+                }
+                netsnmp_oid_stash_add_data(&commitStorage,
+                                           suffix + 1, suffix_len - 1, ci);
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            switch (table_info->colnum) {
+            case COLUMN_NETSNMPHOSTADDRESSTYPE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_netSnmpHostAddressType(ci->data_context,
+                                                   &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_netSnmpHostAddressType(request->requestvb->
+                                                     type,
+                                                     (long *) request->
+                                                     requestvb->val.string,
+                                                     request->requestvb->
+                                                     val_len, retval,
+                                                     retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        atmVclTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_NETSNMPHOSTADDRESS:
+                {
+                    char           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_netSnmpHostAddress(ci->data_context,
+                                               &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_netSnmpHostAddress(request->requestvb->type,
+                                                 (char *) request->
+                                                 requestvb->val.string,
+                                                 request->requestvb->
+                                                 val_len, retval,
+                                                 retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        atmVclTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_NETSNMPHOSTSTORAGE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_netSnmpHostStorage(ci->data_context,
+                                               &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_netSnmpHostStorage(request->requestvb->type,
+                                                 (long *) request->
+                                                 requestvb->val.string,
+                                                 request->requestvb->
+                                                 val_len, retval,
+                                                 retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        atmVclTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            case COLUMN_NETSNMPHOSTROWSTATUS:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    struct undoInfo *ui = NULL;
+                    int             ret;
+
+                    /** first, get the old value */
+                    retval =
+                        get_netSnmpHostRowStatus(ci->data_context,
+                                                 &retval_len);
+                    if (retval) {
+                        ui = SNMP_MALLOC_STRUCT(undoInfo);
+                        ui->len = retval_len;
+                        memdup((u_char **) & ui->ptr,
+                               (u_char *) retval, ui->len);
+                    }
+
+                    /** check the new value, possibly against the
+                        older value for a valid state transition */
+                    ret =
+                        check_netSnmpHostRowStatus(request->requestvb->
+                                                   type,
+                                                   (long *) request->
+                                                   requestvb->val.string,
+                                                   request->requestvb->
+                                                   val_len, retval,
+                                                   retval_len);
+                    if (ret != 0) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                        atmVclTable_free_undoInfo(ui);
+                    } else if (ui) {
+                        /** remember information for undo purposes later */
+                        netsnmp_oid_stash_add_data(&undoStorage,
+                                                   suffix, suffix_len, ui);
+                    }
+
+                }
+                break;
+            default:
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_ERR_NOTWRITABLE);
+                break;
+            }
+            break;
+
+        case MODE_SET_ACTION:
+            /** save a variable copy */
+            switch (table_info->colnum) {
+            case COLUMN_NETSNMPHOSTADDRESSTYPE:
+                {
+                    int             ret;
+                    ret = set_netSnmpHostAddressType(ci->data_context,
+                                                     (long *) request->
+                                                     requestvb->val.string,
+                                                     request->requestvb->
+                                                     val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTADDRESS:
+                {
+                    int             ret;
+                    ret = set_netSnmpHostAddress(ci->data_context,
+                                                 (char *) request->
+                                                 requestvb->val.string,
+                                                 request->requestvb->
+                                                 val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTSTORAGE:
+                {
+                    int             ret;
+                    ret = set_netSnmpHostStorage(ci->data_context,
+                                                 (long *) request->
+                                                 requestvb->val.string,
+                                                 request->requestvb->
+                                                 val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTROWSTATUS:
+                {
+                    int             ret;
+                    ret = set_netSnmpHostRowStatus(ci->data_context,
+                                                   (long *) request->
+                                                   requestvb->val.string,
+                                                   request->requestvb->
+                                                   val_len);
+                    if (ret) {
+                        netsnmp_set_request_error(reqinfo, request, ret);
+                    }
+                    if (*request->requestvb->val.integer == RS_DESTROY) {
+                        ci->new_row = -1;
+                    }
+                }
+                break;
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            if (!ci->have_committed) {
+                    /** do this once per row only */
+                atmVclTable_commit_row(&ci->data_context,
+                                             ci->new_row);
+                ci->have_committed = 1;
+            }
+            break;
+
+        case MODE_SET_UNDO:
+             /** save a variable copy */
+            switch (table_info->colnum) {
+            case COLUMN_NETSNMPHOSTADDRESSTYPE:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_netSnmpHostAddressType(ci->data_context,
+                                                   ui->ptr, ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTADDRESS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_netSnmpHostAddress(ci->data_context, ui->ptr,
+                                               ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTSTORAGE:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_netSnmpHostStorage(ci->data_context, ui->ptr,
+                                               ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            case COLUMN_NETSNMPHOSTROWSTATUS:
+                {
+                    int             retval;
+                    struct undoInfo *ui;
+                    ui = netsnmp_oid_stash_get_data(undoStorage,
+                                                    suffix, suffix_len);
+                    retval =
+                        set_netSnmpHostRowStatus(ci->data_context, ui->ptr,
+                                                 ui->len);
+                    if (retval) {
+                        netsnmp_set_request_error(reqinfo, request,
+                                                  SNMP_ERR_UNDOFAILED);
+                    }
+                }
+                break;
+            }
+            break;
+#endif
+        case MODE_SET_FREE:
+            break;
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in atmVclTable_handler: unsupported mode\n");
+        }
+    }
+
+    /** clean up after all requset processing has ended */
+    switch (reqinfo->mode) {
+    case MODE_SET_UNDO:
+    case MODE_SET_FREE:
+    case MODE_SET_COMMIT:
+        /** clear out the undo cache */
+        netsnmp_oid_stash_free(&undoStorage,
+                               atmVclTable_free_undoInfo);
+        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
+    }
+
+
+    return SNMP_ERR_NOERROR;
+
+#endif
+}
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable.h open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable.h
--- net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable.h	2009-12-16 12:59:35.000000000 +0530
@@ -0,0 +1,30 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.4 2003/07/01 00:15:11 hardaker Exp $
+ */
+#ifndef NETSNMPHOSTSTABLE_H
+#define NETSNMPHOSTSTABLE_H
+
+/** other required module components */
+config_require(atmMIB/atmVclTable/atmVclTable_access)
+    config_require(atmMIB/atmVclTable/atmVclTable_checkfns)
+
+    /*
+     * function declarations 
+     */
+     void            init_atmVclTable(void);
+     void            initialize_table_atmVclTable(void);
+     Netsnmp_Node_Handler atmVclTable_handler;
+
+
+/*
+ * column number definitions for table atmVclTable 
+ */
+#include "atmVclTable_columns.h"
+
+/*
+ * enum definions 
+ */
+#include "atmVclTable_enums.h"
+
+#endif /** NETSNMPHOSTSTABLE_H */
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_access.c open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_access.c
--- net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_access.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_access.c	2009-12-16 12:59:35.000000000 +0530
@@ -0,0 +1,752 @@
+
+#include "debug.h"
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.3 2003/05/31 00:11:57 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "atmVclTable_access.h"
+#include "atmVclTable_enums.h"
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include "atmVclTable.h"
+#define MAX_HOSTS_LINE 4096
+
+/* XXX: make .conf token */
+#define HOSTS_FILE "/etc/hosts"
+#ifdef USING_EXAMPLE_CODE
+typedef struct my_loop_info_s {
+   FILE *filep;
+   in_addr_t theaddr;
+   char line[MAX_HOSTS_LINE];
+   char hostname[64];
+   int lineno;
+   char *current_ptr;
+} my_loop_info;
+#else
+
+typedef struct  atmVclEntry {
+ 	int ifIndex;
+ 	short atmVclvpi;
+ 	int atmVclvci;
+ 	int  atmVclAdminStatus;
+ 	int atmVclOperStatus;
+	unsigned long atmVclLastChange;
+
+ 	struct atmTrafficDescParamEntry *atmVclRxTrafficPtr;
+ 	struct atmTrafficDescParamEntry *atmVclTxTrafficPtr;
+	
+ 	unsigned char atmVccAalType;
+ 	unsigned int atmVccAal5TxSduSize;
+ 	unsigned int atmVccAal5RxSduSize;
+ 	int atmVccAal5Encap;
+ 	int atmVclRowStatus;
+ 	int atmVclCastType;
+ 	int atmVclConnKind;
+ 	struct atmVclEntry *next;
+
+#if 0
+ 	int ifIndex;
+ 	short atmVclvpi;
+ 	int atmVclvci;
+ 	int  atmVclAdminStatus;
+ 	int atmVclOperStatus;
+	unsigned long atmVclLastChange;
+
+ 	struct atmTrafficDescParamEntry *atmVclRxTrafficPtr;
+ 	struct atmTrafficDescParamEntry *atmVclTxTrafficPtr;
+ 	int atmVclRxTrafficPtr;
+ 	int atmVclTxTrafficPtr;
+	
+ 	unsigned char atmVccAalType;
+ 	unsigned int atmVccAal5TxSduSize;
+ 	unsigned int atmVccAal5RxSduSize;
+ 	int atmVccAal5Encap;
+ 	int atmVclRowStatus;
+ 	int atmVclCastType;
+ 	int atmVclConnKind;
+#endif	
+}atmVclEntry;
+atmVclEntry *my_loop_info_head= NULL;
+static long ret;
+#endif
+
+typedef struct my_data_info_s {
+   in_addr_t theaddr;
+   in_addr_t theoldaddr;
+   char hostname[64];
+   int lineno;
+} my_data_info;   
+
+/** NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+
+/** returns the first data point within the atmVclTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+}atmVclEntry;
+atmVclEntry *my_loop_info_head= NULL;
+static long ret;
+#endif
+
+typedef struct my_data_info_s {
+   in_addr_t theaddr;
+   in_addr_t theoldaddr;
+   char hostname[64];
+   int lineno;
+} my_data_info;   
+
+/** NOTE:
+ * - these get_ routines MUST return data that will not be freed (ie,
+ *   use static variables or persistent data).  It will be copied, if
+ *   needed, immediately after the get_ routine has been called.
+ * - these SET routines must copy the incoming data and can not take
+ *   ownership of the memory passed in by the val pointer.
+ */
+
+
+/** returns the first data point within the atmVclTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+atmVclTable_get_first_data_point(void **my_loop_context,
+                                       void **my_data_context,
+                                       netsnmp_variable_list *
+                                       put_index_data,
+                                       netsnmp_iterator_info *mydata)
+{
+#ifdef USING_EXAMPLE_CODE
+
+    my_loop_info *loopctx;
+
+    loopctx = SNMP_MALLOC_TYPEDEF(my_loop_info);
+
+    if (!loopctx)
+        return NULL; /*XXX log err */
+
+    loopctx->filep = fopen("/etc/hosts","r");
+
+    if (!loopctx->filep) {
+        free(loopctx);
+        return NULL;
+    }
+
+    /* at this point, we need to get the first name and address from
+       the file.  But since our get_next_data_point function does
+       this, we'll use it instead of duplicating code */
+    *my_loop_context = loopctx;
+
+    return atmVclTable_get_next_data_point(my_loop_context,
+                                                 my_data_context,
+                                                 put_index_data,
+                                                 mydata);
+#else
+
+    atmVclEntry *loopctx, *predata;
+
+printf("IFX_PLATFORM_API\n");
+// IFX_PLATFORM_API start-section
+    char tmpstring[64];
+	netsnmp_variable_list *vptr;
+
+    // 1st entry
+	loopctx = SNMP_MALLOC_TYPEDEF(atmVclEntry);
+	loopctx->ifIndex = 1; 
+	loopctx->atmVclvpi = 0; 
+	loopctx->atmVclvci = 33; 
+	loopctx->atmVclAdminStatus = 1; 
+	loopctx->atmVclOperStatus = 1; 
+	loopctx->atmVclLastChange = 111111; 
+	loopctx->atmVclRxTrafficPtr = NULL; 
+	loopctx->atmVclTxTrafficPtr = NULL; 
+	loopctx->atmVccAalType='a';
+	loopctx->atmVccAal5TxSduSize = 1; 
+	loopctx->atmVccAal5RxSduSize = 1; 
+	loopctx->atmVccAal5Encap = 1; 
+	loopctx->atmVclRowStatus = 1; 
+	loopctx->atmVclCastType = 1; 
+	loopctx-> atmVclConnKind = 1; 
+	
+	my_loop_info_head=loopctx;
+	predata = loopctx;
+	loopctx->next = NULL; 
+
+    // 2nd entry
+	loopctx = SNMP_MALLOC_TYPEDEF(atmVclEntry);
+	loopctx->ifIndex = 1; 
+	loopctx->atmVclvpi = 0; 
+	loopctx->atmVclvci = 34; 
+	loopctx->atmVclAdminStatus = 1; 
+	loopctx->atmVclOperStatus = 1; 
+	loopctx->atmVclLastChange = 111111; 
+	loopctx->atmVclRxTrafficPtr = NULL; 
+	loopctx->atmVclTxTrafficPtr = NULL; 
+	loopctx->atmVccAalType = 'b';
+	loopctx->atmVccAal5TxSduSize = 1; 
+	loopctx->atmVccAal5RxSduSize = 1; 
+	loopctx->atmVccAal5Encap = 1; 
+	loopctx->atmVclRowStatus = 1; 
+	loopctx->atmVclCastType = 1; 
+	loopctx-> atmVclConnKind = 1; 
+
+	predata->next = loopctx;
+	predata = loopctx;
+	loopctx->next = NULL; 
+ 	
+// IFX_PLATFORM_API end-section
+
+printf("my_loop_context\n");
+	*my_loop_context = (void *)my_loop_info_head->next;
+	*my_data_context = (void *)my_loop_info_head;
+
+	//snmp_set_var_value(put_index_data, (u_char *)my_loop_info_head->hostname,strlen(my_loop_info_head->hostname));
+
+printf("Pass first data point\n");
+	/* Pass first data point (IfIndex,vpi and vci) to agent */
+    vptr = put_index_data;
+    snmp_set_var_value(vptr, (u_char *)&(my_loop_info_head->ifIndex),sizeof(my_loop_info_head->ifIndex));
+
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr, (u_char *) &(my_loop_info_head->atmVclvpi), sizeof(my_loop_info_head->atmVclvpi));
+
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr, (u_char *)&(my_loop_info_head->atmVclvci),
+           sizeof(my_loop_info_head->atmVclvci));
+
+    return put_index_data; 
+#endif
+}
+
+/** functionally the same as atmVclTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+atmVclTable_get_next_data_point(void **my_loop_context,
+                                      void **my_data_context,
+                                      netsnmp_variable_list *
+                                      put_index_data,
+                                      netsnmp_iterator_info *mydata)
+{
+#ifdef USING_EXAMPLE_CODE
+    my_loop_info *loopctx = *my_loop_context;
+    char tmpstring[64];
+
+    if (!loopctx)
+        return NULL;
+
+    while(loopctx->filep) {
+        if (!loopctx->current_ptr) {
+            if (!fgets(loopctx->line, sizeof(loopctx->line), loopctx->filep)) {
+                /* we're done */
+                fclose(loopctx->filep);
+                loopctx->filep = NULL;
+                return NULL;
+            }
+            loopctx->lineno++;
+            loopctx->current_ptr = loopctx->line;
+            loopctx->current_ptr = skip_white(loopctx->current_ptr);
+
+            if (loopctx->current_ptr == NULL || *loopctx->current_ptr == '#') {
+                loopctx->current_ptr = NULL;
+                continue;
+            }
+
+            loopctx->current_ptr =
+                copy_nword(loopctx->current_ptr, tmpstring, sizeof(tmpstring));
+            loopctx->theaddr = inet_addr(tmpstring);
+
+            if (!loopctx->current_ptr)
+                continue;
+        }
+
+        loopctx->current_ptr =
+            copy_nword(loopctx->current_ptr, loopctx->hostname, sizeof(loopctx->hostname));
+        
+        snmp_set_var_value(put_index_data, (u_char *) loopctx->hostname,
+                           strlen(loopctx->hostname));
+        return put_index_data;
+    }
+    
+    /* we're out of data */
+    *my_loop_context = NULL;
+    return NULL;
+#else
+	netsnmp_variable_list *vptr;
+    atmVclEntry *loopctx = (atmVclEntry*) *my_loop_context;
+	
+    if (!loopctx)
+        return NULL;
+
+	*my_loop_context = (void *)loopctx->next;
+	*my_data_context = (void *)loopctx;
+
+	/* Pass first data point (IfIndex,vpi and vci) to agent */
+    vptr = put_index_data;
+    snmp_set_var_value(vptr, (u_char *)&(loopctx->ifIndex),sizeof(loopctx->ifIndex));
+
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr, (u_char *) &(loopctx->atmVclvpi), sizeof(loopctx->atmVclvpi));
+
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr, (u_char *)&(loopctx->atmVclvci),
+           sizeof(loopctx->atmVclvci));
+
+
+    return put_index_data; 
+
+#endif
+}
+
+#ifdef USING_EXAMPLE_CODE
+void *
+atmVclTable_context_convert_function(void *loop_context,
+                                           netsnmp_iterator_info *iinfo)
+{
+    my_loop_info *loopctx = loop_context;
+    my_data_info *datactx = SNMP_MALLOC_TYPEDEF(my_data_info);
+    if (!datactx)
+        return NULL;
+    datactx->theoldaddr = datactx->theaddr = loopctx->theaddr;
+    datactx->lineno = loopctx->lineno;
+    strcpy(datactx->hostname, loopctx->hostname);
+    return datactx;
+}
+
+/** Create a data_context for non-existent rows that SETs are performed on.
+ *  return a void * pointer which will be passed to subsequent get_XXX
+ *  and set_XXX functions for data retrival and modification during
+ *  this SET request.
+ *
+ *  The indexs are encoded (in order) into the index_data pointer if it
+ *  would be helpful to use that information.
+ */
+void           *
+atmVclTable_create_data_context(netsnmp_variable_list * index_data)
+{
+    my_data_info *datactx = SNMP_MALLOC_TYPEDEF(my_data_info);
+    if (!datactx)
+        return NULL;
+    strncpy(datactx->hostname, index_data->val.string,
+            strlen(index_data->val.string));
+    return datactx;
+}
+
+void
+atmVclTable_data_free(void *data, netsnmp_iterator_info *iinfo)
+{
+    free(data);
+}
+
+void
+atmVclTable_loop_free(void *loopctx, netsnmp_iterator_info *iinfo)
+{
+    free(loopctx);
+}
+#endif
+
+/** If the implemented set_* functions don't operate directly on the
+   real-live data (which is actually recommended), then this function
+   can be used to take a given my_data_context pointer and "commit" it
+   to whereever the modified data needs to be put back to.  For
+   example, if this was a routing table you could publish the modified
+   routes back into the kernel at this point.
+
+   rowStatus will be set to 1 if new, 0 if not or -1 if it should
+   be deleted.
+
+   If you free the data yourself, make sure to *my_data_context = NULL */
+int
+atmVclTable_commit_row(void **my_data_context, int new_or_del)
+{
+    /** Add any necessary commit code here */
+    FILE *in, *out;
+    char line[MAX_HOSTS_LINE], line2[MAX_HOSTS_LINE];
+    char myaddr[64], *cp;
+    my_data_info *datactx = *my_data_context;
+    size_t line2_sz;
+    int foundit = 0;
+
+    if (datactx->theaddr == datactx->theoldaddr && new_or_del != -1)
+        return SNMP_ERR_NOERROR; /* no change in the value */
+
+    if ((out = fopen(HOSTS_FILE ".snmp", "w")) == NULL)
+        return SNMP_ERR_COMMITFAILED;
+    
+    if ((in = fopen(HOSTS_FILE, "r")) == NULL)
+        return SNMP_ERR_COMMITFAILED;
+
+    while(fgets(line, sizeof(line), in)) {
+        copy_nword(line,myaddr,sizeof(myaddr));
+        if (inet_addr(myaddr) == datactx->theaddr && new_or_del != -1) {
+            foundit = 1;
+            /* right line to append to */
+            line[strlen(line)-1] = '\0'; /* nuke the new line */
+            fprintf(out, "%s %s\n", line, datactx->hostname);
+        } else if (inet_addr(myaddr) == datactx->theoldaddr) {
+            /* find and remove the name from the current line */
+            int count = 0;
+            cp = copy_nword(line, line2, sizeof(line2)); /* pass the addr */
+            if (strlen(line2) > sizeof(line2)-2) {
+              errorit:
+                fclose(in);
+                fclose(out);
+                unlink(HOSTS_FILE ".snmp");
+                return SNMP_ERR_RESOURCEUNAVAILABLE;
+            }
+            line2_sz = strlen(line2);
+            line2[line2_sz++] = '\t';
+            while(cp) {
+                cp = copy_nword(cp, &line2[line2_sz], sizeof(line2)-line2_sz);
+                if (strcmp(&line2[line2_sz], datactx->hostname) == 0) {
+                    /* a match, so don't add it to line2 (which means
+                       don't update the write line2_sz index */
+                } else {
+                    if (strlen(line2) > sizeof(line2)-2) {
+                        goto errorit;
+                    }
+                    line2_sz = strlen(line2);
+                    line2[line2_sz++] = ' ';
+                    count++;
+                }
+            }
+            if (count) {
+                /* at least one name was still present on the line, so
+                   save it to the new file */
+                line2[line2_sz] = '\0';
+                fprintf(out, "%s\n", line2);
+            }
+        } else {
+            fputs(line, out);
+        }
+    }
+
+    if (!foundit && new_or_del != -1) {
+        /* couldn't add it to an existing line, so append a new one */
+        fprintf(out, "%d.%d.%d.%d\t%s\n",
+                (0x000000ff & datactx->theaddr),
+                (0x0000ff00 & datactx->theaddr) >> 8,
+                (0x00ff0000 & datactx->theaddr) >> 16,
+                (0xff000000 & datactx->theaddr) >> 24,
+                datactx->hostname);
+    }
+    fclose(out); /* close out first to minimize race condition */
+    fclose(in);
+    /*
+     * race condition here - someone else could open the file after
+     *  we close it but before we can rename it.
+     */
+    if (!rename(HOSTS_FILE ".snmp", HOSTS_FILE))
+        return SNMP_ERR_COMMITFAILED;
+        
+    /*
+     * return no errors.  And there shouldn't be any!!!  Ever!!!  You
+     * should have checked the values long before this. 
+     */
+    return SNMP_ERR_NOERROR;
+}
+
+
+/*
+ * User-defined data access functions (per column) for data in table
+ * atmVclTable
+ */
+
+#ifdef USING_EXAMPLE_CODE
+
+long           *
+get_netSnmpHostAddressType(void *data_context, size_t * ret_len)
+{
+    static long ret = NETSNMPHOSTADDRESSTYPE_IPV4;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_netSnmpHostAddressType(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+char           *
+get_netSnmpHostAddress(void *data_context, size_t * ret_len)
+{
+    //my_data_info *datainfo = data_context;
+    my_loop_info *datainfo = data_context;
+    *ret_len = sizeof(in_addr_t);  /* XXX: make sure it's 4 */
+    return (char *) &datainfo->theaddr;
+}
+
+int
+set_netSnmpHostAddress(void *data_context, char *val, size_t val_len)
+{
+    my_data_info *datainfo = data_context;
+    memcpy(&datainfo->theaddr, val, val_len);
+    return SNMP_ERR_NOERROR;
+}
+
+long           *
+get_netSnmpHostStorage(void *data_context, size_t * ret_len)
+{
+    static long ret = ST_NONVOLATILE;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_netSnmpHostStorage(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR;
+}
+
+long           *
+get_netSnmpHostRowStatus(void *data_context, size_t * ret_len)
+{
+    static long ret = RS_ACTIVE;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_netSnmpHostRowStatus(void *data_context, long *val, size_t val_len)
+{
+    /* XXX */
+    return SNMP_ERR_NOERROR;
+}
+#else
+
+long           *
+get_atmVclAdminStatus(void *data_context, size_t * ret_len)
+{
+printf("entering get_atmVclAdminStatus\n");
+    atmVclEntry *datainfo = data_context;
+    ret = datainfo->atmVclAdminStatus;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_netSnmpHostAddressType(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+long           *
+get_atmVclOperStatus(void *data_context, size_t * ret_len)
+{
+    atmVclEntry *datainfo = data_context;
+    ret = datainfo->atmVclOperStatus;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVclOperStatus(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+
+long           *
+get_atmVclLastChange(void *data_context, size_t * ret_len)
+{
+    atmVclEntry *datainfo = data_context;
+    ret = datainfo->atmVclLastChange;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVclLastChange(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+long           *
+get_atmVclReceiveTrafficDescrIndex(void *data_context, size_t * ret_len)
+{
+    ret = 0;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVclReceiveTrafficDescrIndex(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+long           *
+get_atmVclTransmitTrafficDescrIndex(void *data_context, size_t * ret_len)
+{
+    ret = 0;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVclTransmitTrafficDescrIndex(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+long           *
+get_atmVccAalType(void *data_context, size_t * ret_len)
+{
+    atmVclEntry *datainfo = data_context;
+    ret = datainfo->atmVccAalType;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVccAalType(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+long           *
+get_atmVccAal5CpcsTransmitSduSize(void *data_context, size_t * ret_len)
+{
+    atmVclEntry *datainfo = data_context;
+    ret = datainfo->atmVccAal5TxSduSize;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVccAal5CpcsTransmitSduSize(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+long           *
+get_atmVccAal5CpcsReceiveSduSize(void *data_context, size_t * ret_len)
+{
+    atmVclEntry *datainfo = data_context;
+    ret = datainfo->atmVccAal5RxSduSize;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVccAal5CpcsReceiveSduSize(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+long           *
+get_atmVccAal5EncapType(void *data_context, size_t * ret_len)
+{
+    atmVclEntry *datainfo = data_context;
+    ret = datainfo->atmVccAal5Encap;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVccAal5EncapType(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+long           *
+get_atmVclCrossConnectIdentifier(void *data_context, size_t * ret_len)
+{
+    ret = 0;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVclCrossConnectIdentifier(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+long           *
+get_atmVclRowStatus(void *data_context, size_t * ret_len)
+{
+    atmVclEntry *datainfo = data_context;
+    ret = datainfo->atmVclRowStatus;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVclRowStatus(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+long           *
+get_atmVclCastType(void *data_context, size_t * ret_len)
+{
+    atmVclEntry *datainfo = data_context;
+    ret = datainfo->atmVclCastType;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVclCastType(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+long           *
+get_atmVclConnkind(void *data_context, size_t * ret_len)
+{
+    atmVclEntry *datainfo = data_context;
+    ret = datainfo->atmVclConnKind;
+    *ret_len = sizeof(ret);
+    return &ret;
+}
+
+int
+set_atmVclConnkind(void *data_context, long *val, size_t val_len)
+{
+    return SNMP_ERR_NOERROR; /* always ipv4 */
+}
+
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_access.h open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_access.h
--- net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_access.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_access.h	2009-12-16 12:59:35.000000000 +0530
@@ -0,0 +1,39 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.3 2003/05/31 00:11:57 hardaker Exp $
+ */
+#ifndef NETSNMPHOSTSTABLE_ACCESS_H
+#define NETSNMPHOSTSTABLE_ACCESS_H
+
+/** User-defined data access functions for data in table atmVclTable */
+/** row level accessors */
+Netsnmp_First_Data_Point atmVclTable_get_first_data_point;
+Netsnmp_Next_Data_Point atmVclTable_get_next_data_point;
+Netsnmp_Make_Data_Context atmVclTable_context_convert_function;
+Netsnmp_Free_Loop_Context atmVclTable_loop_free;
+Netsnmp_Free_Data_Context atmVclTable_data_free;
+
+int             atmVclTable_commit_row(void **my_data_context,
+                                             int new_or_del);
+void           *atmVclTable_create_data_context(netsnmp_variable_list
+                                                      * index_data);
+
+/** column accessors */
+long           *get_netSnmpHostAddressType(void *data_context,
+                                           size_t * ret_len);
+int             set_netSnmpHostAddressType(void *data_context, long *val,
+                                           size_t val_len);
+char           *get_netSnmpHostAddress(void *data_context,
+                                       size_t * ret_len);
+int             set_netSnmpHostAddress(void *data_context, char *val,
+                                       size_t val_len);
+long           *get_netSnmpHostStorage(void *data_context,
+                                       size_t * ret_len);
+int             set_netSnmpHostStorage(void *data_context, long *val,
+                                       size_t val_len);
+long           *get_netSnmpHostRowStatus(void *data_context,
+                                         size_t * ret_len);
+int             set_netSnmpHostRowStatus(void *data_context, long *val,
+                                         size_t val_len);
+
+#endif                          /* NETSNMPHOSTSTABLE_ACCESS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns.c open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns.c
--- net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns.c	2009-12-16 12:59:35.000000000 +0530
@@ -0,0 +1,189 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.check_values.conf,v 1.5 2003/05/31 00:11:57 hardaker Exp $
+ */
+
+/********************************************************************
+ *                       NOTE   NOTE   NOTE
+ *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
+ *   Modify the atmVclTable_checkfns_local.[ch] files insead so that you
+ *   can regenerate this one as mib2c improvements are made.
+ ********************************************************************/
+
+/*
+ * standard headers 
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include "atmVclTable_checkfns.h"
+#include "atmVclTable_checkfns_local.h"
+#include "atmVclTable_enums.h"
+
+/** Decides if an incoming value for the netSnmpHostAddressType mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_netSnmpHostAddressType(int type, long *val, size_t val_len,
+                             long *old_val, size_t old_val_len)
+{
+
+    int             ret;
+
+    /** Check to see that we were called legally */
+    if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+    if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the enums.  Legal values will continue, others return error. */
+    switch (*val) {
+    case NETSNMPHOSTADDRESSTYPE_UNKNOWN:
+    case NETSNMPHOSTADDRESSTYPE_IPV4:
+    case NETSNMPHOSTADDRESSTYPE_IPV6:
+    case NETSNMPHOSTADDRESSTYPE_IPV4Z:
+    case NETSNMPHOSTADDRESSTYPE_IPV6Z:
+    case NETSNMPHOSTADDRESSTYPE_DNS:
+        break;
+
+    /** not a legal enum value.  return an error */
+    default:
+        return SNMP_ERR_INCONSISTENTVALUE;
+    }
+    ret = SNMP_ERR_NOERROR;
+
+
+    /** looks ok, call the local version of the same function. */
+    return check_netSnmpHostAddressType_local(type, val, val_len, old_val,
+                                              old_val_len);
+}
+
+/** Decides if an incoming value for the netSnmpHostAddress mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_netSnmpHostAddress(int type, char *val, size_t val_len,
+                         char *old_val, size_t old_val_len)
+{
+
+    int             ret;
+
+    /** Check to see that we were called legally */
+    if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+    if (type != ASN_OCTET_STR)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the ranges of the passed value for legality */
+    if (!(val_len >= 0 && val_len <= 255)
+        ) {
+        return SNMP_ERR_WRONGVALUE;
+    }
+
+
+    /** looks ok, call the local version of the same function. */
+    return check_netSnmpHostAddress_local(type, val, val_len, old_val,
+                                          old_val_len);
+}
+
+/** Decides if an incoming value for the netSnmpHostStorage mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_netSnmpHostStorage(int type, long *val, size_t val_len,
+                         long *old_val, size_t old_val_len)
+{
+
+    int             ret;
+
+    /** Check to see that we were called legally */
+    if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+    if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the enums.  Legal values will continue, others return error. */
+    switch (*val) {
+    case NETSNMPHOSTSTORAGE_OTHER:
+    case NETSNMPHOSTSTORAGE_VOLATILE:
+    case NETSNMPHOSTSTORAGE_NONVOLATILE:
+    case NETSNMPHOSTSTORAGE_PERMANENT:
+    case NETSNMPHOSTSTORAGE_READONLY:
+        break;
+
+    /** not a legal enum value.  return an error */
+    default:
+        return SNMP_ERR_INCONSISTENTVALUE;
+    }
+    ret = SNMP_ERR_NOERROR;
+
+    if (ret =
+        check_storage_transition((old_val) ? *old_val : SNMP_STORAGE_NONE,
+                                 *val))
+        return ret;
+
+    /** looks ok, call the local version of the same function. */
+    return check_netSnmpHostStorage_local(type, val, val_len, old_val,
+                                          old_val_len);
+}
+
+/** Decides if an incoming value for the netSnmpHostRowStatus mib node is legal.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_netSnmpHostRowStatus(int type, long *val, size_t val_len,
+                           long *old_val, size_t old_val_len)
+{
+
+    int             ret;
+
+    /** Check to see that we were called legally */
+    if (!val)
+        return SNMP_ERR_GENERR;
+
+    /** Check the incoming type for correctness */
+    if (type != ASN_INTEGER)
+        return SNMP_ERR_WRONGTYPE;
+
+    /** Check the enums.  Legal values will continue, others return error. */
+    switch (*val) {
+    case NETSNMPHOSTROWSTATUS_ACTIVE:
+    case NETSNMPHOSTROWSTATUS_NOTINSERVICE:
+    case NETSNMPHOSTROWSTATUS_NOTREADY:
+    case NETSNMPHOSTROWSTATUS_CREATEANDGO:
+    case NETSNMPHOSTROWSTATUS_CREATEANDWAIT:
+    case NETSNMPHOSTROWSTATUS_DESTROY:
+        break;
+
+    /** not a legal enum value.  return an error */
+    default:
+        return SNMP_ERR_INCONSISTENTVALUE;
+    }
+    ret = SNMP_ERR_NOERROR;
+
+    if (ret =
+        check_rowstatus_transition((old_val) ? *old_val : RS_NONEXISTENT,
+                                   *val))
+        return ret;
+
+    /** looks ok, call the local version of the same function. */
+    return check_netSnmpHostRowStatus_local(type, val, val_len, old_val,
+                                            old_val_len);
+}
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns.h open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns.h
--- net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns.h	2009-12-16 12:59:35.000000000 +0530
@@ -0,0 +1,39 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.6 2003/02/20 00:52:07 hardaker Exp $
+ */
+
+/***********************************************************************
+ *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
+ *   Modify the atmVclTable_checkfns_local.[ch] files insead.
+ *   (so that you can regenerate this one as mib2c improvements are made)
+ ***********************************************************************/
+#ifndef NETSNMPHOSTSTABLE_CHECKFNS_H
+#define NETSNMPHOSTSTABLE_CHECKFNS_H
+
+/** make sure we load the functions that you can modify */
+config_require(atmMIB/atmVclTable/atmVclTable_checkfns_local)
+
+    /*
+     * these functions are designed to check incoming values for 
+     * columns in the atmVclTable table for legality with respect to 
+     * datatype and value.
+     */
+     int             check_netSnmpHostAddressType(int type, long *val,
+                                                  size_t val_len,
+                                                  long *old_val,
+                                                  size_t old_val_len);
+     int             check_netSnmpHostAddress(int type, char *val,
+                                              size_t val_len,
+                                              char *old_val,
+                                              size_t old_val_len);
+     int             check_netSnmpHostStorage(int type, long *val,
+                                              size_t val_len,
+                                              long *old_val,
+                                              size_t old_val_len);
+     int             check_netSnmpHostRowStatus(int type, long *val,
+                                                size_t val_len,
+                                                long *old_val,
+                                                size_t old_val_len);
+
+#endif                          /* NETSNMPHOSTSTABLE_CHECKFNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns_local.c open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns_local.c
--- net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns_local.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns_local.c	2009-12-16 12:59:36.000000000 +0530
@@ -0,0 +1,109 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.check_values_local.conf,v 5.1 2003/05/30 23:53:15 hardaker Exp $
+ */
+
+/*
+ * standard headers 
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include "atmVclTable_checkfns.h"
+#include "atmVclTable_enums.h"
+
+/** Decides if an incoming value for the netSnmpHostAddressType mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_netSnmpHostAddressType_local(int type, long *val, size_t val_len,
+                                   long *old_val, size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    if (*val != NETSNMPHOSTADDRESSTYPE_IPV4)
+        return SNMP_ERR_WRONGVALUE;
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the netSnmpHostAddress mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_netSnmpHostAddress_local(int type, char *val, size_t val_len,
+                               char *old_val, size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    if (val_len != 4)
+        return SNMP_ERR_WRONGVALUE;
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the netSnmpHostStorage mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_netSnmpHostStorage_local(int type, long *val, size_t val_len,
+                               long *old_val, size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    if (*val != ST_NONVOLATILE)
+        return SNMP_ERR_WRONGVALUE;
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
+
+/** Decides if an incoming value for the netSnmpHostRowStatus mib node is legal, from a local implementation specific viewpoint.
+ *  @param type    The incoming data type.
+ *  @param val     The value to be checked.
+ *  @param val_len The length of data stored in val (in bytes).
+ *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
+ */
+int
+check_netSnmpHostRowStatus_local(int type, long *val, size_t val_len,
+                                 long *old_val, size_t old_val_len)
+{
+
+    /** XXX: you may want to check aspects of the new value that
+       were not covered by the automatic checks by the parent function. */
+
+    /** XXX: you make want to check that the requested change from
+        the old value to the new value is legal (ie, the transistion
+        from one value to another is legal */
+
+    /** if everything looks ok, return SNMP_ERR_NOERROR */
+    return SNMP_ERR_NOERROR;
+}
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns_local.h open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns_local.h
--- net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns_local.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_checkfns_local.h	2009-12-16 12:59:36.000000000 +0530
@@ -0,0 +1,27 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : : mib2c.check_values_local.conf,v 5.1 2003/05/30 23:53:15 hardaker Exp $
+ * 
+ */
+#ifndef NETSNMPHOSTSTABLE_CHECKFNS_H
+#define NETSNMPHOSTSTABLE_CHECKFNS_H
+
+/*
+ * these functions are designed to check incoming values for 
+ * columns in the atmVclTable table for legality with respect to 
+ * datatype and value according to local conventions.  You should modify
+ * them as appropriate.  They will be called from parent check_value
+ * functions that are auto-generated using mib2c and the parent functions
+ * should NOT be modified.
+ */
+
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+int             check_(int type, char *val, size_t val_len, char *old_val,
+                       size_t old_val_len);
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+int             check_(int type, long *val, size_t val_len, long *old_val,
+                       size_t old_val_len);
+
+#endif                          /* NETSNMPHOSTSTABLE_CHECKFNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_columns.h open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_columns.h
--- net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_columns.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_columns.h	2009-12-16 12:59:36.000000000 +0530
@@ -0,0 +1,35 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef NETSNMPHOSTSTABLE_COLUMNS_H
+#define NETSNMPHOSTSTABLE_COLUMNS_H
+
+/*
+ * column number definitions for table atmVclTable 
+ */
+#if 1
+#define COLUMN_NETSNMPHOSTNAME		1
+#define COLUMN_NETSNMPHOSTADDRESSTYPE		2
+#define COLUMN_NETSNMPHOSTADDRESS		3
+#define COLUMN_NETSNMPHOSTSTORAGE		4
+#define COLUMN_NETSNMPHOSTROWSTATUS		5
+#endif 
+
+#define COLUMN_ATMVCLVPI		1
+#define COLUMN_ATMVCLVCI		2
+#define COLUMN_ATMVCLADMINSTATUS		3
+#define COLUMN_ATMVCLOPERSTATUS		4
+#define COLUMN_ATMVCLLASTCHANGE		5
+#define COLUMN_ATMVCLRECEIVETRAFFICDESCRINDEX		6
+#define COLUMN_ATMVCLTRANSMITTRAFFICDESCRINDEX		7
+#define COLUMN_ATMVCCAALTYPE		8
+#define COLUMN_ATMVCCAAL5CPCSTRANSMITSDUSIZE		9
+#define COLUMN_ATMVCCAAL5CPCSRECEIVESDUSIZE		10
+#define COLUMN_ATMVCCAAL5ENCAPSTYPE		11
+#define COLUMN_ATMVCLCROSSCONNECTIDENTIFIER		12
+#define COLUMN_ATMVCLROWSTATUS		13
+#define COLUMN_ATMVCLCASTTYPE		14
+#define COLUMN_ATMVCLCONNKIND		15
+
+#endif                          /* NETSNMPHOSTSTABLE_COLUMNS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_enums.h open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_enums.h
--- net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_enums.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB/atmVclTable/atmVclTable_enums.h	2009-12-16 12:59:36.000000000 +0530
@@ -0,0 +1,37 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef NETSNMPHOSTSTABLE_ENUMS_H
+#define NETSNMPHOSTSTABLE_ENUMS_H
+
+/*
+ * enums for column netSnmpHostAddressType 
+ */
+#define NETSNMPHOSTADDRESSTYPE_UNKNOWN		0
+#define NETSNMPHOSTADDRESSTYPE_IPV4		1
+#define NETSNMPHOSTADDRESSTYPE_IPV6		2
+#define NETSNMPHOSTADDRESSTYPE_IPV4Z		3
+#define NETSNMPHOSTADDRESSTYPE_IPV6Z		4
+#define NETSNMPHOSTADDRESSTYPE_DNS		16
+
+/*
+ * enums for column netSnmpHostStorage 
+ */
+#define NETSNMPHOSTSTORAGE_OTHER		1
+#define NETSNMPHOSTSTORAGE_VOLATILE		2
+#define NETSNMPHOSTSTORAGE_NONVOLATILE		3
+#define NETSNMPHOSTSTORAGE_PERMANENT		4
+#define NETSNMPHOSTSTORAGE_READONLY		5
+
+/*
+ * enums for column netSnmpHostRowStatus 
+ */
+#define NETSNMPHOSTROWSTATUS_ACTIVE		1
+#define NETSNMPHOSTROWSTATUS_NOTINSERVICE		2
+#define NETSNMPHOSTROWSTATUS_NOTREADY		3
+#define NETSNMPHOSTROWSTATUS_CREATEANDGO		4
+#define NETSNMPHOSTROWSTATUS_CREATEANDWAIT		5
+#define NETSNMPHOSTROWSTATUS_DESTROY		6
+
+#endif                          /* NETSNMPHOSTSTABLE_ENUMS_H */
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/debug.h open_snmp/agent/mibgroup/atmMIB/atmVclTable/debug.h
--- net-snmp-5.1/agent/mibgroup/atmMIB/atmVclTable/debug.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB/atmVclTable/debug.h	2009-12-16 12:59:36.000000000 +0530
@@ -0,0 +1 @@
+//#define USING_EXAMPLE_CODE
diff -Naur net-snmp-5.1/agent/mibgroup/atmMIB.h open_snmp/agent/mibgroup/atmMIB.h
--- net-snmp-5.1/agent/mibgroup/atmMIB.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/agent/mibgroup/atmMIB.h	2009-12-16 12:59:36.000000000 +0530
@@ -0,0 +1,2 @@
+config_require(atmMIB/atmVclTable/atmVclTable)
+config_add_mib(ATM-MIB)
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/at.c open_snmp/agent/mibgroup/mibII/at.c
--- net-snmp-5.1/agent/mibgroup/mibII/at.c	2002-12-19 21:44:10.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/at.c	2009-12-16 12:59:45.000000000 +0530
@@ -107,11 +107,11 @@
 #endif
 
         /*********************
-	 *
-	 *  Kernel & interface information,
-	 *   and internal forward declarations
-	 *
-	 *********************/
+     *
+     *  Kernel & interface information,
+     *   and internal forward declarations
+     *
+     *********************/
 
 #ifndef WIN32
 #ifndef solaris2
@@ -125,14 +125,14 @@
 #endif
 
         /*********************
-	 *
-	 *  Public interface functions
-	 *
-	 *********************/
+     *
+     *  Public interface functions
+     *
+     *********************/
 
 /*
  * define the structure we're going to ask the agent to register our
- * information at 
+ * information at
  */
 struct variable1 at_variables[] = {
     {ATIFINDEX, ASN_INTEGER, RONLY, var_atEntry, 1, {1}},
@@ -142,7 +142,7 @@
 
 /*
  * Define the OID pointer to the top of the mib tree that we're
- * registering underneath 
+ * registering underneath
  */
 oid             at_variables_oid[] = { SNMP_OID_MIB2, 3, 1, 1 };
 
@@ -150,7 +150,7 @@
 init_at(void)
 {
     /*
-     * register ourselves with the agent to handle our mib tree 
+     * register ourselves with the agent to handle our mib tree
      */
     REGISTER_MIB("mibII/at", at_variables, variable1, at_variables_oid);
 #ifdef solaris2
@@ -166,11 +166,11 @@
  * Arguments:
  * vp     IN      - pointer to variable entry that points here
  * name    IN/OUT  - IN/name requested, OUT/name found
- * length  IN/OUT  - length of IN/OUT oid's 
+ * length  IN/OUT  - length of IN/OUT oid's
  * exact   IN      - TRUE if an exact match was requested
  * var_len OUT     - length of variable or 0 if function returned
  * write_method
- * 
+ *
  */
 
 u_char         *
@@ -204,7 +204,7 @@
     int             oid_length;
 
     /*
-     * fill in object part of name for current (less sizeof instance part) 
+     * fill in object part of name for current (less sizeof instance part)
      */
     memcpy((char *) current, (char *) vp->name,
            (int) vp->namelen * sizeof(oid));
@@ -360,8 +360,8 @@
      * Interface is at offset 10,
      * IPADDR starts at offset 12.
      */
-#define AT_MAX_NAME_LENGTH	16
-#define AT_IFINDEX_OFF	10
+#define AT_MAX_NAME_LENGTH  16
+#define AT_IFINDEX_OFF  10
     u_char         *cp;
     oid            *op;
     oid             lowest[AT_MAX_NAME_LENGTH];
@@ -373,7 +373,7 @@
     int             offset, olength;
 
     /*
-     * fill in object part of name for current (less sizeof instance part) 
+     * fill in object part of name for current (less sizeof instance part)
      */
 
     DEBUGMSGTL(("mibII/at", "var_atEntry: "));
@@ -463,10 +463,10 @@
 
 
         /*********************
-	 *
-	 *  Internal implementation functions
-	 *
-	 *********************/
+     *
+     *  Internal implementation functions
+     *
+     *********************/
 
 #ifndef solaris2
 
@@ -486,12 +486,17 @@
 /*
  * at used to be allocated every time we needed to look at the arp cache.
  * This cause us to parse /proc/net/arp twice for each request and didn't
- * allow us to filter things like we'd like to.  So now we use it 
+ * allow us to filter things like we'd like to.  So now we use it
  * semi-statically.  We initialize it to size 0 and if we need more room
  * we realloc room for ARP_CACHE_INCR more entries in the table.
  * We never release what we've taken . . .
  */
+#if defined(HAVE_OPTIMIZED_CODE)
+#define ARP_CACHE_INCR 32
+#else
 #define ARP_CACHE_INCR 1024
+#endif
+
 static struct arptab *at = NULL;
 static int      arptab_curr_max_size = 0;
 
@@ -584,7 +589,7 @@
     }
 
     /*
-     * Get rid of the header line 
+     * Get rid of the header line
      */
     fgets(line, sizeof(line), in);
 
@@ -617,7 +622,7 @@
         }
         /*
          * Invalidated entries have their flag set to 0.
-         * * We want to ignore them 
+         * * We want to ignore them
          */
         if (tmp_flags == 0) {
             continue;
@@ -687,7 +692,7 @@
 #ifdef linux
     if (arptab_current < arptab_size) {
         /*
-         * copy values 
+         * copy values
          */
         *IPAddr = at[arptab_current].at_iaddr.s_addr;
         *ifType =
@@ -698,18 +703,18 @@
                sizeof(at[arptab_current].at_enaddr));
 
         /*
-         * increment to point next entry 
+         * increment to point next entry
          */
         arptab_current++;
         /*
-         * return success 
+         * return success
          */
         return (1);
     }
 #elif defined(hpux11)
     if (arptab_current < arptab_size) {
         /*
-         * copy values 
+         * copy values
          */
         *IPAddr = at[arptab_current].NetAddr;
         memcpy(PhysAddr, at[arptab_current].PhysAddr.o_bytes,
@@ -717,11 +722,11 @@
         *ifType = at[arptab_current].Type;
         *ifIndex = at[arptab_current].IfIndex;
         /*
-         * increment to point next entry 
+         * increment to point next entry
          */
         arptab_current++;
         /*
-         * return success 
+         * return success
          */
         return (1);
     }
@@ -732,13 +737,13 @@
 #ifdef STRUCT_ARPHD_HAS_AT_NEXT
         /*
          * The arp table is an array of linked lists of arptab entries.
-         * Unused slots have pointers back to the array entry itself 
+         * Unused slots have pointers back to the array entry itself
          */
 
         if (at_ptr == (auto_nlist_value(ARPTAB_SYMBOL) +
                        arptab_current * sizeof(struct arphd))) {
             /*
-             * Usused 
+             * Usused
              */
             arptab_current++;
             at_ptr = at[arptab_current].at_next;
@@ -832,7 +837,7 @@
     u_char          dest_addr[4];
 
     /*
-     * fill in object part of name for current (less sizeof instance part) 
+     * fill in object part of name for current (less sizeof instance part)
      */
     memcpy((char *) current, (char *) vp->name,
            (int) vp->namelen * sizeof(oid));
@@ -848,7 +853,7 @@
         pIpNetTable = (PMIB_IPNETTABLE) malloc(dwActualSize);
         if (pIpNetTable != NULL) {
             /*
-             * Get the sorted IpNet Table 
+             * Get the sorted IpNet Table
              */
             status = GetIpNetTable(pIpNetTable, &dwActualSize, TRUE);
         }
@@ -893,14 +898,14 @@
     }
     if (arp_row == NULL) {
         /*
-         * Free allocated memory in case of SET request's FREE phase 
+         * Free allocated memory in case of SET request's FREE phase
          */
         arp_row = (PMIB_IPNETROW) malloc(sizeof(MIB_IPNETROW));
     }
 
     if (lowState < 0 || status != NO_ERROR) {
         /*
-         * for creation of new row, only ipNetToMediaTable case is considered 
+         * for creation of new row, only ipNetToMediaTable case is considered
          */
         if (*length == 15 || *length == 16) {
             create_flag = 1;
@@ -1061,7 +1066,7 @@
         break;
     case RESERVE2:
         /*
-         * Save the old value, in case of UNDO 
+         * Save the old value, in case of UNDO
          */
         if (oldarp_row == NULL) {
             oldarp_row = (PMIB_IPNETROW) malloc(sizeof(MIB_IPNETROW));
@@ -1076,7 +1081,7 @@
             arp_row->dwIndex = *((int *) var_val);
             /*
              * In case of new entry, physical address is mandatory.
-             * * SetIpNetEntry will be done in COMMIT case 
+             * * SetIpNetEntry will be done in COMMIT case
              */
             if (!create_flag) {
                 if (SetIpNetEntry(arp_row) != NO_ERROR) {
@@ -1084,22 +1089,22 @@
                     retval = SNMP_ERR_COMMITFAILED;
                 }
                 /*
-                 * Don't know yet, whether change in ifIndex creates new row or not 
+                 * Don't know yet, whether change in ifIndex creates new row or not
                  */
                 /*
-                 * else{ 
+                 * else{
                  */
                 /*
-                 * temp_row.dwType = 2; 
+                 * temp_row.dwType = 2;
                  */
                 /*
-                 * if(SetIpNetEntry(&temp_row) != NO_ERROR) 
+                 * if(SetIpNetEntry(&temp_row) != NO_ERROR)
                  */
                 /*
-                 * retval = SNMP_ERR_COMMITFAILED; 
+                 * retval = SNMP_ERR_COMMITFAILED;
                  */
                 /*
-                 * } 
+                 * }
                  */
             }
             break;
@@ -1143,11 +1148,11 @@
         return retval;
     case UNDO:
         /*
-         * Reverse the SET action and free resources 
+         * Reverse the SET action and free resources
          */
         if (oldarp_row != NULL) {
             /*
-             * UNDO the changes done for existing entry. 
+             * UNDO the changes done for existing entry.
              */
             if (!create_flag) {
                 if ((status = SetIpNetEntry(oldarp_row)) != NO_ERROR) {
@@ -1176,7 +1181,7 @@
         break;
     case COMMIT:
         /*
-         * if new entry and physical address specified, create new entry 
+         * if new entry and physical address specified, create new entry
          */
         if (create_flag) {
             if (arp_row->dwPhysAddrLen != 0) {
@@ -1188,21 +1193,21 @@
                 }
             } else {
                 /*
-                 * For new entry, physical address must be set. 
+                 * For new entry, physical address must be set.
                  */
                 snmp_log(LOG_ERR,
                          "Can't create new entry without physical address\n");
                 retval = SNMP_ERR_WRONGVALUE;
             }
             /*
-             * unset the create_flag, so that CreateIpNetEntry called only once 
+             * unset the create_flag, so that CreateIpNetEntry called only once
              */
             create_flag = 0;
         }
 
     case FREE:
         /*
-         * Free any resources allocated 
+         * Free any resources allocated
          */
         free(oldarp_row);
         oldarp_row = NULL;
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/icmp.c open_snmp/agent/mibgroup/mibII/icmp.c
--- net-snmp-5.1/agent/mibgroup/mibII/icmp.c	2003-11-12 18:25:20.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/icmp.c	2009-12-16 12:59:45.000000000 +0530
@@ -24,31 +24,33 @@
 #include "icmp.h"
 #include "sysORTable.h"
 
+
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef MIB_STATS_CACHE_TIMEOUT
-#define MIB_STATS_CACHE_TIMEOUT	5
+#define MIB_STATS_CACHE_TIMEOUT 5
 #endif
 #ifndef ICMP_STATS_CACHE_TIMEOUT
-#define ICMP_STATS_CACHE_TIMEOUT	MIB_STATS_CACHE_TIMEOUT
+#define ICMP_STATS_CACHE_TIMEOUT    MIB_STATS_CACHE_TIMEOUT
+#endif
 #endif
-
         /*********************
-	 *
-	 *  Kernel & interface information,
-	 *   and internal forward declarations
-	 *
-	 *********************/
+     *
+     *  Kernel & interface information,
+     *   and internal forward declarations
+     *
+     *********************/
 
         /*********************
-	 *
-	 *  Initialisation & common implementation functions
-	 *
-	 *********************/
+     *
+     *  Initialisation & common implementation functions
+     *
+     *********************/
 
 
 
 /*
  * Define the OID pointer to the top of the mib tree that we're
- * registering underneath 
+ * registering underneath
  */
 oid             icmp_oid[] = { SNMP_OID_MIB2, 5 };
 #ifdef USING_MIBII_IP_MODULE
@@ -67,17 +69,19 @@
      */
     DEBUGMSGTL(("mibII/icmp", "Initialising ICMP group\n"));
     reginfo = netsnmp_create_handler_registration("icmp", icmp_handler,
-		    icmp_oid, OID_LENGTH(icmp_oid), HANDLER_CAN_RONLY);
+            icmp_oid, OID_LENGTH(icmp_oid), HANDLER_CAN_RONLY);
     netsnmp_register_scalar_group(reginfo, ICMPINMSGS, ICMPOUTADDRMASKREPS);
     /*
      * .... with a local cache
      *    (except for HP-UX 11, which extracts objects individually)
      */
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef hpux11
     netsnmp_inject_handler( reginfo,
-		    netsnmp_get_cache_handler(ICMP_STATS_CACHE_TIMEOUT,
-			   		icmp_load, icmp_free,
-					icmp_oid, OID_LENGTH(icmp_oid)));
+            netsnmp_get_cache_handler(ICMP_STATS_CACHE_TIMEOUT,
+                    icmp_load, icmp_free,
+                    icmp_oid, OID_LENGTH(icmp_oid)));
+#endif
 #endif
 
 #ifdef USING_MIBII_IP_MODULE
@@ -96,23 +100,29 @@
 
 
         /*********************
-	 *
-	 *  System specific data formats
-	 *
-	 *********************/
+     *
+     *  System specific data formats
+     *
+     *********************/
+#if defined(HAVE_OPTIMIZED_CODE)
+#define ICMP_STAT_STRUCTURE struct icmp_mib
+#define USES_SNMP_DESIGNED_ICMPSTAT
+#undef ICMPSTAT_SYMBOL
+
+#else
 
 #ifdef hpux11
-#define ICMP_STAT_STRUCTURE	int
+#define ICMP_STAT_STRUCTURE int
 #endif
 
 #ifdef linux
-#define ICMP_STAT_STRUCTURE	struct icmp_mib
+#define ICMP_STAT_STRUCTURE struct icmp_mib
 #define USES_SNMP_DESIGNED_ICMPSTAT
 #undef ICMPSTAT_SYMBOL
 #endif
 
 #ifdef solaris2
-#define ICMP_STAT_STRUCTURE	mib2_icmp_t
+#define ICMP_STAT_STRUCTURE mib2_icmp_t
 #define USES_SNMP_DESIGNED_ICMPSTAT
 #endif
 
@@ -121,29 +131,31 @@
 #define ICMP_STAT_STRUCTURE MIB_ICMP
 #endif
 
+#endif /* OPTIMIZED CODE */
+
 /* ?? #if (defined(CAN_USE_SYSCTL) && defined(ICMPCTL_STATS)) ?? */
 
 #ifdef HAVE_SYS_ICMPIPSTATS_H
-/* or #ifdef		HAVE_SYS_TCPIPSTATS_H  ??? */
-#define ICMP_STAT_STRUCTURE	struct kna
+/* or #ifdef        HAVE_SYS_TCPIPSTATS_H  ??? */
+#define ICMP_STAT_STRUCTURE struct kna
 #define USES_TRADITIONAL_ICMPSTAT
 #endif
 
 #if !defined(ICMP_STAT_STRUCTURE)
-#define ICMP_STAT_STRUCTURE	struct icmpstat
+#define ICMP_STAT_STRUCTURE struct icmpstat
 #define USES_TRADITIONAL_ICMPSTAT
 #endif
 
-
+#if !defined(HAVE_OPTIMIZED_CODE)
 ICMP_STAT_STRUCTURE icmpstat;
-
+#endif
 
         /*********************
-	 *
-	 *  System independent handler
-	 *       (mostly!)
-	 *
-	 *********************/
+     *
+     *  System independent handler
+     *       (mostly!)
+     *
+     *********************/
 
 int
 icmp_handler(netsnmp_mib_handler          *handler,
@@ -159,20 +171,41 @@
     int      i;
 #endif
 
+#if defined(HAVE_OPTIMIZED_CODE)
+    ICMP_STAT_STRUCTURE *icmpstat;
+    int protocol=0;
+    int ret;
+#endif
+
     /*
      * The cached data should already have been loaded by the
      *    cache handler, higher up the handler chain.
      * But just to be safe, check this and load it manually if necessary
      */
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef hpux11
     if (netsnmp_is_cache_valid(reqinfo)) {
-        icmp_load( NULL, NULL );	/* XXX - check for failure */
+        icmp_load( NULL, NULL );    /* XXX - check for failure */
     }
 #endif
+#endif
 
-
+#if defined(HAVE_OPTIMIZED_CODE)
+    icmpstat = calloc(1, sizeof(ICMP_STAT_STRUCTURE));
+    if (icmpstat == NULL) {
+        snmp_log(LOG_ERR, "mibII/icmp: Malloc Failed for icmpstat\n");
+        return SNMP_ERR_GENERR;
+    }
+    else {
+     /* Fill in the icmpstat structure variables */
+      protocol= IFX_ICMP_STATS;
+      ret = linux_read_mibII_stats_opt((void *)&icmpstat, protocol);
+      if ( ret != 0)
+      return SNMP_ERR_GENERR;
+     }
+#endif
     /*
-     * 
+     *
      *
      */
     DEBUGMSGTL(("mibII/icmp", "Handler - mode %s\n",
@@ -187,6 +220,92 @@
                                        requestvb->name_length));
             DEBUGMSG((   "mibII/icmp", "\n"));
 
+#if defined(HAVE_OPTIMIZED_CODE)
+            switch (subid) {
+#ifdef USES_SNMP_DESIGNED_ICMPSTAT
+    case ICMPINMSGS:
+        ret_value = icmpstat->icmpInMsgs;
+        break;
+    case ICMPINERRORS:
+        ret_value = icmpstat->icmpInErrors;
+        break;
+    case ICMPINDESTUNREACHS:
+        ret_value = icmpstat->icmpInDestUnreachs;
+        break;
+    case ICMPINTIMEEXCDS:
+        ret_value = icmpstat->icmpInTimeExcds;
+        break;
+    case ICMPINPARMPROBS:
+        ret_value = icmpstat->icmpInParmProbs;
+        break;
+    case ICMPINSRCQUENCHS:
+        ret_value = icmpstat->icmpInSrcQuenchs;
+        break;
+    case ICMPINREDIRECTS:
+        ret_value = icmpstat->icmpInRedirects;
+        break;
+    case ICMPINECHOS:
+        ret_value = icmpstat->icmpInEchos;
+        break;
+    case ICMPINECHOREPS:
+        ret_value = icmpstat->icmpInEchoReps;
+        break;
+    case ICMPINTIMESTAMPS:
+        ret_value = icmpstat->icmpInTimestamps;
+        break;
+    case ICMPINTIMESTAMPREPS:
+        ret_value = icmpstat->icmpInTimestampReps;
+        break;
+    case ICMPINADDRMASKS:
+        ret_value = icmpstat->icmpInAddrMasks;
+        break;
+    case ICMPINADDRMASKREPS:
+        ret_value = icmpstat->icmpInAddrMaskReps;
+        break;
+    case ICMPOUTMSGS:
+        ret_value = icmpstat->icmpOutMsgs;
+        break;
+    case ICMPOUTERRORS:
+        ret_value = icmpstat->icmpOutErrors;
+        break;
+    case ICMPOUTDESTUNREACHS:
+        ret_value = icmpstat->icmpOutDestUnreachs;
+        break;
+    case ICMPOUTTIMEEXCDS:
+        ret_value = icmpstat->icmpOutTimeExcds;
+        break;
+    case ICMPOUTPARMPROBS:
+        ret_value = icmpstat->icmpOutParmProbs;
+        break;
+    case ICMPOUTSRCQUENCHS:
+        ret_value = icmpstat->icmpOutSrcQuenchs;
+        break;
+    case ICMPOUTREDIRECTS:
+        ret_value = icmpstat->icmpOutRedirects;
+        break;
+    case ICMPOUTECHOS:
+        ret_value = icmpstat->icmpOutEchos;
+        break;
+    case ICMPOUTECHOREPS:
+        ret_value = icmpstat->icmpOutEchoReps;
+        break;
+    case ICMPOUTTIMESTAMPS:
+        ret_value = icmpstat->icmpOutTimestamps;
+        break;
+    case ICMPOUTTIMESTAMPREPS:
+        ret_value = icmpstat->icmpOutTimestampReps;
+        break;
+    case ICMPOUTADDRMASKS:
+        ret_value = icmpstat->icmpOutAddrMasks;
+        break;
+    case ICMPOUTADDRMASKREPS:
+        ret_value = icmpstat->icmpOutAddrMaskReps;
+        break;
+#endif                          /* USES_SNMP_DESIGNED_ICMPSTAT */
+        }
+
+#else   /* Non-Optimized Package */
+
             switch (subid) {
 #ifdef USES_SNMP_DESIGNED_ICMPSTAT
     case ICMPINMSGS:
@@ -385,15 +504,15 @@
     case ICMPOUTTIMESTAMPREPS:
     case ICMPOUTADDRMASKS:
     case ICMPOUTADDRMASKREPS:
-	/*
-	 * This is a bit of a hack, to shoehorn the HP-UX 11
-	 * single-object retrieval approach into the caching
-	 * architecture.
-	 */
-	if (icmp_load(NULL, (void*)subid) == -1 ) {
+    /*
+     * This is a bit of a hack, to shoehorn the HP-UX 11
+     * single-object retrieval approach into the caching
+     * architecture.
+     */
+    if (icmp_load(NULL, (void*)subid) == -1 ) {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
-	}
+    }
         ret_value = icmpstat;
         break;
 #else                          /* hpux11 */
@@ -481,10 +600,15 @@
 #endif                          /* hpux11 */
 #endif                          /* USES_TRADITIONAL_ICMPSTAT */
 #endif                          /* USES_SNMP_DESIGNED_ICMPSTAT */
-	    }
-	    snmp_set_var_typed_value(request->requestvb, ASN_COUNTER,
-			             (u_char *)&ret_value, sizeof(ret_value));
-	}
+        }
+#endif /* OPTIMIZED_CODE */
+        snmp_set_var_typed_value(request->requestvb, ASN_COUNTER,
+                         (u_char *)&ret_value, sizeof(ret_value));
+
+    }
+#if defined(HAVE_OPTIMIZED_CODE)
+        free(icmpstat);
+#endif
         break;
 
     case MODE_GETNEXT:
@@ -508,12 +632,13 @@
 }
 
 
-        /*********************
-	 *
-	 *  Internal implementation functions
-	 *
-	 *********************/
+    /*********************
+     *
+     *  Internal implementation functions
+     *
+     *********************/
 
+#if defined(HAVE_CACHE_SUPPORT)
 #ifdef hpux11
 int
 icmp_load(netsnmp_cache *cache, void *vmagic)
@@ -640,7 +765,7 @@
     }
     return ret_value;
 }
-#else		/* linux */
+#else       /* linux */
 #ifdef solaris2
 int
 icmp_load(netsnmp_cache *cache, void *vmagic)
@@ -658,7 +783,7 @@
     }
     return ret_value;
 }
-#else		/* solaris2 */
+#else       /* solaris2 */
 #ifdef WIN32
 int
 icmp_load(netsnmp_cache *cache, void *vmagic)
@@ -674,7 +799,7 @@
     }
     return ret_value;
 }
-#else		/* WIN32 */
+#else       /* WIN32 */
 #if (defined(CAN_USE_SYSCTL) && defined(ICMPCTL_STATS))
 int
 icmp_load(netsnmp_cache *cache, void *vmagic)
@@ -693,7 +818,7 @@
     }
     return ret_value;
 }
-#else		/* CAN_USE_SYSCTL && ICMPCTL_STATS */
+#else       /* CAN_USE_SYSCTL && ICMPCTL_STATS */
 #ifdef HAVE_SYS_TCPIPSTATS_H
 int
 icmp_load(netsnmp_cache *cache, void *vmagic)
@@ -710,7 +835,7 @@
     }
     return ret_value;
 }
-#else		/* HAVE_SYS_TCPIPSTATS_H */
+#else       /* HAVE_SYS_TCPIPSTATS_H */
 #ifdef ICMPSTAT_SYMBOL
 int
 icmp_load(netsnmp_cache *cache, void *vmagic)
@@ -727,7 +852,7 @@
     }
     return ret_value;
 }
-#else		/* ICMPSTAT_SYMBOL */
+#else       /* ICMPSTAT_SYMBOL */
 int
 icmp_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -736,16 +861,18 @@
     DEBUGMSGTL(("mibII/icmp", "Failed to load ICMP Group (null)\n"));
     return ret_value;
 }
-#endif		/* ICMPSTAT_SYMBOL */
-#endif		/* HAVE_SYS_TCPIPSTATS_H */
-#endif		/* CAN_USE_SYSCTL && ICMPCTL_STATS */
-#endif		/* WIN32 */
-#endif		/* solaris2 */
-#endif		/* linux */
-#endif		/* hpux11 */
+#endif      /* ICMPSTAT_SYMBOL */
+#endif      /* HAVE_SYS_TCPIPSTATS_H */
+#endif      /* CAN_USE_SYSCTL && ICMPCTL_STATS */
+#endif      /* WIN32 */
+#endif      /* solaris2 */
+#endif      /* linux */
+#endif      /* hpux11 */
 
 void
 icmp_free(netsnmp_cache *cache, void *magic)
 {
     memset(&icmpstat, 0, sizeof(icmpstat));
 }
+
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/interfaces.c open_snmp/agent/mibgroup/mibII/interfaces.c
--- net-snmp-5.1/agent/mibgroup/mibII/interfaces.c	2003-11-02 18:20:38.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/interfaces.c	2009-12-16 12:59:46.000000000 +0530
@@ -1,3 +1,50 @@
+
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : interfaces.c
+ * Author       : Subramani
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions:
+ *                 1) Which gets Ifindex from kernel instead of counting the
+ *                    nodes in the ifnet list
+ *                 2) Return the Number of interfaces in the IfTable as per
+ *                    the max Ifindex Number
+ *
+ *
+ * ===========================================================================
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
+
 /*
  *  Interfaces MIB group implementation - interfaces.c
  *
@@ -235,7 +282,7 @@
 
 /*
  * Define the OID pointer to the top of the mib tree that we're
- * registering underneath, and the OID of the MIB module 
+ * registering underneath, and the OID of the MIB module
  */
 oid             interfaces_variables_oid[] = { SNMP_OID_MIB2, 2 };
 oid             interfaces_module_oid[] = { SNMP_OID_MIB2, 31 };
@@ -244,7 +291,7 @@
 init_interfaces(void)
 {
     /*
-     * register ourselves with the agent to handle our mib tree 
+     * register ourselves with the agent to handle our mib tree
      */
     REGISTER_MIB("mibII/interfaces", interfaces_variables, variable3,
                  interfaces_variables_oid);
@@ -269,7 +316,7 @@
 /*
  * if_type_from_name
  * Return interface type using the interface name as a clue.
- * Returns 1 to imply "other" type if name not recognized. 
+ * Returns 1 to imply "other" type if name not recognized.
  */
 static int
 if_type_from_name(const char *pcch)
@@ -285,9 +332,13 @@
         {9, "tr"},
         {23, "ppp"},
         {28, "sl"},
+	{37, "atm_port"},
+	{49, "aal"},
+        {94, "MEI_PHY"},
+        {124, "MEI_INTL"},
+        {125, "MEI_FAST"},
         {0, 0}                  /* end of list */
     };
-
     int             ii, len;
     register pmatch_if pm;
 
@@ -319,7 +370,6 @@
 {
     conf_if_list   *if_ptr, *if_new;
     char           *name, *type, *speed, *ecp;
-
     name = strtok(cptr, " \t");
     if (!name) {
         config_perror("Missing NAME parameter");
@@ -390,11 +440,11 @@
  * Arguments:
  * vp     IN      - pointer to variable entry that points here
  * name    IN/OUT  - IN/name requested, OUT/name found
- * length  IN/OUT  - length of IN/OUT oid's 
+ * length  IN/OUT  - length of IN/OUT oid's
  * exact   IN      - TRUE if an exact match was requested
  * var_len OUT     - length of variable or 0 if function returned
  * write_method
- * 
+ *
  */
 #ifndef WIN32
 static int
@@ -403,10 +453,13 @@
                size_t * length,
                int exact, size_t * var_len, WriteMethod ** write_method)
 {
-#define IFENTRY_NAME_LENGTH	10
+#define IFENTRY_NAME_LENGTH 10
     oid             newname[MAX_OID_LEN];
     register int    interface;
     int             result, count;
+    short           IfIndex=0;
+    short           Match_Failed=1;
+
 
     DEBUGMSGTL(("mibII/interfaces", "var_ifEntry: "));
     DEBUGMSGOID(("mibII/interfaces", name, *length));
@@ -415,22 +468,45 @@
     memcpy((char *) newname, (char *) vp->name,
            (int) vp->namelen * sizeof(oid));
     /*
-     * find "next" interface 
+     * find "next" interface
      */
     count = Interface_Scan_Get_Count();
-    for (interface = 1; interface <= count; interface++) {
-        newname[IFENTRY_NAME_LENGTH] = (oid) interface;
+
+#ifdef Amazon
+        Interface_Scan_Init();
+     while (Interface_Scan_Next(&IfIndex, NULL, NULL, NULL) != 0) {
+         newname[IFENTRY_NAME_LENGTH] = (oid) IfIndex;
+#else
+      for (interface = 1; interface <= count; interface++) {
+          newname[IFENTRY_NAME_LENGTH] = (oid) interface;
+#endif
+
         result =
             snmp_oid_compare(name, *length, newname,
                              (int) vp->namelen + 1);
+#ifdef Amazon
+        if ((exact && (result == 0)) || (!exact && (result < 0))) {
+          Match_Failed=0;
+          break;
+        }
+#else
+
         if ((exact && (result == 0)) || (!exact && (result < 0)))
             break;
+#endif
     }
+#ifdef Amazon
+        if (Match_Failed == 1) {
+            DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
+            return MATCH_FAILED;
+         }
+#else
+
     if (interface > count) {
         DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
         return MATCH_FAILED;
     }
-
+#endif
 
     memcpy((char *) name, (char *) newname,
            ((int) vp->namelen + 1) * sizeof(oid));
@@ -442,9 +518,31 @@
     DEBUGMSGOID(("mibII/interfaces", name, *length));
     DEBUGMSG(("mibII/interfaces", "\n"));
 
-    return interface;
-}
+    // This is mem leak fix
+   /* temp = *ifnetaddr;
 
+     while(temp != NULL)
+     {
+      temp1 = temp->next;
+      free(temp);
+      temp = temp1;
+     } */
+
+     while (ifnetaddr_list) {
+        struct ifnet   *old = ifnetaddr_list;
+        ifnetaddr_list = ifnetaddr_list->if_next;
+        free(old->if_name);
+        free(old->if_unit);
+        free(old);
+    }
+
+#ifdef Amazon
+
+     return IfIndex;
+#else
+      return interface;
+#endif
+}
 
 
 u_char         *
@@ -459,7 +557,11 @@
 
     switch (vp->magic) {
     case IFNUMBER:
+#ifdef Amazon
+        long_return = Interface_Scan_Get_IfNumber();
+#else
         long_return = Interface_Scan_Get_Count();
+#endif
         return (u_char *) & long_return;
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_interfaces\n",
@@ -532,7 +634,7 @@
                      * existence of struct sockaddr_new.  Hopefully, on
                      * other systems we can simply use get_in_address
                      * three times, with (ifap+1) as the starting
-                     * address. 
+                     * address.
                      */
 
                     sifa->sifa_netmask =
@@ -578,11 +680,10 @@
     long            n = 0;
 
     Interface_Scan_Init();
-
     if (if_list_size) {
         for (cp = if_list, n = 0; cp < if_list_end; cp += ifp->ifm_msglen) {
             ifp = (struct if_msghdr *) cp;
-    
+
             if (ifp->ifm_type == RTM_IFINFO) {
                 ++n;
             }
@@ -668,7 +769,7 @@
         return (u_char *) & long_return;
     case IFPHYSADDRESS:
         /*
-         * XXX 
+         * XXX
          */
         return NULL;
     case IFADMINSTATUS:
@@ -678,7 +779,7 @@
         long_return = if_msg.ifm_flags & IFF_RUNNING ? 1 : 2;
         return (u_char *) & long_return;
         /*
-         * ifLastChange 
+         * ifLastChange
          */
     case IFINOCTETS:
         long_return = (u_long) if_msg.ifm_data.ifi_ibytes;
@@ -758,11 +859,11 @@
 #else                           /* not USE_SYSCTL_IFLIST */
 
         /*********************
-	 *
-	 *  Kernel & interface information,
-	 *   and internal forward declarations
-	 *
-	 *********************/
+     *
+     *  Kernel & interface information,
+     *   and internal forward declarations
+     *
+     *********************/
 
 #ifndef HAVE_NET_IF_MIB_H
 
@@ -779,10 +880,10 @@
 
 
         /*********************
-	 *
-	 *  System specific implementation functions
-	 *
-	 *********************/
+     *
+     *  System specific implementation functions
+     *
+     *********************/
 
 
 #ifndef solaris2
@@ -1038,7 +1139,6 @@
     int             hp_len = sizeof(hp_ifEntry);
 #endif
 
-
     interface =
         header_ifEntry(vp, name, length, exact, var_len, write_method);
     if (interface == MATCH_FAILED)
@@ -1303,6 +1403,7 @@
         DEBUGMSGTL(("mibII/interfaces", "... no mib stats\n"));
         return NULL;
     }
+
     switch (vp->magic) {
     case IFINDEX:
         long_return = ifstat.ifIndex;
@@ -1381,10 +1482,10 @@
 
 
         /*********************
-	 *
-	 *  Internal implementation functions
-	 *
-	 *********************/
+     *
+     *  Internal implementation functions
+     *
+     *********************/
 
 
 #ifndef solaris2
@@ -1400,92 +1501,91 @@
 
 /**
 * Determines network interface speed. It is system specific. Only linux
-* realization is made. 
+* realization is made.
 */
 unsigned int getIfSpeed(int fd, struct ifreq ifr){
-	unsigned int retspeed = 10000000;
+    unsigned int retspeed = 10000000;
 #ifdef linux
 /* the code is based on mii-diag utility by Donald Becker
 * see ftp://ftp.scyld.com/pub/diag/mii-diag.c
 */
-	ushort *data = (ushort *)(&ifr.ifr_data);
-	unsigned phy_id;
-	unsigned char new_ioctl_nums = 0;
-	int mii_reg, i;
-	ushort mii_val[32];
-	ushort bmcr, bmsr, nway_advert, lkpar;
-	const unsigned int media_speeds[] = {10000000, 10000000, 100000000, 100000000, 10000000, 0};	
+    ushort *data = (ushort *)(&ifr.ifr_data);
+    unsigned phy_id;
+    unsigned char new_ioctl_nums = 0;
+    int mii_reg, i;
+    ushort mii_val[32];
+    ushort bmcr, bmsr, nway_advert, lkpar;
+    const unsigned int media_speeds[] = {10000000, 10000000, 100000000, 100000000, 10000000, 0};
 /* It corresponds to "10baseT", "10baseT-FD", "100baseTx", "100baseTx-FD", "100baseT4", "Flow-control", 0, */
 
+    data[0] = 0;
 
-	data[0] = 0;
-
-	if (ioctl(fd, 0x8947, &ifr) >= 0) {
-		new_ioctl_nums = 1;
-	} else if (ioctl(fd, SIOCDEVPRIVATE, &ifr) >= 0) {
-		new_ioctl_nums = 0;
-	} else {
-		DEBUGMSGTL(("mibII/interfaces", "SIOCGMIIPHY on %s failed\n", ifr.ifr_name));
-		return retspeed;
-	}
+    if (ioctl(fd, 0x8947, &ifr) >= 0) {
+        new_ioctl_nums = 1;
+    } else if (ioctl(fd, SIOCDEVPRIVATE, &ifr) >= 0) {
+        new_ioctl_nums = 0;
+    } else {
+        DEBUGMSGTL(("mibII/interfaces", "SIOCGMIIPHY on %s failed\n", ifr.ifr_name));
+        return retspeed;
+    }
 /* Begin getting mii register values */
-	phy_id = data[0];
-	for (mii_reg = 0; mii_reg < 8; mii_reg++){
-		data[0] = phy_id;
-		data[1] = mii_reg;
-		if(ioctl(fd, new_ioctl_nums ? 0x8948 : SIOCDEVPRIVATE+1, &ifr) <0){
-			DEBUGMSGTL(("mibII/interfaces", "SIOCGMIIREG on %s failed\n", ifr.ifr_name));
-		}
-		mii_val[mii_reg] = data[3];		
-	}
+    phy_id = data[0];
+    for (mii_reg = 0; mii_reg < 8; mii_reg++){
+        data[0] = phy_id;
+        data[1] = mii_reg;
+        if(ioctl(fd, new_ioctl_nums ? 0x8948 : SIOCDEVPRIVATE+1, &ifr) <0){
+            DEBUGMSGTL(("mibII/interfaces", "SIOCGMIIREG on %s failed\n", ifr.ifr_name));
+        }
+        mii_val[mii_reg] = data[3];
+    }
 /*Parsing of mii values*/
 /*Invalid basic mode control register*/
-	if (mii_val[0] == 0xffff  ||  mii_val[1] == 0x0000) {
-		DEBUGMSGTL(("mibII/interfaces", "No MII transceiver present!.\n"));
-		return retspeed;
-	}
-	/* Descriptive rename. */
-	bmcr = mii_val[0]; 	  /*basic mode control register*/
-	bmsr = mii_val[1]; 	  /* basic mode status register*/
-	nway_advert = mii_val[4]; /* autonegotiation advertisement*/
-	lkpar = mii_val[5]; 	  /*link partner ability*/
-	
+    if (mii_val[0] == 0xffff  ||  mii_val[1] == 0x0000) {
+        DEBUGMSGTL(("mibII/interfaces", "No MII transceiver present!.\n"));
+        return retspeed;
+    }
+    /* Descriptive rename. */
+    bmcr = mii_val[0];    /*basic mode control register*/
+    bmsr = mii_val[1];    /* basic mode status register*/
+    nway_advert = mii_val[4]; /* autonegotiation advertisement*/
+    lkpar = mii_val[5];       /*link partner ability*/
+
 /*Check for link existence, returns 0 if link is absent*/
-	if ((bmsr & 0x0016) != 0x0004){
-		DEBUGMSGTL(("mibII/interfaces", "No link...\n"));
-		retspeed = 0;
-		return retspeed;
-	}
-	
-	if(!(bmcr & 0x1000) ){
-		DEBUGMSGTL(("mibII/interfaces", "Auto-negotiation disabled.\n"));
-		retspeed = bmcr & 0x2000 ? 100000000 : 10000000;
-		return retspeed;
-	}
-/* Link partner got our advertised abilities */	
-	if (lkpar & 0x4000) {
-		int negotiated = nway_advert & lkpar & 0x3e0;
-		int max_capability = 0;
-		/* Scan for the highest negotiated capability, highest priority
-		   (100baseTx-FDX) to lowest (10baseT-HDX). */
-		int media_priority[] = {8, 9, 7, 6, 5}; 	/* media_names[i-5] */
-		for (i = 0; media_priority[i]; i++){
-			if (negotiated & (1 << media_priority[i])) {
-				max_capability = media_priority[i];
-				break;
-			}
-		}
-		if (max_capability)
-			retspeed = media_speeds[max_capability - 5];
-		else
-			DEBUGMSGTL(("mibII/interfaces", "No common media type was autonegotiated!\n"));
-	}else if(lkpar & 0x00A0){
-		retspeed = (lkpar & 0x0080) ? 100000000 : 10000000;
-	}
-	return retspeed;
-#else /*!linux*/			   
-	return retspeed;
-#endif 
+    if ((bmsr & 0x0016) != 0x0004){
+        DEBUGMSGTL(("mibII/interfaces", "No link...\n"));
+        retspeed = 0;
+        return retspeed;
+    }
+
+    if(!(bmcr & 0x1000) ){
+        DEBUGMSGTL(("mibII/interfaces", "Auto-negotiation disabled.\n"));
+        retspeed = bmcr & 0x2000 ? 100000000 : 10000000;
+        return retspeed;
+    }
+/* Link partner got our advertised abilities */
+    if (lkpar & 0x4000) {
+        int negotiated = nway_advert & lkpar & 0x3e0;
+        int max_capability = 0;
+        /* Scan for the highest negotiated capability, highest priority
+           (100baseTx-FDX) to lowest (10baseT-HDX). */
+        int media_priority[] = {8, 9, 7, 6, 5};     /* media_names[i-5] */
+        for (i = 0; media_priority[i]; i++){
+            if (negotiated & (1 << media_priority[i])) {
+                max_capability = media_priority[i];
+                break;
+            }
+        }
+        if (max_capability)
+            retspeed = media_speeds[max_capability - 5];
+        else
+            DEBUGMSGTL(("mibII/interfaces", "No common media type was autonegotiated!\n"));
+    }else if(lkpar & 0x00A0){
+        retspeed = (lkpar & 0x0080) ? 100000000 : 10000000;
+    }
+    return retspeed;
+#else /*!linux*/
+    return retspeed;
+#endif
 }
 
 void
@@ -1525,7 +1625,7 @@
     LastLoad = et.tv_sec;
 
     /*
-     * free old list: 
+     * free old list:
      */
     while (ifnetaddr_list) {
         struct ifnet   *old = ifnetaddr_list;
@@ -1545,11 +1645,11 @@
     }
 
     /*
-     * build up ifnetaddr list by hand: 
+     * build up ifnetaddr list by hand:
      */
 
     /*
-     * at least linux v1.3.53 says EMFILE without reason... 
+     * at least linux v1.3.53 says EMFILE without reason...
      */
     if (!(devin = fopen("/proc/net/dev", "r"))) {
         close(fd);
@@ -1563,7 +1663,7 @@
      * read the second line (a header) and determine the fields we
      * should read from.  This should be done in a better way by
      * actually looking for the field names we want.  But thats too
-     * much work for today.  -- Wes 
+     * much work for today.  -- Wes
      */
     fgets(line, sizeof(line), devin);
     fgets(line, sizeof(line), devin);
@@ -1626,14 +1726,14 @@
             break;              /* alloc error */
 
         /*
-         * chain in: 
+         * chain in:
          */
         *ifnetaddr_ptr = nnew;
         ifnetaddr_ptr = &nnew->if_next;
         i++;
 
         /*
-         * linux previous to 1.3.~13 may miss transmitted loopback pkts: 
+         * linux previous to 1.3.~13 may miss transmitted loopback pkts:
          */
         if (!strcmp(ifname_buf, "lo") && rec_pkt > 0 && !snd_pkt)
             snd_pkt = rec_pkt;
@@ -1654,12 +1754,12 @@
         }
 
         /*
-         * ifnames are given as ``   eth0'': split in ``eth'' and ``0'': 
+         * ifnames are given as ``   eth0'': split in ``eth'' and ``0'':
          */
         for (ifname = ifname_buf; *ifname && *ifname == ' '; ifname++);
 
         /*
-         * set name and interface# : 
+         * set name and interface# :
          */
         nnew->if_name = (char *) strdup(ifname);
         for (ptr = nnew->if_name; *ptr && (*ptr < '0' || *ptr > '9');
@@ -1749,7 +1849,7 @@
                 break;
 #endif
                 /*
-                 * XXX: more if_arp.h:ARPHDR_xxx to IANAifType mappings... 
+                 * XXX: more if_arp.h:ARPHDR_xxx to IANAifType mappings...
                  */
             }
 #endif
@@ -1779,7 +1879,7 @@
         } else {
             /*
              * do only guess if_type from name, if we could not read
-             * * it before from SIOCGIFHWADDR 
+             * * it before from SIOCGIFHWADDR
              */
             if (!nnew->if_type)
                 nnew->if_type = if_type_from_name(nnew->if_name);
@@ -1818,7 +1918,7 @@
 #if defined(sunV3) || defined(linux)
 /*
  * **  4.2 BSD doesn't have ifaddr
- * **  
+ * **
  */
 int
 Interface_Scan_Next(short *Index,
@@ -1857,8 +1957,15 @@
 #endif
         if (1 || strcmp(saveName, "lo0") != 0) {        /* XXX */
 
+// Modification made for Amazon
+#ifdef Amazon
+           if (Index)
+              GetIfIndex(saveName,Index);
+#else
             if (Index)
                 *Index = ++saveIndex;
+#endif
+
             if (Retifnet)
                 *Retifnet = ifnet;
             if (Name)
@@ -1866,7 +1973,6 @@
             saveifnet = ifnet;
             saveifnetaddr = ifnetaddr;
             ifnetaddr = ifnet.if_next;
-
             return (1);         /* DONE */
         }
         ifnetaddr = ifnet.if_next;
@@ -1880,10 +1986,18 @@
 {
     short           ifIndex = 0;
     char            ifName[20];
-
     Interface_Scan_Init();
     while (Interface_Scan_Next(&ifIndex, ifName, NULL, NULL)
            && strcmp(Name, ifName));
+     // This is mem fix
+     while (ifnetaddr_list) {
+        struct ifnet   *old = ifnetaddr_list;
+        ifnetaddr_list = ifnetaddr_list->if_next;
+        free(old->if_name);
+        free(old->if_unit);
+        free(old);
+    }
+
     return ifIndex;
 }
 #endif
@@ -1913,7 +2027,6 @@
         else
             return (0);         /* EOF */
     }
-
     if (saveIndex >= count)
         return (0);             /* EOF */
 
@@ -1944,7 +2057,6 @@
 #if !STRUCT_IFNET_HAS_IF_XNAME
     register char  *cp;
 #endif
-
     while (ifnetaddr) {
         /*
          *      Get the "ifnet" structure and extract the device name
@@ -1980,7 +2092,7 @@
                         sizeof(in_ifaddr));
                 {
 #ifdef netbsd1
-#define CP(x)	((char *)(x))
+#define CP(x)   ((char *)(x))
                     char           *cp;
                     struct sockaddr *sa;
                     cp = (CP(in_ifaddr.ia_ifa.ifa_addr) - CP(ia)) +
@@ -2006,9 +2118,9 @@
             ifnet.if_addrlist = (struct ifaddr *) ia;   /* WRONG DATA TYPE; ONLY A FLAG */
 #endif
             /*
-             * ifnet.if_addrlist = (struct ifaddr *)&ia->ia_ifa;   
+             * ifnet.if_addrlist = (struct ifaddr *)&ia->ia_ifa;
              *
-             * WRONG DATA TYPE; ONLY A FLAG 
+             * WRONG DATA TYPE; ONLY A FLAG
              */
 
             if (Index)
@@ -2088,7 +2200,6 @@
         int             val;
         unsigned int    ulen;
         int             ret;
-
         if ((fd = open_mib("/dev/ip", O_RDONLY, 0, NM_ASYNC_OFF)) >= 0) {
             p.objid = ID_ifNumber;
             p.buffer = (void *) &val;
@@ -2110,7 +2221,6 @@
 Interface_Scan_Get_Count(void)
 {
     time_t          time_now = time(NULL);
-
     if (!Interface_Count || (time_now > scan_time + 60)) {
         scan_time = time_now;
         Interface_Scan_Init();
@@ -2119,9 +2229,45 @@
             Interface_Count++;
         }
     }
+    // This is mem fix
+    while (ifnetaddr_list) {
+        struct ifnet   *old = ifnetaddr_list;
+        ifnetaddr_list = ifnetaddr_list->if_next;
+        free(old->if_name);
+        free(old->if_unit);
+        free(old);
+    }
+
     return (Interface_Count);
 }
 
+// Modification for Amazon
+
+#ifdef Amazon
+int
+Interface_Scan_Get_IfNumber(void)
+{
+    short IfIndex=0;
+    int IfIndex_Max=0;
+
+        Interface_Scan_Init();
+
+        while (Interface_Scan_Next(&IfIndex, NULL, NULL, NULL) != 0) {
+            if (IfIndex > IfIndex_Max)
+            IfIndex_Max=IfIndex;
+
+          }
+   // This is mem fix
+   while (ifnetaddr_list) {
+        struct ifnet   *old = ifnetaddr_list;
+        ifnetaddr_list = ifnetaddr_list->if_next;
+        free(old->if_name);
+        free(old->if_unit);
+        free(old);
+    }
+    return (IfIndex_Max);
+}
+#endif
 
 static int
 Interface_Get_Ether_By_Index(int Index, u_char * EtherAddr)
@@ -2246,7 +2392,6 @@
     struct ifconf   ifc;
     struct ifreq   *ifrp = NULL;
     char           *buf = NULL;
-
     if (Name == 0) {
         return 0;
     }
@@ -2257,7 +2402,7 @@
     /*
      * Cope with lots of interfaces and brokenness of ioctl SIOCGIFCONF
      * on some platforms; see W. R. Stevens, ``Unix Network Programming
-     * Volume I'', p.435.  
+     * Volume I'', p.435.
      */
 
     for (i = 8;; i += 8) {
@@ -2272,19 +2417,19 @@
         if (ioctl(sd, SIOCGIFCONF, (char *) &ifc) < 0) {
             if (errno != EINVAL || lastlen != 0) {
                 /*
-                 * Something has gone genuinely wrong.  
+                 * Something has gone genuinely wrong.
                  */
                 free(buf);
                 close(sd);
                 return 0;
             }
             /*
-             * Otherwise, it could just be that the buffer is too small.  
+             * Otherwise, it could just be that the buffer is too small.
              */
         } else {
             if (ifc.ifc_len == lastlen) {
                 /*
-                 * The length is the same as the last time; we're done.  
+                 * The length is the same as the last time; we're done.
                  */
                 break;
             }
@@ -2609,7 +2754,7 @@
                size_t * length,
                int exact, size_t * var_len, WriteMethod ** write_method)
 {
-#define IFENTRY_NAME_LENGTH	10
+#define IFENTRY_NAME_LENGTH 10
     oid             newname[MAX_OID_LEN];
     register int    ifIndex;
     int             result, count;
@@ -2625,23 +2770,23 @@
     memcpy((char *) newname, (char *) vp->name,
            (int) vp->namelen * sizeof(oid));
     /*
-     * find "next" ifIndex 
+     * find "next" ifIndex
      */
 
 
     /*
-     * query for buffer size needed 
+     * query for buffer size needed
      */
     status = GetIfTable(pIfTable, &dwActualSize, TRUE);
 
     if (status == ERROR_INSUFFICIENT_BUFFER) {
         /*
-         * need more space 
+         * need more space
          */
         pIfTable = (PMIB_IFTABLE) malloc(dwActualSize);
         if (pIfTable != NULL) {
             /*
-             * Get the sorted IF table 
+             * Get the sorted IF table
              */
             GetIfTable(pIfTable, &dwActualSize, TRUE);
         }
@@ -2717,8 +2862,9 @@
         return NULL;
 
     /*
-     * Get the If Table Row by passing index as argument 
+     * Get the If Table Row by passing index as argument
      */
+
     ifRow.dwIndex = ifIndex;
     if (GetIfEntry(&ifRow) != NO_ERROR)
         return NULL;
@@ -2824,7 +2970,7 @@
         }
 
         /*
-         * The dwAdminStatus member can be MIB_IF_ADMIN_STATUS_UP or MIB_IF_ADMIN_STATUS_DOWN 
+         * The dwAdminStatus member can be MIB_IF_ADMIN_STATUS_UP or MIB_IF_ADMIN_STATUS_DOWN
          */
         if (!(((int) (*var_val) == MIB_IF_ADMIN_STATUS_UP) ||
               ((int) (*var_val) == MIB_IF_ADMIN_STATUS_DOWN))) {
@@ -2838,7 +2984,7 @@
 
     case ACTION:
         /*
-         * Save the old value, in case of UNDO 
+         * Save the old value, in case of UNDO
          */
 
         oldadmin_status = admin_status;
@@ -2854,7 +3000,7 @@
         ifEntryRow.dwIndex = (int) name[10];
         ifEntryRow.dwAdminStatus = admin_status;
         /*
-         * Only UP and DOWN status are supported. Thats why done in COMMIT 
+         * Only UP and DOWN status are supported. Thats why done in COMMIT
          */
         if (SetIfEntry(&ifEntryRow) != NO_ERROR) {
             snmp_log(LOG_ERR,
@@ -2865,10 +3011,42 @@
 
     case FREE:                 /* Free any resources allocated */
         /*
-         * No resources have been allocated 
+         * No resources have been allocated
          */
         break;
     }
     return SNMP_ERR_NOERROR;
 }                               /* end of writeIfEntry */
 #endif                          /* WIN32 */
+
+#ifdef Amazon
+void GetIfIndex(char *savename,short *Index)
+{
+
+    int skfd =0;
+    struct ifreq ifr;
+  /* Create a socket to the INET6 kernel. */
+ if ((skfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+ perror("socket");
+           *Index = 0;
+            return;
+ }
+
+ memset(&ifr, 0, sizeof(ifr));
+ strcpy(ifr.ifr_name, savename);
+
+ if (ioctl(skfd, SIOGIFINDEX, &ifr) < 0) {
+
+           *Index = 0;
+            return;
+
+         } else {
+
+             *Index = ifr.ifr_ifindex;
+             printf("\nName of interface  =%s\n",savename);
+             printf("\nIndex for %s interface  =%d\n",savename,*Index);
+         }
+
+    close(skfd);
+}
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/interfaces.h open_snmp/agent/mibgroup/mibII/interfaces.h
--- net-snmp-5.1/agent/mibgroup/mibII/interfaces.h	2002-04-20 13:00:04.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/interfaces.h	2009-12-16 12:59:46.000000000 +0530
@@ -1,3 +1,48 @@
+
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : interfaces.h
+ * Author       : Subramani
+ * Date         : 17-Jun-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs
+ *
+ * ===========================================================================
+ * Contents: This file contains functions:
+ *                 1) Which gets Ifindex from kernel instead of counting the 
+ *                    nodes in the ifnet list
+ *                 2) Return the Number of interfaces in the IfTable as per
+ *                    the max Ifindex Number
+ *
+ *
+ * ===========================================================================
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
 /*
  *  Interfaces MIB group interface - interfaces.h
  *
@@ -5,6 +50,12 @@
 #ifndef _MIBGROUP_INTERFACES_H
 #define _MIBGROUP_INTERFACES_H
 
+#if defined(IFX_CONFIG_SNMP_ATM_MIB) || defined(IFX_CONFIG_SNMP_ADSL_MIB)
+#define Amazon
+#else
+#undef Amazon
+#endif
+
 config_require(util_funcs)
     config_arch_require(solaris2, kernel_sunos5)
 #ifdef hpux11
@@ -33,6 +84,12 @@
      extern FindVarMethod var_interfaces;
      extern FindVarMethod var_ifEntry;
 
+// Modification made for Amazon
+#ifdef Amazon
+     void GetIfIndex(char *,short *);
+     int Interface_Scan_Get_IfNumber(void);
+#endif
+
 #define IFNUMBER        0
 #define IFINDEX         1
 #define IFDESCR         2
@@ -91,7 +148,7 @@
          u_long          if_oerrors;    /* output errors on interface */
          u_long          if_collisions; /* collisions on csma interfaces */
          /*
-          * end statistics 
+          * end statistics
           */
          struct ifnet   *if_next;
      };
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/ip.c open_snmp/agent/mibgroup/mibII/ip.c
--- net-snmp-5.1/agent/mibgroup/mibII/ip.c	2003-11-12 18:25:20.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/ip.c	2009-12-16 12:59:46.000000000 +0530
@@ -26,33 +26,34 @@
 #include "interfaces.h"
 #include "sysORTable.h"
 
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef MIB_STATS_CACHE_TIMEOUT
-#define MIB_STATS_CACHE_TIMEOUT	5
+#define MIB_STATS_CACHE_TIMEOUT 5
 #endif
 #ifndef IP_STATS_CACHE_TIMEOUT
-#define IP_STATS_CACHE_TIMEOUT	MIB_STATS_CACHE_TIMEOUT
+#define IP_STATS_CACHE_TIMEOUT  MIB_STATS_CACHE_TIMEOUT
+#endif
 #endif
-
         /*********************
-	 *
-	 *  Kernel & interface information,
-	 *   and internal forward declarations
-	 *
-	 *********************/
+     *
+     *  Kernel & interface information,
+     *   and internal forward declarations
+     *
+     *********************/
 
 
         /*********************
-	 *
-	 *  Initialisation & common implementation functions
-	 *
-	 *********************/
+     *
+     *  Initialisation & common implementation functions
+     *
+     *********************/
 
 extern void     init_routes(void);
 
 
 /*
  * define the structure we're going to ask the agent to register our
- * information at 
+ * information at
  */
 struct variable1 ipaddr_variables[] = {
     {IPADADDR,      ASN_IPADDRESS, RONLY, var_ipAddrEntry, 1, {1}},
@@ -98,7 +99,7 @@
 
 /*
  * Define the OID pointer to the top of the mib tree that we're
- * registering underneath, and the OID of the MIB module 
+ * registering underneath, and the OID of the MIB module
  */
 oid             ip_oid[]                = { SNMP_OID_MIB2, 4 };
 
@@ -126,13 +127,14 @@
      * .... with a local cache
      *    (except for HP-UX 11, which extracts objects individually)
      */
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef hpux11
     netsnmp_inject_handler( reginfo,
-		    netsnmp_get_cache_handler(IP_STATS_CACHE_TIMEOUT,
-			   		ip_load, ip_free,
-					ip_oid, OID_LENGTH(ip_oid)));
+            netsnmp_get_cache_handler(IP_STATS_CACHE_TIMEOUT,
+                    ip_load, ip_free,
+                    ip_oid, OID_LENGTH(ip_oid)));
+#endif
 #endif
-
     /*
      * register (using the old-style API) to handle the IP tables
      */
@@ -148,7 +150,7 @@
 
 
     /*
-     * for speed optimization, we call this now to do the lookup 
+     * for speed optimization, we call this now to do the lookup
      */
 #ifdef IPSTAT_SYMBOL
     auto_nlist(IPSTAT_SYMBOL, 0, 0);
@@ -169,23 +171,29 @@
 
 
         /*********************
-	 *
-	 *  System specific data formats
-	 *
-	 *********************/
+     *
+     *  System specific data formats
+     *
+     *********************/
+
+#if defined(HAVE_OPTIMIZED_CODE)
+#define IP_STAT_STRUCTURE   struct ip_mib
+#define USES_SNMP_DESIGNED_IPSTAT
+
+#else
 
 #ifdef hpux11
-#define IP_STAT_STRUCTURE	int
+#define IP_STAT_STRUCTURE   int
 #endif
 
 #ifdef linux
-#define IP_STAT_STRUCTURE	struct ip_mib
-#define	USES_SNMP_DESIGNED_IPSTAT
+#define IP_STAT_STRUCTURE   struct ip_mib
+#define USES_SNMP_DESIGNED_IPSTAT
 #endif
 
 #ifdef solaris2
-#define IP_STAT_STRUCTURE	mib2_ip_t
-#define	USES_SNMP_DESIGNED_IPSTAT
+#define IP_STAT_STRUCTURE   mib2_ip_t
+#define USES_SNMP_DESIGNED_IPSTAT
 #endif
 
 #ifdef WIN32
@@ -196,26 +204,30 @@
 long            ipTTL, oldipTTL;
 #endif                          /* WIN32 */
 
+#endif /* OPTIMIZED CODE */
+
 #ifdef HAVE_SYS_TCPIPSTATS_H
-#define IP_STAT_STRUCTURE	struct kna
-#define	USES_TRADITIONAL_IPSTAT
+#define IP_STAT_STRUCTURE   struct kna
+#define USES_TRADITIONAL_IPSTAT
 #endif
 
 #if !defined(IP_STAT_STRUCTURE)
-#define IP_STAT_STRUCTURE	struct ipstat
-#define	USES_TRADITIONAL_IPSTAT
+#define IP_STAT_STRUCTURE   struct ipstat
+#define USES_TRADITIONAL_IPSTAT
 #endif
 
+#if !defined(HAVE_OPTIMIZED_CODE)
 IP_STAT_STRUCTURE ipstat;
+#endif
 
 
 
         /*********************
-	 *
-	 *  System independent handler
-	 *      (mostly)
-	 *
-	 *********************/
+     *
+     *  System independent handler
+     *      (mostly)
+     *
+     *********************/
 
 
 int
@@ -230,20 +242,43 @@
     oid      subid;
     int      type = ASN_COUNTER;
 
+#if defined(HAVE_OPTIMIZED_CODE)
+    IP_STAT_STRUCTURE *ipstat;
+    int      protocol=0;
+    int ret;
+#endif
+
     /*
      * The cached data should already have been loaded by the
      *    cache handler, higher up the handler chain.
      * But just to be safe, check this and load it manually if necessary
      */
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef hpux11
     if (!netsnmp_is_cache_valid(reqinfo)) {
-        ip_load( NULL, NULL );	/* XXX - check for failure */
+        ip_load( NULL, NULL );  /* XXX - check for failure */
     }
 #endif
+#endif
 
-
+#if defined(HAVE_OPTIMIZED_CODE)
+    ipstat = calloc(1, sizeof(IP_STAT_STRUCTURE));
+    if (ipstat == NULL) {
+        snmp_log(LOG_ERR, "mibII/ip: Malloc Failed for ipstats\n");
+        return SNMP_ERR_GENERR;
+    }
+    else {
+     /* Fill in the ipstat structure variables */
+      protocol= IFX_IP_STATS;
+      ret = linux_read_mibII_stats_opt((void *)&ipstat, protocol);
+      if ( ret != 0) {
+        free (ipstat);
+        return SNMP_ERR_GENERR;
+      }
+     }
+#endif
     /*
-     * 
+     *
      *
      */
     DEBUGMSGTL(("mibII/ip", "Handler - mode %s\n",
@@ -258,6 +293,90 @@
                                      requestvb->name_length));
             DEBUGMSG((   "mibII/ip", "\n"));
 
+#if defined(HAVE_OPTIMIZED_CODE)
+            switch (subid) {
+#ifdef USES_SNMP_DESIGNED_IPSTAT
+    case IPFORWARDING:
+        ret_value = ipstat->ipForwarding;
+        type = ASN_INTEGER;
+        break;
+    case IPDEFAULTTTL:
+        ret_value = ipstat->ipDefaultTTL;
+        type = ASN_INTEGER;
+        break;
+    case IPINRECEIVES:
+        ret_value = ipstat->ipInReceives;
+        break;
+    case IPINHDRERRORS:
+        ret_value = ipstat->ipInHdrErrors;
+        break;
+    case IPINADDRERRORS:
+        ret_value = ipstat->ipInAddrErrors;
+        break;
+    case IPFORWDATAGRAMS:
+        ret_value = ipstat->ipForwDatagrams;
+        break;
+    case IPINUNKNOWNPROTOS:
+        ret_value = ipstat->ipInUnknownProtos;
+        break;
+    case IPINDISCARDS:
+        ret_value = ipstat->ipInDiscards;
+        break;
+    case IPINDELIVERS:
+        ret_value = ipstat->ipInDelivers;
+        break;
+    case IPOUTREQUESTS:
+        ret_value = ipstat->ipOutRequests;
+        break;
+    case IPOUTDISCARDS:
+        ret_value = ipstat->ipOutDiscards;
+        break;
+    case IPOUTNOROUTES:
+        ret_value = ipstat->ipOutNoRoutes;
+        break;
+    case IPREASMTIMEOUT:
+        ret_value = ipstat->ipReasmTimeout;
+        type = ASN_INTEGER;
+        break;
+    case IPREASMREQDS:
+        ret_value = ipstat->ipReasmReqds;
+        break;
+    case IPREASMOKS:
+        ret_value = ipstat->ipReasmOKs;
+        break;
+    case IPREASMFAILS:
+        ret_value = ipstat->ipReasmFails;
+        break;
+    case IPFRAGOKS:
+        ret_value = ipstat->ipFragOKs;
+        break;
+    case IPFRAGFAILS:
+        ret_value = ipstat->ipFragFails;
+        break;
+    case IPFRAGCREATES:
+        ret_value = ipstat->ipFragCreates;
+        break;
+    case IPROUTEDISCARDS:
+        ret_value = ipstat->ipRoutingDiscards;
+        break;
+
+#endif          /* USES_SNMP_DESIGNED_IPSTAT */
+
+    case IPADDRTABLE:
+    case IPROUTETABLE:
+    case IPMEDIATABLE:
+        /*
+     * These are not actually valid scalar objects.
+     * The relevant table registrations should take precedence,
+     *   so skip these three subtrees, regardless of architecture.
+     */
+        netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
+        continue;
+
+        }
+
+#else        /* Non-Optimized Package */
+
             switch (subid) {
 #ifdef USES_SNMP_DESIGNED_IPSTAT
     case IPFORWARDING:
@@ -323,26 +442,26 @@
     case IPROUTEDISCARDS:
         ret_value = ipstat.ipRoutingDiscards;
         break;
-#else		/* USES_SNMP_DESIGNED_IPSTAT */
+#else       /* USES_SNMP_DESIGNED_IPSTAT */
 
 #ifdef USES_TRADITIONAL_IPSTAT
 #ifdef HAVE_SYS_TCPIPSTATS_H
     /*
      * This actually reads statistics for *all* the groups together,
-     * so we need to isolate the IP-specific bits.  
+     * so we need to isolate the IP-specific bits.
      */
-#define	ipstat		ipstat.ipstat
+#define ipstat      ipstat.ipstat
 #endif
     case IPFORWARDING:
     case IPDEFAULTTTL:
-        /* 
+        /*
          * Query these two individually
          */
         ret_value = ip_load(NULL, (void *)subid);
         if (ret_value == -1 ) {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
-	}
+    }
         type = ASN_INTEGER;
         break;
     case IPINRECEIVES:
@@ -480,15 +599,15 @@
     case IPFRAGFAILS:
     case IPFRAGCREATES:
     case IPROUTEDISCARDS:
-	/*
-	 * This is a bit of a hack, to shoehorn the HP-UX 11
-	 * single-object retrieval approach into the caching
-	 * architecture.
-	 */
-	if (ip_load(NULL, (void*)subid) == -1 ) {
+    /*
+     * This is a bit of a hack, to shoehorn the HP-UX 11
+     * single-object retrieval approach into the caching
+     * architecture.
+     */
+    if (ip_load(NULL, (void*)subid) == -1 ) {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
-	}
+    }
         ret_value = ipstat;
         break;
 #else                  /* hpux11 */
@@ -562,29 +681,34 @@
 #endif                  /* WIN32 */
 #endif                  /* hpux11 */
 #endif                  /* USE_TRADITIONAL_IPSTAT */
-#endif			/* USES_SNMP_DESIGNED_IPSTAT */
+#endif          /* USES_SNMP_DESIGNED_IPSTAT */
 
     case IPADDRTABLE:
     case IPROUTETABLE:
     case IPMEDIATABLE:
         /*
-	 * These are not actually valid scalar objects.
-	 * The relevant table registrations should take precedence,
-	 *   so skip these three subtrees, regardless of architecture.
-	 */
+     * These are not actually valid scalar objects.
+     * The relevant table registrations should take precedence,
+     *   so skip these three subtrees, regardless of architecture.
+     */
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 
-	    }
-	    snmp_set_var_typed_value(request->requestvb, type,
-			             (u_char *)&ret_value, sizeof(ret_value));
-	}
+        }
+#endif /* OPTIMIZED_CODE */
+        snmp_set_var_typed_value(request->requestvb, type,
+                         (u_char *)&ret_value, sizeof(ret_value));
+
+    }
+#if defined(HAVE_OPTIMIZED_CODE)
+        free(ipstat);
+#endif
         break;
 
     case MODE_GETNEXT:
     case MODE_GETBULK:
     case MODE_SET_RESERVE1:
-		/* XXX - Windows currently supports setting this */
+        /* XXX - Windows currently supports setting this */
     case MODE_SET_RESERVE2:
     case MODE_SET_ACTION:
     case MODE_SET_COMMIT:
@@ -605,12 +729,13 @@
 
 
         /*********************
-	 *
-	 *  Internal implementation functions
-	 *
-	 *********************/
+     *
+     *  Internal implementation functions
+     *
+     *********************/
 
 
+#if defined(HAVE_CACHE_SUPPORT)
 #ifdef hpux11
 int
 ip_load(netsnmp_cache *cache, void *vmagic)
@@ -620,7 +745,7 @@
     unsigned int    ulen;
     int             ret;
     int             magic = (int) vmagic;
-    
+
     if ((fd = open_mib("/dev/ip", O_RDONLY, 0, NM_ASYNC_OFF)) < 0) {
         DEBUGMSGTL(("mibII/ip", "Failed to load IP object %d (hpux11)\n", magic));
         return (-1);            /* error */
@@ -795,7 +920,7 @@
         return ret_value;
     }
 }
-#else		/* (defined(CAN_USE_SYSCTL) && defined(IPCTL_STATS)) */
+#else       /* (defined(CAN_USE_SYSCTL) && defined(IPCTL_STATS)) */
 #ifdef HAVE_SYS_TCPIPSTATS_H
 int
 ip_load(netsnmp_cache *cache, void *vmagic)
@@ -830,7 +955,7 @@
         return ret_value;
     }
 }
-#else				/* HAVE_SYS_TCPIPSTATS_H */
+#else               /* HAVE_SYS_TCPIPSTATS_H */
 #ifdef IPSTAT_SYMBOL
 int
 ip_load(netsnmp_cache *cache, void *vmagic)
@@ -866,7 +991,7 @@
         return ret_value;
     }
 }
-#else				/* IPSTAT_SYMBOL */
+#else               /* IPSTAT_SYMBOL */
 int
 ip_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -875,9 +1000,9 @@
     DEBUGMSGTL(("mibII/ip", "Failed to load IP Group (null)\n"));
     return ret_value;
 }
-#endif				/* IPSTAT_SYMBOL */
-#endif				/* HAVE_SYS_TCPIPSTATS_H */
-#endif		/* (defined(CAN_USE_SYSCTL) && defined(IPCTL_STATS)) */
+#endif              /* IPSTAT_SYMBOL */
+#endif              /* HAVE_SYS_TCPIPSTATS_H */
+#endif      /* (defined(CAN_USE_SYSCTL) && defined(IPCTL_STATS)) */
 #endif                          /* hpux11 */
 #endif                          /* linux */
 #endif                          /* solaris2 */
@@ -888,4 +1013,6 @@
 {
     memset(&ipstat, 0, sizeof(ipstat));
 }
+#endif
+
 
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/kernel_linux.c open_snmp/agent/mibgroup/mibII/kernel_linux.c
--- net-snmp-5.1/agent/mibgroup/mibII/kernel_linux.c	2003-07-01 15:43:23.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/kernel_linux.c	2009-12-16 12:59:48.000000000 +0530
@@ -19,21 +19,167 @@
 
 #include "kernel_linux.h"
 
+#if defined(HAVE_CACHE_SUPPORT)
 struct ip_mib   cached_ip_mib;
 struct icmp_mib cached_icmp_mib;
 struct tcp_mib  cached_tcp_mib;
 struct udp_mib  cached_udp_mib;
+#endif
 
-#define IP_STATS_LINE	"Ip: %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu"
-#define ICMP_STATS_LINE	"Icmp: %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu"
-#define TCP_STATS_LINE	"Tcp: %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu"
-#define UDP_STATS_LINE	"Udp: %lu %lu %lu %lu"
-
-#define IP_STATS_PREFIX_LEN	4
-#define ICMP_STATS_PREFIX_LEN	6
-#define TCP_STATS_PREFIX_LEN	5
-#define UDP_STATS_PREFIX_LEN	5
+#define IP_STATS_LINE   "Ip: %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu"
+#define ICMP_STATS_LINE "Icmp: %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu"
+#define TCP_STATS_LINE  "Tcp: %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu"
+#define UDP_STATS_LINE  "Udp: %lu %lu %lu %lu"
+
+#define IP_STATS_PREFIX_LEN 4
+#define ICMP_STATS_PREFIX_LEN   6
+#define TCP_STATS_PREFIX_LEN    5
+#define UDP_STATS_PREFIX_LEN    5
 
+#if defined(HAVE_OPTIMIZED_CODE)
+int
+linux_read_mibII_stats_opt(void **mib2struct, unsigned int proto)
+{
+    FILE           *in = fopen("/proc/net/snmp", "r");
+    char            line[1024];
+
+    struct ip_mib   *ifx_ip_mib;
+    struct icmp_mib *ifx_icmp_mib;
+    struct tcp_mib  *ifx_tcp_mib;
+    struct udp_mib  *ifx_udp_mib;
+    int             ret;
+
+    if (!in) {
+        return -1;
+    }
+
+
+    while (line == fgets(line, sizeof(line), in)) {
+    switch (proto) {
+
+     case IFX_IP_STATS:
+            if (!strncmp(line, IP_STATS_LINE, IP_STATS_PREFIX_LEN)) {
+         ifx_ip_mib =(struct ip_mib *)(*mib2struct);
+                sscanf(line, IP_STATS_LINE,
+                   &(ifx_ip_mib->ipForwarding),
+                   &(ifx_ip_mib->ipDefaultTTL),
+                   &(ifx_ip_mib->ipInReceives),
+                   &(ifx_ip_mib->ipInHdrErrors),
+                   &(ifx_ip_mib->ipInAddrErrors),
+                   &(ifx_ip_mib->ipForwDatagrams),
+                   &(ifx_ip_mib->ipInUnknownProtos),
+                   &(ifx_ip_mib->ipInDiscards),
+                   &(ifx_ip_mib->ipInDelivers),
+                   &(ifx_ip_mib->ipOutRequests),
+                   &(ifx_ip_mib->ipOutDiscards),
+                   &(ifx_ip_mib->ipOutNoRoutes),
+                   &(ifx_ip_mib->ipReasmTimeout),
+                   &(ifx_ip_mib->ipReasmReqds),
+                   &(ifx_ip_mib->ipReasmOKs),
+                   &(ifx_ip_mib->ipReasmFails),
+                   &(ifx_ip_mib->ipFragOKs),
+                   &(ifx_ip_mib->ipFragFails),
+                   &(ifx_ip_mib->ipFragCreates));
+            ifx_ip_mib->ipRoutingDiscards = 0;        /* XXX */
+
+            }
+        break;
+
+     case IFX_ICMP_STATS:
+        if (!strncmp(line, ICMP_STATS_LINE, ICMP_STATS_PREFIX_LEN)) {
+         ifx_icmp_mib =(struct icmp_mib *)(*mib2struct);
+            sscanf(line, ICMP_STATS_LINE,
+                   &(ifx_icmp_mib->icmpInMsgs),
+                   &(ifx_icmp_mib->icmpInErrors),
+                   &(ifx_icmp_mib->icmpInDestUnreachs),
+                   &(ifx_icmp_mib->icmpInTimeExcds),
+                   &(ifx_icmp_mib->icmpInParmProbs),
+                   &(ifx_icmp_mib->icmpInSrcQuenchs),
+                   &(ifx_icmp_mib->icmpInRedirects),
+                   &(ifx_icmp_mib->icmpInEchos),
+                   &(ifx_icmp_mib->icmpInEchoReps),
+                   &(ifx_icmp_mib->icmpInTimestamps),
+                   &(ifx_icmp_mib->icmpInTimestampReps),
+                   &(ifx_icmp_mib->icmpInAddrMasks),
+                   &(ifx_icmp_mib->icmpInAddrMaskReps),
+                   &(ifx_icmp_mib->icmpOutMsgs),
+                   &(ifx_icmp_mib->icmpOutErrors),
+                   &(ifx_icmp_mib->icmpOutDestUnreachs),
+                   &(ifx_icmp_mib->icmpOutTimeExcds),
+                   &(ifx_icmp_mib->icmpOutParmProbs),
+                   &(ifx_icmp_mib->icmpOutSrcQuenchs),
+                   &(ifx_icmp_mib->icmpOutRedirects),
+                   &(ifx_icmp_mib->icmpOutEchos),
+                   &(ifx_icmp_mib->icmpOutEchoReps),
+                   &(ifx_icmp_mib->icmpOutTimestamps),
+                   &(ifx_icmp_mib->icmpOutTimestampReps),
+                   &(ifx_icmp_mib->icmpOutAddrMasks),
+                   &(ifx_icmp_mib->icmpOutAddrMaskReps));
+        }
+        break;
+
+     case IFX_TCP_STATS:
+
+        if (!strncmp(line, TCP_STATS_LINE, TCP_STATS_PREFIX_LEN)) {
+            ifx_tcp_mib =(struct tcp_mib *)(*mib2struct);
+                          ret = sscanf(line, TCP_STATS_LINE,
+                                         &(ifx_tcp_mib->tcpRtoAlgorithm),
+                                         &(ifx_tcp_mib->tcpRtoMin),
+                                         &(ifx_tcp_mib->tcpRtoMax),
+                                         &(ifx_tcp_mib->tcpMaxConn),
+                                         &(ifx_tcp_mib->tcpActiveOpens),
+                                         &(ifx_tcp_mib->tcpPassiveOpens),
+                                         &(ifx_tcp_mib->tcpAttemptFails),
+                                         &(ifx_tcp_mib->tcpEstabResets),
+                                         &(ifx_tcp_mib->tcpCurrEstab),
+                                         &(ifx_tcp_mib->tcpInSegs),
+                                         &(ifx_tcp_mib->tcpOutSegs),
+                                         &(ifx_tcp_mib->tcpRetransSegs),
+                                         &(ifx_tcp_mib->tcpInErrs),
+                                         &(ifx_tcp_mib->tcpOutRsts));
+            ifx_tcp_mib->tcpInErrsValid = (ret > 12) ? 1 : 0;
+            ifx_tcp_mib->tcpOutRstsValid = (ret > 13) ? 1 : 0;
+        }
+        break;
+
+     case IFX_UDP_STATS:
+
+        if (!strncmp(line, UDP_STATS_LINE, UDP_STATS_PREFIX_LEN)) {
+            ifx_udp_mib =(struct udp_mib *)(*mib2struct);
+            sscanf(line, UDP_STATS_LINE,
+                   &(ifx_udp_mib->udpInDatagrams),
+                   &(ifx_udp_mib->udpNoPorts),
+                   &(ifx_udp_mib->udpInErrors),
+                   &(ifx_udp_mib->udpOutDatagrams));
+        }
+    }
+
+    }
+    fclose(in);
+
+    /*
+     * Tweak illegal values:
+     *
+     * valid values for ipForwarding are 1 == yup, 2 == nope
+     * a 0 is forbidden, so patch:
+     */
+     if ( proto == IFX_IP_STATS)
+        if (!ifx_ip_mib->ipForwarding)
+            ifx_ip_mib->ipForwarding = 2;
+    /*
+     * 0 is illegal for tcpRtoAlgorithm
+     * so assume `other' algorithm:
+     */
+     if ( proto == IFX_TCP_STATS)
+        if (!ifx_tcp_mib->tcpRtoAlgorithm)
+            ifx_tcp_mib->tcpRtoAlgorithm = 1;
+
+    return 0;
+}
+
+#endif
+
+#if defined(HAVE_CACHE_SUPPORT)
 
 int
 linux_read_mibII_stats(void)
@@ -68,7 +214,7 @@
                    &cached_ip_mib.ipFragOKs,
                    &cached_ip_mib.ipFragFails,
                    &cached_ip_mib.ipFragCreates);
-            cached_ip_mib.ipRoutingDiscards = 0;        /* XXX */
+            cached_ip_mib.ipRoutingDiscards = 0;
         } else if (!strncmp(line, ICMP_STATS_LINE, ICMP_STATS_PREFIX_LEN)) {
             sscanf(line, ICMP_STATS_LINE,
                    &cached_icmp_mib.icmpInMsgs,
@@ -125,24 +271,26 @@
     }
     fclose(in);
 
-    /*
-     * Tweak illegal values:
-     *
-     * valid values for ipForwarding are 1 == yup, 2 == nope
-     * a 0 is forbidden, so patch:
-     */
+    // *
+    // * Tweak illegal values:
+    // *
+    // * valid values for ipForwarding are 1 == yup, 2 == nope
+    // * a 0 is forbidden, so patch:
+    // *
     if (!cached_ip_mib.ipForwarding)
         cached_ip_mib.ipForwarding = 2;
 
-    /*
-     * 0 is illegal for tcpRtoAlgorithm
-     * so assume `other' algorithm:
-     */
+    // *
+    // * 0 is illegal for tcpRtoAlgorithm
+    // * so assume `other' algorithm:
+    // *
     if (!cached_tcp_mib.tcpRtoAlgorithm)
         cached_tcp_mib.tcpRtoAlgorithm = 1;
     return 0;
 }
 
+
+
 int
 linux_read_ip_stat(struct ip_mib *ipstat)
 {
@@ -183,3 +331,5 @@
     memcpy((char *) udpstat, (char *) &cached_udp_mib, sizeof(*udpstat));
     return 0;
 }
+
+#endif
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/kernel_linux.h open_snmp/agent/mibgroup/mibII/kernel_linux.h
--- net-snmp-5.1/agent/mibgroup/mibII/kernel_linux.h	2003-07-01 15:43:23.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/kernel_linux.h	2009-12-16 12:59:48.000000000 +0530
@@ -6,6 +6,11 @@
 #ifndef _MIBGROUP_KERNEL_LINUX_H
 #define _MIBGROUP_KERNEL_LINUX_H
 
+#define IFX_IP_STATS        101
+#define IFX_ICMP_STATS      102
+#define IFX_TCP_STATS       103
+#define IFX_UDP_STATS       104
+
 struct ip_mib {
     unsigned long   ipForwarding;
     unsigned long   ipDefaultTTL;
@@ -84,10 +89,15 @@
     short           tcpOutRstsValid;
 };
 
+#if defined(HAVE_OPTIMIZED_CODE)
+int linux_read_mibII_stats_opt(void **mib2struct, unsigned int proto);
+#endif
 
+#if defined(HAVE_CACHE_SUPPORT)
 int             linux_read_ip_stat(struct ip_mib *);
 int             linux_read_icmp_stat(struct icmp_mib *);
 int             linux_read_udp_stat(struct udp_mib *);
 int             linux_read_tcp_stat(struct tcp_mib *);
+#endif
 
 #endif                          /* _MIBGROUP_KERNEL_LINUX_H */
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/system_mib.c open_snmp/agent/mibgroup/mibII/system_mib.c
--- net-snmp-5.1/agent/mibgroup/mibII/system_mib.c	2002-12-19 20:37:31.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/system_mib.c	2009-12-16 12:59:49.000000000 +0530
@@ -56,6 +56,13 @@
 	 *   and internal forward declarations
 	 *
 	 *********************/
+/* MIB-2 persistent support */
+#define MIB2_SYSTEM_PERSIST
+
+#ifdef MIB2_SYSTEM_PERSIST
+#define FILE_RC_CONF	"/flash/rc.conf"
+#define TAG_MIB2_SYSTEM "mib2_system"
+#endif
 
 #define SYS_STRING_LEN	256
 char            version_descr[SYS_STRING_LEN] = VERS_DESC;
@@ -119,8 +126,11 @@
                  sizeof(sysLocation), cptr);
         config_perror(tmpbuf);
     }
-
+#ifdef MIB2_SYSTEM_PERSIST
+    if (strcmp(token, "syslocation") == 0) {
+#else
     if (strcmp(token, "psyslocation") == 0) {
+#endif
         if (sysLocationSet < 0) {
             /*
              * This is bogus (and shouldn't happen anyway) -- the sysLocation
@@ -167,7 +177,11 @@
         config_perror(tmpbuf);
     }
 
+#ifdef MIB2_SYSTEM_PERSIST
+    if (strcmp(token, "syscontact") == 0) {
+#else
     if (strcmp(token, "psyscontact") == 0) {
+#endif
         if (sysContactSet < 0) {
             /*
              * This is bogus (and shouldn't happen anyway) -- the sysContact
@@ -213,8 +227,11 @@
                  sizeof(sysName), cptr);
         config_perror(tmpbuf);
     }
-
+#ifdef MIB2_SYSTEM_PERSIST
+    if (strcmp(token, "sysname") == 0) {
+#else
     if (strcmp(token, "psysname") == 0) {
+#endif
         if (sysNameSet < 0) {
             /*
              * This is bogus (and shouldn't happen anyway) -- the sysName
@@ -309,15 +326,27 @@
     char            line[SNMP_MAXBUF_SMALL];
 
     if (sysLocationSet > 0) {
+#ifdef MIB2_SYSTEM_PERSIST
+        snprintf(line, SNMP_MAXBUF_SMALL, "syslocation %s", sysLocation);
+#else
         snprintf(line, SNMP_MAXBUF_SMALL, "psyslocation %s", sysLocation);
+#endif
         snmpd_store_config(line);
     }
     if (sysContactSet > 0) {
+#ifdef MIB2_SYSTEM_PERSIST
+        snprintf(line, SNMP_MAXBUF_SMALL, "syscontact %s", sysContact);
+#else
         snprintf(line, SNMP_MAXBUF_SMALL, "psyscontact %s", sysContact);
+#endif
         snmpd_store_config(line);
     }
     if (sysNameSet > 0) {
+#ifdef MIB2_SYSTEM_PERSIST
+        snprintf(line, SNMP_MAXBUF_SMALL, "sysname %s", sysName);
+#else
         snprintf(line, SNMP_MAXBUF_SMALL, "psysname %s", sysName);
+#endif
         snmpd_store_config(line);
     }
 
@@ -410,12 +439,21 @@
                                   NULL, "contact-name");
     snmpd_register_config_handler("sysname", system_parse_config_sysname,
                                   NULL, "node-name");
+#ifdef MIB2_SYSTEM_PERSIST
+    snmpd_register_config_handler("syslocation",
+                                  system_parse_config_sysloc, NULL, NULL);
+    snmpd_register_config_handler("syscontact",
+                                  system_parse_config_syscon, NULL, NULL);
+    snmpd_register_config_handler("sysname", system_parse_config_sysname,
+                                  NULL, NULL);
+#else
     snmpd_register_config_handler("psyslocation",
                                   system_parse_config_sysloc, NULL, NULL);
     snmpd_register_config_handler("psyscontact",
                                   system_parse_config_syscon, NULL, NULL);
     snmpd_register_config_handler("psysname", system_parse_config_sysname,
                                   NULL, NULL);
+#endif
     snmpd_register_config_handler("sysservices",
                                   system_parse_config_sysServices, NULL,
                                   "NUMBER");
@@ -461,14 +499,32 @@
         ulret = netsnmp_get_agent_uptime();
         return ((u_char *) & ulret);
     case SYSCONTACT:
+#ifdef MIB2_SYSTEM_PERSIST
+	if (ifx_GetCfgData(FILE_RC_CONF, TAG_MIB2_SYSTEM, "MIB2sysContact", sysContact) != 1) {
+            DEBUGMSGTL(("snmpd", "unable to get data for sub-id %d\n", vp->magic));
+	    return NULL;
+	}
+#endif
         *var_len = strlen(sysContact);
         *write_method = writeSystem;
         return (u_char *) sysContact;
     case SYSTEMNAME:
+#ifdef MIB2_SYSTEM_PERSIST
+	if (ifx_GetCfgData(FILE_RC_CONF, TAG_MIB2_SYSTEM, "MIB2sysName", sysName) != 1) {
+           DEBUGMSGTL(("snmpd", "unable to get data for sub-id %d\n", vp->magic));
+	   return NULL;
+	}
+#endif
         *var_len = strlen(sysName);
         *write_method = writeSystem;
         return (u_char *) sysName;
     case SYSLOCATION:
+#ifdef MIB2_SYSTEM_PERSIST
+	if (ifx_GetCfgData(FILE_RC_CONF, TAG_MIB2_SYSTEM, "MIB2sysLocation", sysLocation) != 1) {
+           DEBUGMSGTL(("snmpd", "unable to get data for sub-id %d\n", vp->magic));
+	   return NULL;
+	}
+#endif
         *var_len = strlen(sysLocation);
         *write_method = writeSystem;
         return (u_char *) sysLocation;
@@ -506,6 +562,25 @@
     char           *buf = NULL, *oldbuf = NULL;
     int             count, *setvar = NULL;
 
+#ifdef MIB2_SYSTEM_PERSIST
+    char   *psysContact = NULL, *psysName = NULL, *psysLocation = NULL;
+    
+    if ((psysContact = calloc(SYS_STRING_LEN, 1)) == NULL) {
+	DEBUGMSGTL(("snmpd", "unable to malloc for sub-id %d\n", (char) name[7]));
+	return SNMP_ERR_RESOURCEUNAVAILABLE;
+    }
+    
+    if ((psysName = calloc(SYS_STRING_LEN, 1)) == NULL) {
+	DEBUGMSGTL(("snmpd", "unable to malloc for sub-id %d\n", (char) name[7]));
+	return SNMP_ERR_RESOURCEUNAVAILABLE;
+    }
+
+    if ((psysLocation = calloc(SYS_STRING_LEN, 1)) == NULL) {
+	DEBUGMSGTL(("snmpd", "unable to malloc for sub-id %d\n", (char) name[7]));
+	return SNMP_ERR_RESOURCEUNAVAILABLE;
+    }
+#endif
+
     switch ((char) name[7]) {
     case SYSCONTACT:
         buf = sysContact;
@@ -579,18 +654,37 @@
         if (setvar != NULL) {
             *setvar = 1;
         }
+#ifdef MIB2_SYSTEM_PERSIST
+	sprintf(psysContact, ("MIB2sysContact=\"%s\"\n"), sysContact);
+	sprintf(psysName, ("MIB2sysName=\"%s\"\n"), sysName);
+	sprintf(psysLocation, ("MIB2sysLocation=\"%s\"\n"), sysLocation);
+
+	if (ifx_SetCfgData(FILE_RC_CONF, TAG_MIB2_SYSTEM, 3, psysContact, psysName, psysLocation) != 1) {
+            DEBUGMSGTL(("snmpd", "unable to set data for sub-id %d\n", (char) name[7]));
+	    return SNMP_ERR_GENERR;
+	}
+	ifx_flash_write();
+#else
         snmp_save_persistent(netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
         (void) snmp_call_callbacks(SNMP_CALLBACK_LIBRARY,
                                    SNMP_CALLBACK_STORE_DATA, NULL);
         snmp_clean_persistent(netsnmp_ds_get_string
                               (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE));
-
+#endif
     case FREE:                 /* Free any resources allocated */
 
         /*
          * No resources have been allocated, but "empty" the 'oldbuf' 
          */
         oldbuf[0] = 0;
+#ifdef MIB2_SYSTEM_PERSIST
+	if (psysContact != NULL)
+	 free (psysContact);
+	if (psysName != NULL)
+	 free (psysName);
+	if (psysLocation != NULL)
+	 free(psysLocation);
+#endif
         break;
     }
     return SNMP_ERR_NOERROR;
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/tcp.c open_snmp/agent/mibgroup/mibII/tcp.c
--- net-snmp-5.1/agent/mibgroup/mibII/tcp.c	2003-11-12 16:08:18.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/tcp.c	2009-12-16 12:59:49.000000000 +0530
@@ -25,7 +25,7 @@
 /*
  * these are undefed to remove a stupid warning on osf compilers
  * because they get redefined with a slightly different notation of the
- * same value.  -- Wes 
+ * same value.  -- Wes
  */
 #undef TCP_NODELAY
 #undef TCP_MAXSEG
@@ -55,37 +55,39 @@
 #include "tcpTable.h"
 #include "sysORTable.h"
 
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef MIB_STATS_CACHE_TIMEOUT
-#define MIB_STATS_CACHE_TIMEOUT	5
+#define MIB_STATS_CACHE_TIMEOUT 5
 #endif
 #ifndef TCP_STATS_CACHE_TIMEOUT
-#define TCP_STATS_CACHE_TIMEOUT	MIB_STATS_CACHE_TIMEOUT
+#define TCP_STATS_CACHE_TIMEOUT MIB_STATS_CACHE_TIMEOUT
+#endif
 #endif
 
         /*********************
-	 *
-	 *  Kernel & interface information,
-	 *   and internal forward declarations
-	 *
-	 *********************/
+     *
+     *  Kernel & interface information,
+     *   and internal forward declarations
+     *
+     *********************/
 
                         /*
-			 * FreeBSD4 will set this explicitly,
-			 * other system may not even need it at all
-			 * But it doesn't do any harm to define it globally
-			 */
+             * FreeBSD4 will set this explicitly,
+             * other system may not even need it at all
+             * But it doesn't do any harm to define it globally
+             */
 int  hz = 1000;
 
         /*********************
-	 *
-	 *  Initialisation & common implementation functions
-	 *
-	 *********************/
+     *
+     *  Initialisation & common implementation functions
+     *
+     *********************/
 
 
 /*
  * Define the OID pointer to the top of the mib tree that we're
- * registering underneath, and the OID for the MIB module 
+ * registering underneath, and the OID for the MIB module
  */
 oid             tcp_oid[]               = { SNMP_OID_MIB2, 6 };
 oid             tcp_module_oid[]        = { SNMP_OID_MIB2, 49 };
@@ -100,18 +102,20 @@
      */
     DEBUGMSGTL(("mibII/tcpScalar", "Initialising TCP scalar group\n"));
     reginfo = netsnmp_create_handler_registration("tcp", tcp_handler,
-		    tcp_oid, OID_LENGTH(tcp_oid), HANDLER_CAN_RONLY);
+            tcp_oid, OID_LENGTH(tcp_oid), HANDLER_CAN_RONLY);
     netsnmp_register_scalar_group(reginfo, TCPRTOALGORITHM, TCPOUTRSTS);
 
     /*
      * .... with a local cache
      *    (except for HP-UX 11, which extracts objects individually)
      */
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef hpux11
     netsnmp_inject_handler( reginfo,
-		    netsnmp_get_cache_handler(TCP_STATS_CACHE_TIMEOUT,
-			   		tcp_load, tcp_free,
-					tcp_oid, OID_LENGTH(tcp_oid)));
+            netsnmp_get_cache_handler(TCP_STATS_CACHE_TIMEOUT,
+                    tcp_load, tcp_free,
+                    tcp_oid, OID_LENGTH(tcp_oid)));
+#endif
 #endif
 
     REGISTER_SYSOR_ENTRY(tcp_module_oid,
@@ -132,23 +136,30 @@
 }
 
         /*********************
-	 *
-	 *  System specific implementation functions
-	 *
-	 *********************/
+     *
+     *  System specific implementation functions
+     *
+     *********************/
+
+#if defined(HAVE_OPTIMIZED_CODE)
+#define TCP_STAT_STRUCTURE  struct tcp_mib
+#define USES_SNMP_DESIGNED_TCPSTAT
+#undef TCPSTAT_SYMBOL
+
+#else
 
 #ifdef hpux11
-#define TCP_STAT_STRUCTURE	int
+#define TCP_STAT_STRUCTURE  int
 #endif
 
 #ifdef linux
-#define TCP_STAT_STRUCTURE	struct tcp_mib
+#define TCP_STAT_STRUCTURE  struct tcp_mib
 #define USES_SNMP_DESIGNED_TCPSTAT
 #undef TCPSTAT_SYMBOL
 #endif
 
 #ifdef solaris2
-#define TCP_STAT_STRUCTURE	mib2_tcp_t
+#define TCP_STAT_STRUCTURE  mib2_tcp_t
 #define USES_SNMP_DESIGNED_TCPSTAT
 #endif
 
@@ -157,25 +168,28 @@
 #define TCP_STAT_STRUCTURE     MIB_TCPSTATS
 #endif
 
+#endif /* OPTIMIZED CODE */
+
 #ifdef HAVE_SYS_TCPIPSTATS_H
-#define TCP_STAT_STRUCTURE	struct kna
+#define TCP_STAT_STRUCTURE  struct kna
 #define USES_TRADITIONAL_TCPSTAT
 #endif
 
 #if !defined(TCP_STAT_STRUCTURE)
-#define TCP_STAT_STRUCTURE	struct tcpstat
+#define TCP_STAT_STRUCTURE  struct tcpstat
 #define USES_TRADITIONAL_TCPSTAT
 #endif
 
+#if !defined(HAVE_OPTIMIZED_CODE)
 TCP_STAT_STRUCTURE tcpstat;
-
+#endif
 
 
         /*********************
-	 *
-	 *  System independent handler (mostly)
-	 *
-	 *********************/
+     *
+     *  System independent handler (mostly)
+     *
+     *********************/
 
 
 
@@ -191,20 +205,42 @@
     oid      subid;
     int      type = ASN_COUNTER;
 
+#if defined(HAVE_OPTIMIZED_CODE)
+    TCP_STAT_STRUCTURE *tcpstat;
+    int protocol=0;
+    int ret;
+#endif
     /*
      * The cached data should already have been loaded by the
      *    cache handler, higher up the handler chain.
      * But just to be safe, check this and load it manually if necessary
      */
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef hpux11
     if (!netsnmp_is_cache_valid(reqinfo)) {
-        tcp_load( NULL, NULL );	/* XXX - check for failure */
+        tcp_load( NULL, NULL ); /* XXX - check for failure */
     }
 #endif
+#endif
 
-
+#if defined(HAVE_OPTIMIZED_CODE)
+    tcpstat = calloc(1, sizeof(TCP_STAT_STRUCTURE));
+    if (tcpstat == NULL) {
+        snmp_log(LOG_ERR, "mibII/tcp: Malloc Failed for tcpstat\n");
+        return SNMP_ERR_GENERR;
+    }
+    else {
+     /* Fill in the tcpstat structure variables */
+      protocol= IFX_TCP_STATS;
+      ret = linux_read_mibII_stats_opt((void *)&tcpstat, protocol);
+      if ( ret != 0) {
+        free(tcpstat);
+        return SNMP_ERR_GENERR;
+      }
+     }
+#endif
     /*
-     * 
+     *
      *
      */
     DEBUGMSGTL(("mibII/tcpScalar", "Handler - mode %s\n",
@@ -219,6 +255,83 @@
             DEBUGMSGOID(("mibII/tcpScalar", requestvb->name,
                                             requestvb->name_length));
             DEBUGMSG((   "mibII/tcpScalar", "\n"));
+
+#if defined(HAVE_OPTIMIZED_CODE)
+            switch (subid) {
+#ifdef USES_SNMP_DESIGNED_TCPSTAT
+    case TCPRTOALGORITHM:
+        ret_value = tcpstat->tcpRtoAlgorithm;
+        type = ASN_INTEGER;
+        break;
+    case TCPRTOMIN:
+        ret_value = tcpstat->tcpRtoMin;
+        type = ASN_INTEGER;
+        break;
+    case TCPRTOMAX:
+        ret_value = tcpstat->tcpRtoMax;
+        type = ASN_INTEGER;
+        break;
+    case TCPMAXCONN:
+        ret_value = tcpstat->tcpMaxConn;
+        type = ASN_INTEGER;
+        break;
+    case TCPACTIVEOPENS:
+        ret_value = tcpstat->tcpActiveOpens;
+        break;
+    case TCPPASSIVEOPENS:
+        ret_value = tcpstat->tcpPassiveOpens;
+        break;
+    case TCPATTEMPTFAILS:
+        ret_value = tcpstat->tcpAttemptFails;
+        break;
+    case TCPESTABRESETS:
+        ret_value = tcpstat->tcpEstabResets;
+        break;
+    case TCPCURRESTAB:
+        ret_value = tcpstat->tcpCurrEstab;
+        type = ASN_GAUGE;
+        break;
+    case TCPINSEGS:
+        ret_value = tcpstat->tcpInSegs;
+        break;
+    case TCPOUTSEGS:
+        ret_value = tcpstat->tcpOutSegs;
+        break;
+    case TCPRETRANSSEGS:
+        ret_value = tcpstat->tcpRetransSegs;
+        break;
+    case TCPINERRS:
+        if (tcpstat->tcpInErrsValid) {
+            ret_value = tcpstat->tcpInErrs;
+            break;
+        }
+        else {
+            netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
+            continue;
+        }
+    case TCPOUTRSTS:
+        if (tcpstat->tcpOutRstsValid) {
+            ret_value = tcpstat->tcpOutRsts;
+            break;
+        }
+        else {
+            netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
+            continue;
+        }
+#endif   /* USES_SNMP_DESIGNED_TCPSTAT */
+
+    case TCPCONNTABLE:
+        /*
+     * This is not actually a valid scalar object.
+     * The table registration should take precedence,
+     *   so skip this subtree, regardless of architecture.
+     */
+        netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
+        continue;
+
+    }
+
+#else   /* Non-Optimized Package */
             switch (subid) {
 #ifdef USES_SNMP_DESIGNED_TCPSTAT
     case TCPRTOALGORITHM:
@@ -265,41 +378,41 @@
     case TCPINERRS:
 #ifdef solaris2
         ret_value = tcp_load(NULL, (void *)TCPINERRS);
-	if (ret_value == -1) {
+    if (ret_value == -1) {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
-	}
+    }
         break;
-#else			/* solaris2 */
+#else           /* solaris2 */
 #ifdef linux
         if (tcpstat.tcpInErrsValid) {
             ret_value = tcpstat.tcpInErrs;
             break;
-	} else {
+    } else {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
-	}
-#else			/* linux */
+    }
+#else           /* linux */
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
-#endif			/* linux */
-#endif			/* solaris2 */
+#endif          /* linux */
+#endif          /* solaris2 */
     case TCPOUTRSTS:
 #ifdef linux
         if (tcpstat.tcpOutRstsValid) {
             ret_value = tcpstat.tcpOutRsts;
             break;
-	}
-#endif			/* linux */
+    }
+#endif          /* linux */
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
-#else			/* USES_SNMP_DESIGNED_TCPSTAT */
+#else           /* USES_SNMP_DESIGNED_TCPSTAT */
 
 #ifdef USES_TRADITIONAL_TCPSTAT
 #ifdef HAVE_SYS_TCPIPSTATS_H
     /*
      * This actually reads statistics for *all* the groups together,
-     * so we need to isolate the TCP-specific bits.  
+     * so we need to isolate the TCP-specific bits.
      */
 #define tcpstat          tcpstat.tcpstat
 #endif
@@ -324,7 +437,7 @@
         type = ASN_INTEGER;
         break;
     case TCPMAXCONN:
-        ret_value = -1;		/* Dynamic maximum */
+        ret_value = -1;     /* Dynamic maximum */
         type = ASN_INTEGER;
         break;
     case TCPACTIVEOPENS:
@@ -373,7 +486,7 @@
 #ifdef HAVE_SYS_TCPIPSTATS_H
 #undef tcpstat
 #endif
-#else			/* USES_TRADITIONAL_TCPSTAT */
+#else           /* USES_TRADITIONAL_TCPSTAT */
 
 #ifdef hpux11
     case TCPRTOALGORITHM:
@@ -383,7 +496,7 @@
     case TCPCURRESTAB:
         if (subid == TCPCURRESTAB)
            type = ASN_GAUGE;
-	else
+    else
            type = ASN_INTEGER;
     case TCPACTIVEOPENS:
     case TCPPASSIVEOPENS:
@@ -394,18 +507,18 @@
     case TCPRETRANSSEGS:
     case TCPINERRS:
     case TCPOUTRSTS:
-	/*
-	 * This is a bit of a hack, to shoehorn the HP-UX 11
-	 * single-object retrieval approach into the caching
-	 * architecture.
-	 */
-	if (tcp_load(NULL, (void*)subid) == -1 ) {
+    /*
+     * This is a bit of a hack, to shoehorn the HP-UX 11
+     * single-object retrieval approach into the caching
+     * architecture.
+     */
+    if (tcp_load(NULL, (void*)subid) == -1 ) {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
-	}
+    }
         ret_value = tcpstat;
         break;
-#else			/* hpux11 */
+#else           /* hpux11 */
 
 #ifdef WIN32
     case TCPRTOALGORITHM:
@@ -455,24 +568,29 @@
     case TCPOUTRSTS:
         ret_value = tcpstat.dwOutRsts;
         break;
-#endif			/* WIN32 */
-#endif			/* hpux11 */
-#endif			/* USES_TRADITIONAL_TCPSTAT */
-#endif			/* USES_SNMP_DESIGNED_TCPSTAT */
+#endif          /* WIN32 */
+#endif          /* hpux11 */
+#endif          /* USES_TRADITIONAL_TCPSTAT */
+#endif          /* USES_SNMP_DESIGNED_TCPSTAT */
 
     case TCPCONNTABLE:
         /*
-	 * This is not actually a valid scalar object.
-	 * The table registration should take precedence,
-	 *   so skip this subtree, regardless of architecture.
-	 */
+     * This is not actually a valid scalar object.
+     * The table registration should take precedence,
+     *   so skip this subtree, regardless of architecture.
+     */
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 
-	    }
-	    snmp_set_var_typed_value(request->requestvb, type,
-			             (u_char *)&ret_value, sizeof(ret_value));
-	}
+        }
+#endif /* OPTIMIZED_CODE */
+        snmp_set_var_typed_value(request->requestvb, type,
+                         (u_char *)&ret_value, sizeof(ret_value));
+
+    }
+#if defined(HAVE_OPTIMIZED_CODE)
+        free(tcpstat);
+#endif
         break;
 
     case MODE_GETNEXT:
@@ -498,11 +616,12 @@
 
 
         /*********************
-	 *
-	 *  Internal implementation functions
-	 *
-	 *********************/
+     *
+     *  Internal implementation functions
+     *
+     *********************/
 
+#if defined(HAVE_CACHE_SUPPORT)
 #ifdef hpux11
 int
 tcp_load(netsnmp_cache *cache, void *vmagic)
@@ -512,7 +631,7 @@
     unsigned int    ulen;
     int             ret;
     int             magic = (int) vmagic;
-    
+
     if ((fd = open_mib("/dev/ip", O_RDONLY, 0, NM_ASYNC_OFF)) < 0) {
         DEBUGMSGTL(("mibII/tcpScalar", "Failed to load TCP object %d (hpux11)\n", magic));
         return (-1);            /* error */
@@ -665,7 +784,7 @@
     }
     return ret_value;
 }
-#else		/* (defined(CAN_USE_SYSCTL) && defined(TCPCTL_STATS)) */
+#else       /* (defined(CAN_USE_SYSCTL) && defined(TCPCTL_STATS)) */
 #ifdef HAVE_SYS_TCPIPSTATS_H
 int
 tcp_load(netsnmp_cache *cache, void *vmagic)
@@ -681,7 +800,7 @@
     }
     return ret_value;
 }
-#else				/* HAVE_SYS_TCPIPSTATS_H */
+#else               /* HAVE_SYS_TCPIPSTATS_H */
 #ifdef TCPSTAT_SYMBOL
 int
 tcp_load(netsnmp_cache *cache, void *vmagic)
@@ -698,7 +817,7 @@
     }
     return ret_value;
 }
-#else				/* TCPSTAT_SYMBOL */
+#else               /* TCPSTAT_SYMBOL */
 int
 tcp_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -707,9 +826,9 @@
     DEBUGMSGTL(("mibII/tcpScalar", "Failed to load TCP scalar Group (null)\n"));
     return ret_value;
 }
-#endif				/* TCPSTAT_SYMBOL */
-#endif				/* HAVE_SYS_TCPIPSTATS_H */
-#endif		/* (defined(CAN_USE_SYSCTL) && defined(TCPCTL_STATS)) */
+#endif              /* TCPSTAT_SYMBOL */
+#endif              /* HAVE_SYS_TCPIPSTATS_H */
+#endif      /* (defined(CAN_USE_SYSCTL) && defined(TCPCTL_STATS)) */
 #endif                          /* hpux11 */
 #endif                          /* linux */
 #endif                          /* solaris2 */
@@ -721,3 +840,5 @@
 {
     memset(&tcpstat, 0, sizeof(tcpstat));
 }
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/tcpTable.c open_snmp/agent/mibgroup/mibII/tcpTable.c
--- net-snmp-5.1/agent/mibgroup/mibII/tcpTable.c	2003-11-12 18:25:20.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/tcpTable.c	2009-12-16 12:59:50.000000000 +0530
@@ -24,14 +24,26 @@
 #include "tcpTable.h"
 #include "sysORTable.h"
 
+#if defined(HAVE_OPTIMIZED_CODE)
+#define INP_NEXT_SYMBOL     inp_next
+#define TCPTABLE_ENTRY_TYPE struct inpcb
+#define TCPTABLE_STATE      inp_state
+#define TCPTABLE_LOCALADDRESS   inp_laddr.s_addr
+#define TCPTABLE_LOCALPORT  inp_lport
+#define TCPTABLE_REMOTEADDRESS  inp_faddr.s_addr
+#define TCPTABLE_REMOTEPORT inp_fport
+#define TCPTABLE_IS_LINKED_LIST
+
+#else   /* Non-Optimized Package */
+
 #ifdef hpux11
-#define	TCPTABLE_ENTRY_TYPE	mib_tcpConnEnt 
-#define	TCPTABLE_STATE		State 
-#define	TCPTABLE_LOCALADDRESS	LocalAddress 
-#define	TCPTABLE_LOCALPORT	LocalPort 
-#define	TCPTABLE_REMOTEADDRESS	RemAddress 
-#define	TCPTABLE_REMOTEPORT	RemPort 
-#define	TCPTABLE_IS_TABLE
+#define TCPTABLE_ENTRY_TYPE mib_tcpConnEnt
+#define TCPTABLE_STATE      State
+#define TCPTABLE_LOCALADDRESS   LocalAddress
+#define TCPTABLE_LOCALPORT  LocalPort
+#define TCPTABLE_REMOTEADDRESS  RemAddress
+#define TCPTABLE_REMOTEPORT RemPort
+#define TCPTABLE_IS_TABLE
 #else
 
 #ifdef solaris2
@@ -40,36 +52,36 @@
     mib2_tcpConnEntry_t   entry;
     netsnmp_tcpConnEntry *inp_next;
 };
-#define	TCPTABLE_ENTRY_TYPE	netsnmp_tcpConnEntry
-#define	TCPTABLE_STATE		entry.tcpConnState 
-#define	TCPTABLE_LOCALADDRESS	entry.tcpConnLocalAddress 
-#define	TCPTABLE_LOCALPORT	entry.tcpConnLocalPort 
-#define	TCPTABLE_REMOTEADDRESS	entry.tcpConnRemAddress 
-#define	TCPTABLE_REMOTEPORT	entry.tcpConnRemPort 
-#define	TCPTABLE_IS_LINKED_LIST
+#define TCPTABLE_ENTRY_TYPE netsnmp_tcpConnEntry
+#define TCPTABLE_STATE      entry.tcpConnState
+#define TCPTABLE_LOCALADDRESS   entry.tcpConnLocalAddress
+#define TCPTABLE_LOCALPORT  entry.tcpConnLocalPort
+#define TCPTABLE_REMOTEADDRESS  entry.tcpConnRemAddress
+#define TCPTABLE_REMOTEPORT entry.tcpConnRemPort
+#define TCPTABLE_IS_LINKED_LIST
 #else
 
 #ifdef WIN32
 #include <iphlpapi.h>
-#define	TCPTABLE_ENTRY_TYPE	MIB_TCPROW
-#define	TCPTABLE_STATE		dwState 
-#define	TCPTABLE_LOCALADDRESS	dwLocalAddr
-#define	TCPTABLE_LOCALPORT	dwLocalPort 
-#define	TCPTABLE_REMOTEADDRESS	dwRemoteAddr 
-#define	TCPTABLE_REMOTEPORT	dwRemotePort 
-#define	TCPTABLE_IS_TABLE
+#define TCPTABLE_ENTRY_TYPE MIB_TCPROW
+#define TCPTABLE_STATE      dwState
+#define TCPTABLE_LOCALADDRESS   dwLocalAddr
+#define TCPTABLE_LOCALPORT  dwLocalPort
+#define TCPTABLE_REMOTEADDRESS  dwRemoteAddr
+#define TCPTABLE_REMOTEPORT dwRemotePort
+#define TCPTABLE_IS_TABLE
 #else
 
 #ifdef linux
-#define	TCPTABLE_ENTRY_TYPE	struct inpcb 
-#define	TCPTABLE_STATE		inp_state 
-#define	TCPTABLE_LOCALADDRESS	inp_laddr.s_addr 
-#define	TCPTABLE_LOCALPORT	inp_lport
-#define	TCPTABLE_REMOTEADDRESS	inp_faddr.s_addr 
-#define	TCPTABLE_REMOTEPORT	inp_fport
-#define	TCPTABLE_IS_LINKED_LIST
+#define TCPTABLE_ENTRY_TYPE struct inpcb
+#define TCPTABLE_STATE      inp_state
+#define TCPTABLE_LOCALADDRESS   inp_laddr.s_addr
+#define TCPTABLE_LOCALPORT  inp_lport
+#define TCPTABLE_REMOTEADDRESS  inp_faddr.s_addr
+#define TCPTABLE_REMOTEPORT inp_fport
+#define TCPTABLE_IS_LINKED_LIST
 
-#else			/* everything else */
+#else           /* everything else */
 
 typedef struct netsnmp_inpcb_s netsnmp_inpcb;
 struct netsnmp_inpcb_s {
@@ -77,36 +89,40 @@
     int             state;
     netsnmp_inpcb  *inp_next;
 };
-#define	TCPTABLE_ENTRY_TYPE	netsnmp_inpcb 
-#define	TCPTABLE_STATE		state 
-#define	TCPTABLE_LOCALADDRESS	pcb.inp_laddr.s_addr 
-#define	TCPTABLE_LOCALPORT	pcb.inp_lport
-#define	TCPTABLE_REMOTEADDRESS	pcb.inp_faddr.s_addr 
-#define	TCPTABLE_REMOTEPORT	pcb.inp_fport
-#define	TCPTABLE_IS_LINKED_LIST
+#define TCPTABLE_ENTRY_TYPE netsnmp_inpcb
+#define TCPTABLE_STATE      state
+#define TCPTABLE_LOCALADDRESS   pcb.inp_laddr.s_addr
+#define TCPTABLE_LOCALPORT  pcb.inp_lport
+#define TCPTABLE_REMOTEADDRESS  pcb.inp_faddr.s_addr
+#define TCPTABLE_REMOTEPORT pcb.inp_fport
+#define TCPTABLE_IS_LINKED_LIST
 
 #endif                          /* linux */
 #endif                          /* WIN32 */
 #endif                          /* solaris2 */
 #endif                          /* hpux11 */
 
-				/* Head of linked list, or root of table */
-TCPTABLE_ENTRY_TYPE	*tcp_head  = NULL;
-int                      tcp_size  = 0;	/* Only used for table-based systems */
+#endif  /* OPTIMIZED_CODE */
+
+                /* Head of linked list, or root of table */
+TCPTABLE_ENTRY_TYPE *tcp_head  = NULL;
+int                      tcp_size  = 0; /* Only used for table-based systems */
 int                      tcp_estab = 0;
 
 
-	/*
-	 *
-	 * Initialization and handler routines are common to all architectures
-	 *
-	 */
+    /*
+     *
+     * Initialization and handler routines are common to all architectures
+     *
+     */
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef MIB_STATS_CACHE_TIMEOUT
-#define MIB_STATS_CACHE_TIMEOUT	5
+#define MIB_STATS_CACHE_TIMEOUT 5
 #endif
 #ifndef TCP_STATS_CACHE_TIMEOUT
-#define TCP_STATS_CACHE_TIMEOUT	MIB_STATS_CACHE_TIMEOUT
+#define TCP_STATS_CACHE_TIMEOUT MIB_STATS_CACHE_TIMEOUT
 #endif
+#endif /* CACHE_SUPPORT */
 
 oid             tcpTable_oid[] = { SNMP_OID_MIB2, 6, 13 };
 
@@ -161,14 +177,15 @@
      * .... with a local cache
      *    (except for Solaris, which uses a different approach)
      */
+#if defined(HAVE_CACHE_SUPPORT)
     netsnmp_inject_handler( reginfo,
-		    netsnmp_get_cache_handler(TCP_STATS_CACHE_TIMEOUT,
-			   		tcpTable_load, tcpTable_free,
-					tcpTable_oid, OID_LENGTH(tcpTable_oid)));
+            netsnmp_get_cache_handler(TCP_STATS_CACHE_TIMEOUT,
+                    tcpTable_load, tcpTable_free,
+                    tcpTable_oid, OID_LENGTH(tcpTable_oid)));
+#endif
 }
 
 
-
 int
 tcpTable_handler(netsnmp_mib_handler          *handler,
                  netsnmp_handler_registration *reginfo,
@@ -178,10 +195,14 @@
     netsnmp_request_info  *request;
     netsnmp_variable_list *requestvb;
     netsnmp_table_request_info *table_info;
-    TCPTABLE_ENTRY_TYPE	  *entry;
+    TCPTABLE_ENTRY_TYPE   *entry;
     oid      subid;
     long     port;
     long     state;
+#if defined(HAVE_OPTIMIZED_CODE)
+     struct netsnmp_cache *cache;
+     void *vmagic;
+#endif
 
     DEBUGMSGTL(("mibII/tcpTable", "Handler - mode %s\n",
                     se_find_label_in_slist("agent_mode", reqinfo->mode)));
@@ -198,48 +219,56 @@
             if (!entry)
                 continue;
             table_info = netsnmp_extract_table_info(request);
+            if (table_info == NULL) {
+                continue;
+            }
             subid      = table_info->colnum;
 
             switch (subid) {
             case TCPCONNSTATE:
                 state = entry->TCPTABLE_STATE;
-	        snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+            snmp_set_var_typed_value(requestvb, ASN_INTEGER,
                                  (u_char *)&state, sizeof(state));
                 break;
             case TCPCONNLOCALADDRESS:
 #if defined(osf5) && defined(IN6_EXTRACT_V4ADDR)
-	        snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
+            snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
                               (u_char*)IN6_EXTRACT_V4ADDR(entry->pcb.inp_laddr),
                                 sizeof(IN6_EXTRACT_V4ADDR(entry->pcb.inp_laddr)));
 #else
-	        snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
+            snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
                                  (u_char *)&entry->TCPTABLE_LOCALADDRESS,
                                      sizeof(entry->TCPTABLE_LOCALADDRESS));
 #endif
                 break;
             case TCPCONNLOCALPORT:
                 port = ntohs(entry->TCPTABLE_LOCALPORT);
-	        snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+            snmp_set_var_typed_value(requestvb, ASN_INTEGER,
                                  (u_char *)&port, sizeof(port));
                 break;
             case TCPCONNREMOTEADDRESS:
 #if defined(osf5) && defined(IN6_EXTRACT_V4ADDR)
-	        snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
+            snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
                               (u_char*)IN6_EXTRACT_V4ADDR(entry->pcb.inp_laddr),
                                 sizeof(IN6_EXTRACT_V4ADDR(entry->pcb.inp_laddr)));
 #else
-	        snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
+            snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
                                  (u_char *)&entry->TCPTABLE_REMOTEADDRESS,
                                      sizeof(entry->TCPTABLE_REMOTEADDRESS));
 #endif
                 break;
             case TCPCONNREMOTEPORT:
                 port = ntohs(entry->TCPTABLE_REMOTEPORT);
-	        snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+            snmp_set_var_typed_value(requestvb, ASN_INTEGER,
                                  (u_char *)&port, sizeof(port));
+
                 break;
-	    }
-	}
+        }
+    }
+#if defined(HAVE_OPTIMIZED_CODE)
+     tcpTable_free(cache , vmagic);
+#endif
+
         break;
 
     case MODE_GETNEXT:
@@ -267,15 +296,16 @@
     return tcp_estab;
 }
 
-	/*
-	 * Two forms of iteration hook routines:
-	 *    One for when the TCP table is stored as a table
-	 *    One for when the TCP table is stored as a linked list
-	 *
-	 * Also applies to the cache-handler free routine
-	 */
 
-#ifdef	TCPTABLE_IS_TABLE
+    /*
+     * Two forms of iteration hook routines:
+     *    One for when the TCP table is stored as a table
+     *    One for when the TCP table is stored as a linked list
+     *
+     * Also applies to the cache-handler free routine
+     */
+
+#ifdef  TCPTABLE_IS_TABLE
 netsnmp_variable_list *
 tcpTable_first_entry(void **loop_context,
                      void **data_context,
@@ -286,6 +316,7 @@
      * XXX - How can we tell if the cache is valid?
      *       No access to 'reqinfo'
      */
+
     if (tcp_size == 0)
         return NULL;
 
@@ -360,6 +391,14 @@
      * XXX - How can we tell if the cache is valid?
      *       No access to 'reqinfo'
      */
+#if defined(HAVE_OPTIMIZED_CODE)
+
+     struct netsnmp_cache *cache;
+     void *vmagic;
+
+     tcpTable_load(cache,vmagic);
+#endif
+
     if (tcp_head == 0)
         return NULL;
 
@@ -377,7 +416,7 @@
                      netsnmp_variable_list *index,
                      netsnmp_iterator_info *data)
 {
-    TCPTABLE_ENTRY_TYPE	 *entry = (TCPTABLE_ENTRY_TYPE *)*loop_context;
+    TCPTABLE_ENTRY_TYPE  *entry = (TCPTABLE_ENTRY_TYPE *)*loop_context;
     netsnmp_variable_list *idx;
     long addr, port;
 
@@ -434,20 +473,21 @@
     tcp_size  = 0;
     tcp_estab = 0;
 }
-#endif		/* TCPTABLE_IS_LINKED_LIST */
-#endif		/* TCPTABLE_IS_TABLE */
-
+#endif      /* TCPTABLE_IS_LINKED_LIST */
+#endif      /* TCPTABLE_IS_TABLE */
 
-	/*
-	 *
-	 * The cache-handler loading routine is the main
-	 *    place for architecture-specific code
-	 *
-	 * Load into either a table structure, or a linked list
-	 *    depending on the system architecture
-	 */
+//#endif      /* OPTIMIZED_CODE */
+    /*
+     *
+     * The cache-handler loading routine is the main
+     *    place for architecture-specific code
+     *
+     * Load into either a table structure, or a linked list
+     *    depending on the system architecture
+     */
 
 
+//#if defined(HAVE_CACHE_SUPPORT)
 #ifdef hpux11
 int
 tcpTable_load(netsnmp_cache *cache, void *vmagic)
@@ -518,7 +558,7 @@
     }
 
     /*
-     * scan proc-file and build up a linked list 
+     * scan proc-file and build up a linked list
      * This will actually be built up in reverse,
      *   but since the entries are unsorted, that doesn't matter.
      */
@@ -603,7 +643,7 @@
 
         if (getMibstat(MIB_TCP_CONN, &entry, sizeof(mib2_tcpConnEntry_t),
                        GET_NEXT, &TCP_Cmp, &entry) != 0)
-	    break;
+        break;
     }
 
     if (tcp_head) {
@@ -625,14 +665,14 @@
     int           i;
 
     /*
-     * query for the buffer size needed 
+     * query for the buffer size needed
      */
     status = GetTcpTable(pTcpTable, &dwActualSize, TRUE);
     if (status == ERROR_INSUFFICIENT_BUFFER) {
         pTcpTable = (PMIB_TCPTABLE) malloc(dwActualSize);
         if (pTcpTable != NULL) {
             /*
-             * Get the sorted TCP table 
+             * Get the sorted TCP table
              */
             status = GetTcpTable(pTcpTable, &dwActualSize, TRUE);
         }
@@ -702,8 +742,8 @@
         memcpy(&(nnew->pcb), &(((struct xinpcb *) xig)->xt_inp),
                            sizeof(struct inpcb));
 
-	nnew->inp_next = tcp_head;
-	tcp_head   = nnew;
+    nnew->inp_next = tcp_head;
+    tcp_head   = nnew;
         xig = (struct xinpgen *) ((char *) xig + xig->xig_len);
     }
 
@@ -715,7 +755,7 @@
     DEBUGMSGTL(("mibII/tcpTable", "Failed to load TCP Table (sysctl)\n"));
     return -1;
 }
-#else		/* (defined(CAN_USE_SYSCTL) && defined(TCPCTL_PCBLIST)) */
+#else       /* (defined(CAN_USE_SYSCTL) && defined(TCPCTL_PCBLIST)) */
 #ifdef PCB_TABLE
 int
 tcpTable_load(netsnmp_cache *cache, void *vmagic)
@@ -738,20 +778,20 @@
      */
     entry  = table.inpt_queue.cqh_first;
     while (entry) {
-   
+
         nnew = SNMP_MALLOC_TYPEDEF(netsnmp_inpcb);
         if (!nnew)
             break;
         klookup((unsigned long) entry, (char *)&(nnew->pcb), sizeof(struct inpcb));
         klookup((int) nnew->pcb.inp_ppcb, (char *)&tcpcb, sizeof(struct tcpcb));
-	nnew->state = StateMap[tcpcb.t_state];
+    nnew->state = StateMap[tcpcb.t_state];
         if (nnew->state == 5 /* established */ ||
             nnew->state == 8 /*  closeWait  */ )
             tcp_estab++;
 
-        entry      = nnew->inp_queue.cqe_next;	/* Next kernel entry */
-	nnew->inp_next = tcp_head;
-	tcp_head   = nnew;
+        entry      = nnew->inp_queue.cqe_next;  /* Next kernel entry */
+    nnew->inp_next = tcp_head;
+    tcp_head   = nnew;
 
         if (entry == table.inpt_queue.cqh_first)
             break;
@@ -765,7 +805,7 @@
     return -1;
 }
 
-#else				/* PCB_TABLE */
+#else               /* PCB_TABLE */
 #ifdef TCP_SYMBOL
 int
 tcpTable_load(netsnmp_cache *cache, void *vmagic)
@@ -792,20 +832,20 @@
      */
     entry  = tcp_inpcb.INP_NEXT_SYMBOL;
     while (entry) {
-   
+
         nnew = SNMP_MALLOC_TYPEDEF(netsnmp_inpcb);
         if (!nnew)
             break;
         klookup((unsigned long) entry, (char *)&(nnew->pcb), sizeof(struct inpcb));
         klookup((int) nnew->pcb.inp_ppcb, (char *)&tcpcb, sizeof(struct tcpcb));
-	nnew->state    = StateMap[tcpcb.t_state];
+    nnew->state    = StateMap[tcpcb.t_state];
         if (nnew->state == 5 /* established */ ||
             nnew->state == 8 /*  closeWait  */ )
             tcp_estab++;
 
-        entry          = nnew->pcb.INP_NEXT_SYMBOL;	/* Next kernel entry */
-	nnew->inp_next = tcp_head;
-	tcp_head       = nnew;
+        entry          = nnew->pcb.INP_NEXT_SYMBOL; /* Next kernel entry */
+    nnew->inp_next = tcp_head;
+    tcp_head       = nnew;
 
         if (entry == tcp_inpcb.INP_NEXT_SYMBOL)
             break;
@@ -819,17 +859,18 @@
     return -1;
 }
 
-#else				/* UDB_SYMBOL */
+#else               /* UDB_SYMBOL */
 int
 tcpTable_load(netsnmp_cache *cache, void *vmagic)
 {
     DEBUGMSGTL(("mibII/tcpTable", "Loading TCP Table not implemented\n"));
     return -1;
 }
-#endif				/* UDB_SYMBOL */
-#endif				/* PCB_TABLE */
-#endif		/* (defined(CAN_USE_SYSCTL) && defined(TCPCTL_PCBLIST)) */
+#endif              /* UDB_SYMBOL */
+#endif              /* PCB_TABLE */
+#endif      /* (defined(CAN_USE_SYSCTL) && defined(TCPCTL_PCBLIST)) */
 #endif                          /* WIN32 */
 #endif                          /* linux */
 #endif                          /* solaris2 */
 #endif                          /* hpux11 */
+//#endif      /* HAVE_CACHE_SUPPORT */
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/udp.c open_snmp/agent/mibgroup/mibII/udp.c
--- net-snmp-5.1/agent/mibgroup/mibII/udp.c	2003-08-18 18:12:48.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/udp.c	2009-12-16 12:59:50.000000000 +0530
@@ -54,30 +54,32 @@
 #include <dmalloc.h>
 #endif
 
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef MIB_STATS_CACHE_TIMEOUT
-#define MIB_STATS_CACHE_TIMEOUT	5
+#define MIB_STATS_CACHE_TIMEOUT 5
 #endif
 #ifndef UDP_STATS_CACHE_TIMEOUT
-#define UDP_STATS_CACHE_TIMEOUT	MIB_STATS_CACHE_TIMEOUT
+#define UDP_STATS_CACHE_TIMEOUT MIB_STATS_CACHE_TIMEOUT
+#endif
 #endif
 
         /*********************
-	 *
-	 *  Kernel & interface information,
-	 *   and internal forward declarations
-	 *
-	 *********************/
+     *
+     *  Kernel & interface information,
+     *   and internal forward declarations
+     *
+     *********************/
 
 
         /*********************
-	 *
-	 *  Initialisation & common implementation functions
-	 *
-	 *********************/
+     *
+     *  Initialisation & common implementation functions
+     *
+     *********************/
 
 /*
  * Define the OID pointer to the top of the mib tree that we're
- * registering underneath, and the OID for the MIB module 
+ * registering underneath, and the OID for the MIB module
  */
 oid             udp_oid[]               = { SNMP_OID_MIB2, 7 };
 oid             udp_module_oid[]        = { SNMP_OID_MIB2, 50 };
@@ -92,20 +94,21 @@
      */
     DEBUGMSGTL(("mibII/udpScalar", "Initialising UDP scalar group\n"));
     reginfo = netsnmp_create_handler_registration("udp", udp_handler,
-		    udp_oid, OID_LENGTH(udp_oid), HANDLER_CAN_RONLY);
+            udp_oid, OID_LENGTH(udp_oid), HANDLER_CAN_RONLY);
     netsnmp_register_scalar_group(reginfo, UDPINDATAGRAMS, UDPOUTDATAGRAMS);
 
     /*
      * .... with a local cache
      *    (except for HP-UX 11, which extracts objects individually)
      */
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef hpux11
     netsnmp_inject_handler( reginfo,
-		    netsnmp_get_cache_handler(UDP_STATS_CACHE_TIMEOUT,
-			   		udp_load, udp_free,
-					udp_oid, OID_LENGTH(udp_oid)));
+            netsnmp_get_cache_handler(UDP_STATS_CACHE_TIMEOUT,
+                    udp_load, udp_free,
+                    udp_oid, OID_LENGTH(udp_oid)));
+#endif
 #endif
-
     REGISTER_SYSOR_ENTRY(udp_module_oid,
                          "The MIB module for managing UDP implementations");
 
@@ -122,23 +125,29 @@
 
 
         /*********************
-	 *
-	 *  System specific implementation functions
-	 *
-	 *********************/
+     *
+     *  System specific implementation functions
+     *
+     *********************/
+#if defined(HAVE_OPTIMIZED_CODE)
+#define UDP_STAT_STRUCTURE  struct udp_mib
+#define USES_SNMP_DESIGNED_UDPSTAT
+#undef UDPSTAT_SYMBOL
+
+#else
 
 #ifdef hpux11
-#define UDP_STAT_STRUCTURE	int
+#define UDP_STAT_STRUCTURE  int
 #endif
 
 #ifdef linux
-#define UDP_STAT_STRUCTURE	struct udp_mib
+#define UDP_STAT_STRUCTURE  struct udp_mib
 #define USES_SNMP_DESIGNED_UDPSTAT
 #undef UDPSTAT_SYMBOL
 #endif
 
 #ifdef solaris2
-#define UDP_STAT_STRUCTURE	mib2_udp_t
+#define UDP_STAT_STRUCTURE  mib2_udp_t
 #define USES_SNMP_DESIGNED_UDPSTAT
 #endif
 
@@ -147,26 +156,29 @@
 #define UDP_STAT_STRUCTURE MIB_UDPSTATS
 #endif
 
+#endif /* OPTIMIZED CODE */
+
 #ifdef HAVE_SYS_TCPIPSTATS_H
-#define UDP_STAT_STRUCTURE	struct kna
+#define UDP_STAT_STRUCTURE  struct kna
 #define USES_TRADITIONAL_UDPSTAT
 #endif
 
 
 #if !defined(UDP_STAT_STRUCTURE)
-#define UDP_STAT_STRUCTURE	struct udpstat
+#define UDP_STAT_STRUCTURE  struct udpstat
 #define USES_TRADITIONAL_UDPSTAT
 #endif
 
+#if !defined(HAVE_OPTIMIZED_CODE)
 UDP_STAT_STRUCTURE udpstat;
-
+#endif
 
 
         /*********************
-	 *
-	 *  System independent handler (mostly)
-	 *
-	 *********************/
+     *
+     *  System independent handler (mostly)
+     *
+     *********************/
 
 
 
@@ -182,20 +194,42 @@
     oid      subid;
     int      type = ASN_COUNTER;
 
+#if defined(HAVE_OPTIMIZED_CODE)
+    UDP_STAT_STRUCTURE *udpstat;
+    int protocol=0;
+    int ret;
+#endif
     /*
      * The cached data should already have been loaded by the
      *    cache handler, higher up the handler chain.
      * But just to be safe, check this and load it manually if necessary
      */
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef hpux11
     if (!netsnmp_is_cache_valid(reqinfo)) {
-        udp_load( NULL, NULL );	/* XXX - check for failure */
+        udp_load( NULL, NULL ); /* XXX - check for failure */
     }
 #endif
+#endif
 
-
+#if defined(HAVE_OPTIMIZED_CODE)
+    udpstat = calloc(1, sizeof(UDP_STAT_STRUCTURE));
+    if (udpstat == NULL) {
+        snmp_log(LOG_ERR, "mibII/udp: Malloc Failed for udpstat\n");
+        return SNMP_ERR_GENERR;
+    }
+    else {
+     /* Fill in the tcpstat structure variables */
+      protocol= IFX_UDP_STATS;
+      ret = linux_read_mibII_stats_opt((void *)&udpstat, protocol);
+      if ( ret != 0) {
+        free (udpstat);
+        return SNMP_ERR_GENERR;
+      }
+     }
+#endif
     /*
-     * 
+     *
      *
      */
     DEBUGMSGTL(("mibII/udpScalar", "Handler - mode %s\n",
@@ -209,7 +243,25 @@
             DEBUGMSGOID(("mibII/udpScalar", requestvb->name,
                                             requestvb->name_length));
             DEBUGMSG((   "mibII/udpScalar", "\n"));
+#if defined(HAVE_OPTIMIZED_CODE)
+            switch (subid) {
+#ifdef USES_SNMP_DESIGNED_UDPSTAT
+    case UDPINDATAGRAMS:
+        ret_value = udpstat->udpInDatagrams;
+        break;
+    case UDPNOPORTS:
+        ret_value = udpstat->udpNoPorts;
+        break;
+    case UDPOUTDATAGRAMS:
+        ret_value = udpstat->udpOutDatagrams;
+        break;
+    case UDPINERRORS:
+        ret_value = udpstat->udpInErrors;
+        break;
+#endif           /* USES_SNMP_DESIGNED_UDPSTAT */
+        }
 
+#else       /* Non-Optimized Package */
             switch (subid) {
 #ifdef USES_SNMP_DESIGNED_UDPSTAT
     case UDPINDATAGRAMS:
@@ -218,10 +270,10 @@
     case UDPNOPORTS:
 #ifdef solaris2
         ret_value = udp_load(NULL, (void *)UDPNOPORTS);
-	if (ret_value == -1) {
+    if (ret_value == -1) {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
-	}
+    }
         break;
 #else
         ret_value = udpstat.udpNoPorts;
@@ -233,13 +285,13 @@
     case UDPINERRORS:
         ret_value = udpstat.udpInErrors;
         break;
-#else			/* USES_SNMP_DESIGNED_UDPSTAT */
+#else           /* USES_SNMP_DESIGNED_UDPSTAT */
 
 #ifdef USES_TRADITIONAL_UDPSTAT
 #ifdef HAVE_SYS_TCPIPSTATS_H
     /*
      * This actually reads statistics for *all* the groups together,
-     * so we need to isolate the UDP-specific bits.  
+     * so we need to isolate the UDP-specific bits.
      */
 #define udpstat          udpstat.udpstat
 #endif
@@ -283,25 +335,25 @@
 #ifdef HAVE_SYS_TCPIPSTATS_H
 #undef udpstat
 #endif
-#else			/* USES_TRADITIONAL_UDPSTAT */
+#else           /* USES_TRADITIONAL_UDPSTAT */
 
 #ifdef hpux11
     case UDPINDATAGRAMS:
     case UDPNOPORTS:
     case UDPOUTDATAGRAMS:
     case UDPINERRORS:
-	/*
-	 * This is a bit of a hack, to shoehorn the HP-UX 11
-	 * single-object retrieval approach into the caching
-	 * architecture.
-	 */
-	if (udp_load(NULL, (void*)subid) == -1 ) {
+    /*
+     * This is a bit of a hack, to shoehorn the HP-UX 11
+     * single-object retrieval approach into the caching
+     * architecture.
+     */
+    if (udp_load(NULL, (void*)subid) == -1 ) {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
-	}
+    }
         ret_value = udpstat;
         break;
-#else			/* hpux11 */
+#else           /* hpux11 */
 #ifdef WIN32
     case UDPINDATAGRAMS:
         ret_value = udpstat.dwInDatagrams;
@@ -315,15 +367,20 @@
     case UDPINERRORS:
         ret_value = udpstat.dwInErrors;
         break;
-#endif			/* WIN32 */
-#endif			/* hpux11 */
-#endif			/* USES_TRADITIONAL_UDPSTAT */
-#endif			/* USES_SNMP_DESIGNED_UDPSTAT */
-
-	    }
-	    snmp_set_var_typed_value(request->requestvb, type,
-			             (u_char *)&ret_value, sizeof(ret_value));
-	}
+#endif          /* WIN32 */
+#endif          /* hpux11 */
+#endif          /* USES_TRADITIONAL_UDPSTAT */
+#endif          /* USES_SNMP_DESIGNED_UDPSTAT */
+
+        }
+#endif          /* OPTIMIZED_CODE */
+        snmp_set_var_typed_value(request->requestvb, type,
+                         (u_char *)&ret_value, sizeof(ret_value));
+
+    }
+#if defined(HAVE_OPTIMIZED_CODE)
+        free(udpstat);
+#endif
         break;
 
     case MODE_GETNEXT:
@@ -348,11 +405,12 @@
 
 
         /*********************
-	 *
-	 *  Internal implementation functions
-	 *
-	 *********************/
+     *
+     *  Internal implementation functions
+     *
+     *********************/
 
+#if defined(HAVE_CACHE_SUPPORT)
 #ifdef hpux11
 int
 udp_load(netsnmp_cache *cache, void *vmagic)
@@ -362,7 +420,7 @@
     unsigned int    ulen;
     int             ret;
     int             magic = (int) vmagic;
-    
+
     if ((fd = open_mib("/dev/ip", O_RDONLY, 0, NM_ASYNC_OFF)) < 0) {
         DEBUGMSGTL(("mibII/udpScalar", "Failed to load UDP object %d (hpux11)\n", magic));
         return (-1);            /* error */
@@ -485,7 +543,7 @@
     }
     return ret_value;
 }
-#else		/* (defined(CAN_USE_SYSCTL) && defined(UDPCTL_STATS)) */
+#else       /* (defined(CAN_USE_SYSCTL) && defined(UDPCTL_STATS)) */
 #ifdef HAVE_SYS_TCPIPSTATS_H
 int
 udp_load(netsnmp_cache *cache, void *vmagic)
@@ -501,7 +559,7 @@
     }
     return ret_value;
 }
-#else				/* HAVE_SYS_TCPIPSTATS_H */
+#else               /* HAVE_SYS_TCPIPSTATS_H */
 #ifdef UDPSTAT_SYMBOL
 int
 udp_load(netsnmp_cache *cache, void *vmagic)
@@ -518,7 +576,7 @@
     }
     return ret_value;
 }
-#else				/* UDPSTAT_SYMBOL */
+#else               /* UDPSTAT_SYMBOL */
 int
 udp_load(netsnmp_cache *cache, void *vmagic)
 {
@@ -527,9 +585,9 @@
     DEBUGMSGTL(("mibII/udpScalar", "Failed to load UDP scalar Group (null)\n"));
     return ret_value;
 }
-#endif				/* UDPSTAT_SYMBOL */
-#endif				/* HAVE_SYS_TCPIPSTATS_H */
-#endif		/* (defined(CAN_USE_SYSCTL) && defined(UDPCTL_STATS)) */
+#endif              /* UDPSTAT_SYMBOL */
+#endif              /* HAVE_SYS_TCPIPSTATS_H */
+#endif      /* (defined(CAN_USE_SYSCTL) && defined(UDPCTL_STATS)) */
 #endif                          /* hpux11 */
 #endif                          /* linux */
 #endif                          /* solaris2 */
@@ -541,3 +599,6 @@
 {
     memset(&udpstat, 0, sizeof(udpstat));
 }
+
+#endif
+
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/udpTable.c open_snmp/agent/mibgroup/mibII/udpTable.c
--- net-snmp-5.1/agent/mibgroup/mibII/udpTable.c	2003-08-18 18:12:48.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/udpTable.c	2009-12-16 12:59:50.000000000 +0530
@@ -24,11 +24,20 @@
 #include "udpTable.h"
 #include "sysORTable.h"
 
+#if defined(HAVE_OPTIMIZED_CODE)
+#define INP_NEXT_SYMBOL     inp_next
+#define UDPTABLE_ENTRY_TYPE struct inpcb
+#define UDPTABLE_LOCALADDRESS   inp_laddr.s_addr
+#define UDPTABLE_LOCALPORT  inp_lport
+#define UDPTABLE_IS_LINKED_LIST
+
+#else   /* Non-Optimized Package */
+
 #ifdef hpux11
-#define	UDPTABLE_ENTRY_TYPE	mib_udpLsnEnt 
-#define	UDPTABLE_LOCALADDRESS	LocalAddress 
-#define	UDPTABLE_LOCALPORT	LocalPort 
-#define	UDPTABLE_IS_TABLE
+#define UDPTABLE_ENTRY_TYPE mib_udpLsnEnt
+#define UDPTABLE_LOCALADDRESS   LocalAddress
+#define UDPTABLE_LOCALPORT  LocalPort
+#define UDPTABLE_IS_TABLE
 #else
 
 #ifdef solaris2
@@ -37,48 +46,52 @@
     mib2_udpEntry_t   entry;
     netsnmp_udpEntry *inp_next;
 };
-#define	UDPTABLE_ENTRY_TYPE	netsnmp_udpEntry
-#define	UDPTABLE_LOCALADDRESS	entry.udpLocalAddress 
-#define	UDPTABLE_LOCALPORT	entry.udpLocalPort 
-#define	UDPTABLE_IS_LINKED_LIST
+#define UDPTABLE_ENTRY_TYPE netsnmp_udpEntry
+#define UDPTABLE_LOCALADDRESS   entry.udpLocalAddress
+#define UDPTABLE_LOCALPORT  entry.udpLocalPort
+#define UDPTABLE_IS_LINKED_LIST
 #else
 
 #ifdef WIN32
 #include <iphlpapi.h>
-#define	UDPTABLE_ENTRY_TYPE	MIB_UDPROW		/* ??? */
-#define	UDPTABLE_LOCALADDRESS	dwLocalAddr
-#define	UDPTABLE_LOCALPORT	dwLocalPort 
-#define	UDPTABLE_IS_TABLE
-#else			/* everything else */
+#define UDPTABLE_ENTRY_TYPE MIB_UDPROW      /* ??? */
+#define UDPTABLE_LOCALADDRESS   dwLocalAddr
+#define UDPTABLE_LOCALPORT  dwLocalPort
+#define UDPTABLE_IS_TABLE
+#else           /* everything else */
 
 #ifdef linux
-#define INP_NEXT_SYMBOL		inp_next
+#define INP_NEXT_SYMBOL     inp_next
 #endif
-#define	UDPTABLE_ENTRY_TYPE	struct inpcb 
-#define	UDPTABLE_LOCALADDRESS	inp_laddr.s_addr 
-#define	UDPTABLE_LOCALPORT	inp_lport
-#define	UDPTABLE_IS_LINKED_LIST
+#define UDPTABLE_ENTRY_TYPE struct inpcb
+#define UDPTABLE_LOCALADDRESS   inp_laddr.s_addr
+#define UDPTABLE_LOCALPORT  inp_lport
+#define UDPTABLE_IS_LINKED_LIST
 
 #endif                          /* WIN32 */
 #endif                          /* solaris2 */
 #endif                          /* hpux11 */
 
-				/* Head of linked list, or root of table */
-UDPTABLE_ENTRY_TYPE	*udp_head  = NULL;
-int                      udp_size  = 0;	/* Only used for table-based systems */
+#endif  /* OPTIMIZED_CODE */
 
+                /* Head of linked list, or root of table */
+UDPTABLE_ENTRY_TYPE *udp_head  = NULL;
+int                      udp_size  = 0; /* Only used for table-based systems */
 
-	/*
-	 *
-	 * Initialization and handler routines are common to all architectures
-	 *
-	 */
+
+    /*
+     *
+     * Initialization and handler routines are common to all architectures
+     *
+     */
+#if defined(HAVE_CACHE_SUPPORT)
 #ifndef MIB_STATS_CACHE_TIMEOUT
-#define MIB_STATS_CACHE_TIMEOUT	5
+#define MIB_STATS_CACHE_TIMEOUT 5
 #endif
 #ifndef UDP_STATS_CACHE_TIMEOUT
-#define UDP_STATS_CACHE_TIMEOUT	MIB_STATS_CACHE_TIMEOUT
+#define UDP_STATS_CACHE_TIMEOUT MIB_STATS_CACHE_TIMEOUT
 #endif
+#endif /* CACHE_SUPPORT */
 
 oid             udpTable_oid[] = { SNMP_OID_MIB2, 7, 5 };
 
@@ -130,10 +143,12 @@
     /*
      * .... with a local cache
      */
+#if defined(HAVE_CACHE_SUPPORT)
     netsnmp_inject_handler( reginfo,
-		    netsnmp_get_cache_handler(UDP_STATS_CACHE_TIMEOUT,
-			   		udpTable_load, udpTable_free,
-					udpTable_oid, OID_LENGTH(udpTable_oid)));
+            netsnmp_get_cache_handler(UDP_STATS_CACHE_TIMEOUT,
+                    udpTable_load, udpTable_free,
+                    udpTable_oid, OID_LENGTH(udpTable_oid)));
+#endif
 }
 
 
@@ -147,9 +162,14 @@
     netsnmp_request_info  *request;
     netsnmp_variable_list *requestvb;
     netsnmp_table_request_info *table_info;
-    UDPTABLE_ENTRY_TYPE	  *entry;
+    UDPTABLE_ENTRY_TYPE   *entry;
     oid      subid;
     long     port;
+#if defined(HAVE_OPTIMIZED_CODE)
+     struct netsnmp_cache *cache;
+     void *vmagic;
+#endif
+
 
     DEBUGMSGTL(("mibII/udpTable", "Handler - mode %s\n",
                     se_find_label_in_slist("agent_mode", reqinfo->mode)));
@@ -171,22 +191,27 @@
             switch (subid) {
             case UDPLOCALADDRESS:
 #if defined(osf5) && defined(IN6_EXTRACT_V4ADDR)
-	        snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
+            snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
                               (u_char*)IN6_EXTRACT_V4ADDR(pcb->inp_laddr),
                                 sizeof(IN6_EXTRACT_V4ADDR(pcb->inp_laddr)));
 #else
-	        snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
+            snmp_set_var_typed_value(requestvb, ASN_IPADDRESS,
                                  (u_char *)&entry->UDPTABLE_LOCALADDRESS,
                                      sizeof(entry->UDPTABLE_LOCALADDRESS));
 #endif
                 break;
             case UDPLOCALPORT:
                 port = ntohs(entry->UDPTABLE_LOCALPORT);
-	        snmp_set_var_typed_value(requestvb, ASN_INTEGER,
+            snmp_set_var_typed_value(requestvb, ASN_INTEGER,
                                  (u_char *)&port, sizeof(port));
+
+
                 break;
-	    }
-	}
+        }
+    }
+#if defined(HAVE_OPTIMIZED_CODE)
+     udpTable_free(cache,vmagic);
+#endif
         break;
 
     case MODE_GETNEXT:
@@ -209,15 +234,16 @@
     return SNMP_ERR_NOERROR;
 }
 
-	/*
-	 * Two forms of iteration hook routines:
-	 *    One for when the UDP table is stored as a table
-	 *    One for when the UDP table is stored as a linked list
-	 *
-	 * Also applies to the cache-handler free routine
-	 */
 
-#ifdef	UDPTABLE_IS_TABLE
+    /*
+     * Two forms of iteration hook routines:
+     *    One for when the UDP table is stored as a table
+     *    One for when the UDP table is stored as a linked list
+     *
+     * Also applies to the cache-handler free routine
+     */
+
+#ifdef  UDPTABLE_IS_TABLE
 netsnmp_variable_list *
 udpTable_first_entry(void **loop_context,
                      void **data_context,
@@ -276,6 +302,7 @@
     udp_head = NULL;
     udp_size = 0;
 }
+
 #else
 #ifdef UDPTABLE_IS_LINKED_LIST
 netsnmp_variable_list *
@@ -288,6 +315,14 @@
      * XXX - How can we tell if the cache is valid?
      *       No access to 'reqinfo'
      */
+#if defined(HAVE_OPTIMIZED_CODE)
+
+     struct netsnmp_cache *cache;
+     void *vmagic;
+
+     udpTable_load(cache,vmagic);
+#endif
+
     if (udp_head == 0)
         return NULL;
 
@@ -305,7 +340,7 @@
                      netsnmp_variable_list *index,
                      netsnmp_iterator_info *data)
 {
-    UDPTABLE_ENTRY_TYPE	 *entry = (UDPTABLE_ENTRY_TYPE *)*loop_context;
+    UDPTABLE_ENTRY_TYPE  *entry = (UDPTABLE_ENTRY_TYPE *)*loop_context;
     long port;
 
     if (!entry)
@@ -338,7 +373,7 @@
 void
 udpTable_free(netsnmp_cache *cache, void *magic)
 {
-    UDPTABLE_ENTRY_TYPE	 *p;
+    UDPTABLE_ENTRY_TYPE  *p;
     while (udp_head) {
         p = udp_head;
         udp_head = udp_head->INP_NEXT_SYMBOL;
@@ -347,20 +382,22 @@
 
     udp_head = NULL;
 }
-#endif		/* UDPTABLE_IS_LINKED_LIST */
-#endif		/* UDPTABLE_IS_TABLE */
+#endif      /* UDPTABLE_IS_LINKED_LIST */
+#endif      /* UDPTABLE_IS_TABLE */
 
+//#endif      /* OPTIMIZED_CODE /
 
-	/*
-	 *
-	 * The cache-handler loading routine is the main
-	 *    place for architecture-specific code
-	 *
-	 * Load into either a table structure, or a linked list
-	 *    depending on the system architecture
-	 */
+    /*
+     *
+     * The cache-handler loading routine is the main
+     *    place for architecture-specific code
+     *
+     * Load into either a table structure, or a linked list
+     *    depending on the system architecture
+     */
 
 
+//#if defined(HAVE_CACHE_SUPPORT)
 #ifdef hpux11
 int
 udpTable_load(netsnmp_cache *cache, void *vmagic)
@@ -420,7 +457,7 @@
     }
 
     /*
-     * scan proc-file and build up a linked list 
+     * scan proc-file and build up a linked list
      * This will actually be built up in reverse,
      *   but since the entries are unsorted, that doesn't matter.
      */
@@ -489,23 +526,23 @@
             /*
              * Build up a linked list copy of the getMibstat results
              * Note that since getMibstat returns rows in sorted order,
-	     *    we need to retain this order while building the list
-	     *    so new entries are added onto the end of the list.
+         *    we need to retain this order while building the list
+         *    so new entries are added onto the end of the list.
              */
             nnew = SNMP_MALLOC_TYPEDEF(netsnmp_udpEntry);
             if (nnew == NULL)
                 break;
             memcpy(&(nnew->entry), &entry, sizeof(mib2_udpEntry_t));
             if (!prev_entry)
-	        udp_head = nnew;
-	    else
-	        prev_entry->inp_next = nnew;
-	    prev_entry = nnew;
-	}
+            udp_head = nnew;
+        else
+            prev_entry->inp_next = nnew;
+        prev_entry = nnew;
+    }
 
         if (getMibstat(MIB_UDP_LISTEN, &entry, sizeof(mib2_udpEntry_t),
                        GET_NEXT, &UDP_Cmp, &entry) != 0)
-	    break;
+        break;
     }
 
     if (udp_head) {
@@ -526,14 +563,14 @@
     DWORD         status = NO_ERROR;
 
     /*
-     * query for the buffer size needed 
+     * query for the buffer size needed
      */
     status = GetUdpTable(pUdpTable, &dwActualSize, TRUE);
     if (status == ERROR_INSUFFICIENT_BUFFER) {
         pUdpTable = (PMIB_UDPTABLE) malloc(dwActualSize);
         if (pUdpTable != NULL) {
             /*
-             * Get the sorted UDP table 
+             * Get the sorted UDP table
              */
             status = GetUdpTable(pUdpTable, &dwActualSize, TRUE);
         }
@@ -586,8 +623,8 @@
             break;
         memcpy(nnew, ((struct xinpcb *) xig)->xi_inp, sizeof(struct inpcb));
 
-	nnew->next = udp_head;		/* XXX - ?? Check 'next' pointer */
-	udp_head   = nnew;
+    nnew->next = udp_head;      /* XXX - ?? Check 'next' pointer */
+    udp_head   = nnew;
         xig = (struct xinpgen *) ((char *) xig + xig->xig_len);
     }
 
@@ -599,7 +636,7 @@
     DEBUGMSGTL(("mibII/udpTable", "Failed to load UDP Table (sysctl)\n"));
     return -1;
 }
-#else		/* (defined(CAN_USE_SYSCTL) && defined(UDPCTL_PCBLIST)) */
+#else       /* (defined(CAN_USE_SYSCTL) && defined(UDPCTL_PCBLIST)) */
 #ifdef PCB_TABLE
 int
 udpTable_load(netsnmp_cache *cache, void *vmagic)
@@ -619,15 +656,15 @@
      */
     entry  = table.inpt_queue.cqh_first;
     while (entry) {
-   
+
         nnew = SNMP_MALLOC_TYPEDEF(struct inpcb);
         if (!nnew)
             break;
         klookup((unsigned long) entry, (char *) nnew, sizeof(struct inpcb));
 
-        entry    = nnew->inp_queue.cqe_next;	/* Next kernel entry */
-	nnew->inp_queue.cqe_next = udp_head;
-	udp_head = nnew;
+        entry    = nnew->inp_queue.cqe_next;    /* Next kernel entry */
+    nnew->inp_queue.cqe_next = udp_head;
+    udp_head = nnew;
 
         if (entry == table.inpt_queue.cqh_first)
             break;
@@ -641,7 +678,7 @@
     return -1;
 }
 
-#else				/* PCB_TABLE */
+#else               /* PCB_TABLE */
 #ifdef UDB_SYMBOL
 int
 udpTable_load(netsnmp_cache *cache, void *vmagic)
@@ -661,15 +698,15 @@
      */
     entry  = udp_inpcb.INP_NEXT_SYMBOL;
     while (entry) {
-   
+
         nnew = SNMP_MALLOC_TYPEDEF(struct inpcb);
         if (!nnew)
             break;
         klookup((unsigned long) entry, (char *) nnew, sizeof(struct inpcb));
 
-        entry    = nnew->INP_NEXT_SYMBOL;		/* Next kernel entry */
-	nnew->INP_NEXT_SYMBOL = udp_head;
-	udp_head = nnew;
+        entry    = nnew->INP_NEXT_SYMBOL;       /* Next kernel entry */
+    nnew->INP_NEXT_SYMBOL = udp_head;
+    udp_head = nnew;
 
         if (entry == udp_inpcb.INP_NEXT_SYMBOL)
             break;
@@ -683,17 +720,19 @@
     return -1;
 }
 
-#else				/* UDB_SYMBOL */
+#else               /* UDB_SYMBOL */
 int
 udpTable_load(netsnmp_cache *cache, void *vmagic)
 {
     DEBUGMSGTL(("mibII/udpTable", "Loading UDP Table not implemented\n"));
     return -1;
 }
-#endif				/* UDB_SYMBOL */
-#endif				/* PCB_TABLE */
-#endif		/* (defined(CAN_USE_SYSCTL) && defined(UDPCTL_PCBLIST)) */
+#endif              /* UDB_SYMBOL */
+#endif              /* PCB_TABLE */
+#endif      /* (defined(CAN_USE_SYSCTL) && defined(UDPCTL_PCBLIST)) */
 #endif                          /* WIN32 */
 #endif                          /* linux */
 #endif                          /* solaris2 */
 #endif                          /* hpux11 */
+//#endif      /* HAVE_CACHE_SUPPORT */
+
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/vacm_context.c open_snmp/agent/mibgroup/mibII/vacm_context.c
--- net-snmp-5.1/agent/mibgroup/mibII/vacm_context.c	2003-05-21 23:27:40.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/vacm_context.c	2009-12-16 12:59:50.000000000 +0530
@@ -13,6 +13,16 @@
 
 #include "vacm_context.h"
 
+#if defined(HAVE_OPTIMIZED_CODE)
+void
+init_vacm_context(void)
+{
+/* Dummy function */
+ return;
+}
+
+#else
+
 static oid      vacm_context_oid[] = { 1, 3, 6, 1, 6, 3, 16, 1, 1 };
 
 #define CONTEXTNAME_COLUMN 1
@@ -162,3 +172,4 @@
 
     return SNMP_ERR_NOERROR;
 }
+#endif /* HAVE_OPTIMIZED_CODE */
diff -Naur net-snmp-5.1/agent/mibgroup/mibII/vacm_vars.c open_snmp/agent/mibgroup/mibII/vacm_vars.c
--- net-snmp-5.1/agent/mibgroup/mibII/vacm_vars.c	2003-06-25 20:08:35.000000000 +0530
+++ open_snmp/agent/mibgroup/mibII/vacm_vars.c	2009-12-16 12:59:51.000000000 +0530
@@ -62,6 +62,119 @@
 #endif
 #include "sysORTable.h"
 #endif
+
+#if defined(HAVE_OPTIMIZED_CODE)
+char  glb_rocommunity[COMMUNITY_MAX_LEN] = {'\0'};
+char  glb_rwcommunity[COMMUNITY_MAX_LEN] = {'\0'};
+ 
+void
+init_vacm_vars(void)
+{
+    snmpd_register_config_handler("rwcommunity", vacm_parse_simple, NULL,
+                                  "community [default|hostname|network/bits [oid]]");
+    snmpd_register_config_handler("rocommunity", vacm_parse_simple, NULL,
+                                  "community [default|hostname|network/bits [oid]]");
+
+    /*
+     * register ourselves to handle access control 
+     */
+    snmp_register_callback(SNMP_CALLBACK_APPLICATION,
+                           SNMPD_CALLBACK_ACM_CHECK, vacm_in_view_callback,
+                           NULL);
+    snmp_register_callback(SNMP_CALLBACK_APPLICATION,
+                           SNMPD_CALLBACK_ACM_CHECK_INITIAL,
+                           vacm_in_view_callback, NULL);
+    
+}	
+
+
+void
+vacm_parse_simple(const char *token, char *confline)
+{
+    if (strcmp(token, "rocommunity") == 0)
+	strncpy(glb_rocommunity, confline, strlen(confline));
+    else if (strcmp(token, "rwcommunity") == 0)
+	strncpy(glb_rwcommunity, confline, strlen(confline));
+    else
+        snmp_log(LOG_WARNING,
+                 "Warning: no community strings are configured.\n  It's "
+                 "unlikely this agent can serve any useful purpose in this "
+                 "state.\n");
+    return;
+}
+
+
+int
+vacm_in_view_callback(int majorID, int minorID, void *serverarg,
+                      void *clientarg)
+{
+    struct view_parameters *view_parms =
+        (struct view_parameters *) serverarg;
+    int             retval;
+
+    if (view_parms == NULL)
+        return 1;
+    retval = vacm_in_view(view_parms->pdu, view_parms->name,
+                          view_parms->namelen, view_parms->check_subtree);
+    if (retval != 0)
+        view_parms->errorcode = retval;
+    return retval;
+}
+
+
+int
+vacm_in_view(netsnmp_pdu *pdu, oid * name, size_t namelen,
+             int check_subtree)
+{
+    if (pdu->version == SNMP_VERSION_1
+	    || pdu->version == SNMP_VERSION_2c) {
+	switch (pdu->command) {
+    	case SNMP_MSG_GET:
+    	case SNMP_MSG_GETNEXT:
+    	case SNMP_MSG_GETBULK:
+	 if (pdu->community) {
+	 	if ((strcmp(pdu->community, glb_rocommunity) != 0)
+			&& (strcmp(pdu->community, glb_rwcommunity) != 0)) {
+        	  DEBUGMSG(("Community string doesn't match for GET operation!", "\n"));
+        	  snmp_increment_statistic(STAT_SNMPINBADCOMMUNITYNAMES);
+        	  return VACM_NOACCESS;
+		}
+	 }
+	break;
+	
+    	case SNMP_MSG_SET:
+	 if (pdu->community) {
+	 	if (strcmp(pdu->community, glb_rwcommunity) != 0) {
+        	  DEBUGMSG(("Community string doesn't match for SET operation!", "\n"));
+        	  snmp_increment_statistic(STAT_SNMPINBADCOMMUNITYNAMES);
+        	  return VACM_NOACCESS;
+		}
+	 }
+	break;
+	
+    	case SNMP_MSG_TRAP:
+    	case SNMP_MSG_TRAP2:
+    	case SNMP_MSG_INFORM:
+	break;
+	
+    	default:
+        	snmp_log(LOG_ERR, "bad msg type in vacm_in_view: %d\n",
+                 	pdu->command);
+		return VACM_NOSUCHCONTEXT;
+    	}
+
+    }
+    else {
+    
+    	DEBUGMSG(("SNMP Version %d", "not supported\n", pdu->version));
+	return VACM_NOSUCHCONTEXT;
+    }
+
+    return VACM_SUCCESS;
+}                               /* end vacm_in_view() */
+
+#else
+
 static unsigned int vacmViewSpinLock = 0;
 
 void
@@ -915,7 +1028,6 @@
 
 }                               /* end vacm_in_view() */
 
-
 u_char         *
 var_vacm_sec2group(struct variable * vp,
                    oid * name,
@@ -2657,3 +2769,4 @@
     }
     return SNMP_ERR_NOERROR;
 }
+#endif /* HAVE_OPTIMIZED_CODE */
diff -Naur net-snmp-5.1/agent/mibgroup/target/snmpTargetParamsEntry.c open_snmp/agent/mibgroup/target/snmpTargetParamsEntry.c
--- net-snmp-5.1/agent/mibgroup/target/snmpTargetParamsEntry.c	2002-12-19 20:37:32.000000000 +0530
+++ open_snmp/agent/mibgroup/target/snmpTargetParamsEntry.c	2009-12-16 12:59:55.000000000 +0530
@@ -846,13 +846,14 @@
                         "write to snmpTargetParamsSecModel: secModel out of range\n"));
             return SNMP_ERR_WRONGVALUE;
         }
+#ifdef SNMP_SECMOD_USM
         if (find_sec_mod(long_ret) == NULL && long_ret >= 3) {
             DEBUGMSGTL(("snmpTargetParamsEntry",
                         "write to snmpTargetParamsSecModel: secModel %d unsupported\n",
                         long_ret));
             return SNMP_ERR_INCONSISTENTVALUE;
         }
-
+#endif /* SNMP_SECMOD_USM */
     } else if (action == RESERVE2) {
         snmpTargetParamsOID[snmpTargetParamsOIDLen - 1] =
             SNMPTARGETPARAMSSECURITYMODELCOLUMN;
diff -Naur net-snmp-5.1/agent/snmp_agent.c open_snmp/agent/snmp_agent.c
--- net-snmp-5.1/agent/snmp_agent.c	2003-10-31 07:07:28.000000000 +0530
+++ open_snmp/agent/snmp_agent.c	2009-12-16 13:00:05.000000000 +0530
@@ -98,6 +98,7 @@
 #include "smux/smux.h"
 #endif
 
+#if !defined(HAVE_OPTIMIZED_CODE)
 #define SNMP_ADDRCACHE_SIZE 10
 
 struct addrCache {
@@ -111,6 +112,7 @@
 static struct addrCache addrCache[SNMP_ADDRCACHE_SIZE];
 int             lastAddrAge = 0;
 int             log_addresses = 0;
+#endif
 
 
 
@@ -147,7 +149,6 @@
 int             netsnmp_add_queued(netsnmp_agent_session *asp);
 int             netsnmp_remove_from_delegated(netsnmp_agent_session *asp);
 
-
 static int      current_globalid = 0;
 
 int
@@ -333,6 +334,9 @@
     int             all_eoMib;
     netsnmp_variable_list *prev = NULL;
             
+    if (asp->vbcount == 0)  /* Nothing to do! */
+	  return;
+		
     if (asp->pdu->errstat < asp->vbcount) {
         n = asp->pdu->errstat;
     } else {
@@ -342,6 +346,10 @@
         r = 0;
     }
             
+    /* we do nothing if there is nothing repeated */
+    if (r == 0)
+       return;
+		
     /*
      * For each of the original repeating varbinds (except the last),
      *  go through the block of results for that varbind,
@@ -449,7 +457,6 @@
     }
 }
 
-
 int
 getNextSessID()
 {
@@ -524,7 +531,7 @@
 }
 
 
-
+#if !defined(HAVE_OPTIMIZED_CODE)
 /*
  * Set up the address cache.  
  */
@@ -564,6 +571,7 @@
         }
     }
 }
+#endif
 
 /*******************************************************************-o-******
  * netsnmp_agent_check_packet
@@ -626,7 +634,7 @@
 #endif                          /*USE_LIBWRAP */
 
     snmp_increment_statistic(STAT_SNMPINPKTS);
-
+#if !defined(HAVE_OPTIMIZED_CODE)
     if (log_addresses || netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 						NETSNMP_DS_AGENT_VERBOSE)) {
         for (i = 0; i < SNMP_ADDRCACHE_SIZE; i++) {
@@ -672,6 +680,7 @@
             addrCache[i].status = SNMP_ADDRCACHE_USED;
         }
     }
+#endif
 
     if (addr_string != NULL) {
         SNMP_FREE(addr_string);
@@ -1804,6 +1813,7 @@
     return request;
 }
 
+#if !defined(HAVE_OPTIMIZED_CODE)
 /*
  * check the ACM(s) for the results on each of the varbinds.
  * If ACM disallows it, replace the value with type
@@ -1873,7 +1883,7 @@
     }
     return ret;
 }
-
+#endif
 
 int
 netsnmp_create_subtree_cache(netsnmp_agent_session *asp)
@@ -2559,11 +2569,12 @@
             return SNMP_ERR_NOERROR;
         }
 
+#if !defined(HAVE_OPTIMIZED_CODE)
         /*
          * check vacm against results 
          */
         check_acm(asp, ASN_PRIV_RETRY);
-
+#endif
         /*
          * need to keep going we're not done yet. 
          */
@@ -2850,10 +2861,12 @@
          */
         snmp_increment_statistic(STAT_SNMPINGETREQUESTS);
 
+#if !defined(HAVE_OPTIMIZED_CODE)
         /*
          * check vacm ahead of time 
          */
         check_acm(asp, SNMP_NOSUCHOBJECT);
+#endif
 
         /*
          * get the results 
@@ -2919,11 +2932,14 @@
         break;
 
     case SNMP_MSG_SET:
+
+#if !defined(HAVE_OPTIMIZED_CODE)
         /*
          * check access permissions first 
          */
         if (check_acm(asp, SNMP_NOSUCHOBJECT))
             return SNMP_ERR_NOTWRITABLE;
+#endif
 
         asp->mode = MODE_SET_BEGIN;
         status = handle_set_loop(asp);
diff -Naur net-snmp-5.1/agent/snmp_vars.c open_snmp/agent/snmp_vars.c
--- net-snmp-5.1/agent/snmp_vars.c	2003-10-31 07:06:04.000000000 +0530
+++ open_snmp/agent/snmp_vars.c	2009-12-16 13:00:05.000000000 +0530
@@ -305,9 +305,11 @@
     netsnmp_clear_tdomain_list();
     netsnmp_clear_handler_list();
     netsnmp_container_free_list();
-    clear_sec_mod();
     clear_snmp_enum();
     clear_callback();
+#ifdef SNMP_SECMOD_USM
+    clear_sec_mod();
     clear_user_list();
+#endif /* SNMP_SECMOD_USM */
 }
 
diff -Naur net-snmp-5.1/agent/snmpd.c open_snmp/agent/snmpd.c
--- net-snmp-5.1/agent/snmpd.c	2003-11-02 18:20:37.000000000 +0530
+++ open_snmp/agent/snmpd.c	2009-12-16 13:00:06.000000000 +0530
@@ -31,10 +31,12 @@
  * *****************************************************************
  */
 /*
- * Copyright  2003 Sun Microsystems, Inc. All rights reserved.
+ * Copyright ?2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
+//509141:tc.chen 2005/09/14 added cpe-dsl-mib feature support
+
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdio.h>
@@ -113,7 +115,12 @@
 #if HAVE_GRP_H
 #include <grp.h>
 #endif
-
+#ifdef PATH_MAX
+#  undef PATH_MAX
+#endif
+#if defined(HAVE_OPTIMIZED_CODE)
+#  define PATH_MAX 50
+#else
 #ifndef PATH_MAX
 # ifdef _POSIX_PATH_MAX
 #  define PATH_MAX _POSIX_PATH_MAX
@@ -121,6 +128,7 @@
 #  define PATH_MAX 255
 # endif
 #endif
+#endif /* HAVE_OPTIMIZED_CODE */
 
 #ifndef FD_SET
 typedef long    fd_mask;
@@ -153,6 +161,20 @@
 #include <net-snmp/agent/table_iterator.h>
 #include "mib_module_includes.h"
 
+#include "ifx_common.h"
+#include "ifx_snmpdefs.h"
+
+//509141:tc.chen added start
+#include <ifx_config.h>
+#ifdef IFX_CONFIG_CPE_DSL_MIB
+#include "../apps/snmptrapd_handlers.h"
+//#include "../apps/notification_log.h"
+u_long          num_received = 0;
+int             SyslogTrap = 0;
+int             dropauth = 0;
+#endif
+//509141:tc.chen added end
+
 /*
  * Include winservice.h to support Windows Service
  */
@@ -190,7 +212,11 @@
 extern char    *argvrestart;
 extern char    *argvrestartname;
 
+#if defined(HAVE_OPTIMIZED_CODE)
+#define NUM_SOCKETS	8
+#else
 #define NUM_SOCKETS	32
+#endif
 
 #ifdef USING_SMUX_MODULE
 static int      sdlist[NUM_SOCKETS], sdlen = 0;
@@ -293,6 +319,11 @@
     printf("  \t\t\t  (followed by the startup parameter list)\n");
     printf("  \t\t\t  Note that not all parameters are relevant when running as a service\n");
 #endif
+//509141:tc.chen added start
+#ifdef IFX_CONFIG_CPE_DSL_MIB
+    printf("  -T TRAP_PORT\t\tuse TRAP_PORT instend of the default trap port 162 for trap demand\n");
+#endif
+//509141:tc.chen added end
 #if HAVE_UNISTD_H
     printf("  -u UID\t\tchange to this uid (numeric or textual) after\n"
 	   "\t\t\t  opening transport endpoints\n");
@@ -344,6 +375,8 @@
      */
     snmp_close(main_session);
 #endif
+    /* Remove the PID file */
+    ifx_rm_pid_file(SNMP_PID_FILE_PREFIX);
 }
 
 #ifdef SIGHUP
@@ -389,10 +422,13 @@
 	    strncpy(logfile_s, logfile, PATH_MAX);
 	}
 	dont_zero_s  = dont_zero;
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
 	stderr_log_s = stderr_log;
+#endif
 	syslog_log_s = syslog_log;
     }
 
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
     if (stderr_log_s) {
 	snmp_enable_stderrlog();
     } else {
@@ -402,12 +438,109 @@
     if (logfile_s[0]) {
 	snmp_enable_filelog(logfile_s, dont_zero_s);
     }
+#endif
 
     if (syslog_log_s) {
 	snmp_enable_syslog_ident("snmpd", Facility);
     }
 }
 
+//509141:tc.chen added start
+#ifdef IFX_CONFIG_CPE_DSL_MIB
+void
+event_input(netsnmp_variable_list * vp)
+{
+    int             eventid = 0;
+    oid             variable[MAX_OID_LEN];
+    int             variablelen = 0;
+    u_long          destip = 0;
+    int             sampletype = 0;
+    int             value = 0;
+    int             threshold = 0;
+    int             i;
+    int             nvars = 0;
+
+    netsnmp_variable_list       *vp2 = vp;
+
+    oid            *op = NULL;
+
+}
+
+
+static int
+pre_parse(netsnmp_session * session, netsnmp_transport *transport,
+          void *transport_data, int transport_data_length)
+{
+#if USE_LIBWRAP
+    char *addr_string = NULL;
+
+    if (transport != NULL && transport->f_fmtaddr != NULL) {
+        /*
+         * Okay I do know how to format this address for logging.
+         */
+        addr_string = transport->f_fmtaddr(transport, transport_data,
+                                           transport_data_length);
+        /*
+         * Don't forget to free() it.
+         */
+    }
+
+    if (addr_string != NULL) {
+        if (hosts_ctl("snmptrapd", STRING_UNKNOWN,
+                      addr_string, STRING_UNKNOWN) == 0) {
+            free(addr_string);
+            return 0;
+        }
+        free(addr_string);
+    } else {
+        if (hosts_ctl("snmptrapd", STRING_UNKNOWN,
+                      STRING_UNKNOWN, STRING_UNKNOWN) == 0) {
+            return 0;
+        }
+    }
+#endif/*  USE_LIBWRAP  */
+    return 1;
+}
+
+static netsnmp_session *
+snmptrapd_add_session(netsnmp_transport *t)
+{
+    netsnmp_session sess, *session = &sess, *rc = NULL;
+
+    snmp_sess_init(session);
+    session->peername = SNMP_DEFAULT_PEERNAME;  /* Original code had NULL here
+*/
+    session->version = SNMP_DEFAULT_VERSION;
+    session->community_len = SNMP_DEFAULT_COMMUNITY_LEN;
+    session->retries = SNMP_DEFAULT_RETRIES;
+    session->timeout = SNMP_DEFAULT_TIMEOUT;
+    session->callback = snmp_trapd_input;
+    session->callback_magic = (void *) t;
+    session->authenticator = NULL;
+    sess.isAuthoritative = SNMP_SESS_UNKNOWNAUTH;
+
+    rc = snmp_add(session, t, pre_parse, NULL);
+    if (rc == NULL) {
+        snmp_sess_perror("snmptrapd", session);
+    }
+    return rc;
+}
+  
+static void
+snmptrapd_close_sessions(netsnmp_session * sess_list)
+{
+    netsnmp_session *s = NULL, *next = NULL;
+
+    for (s = sess_list; s != NULL; s = next) {
+        next = s->next;
+        snmp_close(s);
+    }
+}
+
+int send_boottrap_signal=0;
+#endif
+//509141:tc.chen added end
+
 /*******************************************************************-o-******
  * main - Non Windows
  * SnmpDeamonMain - Windows to support windows serivce
@@ -431,7 +564,19 @@
 main(int argc, char *argv[])
 #endif
 {
+#if defined(HAVE_OPTIMIZED_CODE)
+#ifdef IFX_CONFIG_CPE_DSL_MIB //509141:tc.chen
+    char            options[] = "aAc:CdD::fhHI:l:L:m:M:p:P:qrsS:T:UvV-:"; //509141:tc.chen
+#else
+    char            options[] = "aAc:CdD::fhHI:l:L:m:M:p:P:qrsS:UvV-:";
+#endif
+#else
+#ifdef IFX_CONFIG_CPE_DSL_MIB //509141:tc.chen
+    char            options[128] = "aAc:CdD::fhHI:l:L:m:M:p:P:qrsS:T:UvV-:";//509141:tc.chen
+#else
     char            options[128] = "aAc:CdD::fhHI:l:L:m:M:p:P:qrsS:UvV-:";
+#endif
+#endif
     int             arg, i, ret;
     int             dont_fork = 0;
     int             dont_zero_log = 0;
@@ -446,6 +591,14 @@
     int fd;
     FILE           *PID;
 #endif
+//509141:tc.chen added start
+#ifdef IFX_CONFIG_CPE_DSL_MIB
+char           snmp_trapd_port[12]="udp:162";
+char           *cp;
+netsnmp_transport *transport = NULL;
+netsnmp_session *sess_list = NULL, *ss = NULL;
+#endif
+//509141:tc.chen added end
 
 #ifdef LOGFILE
     strncpy(logfile, LOGFILE, PATH_MAX);
@@ -506,10 +659,11 @@
             handle_long_opt(optarg);
             break;
 
+#if !defined(HAVE_OPTIMIZED_CODE)
         case 'a':
             log_addresses++;
             break;
-
+#endif
         case 'A':
             dont_zero_log = 1;
             break;
@@ -528,11 +682,13 @@
 				   NETSNMP_DS_LIB_DONT_READ_CONFIGS, 1);
             break;
 
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
         case 'd':
             snmp_set_dump_packet(++snmp_dump_packet);
             netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
 				   NETSNMP_DS_AGENT_VERBOSE, 1);
             break;
+#endif
 
         case 'D':
             debug_register_tokens(optarg);
@@ -626,9 +782,11 @@
             }
             break;
 
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
         case 'q':
             snmp_set_quick_print(1);
             break;
+#endif
 
         case 'r':
             netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID, 
@@ -685,7 +843,23 @@
                 usage(argv[0]);
             }
             break;
-
+//509141:tc.chen added start
+#ifdef IFX_CONFIG_CPE_DSL_MIB
+	case 'T':
+            if (optarg != NULL) {
+		if (atoi(optarg) <=0 || atoi(optarg) >65535)
+		{
+                	usage(argv[0]);
+		}else
+		{
+			sprintf(snmp_trapd_port,"udp:%d",atoi(optarg));
+		}
+            } else {
+                usage(argv[0]);
+            }
+	    break;
+#endif
+//509141:tc.chen added end
         case 'U':
             netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID, 
 				      NETSNMP_DS_AGENT_LEAVE_PIDFILE);
@@ -850,12 +1024,49 @@
      */
     init_snmp("snmpd");
 
+    /*
+     * Initialize the PID file for snmp daemon - IFX
+     */
+    ifx_create_pid_file(SNMP_PID_FILE_PREFIX);
+
     if ((ret = init_master_agent()) != 0) {
         /*
          * Some error opening one of the specified agent transports.  
          */
         Exit(1);                /*  Exit logs exit val for us  */
     }
+
+//509141:tc.chen added start
+#ifdef IFX_CONFIG_CPE_DSL_MIB
+    cp = snmp_trapd_port;
+    DEBUGMSGTL(("snmp_agent", "trapd final port spec: %s\n", snmp_trapd_port));
+    transport = netsnmp_tdomain_transport(cp, 1, "udp");
+    if (transport == NULL) {
+        snmp_log(LOG_ERR, "couldn't open %s -- errno %d (\"%s\")\n",
+            cp, errno, strerror(errno));
+        snmptrapd_close_sessions(sess_list);
+        SOCK_CLEANUP;
+        exit(1);
+    } else {
+        ss = snmptrapd_add_session(transport);
+        if (ss == NULL) {
+            /*
+             * Shouldn't happen?  We have already opened the transport
+             * successfully so what could have gone wrong?
+             */
+            snmptrapd_close_sessions(sess_list);
+            netsnmp_transport_free(transport);
+            snmp_log(LOG_ERR, "couldn't open snmp - %m");
+            SOCK_CLEANUP;
+            exit(1);
+        } else {
+            ss->next = sess_list;
+            sess_list = ss;
+        }
+    }
+#endif
+//509141:tc.chen added end
+
 #ifdef SIGTERM
     DEBUGMSGTL(("signal", "registering SIGTERM signal handler\n"));
     signal(SIGTERM, SnmpdShutDown);
@@ -877,6 +1088,12 @@
     signal(SIGPIPE, SIG_IGN);   /* 'Inline' failure of wayward readers */
 #endif
 
+#ifdef IFX_CONFIG_SNMPv3
+	IFX_create_usm_cmd_file_on_startup();
+	IFX_read_snmpv3_usm_cmd_file();	
+	kill(getpid(), SIGHUP); /* Send a HUP to recreate /var/net-snmp/snmpd.conf */
+#endif
+
     /*
      * Store persistent data immediately in case we crash later.  
      */
@@ -900,12 +1117,12 @@
             snmp_log_perror(pid_file);
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
                                         NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
-                exit(1);
+                Exit(1);
             }
         } else {
             if ((PID = fdopen(fd, "w")) == NULL) {
                 snmp_log_perror(pid_file);
-                exit(1);
+                Exit(1);
             } else {
                 fprintf(PID, "%d\n", (int) getpid());
                 fclose(PID);
@@ -928,7 +1145,7 @@
             snmp_log_perror("setgid failed");
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
-                exit(1);
+                Exit(1);
             }
         }
     }
@@ -941,7 +1158,7 @@
             snmp_log_perror("setuid failed");
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
-                exit(1);
+                Exit(1);
             }
         }
     }
@@ -955,7 +1172,10 @@
 #ifdef WIN32
     agent_status = AGENT_RUNNING;
 #endif
+
+#if !defined(HAVE_OPTIMIZED_CODE)
     netsnmp_addrcache_initialise();
+#endif
 
     /*
      * Forever monitor the dest_port for incoming PDUs.  
@@ -1038,11 +1258,20 @@
             snmp_log(LOG_INFO, "Reconfiguring daemon\n");
 	    /*  Stop and restart logging.  This allows logfiles to be
 		rotated etc.  */
+
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
 	    snmp_disable_log();
+#endif
 	    setup_log(1, 0, 0, 0, NULL);
 	    snmp_log(LOG_INFO, "NET-SNMP version %s restarted\n",
 		     netsnmp_get_version());
             update_config();
+#ifdef IFX_CONFIG_SNMPv3 
+			/* v3 user add/del support - IFX */
+			/* First read the config file to determine if anything needs to
+			 * be done. This is written to by our API. */
+			IFX_read_snmpv3_usm_cmd_file();	
+#endif /* IFX_CONFIG_SNMPv3 */
             send_easy_trap(SNMP_TRAP_ENTERPRISESPECIFIC, 3);
         }
 
@@ -1173,9 +1402,21 @@
                      * likely that we got a signal. Check our special signal
                      * flags before retrying select.
                      */
+#ifdef IFX_CONFIG_CPE_DSL_MIB //509141:tc.chen
+		    if (running && !reconfig && !send_boottrap_signal) {//509141:tc.chen
+#else
 		    if (running && !reconfig) {
+#endif
                         goto reselect;
 		    }
+//509141:tc.chen added start
+#ifdef IFX_CONFIG_CPE_DSL_MIB
+		    if (send_boottrap_signal)
+		    {
+			send_boottrap_signal=0;
+		    }
+#endif
+//509141:tc.chen added end
                     continue;
                 } else {
                     snmp_log_perror("select");
@@ -1208,9 +1449,11 @@
                 svp->tv_usec -= ONE_SEC;
                 svp->tv_sec++;
             }
+#if !defined(HAVE_OPTIMIZED_CODE)
             if (log_addresses && lastAddrAge++ > 600) {
                 netsnmp_addrcache_age();
             }
+#endif
         }
 
         /*
@@ -1371,3 +1614,102 @@
 }
 
 #endif/*WIN32*/
+
+#ifdef IFX_CONFIG_SNMPv3
+
+/* This function reads the user command from the cmd file and identifies 
+ * whether to add or delete the spcified user*/
+int IFX_read_snmpv3_usm_cmd_file(void)	
+{
+	FILE *fp = NULL;
+	char buf[MAX_LINE_LEN];
+	char *token, *ptr=NULL, *orgptr=NULL;
+	char *param[10];
+	int ret=-1;
+	int i=0;
+	int cmd=0;
+
+	fp = fopen(SNMPV3_USM_CMD_FILE, "r");
+
+	if (!fp)
+		goto lbl_exit;
+	while (!feof(fp)) {
+	memset(buf, '\0', sizeof(buf));
+	if (fgets(buf, sizeof(buf), fp)	== NULL) 
+		goto lbl_exit;
+
+	ptr=malloc(MAX_LINE_LEN);
+	if (!ptr) 
+		goto lbl_exit;
+
+	orgptr = ptr; /* store ptr for freeing */
+
+	token = strtok_r(buf, delimiters, &ptr);
+	if (token == NULL)
+		goto lbl_exit1;
+
+	if (!strcmp(token, SNMPV3_USM_CREATE_USER)) {
+		cmd = USM_CREATE_USER;
+	} else if (!strcmp(token, SNMPV3_USM_DELETE_USER)) {
+		cmd = USM_DELETE_USER;
+	} else {
+		goto lbl_exit1;
+	}
+
+	memset(param, '\0', sizeof(param));
+
+	/* read the params */
+	i=0;
+	while ((token = strtok_r(NULL, delimiters, &ptr)) != NULL) {
+		param[i]=token;
+		i++;
+		if (i > 9) {
+			break;
+		}
+	}
+
+	if (cmd == USM_CREATE_USER) {
+		/* createUser username rouser|rwuser MD5|SHA AuthPasswd DES|AES... AESPasswd */
+		if (strcmp(param[1], SNMP_ROUSER_STR) && strcmp(param[1], SNMP_RWUSER_STR)) {
+			goto lbl_exit1;
+		}
+                if ((param[2] != NULL) && (param[2][0] != '\0') 
+				&& strcmp(param[2], "MD5") && strcmp(param[2], "SHA")) {
+			goto lbl_exit1;
+	        }
+		if ((param[3] != NULL) && param[3][0] == '\0' 
+				&& param[2][0] != '\0') {
+			goto lbl_exit1; /* can't be empty authphrase */
+		}
+		if ((param[4] != NULL) && (param[4][0] != '\0') 
+				&& strcmp(param[4], "DES") && strcmp(param[4], "AES")) {
+			goto lbl_exit1;
+		}
+		ret = IFX_create_usmUser(param[0], param[1], param[2], param[3],
+			param[4], param[5], "snmpd");
+		
+	} else { /* DELETE_USER */
+		/* deleteUser username */
+		if (param[0] =='\0') {
+			goto lbl_exit1;
+		}
+		ret = IFX_delete_usmUser(param[0], "snmpd");
+	}
+
+	
+lbl_exit1:
+	free(orgptr);
+
+	} // !feof 
+
+lbl_exit:
+	if (fp) 
+		fclose(fp);
+
+	remove(SNMPV3_USM_CMD_FILE);
+	return (ret);
+
+}
+
+#endif /* IFX_CONFIG_SNMPv3 */
+
diff -Naur net-snmp-5.1/apps/ADSL-LINE-MIB.txt open_snmp/apps/ADSL-LINE-MIB.txt
--- net-snmp-5.1/apps/ADSL-LINE-MIB.txt	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/apps/ADSL-LINE-MIB.txt	2009-12-16 13:00:06.000000000 +0530
@@ -0,0 +1,4305 @@
+ADSL-LINE-MIB DEFINITIONS ::= BEGIN
+
+   IMPORTS
+       MODULE-IDENTITY, OBJECT-TYPE,
+       Counter32, Gauge32,
+       NOTIFICATION-TYPE,
+       transmission, Unsigned32          FROM SNMPv2-SMI
+       RowStatus,
+       TruthValue, VariablePointer       FROM SNMPv2-TC
+       MODULE-COMPLIANCE, OBJECT-GROUP,
+       NOTIFICATION-GROUP                FROM SNMPv2-CONF
+       ifIndex                           FROM IF-MIB
+       SnmpAdminString                   FROM SNMP-FRAMEWORK-MIB
+       AdslPerfCurrDayCount,
+       AdslPerfPrevDayCount,
+       AdslPerfTimeElapsed,
+       AdslLineCodingType                FROM ADSL-TC-MIB
+       ;
+
+   adslMIB MODULE-IDENTITY
+
+   LAST-UPDATED "9908190000Z"
+
+   ORGANIZATION "IETF ADSL MIB Working Group"
+
+   CONTACT-INFO
+       "
+       Gregory Bathrick
+       AG Communication Systems
+       A Subsidiary of Lucent Technologies
+       2500 W Utopia Rd.
+       Phoenix, AZ 85027 USA
+       Tel: +1 602-582-7679
+       Fax: +1 602-582-7697
+       E-mail: bathricg@agcs.com
+
+       Faye Ly
+       Copper Mountain Networks
+       Norcal Office
+       2470 Embarcadero Way
+       Palo Alto, CA 94303
+       Tel: +1 650-858-8500
+       Fax: +1 650-858-8085
+       E-Mail: faye@coppermountain.com
+
+       (ADSL Forum input only)
+       John Burgess
+       Predictive Systems, Inc.
+       25A Vreeland Rd.
+       Florham Park, NJ 07932 USA
+       Tel: +1 973-301-5610
+       Fax: +1 973-301-5699
+       E-mail: jtburgess@predictive.com
+
+       IETF ADSL MIB Working Group (adsl@xlist.agcs.com)
+       "
+
+   DESCRIPTION
+       "The MIB module defining objects for the management of a pair of
+       ADSL modems at each end of the ADSL line.  Each such line has
+       an entry in an ifTable which may include multiple modem lines.
+       An agent may reside at either end of the ADSL line however the
+       MIB is designed to require no management communication between
+       them beyond that inherent in the low-level ADSL line protocol.
+       The agent may monitor and control this protocol for its needs.
+
+       ADSL lines may support optional Fast or Interleaved channels.
+       If these are supported, additional entries corresponding to the
+       supported channels must be created in the ifTable. Thus an ADSL
+       line that supports both channels will have three entries in the
+       ifTable, one for each physical, fast, and interleaved, whose
+       ifType values are equal to adsl(94), fast(125), and
+       interleaved(124), respectively. The ifStackTable is used to
+       represent the relationship between the entries.
+
+       Naming Conventions:
+                 Atuc -- (ATUC) modem at near (Central) end of line
+                 Atur -- (ATUR) modem at Remote end of line
+                 Curr -- Current
+                 Prev -- Previous
+                 Atn -- Attenuation
+                 ES  -- Errored Second.
+                 LCS -- Line Code Specific
+                 Lof -- Loss of Frame
+                 Lol -- Loss of Link
+                 Los -- Loss of Signal
+                 Lpr -- Loss of Power
+                 xxxs-- interval of Seconds in which xxx occurs
+                         (e.g., xxx=Lof, Los, Lpr)
+                 Max -- Maximum
+                 Mgn -- Margin
+                 Min -- Minimum
+                 Psd -- Power Spectral Density
+                 Snr -- Signal to Noise Ratio
+                 Tx  -- Transmit
+                 Blks-- Blocks, a data unit, see
+                        adslAtuXChanCrcBlockLength
+         "
+         --  Revision history
+         REVISION     "9908190000Z"  -- 19 August 1999, midnight
+         DESCRIPTION  "Initial Version, published as RFC 2662"
+
+   ::= { transmission 94 }
+
+   adslLineMib OBJECT IDENTIFIER ::= { adslMIB 1 }
+
+   adslMibObjects OBJECT IDENTIFIER ::= { adslLineMib 1 }
+
+   -- objects
+         adslLineTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslLineEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table includes common attributes describing
+                 both ends of the line.  It is required for all ADSL
+                 physical interfaces.  ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 1 }
+
+         adslLineEntry   OBJECT-TYPE
+             SYNTAX          AdslLineEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in adslLineTable."
+             INDEX           { ifIndex }
+         ::= { adslLineTable 1 }
+
+         AdslLineEntry ::=
+             SEQUENCE {
+             adslLineCoding           AdslLineCodingType,
+             adslLineType             INTEGER,
+             adslLineSpecific         VariablePointer,
+             adslLineConfProfile      SnmpAdminString,
+             adslLineAlarmConfProfile SnmpAdminString
+             }
+
+         adslLineCoding OBJECT-TYPE
+             SYNTAX      AdslLineCodingType
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Specifies the ADSL coding type used on this
+                 line."
+         ::= { adslLineEntry 1 }
+
+        adslLineType OBJECT-TYPE
+             SYNTAX      INTEGER {
+                 noChannel (1),        -- no channels exist
+                 fastOnly (2),         -- fast channel exists only
+                 interleavedOnly (3),  -- interleaved channel exists
+                                       -- only
+                 fastOrInterleaved (4),-- either fast or interleaved
+                                       -- channels can exist, but
+                                       -- only one at any time
+                 fastAndInterleaved (5)-- both fast or interleaved
+                                       -- channels exist
+             }
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Defines the type of ADSL physical line
+                 entity that exists, by defining whether and how
+                 the line is channelized.  If the line is channelized,
+                 the value will be other than noChannel(1).  This
+                 object defines which channel type(s) are supported.
+
+                 In the case that the line is channelized, the manager
+                 can use the ifStackTable to determine the ifIndex for
+                 the associated channel(s)."
+         ::= { adslLineEntry 2 }
+
+         adslLineSpecific OBJECT-TYPE
+             SYNTAX      VariablePointer
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "OID instance in vendor-specific MIB. The Instance may
+                 be used to determine shelf/slot/port of the ATUC
+                 interface in a DSLAM."
+         ::= { adslLineEntry 3 }
+
+        adslLineConfProfile OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (1..32))
+             MAX-ACCESS  read-write
+             STATUS      current
+             DESCRIPTION
+                 "The value of this object identifies the row
+                 in the ADSL Line Configuration Profile Table,
+                 (adslLineConfProfileTable), which applies for this
+                 ADSL line, and channels if applicable.
+
+                 For `dynamic' mode, in the case which the
+                 configuration profile has not been set, the
+                 value will be set to `DEFVAL'.
+
+                 If the implementator of this MIB has chosen not
+                 to implement `dynamic assignment' of profiles, this
+                 object's MIN-ACCESS is read-only."
+         ::= { adslLineEntry 4 }
+
+        adslLineAlarmConfProfile OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (1..32))
+             MAX-ACCESS  read-write
+             STATUS      current
+             DESCRIPTION
+                 "The value of this object identifies the row
+                 in the ADSL Line Alarm Configuration Profile Table,
+                 (adslLineAlarmConfProfileTable), which applies to this
+                 ADSL line, and channels if applicable.
+
+                 For `dynamic' mode, in the case which the
+                 alarm profile has not been set, the
+                 value will be set to `DEFVAL'.
+
+                 If the implementator of this MIB has chosen not
+                 to implement `dynamic assignment' of profiles, this
+                 object's MIN-ACCESS is read-only."
+         ::= { adslLineEntry 5 }
+
+         adslAtucPhysTable       OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucPhysEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC.
+                 Each row contains the Physical Layer Parameters
+                 table for that ATUC. ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 2 }
+
+         adslAtucPhysEntry       OBJECT-TYPE
+             SYNTAX          AdslAtucPhysEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAtucPhysTable."
+             INDEX           { ifIndex }
+         ::= { adslAtucPhysTable 1 }
+
+         AdslAtucPhysEntry ::=
+             SEQUENCE {
+             adslAtucInvSerialNumber         SnmpAdminString,
+             adslAtucInvVendorID             SnmpAdminString,
+             adslAtucInvVersionNumber        SnmpAdminString,
+             adslAtucCurrSnrMgn              INTEGER,
+             adslAtucCurrAtn                 Gauge32,
+             adslAtucCurrStatus              BITS,
+             adslAtucCurrOutputPwr           INTEGER,
+             adslAtucCurrAttainableRate      Gauge32
+             }
+
+         -- inventory group
+         --
+         -- These items should describe the lowest level identifiable
+         -- component, be it a stand-alone modem, a card in a rack,
+         -- a child-board, etc.
+         --
+         adslAtucInvSerialNumber OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..32))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor specific string that identifies the
+                 vendor equipment."
+         ::= { adslAtucPhysEntry 1 }
+
+         adslAtucInvVendorID OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..16))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor ID code is a copy of the binary
+                 vendor identification field defined by the
+                 PHY[10] and expressed as readable characters."
+
+             REFERENCE "ANSI T1.413[10]"
+         ::= { adslAtucPhysEntry 2 }
+
+         adslAtucInvVersionNumber OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..16))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor specific version number sent by this ATU
+                 as part of the initialization messages.  It is a copy
+                 of the binary version number field defined by the
+                 PHY[10] and expressed as readable characters."
+             REFERENCE "ANSI T1.413[10]"
+         ::= { adslAtucPhysEntry 3 }
+
+         -- current status group
+         --
+         adslAtucCurrSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (-640..640)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Noise Margin as seen by this ATU with respect to its
+                 received signal in tenth dB."
+         ::= { adslAtucPhysEntry 4 }
+
+         adslAtucCurrAtn OBJECT-TYPE
+             SYNTAX      Gauge32(0..630)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Measured difference in the total power transmitted by
+                 the peer ATU and the total power received by this ATU."
+         ::= { adslAtucPhysEntry 5 }
+
+        adslAtucCurrStatus OBJECT-TYPE
+             SYNTAX      BITS {
+                               noDefect(0),
+                               lossOfFraming(1),
+                               lossOfSignal(2),
+                               lossOfPower(3),
+                               lossOfSignalQuality(4),
+                               lossOfLink(5),
+                               dataInitFailure(6),
+                               configInitFailure(7),
+                               protocolInitFailure(8),
+                               noPeerAtuPresent(9)
+                              }
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates current state of the ATUC line.  This is a
+                 bit-map of possible conditions.  The various bit
+                 positions are:
+
+          0      noDefect             There no defects on the line
+
+          1      lossOfFraming        ATUC failure due to not
+                                      receiving valid frame.
+
+          2      lossOfSignal         ATUC failure due to not
+                                      receiving signal.
+
+          3      lossOfPower          ATUC failure due to loss of
+                                      power.
+                                      Note: the Agent may still
+                                      function.
+
+          4      lossOfSignalQuality  Loss of Signal Quality is
+                                      declared when the Noise Margin
+                                      falls below the Minimum Noise
+                                      Margin, or the bit-error-rate
+                                      exceeds 10^-7.
+
+          5      lossOfLink           ATUC failure due to inability
+                                      to link with ATUR.
+
+          6      dataInitFailure      ATUC failure during
+                                      initialization due to bit
+                                      errors corrupting startup
+                                      exchange data.
+
+          7      configInitFailure    ATUC failure during
+                                      initialization due to peer
+                                      ATU not able to support
+                                      requested configuration
+
+          8      protocolInitFailure  ATUC failure during
+                                      initialization due to
+                                      incompatible protocol used by
+                                      the peer ATU.
+
+          9      noPeerAtuPresent     ATUC failure during
+                                      initialization due to no
+                                      activation sequence detected
+                                      from peer ATU.
+
+                 This is intended to supplement ifOperStatus."
+         ::= { adslAtucPhysEntry 6 }
+
+         adslAtucCurrOutputPwr OBJECT-TYPE
+             SYNTAX      INTEGER (-310..310)
+             UNITS       "tenth dBm"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Measured total output power transmitted by this ATU.
+                 This is the measurement that was reported during
+                 the last activation sequence."
+         ::= { adslAtucPhysEntry 7 }
+
+         adslAtucCurrAttainableRate OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates the maximum currently attainable data rate
+                 by the ATU.  This value will be equal or greater than
+                 the current line rate."
+         ::= { adslAtucPhysEntry 8 }
+
+         adslAturPhysTable        OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturPhysEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR
+                 Each row contains the Physical Layer Parameters
+                 table for that ATUR. ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 3 }
+
+         adslAturPhysEntry       OBJECT-TYPE
+             SYNTAX          AdslAturPhysEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAturPhysTable."
+             INDEX           { ifIndex }
+         ::= { adslAturPhysTable 1 }
+
+         AdslAturPhysEntry ::=
+             SEQUENCE {
+             adslAturInvSerialNumber         SnmpAdminString,
+             adslAturInvVendorID             SnmpAdminString,
+             adslAturInvVersionNumber        SnmpAdminString,
+             adslAturCurrSnrMgn              INTEGER,
+             adslAturCurrAtn                 Gauge32,
+             adslAturCurrStatus              BITS,
+             adslAturCurrOutputPwr           INTEGER,
+             adslAturCurrAttainableRate      Gauge32
+             }
+
+         -- inventory group
+         --
+         adslAturInvSerialNumber OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..32))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor specific string that identifies the
+                 vendor equipment."
+         ::= { adslAturPhysEntry 1 }
+
+         adslAturInvVendorID OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..16))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor ID code is a copy of the binary
+                 vendor identification field defined by the
+                 PHY[10] and expressed as readable characters."
+             REFERENCE "ANSI T1.413"
+         ::= { adslAturPhysEntry 2 }
+
+         adslAturInvVersionNumber OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..16))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor specific version number sent by this ATU
+                 as part of the initialization messages.  It is a copy
+                 of the binary version number field defined by the
+                 PHY[10] and expressed as readable characters."
+             REFERENCE "ANSI T1.413"
+         ::= { adslAturPhysEntry 3 }
+
+         -- current status group
+         --
+         adslAturCurrSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (-640..640)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Noise Margin as seen by this ATU with respect to its
+                 received signal in tenth dB."
+         ::= { adslAturPhysEntry 4 }
+
+         adslAturCurrAtn OBJECT-TYPE
+             SYNTAX      Gauge32(0..630)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Measured difference in the total power transmitted by
+                 the peer ATU and the total power received by this ATU."
+         ::= { adslAturPhysEntry 5 }
+
+        adslAturCurrStatus OBJECT-TYPE
+             SYNTAX     BITS {
+                              noDefect(0),
+                              lossOfFraming(1),
+                              lossOfSignal(2),
+                              lossOfPower(3),
+                              lossOfSignalQuality(4)
+                             }
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates current state of the ATUR line.  This is a
+                 bit-map of possible conditions.  Due to the isolation
+                 of the ATUR when line problems occur, many state
+                 conditions like loss of power, loss of quality signal,
+                 and initialization errors,  can not be determined.
+                 While trouble shooting ATUR, also use object,
+                 adslAtucCurrStatus.  The various bit positions are:
+
+          0      noDefect             There no defects on the line
+
+          1      lossOfFraming        ATUR failure due to not
+                                      receiving valid frame
+
+          2      lossOfSignal         ATUR failure due to not
+                                      receiving signal
+
+          3      lossOfPower          ATUR failure due to loss of
+                                      power
+
+          4      lossOfSignalQuality  Loss of Signal Quality is
+                                      declared when the Noise Margin
+                                      falls below the Minimum Noise
+                                      Margin, or the
+                                      bit-error-rate exceeds 10^-7.
+
+                 This is intended to supplement ifOperStatus."
+         ::= { adslAturPhysEntry 6 }
+
+         adslAturCurrOutputPwr OBJECT-TYPE
+             SYNTAX      INTEGER (-310..310)
+             UNITS       "tenth dBm"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Measured total output power transmitted by this ATU.
+                 This is the measurement that was reported during
+                 the last activation sequence."
+         ::= { adslAturPhysEntry 7 }
+
+         adslAturCurrAttainableRate OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates the maximum currently attainable data rate
+                 by the ATU.  This value will be equal or greater than
+                 the current line rate."
+         ::= { adslAturPhysEntry 8 }
+
+         adslAtucChanTable       OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucChanEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC channel.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 4 }
+
+         adslAtucChanEntry       OBJECT-TYPE
+             SYNTAX          AdslAtucChanEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAtucChanTable."
+             INDEX           { ifIndex }
+         ::= { adslAtucChanTable 1 }
+
+         AdslAtucChanEntry ::=
+             SEQUENCE {
+             adslAtucChanInterleaveDelay     Gauge32,
+             adslAtucChanCurrTxRate          Gauge32,
+             adslAtucChanPrevTxRate          Gauge32,
+             adslAtucChanCrcBlockLength      Gauge32
+             }
+
+         -- current group
+         --
+         adslAtucChanInterleaveDelay OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "milli-seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Interleave Delay for this channel.
+
+                 Interleave delay applies only to the
+                 interleave channel and defines the mapping
+                 (relative spacing) between subsequent input
+                 bytes at the interleaver input and their placement
+                 in the bit stream at the interleaver output.
+                 Larger numbers provide greater separation between
+                 consecutive input bytes in the output bit stream
+                 allowing for improved impulse noise immunity at
+                 the expense of payload latency.
+
+                 In the case where the ifType is Fast(125), use
+                 noSuchObject."
+         ::= { adslAtucChanEntry 1 }
+
+         adslAtucChanCurrTxRate  OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Actual transmit rate on this channel."
+         ::= { adslAtucChanEntry 2 }
+
+         adslAtucChanPrevTxRate OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS        "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The rate at the time of the last
+                 adslAtucRateChangeTrap event. It is also set at
+                 initialization to prevent a trap being sent.
+
+                 Rate changes less than adslAtucThresh(*)RateDown
+                 or less than adslAtucThresh(*)RateUp will not
+                 cause a trap or cause this object to change.
+                 (*) == Fast or Interleave.
+                 See AdslLineAlarmConfProfileEntry."
+         ::= { adslAtucChanEntry 3 }
+
+         adslAtucChanCrcBlockLength OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS        "byte"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates the length of the channel data-block
+                 on which the CRC operates.  Refer to Line Code
+                 Specific MIBs, [11] and [12] for more
+                 information."
+         ::= { adslAtucChanEntry 4 }
+
+        adslAturChanTable       OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturChanEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR channel.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 5 }
+
+         adslAturChanEntry       OBJECT-TYPE
+             SYNTAX          AdslAturChanEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAturChanTable."
+             INDEX           { ifIndex }
+         ::= { adslAturChanTable 1 }
+
+         AdslAturChanEntry ::=
+             SEQUENCE {
+             adslAturChanInterleaveDelay     Gauge32,
+             adslAturChanCurrTxRate          Gauge32,
+             adslAturChanPrevTxRate          Gauge32,
+             adslAturChanCrcBlockLength      Gauge32
+             }
+
+         -- current group
+         --
+         adslAturChanInterleaveDelay OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "milli-seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Interleave Delay for this channel.
+
+                 Interleave delay applies only to the
+                 interleave channel and defines the mapping
+                 (relative spacing) between subsequent input
+                 bytes at the interleaver input and their placement
+                 in the bit stream at the interleaver output.
+                 Larger numbers provide greater separation between
+                 consecutive input bytes in the output bit stream
+                 allowing for improved impulse noise immunity at
+                 the expense of payload latency.
+
+                 In the case where the ifType is Fast(125), use
+                 noSuchObject."
+         ::= { adslAturChanEntry 1 }
+
+         adslAturChanCurrTxRate  OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Actual transmit rate on this channel."
+         ::= { adslAturChanEntry 2 }
+
+         adslAturChanPrevTxRate OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                "The rate at the time of the last
+                 adslAturRateChangeTrap event. It is also set at
+                 initialization to prevent a trap being sent.
+                 Rate changes less than adslAturThresh(*)RateDown
+                 or less than adslAturThresh(*)RateUp will not
+                 cause a trap or cause this object to change.
+                 (*) == Fast or Interleave.
+                 See AdslLineAlarmConfProfileEntry."
+         ::= { adslAturChanEntry 3 }
+
+         adslAturChanCrcBlockLength OBJECT-TYPE
+             SYNTAX      Gauge32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates the length of the channel data-block
+                 on which the CRC operates.  Refer to Line Code
+                 Specific MIBs, [11] and [12] for more
+                 information."
+         ::= { adslAturChanEntry 4 }
+
+         adslAtucPerfDataTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC.
+                 ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 6 }
+         adslAtucPerfDataEntry       OBJECT-TYPE
+             SYNTAX          AdslAtucPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in adslAtucPerfDataTable."
+             INDEX           { ifIndex }
+         ::= { adslAtucPerfDataTable 1 }
+
+         AdslAtucPerfDataEntry ::=
+             SEQUENCE {
+             adslAtucPerfLofs                 Counter32,
+             adslAtucPerfLoss                 Counter32,
+             adslAtucPerfLols                 Counter32,
+             adslAtucPerfLprs                 Counter32,
+             adslAtucPerfESs                  Counter32,
+             adslAtucPerfInits                Counter32,
+             adslAtucPerfValidIntervals       INTEGER,
+             adslAtucPerfInvalidIntervals     INTEGER,
+             adslAtucPerfCurr15MinTimeElapsed AdslPerfTimeElapsed,
+             adslAtucPerfCurr15MinLofs        PerfCurrentCount,
+             adslAtucPerfCurr15MinLoss        PerfCurrentCount,
+             adslAtucPerfCurr15MinLols        PerfCurrentCount,
+             adslAtucPerfCurr15MinLprs        PerfCurrentCount,
+             adslAtucPerfCurr15MinESs         PerfCurrentCount,
+             adslAtucPerfCurr15MinInits       PerfCurrentCount,
+             adslAtucPerfCurr1DayTimeElapsed  AdslPerfTimeElapsed,
+             adslAtucPerfCurr1DayLofs         AdslPerfCurrDayCount,
+             adslAtucPerfCurr1DayLoss         AdslPerfCurrDayCount,
+             adslAtucPerfCurr1DayLols         AdslPerfCurrDayCount,
+             adslAtucPerfCurr1DayLprs         AdslPerfCurrDayCount,
+             adslAtucPerfCurr1DayESs          AdslPerfCurrDayCount,
+             adslAtucPerfCurr1DayInits        AdslPerfCurrDayCount,
+             adslAtucPerfPrev1DayMoniSecs     INTEGER,
+             adslAtucPerfPrev1DayLofs         AdslPerfPrevDayCount,
+             adslAtucPerfPrev1DayLoss         AdslPerfPrevDayCount,
+             adslAtucPerfPrev1DayLols         AdslPerfPrevDayCount,
+             adslAtucPerfPrev1DayLprs         AdslPerfPrevDayCount,
+             adslAtucPerfPrev1DayESs          AdslPerfPrevDayCount,
+             adslAtucPerfPrev1DayInits        AdslPerfPrevDayCount
+             }
+
+         -- Event Counters
+         --
+         -- Also see adslAtucIntervalTable for 15 minute interval
+         -- elapsed counters.
+         --
+         adslAtucPerfLofs OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Framing failures since
+                 agent reset."
+         ::= { adslAtucPerfDataEntry 1 }
+
+         adslAtucPerfLoss  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Signal failures since
+                 agent reset."
+         ::= { adslAtucPerfDataEntry 2 }
+
+         adslAtucPerfLols OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Link failures since
+                 agent reset."
+         ::= { adslAtucPerfDataEntry 3 }
+
+         adslAtucPerfLprs OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Power failures since
+                 agent reset."
+         ::= { adslAtucPerfDataEntry 4 }
+
+         adslAtucPerfESs OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Errored Seconds since agent
+                 reset.  The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAtucPerfDataEntry 5 }
+
+         adslAtucPerfInits OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the line initialization attempts since
+                 agent reset. Includes both successful and failed
+                 attempts."
+         ::= { adslAtucPerfDataEntry 6 }
+
+         -- general 15 min interval information
+         --
+
+         adslAtucPerfValidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of previous 15-minute intervals in the
+                 interval table for which data was collected.  Given
+                 that <n> is the maximum # of intervals supported.
+                 The value will be <n> unless the measurement was
+                 (re-)started within the last (<n>*15) minutes, in which
+                 case the value will be the number of complete 15
+                 minute intervals for which the agent has at least
+                 some data. In certain cases (e.g., in the case
+                 where the agent is a proxy) it is possible that some
+                 intervals are unavailable.  In this case, this
+                 interval is the maximum interval number for
+                 which data is available."
+         ::= { adslAtucPerfDataEntry 7 }
+
+         adslAtucPerfInvalidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of intervals in the range from
+                 0 to the value of adslAtucPerfValidIntervals
+                 for which no data is available. This object
+                 will typically be zero except in cases where
+                 the data for some intervals are not available
+                 (e.g., in proxy situations)."
+         ::= { adslAtucPerfDataEntry 8 }
+
+         -- 15 min current performance group
+         --
+         adslAtucPerfCurr15MinTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..899)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Total elapsed seconds in this interval."
+         ::= { adslAtucPerfDataEntry 9 }
+
+         adslAtucPerfCurr15MinLofs OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Framing."
+         ::= { adslAtucPerfDataEntry 10 }
+
+         adslAtucPerfCurr15MinLoss  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Signal."
+         ::= { adslAtucPerfDataEntry 11 }
+
+         adslAtucPerfCurr15MinLols  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Link."
+         ::= { adslAtucPerfDataEntry 12 }
+
+         adslAtucPerfCurr15MinLprs  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Power."
+         ::= { adslAtucPerfDataEntry 13 }
+
+         adslAtucPerfCurr15MinESs OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds in the current 15 minute
+                 interval.  The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAtucPerfDataEntry 14 }
+
+         adslAtucPerfCurr15MinInits  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the line initialization attempts in the
+                 current 15 minute interval. Includes both successful
+                 and failed attempts."
+         ::= { adslAtucPerfDataEntry 15 }
+
+         -- 1-day current and previous performance group
+         --
+         adslAtucPerfCurr1DayTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..86399)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Number of seconds that have elapsed since the
+                 beginning of the current 1-day interval."
+         ::= { adslAtucPerfDataEntry 16 }
+
+         adslAtucPerfCurr1DayLofs  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss of
+                 Framing during the current day as measured by
+                 adslAtucPerfCurr1DayTimeElapsed."
+         ::= { adslAtucPerfDataEntry 17 }
+
+         adslAtucPerfCurr1DayLoss  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss of
+                 Signal during the current day as measured by
+                 adslAtucPerfCurr1DayTimeElapsed."
+         ::= { adslAtucPerfDataEntry 18 }
+
+         adslAtucPerfCurr1DayLols  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss of
+                 Link during the current day as measured by
+                 adslAtucPerfCurr1DayTimeElapsed."
+         ::= { adslAtucPerfDataEntry 19 }
+
+         adslAtucPerfCurr1DayLprs  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss of
+                 Power during the current day as measured by
+                 adslAtucPerfCurr1DayTimeElapsed."
+         ::= { adslAtucPerfDataEntry 20 }
+
+         adslAtucPerfCurr1DayESs OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds during the current day as
+                 measured by adslAtucPerfCurr1DayTimeElapsed.
+                 The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAtucPerfDataEntry 21 }
+
+         adslAtucPerfCurr1DayInits  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the line initialization attempts in the
+                 day as measured by adslAtucPerfCurr1DayTimeElapsed.
+                 Includes both successful and failed attempts."
+         ::= { adslAtucPerfDataEntry 22 }
+
+         adslAtucPerfPrev1DayMoniSecs OBJECT-TYPE
+             SYNTAX      INTEGER(0..86400)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The amount of time in the previous 1-day interval
+                 over which the performance monitoring information
+                 is actually counted. This value will be the same as
+                 the interval duration except in a situation where
+                 performance monitoring data could not be collected
+                 for any reason."
+         ::= { adslAtucPerfDataEntry 23 }
+
+         adslAtucPerfPrev1DayLofs  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Framing within the most recent previous
+                 1-day period."
+         ::= { adslAtucPerfDataEntry 24 }
+
+         adslAtucPerfPrev1DayLoss  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Signal within the most recent previous
+                 1-day period."
+         ::= { adslAtucPerfDataEntry 25 }
+
+         adslAtucPerfPrev1DayLols  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Link within the most recent previous
+                 1-day period."
+         ::= { adslAtucPerfDataEntry 26 }
+         adslAtucPerfPrev1DayLprs  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Power within the most recent previous
+                 1-day period."
+         ::= { adslAtucPerfDataEntry 27 }
+
+         adslAtucPerfPrev1DayESs OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds within the most recent
+                 previous 1-day period. The errored second parameter is
+                 a count of one-second intervals containing one or more
+                 crc anomalies, or one or more los or sef defects."
+         ::= { adslAtucPerfDataEntry 28 }
+
+         adslAtucPerfPrev1DayInits  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the line initialization attempts in the most
+                 recent previous 1-day period. Includes both successful
+                 and failed attempts."
+         ::= { adslAtucPerfDataEntry 29 }
+
+         adslAturPerfDataTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR.
+                 ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 7 }
+
+         adslAturPerfDataEntry       OBJECT-TYPE
+             SYNTAX          AdslAturPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in adslAturPerfDataTable."
+             INDEX           { ifIndex }
+         ::= { adslAturPerfDataTable 1 }
+
+         AdslAturPerfDataEntry ::=
+             SEQUENCE {
+             adslAturPerfLofs                 Counter32,
+             adslAturPerfLoss                 Counter32,
+             adslAturPerfLprs                 Counter32,
+             adslAturPerfESs                  Counter32,
+             adslAturPerfValidIntervals       INTEGER,
+             adslAturPerfInvalidIntervals     INTEGER,
+             adslAturPerfCurr15MinTimeElapsed AdslPerfTimeElapsed,
+             adslAturPerfCurr15MinLofs        PerfCurrentCount,
+             adslAturPerfCurr15MinLoss        PerfCurrentCount,
+             adslAturPerfCurr15MinLprs        PerfCurrentCount,
+             adslAturPerfCurr15MinESs         PerfCurrentCount,
+             adslAturPerfCurr1DayTimeElapsed  AdslPerfTimeElapsed,
+             adslAturPerfCurr1DayLofs         AdslPerfCurrDayCount,
+             adslAturPerfCurr1DayLoss         AdslPerfCurrDayCount,
+             adslAturPerfCurr1DayLprs         AdslPerfCurrDayCount,
+             adslAturPerfCurr1DayESs          AdslPerfCurrDayCount,
+             adslAturPerfPrev1DayMoniSecs     INTEGER,
+             adslAturPerfPrev1DayLofs         AdslPerfPrevDayCount,
+             adslAturPerfPrev1DayLoss         AdslPerfPrevDayCount,
+             adslAturPerfPrev1DayLprs         AdslPerfPrevDayCount,
+             adslAturPerfPrev1DayESs          AdslPerfPrevDayCount
+             }
+
+         -- Event (Raw) Counters
+         --
+         -- Also see adslAturIntervalTable for 15 minute interval
+         -- elapsed counters.
+         --
+         adslAturPerfLofs OBJECT-TYPE
+             SYNTAX      Counter32
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Framing failures since
+                 agent reset."
+         ::= { adslAturPerfDataEntry 1 }
+
+         adslAturPerfLoss  OBJECT-TYPE
+             SYNTAX      Counter32
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Signal failures since
+                 agent reset."
+         ::= { adslAturPerfDataEntry 2 }
+
+        adslAturPerfLprs  OBJECT-TYPE
+             SYNTAX      Counter32
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Power failures since
+                 agent reset."
+         ::= { adslAturPerfDataEntry 3 }
+
+         adslAturPerfESs  OBJECT-TYPE
+             SYNTAX      Counter32
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Errored Seconds since agent
+                 reset.  The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAturPerfDataEntry 4 }
+
+         -- general 15 min interval information
+         --
+         adslAturPerfValidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of previous 15-minute intervals in the
+                 interval table for which data was collected.  Given
+                 that <n> is the maximum # of intervals supported.
+                 The value will be <n> unless the measurement was
+                 (re-)started within the last (<n>*15) minutes, in which
+                 case the value will be the number of complete 15
+                 minute intervals for which the agent has at least
+                 some data. In certain cases (e.g., in the case
+                 where the agent is a proxy) it is possible that some
+                 intervals are unavailable.  In this case, this
+                 interval is the maximum interval number for
+                 which data is available."
+         ::= { adslAturPerfDataEntry 5 }
+
+         adslAturPerfInvalidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of intervals in the range from
+                 0 to the value of adslAturPerfValidIntervals
+                 for which no data is available. This object
+                 will typically be zero except in cases where
+                 the data for some intervals are not available
+                 (e.g., in proxy situations)."
+         ::= { adslAturPerfDataEntry 6 }
+
+         -- 15 min current performance group
+         --
+         adslAturPerfCurr15MinTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..899)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Total elapsed seconds in this interval."
+         ::= { adslAturPerfDataEntry 7 }
+
+         adslAturPerfCurr15MinLofs OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Framing."
+         ::= { adslAturPerfDataEntry 8 }
+
+         adslAturPerfCurr15MinLoss  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Signal."
+         ::= { adslAturPerfDataEntry 9 }
+
+         adslAturPerfCurr15MinLprs  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Power."
+         ::= { adslAturPerfDataEntry 10 }
+
+         adslAturPerfCurr15MinESs OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                "Count of Errored Seconds in the current 15 minute
+                interval.  The errored second parameter is a count of
+                one-second intervals containing one or more crc
+                anomalies, or one or more los or sef defects."
+
+         ::= { adslAturPerfDataEntry 11 }
+
+         -- 1-day current and previous performance group
+         --
+         adslAturPerfCurr1DayTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..86399)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Number of seconds that have elapsed since the
+                 beginning of the current 1-day interval."
+         ::= { adslAturPerfDataEntry 12 }
+
+         adslAturPerfCurr1DayLofs  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss
+                 of Framing during the current day as measured by
+                 adslAturPerfCurr1DayTimeElapsed."
+         ::= { adslAturPerfDataEntry 13 }
+
+         adslAturPerfCurr1DayLoss  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss
+                 of Signal during the current day as measured by
+                 adslAturPerfCurr1DayTimeElapsed."
+         ::= { adslAturPerfDataEntry 14 }
+
+         adslAturPerfCurr1DayLprs  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss
+                 of Power during the current day as measured by
+                 adslAturPerfCurr1DayTimeElapsed."
+         ::= { adslAturPerfDataEntry 15 }
+
+    adslAturPerfCurr1DayESs OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds during the current day as
+                 measured by adslAturPerfCurr1DayTimeElapsed.
+                 The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAturPerfDataEntry 16 }
+
+         adslAturPerfPrev1DayMoniSecs OBJECT-TYPE
+             SYNTAX      INTEGER(0..86400)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The amount of time in the previous 1-day interval
+                 over which the performance monitoring information
+                 is actually counted. This value will be the same as
+                 the interval duration except in a situation where
+                 performance monitoring data could not be collected
+                 for any reason."
+         ::= { adslAturPerfDataEntry 17 }
+
+         adslAturPerfPrev1DayLofs  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Framing within the most recent previous
+                 1-day period."
+         ::= { adslAturPerfDataEntry 18 }
+
+         adslAturPerfPrev1DayLoss  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Signal within the most recent previous
+                 1-day period."
+         ::= { adslAturPerfDataEntry 19 }
+
+         adslAturPerfPrev1DayLprs  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Power within the most recent previous
+                 1-day period."
+         ::= { adslAturPerfDataEntry 20 }
+
+         adslAturPerfPrev1DayESs OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds within the most recent
+                 previous 1-day period. The errored second parameter is
+                 a count of one-second intervals containing one or more
+                 crc anomalies, or one or more los or sef defects."
+         ::= { adslAturPerfDataEntry 21 }
+
+         adslAtucIntervalTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC
+                 performance data collection interval.
+                 ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 8 }
+
+         adslAtucIntervalEntry   OBJECT-TYPE
+             SYNTAX          AdslAtucIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAtucIntervalTable."
+             INDEX           { ifIndex, adslAtucIntervalNumber }
+         ::= { adslAtucIntervalTable 1 }
+
+         AdslAtucIntervalEntry ::=
+             SEQUENCE {
+             adslAtucIntervalNumber          INTEGER,
+             adslAtucIntervalLofs            PerfIntervalCount,
+             adslAtucIntervalLoss            PerfIntervalCount,
+             adslAtucIntervalLols            PerfIntervalCount,
+             adslAtucIntervalLprs            PerfIntervalCount,
+             adslAtucIntervalESs             PerfIntervalCount,
+             adslAtucIntervalInits           PerfIntervalCount,
+             adslAtucIntervalValidData       TruthValue
+             }
+
+         adslAtucIntervalNumber OBJECT-TYPE
+             SYNTAX      INTEGER(1..96)
+             MAX-ACCESS  not-accessible
+             STATUS      current
+             DESCRIPTION
+                 "Performance Data Interval number 1 is the
+                 the most recent previous interval; interval
+                 96 is 24 hours ago.  Intervals 2..96 are
+                 optional."
+         ::= { adslAtucIntervalEntry 1 }
+
+         adslAtucIntervalLofs OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was Loss
+                 of Framing."
+         ::= { adslAtucIntervalEntry 2 }
+
+         adslAtucIntervalLoss  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was Loss
+                 of Signal."
+         ::= { adslAtucIntervalEntry 3 }
+
+         adslAtucIntervalLols  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was Loss
+                 of Link."
+         ::= { adslAtucIntervalEntry 4 }
+
+         adslAtucIntervalLprs  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was Loss
+                 of Power."
+         ::= { adslAtucIntervalEntry 5 }
+
+         adslAtucIntervalESs OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds in the interval.
+                 The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAtucIntervalEntry 6 }
+
+         adslAtucIntervalInits  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the line initialization attempts
+                 during the interval. Includes both successful
+                 and failed attempts."
+         ::= { adslAtucIntervalEntry 7 }
+
+         adslAtucIntervalValidData OBJECT-TYPE
+             SYNTAX TruthValue
+             MAX-ACCESS read-only
+             STATUS current
+             DESCRIPTION
+                 "This variable indicates if the data for this
+                 interval is valid."
+         ::= { adslAtucIntervalEntry 8 }
+
+         adslAturIntervalTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR
+                 performance data collection interval.
+                 ADSL physical interfaces are those
+                 ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 9 }
+
+         adslAturIntervalEntry   OBJECT-TYPE
+             SYNTAX          AdslAturIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAturIntervalTable."
+             INDEX           { ifIndex, adslAturIntervalNumber }
+         ::= { adslAturIntervalTable 1 }
+
+         AdslAturIntervalEntry ::=
+             SEQUENCE {
+             adslAturIntervalNumber          INTEGER,
+             adslAturIntervalLofs            PerfIntervalCount,
+             adslAturIntervalLoss            PerfIntervalCount,
+             adslAturIntervalLprs            PerfIntervalCount,
+             adslAturIntervalESs             PerfIntervalCount,
+             adslAturIntervalValidData       TruthValue
+             }
+
+         adslAturIntervalNumber OBJECT-TYPE
+             SYNTAX      INTEGER(1..96)
+             MAX-ACCESS  not-accessible
+             STATUS      current
+             DESCRIPTION
+                 "Performance Data Interval number 1 is the
+                 the most recent previous interval; interval
+                 96 is 24 hours ago.  Intervals 2..96 are
+                 optional."
+         ::= { adslAturIntervalEntry 1 }
+         adslAturIntervalLofs OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Framing."
+         ::= { adslAturIntervalEntry 2 }
+
+         adslAturIntervalLoss  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Signal."
+         ::= { adslAturIntervalEntry 3 }
+
+         adslAturIntervalLprs  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Power."
+         ::= { adslAturIntervalEntry 4 }
+
+         adslAturIntervalESs OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds in the interval.
+                 The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAturIntervalEntry 5 }
+
+         adslAturIntervalValidData OBJECT-TYPE
+             SYNTAX TruthValue
+             MAX-ACCESS read-only
+             STATUS current
+             DESCRIPTION
+                 "This variable indicates if the data for this
+                 interval is valid."
+         ::= { adslAturIntervalEntry 6 }
+
+         adslAtucChanPerfDataTable       OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucChanPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC channel.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 10 }
+
+         adslAtucChanPerfDataEntry       OBJECT-TYPE
+
+             SYNTAX          AdslAtucChanPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in adslAtucChanPerfDataTable."
+             INDEX           { ifIndex }
+         ::= { adslAtucChanPerfDataTable 1 }
+
+         AdslAtucChanPerfDataEntry ::=
+          SEQUENCE {
+          adslAtucChanReceivedBlks                 Counter32,
+          adslAtucChanTransmittedBlks              Counter32,
+          adslAtucChanCorrectedBlks                Counter32,
+          adslAtucChanUncorrectBlks                Counter32,
+          adslAtucChanPerfValidIntervals           INTEGER,
+          adslAtucChanPerfInvalidIntervals         INTEGER,
+          adslAtucChanPerfCurr15MinTimeElapsed     AdslPerfTimeElapsed,
+          adslAtucChanPerfCurr15MinReceivedBlks    PerfCurrentCount,
+          adslAtucChanPerfCurr15MinTransmittedBlks PerfCurrentCount,
+          adslAtucChanPerfCurr15MinCorrectedBlks   PerfCurrentCount,
+          adslAtucChanPerfCurr15MinUncorrectBlks   PerfCurrentCount,
+          adslAtucChanPerfCurr1DayTimeElapsed      AdslPerfTimeElapsed,
+          adslAtucChanPerfCurr1DayReceivedBlks     AdslPerfCurrDayCount,
+          adslAtucChanPerfCurr1DayTransmittedBlks  AdslPerfCurrDayCount,
+          adslAtucChanPerfCurr1DayCorrectedBlks    AdslPerfCurrDayCount,
+          adslAtucChanPerfCurr1DayUncorrectBlks    AdslPerfCurrDayCount,
+          adslAtucChanPerfPrev1DayMoniSecs         INTEGER,
+          adslAtucChanPerfPrev1DayReceivedBlks     AdslPerfPrevDayCount,
+          adslAtucChanPerfPrev1DayTransmittedBlks  AdslPerfPrevDayCount,
+          adslAtucChanPerfPrev1DayCorrectedBlks    AdslPerfPrevDayCount,
+          adslAtucChanPerfPrev1DayUncorrectBlks    AdslPerfPrevDayCount
+         }
+         -- performance group
+         --
+         -- Note: block is intended to be the length of the channel
+         --       data-block on which the CRC operates. See
+         --       adslAtucChanCrcBlockLength for more information.
+         --
+         adslAtucChanReceivedBlks OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this channel
+                 since agent reset."
+         ::= { adslAtucChanPerfDataEntry 1 }
+
+         adslAtucChanTransmittedBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel since agent reset."
+         ::= { adslAtucChanPerfDataEntry 2 }
+
+         adslAtucChanCorrectedBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected since agent reset.  These blocks are passed
+                 on as good data."
+         ::= { adslAtucChanPerfDataEntry 3 }
+
+         adslAtucChanUncorrectBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors since agent reset."
+         ::= { adslAtucChanPerfDataEntry 4 }
+
+         -- general 15 min interval information
+         --
+         adslAtucChanPerfValidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of previous 15-minute intervals in the
+                 interval table for which data was collected.  Given
+                 that <n> is the maximum # of intervals supported.
+                 The value will be <n> unless the measurement was
+                 (re-)started within the last (<n>*15) minutes, in which
+                 case the value will be the number of complete 15
+                 minute intervals for which the agent has at least
+                 some data. In certain cases (e.g., in the case
+                 where the agent is a proxy) it is possible that some
+                 intervals are unavailable.  In this case, this
+                 interval is the maximum interval number for
+                 which data is available."
+         ::= { adslAtucChanPerfDataEntry 5 }
+
+         adslAtucChanPerfInvalidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of intervals in the range from
+                 0 to the value of adslAtucChanPerfValidIntervals
+                 for which no data is available. This object
+                 will typically be zero except in cases where
+                 the data for some intervals are not available
+                 (e.g., in proxy situations)."
+         ::= { adslAtucChanPerfDataEntry 6 }
+
+         -- 15 min current performance group
+         --
+         adslAtucChanPerfCurr15MinTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..899)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Total elapsed seconds in this interval."
+         ::= { adslAtucChanPerfDataEntry 7 }
+
+         adslAtucChanPerfCurr15MinReceivedBlks OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this channel
+                 within the current 15 minute interval."
+         ::= { adslAtucChanPerfDataEntry 8 }
+
+         adslAtucChanPerfCurr15MinTransmittedBlks OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel within the current 15 minute interval."
+         ::= { adslAtucChanPerfDataEntry 9 }
+
+         adslAtucChanPerfCurr15MinCorrectedBlks  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel within the current 15 minute
+                 interval."
+         ::= { adslAtucChanPerfDataEntry 10 }
+
+         adslAtucChanPerfCurr15MinUncorrectBlks  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel within the current 15 minute
+                 interval."
+         ::= { adslAtucChanPerfDataEntry 11 }
+
+         -- 1-day current and previous performance group
+         --
+         adslAtucChanPerfCurr1DayTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..86399)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Number of seconds that have elapsed since the
+                 beginning of the current 1-day interval."
+         ::= { adslAtucChanPerfDataEntry 12 }
+
+         adslAtucChanPerfCurr1DayReceivedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this
+                 channel during the current day as measured by
+                 adslAtucChanPerfCurr1DayTimeElapsed."
+         ::= { adslAtucChanPerfDataEntry 13 }
+
+         adslAtucChanPerfCurr1DayTransmittedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel during the current day as measured by
+                 adslAtucChanPerfCurr1DayTimeElapsed."
+         ::= { adslAtucChanPerfDataEntry 14 }
+
+         adslAtucChanPerfCurr1DayCorrectedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel during the current day as
+                 measured by adslAtucChanPerfCurr1DayTimeElapsed."
+         ::= { adslAtucChanPerfDataEntry 15 }
+
+         adslAtucChanPerfCurr1DayUncorrectBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel during the current day as
+                 measured by adslAtucChanPerfCurr1DayTimeElapsed."
+         ::= { adslAtucChanPerfDataEntry 16 }
+
+         adslAtucChanPerfPrev1DayMoniSecs OBJECT-TYPE
+             SYNTAX      INTEGER(0..86400)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The amount of time in the previous 1-day interval
+                 over which the performance monitoring information
+                 is actually counted. This value will be the same as
+                 the interval duration except in a situation where
+                 performance monitoring data could not be collected
+                 for any reason."
+         ::= { adslAtucChanPerfDataEntry 17 }
+
+         adslAtucChanPerfPrev1DayReceivedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this
+                 channel within the most recent previous 1-day
+                 period."
+         ::= { adslAtucChanPerfDataEntry 18 }
+
+         adslAtucChanPerfPrev1DayTransmittedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel within the most recent previous 1-day
+                 period."
+         ::= { adslAtucChanPerfDataEntry 19 }
+
+         adslAtucChanPerfPrev1DayCorrectedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel within the most recent
+                 previous 1-day period."
+         ::= { adslAtucChanPerfDataEntry 20 }
+
+         adslAtucChanPerfPrev1DayUncorrectBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel within the most recent previous
+                 1-day period."
+         ::= { adslAtucChanPerfDataEntry 21 }
+
+         adslAturChanPerfDataTable       OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturChanPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR channel.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 11 }
+
+         adslAturChanPerfDataEntry       OBJECT-TYPE
+             SYNTAX          AdslAturChanPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in adslAturChanPerfDataTable."
+             INDEX           { ifIndex }
+         ::= { adslAturChanPerfDataTable 1 }
+
+         AdslAturChanPerfDataEntry ::=
+          SEQUENCE {
+          adslAturChanReceivedBlks                 Counter32,
+          adslAturChanTransmittedBlks              Counter32,
+          adslAturChanCorrectedBlks                Counter32,
+          adslAturChanUncorrectBlks                Counter32,
+          adslAturChanPerfValidIntervals           INTEGER,
+          adslAturChanPerfInvalidIntervals         INTEGER,
+          adslAturChanPerfCurr15MinTimeElapsed     AdslPerfTimeElapsed,
+          adslAturChanPerfCurr15MinReceivedBlks    PerfCurrentCount,
+          adslAturChanPerfCurr15MinTransmittedBlks PerfCurrentCount,
+          adslAturChanPerfCurr15MinCorrectedBlks   PerfCurrentCount,
+          adslAturChanPerfCurr15MinUncorrectBlks   PerfCurrentCount,
+          adslAturChanPerfCurr1DayTimeElapsed      AdslPerfTimeElapsed,
+          adslAturChanPerfCurr1DayReceivedBlks     AdslPerfCurrDayCount,
+          adslAturChanPerfCurr1DayTransmittedBlks  AdslPerfCurrDayCount,
+          adslAturChanPerfCurr1DayCorrectedBlks    AdslPerfCurrDayCount,
+          adslAturChanPerfCurr1DayUncorrectBlks    AdslPerfCurrDayCount,
+          adslAturChanPerfPrev1DayMoniSecs         INTEGER,
+          adslAturChanPerfPrev1DayReceivedBlks     AdslPerfPrevDayCount,
+          adslAturChanPerfPrev1DayTransmittedBlks  AdslPerfPrevDayCount,
+          adslAturChanPerfPrev1DayCorrectedBlks    AdslPerfPrevDayCount,
+          adslAturChanPerfPrev1DayUncorrectBlks    AdslPerfPrevDayCount
+          }
+         -- performance group
+         --
+         -- Note: block is intended to be the length of the channel
+         --       data-block on which the CRC operates. See
+         --       adslAturChanCrcBlockLength for more information.
+         --
+         adslAturChanReceivedBlks OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this channel
+                 since agent reset."
+         ::= { adslAturChanPerfDataEntry 1 }
+         adslAturChanTransmittedBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel since agent reset."
+         ::= { adslAturChanPerfDataEntry 2 }
+
+         adslAturChanCorrectedBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected since agent reset.  These blocks are passed
+                 on as good data."
+         ::= { adslAturChanPerfDataEntry 3 }
+
+         adslAturChanUncorrectBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors since agent reset."
+         ::= { adslAturChanPerfDataEntry 4 }
+
+         -- general 15 min interval information
+         --
+         adslAturChanPerfValidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of previous 15-minute intervals in the
+                 interval table for which data was collected.  Given
+                 that <n> is the maximum # of intervals supported.
+                 The value will be <n> unless the measurement was
+                 (re-)started within the last (<n>*15) minutes, in which
+                 case the value will be the number of complete 15
+                 minute intervals for which the agent has at least
+                 some data. In certain cases (e.g., in the case
+                 where the agent is a proxy) it is possible that some
+                 intervals are unavailable.  In this case, this
+                 interval is the maximum interval number for
+                 which data is available."
+         ::= { adslAturChanPerfDataEntry 5 }
+         adslAturChanPerfInvalidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of intervals in the range from
+                 0 to the value of adslAturChanPerfValidIntervals
+                 for which no data is available. This object
+                 will typically be zero except in cases where
+                 the data for some intervals are not available
+                 (e.g., in proxy situations)."
+         ::= { adslAturChanPerfDataEntry 6 }
+
+         -- 15 min current performance group
+         --
+         adslAturChanPerfCurr15MinTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..899)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Total elapsed seconds in this interval.
+                 A full interval is 900 seconds."
+         ::= { adslAturChanPerfDataEntry 7 }
+
+         adslAturChanPerfCurr15MinReceivedBlks OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this
+                 channel within the current 15 minute interval."
+         ::= { adslAturChanPerfDataEntry 8 }
+
+         adslAturChanPerfCurr15MinTransmittedBlks OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel within the current 15 minute interval."
+         ::= { adslAturChanPerfDataEntry 9 }
+
+         adslAturChanPerfCurr15MinCorrectedBlks  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel within the current 15 minute
+                 interval."
+         ::= { adslAturChanPerfDataEntry 10 }
+
+         adslAturChanPerfCurr15MinUncorrectBlks  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel within the current 15 minute
+                 interval."
+         ::= { adslAturChanPerfDataEntry 11 }
+
+         -- 1-day current and previous performance group
+         --
+         adslAturChanPerfCurr1DayTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..86399)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Number of seconds that have elapsed since the
+                 beginning of the current 1-day interval."
+         ::= { adslAturChanPerfDataEntry 12 }
+
+         adslAturChanPerfCurr1DayReceivedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this
+                 channel during the current day as measured by
+                 adslAturChanPerfCurr1DayTimeElapsed."
+         ::= { adslAturChanPerfDataEntry 13 }
+
+         adslAturChanPerfCurr1DayTransmittedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel during the current day as measured by
+                 adslAturChanPerfCurr1DayTimeElapsed."
+
+         ::= { adslAturChanPerfDataEntry 14 }
+
+         adslAturChanPerfCurr1DayCorrectedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel during the current day as
+                 measured by adslAturChanPerfCurr1DayTimeElapsed."
+         ::= { adslAturChanPerfDataEntry 15 }
+
+         adslAturChanPerfCurr1DayUncorrectBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel during the current day as
+                 measured by adslAturChanPerfCurr1DayTimeElapsed."
+         ::= { adslAturChanPerfDataEntry 16 }
+
+         adslAturChanPerfPrev1DayMoniSecs OBJECT-TYPE
+             SYNTAX      INTEGER(0..86400)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The amount of time in the previous 1-day interval
+                 over which the performance monitoring information
+                 is actually counted. This value will be the same as
+                 the interval duration except in a situation where
+                 performance monitoring data could not be collected
+                 for any reason."
+         ::= { adslAturChanPerfDataEntry 17 }
+
+         adslAturChanPerfPrev1DayReceivedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this
+                 channel within the most recent previous 1-day
+                 period."
+         ::= { adslAturChanPerfDataEntry 18 }
+
+         adslAturChanPerfPrev1DayTransmittedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel within the most recent previous 1-day
+                 period."
+         ::= { adslAturChanPerfDataEntry 19 }
+
+         adslAturChanPerfPrev1DayCorrectedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel within the most recent
+                 previous 1-day period."
+         ::= { adslAturChanPerfDataEntry 20 }
+
+         adslAturChanPerfPrev1DayUncorrectBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel within the most recent previous
+                 1-day period."
+         ::= { adslAturChanPerfDataEntry 21 }
+
+         adslAtucChanIntervalTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucChanIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC channel's
+                 performance data collection interval.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 12 }
+
+         adslAtucChanIntervalEntry   OBJECT-TYPE
+             SYNTAX          AdslAtucChanIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAtucIntervalTable."
+             INDEX           { ifIndex, adslAtucChanIntervalNumber }
+         ::= { adslAtucChanIntervalTable 1 }
+
+         AdslAtucChanIntervalEntry ::=
+             SEQUENCE {
+             adslAtucChanIntervalNumber          INTEGER,
+             adslAtucChanIntervalReceivedBlks    PerfIntervalCount,
+             adslAtucChanIntervalTransmittedBlks PerfIntervalCount,
+             adslAtucChanIntervalCorrectedBlks   PerfIntervalCount,
+             adslAtucChanIntervalUncorrectBlks   PerfIntervalCount,
+             adslAtucChanIntervalValidData       TruthValue
+             }
+         adslAtucChanIntervalNumber OBJECT-TYPE
+             SYNTAX      INTEGER(1..96)
+             MAX-ACCESS  not-accessible
+             STATUS      current
+             DESCRIPTION
+                 "Performance Data Interval number 1 is the
+                 the most recent previous interval; interval
+                 96 is 24 hours ago.  Intervals 2..96 are
+                 optional."
+         ::= { adslAtucChanIntervalEntry 1 }
+
+         adslAtucChanIntervalReceivedBlks OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this channel
+                 during this interval."
+         ::= { adslAtucChanIntervalEntry 2 }
+
+         adslAtucChanIntervalTransmittedBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel during this interval."
+         ::= { adslAtucChanIntervalEntry 3 }
+
+         adslAtucChanIntervalCorrectedBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel during this interval."
+         ::= { adslAtucChanIntervalEntry 4 }
+
+         adslAtucChanIntervalUncorrectBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel during this interval."
+         ::= { adslAtucChanIntervalEntry 5 }
+
+         adslAtucChanIntervalValidData OBJECT-TYPE
+             SYNTAX TruthValue
+             MAX-ACCESS read-only
+             STATUS current
+             DESCRIPTION
+                 "This variable indicates if the data for this
+                 interval is valid."
+         ::= { adslAtucChanIntervalEntry 6 }
+
+         adslAturChanIntervalTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturChanIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR channel's
+                 performance data collection interval.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 13 }
+
+         adslAturChanIntervalEntry   OBJECT-TYPE
+             SYNTAX          AdslAturChanIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAturIntervalTable."
+             INDEX           { ifIndex, adslAturChanIntervalNumber }
+         ::= { adslAturChanIntervalTable 1 }
+
+         AdslAturChanIntervalEntry ::=
+             SEQUENCE {
+             adslAturChanIntervalNumber               INTEGER,
+             adslAturChanIntervalReceivedBlks         PerfIntervalCount,
+             adslAturChanIntervalTransmittedBlks      PerfIntervalCount,
+             adslAturChanIntervalCorrectedBlks        PerfIntervalCount,
+             adslAturChanIntervalUncorrectBlks        PerfIntervalCount,
+             adslAturChanIntervalValidData            TruthValue
+             }
+         adslAturChanIntervalNumber OBJECT-TYPE
+             SYNTAX      INTEGER(1..96)
+             MAX-ACCESS  not-accessible
+             STATUS      current
+             DESCRIPTION
+                 "Performance Data Interval number 1 is the
+                 the most recent previous interval; interval
+                 96 is 24 hours ago.  Intervals 2..96 are
+                 optional."
+         ::= { adslAturChanIntervalEntry 1 }
+
+         adslAturChanIntervalReceivedBlks OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this channel
+                 during this interval."
+         ::= { adslAturChanIntervalEntry 2 }
+
+         adslAturChanIntervalTransmittedBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel during this interval."
+         ::= { adslAturChanIntervalEntry 3 }
+
+         adslAturChanIntervalCorrectedBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel during this interval."
+         ::= { adslAturChanIntervalEntry 4 }
+
+         adslAturChanIntervalUncorrectBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel during this interval."
+         ::= { adslAturChanIntervalEntry 5 }
+
+         adslAturChanIntervalValidData OBJECT-TYPE
+             SYNTAX TruthValue
+             MAX-ACCESS read-only
+             STATUS current
+             DESCRIPTION
+                 "This variable indicates if the data for this
+                 interval is valid."
+         ::= { adslAturChanIntervalEntry 6 }
+
+         -- Profile Group
+         --
+
+         adslLineConfProfileTable    OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslLineConfProfileEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table contains information on the ADSL line
+                 configuration.  One entry in this table reflects a
+                 profile defined by a manager which can be used to
+                 configure the ADSL line."
+         ::= { adslMibObjects 14}
+
+         adslLineConfProfileEntry    OBJECT-TYPE
+             SYNTAX          AdslLineConfProfileEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "Each entry consists of a list of parameters that
+                 represents the configuration of an ADSL modem.
+
+                 When `dynamic' profiles are implemented, a default
+                 profile will always exist.  This profile's name will
+                 be set to `DEFVAL' and its parameters will be set
+                 to vendor specific values, unless otherwise specified
+                 in this document.
+
+                 When `static' profiles are implemented, profiles
+                 are automaticly created or destroyed as ADSL
+                 physical lines are discovered and removed by
+                 the system.  The name of the profile will be
+                 equivalent to the decimal value of the line's
+                 interface index.
+                 "
+             INDEX { IMPLIED adslLineConfProfileName}
+         ::= { adslLineConfProfileTable 1}
+
+         AdslLineConfProfileEntry ::=
+             SEQUENCE {
+             adslLineConfProfileName               SnmpAdminString,
+             adslAtucConfRateMode                  INTEGER,
+             adslAtucConfRateChanRatio             INTEGER,
+             adslAtucConfTargetSnrMgn              INTEGER,
+             adslAtucConfMaxSnrMgn                 INTEGER,
+             adslAtucConfMinSnrMgn                 INTEGER,
+             adslAtucConfDownshiftSnrMgn           INTEGER,
+             adslAtucConfUpshiftSnrMgn             INTEGER,
+             adslAtucConfMinUpshiftTime            INTEGER,
+             adslAtucConfMinDownshiftTime          INTEGER,
+             adslAtucChanConfFastMinTxRate         Unsigned32,
+             adslAtucChanConfInterleaveMinTxRate   Unsigned32,
+             adslAtucChanConfFastMaxTxRate         Unsigned32,
+             adslAtucChanConfInterleaveMaxTxRate   Unsigned32,
+             adslAtucChanConfMaxInterleaveDelay    INTEGER,
+             adslAturConfRateMode                  INTEGER,
+             adslAturConfRateChanRatio             INTEGER,
+             adslAturConfTargetSnrMgn              INTEGER,
+             adslAturConfMaxSnrMgn                 INTEGER,
+             adslAturConfMinSnrMgn                 INTEGER,
+             adslAturConfDownshiftSnrMgn           INTEGER,
+             adslAturConfUpshiftSnrMgn             INTEGER,
+             adslAturConfMinUpshiftTime            INTEGER,
+             adslAturConfMinDownshiftTime          INTEGER,
+             adslAturChanConfFastMinTxRate         Unsigned32,
+             adslAturChanConfInterleaveMinTxRate   Unsigned32,
+             adslAturChanConfFastMaxTxRate         Unsigned32,
+             adslAturChanConfInterleaveMaxTxRate   Unsigned32,
+             adslAturChanConfMaxInterleaveDelay    INTEGER,
+             adslLineConfProfileRowStatus          RowStatus
+         }
+
+         adslLineConfProfileName    OBJECT-TYPE
+                 SYNTAX          SnmpAdminString (SIZE (1..32))
+                 MAX-ACCESS      not-accessible
+                 STATUS          current
+                 DESCRIPTION
+                 "This object is used by the line configuration table
+                 in order to identify a row of this table.
+
+                 When `dynamic' profiles are implemented, the profile
+                 name is user specified.  Also, the system will always
+                 provide a default profile whose name is `DEFVAL'.
+
+                 When `static' profiles are implemented, there is an
+                 one-to-one relationship between each line and its
+                 profile.  In which case, the profile name will
+                 need to algorithmicly represent the Line's ifIndex.
+                 Therefore, the profile's name is a decimalized string
+                 of the ifIndex that is fixed-length (i.e., 10) with
+                 leading zero(s).  For example, the profile name for
+                 ifIndex which equals '15' will be '0000000015'."
+         ::= { adslLineConfProfileEntry 1 }
+
+         adslAtucConfRateMode OBJECT-TYPE
+             SYNTAX      INTEGER {
+                 fixed (1),              -- no rate adaptation
+                 adaptAtStartup (2),     -- perform rate adaptation
+                                         -- only at initialization
+                 adaptAtRuntime (3)      -- perform rate adaptation at
+                                         -- any time
+             }
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Defines what form of transmit rate adaptation is
+                 configured on this modem.  See ADSL Forum TR-005 [3]
+                 for more information."
+         ::= { adslLineConfProfileEntry 2 }
+
+         adslAtucConfRateChanRatio OBJECT-TYPE
+             SYNTAX      INTEGER(0..100)
+             UNITS        "%"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured allocation ratio of excess transmit
+                 bandwidth between fast and interleaved channels.  Only
+                 applies when two channel mode and RADSL are supported.
+                 Distribute bandwidth on each channel in excess of the
+                 corresponding ChanConfMinTxRate so that:
+                 adslAtucConfRateChanRatio =
+
+                         [Fast / (Fast + Interleaved)] * 100
+
+                 In other words this value is the fast channel
+                 percentage."
+         ::= { adslLineConfProfileEntry 3 }
+
+       adslAtucConfTargetSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Target Signal/Noise Margin.
+                 This is the Noise Margin the modem must achieve
+                 with a BER of 10-7 or better to successfully complete
+                 initialization."
+         ::= { adslLineConfProfileEntry 4 }
+       adslAtucConfMaxSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum acceptable Signal/Noise Margin.
+                 If the Noise Margin is above this the modem should
+                 attempt to reduce its power output to optimize its
+                 operation."
+         ::= { adslLineConfProfileEntry 5 }
+
+         adslAtucConfMinSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum acceptable Signal/Noise Margin.
+                 If the noise margin falls below this level, the modem
+                 should attempt to increase its power output.  If that
+                 is not possible the modem will attempt to
+                 re-initialize or shut down."
+         ::= { adslLineConfProfileEntry 6 }
+
+         adslAtucConfDownshiftSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Signal/Noise Margin for rate downshift.
+                 If the noise margin falls below this level, the modem
+                 should attempt to decrease its transmit rate.  In
+                 the case that RADSL mode is not present,
+                 the value will be `0'."
+         ::= { adslLineConfProfileEntry 7 }
+
+         adslAtucConfUpshiftSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Signal/Noise Margin for rate upshift.
+                 If the noise margin rises above this level, the modem
+                 should attempt to increase its transmit rate.    In
+                 the case that RADSL is not present, the value will
+                 be `0'."
+         ::= { adslLineConfProfileEntry 8 }
+
+         adslAtucConfMinUpshiftTime OBJECT-TYPE
+             SYNTAX      INTEGER(0..16383)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Minimum time that the current margin is above
+                 UpshiftSnrMgn before an upshift occurs.
+                 In the case that RADSL is not present, the value will
+                 be `0'."
+         ::= { adslLineConfProfileEntry 9 }
+        adslAtucConfMinDownshiftTime OBJECT-TYPE
+             SYNTAX      INTEGER(0..16383)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Minimum time that the current margin is below
+                 DownshiftSnrMgn before a downshift occurs.
+                 In the case that RADSL mode is not present,
+                 the value will be `0'."
+         ::= { adslLineConfProfileEntry 10 }
+
+         adslAtucChanConfFastMinTxRate  OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum Transmit rate for `Fast' channels,
+                 in bps.  See adslAtucConfRateChanRatio for information
+                 regarding RADSL mode and ATUR transmit rate for
+                 ATUC receive rates."
+         ::= { adslLineConfProfileEntry 11 }
+
+         adslAtucChanConfInterleaveMinTxRate OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum Transmit rate for `Interleave'
+                 channels, in bps.  See adslAtucConfRateChanRatio for
+                 information regarding RADSL mode and see
+                 ATUR transmit rate for receive rates."
+         ::= { adslLineConfProfileEntry 12 }
+
+         adslAtucChanConfFastMaxTxRate  OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum Transmit rate for `Fast' channels,
+                 in bps.  See adslAtucConfRateChanRatio for information
+                 regarding RADSL mode and see ATUR transmit rate for
+                 ATUC receive rates."
+         ::= { adslLineConfProfileEntry 13 }
+
+         adslAtucChanConfInterleaveMaxTxRate OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum Transmit rate for `Interleave'
+                 channels, in bps.  See adslAtucConfRateChanRatio for
+                 information regarding RADSL mode and ATUR transmit
+                 rate for ATUC receive rates."
+         ::= { adslLineConfProfileEntry 14 }
+
+         adslAtucChanConfMaxInterleaveDelay OBJECT-TYPE
+             SYNTAX      INTEGER(0..255)
+             UNITS        "milli-seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured maximum Interleave Delay for this channel.
+
+                 Interleave delay applies only to the interleave channel
+                 and defines the mapping (relative spacing) between
+                 subsequent input bytes at the interleaver input and
+                 their placement in the bit stream at the interleaver
+                 output.  Larger numbers provide greater separation
+                 between consecutive input bytes in the output bit
+                 stream allowing for improved impulse noise immunity
+                 at the expense of payload latency."
+         ::= { adslLineConfProfileEntry 15 }
+
+         adslAturConfRateMode OBJECT-TYPE
+             SYNTAX      INTEGER {
+                 fixed (1),              -- no rate adaptation
+                 adaptAtStartup (2),     -- perform rate adaptation
+                                         -- only at initialization
+                 adaptAtRuntime (3)      -- perform rate adaptation at
+                                         -- any time
+             }
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Defines what form of transmit rate adaptation is
+                 configured on this modem.  See ADSL Forum TR-005 [3]
+                 for more information."
+         ::= { adslLineConfProfileEntry 16 }
+
+         adslAturConfRateChanRatio OBJECT-TYPE
+             SYNTAX      INTEGER(0..100)
+             UNITS        "%"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured allocation ratio of excess transmit
+                 bandwidth between fast and interleaved channels.  Only
+                 applies when two channel mode and RADSL are supported.
+                 Distribute bandwidth on each channel in excess of the
+                 corresponding ChanConfMinTxRate so that:
+                 adslAturConfRateChanRatio =
+
+                         [Fast / (Fast + Interleaved)] * 100
+
+                 In other words this value is the fast channel
+                 percentage."
+         ::= { adslLineConfProfileEntry 17 }
+
+       adslAturConfTargetSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Target Signal/Noise Margin.
+                 This is the Noise Margin the modem must achieve
+                 with a BER of 10-7 or better to successfully complete
+                 initialization."
+         ::= { adslLineConfProfileEntry 18 }
+
+       adslAturConfMaxSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum acceptable Signal/Noise Margin.
+                 If the Noise Margin is above this the modem should
+                 attempt to reduce its power output to optimize its
+                 operation."
+         ::= { adslLineConfProfileEntry 19 }
+
+        adslAturConfMinSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum acceptable Signal/Noise Margin.
+                 If the noise margin falls below this level, the modem
+                 should attempt to increase its power output.  If that
+                 is not possible the modem will attempt to
+                 re-initialize or shut down."
+         ::= { adslLineConfProfileEntry 20 }
+
+         adslAturConfDownshiftSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Signal/Noise Margin for rate downshift.
+                 If the noise margin falls below this level, the modem
+                 should attempt to decrease its transmit rate.
+                 In the case that RADSL mode is not present,
+                 the value will be `0'."
+         ::= { adslLineConfProfileEntry 21 }
+
+         adslAturConfUpshiftSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Signal/Noise Margin for rate upshift.
+                 If the noise margin rises above this level, the modem
+                 should attempt to increase its transmit rate.
+                 In the case that RADSL is not present,
+                 the value will be `0'."
+         ::= { adslLineConfProfileEntry 22 }
+
+         adslAturConfMinUpshiftTime OBJECT-TYPE
+             SYNTAX      INTEGER(0..16383)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Minimum time that the current margin is above
+                 UpshiftSnrMgn before an upshift occurs.
+                 In the case that RADSL is not present, the value will
+                 be `0'."
+         ::= { adslLineConfProfileEntry 23 }
+
+        adslAturConfMinDownshiftTime OBJECT-TYPE
+             SYNTAX      INTEGER(0..16383)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Minimum time that the current margin is below
+                 DownshiftSnrMgn before a downshift occurs.
+                 In the case that RADSL mode is not present,
+                 the value will be `0'."
+         ::= { adslLineConfProfileEntry 24 }
+
+         adslAturChanConfFastMinTxRate  OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum Transmit rate for `Fast' channels,
+                 in bps.  See adslAturConfRateChanRatio for information
+                 regarding RADSL mode and ATUC transmit rate
+                 for ATUR receive rates."
+         ::= { adslLineConfProfileEntry 25 }
+
+         adslAturChanConfInterleaveMinTxRate OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum Transmit rate for `Interleave'
+                 channels, in bps.  See adslAturConfRateChanRatio for
+                 information regarding RADSL mode and ATUC transmit rate
+                 for ATUR receive rates."
+         ::= { adslLineConfProfileEntry 26 }
+
+         adslAturChanConfFastMaxTxRate  OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum Transmit rate for `Fast' channels,
+                 in bps.  See adslAturConfRateChanRatio for information
+                 regarding RADSL mode and ATUC transmit rate
+                 for ATUR receive rates."
+         ::= { adslLineConfProfileEntry 27 }
+
+         adslAturChanConfInterleaveMaxTxRate OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum Transmit rate for `Interleave'
+                 channels, in bps.  See adslAturConfRateChanRatio for
+                 information regarding RADSL mode and see
+                 ATUC transmit rate for ATUR receive rates."
+         ::= { adslLineConfProfileEntry 28 }
+
+         adslAturChanConfMaxInterleaveDelay OBJECT-TYPE
+             SYNTAX      INTEGER(0..255)
+             UNITS        "milli-seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured maximum Interleave Delay for this channel.
+
+                 Interleave delay applies only to the interleave channel
+                 and defines the mapping (relative spacing) between
+                 subsequent input bytes at the interleaver input and
+                 their placement in the bit stream at the interleaver
+                 output.  Larger numbers provide greater separation
+                 between consecutive input bytes in the output bit
+                 stream allowing for improved impulse noise immunity
+                 at the expense of payload latency."
+         ::= { adslLineConfProfileEntry 29 }
+
+         adslLineConfProfileRowStatus OBJECT-TYPE
+             SYNTAX          RowStatus
+             MAX-ACCESS      read-create
+             STATUS          current
+             DESCRIPTION
+                 "This object is used to create a new row or modify or
+                 delete an existing row in this table.
+
+                 A profile activated by setting this object to
+                 `active'.  When `active' is set, the system
+                 will validate the profile.
+
+                 Before a profile can be deleted or taken out of
+                 service, (by setting this object to `destroy' or
+                 `outOfService') it must be first unreferenced
+                 from all associated lines.
+
+                 If the implementator of this MIB has chosen not
+                 to implement `dynamic assignment' of profiles, this
+                 object's MIN-ACCESS is read-only and its value
+                 is always to be `active'."
+         ::= { adslLineConfProfileEntry 30 }
+
+         adslLineAlarmConfProfileTable    OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslLineAlarmConfProfileEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table contains information on the ADSL line
+                 configuration.  One entry in this table reflects a
+                 profile defined by a manager which can be used to
+                 configure the modem for a physical line"
+         ::= { adslMibObjects 15}
+
+         adslLineAlarmConfProfileEntry    OBJECT-TYPE
+             SYNTAX          AdslLineAlarmConfProfileEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "Each entry consists of a list of parameters that
+                 represents the configuration of an ADSL modem.
+
+                 When `dynamic' profiles are implemented, a default
+                 profile will always exist.  This profile's name will
+                 be set to `DEFVAL' and its parameters will be set to
+                 vendor specific values, unless otherwise specified
+                 in this document.
+
+                 When `static' profiles are implemented, profiles
+                 are automaticly created or destroyed as ADSL
+                 physical lines are discovered and removed by
+                 the system.  The name of the profile will be
+                 equivalent to the decimal value of the line's
+                 interface index.
+                 "
+             INDEX { IMPLIED adslLineAlarmConfProfileName}
+         ::= { adslLineAlarmConfProfileTable 1}
+
+         AdslLineAlarmConfProfileEntry ::=
+             SEQUENCE {
+             adslLineAlarmConfProfileName          SnmpAdminString,
+             adslAtucThresh15MinLofs               INTEGER,
+             adslAtucThresh15MinLoss               INTEGER,
+             adslAtucThresh15MinLols               INTEGER,
+             adslAtucThresh15MinLprs               INTEGER,
+             adslAtucThresh15MinESs                INTEGER,
+             adslAtucThreshFastRateUp              Unsigned32,
+             adslAtucThreshInterleaveRateUp        Unsigned32,
+             adslAtucThreshFastRateDown            Unsigned32,
+             adslAtucThreshInterleaveRateDown      Unsigned32,
+             adslAtucInitFailureTrapEnable         INTEGER,
+             adslAturThresh15MinLofs               INTEGER,
+             adslAturThresh15MinLoss               INTEGER,
+             adslAturThresh15MinLprs               INTEGER,
+             adslAturThresh15MinESs                INTEGER,
+             adslAturThreshFastRateUp              Unsigned32,
+             adslAturThreshInterleaveRateUp        Unsigned32,
+             adslAturThreshFastRateDown            Unsigned32,
+             adslAturThreshInterleaveRateDown      Unsigned32,
+             adslLineAlarmConfProfileRowStatus     RowStatus
+             }
+
+         adslLineAlarmConfProfileName    OBJECT-TYPE
+             SYNTAX          SnmpAdminString (SIZE (1..32))
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This object is used by the line alarm configuration
+                 table in order to identify a row of this table.
+
+                 When `dynamic' profiles are implemented, the profile
+                 name is user specified.  Also, the system will always
+                 provide a default profile whose name is `DEFVAL'.
+
+                 When `static' profiles are implemented, there is an
+                 one-to-one relationship between each line and its
+                 profile.  In which case, the profile name will
+                 need to algorithmicly represent the Line's ifIndex.
+                 Therefore, the profile's name is a decimalized string
+                 of the ifIndex that is fixed-length (i.e., 10) with
+                 leading zero(s).  For example, the profile name for
+                 ifIndex which equals '15' will be '0000000015'."
+         ::= { adslLineAlarmConfProfileEntry 1}
+
+         adslAtucThresh15MinLofs OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Frame Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAtucPerfLofsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 2}
+
+         adslAtucThresh15MinLoss  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Signal Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAtucPerfLossThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 3}
+
+         adslAtucThresh15MinLols  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Link Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAtucPerfLolsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 4}
+
+         adslAtucThresh15MinLprs  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Power Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAtucPerfLprsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 5}
+
+         adslAtucThresh15MinESs  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Errored Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAtucPerfESsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 6}
+
+         adslAtucThreshFastRateUp OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Fast' channels only.
+                 Configured change in rate causing an
+                 adslAtucRateChangeTrap. A trap is produced when:
+                 ChanCurrTxRate >= ChanPrevTxRate plus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 7}
+
+         adslAtucThreshInterleaveRateUp OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Interleave' channels only.
+                 Configured change in rate causing an
+                 adslAtucRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate >= ChanPrevTxRate plus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 8}
+
+         adslAtucThreshFastRateDown OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Fast' channels only.
+                 Configured change in rate causing an
+                 adslAtucRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate <= ChanPrevTxRate minus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 9 }
+
+         adslAtucThreshInterleaveRateDown OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Interleave' channels only.
+                 Configured change in rate causing an
+                 adslAtucRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate <= ChanPrevTxRate minus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 10 }
+
+         adslAtucInitFailureTrapEnable OBJECT-TYPE
+             SYNTAX      INTEGER {
+                 enable (1),
+                 disable (2)
+             }
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Enables and disables the InitFailureTrap.  This
+                 object is defaulted disable(2)."
+         DEFVAL { disable }
+         ::= { adslLineAlarmConfProfileEntry 11 }
+
+         adslAturThresh15MinLofs OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Frame Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAturPerfLofsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 12 }
+
+         adslAturThresh15MinLoss  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Signal Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAturPerfLossThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 13 }
+
+         adslAturThresh15MinLprs  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Power Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAturPerfLprsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 14 }
+
+         adslAturThresh15MinESs  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Errored Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAturPerfESsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 15 }
+
+         adslAturThreshFastRateUp OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Fast' channels only.
+                 Configured change in rate causing an
+                 adslAturRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate >= ChanPrevTxRate plus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 16 }
+
+         adslAturThreshInterleaveRateUp OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Interleave' channels only.
+                 configured change in rate causing an
+                 adslAturRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate >= ChanPrevTxRate plus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 17 }
+
+         adslAturThreshFastRateDown OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Fast' channels only.
+                 Configured change in rate causing an
+                 adslAturRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate <= ChanPrevTxRate minus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 18 }
+
+         adslAturThreshInterleaveRateDown OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Interleave' channels only.
+                 Configured change in rate causing an
+                 adslAturRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate <= ChanPrevTxRate minus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 19 }
+
+         adslLineAlarmConfProfileRowStatus OBJECT-TYPE
+             SYNTAX          RowStatus
+             MAX-ACCESS      read-create
+             STATUS          current
+             DESCRIPTION
+                 "This object is used to create a new row or modify or
+                 delete an existing row in this table.
+
+                 A profile activated by setting this object to
+                 `active'.  When `active' is set, the system
+                 will validate the profile.
+
+                 Before a profile can be deleted or taken out of
+                 service, (by setting this object to `destroy' or
+                 `outOfService') it must be first unreferenced
+                 from all associated lines.
+
+                 If the implementator of this MIB has chosen not
+                 to implement `dynamic assignment' of profiles, this
+                 object's MIN-ACCESS is read-only and its value
+                 is always to be `active'."
+         ::= { adslLineAlarmConfProfileEntry 20 }
+
+         -- Line Code Specific Tables
+
+         -- These are place holders for the Line Code Specific MIBs
+         -- once they become available.
+
+         adslLCSMib  OBJECT IDENTIFIER ::= { adslMibObjects 16 }
+
+   -- trap definitions
+
+   adslTraps OBJECT IDENTIFIER ::= { adslLineMib 2 }
+
+   adslAtucTraps OBJECT IDENTIFIER ::= { adslTraps 1 }
+
+         adslAtucPerfLofsThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAtucPerfCurr15MinLofs,
+                       adslAtucThresh15MinLofs }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Framing 15-minute interval threshold reached."
+         ::= { adslAtucTraps 0 1 }
+
+         adslAtucPerfLossThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAtucPerfCurr15MinLoss,
+                       adslAtucThresh15MinLoss }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Signal 15-minute interval threshold reached."
+         ::= { adslAtucTraps 0 2 }
+
+         adslAtucPerfLprsThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAtucPerfCurr15MinLprs,
+                       adslAtucThresh15MinLprs }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Power 15-minute interval threshold reached."
+         ::= { adslAtucTraps 0 3 }
+
+         adslAtucPerfESsThreshTrap       NOTIFICATION-TYPE
+             OBJECTS { adslAtucPerfCurr15MinESs,
+                       adslAtucThresh15MinESs }
+             STATUS  current
+             DESCRIPTION
+                 "Errored Second 15-minute interval threshold reached."
+         ::= { adslAtucTraps 0 4 }
+
+         adslAtucRateChangeTrap  NOTIFICATION-TYPE
+             OBJECTS { adslAtucChanCurrTxRate,
+                       adslAtucChanPrevTxRate }
+             STATUS  current
+             DESCRIPTION
+                 "The ATUCs transmit rate has changed (RADSL mode only)"
+         ::= { adslAtucTraps 0 5 }
+
+         adslAtucPerfLolsThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAtucPerfCurr15MinLols,
+                       adslAtucThresh15MinLols }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Link 15-minute interval threshold reached."
+         ::= { adslAtucTraps 0 6 }
+
+         adslAtucInitFailureTrap NOTIFICATION-TYPE
+             OBJECTS { adslAtucCurrStatus }
+             STATUS  current
+             DESCRIPTION
+                 "ATUC initialization failed. See adslAtucCurrStatus
+                 for potential reasons."
+         ::= { adslAtucTraps 0 7 }
+
+   adslAturTraps OBJECT IDENTIFIER ::= { adslTraps 2 }
+
+         adslAturPerfLofsThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAturPerfCurr15MinLofs,
+                       adslAturThresh15MinLofs }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Framing 15-minute interval threshold reached."
+         ::= { adslAturTraps 0 1 }
+
+         adslAturPerfLossThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAturPerfCurr15MinLoss,
+                       adslAturThresh15MinLoss }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Signal 15-minute interval threshold reached."
+         ::= { adslAturTraps 0 2 }
+
+         adslAturPerfLprsThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAturPerfCurr15MinLprs,
+                       adslAturThresh15MinLprs }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Power 15-minute interval threshold reached."
+         ::= { adslAturTraps 0 3 }
+
+         adslAturPerfESsThreshTrap       NOTIFICATION-TYPE
+             OBJECTS { adslAturPerfCurr15MinESs,
+                       adslAturThresh15MinESs }
+             STATUS  current
+             DESCRIPTION
+                 "Errored Second 15-minute interval threshold reached."
+         ::= { adslAturTraps 0 4 }
+
+         adslAturRateChangeTrap  NOTIFICATION-TYPE
+             OBJECTS { adslAturChanCurrTxRate,
+                       adslAturChanPrevTxRate }
+             STATUS  current
+             DESCRIPTION
+                 "The ATURs transmit rate has changed (RADSL mode only)"
+         ::= { adslAturTraps 0 5 }
+
+         -- no adslAturPerfLolsThreshTrap possible { 0 6 }
+
+         -- no adslAturInitFailureTrap possible { 0 7 }
+
+   -- conformance information
+
+   adslConformance OBJECT IDENTIFIER ::= { adslLineMib 3 }
+
+   adslGroups OBJECT IDENTIFIER ::= { adslConformance 1 }
+   adslCompliances OBJECT IDENTIFIER ::= { adslConformance 2 }
+
+         -- ATU-C agent compliance statements
+
+         adslLineMibAtucCompliance MODULE-COMPLIANCE
+             STATUS  current
+             DESCRIPTION
+                 "The compliance statement for SNMP entities
+                  which manage ADSL ATU-C interfaces."
+
+             MODULE  -- this module
+             MANDATORY-GROUPS
+                {
+                adslLineGroup, adslPhysicalGroup, adslChannelGroup,
+                adslAtucPhysPerfIntervalGroup,
+                adslAturPhysPerfIntervalGroup, adslLineConfProfileGroup,
+                adslLineAlarmConfProfileGroup,
+                adslLineConfProfileControlGroup
+                }
+
+             GROUP       adslAtucPhysPerfRawCounterGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require continuous ATU-C physical event counters
+                  should implement this group."
+
+             GROUP       adslAturPhysPerfRawCounterGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require continuous ATU-R physical event counters
+                  should implement this group."
+
+             GROUP       adslAtucChanPerformanceGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require ATU-C channel block event counters should
+                  implement this group."
+             GROUP       adslAturChanPerformanceGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require ATU-R channel block event counters should
+                  implement this group."
+
+             OBJECT      adslLineConfProfile
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable when static
+                  profiles are implemented."
+
+             OBJECT      adslAtucConfRateMode
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfRateChanRatio
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfTargetSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfMaxSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfMinSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfDownshiftSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+             OBJECT      adslAtucConfUpshiftSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfMinUpshiftTime
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfMinDownshiftTime
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucChanConfFastMinTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucChanConfInterleaveMinTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucChanConfFastMaxTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucChanConfInterleaveMaxTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucChanConfMaxInterleaveDelay
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfRateMode
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfRateChanRatio
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfTargetSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfMaxSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfMinSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfDownshiftSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfUpshiftSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfMinUpshiftTime
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfMinDownshiftTime
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturChanConfFastMinTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturChanConfInterleaveMinTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturChanConfFastMaxTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturChanConfInterleaveMaxTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturChanConfMaxInterleaveDelay
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslLineConfProfileRowStatus
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable only when static
+                  profiles are implemented."
+
+             OBJECT      adslLineAlarmConfProfile
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable only when static
+                  profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLofs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLoss
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLols
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLprs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinESs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshFastRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshInterleaveRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshFastRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshInterleaveRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucInitFailureTrapEnable
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLofs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLoss
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLprs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinESs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshFastRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshInterleaveRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshFastRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshInterleaveRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslLineAlarmConfProfileRowStatus
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable only when static
+                  profiles are implemented."
+
+         ::= { adslCompliances 1 }
+
+         -- ATU-R agent compliance statements
+
+         adslLineMibAturCompliance MODULE-COMPLIANCE
+             STATUS  current
+             DESCRIPTION
+                 "The compliance statement for SNMP entities
+                  which manage ADSL ATU-R interfaces."
+
+             MODULE  -- this module
+             MANDATORY-GROUPS
+                 {
+                 adslAturLineGroup, adslAturPhysicalGroup,
+                 adslAturChannelGroup,
+                 adslAturAtucPhysPerfIntervalGroup,
+                 adslAturAturPhysPerfIntervalGroup,
+                 adslAturLineAlarmConfProfileGroup,
+                 adslAturLineConfProfileControlGroup
+                 }
+
+             GROUP       adslAturAtucPhysPerfRawCounterGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require continuous ATU-C physical event counters
+                  should implement this group."
+
+             GROUP       adslAturAturPhysPerfRawCounterGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require continuous ATU-R physical event counters
+                  should implement this group."
+
+             GROUP       adslAturAtucChanPerformanceGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require ATU-C channel block event counters should
+                  implement this group."
+
+             GROUP       adslAturAturChanPerformanceGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require ATU-R channel block event counters should
+                  implement this group."
+
+             OBJECT      adslLineAlarmConfProfile
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable only when static
+                  profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLofs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLoss
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinESs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshFastRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshInterleaveRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshFastRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucInitFailureTrapEnable
+             MIN-ACCESS  read-write
+
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLofs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLoss
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLprs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinESs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshFastRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshInterleaveRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshFastRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshInterleaveRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslLineAlarmConfProfileRowStatus
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable only when static
+                  profiles are implemented."
+
+             OBJECT     adslAtucCurrStatus
+             SYNTAX   BITS {
+                            noDefect(0),
+                            lossOfFraming(1),
+                            lossOfSignal(2)
+                           }
+             DESCRIPTION
+                 "It is allowable to implement only noDefect(0),
+                 lossOfFraming(1) and lossOfSignal(2) by the ATU-R
+                 agent."
+
+        ::= { adslCompliances 2 }
+
+         -- units of conformance
+         adslLineGroup    OBJECT-GROUP
+             OBJECTS {
+                adslLineCoding, adslLineType, adslLineSpecific
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing configuration
+                 information about an ADSL Line."
+         ::= { adslGroups 1 }
+
+         adslPhysicalGroup    OBJECT-GROUP
+             OBJECTS {
+                adslAtucInvSerialNumber, adslAtucInvVendorID,
+                adslAtucInvVersionNumber, adslAtucCurrSnrMgn,
+                adslAtucCurrAtn, adslAtucCurrStatus,
+                adslAtucCurrOutputPwr, adslAtucCurrAttainableRate,
+                adslAturInvSerialNumber, adslAturInvVendorID,
+                adslAturInvVersionNumber, adslAturCurrSnrMgn,
+                adslAturCurrAtn, adslAturCurrStatus,
+                adslAturCurrOutputPwr, adslAturCurrAttainableRate
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing physical
+                 configuration information of the ADSL Line."
+         ::= { adslGroups 2 }
+
+         adslChannelGroup    OBJECT-GROUP
+             OBJECTS {
+                adslAtucChanInterleaveDelay, adslAtucChanCurrTxRate,
+                adslAtucChanPrevTxRate, adslAtucChanCrcBlockLength,
+                adslAturChanInterleaveDelay, adslAturChanCurrTxRate,
+                adslAturChanPrevTxRate, adslAturChanCrcBlockLength
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing configuration
+                 information about an ADSL channel."
+         ::= { adslGroups 3 }
+
+         adslAtucPhysPerfRawCounterGroup OBJECT-GROUP
+             OBJECTS {
+                adslAtucPerfLofs, adslAtucPerfLoss,
+                adslAtucPerfLols, adslAtucPerfLprs,
+                adslAtucPerfESs, adslAtucPerfInits
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing raw performance
+                 counts on an ADSL Line (ATU-C end)."
+         ::= { adslGroups 4 }
+
+         adslAtucPhysPerfIntervalGroup OBJECT-GROUP
+             OBJECTS {
+                adslAtucPerfValidIntervals,
+                adslAtucPerfInvalidIntervals,
+                adslAtucPerfCurr15MinTimeElapsed,
+                adslAtucPerfCurr15MinLofs, adslAtucPerfCurr15MinLoss,
+                adslAtucPerfCurr15MinLols, adslAtucPerfCurr15MinLprs,
+                adslAtucPerfCurr15MinESs, adslAtucPerfCurr15MinInits,
+                adslAtucPerfCurr1DayLofs, adslAtucPerfCurr1DayLoss,
+                adslAtucPerfCurr1DayLols, adslAtucPerfCurr1DayLprs,
+                adslAtucPerfCurr1DayESs, adslAtucPerfCurr1DayInits,
+                adslAtucPerfPrev1DayMoniSecs,
+                adslAtucPerfPrev1DayLofs, adslAtucPerfPrev1DayLoss,
+                adslAtucPerfPrev1DayLols, adslAtucPerfPrev1DayLprs,
+                adslAtucPerfPrev1DayESs, adslAtucPerfPrev1DayInits,
+                adslAtucIntervalLofs, adslAtucIntervalLoss,
+                adslAtucIntervalLols, adslAtucIntervalLprs,
+                adslAtucIntervalESs, adslAtucIntervalInits,
+                adslAtucIntervalValidData
+                }
+
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing current 15-minute,
+                 1-day; and previous 1-day performance counts on
+                 ADSL Line (ATU-C end) ."
+         ::= { adslGroups 5 }
+
+         adslAturPhysPerfRawCounterGroup OBJECT-GROUP
+             OBJECTS {
+                adslAturPerfLofs, adslAturPerfLoss,
+                adslAturPerfLprs, adslAturPerfESs
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing raw performance
+                 counts on an ADSL Line (ATU-R end)."
+         ::= { adslGroups 6 }
+
+         adslAturPhysPerfIntervalGroup OBJECT-GROUP
+             OBJECTS {
+                adslAturPerfValidIntervals,
+                adslAturPerfInvalidIntervals,
+                adslAturPerfCurr15MinTimeElapsed,
+                adslAturPerfCurr15MinLofs, adslAturPerfCurr15MinLoss,
+                adslAturPerfCurr15MinLprs, adslAturPerfCurr15MinESs,
+                adslAturPerfCurr1DayTimeElapsed,
+                adslAturPerfCurr1DayLofs, adslAturPerfCurr1DayLoss,
+                adslAturPerfCurr1DayLprs, adslAturPerfCurr1DayESs,
+                adslAturPerfPrev1DayMoniSecs,
+                adslAturPerfPrev1DayLofs, adslAturPerfPrev1DayLoss,
+                adslAturPerfPrev1DayLprs, adslAturPerfPrev1DayESs,
+                adslAturIntervalLofs,
+                adslAturIntervalLoss, adslAturIntervalLprs,
+                adslAturIntervalESs, adslAturIntervalValidData
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing current 15-minute,
+                 1-day; and previous 1-day performance counts on
+                 ADSL Line (ATU-R end)."
+         ::= { adslGroups 7 }
+
+         adslAtucChanPerformanceGroup OBJECT-GROUP
+             OBJECTS {
+                adslAtucChanReceivedBlks,
+                adslAtucChanTransmittedBlks,
+                adslAtucChanCorrectedBlks,
+                adslAtucChanUncorrectBlks,
+                adslAtucChanPerfValidIntervals,
+                adslAtucChanPerfInvalidIntervals,
+                adslAtucChanPerfCurr15MinTimeElapsed,
+                adslAtucChanPerfCurr15MinReceivedBlks,
+                adslAtucChanPerfCurr15MinTransmittedBlks,
+                adslAtucChanPerfCurr15MinCorrectedBlks,
+                adslAtucChanPerfCurr15MinUncorrectBlks,
+                adslAtucChanPerfCurr1DayTimeElapsed,
+                adslAtucChanPerfCurr1DayReceivedBlks,
+                adslAtucChanPerfCurr1DayTransmittedBlks,
+                adslAtucChanPerfCurr1DayCorrectedBlks,
+                adslAtucChanPerfCurr1DayUncorrectBlks,
+                adslAtucChanPerfPrev1DayMoniSecs,
+                adslAtucChanPerfPrev1DayReceivedBlks,
+                adslAtucChanPerfPrev1DayTransmittedBlks,
+                adslAtucChanPerfPrev1DayCorrectedBlks,
+                adslAtucChanPerfPrev1DayUncorrectBlks,
+                adslAtucChanIntervalReceivedBlks,
+                adslAtucChanIntervalTransmittedBlks,
+                adslAtucChanIntervalCorrectedBlks,
+                adslAtucChanIntervalUncorrectBlks,
+                adslAtucChanIntervalValidData
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing channel block
+                 performance information on an ADSL channel
+                 (ATU-C end)."
+         ::= { adslGroups 8 }
+
+         adslAturChanPerformanceGroup OBJECT-GROUP
+             OBJECTS {
+                adslAturChanReceivedBlks,
+                adslAturChanTransmittedBlks,
+                adslAturChanCorrectedBlks,
+                adslAturChanUncorrectBlks,
+                adslAturChanPerfValidIntervals,
+                adslAturChanPerfInvalidIntervals,
+                adslAturChanPerfCurr15MinTimeElapsed,
+                adslAturChanPerfCurr15MinReceivedBlks,
+                adslAturChanPerfCurr15MinTransmittedBlks,
+                adslAturChanPerfCurr15MinCorrectedBlks,
+                adslAturChanPerfCurr15MinUncorrectBlks,
+                adslAturChanPerfCurr1DayTimeElapsed,
+                adslAturChanPerfCurr1DayReceivedBlks,
+                adslAturChanPerfCurr1DayTransmittedBlks,
+                adslAturChanPerfCurr1DayCorrectedBlks,
+                adslAturChanPerfCurr1DayUncorrectBlks,
+                adslAturChanPerfPrev1DayMoniSecs,
+                adslAturChanPerfPrev1DayReceivedBlks,
+                adslAturChanPerfPrev1DayTransmittedBlks,
+                adslAturChanPerfPrev1DayCorrectedBlks,
+                adslAturChanPerfPrev1DayUncorrectBlks,
+                adslAturChanIntervalReceivedBlks,
+                adslAturChanIntervalTransmittedBlks,
+                adslAturChanIntervalCorrectedBlks,
+                adslAturChanIntervalUncorrectBlks,
+                adslAturChanIntervalValidData
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing channel block
+                 performance information on an ADSL channel
+                 (ATU-C end)."
+         ::= { adslGroups 9 }
+
+         adslLineConfProfileGroup OBJECT-GROUP
+             OBJECTS {
+                adslAtucConfRateMode, adslAtucConfRateChanRatio,
+                adslAtucConfTargetSnrMgn, adslAtucConfMaxSnrMgn,
+                adslAtucConfMinSnrMgn,
+                adslAtucConfDownshiftSnrMgn,
+                adslAtucConfUpshiftSnrMgn,
+                adslAtucConfMinUpshiftTime,
+                adslAtucConfMinDownshiftTime,
+                adslAtucChanConfFastMinTxRate,
+                adslAtucChanConfInterleaveMinTxRate,
+                adslAtucChanConfFastMaxTxRate,
+                adslAtucChanConfInterleaveMaxTxRate,
+                adslAtucChanConfMaxInterleaveDelay,
+                adslAturConfRateMode, adslAturConfRateChanRatio,
+                adslAturConfTargetSnrMgn, adslAturConfMaxSnrMgn,
+                adslAturConfMinSnrMgn, adslAturConfDownshiftSnrMgn,
+                adslAturConfUpshiftSnrMgn,
+                adslAturConfMinUpshiftTime,
+                adslAturConfMinDownshiftTime,
+                adslAturChanConfFastMinTxRate,
+                adslAturChanConfInterleaveMinTxRate,
+                adslAturChanConfFastMaxTxRate,
+                adslAturChanConfInterleaveMaxTxRate,
+                adslAturChanConfMaxInterleaveDelay
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing provisioning
+                 information about an ADSL Line."
+         ::= { adslGroups 10 }
+
+         adslLineAlarmConfProfileGroup OBJECT-GROUP
+             OBJECTS {
+                adslAtucThresh15MinLofs, adslAtucThresh15MinLoss,
+                adslAtucThresh15MinLols, adslAtucThresh15MinLprs,
+                adslAtucThresh15MinESs, adslAtucThreshFastRateUp,
+                adslAtucThreshInterleaveRateUp,
+                adslAtucThreshFastRateDown,
+                adslAtucThreshInterleaveRateDown,
+                adslAtucInitFailureTrapEnable,
+                adslAturThresh15MinLofs, adslAturThresh15MinLoss,
+                adslAturThresh15MinLprs, adslAturThresh15MinESs,
+                adslAturThreshFastRateUp,
+                adslAturThreshInterleaveRateUp,
+                adslAturThreshFastRateDown,
+                adslAturThreshInterleaveRateDown
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing alarm provisioning
+                 information about an ADSL Line."
+         ::= { adslGroups 11 }
+
+         adslLineConfProfileControlGroup OBJECT-GROUP
+             OBJECTS {
+                adslLineConfProfile, adslLineAlarmConfProfile,
+                adslLineConfProfileRowStatus,
+                adslLineAlarmConfProfileRowStatus
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing profile
+                 control for the ADSL system."
+         ::= { adslGroups 12 }
+         adslNotificationsGroup NOTIFICATION-GROUP
+             NOTIFICATIONS {
+                adslAtucPerfLofsThreshTrap,
+                adslAtucPerfLossThreshTrap,
+                adslAtucPerfLprsThreshTrap,
+                adslAtucPerfESsThreshTrap,
+                adslAtucRateChangeTrap,
+                adslAtucPerfLolsThreshTrap,
+                adslAtucInitFailureTrap,
+                adslAturPerfLofsThreshTrap,
+                adslAturPerfLossThreshTrap,
+                adslAturPerfLprsThreshTrap,
+                adslAturPerfESsThreshTrap,
+                adslAturRateChangeTrap
+                }
+             STATUS        current
+             DESCRIPTION
+                 "The collection of adsl notifications."
+         ::= { adslGroups 13 }
+
+   -- units of conformance for ATU-R agent
+
+            adslAturLineGroup    OBJECT-GROUP
+                OBJECTS {
+                   adslLineCoding
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing configuration
+                    information about an ADSL Line on the ATU-R side."
+            ::= { adslGroups 14 }
+
+            adslAturPhysicalGroup    OBJECT-GROUP
+                OBJECTS {
+                   adslAtucInvVendorID,
+                   adslAtucInvVersionNumber,
+                   adslAtucCurrOutputPwr, adslAtucCurrAttainableRate,
+                   adslAturInvSerialNumber, adslAturInvVendorID,
+                   adslAturInvVersionNumber, adslAturCurrSnrMgn,
+                   adslAturCurrAtn, adslAturCurrStatus,
+                   adslAturCurrOutputPwr, adslAturCurrAttainableRate,
+                   adslAtucCurrStatus
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing physical
+                    configuration information of the ADSL Line on the
+                    ATU-R side."
+            ::= { adslGroups 15 }
+
+            adslAturChannelGroup    OBJECT-GROUP
+                OBJECTS {
+                   adslAtucChanInterleaveDelay, adslAtucChanCurrTxRate,
+                   adslAtucChanPrevTxRate,
+                   adslAturChanInterleaveDelay, adslAturChanCurrTxRate,
+                   adslAturChanPrevTxRate, adslAturChanCrcBlockLength
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing configuration
+                   information about an ADSL channel on the ATU-R
+                   side."
+            ::= { adslGroups 16 }
+
+            adslAturAtucPhysPerfRawCounterGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAtucPerfLofs, adslAtucPerfLoss,
+                   adslAtucPerfESs, adslAtucPerfInits
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing raw performance
+                   counts on an ADSL Line (ATU-C end) provided by the
+                   ATU-R agent."
+            ::= { adslGroups 17 }
+
+            adslAturAtucPhysPerfIntervalGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAtucPerfValidIntervals,
+                   adslAtucPerfInvalidIntervals,
+                   adslAtucPerfCurr15MinTimeElapsed,
+                   adslAtucPerfCurr15MinLofs, adslAtucPerfCurr15MinLoss,
+                   adslAtucPerfCurr15MinESs, adslAtucPerfCurr15MinInits,
+                   adslAtucPerfCurr1DayTimeElapsed,
+                   adslAtucPerfCurr1DayLofs, adslAtucPerfCurr1DayLoss,
+                   adslAtucPerfCurr1DayESs, adslAtucPerfCurr1DayInits,
+                   adslAtucPerfPrev1DayMoniSecs,
+                   adslAtucPerfPrev1DayLofs, adslAtucPerfPrev1DayLoss,
+                   adslAtucPerfPrev1DayESs, adslAtucPerfPrev1DayInits,
+                   adslAtucIntervalLofs, adslAtucIntervalLoss,
+                   adslAtucIntervalESs, adslAtucIntervalInits,
+                   adslAtucIntervalValidData
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing current
+                   15-minute, 1-day; and previous 1-day performance
+                   counts on ADSL Line (ATU-C end) provided by the
+                   ATU-R agent."
+            ::= { adslGroups 18 }
+
+            adslAturAturPhysPerfRawCounterGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAturPerfLofs, adslAturPerfLoss,
+                   adslAturPerfLprs, adslAturPerfESs
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing raw performance
+                   counts on an ADSL Line (ATU-R end) provided by the
+                   ATU-R agent."
+            ::= { adslGroups 19 }
+
+            adslAturAturPhysPerfIntervalGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAturPerfValidIntervals,
+                   adslAturPerfInvalidIntervals,
+                   adslAturPerfCurr15MinTimeElapsed,
+                   adslAturPerfCurr15MinLofs, adslAturPerfCurr15MinLoss,
+                   adslAturPerfCurr15MinLprs, adslAturPerfCurr15MinESs,
+                   adslAturPerfCurr1DayTimeElapsed,
+                   adslAturPerfCurr1DayLofs, adslAturPerfCurr1DayLoss,
+                   adslAturPerfCurr1DayLprs, adslAturPerfCurr1DayESs,
+                   adslAturPerfPrev1DayMoniSecs,
+                   adslAturPerfPrev1DayLofs, adslAturPerfPrev1DayLoss,
+                   adslAturPerfPrev1DayLprs, adslAturPerfPrev1DayESs,
+                   adslAturIntervalLofs,
+                   adslAturIntervalLoss, adslAturIntervalLprs,
+                   adslAturIntervalESs, adslAturIntervalValidData
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing current
+                   15-minute, 1-day; and previous 1-day performance
+                   counts on ADSL Line (ATU-R end) provided by the
+                   ATU-R agent."
+            ::= { adslGroups 20 }
+
+            adslAturAtucChanPerformanceGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAtucChanReceivedBlks,
+                   adslAtucChanTransmittedBlks,
+                   adslAtucChanCorrectedBlks,
+                   adslAtucChanUncorrectBlks,
+                   adslAtucChanPerfCurr15MinTimeElapsed,
+                   adslAtucChanPerfCurr15MinReceivedBlks,
+                   adslAtucChanPerfCurr15MinTransmittedBlks,
+                   adslAtucChanPerfCurr15MinCorrectedBlks,
+                   adslAtucChanPerfCurr15MinUncorrectBlks,
+                   adslAtucChanPerfCurr1DayTimeElapsed,
+                   adslAtucChanPerfCurr1DayReceivedBlks,
+                   adslAtucChanPerfCurr1DayTransmittedBlks,
+                   adslAtucChanPerfCurr1DayCorrectedBlks,
+                   adslAtucChanPerfCurr1DayUncorrectBlks,
+                   adslAtucChanPerfPrev1DayMoniSecs,
+                   adslAtucChanPerfPrev1DayReceivedBlks,
+                   adslAtucChanPerfPrev1DayTransmittedBlks,
+                   adslAtucChanPerfPrev1DayCorrectedBlks,
+                   adslAtucChanPerfPrev1DayUncorrectBlks,
+                   adslAtucChanPerfValidIntervals,
+                   adslAtucChanPerfInvalidIntervals,
+                   adslAtucChanIntervalReceivedBlks,
+                   adslAtucChanIntervalTransmittedBlks,
+                   adslAtucChanIntervalCorrectedBlks,
+                   adslAtucChanIntervalUncorrectBlks,
+                   adslAtucChanIntervalValidData
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing channel block
+                    performance information on an ADSL channel
+                    (ATU-C end) provided by the ATU-R agent."
+            ::= { adslGroups 21 }
+
+            adslAturAturChanPerformanceGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAturChanReceivedBlks,
+                   adslAturChanTransmittedBlks,
+                   adslAturChanCorrectedBlks,
+                   adslAturChanUncorrectBlks,
+                   adslAturChanPerfValidIntervals,
+                   adslAturChanPerfInvalidIntervals,
+                   adslAturChanPerfCurr15MinTimeElapsed,
+                   adslAturChanPerfCurr15MinReceivedBlks,
+                   adslAturChanPerfCurr15MinTransmittedBlks,
+                   adslAturChanPerfCurr15MinCorrectedBlks,
+                   adslAturChanPerfCurr15MinUncorrectBlks,
+                   adslAturChanPerfCurr1DayTimeElapsed,
+                   adslAturChanPerfCurr1DayReceivedBlks,
+                   adslAturChanPerfCurr1DayTransmittedBlks,
+                   adslAturChanPerfCurr1DayCorrectedBlks,
+                   adslAturChanPerfCurr1DayUncorrectBlks,
+                   adslAturChanPerfPrev1DayMoniSecs,
+                   adslAturChanPerfPrev1DayReceivedBlks,
+                   adslAturChanPerfPrev1DayTransmittedBlks,
+                   adslAturChanPerfPrev1DayCorrectedBlks,
+                   adslAturChanPerfPrev1DayUncorrectBlks,
+                   adslAturChanIntervalReceivedBlks,
+                   adslAturChanIntervalTransmittedBlks,
+                   adslAturChanIntervalCorrectedBlks,
+                   adslAturChanIntervalUncorrectBlks,
+                   adslAturChanIntervalValidData
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing channel block
+                    performance information on an ADSL channel
+                    (ATU-R end) provided by the ATU-R agent."
+            ::= { adslGroups 22 }
+
+            adslAturLineAlarmConfProfileGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAtucThresh15MinLofs, adslAtucThresh15MinLoss,
+                   adslAtucThresh15MinESs, adslAtucThreshFastRateUp,
+                   adslAtucThreshInterleaveRateUp,
+                   adslAtucThreshFastRateDown,
+                   adslAtucThreshInterleaveRateDown,
+                   adslAtucInitFailureTrapEnable,
+                   adslAturThresh15MinLofs, adslAturThresh15MinLoss,
+                   adslAturThresh15MinLprs, adslAturThresh15MinESs,
+                   adslAturThreshFastRateUp,
+                   adslAturThreshInterleaveRateUp,
+                   adslAturThreshFastRateDown,
+                   adslAturThreshInterleaveRateDown
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing alarm provisioning
+                    information about an ADSL Line provided by the
+                    ATU-R agent."
+            ::= { adslGroups 23 }
+
+            adslAturLineConfProfileControlGroup OBJECT-GROUP
+                OBJECTS {
+                   adslLineAlarmConfProfile,
+                   adslLineAlarmConfProfileRowStatus
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing profile
+                    control for the ADSL system by the ATU-R agent."
+            ::= { adslGroups 24 }
+
+            adslAturNotificationsGroup NOTIFICATION-GROUP
+                NOTIFICATIONS {
+                    adslAtucPerfLofsThreshTrap,
+                    adslAtucPerfLossThreshTrap,
+                    adslAtucPerfESsThreshTrap,
+                    adslAtucRateChangeTrap,
+                    adslAturPerfLofsThreshTrap,
+                    adslAturPerfLossThreshTrap,
+                    adslAturPerfLprsThreshTrap,
+                    adslAturPerfESsThreshTrap,
+                    adslAturRateChangeTrap
+                    }
+                STATUS        current
+                DESCRIPTION
+                    "The collection of ADSL notifications implemented by
+                    the ATU-R agent."
+            ::= { adslGroups 25 }
+
+   END
diff -Naur net-snmp-5.1/apps/ADSL-TC-MIB.txt open_snmp/apps/ADSL-TC-MIB.txt
--- net-snmp-5.1/apps/ADSL-TC-MIB.txt	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/apps/ADSL-TC-MIB.txt	2009-12-16 13:00:06.000000000 +0530
@@ -0,0 +1,113 @@
+ADSL-TC-MIB DEFINITIONS ::= BEGIN
+
+IMPORTS
+    transmission,
+    MODULE-IDENTITY, Gauge32            FROM SNMPv2-SMI
+    TEXTUAL-CONVENTION                  FROM SNMPv2-TC;
+
+adsltcmib MODULE-IDENTITY
+   LAST-UPDATED "9908190000Z"
+   ORGANIZATION "IETF ADSL MIB Working Group"
+   CONTACT-INFO
+       "
+       Gregory Bathrick
+       AG Communication Systems
+       A Subsidiary of Lucent Technologies
+       2500 W Utopia Rd.
+       Phoenix, AZ 85027 USA
+       Tel: +1 602-582-7679
+       Fax: +1 602-582-7697
+       E-mail: bathricg@agcs.com
+
+       Faye Ly
+       Copper Mountain Networks
+       Norcal Office
+       2470 Embarcadero Way
+       Palo Alto, CA 94303
+       Tel: +1 650-858-8500
+       Fax: +1 650-858-8085
+       E-Mail: faye@coppermountain.com
+
+
+       IETF ADSL MIB Working Group (adsl@xlist.agcs.com)
+       "
+       DESCRIPTION
+           "The MIB module which provides a ADSL
+           Line Coding Textual Convention to be used
+           by ADSL Lines."
+
+       --  Revision history
+       REVISION     "9908190000Z"  -- 19 August 1999, midnight
+       DESCRIPTION  "Initial Version, published as RFC 2662"
+
+       ::= { transmission 94 2 } -- adslMIB 2
+
+       AdslLineCodingType ::= TEXTUAL-CONVENTION
+           STATUS       current
+           DESCRIPTION
+               "This data type is used as the syntax for the ADSL
+               Line Code."
+           SYNTAX  INTEGER {
+               other(1),-- none of the following
+               dmt (2), -- Discrete MultiTone
+               cap (3), -- Carrierless Amplitude & Phase modulation
+               qam (4)  -- Quadrature Amplitude Modulation
+           }
+
+       AdslPerfCurrDayCount ::= TEXTUAL-CONVENTION
+           STATUS  current
+           DESCRIPTION
+               "A counter associated with interface performance
+               measurements in a current 1-day (24 hour) measurement
+               interval.
+
+               The value of this counter starts at zero at the
+               beginning of an interval and is increased when
+               associated events occur, until the end of the
+               1-day interval.  At that time the value of the
+               counter is stored in the previous 1-day history
+               interval, if available, and the current interval
+               counter is restarted at zero.
+
+               In the case where the agent has no valid data available
+               for this interval the corresponding object
+               instance is not available and upon a retrieval
+               request a corresponding error message shall be
+               returned to indicate that this instance does
+               not exist (for example, a noSuchName error for
+               SNMPv1 and a noSuchInstance for SNMPv2 GET
+               operation)."
+            SYNTAX  Gauge32
+
+       AdslPerfPrevDayCount ::= TEXTUAL-CONVENTION
+           STATUS  current
+           DESCRIPTION
+               "A counter associated with interface performance
+               measurements during the most previous 1-day (24 hour)
+               measurement interval.  The value of this counter is
+               equal to the value of the current day counter at
+               the end of its most recent interval.
+
+               In the case where the agent has no valid data available
+               for this interval the corresponding object
+               instance is not available and upon a retrieval
+               request a corresponding error message shall be
+               returned to indicate that this instance does
+               not exist (for example, a noSuchName error for
+               SNMPv1 and a noSuchInstance for SNMPv2 GET
+               operation)."
+           SYNTAX  Gauge32
+
+       AdslPerfTimeElapsed ::= TEXTUAL-CONVENTION
+           STATUS current
+           DESCRIPTION
+               "The number of seconds that have elapsed since
+               the beginning of the current measurement period.
+               If, for some reason, such as an adjustment in the
+               system's time-of-day clock, the current interval
+               exceeds the maximum value, the agent will return
+               the maximum value."
+           SYNTAX  Gauge32
+
+END
+
diff -Naur net-snmp-5.1/apps/Makefile.in open_snmp/apps/Makefile.in
--- net-snmp-5.1/apps/Makefile.in	2003-10-02 23:24:45.000000000 +0530
+++ open_snmp/apps/Makefile.in	2009-12-16 13:00:06.000000000 +0530
@@ -26,7 +26,8 @@
 		snmpdf$(EXEEXT) 			\
 		snmpvacm$(EXEEXT)
 
-INSTALLSBINPROGS = snmptrapd$(EXEEXT)
+INSTALLSBINPROGS = 
+#INSTALLSBINPROGS = snmptrapd$(EXEEXT)
 
 INSTALLLIBS     = libnetsnmptrapd.$(LIB_EXTENSION)$(LIB_VERSION)
 
@@ -38,8 +39,11 @@
 
 USELIBS		= ../snmplib/libnetsnmp.$(LIB_EXTENSION)$(LIB_VERSION) 
 USETRAPLIBS	= ../agent/libnetsnmpagent.$(LIB_EXTENSION)$(LIB_VERSION) ../agent/libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION) ../agent/helpers/libnetsnmphelpers.$(LIB_EXTENSION)$(LIB_VERSION) $(USELIBS)
+IFX_COMMON  = $(top_srcdir)/../../ifx/IFXAPIs
+IFX_COMMON_LIBS = -lIFXAPIs -L$(IFX_COMMON)/lib
+
 LOCAL_LIBS	= -L../snmplib -L../agent -L../agent/helpers
-LIBS		= $(USELIBS) @LIBS@
+LIBS		= $(USELIBS) $(IFX_COMMON_LIBS) @LIBS@
 TRAPLIBS	= $(USETRAPLIBS) @AGENTLIBS@
 
 CPPFLAGS	= -I$(top_srcdir)/include -I../include \
@@ -88,8 +92,8 @@
 snmptest$(EXEEXT):    snmptest.$(OSUFFIX) $(USELIBS)
 	$(LINK) -o $@ snmptest.$(OSUFFIX) $(LOCAL_LIBS) ${LDFLAGS} ${LIBS} 
 
-snmptrapd$(EXEEXT):    $(TRAPD_OBJECTS) $(USETRAPLIBS) $(INSTALLLIBS)
-	$(LINK) -o $@ $(TRAPD_OBJECTS) $(INSTALLLIBS) $(LOCAL_LIBS) ${LDFLAGS} ${TRAPLIBS} @WRAPLIBS@
+#snmptrapd$(EXEEXT):    $(TRAPD_OBJECTS) $(USETRAPLIBS) $(INSTALLLIBS)
+#	$(LINK) -o $@ $(TRAPD_OBJECTS) $(INSTALLLIBS) $(LOCAL_LIBS) ${LDFLAGS} ${TRAPLIBS} @WRAPLIBS@
 
 snmptrap$(EXEEXT):    snmptrap.$(OSUFFIX) $(USELIBS)
 	$(LINK) -o $@ snmptrap.$(OSUFFIX) $(LOCAL_LIBS) ${LDFLAGS} ${LIBS} 
diff -Naur net-snmp-5.1/apps/encode_keychange.c open_snmp/apps/encode_keychange.c
--- net-snmp-5.1/apps/encode_keychange.c	2002-12-19 21:35:06.000000000 +0530
+++ open_snmp/apps/encode_keychange.c	2009-12-16 13:00:07.000000000 +0530
@@ -187,7 +187,7 @@
     }
 
 
-
+#ifdef SNMP_SECMOD_USM
     /*
      * Convert and error check transform_type.
      */
@@ -204,7 +204,7 @@
         usage_synopsis(stderr);
         QUITFUN(rval = SNMPERR_GENERR, main_quit);
     }
-
+#endif /* SNMP_SECMOD_USM */
     if (verbose) {
         fprintf(stderr, "Hash:\t\t%s\n",
                 (transform_type == usmHMACMD5AuthProtocol)
diff -Naur net-snmp-5.1/apps/notification_log.lo open_snmp/apps/notification_log.lo
--- net-snmp-5.1/apps/notification_log.lo	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/apps/notification_log.lo	2009-12-16 13:00:07.000000000 +0530
@@ -0,0 +1 @@
+timestamp
diff -Naur net-snmp-5.1/apps/snmpnetstat/Makefile.in open_snmp/apps/snmpnetstat/Makefile.in
--- net-snmp-5.1/apps/snmpnetstat/Makefile.in	2002-04-20 13:00:10.000000000 +0530
+++ open_snmp/apps/snmpnetstat/Makefile.in	2009-12-16 13:00:08.000000000 +0530
@@ -16,7 +16,10 @@
 CPPFLAGS=-I../../include -I../.. -I$(srcdir)/../.. -I$(srcdir)/../../include @CPPFLAGS@
 
 USELIBS= ../../snmplib/libnetsnmp.$(LIB_EXTENSION)$(LIB_VERSION)
-LIBS=	 ../../snmplib/libnetsnmp.$(LIB_EXTENSION)$(LIB_VERSION) @LIBS@
+IFX_COMMON  = $(top_srcdir)/../../ifx/IFXAPIs
+IFX_COMMON_LIBS = -lIFXAPIs -L$(IFX_COMMON)/lib
+
+LIBS=	 ../../snmplib/libnetsnmp.$(LIB_EXTENSION)$(LIB_VERSION) $(IFX_COMMON_LIBS) @LIBS@
 
 all: standardall
 
diff -Naur net-snmp-5.1/apps/snmptrapd.c open_snmp/apps/snmptrapd.c
--- net-snmp-5.1/apps/snmptrapd.c	2003-10-24 18:19:22.000000000 +0530
+++ open_snmp/apps/snmptrapd.c	2009-12-16 13:00:10.000000000 +0530
@@ -23,7 +23,9 @@
 ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
+//509141:tc.chen 2005/09/14 add cpe-dsl-mib feature support
 #include <net-snmp/net-snmp-config.h>
+#include <ifx_config.h> //509141:tc.chen
 
 #if HAVE_STDLIB_H
 #include <stdlib.h>
@@ -370,7 +372,7 @@
     session->community_len = SNMP_DEFAULT_COMMUNITY_LEN;
     session->retries = SNMP_DEFAULT_RETRIES;
     session->timeout = SNMP_DEFAULT_TIMEOUT;
-    session->callback = snmp_input;
+    session->callback = snmp_trapd_input;//509141:tc.chen
     session->callback_magic = (void *) t;
     session->authenticator = NULL;
     sess.isAuthoritative = SNMP_SESS_UNKNOWNAUTH;
@@ -440,19 +442,23 @@
      * register our configuration handlers now so -H properly displays them 
      */
     snmptrapd_register_configs( );
+#ifndef IFX_CONFIG_CPE_DSL_MIB //509141:tc.chen
     register_config_handler("snmptrapd", "createUser",
                             usm_parse_create_usmUser, NULL,
                            "username (MD5|SHA) passphrase [DES [passphrase]]");
     register_config_handler("snmptrapd", "usmUser",
                             usm_parse_config_usmUser, NULL, NULL);
+#endif
     register_config_handler("snmptrapd", "snmptrapdaddr",
                             parse_trapd_address, free_trapd_address, NULL);
 
     /*
      * we need to be called back later 
      */
+#ifndef IFX_CONFIG_CPE_DSL_MIB //509141:tc.chen 
     snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
                            usm_store_users, NULL);
+#endif
 
 #ifdef WIN32
     setvbuf(stdout, NULL, _IONBF, BUFSIZ);
@@ -744,6 +750,10 @@
 	 */
     }
 
+#ifdef IFX_CONFIG_CPE_DSL_MIB //509141:tc.chen
+    init_cpeBootTrap_handler(); //509141:tc.chen
+#endif
+
 #ifdef USING_AGENTX_SUBAGENT_MODULE
     /*
      * we're an agentx subagent? 
diff -Naur net-snmp-5.1/apps/snmptrapd_handlers.c open_snmp/apps/snmptrapd_handlers.c
--- net-snmp-5.1/apps/snmptrapd_handlers.c	2003-11-02 18:20:38.000000000 +0530
+++ open_snmp/apps/snmptrapd_handlers.c	2009-12-16 13:00:10.000000000 +0530
@@ -1,3 +1,4 @@
+//509141:tc.chen 2005/09/14 add cpe-dsl-mib feature support
 #include <net-snmp/net-snmp-config.h>
 
 #if HAVE_STDLIB_H
@@ -697,8 +698,10 @@
     int             oldquick, result;
 
     DEBUGMSGTL(("snmptrapd", "Running: %s\n", cmd));
+#if !defined(HAVE_MINIMAL_LIBSUPPORT) //509141:tc.chen
     oldquick = snmp_get_quick_print();
     snmp_set_quick_print(1);
+#endif
     if (cmd) {
 #ifndef WIN32
         int             fd[2];
@@ -755,7 +758,9 @@
         }
 #endif                          /* WIN32 */
     }
+#if !defined(HAVE_MINIMAL_LIBSUPPORT) //509141:tc.chen
     snmp_set_quick_print(oldquick);
+#endif
 }
 
 
@@ -772,8 +777,10 @@
     DEBUGMSGTL(( "snmptrapd", "command_handler\n"));
     DEBUGMSGTL(( "snmptrapd", "token = '%s'\n", handler->token));
     if (handler && handler->token && *handler->token) {
+#if !defined(HAVE_MINIMAL_LIBSUPPORT) //509141:tc.chen
         oldquick = snmp_get_quick_print();
         snmp_set_quick_print(1);
+#endif
 
         /*
 	 * Format the trap and pass this string to the external command
@@ -802,8 +809,12 @@
         /*
          *  and pass this formatted string to the command specified
          */
+#ifndef IFX_CONFIG_CPE_DSL_MIB //509141:tc.chen
         run_exec_command(handler->token, rbuf, NULL, 0);   /* Not interested in output */
+#endif
+#if !defined(HAVE_MINIMAL_LIBSUPPORT) //509141:tc.chen
         snmp_set_quick_print(oldquick);
+#endif
     }
     return NETSNMPTRAPD_HANDLER_OK;
 }
@@ -866,7 +877,8 @@
 
 
 int
-snmp_input(int op, netsnmp_session *session,
+//509141:tc.chen snmp_input(int op, netsnmp_session *session,
+snmp_trapd_input(int op, netsnmp_session *session,
            int reqid, netsnmp_pdu *pdu, void *magic)
 {
     oid stdTrapOidRoot[] = { 1, 3, 6, 1, 6, 3, 1, 1, 5 };
diff -Naur net-snmp-5.1/apps/snmptrapd_handlers.h open_snmp/apps/snmptrapd_handlers.h
--- net-snmp-5.1/apps/snmptrapd_handlers.h	2003-06-23 18:43:52.000000000 +0530
+++ open_snmp/apps/snmptrapd_handlers.h	2009-12-16 13:00:11.000000000 +0530
@@ -1,6 +1,9 @@
+//509141:tc.chen 2005/09/14 add cpe-dsl-mib feature support
 #ifndef SNMPTRAPD_HANDLERS_H
 #define SNMPTRAPD_HANDLERS_H
 
+#include <ifx_config.h> //509141:tc.chen
+
 typedef struct netsnmp_trapd_handler_s netsnmp_trapd_handler;
 
 typedef int (Netsnmp_Trap_Handler)(netsnmp_pdu           *pdu,
@@ -52,7 +55,8 @@
 const char *trap_description(int trap);
 void do_external(char *cmd, struct hostent *host,
             netsnmp_pdu *pdu, netsnmp_transport *transport);
-int snmp_input(int op, netsnmp_session *session,
+//509141:tc.chen int snmp_input(int op, netsnmp_session *session,
+ int snmp_trapd_input(int op, netsnmp_session *session,
            int reqid, netsnmp_pdu *pdu, void *magic);
 
 #endif                          /* SNMPTRAPD_HANDLERS_H */
diff -Naur net-snmp-5.1/apps/snmptrapd_handlers.lo open_snmp/apps/snmptrapd_handlers.lo
--- net-snmp-5.1/apps/snmptrapd_handlers.lo	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/apps/snmptrapd_handlers.lo	2009-12-16 13:00:11.000000000 +0530
@@ -0,0 +1 @@
+timestamp
diff -Naur net-snmp-5.1/apps/snmptrapd_log.lo open_snmp/apps/snmptrapd_log.lo
--- net-snmp-5.1/apps/snmptrapd_log.lo	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/apps/snmptrapd_log.lo	2009-12-16 13:00:11.000000000 +0530
@@ -0,0 +1 @@
+timestamp
diff -Naur net-snmp-5.1/build.sh open_snmp/build.sh
--- net-snmp-5.1/build.sh	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/build.sh	2009-12-16 13:00:11.000000000 +0530
@@ -0,0 +1,128 @@
+#!/bin/sh
+APPS_NAME="snmp-5.1"
+if [ -e sysconfig.sh ]; then
+	. sysconfig.sh
+	. config.sh
+	. model_config.sh
+else
+        echo "Application "$APPS_NAME" not configured"
+        exit 0
+fi                                                                                                                                       
+
+display_info "----------------------------------------------------------------------"
+display_info "----------------------- Build net snmp-5.1     ------------------------"
+display_info "----------------------------------------------------------------------"
+
+if [ "$IFX_CONFIG_CPU" == "AMAZON" ]; then
+	IFX_CFLAGS="${IFX_CFLAGS} -DCPU_AMAZON"
+elif ["$IFX_CONFIG_CPU" == "DANUBE" ]; then
+	IFX_CFLAGS="${IFX_CFLAGS} -DCPU_DANUBE"
+fi
+
+CONFIG_FULL_PACKAGE=y
+if [ "$CONFIG_FULL_PACKAGE" == "y" ]; then
+
+parse_args $@
+
+if [ $BUILD_CLEAN -eq 1 ]; then
+	rm -rf .config_ok
+	rm -f ${BUILD_ROOTFS_DIR}usr/lib/libnetsnmp*
+	rm -f ${BUILD_ROOTFS_DIR}usr/sbin/snmp*
+	make distclean
+	[ ! $BUILD_CONFIGURE -eq 1 ] && exit 0
+fi
+
+#export IFX_CFLAGS TARGET HOST BUILD IFX_LDFLAGS
+	# Added by Subbi for ATM-MIB support in User space */
+	if [ "$IFX_CONFIG_SNMP_ATM_MIB" = "1" ]; then
+		IFX_CONFIG_MIB_MODULES="${IFX_CONFIG_MIB_MODULES} atmMIB"
+		IFX_CFLAGS="${IFX_CFLAGS} -DIFX_CONFIG_SNMP_ATM_MIB" 
+	fi
+
+	# Added by Subbi for ADSL-MIB support in User space */
+	if [ "$IFX_CONFIG_SNMP_ADSL_MIB" = "1" ]; then
+		IFX_CONFIG_MIB_MODULES="${IFX_CONFIG_MIB_MODULES} adslMIB"
+		IFX_CFLAGS="${IFX_CFLAGS} -DIFX_CONFIG_SNMP_ADSL_MIB"
+		if [ "$IFX_CONFIG_CPU" == "AMAZON" ]; then
+			 IFX_CFLAGS="${IFX_CFLAGS} -DAMAZON_MEI_MIB_RFC3440" 
+		elif [ "$IFX_CONFIG_CPU" == "DANUBE" ]; then
+			 IFX_CFLAGS="${IFX_CFLAGS} -DDANUBE_MEI_MIB_RFC3440" 
+		fi
+	fi
+	
+	#Added by Subbi for SNMP Transports in SNMP
+	if [ "$IFX_SNMP_TRANSPORT_ATMPVC_DOMAIN" = "1" ]; then
+		if [ "$IFX_SNMP_TRANSPORT_EOC_DOMAIN" = "1" ]; then
+			IFX_CONFIG_SNMP_TRANSPORTS="${IFX_CONFIG_SNMP_TRANSPORTS} AAL5PVC EOC"
+		else  
+			IFX_CONFIG_SNMP_TRANSPORTS="${IFX_CONFIG_SNMP_TRANSPORTS} AAL5PVC"
+		fi
+	fi
+
+if [ "$1" = "config_only" -a ! -f .config_ok -o $BUILD_CONFIGURE -eq 1 ]; then
+	make distclean
+	if [ "$BUILD_2MB_PACKAGE" = "1" ]; then
+		display_info "Configuring for 2MB pkg"
+		cp -f configure_2MB_pkg current_configuration
+		cp -f configure_2MB configure
+		cp -f Makefile.rules.2MB_pkg Makefile.rules
+	elif [ "$IFX_CONFIG_SNMPv1" = "1" ]; then
+		display_info "Configuring for SNMPv1"
+		cp -f configure_snmpv1_pkg current_configuration
+		cp -f configure_full configure
+		cp -f Makefile.rules.full Makefile.rules
+	elif [ "$IFX_CONFIG_SNMPv3" = "1" ]; then
+		display_info "Configuring for SNMPv3"
+		cp -f configure_snmpv3_pkg current_configuration
+		cp -f configure_full configure
+		cp -f Makefile.rules.full Makefile.rules 
+		IFX_CFLAGS="${IFX_CFLAGS} -DIFX_CONFIG_SNMPv3" 
+	fi
+
+	chmod a+x current_configuration
+	AR=${IFX_AR} AS=${IFX_AS} LD=${IFX_LD} NM=${IFX_NM} CC=${IFX_CC}  RANLIB=${IFX_RANLIB} BUILDCC=${IFX_HOSTCC} CXX=${IFX_CXX} OBJCOPY=${IFX_OBJCOPY} OBJDUMP=${IFX_OBJDUMP} IFX_CFLAGS=${IFX_CFLAGS} IFX_LDFLAGS=${IFX_LDFLAGS} TARGET=${TARGET} HOST=${HOST} BUILD=${BUILD} BUILD_ROOTFS_DIR=${BUILD_ROOTFS_DIR} IFX_CONFIG_SNMP_TRANSPORTS=${IFX_CONFIG_SNMP_TRANSPORTS} IFX_CONFIG_MIB_MODULES=${IFX_CONFIG_MIB_MODULES} ./current_configuration
+
+	ifx_error_check $? 
+	echo -n > .config_ok
+fi
+
+if [ "$1" = "config_only" ] ;then
+	exit 0
+fi
+
+if [ "$BUILD_2MB_PACKAGE" = "1" ]; then
+	IFX_CFLAGS="${IFX_CFLAGS} -DHAVE_MINIMAL_HELPERS -DHAVE_MINIMAL_LIBSUPPORT -DHAVE_OPTIMIZED_CODE"
+else 
+	IFX_CFLAGS="${IFX_CFLAGS}"
+fi
+
+if [ "$IFX_CONFIG_SNMPv3" = "1" ]; then
+	IFX_CFLAGS="${IFX_CFLAGS} -DIFX_CONFIG_SNMPv3" 
+fi
+
+#chandrav, for ilmid
+if [ "$IFX_CONFIG_TR037" = "1" ]; then
+        IFX_CFLAGS="${IFX_CFLAGS} -DIFX_CONFIG_TR037"
+fi
+
+make IFX_CFLAGS="${IFX_CFLAGS}" IFX_LDFLAGS="${IFX_LDFLAGS}" all
+ifx_error_check $? 
+
+if [ "$BUILD_2MB_PACKAGE" = "1" ]; then
+	install -d $BUILD_ROOTFS_DIR/usr/sbin/
+	cp -f snmpd $BUILD_ROOTFS_DIR/usr/sbin/
+else
+	make -C agent install  IFX_CFLAGS="${IFX_CFLAGS}" IFX_LDFLAGS="${IFX_LDFLAGS}"  
+	ifx_error_check $? 
+
+	make -C snmplib install IFX_CFLAGS="${IFX_CFLAGS}" IFX_LDFLAGS="${IFX_LDFLAGS}" 
+	ifx_error_check $?
+
+	rm -f ${BUILD_ROOTFS_DIR}usr/lib/libnetsnmp*.a
+	rm -f ${BUILD_ROOTFS_DIR}usr/lib/libnetsnmp*.la
+	${IFX_STRIP} --strip-unneeded ${BUILD_ROOTFS_DIR}usr/lib/libnetsnmp*
+fi
+
+${IFX_STRIP} -R.note -R.comment ${BUILD_ROOTFS_DIR}usr/sbin/snmp*
+
+fi
diff -Naur net-snmp-5.1/configure.in open_snmp/configure.in
--- net-snmp-5.1/configure.in	2003-11-06 07:41:41.000000000 +0530
+++ open_snmp/configure.in	2009-12-16 13:00:12.000000000 +0530
@@ -686,7 +686,7 @@
 AC_CANONICAL_TARGET
 changequote(, )
 PARTIALTARGETOS=`echo $target_os | sed 's/[-._].*//'`
-CFLAGS="$CFLAGS -D$PARTIALTARGETOS"
+CFLAGS="$CFLAGS -D$PARTIALTARGETOS" -Os -mips2 -mtune=4kc -Wall
 changequote([, ])
 AC_MSG_CACHE_ADD(Building for:               $PARTIALTARGETOS)
 
@@ -1067,7 +1067,7 @@
 # 
 
 AC_MSG_CHECKING([for security modules to use])
-security_def_list="usm"
+security_def_list=""
 security_src_list=""
 security_init_file="snmplib/snmpsm_init.h"
 security_incl_file="include/net-snmp/library/snmpv3-security-includes.h"
@@ -1098,10 +1098,11 @@
 
 for i in $security_def_list; do
   if echo " $new_with_out_security " | grep " $i " > /dev/null; then
-    if test "x$i" = "xusm"; then
-	echo
-        AC_MSG_ERROR(The USM security module is mandatory)
-    fi
+     :
+     #if test "x$i" = "xusm"; then
+	#echo 
+          #AC_MSG_ERROR(The USM security module is mandatory)
+    #fi
   else
     new_with_security="$new_with_security $i"
   fi
diff -Naur net-snmp-5.1/configure_2MB open_snmp/configure_2MB
--- net-snmp-5.1/configure_2MB	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/configure_2MB	2009-12-16 13:00:12.000000000 +0530
@@ -0,0 +1,27681 @@
+#! /bin/sh
+# From configure.in Revision: 5.64 .
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.57 for Net-SNMP 5.1-pre1a.
+#
+# Report bugs to <net-snmp-coders@lists.sourceforge.net>.
+#
+# Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
+# Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+
+# Support unset when possible.
+if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Find the correct PATH separator.  Usually this is `:', but
+# DJGPP uses `;' like DOS.
+if test "X${PATH_SEPARATOR+set}" != Xset; then
+  UNAME=${UNAME-`uname 2>/dev/null`}
+  case X$UNAME in
+    *-DOS) lt_cv_sys_path_separator=';' ;;
+    *)     lt_cv_sys_path_separator=':' ;;
+  esac
+  PATH_SEPARATOR=$lt_cv_sys_path_separator
+fi
+
+
+# Check that we are running under the correct shell.
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+case X$ECHO in
+X*--fallback-echo)
+  # Remove one level of quotation (which was required for Make).
+  ECHO=`echo "$ECHO" | sed 's,\\\\\$\\$0,'$0','`
+  ;;
+esac
+
+echo=${ECHO-echo}
+if test "X$1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X$1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`($echo '\t') 2>/dev/null`" = 'X\t'; then
+  # Yippee, $echo works!
+  :
+else
+  # Restart under the correct shell.
+  exec $SHELL "$0" --no-reexec ${1+"$@"}
+fi
+
+if test "X$1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<EOF
+
+EOF
+  exit 0
+fi
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+if test "X${CDPATH+set}" = Xset; then CDPATH=:; export CDPATH; fi
+
+if test -z "$ECHO"; then
+if test "X${echo_test_string+set}" != Xset; then
+# find a string as large as possible, as long as the shell can cope with it
+  for cmd in 'sed 50q "$0"' 'sed 20q "$0"' 'sed 10q "$0"' 'sed 2q "$0"' 'echo test'; do
+    # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...
+    if (echo_test_string="`eval $cmd`") 2>/dev/null &&
+       echo_test_string="`eval $cmd`" &&
+       (test "X$echo_test_string" = "X$echo_test_string") 2>/dev/null
+    then
+      break
+    fi
+  done
+fi
+
+if test "X`($echo '\t') 2>/dev/null`" = 'X\t' &&
+   echo_testing_string=`($echo "$echo_test_string") 2>/dev/null` &&
+   test "X$echo_testing_string" = "X$echo_test_string"; then
+  :
+else
+  # The Solaris, AIX, and Digital Unix default echo programs unquote
+  # backslashes.  This makes it impossible to quote backslashes using
+  #   echo "$something" | sed 's/\\/\\\\/g'
+  #
+  # So, first we look for a working echo in the user's PATH.
+
+  IFS="${IFS= 	}"; save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for dir in $PATH /usr/ucb; do
+    if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&
+       test "X`($dir/echo '\t') 2>/dev/null`" = 'X\t' &&
+       echo_testing_string=`($dir/echo "$echo_test_string") 2>/dev/null` &&
+       test "X$echo_testing_string" = "X$echo_test_string"; then
+      echo="$dir/echo"
+      break
+    fi
+  done
+  IFS="$save_ifs"
+
+  if test "X$echo" = Xecho; then
+    # We didn't find a better echo, so look for alternatives.
+    if test "X`(print -r '\t') 2>/dev/null`" = 'X\t' &&
+       echo_testing_string=`(print -r "$echo_test_string") 2>/dev/null` &&
+       test "X$echo_testing_string" = "X$echo_test_string"; then
+      # This shell has a builtin print -r that does the trick.
+      echo='print -r'
+    elif (test -f /bin/ksh || test -f /bin/ksh$ac_exeext) &&
+	 test "X$CONFIG_SHELL" != X/bin/ksh; then
+      # If we have ksh, try running configure again with it.
+      ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+      export ORIGINAL_CONFIG_SHELL
+      CONFIG_SHELL=/bin/ksh
+      export CONFIG_SHELL
+      exec $CONFIG_SHELL "$0" --no-reexec ${1+"$@"}
+    else
+      # Try using printf.
+      echo='printf %s\n'
+      if test "X`($echo '\t') 2>/dev/null`" = 'X\t' &&
+	 echo_testing_string=`($echo "$echo_test_string") 2>/dev/null` &&
+	 test "X$echo_testing_string" = "X$echo_test_string"; then
+	# Cool, printf works
+	:
+      elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
+	   test "X$echo_testing_string" = 'X\t' &&
+	   echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	   test "X$echo_testing_string" = "X$echo_test_string"; then
+	CONFIG_SHELL=$ORIGINAL_CONFIG_SHELL
+	export CONFIG_SHELL
+	SHELL="$CONFIG_SHELL"
+	export SHELL
+	echo="$CONFIG_SHELL $0 --fallback-echo"
+      elif echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
+	   test "X$echo_testing_string" = 'X\t' &&
+	   echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	   test "X$echo_testing_string" = "X$echo_test_string"; then
+	echo="$CONFIG_SHELL $0 --fallback-echo"
+      else
+	# maybe with a smaller string...
+	prev=:
+
+	for cmd in 'echo test' 'sed 2q "$0"' 'sed 10q "$0"' 'sed 20q "$0"' 'sed 50q "$0"'; do
+	  if (test "X$echo_test_string" = "X`eval $cmd`") 2>/dev/null
+	  then
+	    break
+	  fi
+	  prev="$cmd"
+	done
+
+	if test "$prev" != 'sed 50q "$0"'; then
+	  echo_test_string=`eval $prev`
+	  export echo_test_string
+	  exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} "$0" ${1+"$@"}
+	else
+	  # Oops.  We lost completely, so just stick with echo.
+	  echo=echo
+	fi
+      fi
+    fi
+  fi
+fi
+fi
+
+# Copy echo and quote the copy suitably for passing to libtool from
+# the Makefile, instead of quoting the original, which is used later.
+ECHO=$echo
+if test "X$ECHO" = "X$CONFIG_SHELL $0 --fallback-echo"; then
+   ECHO="$CONFIG_SHELL \\\$\$0 --fallback-echo"
+fi
+
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+exec 6>&1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME='Net-SNMP'
+PACKAGE_TARNAME='net-snmp'
+PACKAGE_VERSION='5.1-pre1a'
+PACKAGE_STRING='Net-SNMP 5.1-pre1a'
+PACKAGE_BUGREPORT='net-snmp-coders@lists.sourceforge.net'
+
+ac_unique_file="agent/mibgroup/ucd-snmp/extensible.c"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# if HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#if HAVE_STRING_H
+# if !STDC_HEADERS && HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#if HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#if HAVE_INTTYPES_H
+# include <inttypes.h>
+#else
+# if HAVE_STDINT_H
+#  include <stdint.h>
+# endif
+#endif
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CONFIGURE_OPTIONS LIBTOOLFLAGS INSTALL_PREFIX MAINSUBS HAVE_DMALLOC_H WRAPLIBS installucdheaders installucdlibs CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP EGREP build build_cpu build_vendor build_os host host_cpu host_vendor host_os LN_S ECHO RANLIB ac_ct_RANLIB STRIP ac_ct_STRIP LIBTOOL LIBTOOL_DEPS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA SET_MAKE PSPROG PERLPROG WHOAMI SED AUTOCONF AUTOHEADER UNAMEPROG VERSION RELEASEVERSION DEVFLAGS target target_cpu target_vendor target_os CCPATH EXTRACPPFLAGS SNMPCONFPATH transport_hdr_list transport_src_list security_src_list security_hdr_list MODULE_LIST module_list_c module_list_h module_list_o module_list_lo mibgroup_list_o mibgroup_list_lo module_list default_mibs_install PERLTARGS PERLINSTALLTARGS PERLUNINSTALLTARGS PERLARGS EMBEDPERLINSTALL EMBEDPERLUNINSTALL LPSTAT_PATH PSCMD ALLOCA LIBOBJS AGENTLIBS OTHERAGENTLIBOBJS OTHERAGENTLIBLOBJS PERSISTENT_DIRECTORY UCDPERSISTENT_DIRECTORY COPY_PERSISTENT_FILES DLLIBS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+              localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$0" : 'X\(//\)[^/]' \| \
+         X"$0" : 'X\(//\)$' \| \
+         X"$0" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+ac_env_CC_set=${CC+set}
+ac_env_CC_value=$CC
+ac_cv_env_CC_set=${CC+set}
+ac_cv_env_CC_value=$CC
+ac_env_CFLAGS_set=${CFLAGS+set}
+ac_env_CFLAGS_value=$CFLAGS
+ac_cv_env_CFLAGS_set=${CFLAGS+set}
+ac_cv_env_CFLAGS_value=$CFLAGS
+ac_env_LDFLAGS_set=${LDFLAGS+set}
+ac_env_LDFLAGS_value=$LDFLAGS
+ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
+ac_cv_env_LDFLAGS_value=$LDFLAGS
+ac_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_env_CPPFLAGS_value=$CPPFLAGS
+ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_cv_env_CPPFLAGS_value=$CPPFLAGS
+ac_env_CPP_set=${CPP+set}
+ac_env_CPP_value=$CPP
+ac_cv_env_CPP_set=${CPP+set}
+ac_cv_env_CPP_value=$CPP
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures Net-SNMP 5.1-pre1a to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat <<_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat <<\_ACEOF
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+  case $ac_init_help in
+     short | recursive ) echo "Configuration of Net-SNMP 5.1-pre1a:";;
+   esac
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-silent-libtool         Pass --silent to libtool.
+  --enable-mini-agent             Build a minimal agent.
+  --disable-agent                 Do not build the agent (snmpd).
+  --disable-applications          Do not build the apps (snmpget, ...).
+  --disable-manuals               Do not install the manuals.
+  --disable-scripts               Do not install the scripts (mib2c, ...).
+  --disable-mibs                  Do not install the mib files.
+  --disable-mib-loading            Do not include code that parses and
+                                   manipulates the mib files.
+  --enable-ipv6                   Generate IPv6 ready version.
+  --enable-local-smux             Restrict SMUX connections to localhost (by default).
+  --enable-debugging              Outputs extra debugging information at all
+                                  times.  Normally, you should not enable this,
+                                  but instead use the -D flag of the commands,
+                                  which toggles debbuging output at runtime.
+  --disable-debugging             Disallows debugging code to be built in.
+                                  This might provide some speed benefits.
+  --enable-developer              Turns on super-duper-extra-compile-warnings
+                                  when using gcc.
+  --disable-privacy               Don't compile in support for privacy.
+  --enable-internal-md5           Use the internal MD5 support.
+  --enable-testing-code           Enables some code sections that should
+                                  only be used for testing of certain
+                                  SNMP functionalities.  This should *not*
+                                  be turned on for production use.  Ever.
+  --enable-reentrant              Enables locking functions that protect
+                                  library resources in some multi-threading
+                                  environments.  This does not guarantee
+                                  thread-safe operation.
+                                  Currently an experimental setting.
+
+  --enable-embedded-perl          Embed perl in the SNMP agent.
+                                  forces --with-perl-modules as well.
+
+--enable-ucd-snmp-compatibility  Install ucd-snmp look-alike headers and libs.
+  --enable-shared=PKGS  build shared libraries default=yes
+  --enable-static=PKGS  build static libraries default=yes
+  --enable-fast-install=PKGS  optimize for fast installation default=yes
+  --disable-libtool-lock  avoid locking (might break parallel builds)
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+
+Compiler Options:
+  --with-cc=CC                    use CC to compile (default=gcc).
+  --with-ar=AR                    use AR as the archiver.
+  --with-endianness=big|little    define endianness of target platform when
+                                  cross-compiling.
+  --with-cflags=CFLAGS            use CFLAGS as compile time arguments.
+  --with-ldflags=LDFLAGS          use LDFLAGS as link time arguments to ld.
+  --with-libs=LIBS                use LIBS as link time arguments to ld.
+  --with-install-prefix=PATH      Just for installing, prefix all
+                                  directories with PATH.  This is known not
+                                  to work on some systems with shared
+                                  libraries (eg, HPUX)
+  --with-dmalloc=PATH             Use dmalloc library (www.dmalloc.com)
+  --with-efence                   Look for and use libefence (malloc).
+  --with-rsaref=PATH              Look for librsaref in PATH/lib.
+  --with-openssl=PATH             Look for openssl in PATH/lib.
+  --without-rpm                  Don't include support for the RPM package
+                                 management system when building the host MIB
+                                 module.
+  --without-opaque-special-types  Don't use special opaque encodings.
+                                  SNMP normally cannot handle
+                                  floating numbers, nor large 64 bit
+                                  integers well.  By default, the
+                                  net-snmp package compiles in
+                                  support for these extra datatypes
+                                  (in a legal way)
+  --with-mibdirs=\"dir1:dir2:\"     Default directories to look for mibs.
+                                    (Default: \$HOME/.snmp/mibs:DATADIR/snmp/mibs)
+  --with-mibs=\"item1:item2:\"      Default mib IDs to read.
+                                    (The default list is \"IP-MIB:IF-MIB:
+                                    TCP-MIB:UDP-MIB:SNMPv2-MIB:RFC1213-MIB\"
+                                    with the addition of any mibs used
+                                    by the mib modules the agent is
+                                    configured with)
+  --with-mibfiles=\"file1:file2\"   Default mib files to load.
+                                    (Default:  none.  uses IDs above instead.)
+
+Configuring the agent:
+  --without-root-access           The snmpd agent won't require root access to
+                                  run it.  The information it returns in the
+                                  mib-II tree may not be correct, however.
+
+Configuring the agent:
+  --without-kmem-usage            Do not include any code related to the use
+                                  of kmem. This option can only be used with
+                                  the option --enable-mini-agent.
+  --with-dummy-values             Provide 'placeholder' dummy values where
+                                  the necessary information is not available.
+                                  This is technically not compliant with the
+                                  SNMP specifications, but was how the agent
+                                  operated for versions < 4.0.
+  --with-persistent-directory=\"directory\"
+                                  Default directory for persistent data storage.
+  --with-copy-persistent-files=\"no\" Don't copy persistent files
+                                       (or use \"yes\" to copy them).
+                                       (Default: yes)
+  --with-default-snmp-version=\"3\" Default version of SNMP to use.
+                                  (Default: 3)
+                                  Legal values: 1, 2 (for SNMPv2c) or 3.
+  --with-sys-contact=\"who@where\"  Default system contact.
+                                    (Default: LOGIN@DOMAINNAME)
+  --with-sys-location=\"location\"  Default system location.
+                                    (Default: Unknown)
+  --with-logfile=\"location\"       Default log file location for snmpd.
+  --with-transports=\"t1 t2 ...\"   Compile in the given SNMP transport
+                                    modules (space separated list).
+  --with-out-transports=\"t1 ...\"  Exclude listed SNMP transports
+                                    (space separated list).
+
+  Available SNMP transport modules are:
+
+    UDP         support for SNMP over UDP/IP.
+                This transport is always compiled in.
+    UDPIPv6     support for SNMP over UDP/IPv6.
+                This transport is available for Linux, Solaris and
+                FreeBSD.
+                It is never compiled in by default.
+    TCPIPv6     support for SNMP over UDP/IPv6.
+                This transport is available for Linux, Solaris and
+                FreeBSD.
+                It is never compiled in by default.
+    TCP         support for SNMP over TCP/IP.
+                This transport is compiled in by default, but may be omitted.
+    Unix        support for SNMP over Unix domain protocols.
+                This transport is compiled in by default except on Win32
+                platforms, and may be omitted.
+    Callback    support for SNMP over an internal locally connected pair
+                of snmp_sessions.
+    AAL5PVC     support for SNMP over AAL5 PVCs.
+                This transport is presently only available for Linux,
+                is never compiled in by default and may be omitted.
+    IPX         support for SNMP over IPX per RFC 1420.
+                This transport is presently only available for Linux,
+                is never compiled in by default and may be omitted.
+
+
+  --with-security-modules=\"s1 s2 ...\"   Compile in the given SNMP security
+                                    module services (space separated list).
+
+  Available SNMP security services:
+
+        usm                support for user based SNMP security
+                           (required and always compiled in)
+        ksm                support for kerberos based SNMP security
+
+  --with-mib-modules=\"item1 ...\"  Compile with additional mib modules
+                                    (Space separated list).
+  --with-out-mib-modules=\"list\"   Compile without these mib modules.
+
+  Default mib modules compiled into the agent (which can be removed):
+
+    mibII                  support for the mib-II tree.
+    snmpv3mibs             support for the snmpv3 mib modules.
+    ucd_snmp               UCD-SNMP-MIB specific extensions.
+    agent_mibs             NET-SNMP-AGENT-MIB extensions
+    agentx                 (see below)
+    notification           mibs supporting specification of trap destinations.
+    target                 Support for the SNMP WGs TARGET-MIB.
+    utilities              general agent configuration utilities.
+
+  Optional mib modules that can be built into the agent include:
+    host                   host resources mib support.
+    disman/event-mib       support for the DISMAN-EVENT-MIB (beta)
+                             (supports self monitoring and notification
+                              delivery when error conditions are found)
+    smux                   smux support to allow subagents to attach to snmpd.
+    mibII/mta_sendmail     Sendmail statistics monitoring (MTA-MIB)
+    misc/ipfwacc           accounting rules IP firewall information (linux).
+    ipfwchains/ipfwchains  firewall chains under ipfw for linux.
+                           (Download separately from the ucd-snmp ftp site.)
+    ucd-snmp/diskio        Table of io-devices and how much data they have
+                           read/written.  (only tested on Solaris, Linux)
+    tunnel                 Linux TUNNEL-MIB support (ifTable extension)
+
+  AgentX support:
+    agentx/subagent        allows the agent to run as either a snmp agent
+                           or as an agentX sub-agent.
+    agentx/master          makes the agent run as an agentX master agent
+                           as well as a normal snmp agent.
+    agentx                 includes both agentx/master and agentx/client.
+
+  Optional modules for C coders to look at and/or include as extension examples:
+
+    examples/ucdDemoPublic  SNMPv3 interoperability testing mib.
+    examples/example        example C code extension.
+Enterprise OIDs:  (warning: this should be used with caution.)
+
+  --with-enterprise-oid              The enterprise number assigned to the
+                                     vendor by IANA.  See
+                                     http://www.iana.org/cgi-bin/enterprise.pl
+                                     to get one, though using the default is
+                                     probably the right choice is most cases.
+                                     (default 8072 = "enterprise.net-snmp")
+
+  --with-enterprise-sysoid           The base OID for the sysObjectID
+                                     of the system group
+                                     (default .1.3.6.1.4.1.8072.3.2... =
+                                      "netSnmpAgentOIDs...")
+
+  --with-enterprise-notification-oid The OID used for the root of
+				     enterprise specific notifications.
+                                     (default .1.3.6.1.4.1.2021 = "enterprise.ucdavis")
+
+Perl:
+  --with-perl-modules=ARGS      Install the perl modules along with the rest
+                                  of the net-snmp toolkit.  If ARGS is
+                                  specified, they're passed to the
+                                  Makefile.PL script.
+
+Miscellaneous:
+  --with-defaults          Use defaults for prompted values.
+  --with-gnu-ld           assume the C compiler uses GNU ld default=no
+  --with-pic              try to use only PIC/non-PIC objects default=use both
+  --with-libwrap=LIBPATH Compile in libwrap (tcp_wrappers) support.
+  --with-zlib=DIR        use libz in DIR
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
+              headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to <net-snmp-coders@lists.sourceforge.net>.
+_ACEOF
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
+# absolute.
+ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
+ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
+ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
+ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+           test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n "$ac_init_help" && exit 0
+if $ac_init_version; then
+  cat <<\_ACEOF
+Net-SNMP configure 5.1-pre1a
+generated by GNU Autoconf 2.57
+
+Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
+Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5>config.log
+cat >&5 <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by Net-SNMP $as_me 5.1-pre1a, which was
+generated by GNU Autoconf 2.57.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+        ac_must_keep_next=false # Got value, back to normal.
+      else
+        case $ac_arg in
+          *=* | --config-cache | -C | -disable-* | --disable-* \
+          | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+          | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+          | -with-* | --with-* | -without-* | --without-* | --x)
+            case "$ac_configure_args0 " in
+              "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+            esac
+            ;;
+          -* ) ac_must_keep_next=true ;;
+        esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2>&1 |
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      sed -n \
+        "s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+    	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
+    *)
+      sed -n \
+        "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+}
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+        echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed "/^$/d" confdefs.h | sort
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core core.* *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2>&1 |
+               sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+        { echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+        { echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+        { echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+        ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+          ac_config_headers="$ac_config_headers include/net-snmp/net-snmp-config.h"
+
+
+
+  rm -f configure-summary
+
+
+#
+# save the configure arguments
+#
+cat >>confdefs.h <<_ACEOF
+#define CONFIGURE_OPTIONS "\"$ac_configure_args\""
+_ACEOF
+
+CONFIGURE_OPTIONS="\"$ac_configure_args\""
+
+
+#
+# Compilation setup
+#
+
+# Check whether --with-cc or --without-cc was given.
+if test "${with_cc+set}" = set; then
+  withval="$with_cc"
+  CC=$with_cc;export CC
+fi;
+
+
+# Check whether --with-ar or --without-ar was given.
+if test "${with_ar+set}" = set; then
+  withval="$with_ar"
+  AR=$with_ar; export AR
+fi;
+
+
+# Check whether --with-endianness or --without-endianness was given.
+if test "${with_endianness+set}" = set; then
+  withval="$with_endianness"
+  if test $with_endianness != "big" -a $with_endianness != "little" ; then
+       { { echo "$as_me:$LINENO: error: Endianness must be big or little, not \"$with_endianness\"." >&5
+echo "$as_me: error: Endianness must be big or little, not \"$with_endianness\"." >&2;}
+   { (exit 1); exit 1; }; };
+     fi
+
+fi;
+
+
+# Check whether --with-cflags or --without-cflags was given.
+if test "${with_cflags+set}" = set; then
+  withval="$with_cflags"
+  CFLAGS=$with_cflags; export CFLAGS
+fi;
+
+
+# Check whether --with-ldflags or --without-ldflags was given.
+if test "${with_ldflags+set}" = set; then
+  withval="$with_ldflags"
+  LDFLAGS=$with_ldflags; export LDFLAGS
+fi;
+
+
+# Check whether --with-libs or --without-libs was given.
+if test "${with_libs+set}" = set; then
+  withval="$with_libs"
+  LIBS=$with_libs; export LIBS
+fi;
+
+# Check whether --enable-silent-libtool or --disable-silent-libtool was given.
+if test "${enable_silent_libtool+set}" = set; then
+  enableval="$enable_silent_libtool"
+  LIBTOOLFLAGS=--silent
+fi;
+
+
+
+# Check whether --with-install-prefix or --without-install-prefix was given.
+if test "${with_install_prefix+set}" = set; then
+  withval="$with_install_prefix"
+  INSTALL_PREFIX="$withval"
+fi;
+
+if test "x$INSTALL_PREFIX" = "xyes" ; then
+  { { echo "$as_me:$LINENO: error: --with-install-prefix requires an argument" >&5
+echo "$as_me: error: --with-install-prefix requires an argument" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test "x$INSTALL_PREFIX" = "xno" ; then
+  INSTALL_PREFIX=""
+fi
+
+
+# Check whether --enable-mini_agent or --disable-mini_agent was given.
+if test "${enable_mini_agent+set}" = set; then
+  enableval="$enable_mini_agent"
+  mini_agent="yes"
+else
+  mini_agent="no"
+fi;
+
+# Check whether --enable-agent or --disable-agent was given.
+if test "${enable_agent+set}" = set; then
+  enableval="$enable_agent"
+
+fi;
+if test "x$enable_agent" != "xno"; then
+   MAINSUBS="$MAINSUBS agent"
+fi
+
+# Check whether --enable-applications or --disable-applications was given.
+if test "${enable_applications+set}" = set; then
+  enableval="$enable_applications"
+
+fi;
+if test "x$enable_applications" != "xno"; then
+   MAINSUBS="$MAINSUBS apps"
+fi
+
+# Check whether --enable-manuals or --disable-manuals was given.
+if test "${enable_manuals+set}" = set; then
+  enableval="$enable_manuals"
+
+fi;
+if test "x$enable_manuals" != "xno"; then
+   MAINSUBS="$MAINSUBS man"
+fi
+
+# Check whether --enable-scripts or --disable-scripts was given.
+if test "${enable_scripts+set}" = set; then
+  enableval="$enable_scripts"
+
+fi;
+if test "x$enable_scripts" != "xno"; then
+   MAINSUBS="$MAINSUBS local"
+fi
+
+# Check whether --enable-mibs or --disable-mibs was given.
+if test "${enable_mibs+set}" = set; then
+  enableval="$enable_mibs"
+
+fi;
+if test "x$enable_mibs" != "xno"; then
+   MAINSUBS="$MAINSUBS mibs"
+fi
+
+
+echo "$as_me:$LINENO: checking what to build and install" >&5
+echo $ECHO_N "checking what to build and install... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $MAINSUBS" >&5
+echo "${ECHO_T}$MAINSUBS" >&6
+
+# Check whether --enable-mib-loading or --disable-mib-loading was given.
+if test "${enable_mib_loading+set}" = set; then
+  enableval="$enable_mib_loading"
+
+fi;
+if test "x$enable_mib_loading" = "xno"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define DISABLE_MIB_LOADING 1
+_ACEOF
+
+fi
+
+# Check whether --enable-ipv6 or --disable-ipv6 was given.
+if test "${enable_ipv6+set}" = set; then
+  enableval="$enable_ipv6"
+  if test "x$enable_ipv6" = "xyes"; then
+      cat >>confdefs.h <<\_ACEOF
+#define INET6 1
+_ACEOF
+
+    fi
+fi;
+
+# Check whether --enable-local-smux or --disable-local-smux was given.
+if test "${enable_local_smux+set}" = set; then
+  enableval="$enable_local_smux"
+  if test "x$local_smux" = "xyes"; then
+      cat >>confdefs.h <<\_ACEOF
+#define LOCAL_SMUX 1
+_ACEOF
+
+    fi
+fi;
+
+# Check whether --enable-debugging or --disable-debugging was given.
+if test "${enable_debugging+set}" = set; then
+  enableval="$enable_debugging"
+  cat >>confdefs.h <<\_ACEOF
+#define SNMP_ALWAYS_DEBUG 1
+_ACEOF
+
+fi;
+
+# Check whether --enable-developer or --disable-developer was given.
+if test "${enable_developer+set}" = set; then
+  enableval="$enable_developer"
+  developer=yes
+fi;
+
+if test "x$enable_debugging" = "xno"; then
+    cat >>confdefs.h <<\_ACEOF
+#define SNMP_NO_DEBUGGING 1
+_ACEOF
+
+fi
+
+
+# Check whether --with-dmalloc or --without-dmalloc was given.
+if test "${with_dmalloc+set}" = set; then
+  withval="$with_dmalloc"
+  if test "x$withval" = "xyes"; then
+      LIBS="$LIBS -ldmalloc"
+      cat >>confdefs.h <<\_ACEOF
+#define HAVE_DMALLOC_H 1
+_ACEOF
+
+    elif test -d "$withval"; then
+
+  if test "x$withval" != x -a -d $withval; then
+     if test -d $withval/lib; then
+       LDFLAGS="-L$withval/lib $LDFLAGS"
+     fi
+     if test -d $withval/include; then
+	CPPFLAGS="-I$withval/include $CPPFLAGS"
+     fi
+  fi
+
+      LIBS="$LIBS -ldmalloc"
+      cat >>confdefs.h <<\_ACEOF
+#define HAVE_DMALLOC_H 1
+_ACEOF
+
+    fi
+
+fi;
+
+
+
+# Check whether --with-efence or --without-efence was given.
+if test "${with_efence+set}" = set; then
+  withval="$with_efence"
+  use_efence="$withval"
+fi;
+
+tryrsaref=no
+
+# Check whether --with-rsaref or --without-rsaref was given.
+if test "${with_rsaref+set}" = set; then
+  withval="$with_rsaref"
+  if test "x$withval" = "xyes"; then
+      tryrsaref=yes
+    elif test "x$withval" = "xno"; then
+      tryrsaref=no
+    elif test -d "$withval"; then
+
+  if test "x$withval" != x -a -d $withval; then
+     if test -d $withval/lib; then
+       LDFLAGS="-L$withval/lib $LDFLAGS"
+     fi
+     if test -d $withval/include; then
+	CPPFLAGS="-I$withval/include $CPPFLAGS"
+     fi
+  fi
+
+      tryrsaref=yes
+    fi
+fi;
+
+tryopenssl=defaultyes
+askedopenssl=no
+
+# Check whether --with-openssl or --without-openssl was given.
+if test "${with_openssl+set}" = set; then
+  withval="$with_openssl"
+  if test "x$withval" = "xyes"; then
+      tryopenssl=yes
+      askedopenssl=yes
+    elif test "x$withval" = "xno"; then
+      tryopenssl=no
+    elif test -d "$withval"; then
+
+  if test "x$withval" != x -a -d $withval; then
+     if test -d $withval/lib; then
+       LDFLAGS="-L$withval/lib $LDFLAGS"
+     fi
+     if test -d $withval/include; then
+	CPPFLAGS="-I$withval/include $CPPFLAGS"
+     fi
+  fi
+
+      tryopenssl=yes
+      askedopenssl=yes
+    fi
+fi;
+if test "x$tryopenssl" = "xdefaultyes"; then
+
+  if test "x/usr/local/ssl" != x -a -d /usr/local/ssl; then
+     if test -d /usr/local/ssl/lib; then
+       LDFLAGS="-L/usr/local/ssl/lib $LDFLAGS"
+     fi
+     if test -d /usr/local/ssl/include; then
+	CPPFLAGS="-I/usr/local/ssl/include $CPPFLAGS"
+     fi
+  fi
+
+      tryopenssl=yes
+fi
+
+
+# Check whether --with-rpm or --without-rpm was given.
+if test "${with_rpm+set}" = set; then
+  withval="$with_rpm"
+
+fi;
+
+# Check whether --enable-privacy or --disable-privacy was given.
+if test "${enable_privacy+set}" = set; then
+  enableval="$enable_privacy"
+
+fi;
+if test "x$enable_privacy" != "xno"; then
+  cat >>confdefs.h <<\_ACEOF
+#define SCAPI_AUTHPRIV 1
+_ACEOF
+
+fi
+
+# Check whether --enable-internal-md5 or --disable-internal-md5 was given.
+if test "${enable_internal_md5+set}" = set; then
+  enableval="$enable_internal_md5"
+  cat >>confdefs.h <<\_ACEOF
+#define USE_INTERNAL_MD5 1
+_ACEOF
+
+fi;
+
+
+
+# Check whether --with-opaque-special-types or --without-opaque-special-types was given.
+if test "${with_opaque_special_types+set}" = set; then
+  withval="$with_opaque_special_types"
+
+fi;
+
+
+# Check whether --with-mibdirs or --without-mibdirs was given.
+if test "${with_mibdirs+set}" = set; then
+  withval="$with_mibdirs"
+  DEFAULT_MIBDIRS="$with_mibdirs"
+    cat >>confdefs.h <<_ACEOF
+#define DEFAULT_MIBDIRS "$with_mibdirs"
+_ACEOF
+
+fi;
+
+
+# Check whether --with-mibs or --without-mibs was given.
+if test "${with_mibs+set}" = set; then
+  withval="$with_mibs"
+  DEFAULT_MIBS="$with_mibs"
+fi;
+
+
+# Check whether --with-mibfiles or --without-mibfiles was given.
+if test "${with_mibfiles+set}" = set; then
+  withval="$with_mibfiles"
+  cat >>confdefs.h <<_ACEOF
+#define DEFAULT_MIBFILES "$with_mibfiles"
+_ACEOF
+
+fi;
+
+
+# Check whether --enable-testing-code or --disable-testing-code was given.
+if test "${enable_testing_code+set}" = set; then
+  enableval="$enable_testing_code"
+  cat >>confdefs.h <<\_ACEOF
+#define SNMP_TESTING_CODE 1
+_ACEOF
+
+fi;
+
+# Check whether --enable-reentrant or --disable-reentrant was given.
+if test "${enable_reentrant+set}" = set; then
+  enableval="$enable_reentrant"
+  with_res_locks="yes"
+else
+  with_res_locks="no"
+fi;
+
+
+# Check whether --with-root-access or --without-root-access was given.
+if test "${with_root_access+set}" = set; then
+  withval="$with_root_access"
+
+fi;
+
+
+# Check whether --with-kmem-usage or --without-kmem-usage was given.
+if test "${with_kmem_usage+set}" = set; then
+  withval="$with_kmem_usage"
+
+fi;
+
+
+# Check whether --with-dummy-values or --without-dummy-values was given.
+if test "${with_dummy_values+set}" = set; then
+  withval="$with_dummy_values"
+
+fi;
+
+
+# Check whether --with-persistent-directory or --without-persistent-directory was given.
+if test "${with_persistent_directory+set}" = set; then
+  withval="$with_persistent_directory"
+  ac_cv_user_prompt_PERSISTENT_DIRECTORY="$with_persistent_directory"
+fi;
+
+
+# Check whether --with-copy_persistent_files or --without-copy_persistent_files was given.
+if test "${with_copy_persistent_files+set}" = set; then
+  withval="$with_copy_persistent_files"
+  ac_cv_user_prompt_COPY_PERSISTENT_FILES="$with_copy_persistent_files"
+fi;
+
+
+# Check whether --with-default-snmp-version or --without-default-snmp-version was given.
+if test "${with_default_snmp_version+set}" = set; then
+  withval="$with_default_snmp_version"
+  ac_cv_user_prompt_DEFAULT_SNMP_VERSION="$with_default_snmp_version"
+fi;
+
+# we test this now and later as well.  we test it now so configure can die
+# early on with an error rather than waiting till the end of the script.
+if test "x$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "x"; then
+  if test "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "1" -a "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "2" -a "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "3"; then
+    { { echo "$as_me:$LINENO: error: Illegal version number passed to --with-default-snmp-version" >&5
+echo "$as_me: error: Illegal version number passed to --with-default-snmp-version" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+fi
+
+
+# Check whether --with-sys_contact or --without-sys_contact was given.
+if test "${with_sys_contact+set}" = set; then
+  withval="$with_sys_contact"
+  ac_cv_user_prompt_SYS_CONTACT="$with_sys_contact"
+fi;
+
+
+# Check whether --with-sys_location or --without-sys_location was given.
+if test "${with_sys_location+set}" = set; then
+  withval="$with_sys_location"
+  ac_cv_user_prompt_SYS_LOC="$with_sys_location"
+fi;
+
+
+# Check whether --with-logfile or --without-logfile was given.
+if test "${with_logfile+set}" = set; then
+  withval="$with_logfile"
+  ac_cv_user_prompt_LOGFILE="$with_logfile"
+fi;
+
+# This can't be within AC_ARG_WITH.  I don't want to read autoconf m4
+# to find out why.
+
+
+
+# Check whether --with-transports or --without-transports was given.
+if test "${with_transports+set}" = set; then
+  withval="$with_transports"
+
+fi;
+
+# Check whether --with-out_transports or --without-out_transports was given.
+if test "${with_out_transports+set}" = set; then
+  withval="$with_out_transports"
+
+fi;
+
+#
+# Catch common mistakes in transport options
+#
+
+# Check whether --with-transport or --without-transport was given.
+if test "${with_transport+set}" = set; then
+  withval="$with_transport"
+  { { echo "$as_me:$LINENO: error:  Invalid option. Use --with-transports instead " >&5
+echo "$as_me: error:  Invalid option. Use --with-transports instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+# Check whether --with-out-transport or --without-out-transport was given.
+if test "${with_out_transport+set}" = set; then
+  withval="$with_out_transport"
+  { { echo "$as_me:$LINENO: error:  Invalid option. Use --with-out-transports instead " >&5
+echo "$as_me: error:  Invalid option. Use --with-out-transports instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+#
+# security modules
+#
+
+
+# Check whether --with-security-modules or --without-security-modules was given.
+if test "${with_security_modules+set}" = set; then
+  withval="$with_security_modules"
+
+fi;
+
+#
+# mib modules
+#
+
+
+# Check whether --with-mib_modules or --without-mib_modules was given.
+if test "${with_mib_modules+set}" = set; then
+  withval="$with_mib_modules"
+
+fi;
+
+
+# Check whether --with-out_mib_modules or --without-out_mib_modules was given.
+if test "${with_out_mib_modules+set}" = set; then
+  withval="$with_out_mib_modules"
+
+fi;
+
+
+#
+
+# Check whether --with-enterprise-oid or --without-enterprise-oid was given.
+if test "${with_enterprise_oid+set}" = set; then
+  withval="$with_enterprise_oid"
+
+  if test "$withval" = yes; then
+    { { echo "$as_me:$LINENO: error:  Please provide a value for the enterprise number " >&5
+echo "$as_me: error:  Please provide a value for the enterprise number " >&2;}
+   { (exit 1); exit 1; }; };
+  fi
+  cat >>confdefs.h <<_ACEOF
+#define ENTERPRISE_OID $withval
+_ACEOF
+
+  ent_oid="1,3,6,1,4,1,$withval"
+  cat >>confdefs.h <<_ACEOF
+#define ENTERPRISE_MIB $ent_oid
+_ACEOF
+
+  ent_dot_oid="1.3.6.1.4.1.$withval"
+  cat >>confdefs.h <<_ACEOF
+#define ENTERPRISE_DOT_MIB $ent_dot_oid
+_ACEOF
+
+  echo "$as_me:$LINENO: result: using enterprise number $withval" >&5
+echo "${ECHO_T}using enterprise number $withval" >&6
+
+else
+
+  echo "$as_me:$LINENO: result: using default \"enterprise.net-snmp\"" >&5
+echo "${ECHO_T}using default \"enterprise.net-snmp\"" >&6
+
+fi;
+
+
+# Check whether --with-enterprise-sysoid or --without-enterprise-sysoid was given.
+if test "${with_enterprise_sysoid+set}" = set; then
+  withval="$with_enterprise_sysoid"
+
+  if test "$withval" = yes; then
+    { { echo "$as_me:$LINENO: error:  Please provide a base OID value " >&5
+echo "$as_me: error:  Please provide a base OID value " >&2;}
+   { (exit 1); exit 1; }; };
+  fi
+  sys_oid=`echo "$withval" | sed 's/^\.//' | sed 's/\./\,/g'`
+  cat >>confdefs.h <<_ACEOF
+#define SYSTEM_MIB $sys_oid
+_ACEOF
+
+  sys_dot_oid=`echo "$withval" | sed 's/^\.//'`
+  cat >>confdefs.h <<_ACEOF
+#define SYSTEM_DOT_MIB $sys_dot_oid
+_ACEOF
+
+  sysoid_len=`echo "$withval" | sed 's/^\.//g' | awk -F\. '{ print NF }'`
+  cat >>confdefs.h <<_ACEOF
+#define SYSTEM_DOT_MIB_LENGTH $sysoid_len
+_ACEOF
+
+  echo "$as_me:$LINENO: result: using enterprise sysOID $withval ...." >&5
+echo "${ECHO_T}using enterprise sysOID $withval ...." >&6
+
+else
+
+  echo "$as_me:$LINENO: result: using default enterprise sysOID \"NET-SNMP-MIB::netSnmpAgentOIDs...\"" >&5
+echo "${ECHO_T}using default enterprise sysOID \"NET-SNMP-MIB::netSnmpAgentOIDs...\"" >&6
+
+fi;
+
+
+# Check whether --with-enterprise-notification-oid or --without-enterprise-notification-oid was given.
+if test "${with_enterprise_notification_oid+set}" = set; then
+  withval="$with_enterprise_notification_oid"
+
+  if test "$withval" = yes; then
+    { { echo "$as_me:$LINENO: error:  Please provide a base OID value " >&5
+echo "$as_me: error:  Please provide a base OID value " >&2;}
+   { (exit 1); exit 1; }; };
+  fi
+  notification_oid=`echo "$withval" | sed 's/^\.//' | sed 's/\./\,/g'`
+  cat >>confdefs.h <<_ACEOF
+#define NOTIFICATION_MIB $notification_oid
+_ACEOF
+
+  notification_dot_oid=`echo "$withval" | sed 's/^\.//'`
+  cat >>confdefs.h <<_ACEOF
+#define NOTIFICATION_DOT_MIB $notification_dot_oid
+_ACEOF
+
+  notificationoid_len=`echo "$withval" | sed 's/^\.//g' | awk -F\. '{ print NF }'`
+  cat >>confdefs.h <<_ACEOF
+#define NOTIFICATION_DOT_MIB_LENGTH $notificationoid_len
+_ACEOF
+
+  echo "$as_me:$LINENO: result: using enterprise notifications $withval" >&5
+echo "${ECHO_T}using enterprise notifications $withval" >&6
+
+else
+
+  echo "$as_me:$LINENO: result: using default notifications \"NET-SNMP-MIB::netSnmpNotifications\"" >&5
+echo "${ECHO_T}using default notifications \"NET-SNMP-MIB::netSnmpNotifications\"" >&6
+
+fi;
+#
+# Catch common mistakes in configure options
+#
+
+# Check whether --with-mib-module or --without-mib-module was given.
+if test "${with_mib_module+set}" = set; then
+  withval="$with_mib_module"
+  { { echo "$as_me:$LINENO: error:  Invalid option1. Use --with-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option1. Use --with-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+# Check whether --with-module or --without-module was given.
+if test "${with_module+set}" = set; then
+  withval="$with_module"
+  { { echo "$as_me:$LINENO: error:  Invalid option3. Use --with-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option3. Use --with-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+# Check whether --with-modules or --without-modules was given.
+if test "${with_modules+set}" = set; then
+  withval="$with_modules"
+  { { echo "$as_me:$LINENO: error:  Invalid option4. Use --with-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option4. Use --with-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+
+# Check whether --with-out-mib-module or --without-out-mib-module was given.
+if test "${with_out_mib_module+set}" = set; then
+  withval="$with_out_mib_module"
+  { { echo "$as_me:$LINENO: error:  Invalid option5. Use --with-out-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option5. Use --with-out-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+# Check whether --with-out-modules or --without-out-modules was given.
+if test "${with_out_modules+set}" = set; then
+  withval="$with_out_modules"
+  { { echo "$as_me:$LINENO: error:  Invalid option7. Use --with-out-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option7. Use --with-out-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+# Check whether --with-out-module or --without-out-module was given.
+if test "${with_out_module+set}" = set; then
+  withval="$with_out_module"
+  { { echo "$as_me:$LINENO: error:  Invalid option8. Use --with-out-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option8. Use --with-out-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+#
+# Perl specific
+#
+
+# Check whether --with-perl-modules or --without-perl-modules was given.
+if test "${with_perl_modules+set}" = set; then
+  withval="$with_perl_modules"
+
+    install_perl=yes
+    if test "$withval" = yes; then
+      PERLARGS=""
+    else
+      PERLARGS="$withval"
+    fi
+
+fi;
+
+# Check whether --enable-embedded-perl or --disable-embedded-perl was given.
+if test "${enable_embedded_perl+set}" = set; then
+  enableval="$enable_embedded_perl"
+  embed_perl="yes"
+else
+  embed_perl="no"
+fi;
+
+# Common perl mistakes
+# Check whether --enable-perl-modules or --disable-perl-modules was given.
+if test "${enable_perl_modules+set}" = set; then
+  enableval="$enable_perl_modules"
+  { { echo "$as_me:$LINENO: error:  Invalid option. Use --with-perl-modules instead " >&5
+echo "$as_me: error:  Invalid option. Use --with-perl-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+#
+# otherwise prompted information
+#
+
+# Check whether --with-defaults or --without-defaults was given.
+if test "${with_defaults+set}" = set; then
+  withval="$with_defaults"
+  defaults="yes"
+else
+  defaults="no"
+fi;
+
+# Check whether --enable-ucd-snmp-compatibility or --disable-ucd-snmp-compatibility was given.
+if test "${enable_ucd_snmp_compatibility+set}" = set; then
+  enableval="$enable_ucd_snmp_compatibility"
+  ucd_compat=yes
+else
+  ucd_compat=no
+fi;
+#
+# setup install targets
+#
+if test "x$ucd_compat" != "xno" ; then
+  installucdheaders=installucdheaders
+  installucdlibs=installucdlibs
+
+  cat >> configure-summary << EOF
+  UCD-SNMP compatability:     enabled
+EOF
+
+fi
+
+
+
+# Only define if specifically chosen as --without (i.e., default to true).
+if test "x$with_root_access" = "xno"; then
+  cat >>confdefs.h <<\_ACEOF
+#define NO_ROOT_ACCESS 1
+_ACEOF
+
+fi
+
+# Only define if specifically chosen as --without (i.e., default to true).
+if test "x$with_kmem_usage" = "xno"; then
+  cat >>confdefs.h <<\_ACEOF
+#define NO_KMEM_USAGE 1
+_ACEOF
+
+fi
+
+# Define unless specifically suppressed (i.e., option defaults to false).
+if test "x$with_dummy_values" != "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define NO_DUMMY_VALUES 1
+_ACEOF
+
+fi
+
+# Only define if specifically chosen as --without (i.e., default to true).
+if test "x$with_opaque_special_types" != "xno"; then
+  cat >>confdefs.h <<\_ACEOF
+#define OPAQUE_SPECIAL_TYPES 1
+_ACEOF
+
+fi
+
+
+# overflow problems with hpux's sh
+# taken from Perl's Configure script
+
+echo "$as_me:$LINENO: checking if I need to feed myself to ksh" >&5
+echo $ECHO_N "checking if I need to feed myself to ksh... $ECHO_C" >&6
+if test -f /hp-ux -a -f /bin/ksh; then
+  if (PATH=.; alias -x) >/dev/null 2>&1; then
+    echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+  else
+    echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+    if test "x$1" = "x"; then
+      exec /bin/ksh $0
+    else
+      exec /bin/ksh $0 "$@"
+    fi
+  fi
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+if test "x$developer" != "xno" -a -f $srcdir/remove-files; then
+  # turn on the developer flag when taken from a CVS checkout (not a release)
+  developer="yes"
+fi
+
+# disable --enable-shared by default in cvs/developer cases.
+if test "x$developer" = "xyes"; then
+  # don't do anything if option set via cmdline
+  if test "${enable_shared+set}" != set; then
+    enable_shared=no
+  fi
+fi
+
+# perl requires shared libs
+if test "x$embed_perl" = "xyes"; then
+    if test "x$enable_shared" != "xyes"; then
+      { { echo "$as_me:$LINENO: error: --enable-embedded-perl requires --enable-shared" >&5
+echo "$as_me: error: --enable-embedded-perl requires --enable-shared" >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+fi
+
+# AIX has problems with shared libs
+case $target_os in
+    aix*)
+        echo "$as_me:$LINENO: checking whether using AIX and if we should disable shared libraries" >&5
+echo $ECHO_N "checking whether using AIX and if we should disable shared libraries... $ECHO_C" >&6
+	echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	enable_shared=no
+        ;;
+    *)
+        ;;
+esac
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$ac_ct_CC" && break
+done
+
+  CC=$ac_ct_CC
+fi
+
+fi
+
+
+test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+
+# Provide some information about the compiler.
+echo "$as_me:$LINENO:" \
+     "checking for C compiler version" >&5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
+  (eval $ac_compiler --version </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -v </dev/null >&5\"") >&5
+  (eval $ac_compiler -v </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -V </dev/null >&5\"") >&5
+  (eval $ac_compiler -V </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+echo "$as_me:$LINENO: checking for C compiler default output" >&5
+echo $ECHO_N "checking for C compiler default output... $ECHO_C" >&6
+ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
+  (eval $ac_link_default) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Find the output, starting from the most likely.  This scheme is
+# not robust to junk in `.', hence go to wildcards (a.*) only as a last
+# resort.
+
+# Be careful to initialize this variable, since it used to be cached.
+# Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
+ac_cv_exeext=
+# b.out is created by i960 compilers.
+for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
+        ;;
+    conftest.$ac_ext )
+        # This is the source file.
+        ;;
+    [ab].out )
+        # We found the default executable, but exeext='' is most
+        # certainly right.
+        break;;
+    *.* )
+        ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+        # FIXME: I believe we export ac_cv_exeext for Libtool,
+        # but it would be cool to find out if it's true.  Does anybody
+        # maintain Libtool? --akim.
+        export ac_cv_exeext
+        break;;
+    * )
+        break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
+See \`config.log' for more details." >&5
+echo "$as_me: error: C compiler cannot create executables
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_file" >&5
+echo "${ECHO_T}$ac_file" >&6
+
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+fi
+echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $cross_compiling" >&5
+echo "${ECHO_T}$cross_compiling" >&6
+
+echo "$as_me:$LINENO: checking for suffix of executables" >&5
+echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+          export ac_cv_exeext
+          break;;
+    * ) break;;
+  esac
+done
+else
+  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+echo "${ECHO_T}$ac_cv_exeext" >&6
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+echo "$as_me:$LINENO: checking for suffix of object files" >&5
+echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6
+if test "${ac_cv_objext+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+echo "${ECHO_T}$ac_cv_objext" >&6
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
+GCC=`test $ac_compiler_gnu = yes && echo yes`
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+CFLAGS="-g"
+echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_prog_cc_g=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+echo "$as_me:$LINENO: checking for $CC option to accept ANSI C" >&5
+echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_prog_cc_stdc=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_stdc=$ac_arg
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext
+done
+rm -f conftest.$ac_ext conftest.$ac_objext
+CC=$ac_save_CC
+
+fi
+
+case "x$ac_cv_prog_cc_stdc" in
+  x|xno)
+    echo "$as_me:$LINENO: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6 ;;
+  *)
+    echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
+    CC="$CC $ac_cv_prog_cc_stdc" ;;
+esac
+
+# Some people use a C++ compiler to compile C.  Since we use `exit',
+# in C++ we need to declare it.  In case someone uses the same compiler
+# for both compiling C and C++ we need to have the C++ compiler decide
+# the declaration of exit, since it's the most demanding environment.
+cat >conftest.$ac_ext <<_ACEOF
+#ifndef __cplusplus
+  choke me
+#endif
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  for ac_declaration in \
+   ''\
+   '#include <stdlib.h>' \
+   'extern "C" void std::exit (int) throw (); using std::exit;' \
+   'extern "C" void std::exit (int); using std::exit;' \
+   'extern "C" void exit (int) throw ();' \
+   'extern "C" void exit (int);' \
+   'void exit (int);'
+do
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+continue
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n "$ac_declaration"; then
+  echo '#ifdef __cplusplus' >>confdefs.h
+  echo $ac_declaration      >>confdefs.h
+  echo '#endif'             >>confdefs.h
+fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+                     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+echo "$as_me:$LINENO: result: $CPP" >&5
+echo "${ECHO_T}$CPP" >&6
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+                     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
+
+echo "$as_me:$LINENO: checking for AIX" >&5
+echo $ECHO_N "checking for AIX... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef _AIX
+  yes
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+cat >>confdefs.h <<\_ACEOF
+#define _ALL_SOURCE 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+rm -f conftest*
+
+
+
+
+# libtool stuff for shared/static libraries.
+
+
+# Check whether --enable-shared or --disable-shared was given.
+if test "${enable_shared+set}" = set; then
+  enableval="$enable_shared"
+  p=${PACKAGE-default}
+case $enableval in
+yes) enable_shared=yes ;;
+no) enable_shared=no ;;
+*)
+  enable_shared=no
+  # Look at the argument we got.  We use all the common list separators.
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:,"
+  for pkg in $enableval; do
+    if test "X$pkg" = "X$p"; then
+      enable_shared=yes
+    fi
+  done
+  IFS="$ac_save_ifs"
+  ;;
+esac
+else
+  enable_shared=yes
+fi;
+# Check whether --enable-static or --disable-static was given.
+if test "${enable_static+set}" = set; then
+  enableval="$enable_static"
+  p=${PACKAGE-default}
+case $enableval in
+yes) enable_static=yes ;;
+no) enable_static=no ;;
+*)
+  enable_static=no
+  # Look at the argument we got.  We use all the common list separators.
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:,"
+  for pkg in $enableval; do
+    if test "X$pkg" = "X$p"; then
+      enable_static=yes
+    fi
+  done
+  IFS="$ac_save_ifs"
+  ;;
+esac
+else
+  enable_static=yes
+fi;
+# Check whether --enable-fast-install or --disable-fast-install was given.
+if test "${enable_fast_install+set}" = set; then
+  enableval="$enable_fast_install"
+  p=${PACKAGE-default}
+case $enableval in
+yes) enable_fast_install=yes ;;
+no) enable_fast_install=no ;;
+*)
+  enable_fast_install=no
+  # Look at the argument we got.  We use all the common list separators.
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:,"
+  for pkg in $enableval; do
+    if test "X$pkg" = "X$p"; then
+      enable_fast_install=yes
+    fi
+  done
+  IFS="$ac_save_ifs"
+  ;;
+esac
+else
+  enable_fast_install=yes
+fi;
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&5
+echo "$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"
+ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
+
+# Make sure we can run config.sub.
+$ac_config_sub sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
+echo "$as_me: error: cannot run $ac_config_sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_build_alias=$build_alias
+test -z "$ac_cv_build_alias" &&
+  ac_cv_build_alias=`$ac_config_guess`
+test -z "$ac_cv_build_alias" &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6
+build=$ac_cv_build
+build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_host_alias=$host_alias
+test -z "$ac_cv_host_alias" &&
+  ac_cv_host_alias=$ac_cv_build_alias
+ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6
+host=$ac_cv_host
+host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+# Find the correct PATH separator.  Usually this is `:', but
+# DJGPP uses `;' like DOS.
+if test "X${PATH_SEPARATOR+set}" != Xset; then
+  UNAME=${UNAME-`uname 2>/dev/null`}
+  case X$UNAME in
+    *-DOS) lt_cv_sys_path_separator=';' ;;
+    *)     lt_cv_sys_path_separator=':' ;;
+  esac
+  PATH_SEPARATOR=$lt_cv_sys_path_separator
+fi
+
+
+# Check whether --with-gnu-ld or --without-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then
+  withval="$with_gnu_ld"
+  test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi;
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  echo "$as_me:$LINENO: checking for ld used by GCC" >&5
+echo $ECHO_N "checking for ld used by GCC... $ECHO_C" >&6
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | [A-Za-z]:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the path of ld
+      ac_prog=`echo $ac_prog| sed 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| sed "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  echo "$as_me:$LINENO: checking for GNU ld" >&5
+echo $ECHO_N "checking for GNU ld... $ECHO_C" >&6
+else
+  echo "$as_me:$LINENO: checking for non-GNU ld" >&5
+echo $ECHO_N "checking for non-GNU ld... $ECHO_C" >&6
+fi
+if test "${lt_cv_path_LD+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      if "$lt_cv_path_LD" -v 2>&1 < /dev/null | egrep '(GNU|with BFD)' > /dev/null; then
+	test "$with_gnu_ld" != no && break
+      else
+	test "$with_gnu_ld" != yes && break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
+
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  echo "$as_me:$LINENO: result: $LD" >&5
+echo "${ECHO_T}$LD" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+test -z "$LD" && { { echo "$as_me:$LINENO: error: no acceptable ld found in \$PATH" >&5
+echo "$as_me: error: no acceptable ld found in \$PATH" >&2;}
+   { (exit 1); exit 1; }; }
+echo "$as_me:$LINENO: checking if the linker ($LD) is GNU ld" >&5
+echo $ECHO_N "checking if the linker ($LD) is GNU ld... $ECHO_C" >&6
+if test "${lt_cv_prog_gnu_ld+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # I'd rather use --version here, but apparently some GNU ld's only accept -v.
+if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
+  lt_cv_prog_gnu_ld=yes
+else
+  lt_cv_prog_gnu_ld=no
+fi
+fi
+echo "$as_me:$LINENO: result: $lt_cv_prog_gnu_ld" >&5
+echo "${ECHO_T}$lt_cv_prog_gnu_ld" >&6
+with_gnu_ld=$lt_cv_prog_gnu_ld
+
+
+echo "$as_me:$LINENO: checking for $LD option to reload object files" >&5
+echo $ECHO_N "checking for $LD option to reload object files... $ECHO_C" >&6
+if test "${lt_cv_ld_reload_flag+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  lt_cv_ld_reload_flag='-r'
+fi
+echo "$as_me:$LINENO: result: $lt_cv_ld_reload_flag" >&5
+echo "${ECHO_T}$lt_cv_ld_reload_flag" >&6
+reload_flag=$lt_cv_ld_reload_flag
+test -n "$reload_flag" && reload_flag=" $reload_flag"
+
+echo "$as_me:$LINENO: checking for BSD-compatible nm" >&5
+echo $ECHO_N "checking for BSD-compatible nm... $ECHO_C" >&6
+if test "${lt_cv_path_NM+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH /usr/ccs/bin /usr/ucb /bin; do
+    test -z "$ac_dir" && ac_dir=.
+    tmp_nm=$ac_dir/${ac_tool_prefix}nm
+    if test -f $tmp_nm || test -f $tmp_nm$ac_exeext ; then
+      # Check to see if the nm accepts a BSD-compat flag.
+      # Adding the `sed 1q' prevents false positives on HP-UX, which says:
+      #   nm: unknown option "B" ignored
+      # Tru64's nm complains that /dev/null is an invalid object file
+      if ($tmp_nm -B /dev/null 2>&1 | sed '1q'; exit 0) | egrep '(/dev/null|Invalid file or object type)' >/dev/null; then
+	lt_cv_path_NM="$tmp_nm -B"
+	break
+      elif ($tmp_nm -p /dev/null 2>&1 | sed '1q'; exit 0) | egrep /dev/null >/dev/null; then
+	lt_cv_path_NM="$tmp_nm -p"
+	break
+      else
+	lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	continue # so that we can try to find one that supports BSD flags
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$lt_cv_path_NM" && lt_cv_path_NM=nm
+fi
+fi
+
+NM="$lt_cv_path_NM"
+echo "$as_me:$LINENO: result: $NM" >&5
+echo "${ECHO_T}$NM" >&6
+
+echo "$as_me:$LINENO: checking for a sed that does not truncate output" >&5
+echo $ECHO_N "checking for a sed that does not truncate output... $ECHO_C" >&6
+if test "${lt_cv_path_SED+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # Loop through the user's path and test for sed and gsed.
+# Then use that list of sed's as ones to test for truncation.
+as_executable_p="test -f"
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+        _sed_list="$_sed_list $as_dir/$ac_prog$ac_exec_ext"
+      fi
+    done
+  done
+done
+
+  # Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+: ${TMPDIR=/tmp}
+{
+  tmp=`(umask 077 && mktemp -d -q "$TMPDIR/sedXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=$TMPDIR/sed$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in $TMPDIR" >&2
+   { (exit 1); exit 1; }
+}
+  _max=0
+  _count=0
+  # Add /usr/xpg4/bin/sed as it is typically found on Solaris
+  # along with /bin/sed that truncates output.
+  for _sed in $_sed_list /usr/xpg4/bin/sed; do
+    test ! -f ${_sed} && break
+    cat /dev/null > "$tmp/sed.in"
+    _count=0
+    echo ${ECHO_N-$ac_n} "0123456789${ECHO_C-$ac_c}" >"$tmp/sed.in"
+    # Check for GNU sed and select it if it is found.
+    if "${_sed}" --version 2>&1 < /dev/null | egrep '(GNU)' > /dev/null; then
+      lt_cv_path_SED=${_sed}
+      break
+    fi
+    while true; do
+      cat "$tmp/sed.in" "$tmp/sed.in" >"$tmp/sed.tmp"
+      mv "$tmp/sed.tmp" "$tmp/sed.in"
+      cp "$tmp/sed.in" "$tmp/sed.nl"
+      echo >>"$tmp/sed.nl"
+      ${_sed} -e 's/a$//' < "$tmp/sed.nl" >"$tmp/sed.out" || break
+      cmp -s "$tmp/sed.out" "$tmp/sed.nl" || break
+      # 40000 chars as input seems more than enough
+      test $_count -gt 10 && break
+      _count=`expr $_count + 1`
+      if test $_count -gt $_max; then
+        _max=$_count
+        lt_cv_path_SED=$_sed
+      fi
+    done
+  done
+  rm -rf "$tmp"
+
+fi
+
+if test "X$SED" != "X"; then
+  lt_cv_path_SED=$SED
+else
+  SED=$lt_cv_path_SED
+fi
+echo "$as_me:$LINENO: result: $SED" >&5
+echo "${ECHO_T}$SED" >&6
+
+echo "$as_me:$LINENO: checking whether ln -s works" >&5
+echo $ECHO_N "checking whether ln -s works... $ECHO_C" >&6
+LN_S=$as_ln_s
+if test "$LN_S" = "ln -s"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+  echo "$as_me:$LINENO: result: no, using $LN_S" >&5
+echo "${ECHO_T}no, using $LN_S" >&6
+fi
+
+echo "$as_me:$LINENO: checking how to recognise dependent libraries" >&5
+echo $ECHO_N "checking how to recognise dependent libraries... $ECHO_C" >&6
+if test "${lt_cv_deplibs_check_method+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given egrep regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix4* | aix5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi4*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin* | mingw* | pw32*)
+  lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method='file_magic Mach-O dynamically linked shared library'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  case "$host_os" in
+  rhapsody* | darwin1.[012])
+    lt_cv_file_magic_test_file=`echo /System/Library/Frameworks/System.framework/Versions/*/System | head -1`
+    ;;
+  *) # Darwin 1.3 on
+    lt_cv_file_magic_test_file='/usr/lib/libSystem.dylib'
+    ;;
+  esac
+  ;;
+
+freebsd*)
+  if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD)/i[3-9]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20*|hpux11*)
+  lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9].[0-9]) shared library'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libc.sl
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+  irix5* | nonstopux*)
+    # this will be overridden with pass_all, but let us keep it just in case
+    lt_cv_deplibs_check_method="file_magic ELF 32-bit MSB dynamic lib MIPS - version 1"
+    ;;
+  *)
+    case $LD in
+    *-32|*"-32 ") libmagic=32-bit;;
+    *-n32|*"-n32 ") libmagic=N32;;
+    *-64|*"-64 ") libmagic=64-bit;;
+    *) libmagic=never-match;;
+    esac
+    # this will be overridden with pass_all, but let us keep it just in case
+    lt_cv_deplibs_check_method="file_magic ELF ${libmagic} MSB mips-[1234] dynamic lib MIPS - version 1"
+    ;;
+  esac
+  lt_cv_file_magic_test_file=`echo /lib${libsuff}/libc.so*`
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be Linux ELF.
+linux-gnu*)
+  case $host_cpu in
+  alpha* | hppa* | i*86 | mips | mipsel | powerpc* | sparc* | ia64*)
+    lt_cv_deplibs_check_method=pass_all ;;
+  *)
+    # glibc up to 2.1.1 does not perform some relocations on ARM
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
+  esac
+  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  ;;
+
+netbsd*)
+  if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/\.]+\.so\.[0-9]+\.[0-9]+$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/\.]+\.so$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+openbsd*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB shared object'
+  else
+    lt_cv_deplibs_check_method='file_magic OpenBSD.* shared library'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  # this will be overridden with pass_all, but let us keep it just in case
+  lt_cv_deplibs_check_method='file_magic COFF format alpha shared library'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sco3.2v5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  lt_cv_file_magic_test_file=/lib/libc.so
+  ;;
+
+sysv5uw[78]* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+esac
+
+fi
+echo "$as_me:$LINENO: result: $lt_cv_deplibs_check_method" >&5
+echo "${ECHO_T}$lt_cv_deplibs_check_method" >&6
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+
+
+
+
+
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+echo "$as_me:$LINENO: checking command to parse $NM output" >&5
+echo $ECHO_N "checking command to parse $NM output... $ECHO_C" >&6
+if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[BCDEGRST]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
+
+# Transform the above into a raw symbol and a C symbol.
+symxfrm='\1 \2\3 \3'
+
+# Transform an extracted symbol line into a proper C declaration
+lt_cv_global_symbol_to_cdecl="sed -n -e 's/^. .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (lt_ptr) 0},/p' -e 's/^$symcode \([^ ]*\) \([^ ]*\)$/  {\"\2\", (lt_ptr) \&\2},/p'"
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[BCDT]'
+  ;;
+cygwin* | mingw* | pw32*)
+  symcode='[ABCDGISTW]'
+  ;;
+hpux*) # Its linker distinguishes data from code symbols
+  lt_cv_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern char \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+  lt_cv_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (lt_ptr) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (lt_ptr) \&\2},/p'"
+  ;;
+irix* | nonstopux*)
+  symcode='[BCDEGRST]'
+  ;;
+osf*)
+  symcode='[BCDEGQRST]'
+  ;;
+solaris* | sysv5*)
+  symcode='[BDT]'
+  ;;
+sysv4)
+  symcode='[DFNSTU]'
+  ;;
+esac
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $host_os in
+mingw*)
+  opt_cr=`echo 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+if $NM -V 2>&1 | egrep '(GNU|with BFD)' > /dev/null; then
+  symcode='[ABCDGISTW]'
+fi
+
+# Try without a prefix undercore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Write the raw and C identifiers.
+lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[ 	]\($symcode$symcode*\)[ 	][ 	]*\($ac_symprfx\)$sympat$opt_cr$/$symxfrm/p'"
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+  rm -f conftest*
+  cat > conftest.$ac_ext <<EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+EOF
+
+  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if { (eval echo "$as_me:$LINENO: \"$NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist\"") >&5
+  (eval $NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if egrep ' nm_test_var$' "$nlist" >/dev/null; then
+	if egrep ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<EOF > conftest.$ac_ext
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_global_symbol_to_cdecl"' < "$nlist" >> conftest.$ac_ext'
+
+	  cat <<EOF >> conftest.$ac_ext
+#if defined (__STDC__) && __STDC__
+# define lt_ptr void *
+#else
+# define lt_ptr char *
+# define const
+#endif
+
+/* The mapping between symbol names and symbols. */
+const struct {
+  const char *name;
+  lt_ptr address;
+}
+lt_preloaded_symbols[] =
+{
+EOF
+	  sed "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (lt_ptr) \&\2},/" < "$nlist" >> conftest.$ac_ext
+	  cat <<\EOF >> conftest.$ac_ext
+  {0, (lt_ptr) 0}
+};
+
+#ifdef __cplusplus
+}
+#endif
+EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  save_LIBS="$LIBS"
+	  save_CFLAGS="$CFLAGS"
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$no_builtin_flag"
+	  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s conftest$ac_exeext; then
+	    pipe_works=yes
+	  fi
+	  LIBS="$save_LIBS"
+	  CFLAGS="$save_CFLAGS"
+	else
+	  echo "cannot find nm_test_func in $nlist" >&5
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&5
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
+    fi
+  else
+    echo "$progname: failed program was:" >&5
+    cat conftest.$ac_ext >&5
+  fi
+  rm -f conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+
+fi
+
+global_symbol_pipe="$lt_cv_sys_global_symbol_pipe"
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  global_symbol_to_cdecl=
+  global_symbol_to_c_name_address=
+else
+  global_symbol_to_cdecl="$lt_cv_global_symbol_to_cdecl"
+  global_symbol_to_c_name_address="$lt_cv_global_symbol_to_c_name_address"
+fi
+if test -z "$global_symbol_pipe$global_symbol_to_cdec$global_symbol_to_c_name_address";
+then
+  echo "$as_me:$LINENO: result: failed" >&5
+echo "${ECHO_T}failed" >&6
+else
+  echo "$as_me:$LINENO: result: ok" >&5
+echo "${ECHO_T}ok" >&6
+fi
+
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_stdc=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+                   (('a' <= (c) && (c) <= 'i') \
+                     || ('j' <= (c) && (c) <= 'r') \
+                     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+        || toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+
+
+
+
+
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+                  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_Header=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in dlfcn.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+
+# Only perform the check for file, if the check method requires it
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    echo "$as_me:$LINENO: checking for ${ac_tool_prefix}file" >&5
+echo $ECHO_N "checking for ${ac_tool_prefix}file... $ECHO_C" >&6
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $MAGIC_CMD in
+  /*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+  ?:/*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a dos path.
+  ;;
+  *)
+  ac_save_MAGIC_CMD="$MAGIC_CMD"
+  IFS="${IFS=   }"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="/usr/bin:$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/${ac_tool_prefix}file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex="`expr \"$deplibs_check_method\" : \"file_magic \(.*\)\"`"
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    egrep "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  MAGIC_CMD="$ac_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  echo "$as_me:$LINENO: result: $MAGIC_CMD" >&5
+echo "${ECHO_T}$MAGIC_CMD" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    echo "$as_me:$LINENO: checking for file" >&5
+echo $ECHO_N "checking for file... $ECHO_C" >&6
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $MAGIC_CMD in
+  /*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+  ?:/*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a dos path.
+  ;;
+  *)
+  ac_save_MAGIC_CMD="$MAGIC_CMD"
+  IFS="${IFS=   }"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="/usr/bin:$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex="`expr \"$deplibs_check_method\" : \"file_magic \(.*\)\"`"
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    egrep "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  MAGIC_CMD="$ac_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  echo "$as_me:$LINENO: result: $MAGIC_CMD" >&5
+echo "${ECHO_T}$MAGIC_CMD" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  else
+    MAGIC_CMD=:
+  fi
+fi
+
+  fi
+  ;;
+esac
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  echo "$as_me:$LINENO: result: $RANLIB" >&5
+echo "${ECHO_T}$RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_RANLIB" && ac_cv_prog_ac_ct_RANLIB=":"
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+echo "${ECHO_T}$ac_ct_RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  RANLIB=$ac_ct_RANLIB
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_STRIP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  echo "$as_me:$LINENO: result: $STRIP" >&5
+echo "${ECHO_T}$STRIP" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_STRIP" && ac_cv_prog_ac_ct_STRIP=":"
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
+echo "${ECHO_T}$ac_ct_STRIP" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  STRIP=$ac_ct_STRIP
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+
+enable_dlopen=no
+enable_win32_dll=no
+
+# Check whether --enable-libtool-lock or --disable-libtool-lock was given.
+if test "${enable_libtool_lock+set}" = set; then
+  enableval="$enable_libtool_lock"
+
+fi;
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '#line 5139 "configure"' > conftest.$ac_ext
+  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+    case `/usr/bin/file conftest.$ac_objext` in
+    *32-bit*)
+      LD="${LD-ld} -32"
+      ;;
+    *N32*)
+      LD="${LD-ld} -n32"
+      ;;
+    *64-bit*)
+      LD="${LD-ld} -64"
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  echo "$as_me:$LINENO: checking whether the C compiler needs -belf" >&5
+echo $ECHO_N "checking whether the C compiler needs -belf... $ECHO_C" >&6
+if test "${lt_cv_cc_needs_belf+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+
+     ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+     cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  lt_cv_cc_needs_belf=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+lt_cv_cc_needs_belf=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+     ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+fi
+echo "$as_me:$LINENO: result: $lt_cv_cc_needs_belf" >&5
+echo "${ECHO_T}$lt_cv_cc_needs_belf" >&6
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+
+
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed='sed -e s/^X//'
+sed_quote_subst='s/\([\\"\\`$\\\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\([\\"\\`\\\\]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Constants:
+rm="rm -f"
+
+# Global variables:
+default_ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except M$VC,
+# which needs '.lib').
+libext=a
+ltmain="$ac_aux_dir/ltmain.sh"
+ofile="$default_ofile"
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+need_locks="$enable_libtool_lock"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$AR" && AR=ar
+test -z "$AR_FLAGS" && AR_FLAGS=cru
+test -z "$AS" && AS=as
+test -z "$CC" && CC=cc
+test -z "$DLLTOOL" && DLLTOOL=dlltool
+test -z "$LD" && LD=ld
+test -z "$LN_S" && LN_S="ln -s"
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+test -z "$NM" && NM=nm
+test -z "$OBJDUMP" && OBJDUMP=objdump
+test -z "$RANLIB" && RANLIB=:
+test -z "$STRIP" && STRIP=:
+test -z "$ac_objext" && ac_objext=o
+
+if test x"$host" != x"$build"; then
+  ac_tool_prefix=${host_alias}-
+else
+  ac_tool_prefix=
+fi
+
+# Transform linux* to *-*-linux-gnu*, to support old configure scripts.
+case $host_os in
+linux-gnu*) ;;
+linux*) host=`echo $host | sed 's/^\(.*-.*-linux\)\(.*\)$/\1-gnu\2/'`
+esac
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="\$RANLIB -t \$oldlib~$old_postinstall_cmds"
+    ;;
+  *)
+    old_postinstall_cmds="\$RANLIB \$oldlib~$old_postinstall_cmds"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+fi
+
+# Allow CC to be a program name with arguments.
+set dummy $CC
+compiler="$2"
+
+## FIXME: this should be a separate macro
+##
+echo "$as_me:$LINENO: checking for objdir" >&5
+echo $ECHO_N "checking for objdir... $ECHO_C" >&6
+rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  objdir=_libs
+fi
+rmdir .libs 2>/dev/null
+echo "$as_me:$LINENO: result: $objdir" >&5
+echo "${ECHO_T}$objdir" >&6
+##
+## END FIXME
+
+
+## FIXME: this should be a separate macro
+##
+
+# Check whether --with-pic or --without-pic was given.
+if test "${with_pic+set}" = set; then
+  withval="$with_pic"
+  pic_mode="$withval"
+else
+  pic_mode=default
+fi;
+test -z "$pic_mode" && pic_mode=default
+
+# We assume here that the value for lt_cv_prog_cc_pic will not be cached
+# in isolation, and that seeing it set (from the cache) indicates that
+# the associated values are set (in the cache) correctly too.
+echo "$as_me:$LINENO: checking for $compiler option to produce PIC" >&5
+echo $ECHO_N "checking for $compiler option to produce PIC... $ECHO_C" >&6
+if test "${lt_cv_prog_cc_pic+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+   lt_cv_prog_cc_pic=
+  lt_cv_prog_cc_shlib=
+  lt_cv_prog_cc_wl=
+  lt_cv_prog_cc_static=
+  lt_cv_prog_cc_no_builtin=
+  lt_cv_prog_cc_can_build_shared=$can_build_shared
+
+  if test "$GCC" = yes; then
+    lt_cv_prog_cc_wl='-Wl,'
+    lt_cv_prog_cc_static='-static'
+
+    case $host_os in
+    aix*)
+      # Below there is a dirty hack to force normal static linking with -ldl
+      # The problem is because libdl dynamically linked with both libc and
+      # libC (AIX C++ library), which obviously doesn't included in libraries
+      # list by gcc. This cause undefined symbols with -static flags.
+      # This hack allows C programs to be linked with "-static -ldl", but
+      # not sure about C++ programs.
+      lt_cv_prog_cc_static="$lt_cv_prog_cc_static ${lt_cv_prog_cc_wl}-lC"
+      ;;
+    amigaos*)
+      # FIXME: we need at least 68020 code to build shared libraries, but
+      # adding the `-m68020' flag to GCC prevents building anything better,
+      # like `-m68040'.
+      lt_cv_prog_cc_pic='-m68020 -resident32 -malways-restore-a4'
+      ;;
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_cv_prog_cc_pic='-fno-common'
+      ;;
+    cygwin* | mingw* | pw32* | os2*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_cv_prog_cc_pic='-DDLL_EXPORT'
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	 lt_cv_prog_cc_pic=-Kconform_pic
+      fi
+      ;;
+    *)
+      lt_cv_prog_cc_pic='-fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for PIC flags for the system compiler.
+    case $host_os in
+    aix3* | aix4* | aix5*)
+      lt_cv_prog_cc_wl='-Wl,'
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_cv_prog_cc_static='-Bstatic'
+      else
+	lt_cv_prog_cc_static='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      # Is there a better lt_cv_prog_cc_static that works with the bundled CC?
+      lt_cv_prog_cc_wl='-Wl,'
+      lt_cv_prog_cc_static="${lt_cv_prog_cc_wl}-a ${lt_cv_prog_cc_wl}archive"
+      lt_cv_prog_cc_pic='+Z'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      lt_cv_prog_cc_wl='-Wl,'
+      lt_cv_prog_cc_static='-non_shared'
+      # PIC (with -KPIC) is the default.
+      ;;
+
+    cygwin* | mingw* | pw32* | os2*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_cv_prog_cc_pic='-DDLL_EXPORT'
+      ;;
+
+    newsos6)
+      lt_cv_prog_cc_pic='-KPIC'
+      lt_cv_prog_cc_static='-Bstatic'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      # All OSF/1 code is PIC.
+      lt_cv_prog_cc_wl='-Wl,'
+      lt_cv_prog_cc_static='-non_shared'
+      ;;
+
+    sco3.2v5*)
+      lt_cv_prog_cc_pic='-Kpic'
+      lt_cv_prog_cc_static='-dn'
+      lt_cv_prog_cc_shlib='-belf'
+      ;;
+
+    solaris*)
+      lt_cv_prog_cc_pic='-KPIC'
+      lt_cv_prog_cc_static='-Bstatic'
+      lt_cv_prog_cc_wl='-Wl,'
+      ;;
+
+    sunos4*)
+      lt_cv_prog_cc_pic='-PIC'
+      lt_cv_prog_cc_static='-Bstatic'
+      lt_cv_prog_cc_wl='-Qoption ld '
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+      lt_cv_prog_cc_pic='-KPIC'
+      lt_cv_prog_cc_static='-Bstatic'
+      lt_cv_prog_cc_wl='-Wl,'
+      ;;
+
+    uts4*)
+      lt_cv_prog_cc_pic='-pic'
+      lt_cv_prog_cc_static='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	lt_cv_prog_cc_pic='-Kconform_pic'
+	lt_cv_prog_cc_static='-Bstatic'
+      fi
+      ;;
+
+    *)
+      lt_cv_prog_cc_can_build_shared=no
+      ;;
+    esac
+  fi
+
+fi
+
+if test -z "$lt_cv_prog_cc_pic"; then
+  echo "$as_me:$LINENO: result: none" >&5
+echo "${ECHO_T}none" >&6
+else
+  echo "$as_me:$LINENO: result: $lt_cv_prog_cc_pic" >&5
+echo "${ECHO_T}$lt_cv_prog_cc_pic" >&6
+
+  # Check to make sure the pic_flag actually works.
+  echo "$as_me:$LINENO: checking if $compiler PIC flag $lt_cv_prog_cc_pic works" >&5
+echo $ECHO_N "checking if $compiler PIC flag $lt_cv_prog_cc_pic works... $ECHO_C" >&6
+  if test "${lt_cv_prog_cc_pic_works+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      save_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS $lt_cv_prog_cc_pic -DPIC"
+    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+        case $host_os in
+      hpux9* | hpux10* | hpux11*)
+	# On HP-UX, both CC and GCC only warn that PIC is supported... then
+	# they create non-PIC objects.  So, if there were any warnings, we
+	# assume that PIC is not supported.
+	if test -s conftest.err; then
+	  lt_cv_prog_cc_pic_works=no
+	else
+	  lt_cv_prog_cc_pic_works=yes
+	fi
+	;;
+      *)
+	lt_cv_prog_cc_pic_works=yes
+	;;
+      esac
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+      lt_cv_prog_cc_pic_works=no
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+    CFLAGS="$save_CFLAGS"
+
+fi
+
+
+  if test "X$lt_cv_prog_cc_pic_works" = Xno; then
+    lt_cv_prog_cc_pic=
+    lt_cv_prog_cc_can_build_shared=no
+  else
+    lt_cv_prog_cc_pic=" $lt_cv_prog_cc_pic"
+  fi
+
+  echo "$as_me:$LINENO: result: $lt_cv_prog_cc_pic_works" >&5
+echo "${ECHO_T}$lt_cv_prog_cc_pic_works" >&6
+fi
+##
+## END FIXME
+
+# Check for any special shared library compilation flags.
+if test -n "$lt_cv_prog_cc_shlib"; then
+  { echo "$as_me:$LINENO: WARNING: \`$CC' requires \`$lt_cv_prog_cc_shlib' to build shared libraries" >&5
+echo "$as_me: WARNING: \`$CC' requires \`$lt_cv_prog_cc_shlib' to build shared libraries" >&2;}
+  if echo "$old_CC $old_CFLAGS " | egrep -e "[ 	]$lt_cv_prog_cc_shlib[ 	]" >/dev/null; then :
+  else
+   { echo "$as_me:$LINENO: WARNING: add \`$lt_cv_prog_cc_shlib' to the CC or CFLAGS env variable and reconfigure" >&5
+echo "$as_me: WARNING: add \`$lt_cv_prog_cc_shlib' to the CC or CFLAGS env variable and reconfigure" >&2;}
+    lt_cv_prog_cc_can_build_shared=no
+  fi
+fi
+
+## FIXME: this should be a separate macro
+##
+echo "$as_me:$LINENO: checking if $compiler static flag $lt_cv_prog_cc_static works" >&5
+echo $ECHO_N "checking if $compiler static flag $lt_cv_prog_cc_static works... $ECHO_C" >&6
+if test "${lt_cv_prog_cc_static_works+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+    lt_cv_prog_cc_static_works=no
+  save_LDFLAGS="$LDFLAGS"
+  LDFLAGS="$LDFLAGS $lt_cv_prog_cc_static"
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  lt_cv_prog_cc_static_works=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+  LDFLAGS="$save_LDFLAGS"
+
+fi
+
+
+# Belt *and* braces to stop my trousers falling down:
+test "X$lt_cv_prog_cc_static_works" = Xno && lt_cv_prog_cc_static=
+echo "$as_me:$LINENO: result: $lt_cv_prog_cc_static_works" >&5
+echo "${ECHO_T}$lt_cv_prog_cc_static_works" >&6
+
+pic_flag="$lt_cv_prog_cc_pic"
+special_shlib_compile_flags="$lt_cv_prog_cc_shlib"
+wl="$lt_cv_prog_cc_wl"
+link_static_flag="$lt_cv_prog_cc_static"
+no_builtin_flag="$lt_cv_prog_cc_no_builtin"
+can_build_shared="$lt_cv_prog_cc_can_build_shared"
+##
+## END FIXME
+
+
+## FIXME: this should be a separate macro
+##
+# Check to see if options -o and -c are simultaneously supported by compiler
+echo "$as_me:$LINENO: checking if $compiler supports -c -o file.$ac_objext" >&5
+echo $ECHO_N "checking if $compiler supports -c -o file.$ac_objext... $ECHO_C" >&6
+if test "${lt_cv_compiler_c_o+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+$rm -r conftest 2>/dev/null
+mkdir conftest
+cd conftest
+echo "int some_variable = 0;" > conftest.$ac_ext
+mkdir out
+# According to Tom Tromey, Ian Lance Taylor reported there are C compilers
+# that will create temporary files in the current directory regardless of
+# the output directory.  Thus, making CWD read-only will cause this test
+# to fail, enabling locking or at least warning the user not to do parallel
+# builds.
+chmod -w .
+save_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS -o out/conftest2.$ac_objext"
+compiler_c_o=no
+if { (eval echo configure:5682: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>out/conftest.err; } && test -s out/conftest2.$ac_objext; then
+  # The compiler can only warn and ignore the option if not recognized
+  # So say no if there are warnings
+  if test -s out/conftest.err; then
+    lt_cv_compiler_c_o=no
+  else
+    lt_cv_compiler_c_o=yes
+  fi
+else
+  # Append any errors to the config.log.
+  cat out/conftest.err 1>&5
+  lt_cv_compiler_c_o=no
+fi
+CFLAGS="$save_CFLAGS"
+chmod u+w .
+$rm conftest* out/*
+rmdir out
+cd ..
+rmdir conftest
+$rm -r conftest 2>/dev/null
+
+fi
+
+compiler_c_o=$lt_cv_compiler_c_o
+echo "$as_me:$LINENO: result: $compiler_c_o" >&5
+echo "${ECHO_T}$compiler_c_o" >&6
+
+if test x"$compiler_c_o" = x"yes"; then
+  # Check to see if we can write to a .lo
+  echo "$as_me:$LINENO: checking if $compiler supports -c -o file.lo" >&5
+echo $ECHO_N "checking if $compiler supports -c -o file.lo... $ECHO_C" >&6
+  if test "${lt_cv_compiler_o_lo+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+  lt_cv_compiler_o_lo=no
+  save_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -c -o conftest.lo"
+  save_objext="$ac_objext"
+  ac_objext=lo
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+int some_variable = 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+      # The compiler can only warn and ignore the option if not recognized
+    # So say no if there are warnings
+    if test -s conftest.err; then
+      lt_cv_compiler_o_lo=no
+    else
+      lt_cv_compiler_o_lo=yes
+    fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+  ac_objext="$save_objext"
+  CFLAGS="$save_CFLAGS"
+
+fi
+
+  compiler_o_lo=$lt_cv_compiler_o_lo
+  echo "$as_me:$LINENO: result: $compiler_o_lo" >&5
+echo "${ECHO_T}$compiler_o_lo" >&6
+else
+  compiler_o_lo=no
+fi
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+# Check to see if we can do hard links to lock some files if needed
+hard_links="nottested"
+if test "$compiler_c_o" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  echo "$as_me:$LINENO: checking if we can lock with hard links" >&5
+echo $ECHO_N "checking if we can lock with hard links... $ECHO_C" >&6
+  hard_links=yes
+  $rm conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  echo "$as_me:$LINENO: result: $hard_links" >&5
+echo "${ECHO_T}$hard_links" >&6
+  if test "$hard_links" = no; then
+    { echo "$as_me:$LINENO: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+if test "$GCC" = yes; then
+  # Check to see if options -fno-rtti -fno-exceptions are supported by compiler
+  echo "$as_me:$LINENO: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+echo $ECHO_N "checking if $compiler supports -fno-rtti -fno-exceptions... $ECHO_C" >&6
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  save_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -fno-rtti -fno-exceptions -c conftest.$ac_ext"
+  compiler_rtti_exceptions=no
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+int some_variable = 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+      # The compiler can only warn and ignore the option if not recognized
+    # So say no if there are warnings
+    if test -s conftest.err; then
+      compiler_rtti_exceptions=no
+    else
+      compiler_rtti_exceptions=yes
+    fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+  CFLAGS="$save_CFLAGS"
+  echo "$as_me:$LINENO: result: $compiler_rtti_exceptions" >&5
+echo "${ECHO_T}$compiler_rtti_exceptions" >&6
+
+  if test "$compiler_rtti_exceptions" = "yes"; then
+    no_builtin_flag=' -fno-builtin -fno-rtti -fno-exceptions'
+  else
+    no_builtin_flag=' -fno-builtin'
+  fi
+fi
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+# See if the linker supports building shared libraries.
+echo "$as_me:$LINENO: checking whether the linker ($LD) supports shared libraries" >&5
+echo $ECHO_N "checking whether the linker ($LD) supports shared libraries... $ECHO_C" >&6
+
+allow_undefined_flag=
+no_undefined_flag=
+need_lib_prefix=unknown
+need_version=unknown
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+archive_cmds=
+archive_expsym_cmds=
+old_archive_from_new_cmds=
+old_archive_from_expsyms_cmds=
+export_dynamic_flag_spec=
+whole_archive_flag_spec=
+thread_safe_flag_spec=
+hardcode_into_libs=no
+hardcode_libdir_flag_spec=
+hardcode_libdir_separator=
+hardcode_direct=no
+hardcode_minus_L=no
+hardcode_shlibpath_var=unsupported
+runpath_var=
+link_all_deplibs=unknown
+always_export_symbols=no
+export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | sed '\''s/.* //'\'' | sort | uniq > $export_symbols'
+# include_expsyms should be a list of space-separated symbols to be *always*
+# included in the symbol list
+include_expsyms=
+# exclude_expsyms can be an egrep regular expression of symbols to exclude
+# it will be wrapped by ` (' and `)$', so one must not match beginning or
+# end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+# as well as any symbol that contains `d'.
+exclude_expsyms="_GLOBAL_OFFSET_TABLE_"
+# Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+# platforms (ab)use it in PIC code, but their linkers get confused if
+# the symbol is explicitly referenced.  Since portable code cannot
+# rely on this symbol name, it's probably fine to never include it in
+# preloaded symbol tables.
+extract_expsyms_cmds=
+
+case $host_os in
+cygwin* | mingw* | pw32*)
+  # FIXME: the MSVC++ port hasn't been tested in a loooong time
+  # When not using gcc, we currently assume that we are using
+  # Microsoft Visual C++.
+  if test "$GCC" != yes; then
+    with_gnu_ld=no
+  fi
+  ;;
+openbsd*)
+  with_gnu_ld=no
+  ;;
+esac
+
+ld_shlibs=yes
+if test "$with_gnu_ld" = yes; then
+  # If archive_cmds runs LD, not CC, wlarc should be empty
+  wlarc='${wl}'
+
+  # See if GNU ld supports shared libraries.
+  case $host_os in
+  aix3* | aix4* | aix5*)
+    # On AIX, the GNU linker is very broken
+    # Note:Check GNU linker on AIX 5-IA64 when/if it becomes available.
+    ld_shlibs=no
+    cat <<EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.9.1, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to modify your PATH
+*** so that a non-GNU linker is found, and then restart.
+
+EOF
+    ;;
+
+  amigaos*)
+    archive_cmds='$rm $output_objdir/a2ixlibrary.data~$echo "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$echo "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$echo "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$echo "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_minus_L=yes
+
+    # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports
+    # that the semantics of dynamic libraries on AmigaOS, at least up
+    # to version 4, is to share data among multiple programs linked
+    # with the same dynamic library.  Since this doesn't match the
+    # behavior of shared libraries on other platforms, we can use
+    # them.
+    ld_shlibs=no
+    ;;
+
+  beos*)
+    if $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then
+      allow_undefined_flag=unsupported
+      # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+      # support --undefined.  This deserves some investigation.  FIXME
+      archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+    else
+      ld_shlibs=no
+    fi
+    ;;
+
+  cygwin* | mingw* | pw32*)
+    # hardcode_libdir_flag_spec is actually meaningless, as there is
+    # no search path for DLLs.
+    hardcode_libdir_flag_spec='-L$libdir'
+    allow_undefined_flag=unsupported
+    always_export_symbols=yes
+
+    extract_expsyms_cmds='test -f $output_objdir/impgen.c || \
+      sed -e "/^# \/\* impgen\.c starts here \*\//,/^# \/\* impgen.c ends here \*\// { s/^# //;s/^# *$//; p; }" -e d < $''0 > $output_objdir/impgen.c~
+      test -f $output_objdir/impgen.exe || (cd $output_objdir && \
+      if test "x$HOST_CC" != "x" ; then $HOST_CC -o impgen impgen.c ; \
+      else $CC -o impgen impgen.c ; fi)~
+      $output_objdir/impgen $dir/$soroot > $output_objdir/$soname-def'
+
+    old_archive_from_expsyms_cmds='$DLLTOOL --as=$AS --dllname $soname --def $output_objdir/$soname-def --output-lib $output_objdir/$newlib'
+
+    # cygwin and mingw dlls have different entry points and sets of symbols
+    # to exclude.
+    # FIXME: what about values for MSVC?
+    dll_entry=__cygwin_dll_entry@12
+    dll_exclude_symbols=DllMain@12,_cygwin_dll_entry@12,_cygwin_noncygwin_dll_entry@12~
+    case $host_os in
+    mingw*)
+      # mingw values
+      dll_entry=_DllMainCRTStartup@12
+      dll_exclude_symbols=DllMain@12,DllMainCRTStartup@12,DllEntryPoint@12~
+      ;;
+    esac
+
+    # mingw and cygwin differ, and it's simplest to just exclude the union
+    # of the two symbol sets.
+    dll_exclude_symbols=DllMain@12,_cygwin_dll_entry@12,_cygwin_noncygwin_dll_entry@12,DllMainCRTStartup@12,DllEntryPoint@12
+
+    # recent cygwin and mingw systems supply a stub DllMain which the user
+    # can override, but on older systems we have to supply one (in ltdll.c)
+    if test "x$lt_cv_need_dllmain" = "xyes"; then
+      ltdll_obj='$output_objdir/$soname-ltdll.'"$ac_objext "
+      ltdll_cmds='test -f $output_objdir/$soname-ltdll.c || sed -e "/^# \/\* ltdll\.c starts here \*\//,/^# \/\* ltdll.c ends here \*\// { s/^# //; p; }" -e d < $''0 > $output_objdir/$soname-ltdll.c~
+	test -f $output_objdir/$soname-ltdll.$ac_objext || (cd $output_objdir && $CC -c $soname-ltdll.c)~'
+    else
+      ltdll_obj=
+      ltdll_cmds=
+    fi
+
+    # Extract the symbol export list from an `--export-all' def file,
+    # then regenerate the def file from the symbol export list, so that
+    # the compiled dll only exports the symbol export list.
+    # Be careful not to strip the DATA tag left be newer dlltools.
+    export_symbols_cmds="$ltdll_cmds"'
+      $DLLTOOL --export-all --exclude-symbols '$dll_exclude_symbols' --output-def $output_objdir/$soname-def '$ltdll_obj'$libobjs $convenience~
+      sed -e "1,/EXPORTS/d" -e "s/ @ [0-9]*//" -e "s/ *;.*$//" < $output_objdir/$soname-def > $export_symbols'
+
+    # If the export-symbols file already is a .def file (1st line
+    # is EXPORTS), use it as is.
+    # If DATA tags from a recent dlltool are present, honour them!
+    archive_expsym_cmds='if test "x`sed 1q $export_symbols`" = xEXPORTS; then
+	cp $export_symbols $output_objdir/$soname-def;
+      else
+	echo EXPORTS > $output_objdir/$soname-def;
+	_lt_hint=1;
+	cat $export_symbols | while read symbol; do
+	 set dummy \$symbol;
+	 case \$# in
+	   2) echo "   \$2 @ \$_lt_hint ; " >> $output_objdir/$soname-def;;
+	   4) echo "   \$2 \$3 \$4 ; " >> $output_objdir/$soname-def; _lt_hint=`expr \$_lt_hint - 1`;;
+	   *) echo "     \$2 @ \$_lt_hint \$3 ; " >> $output_objdir/$soname-def;;
+	 esac;
+	 _lt_hint=`expr 1 + \$_lt_hint`;
+	done;
+      fi~
+      '"$ltdll_cmds"'
+      $CC -Wl,--base-file,$output_objdir/$soname-base '$lt_cv_cc_dll_switch' -Wl,-e,'$dll_entry' -o $output_objdir/$soname '$ltdll_obj'$libobjs $deplibs $compiler_flags~
+      $DLLTOOL --as=$AS --dllname $soname --exclude-symbols '$dll_exclude_symbols' --def $output_objdir/$soname-def --base-file $output_objdir/$soname-base --output-exp $output_objdir/$soname-exp~
+      $CC -Wl,--base-file,$output_objdir/$soname-base $output_objdir/$soname-exp '$lt_cv_cc_dll_switch' -Wl,-e,'$dll_entry' -o $output_objdir/$soname '$ltdll_obj'$libobjs $deplibs $compiler_flags~
+      $DLLTOOL --as=$AS --dllname $soname --exclude-symbols '$dll_exclude_symbols' --def $output_objdir/$soname-def --base-file $output_objdir/$soname-base --output-exp $output_objdir/$soname-exp --output-lib $output_objdir/$libname.dll.a~
+      $CC $output_objdir/$soname-exp '$lt_cv_cc_dll_switch' -Wl,-e,'$dll_entry' -o $output_objdir/$soname '$ltdll_obj'$libobjs $deplibs $compiler_flags'
+    ;;
+
+  netbsd*)
+    if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+      archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+      wlarc=
+    else
+      archive_cmds='$CC -shared -nodefaultlibs $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      archive_expsym_cmds='$CC -shared -nodefaultlibs $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+    fi
+    ;;
+
+  solaris* | sysv5*)
+    if $LD -v 2>&1 | egrep 'BFD 2\.8' > /dev/null; then
+      ld_shlibs=no
+      cat <<EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+EOF
+    elif $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then
+      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+    else
+      ld_shlibs=no
+    fi
+    ;;
+
+  sunos4*)
+    archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+    wlarc=
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  *)
+    if $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then
+      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+    else
+      ld_shlibs=no
+    fi
+    ;;
+  esac
+
+  if test "$ld_shlibs" = yes; then
+    runpath_var=LD_RUN_PATH
+    hardcode_libdir_flag_spec='${wl}--rpath ${wl}$libdir'
+    export_dynamic_flag_spec='${wl}--export-dynamic'
+    case $host_os in
+    cygwin* | mingw* | pw32*)
+      # dlltool doesn't understand --whole-archive et. al.
+      whole_archive_flag_spec=
+      ;;
+    *)
+      # ancient GNU ld didn't support --whole-archive et. al.
+      if $LD --help 2>&1 | egrep 'no-whole-archive' > /dev/null; then
+	whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+      else
+	whole_archive_flag_spec=
+      fi
+      ;;
+    esac
+  fi
+else
+  # PORTME fill in a description of your system's linker (not GNU ld)
+  case $host_os in
+  aix3*)
+    allow_undefined_flag=unsupported
+    always_export_symbols=yes
+    archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+    # Note: this linker hardcodes the directories in LIBPATH if there
+    # are no directories specified by -L.
+    hardcode_minus_L=yes
+    if test "$GCC" = yes && test -z "$link_static_flag"; then
+      # Neither direct hardcoding nor static linking is supported with a
+      # broken collect2.
+      hardcode_direct=unsupported
+    fi
+    ;;
+
+  aix4* | aix5*)
+    if test "$host_cpu" = ia64; then
+      # On IA64, the linker does run time linking by default, so we don't
+      # have to do anything special.
+      aix_use_runtimelinking=no
+      exp_sym_flag='-Bexport'
+      no_entry_flag=""
+    else
+      aix_use_runtimelinking=no
+
+      # Test if we are trying to use run time linking or normal
+      # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+      # need to do runtime linking.
+      case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+	for ld_flag in $LDFLAGS; do
+	  case $ld_flag in
+	  *-brtl*)
+	    aix_use_runtimelinking=yes
+	    break
+	  ;;
+	  esac
+	done
+      esac
+
+      exp_sym_flag='-bexport'
+      no_entry_flag='-bnoentry'
+    fi
+
+    # When large executables or shared objects are built, AIX ld can
+    # have problems creating the table of contents.  If linking a library
+    # or program results in "error TOC overflow" add -mminimal-toc to
+    # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+    # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+    hardcode_direct=yes
+    archive_cmds=''
+    hardcode_libdir_separator=':'
+    if test "$GCC" = yes; then
+      case $host_os in aix4.[012]|aix4.[012].*)
+	collect2name=`${CC} -print-prog-name=collect2`
+	if test -f "$collect2name" && \
+	  strings "$collect2name" | grep resolve_lib_name >/dev/null
+	then
+	  # We have reworked collect2
+	  hardcode_direct=yes
+	else
+	  # We have old collect2
+	  hardcode_direct=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  hardcode_minus_L=yes
+	  hardcode_libdir_flag_spec='-L$libdir'
+	  hardcode_libdir_separator=
+	fi
+      esac
+
+      shared_flag='-shared'
+    else
+      # not using gcc
+      if test "$host_cpu" = ia64; then
+	shared_flag='${wl}-G'
+      else
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag='${wl}-G'
+	else
+	  shared_flag='${wl}-bM:SRE'
+	fi
+      fi
+    fi
+
+    # It seems that -bexpall can do strange things, so it is better to
+    # generate a list of symbols to export.
+    always_export_symbols=yes
+    if test "$aix_use_runtimelinking" = yes; then
+      # Warning - without using the other runtime loading flags (-brtl),
+      # -berok will link without error, but may produce a broken library.
+      allow_undefined_flag='-berok'
+      hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:/usr/lib:/lib'
+      archive_expsym_cmds="\$CC"' -o $output_objdir/$soname $libobjs $deplibs $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then echo "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$no_entry_flag \${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+    else
+      if test "$host_cpu" = ia64; then
+	hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+	allow_undefined_flag="-z nodefs"
+	archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname ${wl}-h$soname $libobjs $deplibs $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$no_entry_flag \${wl}$exp_sym_flag:\$export_symbols"
+      else
+	hardcode_libdir_flag_spec='${wl}-bnolibpath ${wl}-blibpath:$libdir:/usr/lib:/lib'
+	# Warning - without using the other run time loading flags,
+	# -berok will link without error, but may produce a broken library.
+	allow_undefined_flag='${wl}-berok'
+	# This is a bit strange, but is similar to how AIX traditionally builds
+	# it's shared libraries.
+	archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs $compiler_flags ${allow_undefined_flag} '"\${wl}$no_entry_flag \${wl}$exp_sym_flag:\$export_symbols"' ~$AR -crlo $objdir/$libname$release.a $objdir/$soname'
+      fi
+    fi
+    ;;
+
+  amigaos*)
+    archive_cmds='$rm $output_objdir/a2ixlibrary.data~$echo "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$echo "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$echo "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$echo "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_minus_L=yes
+    # see comment about different semantics on the GNU ld section
+    ld_shlibs=no
+    ;;
+
+  cygwin* | mingw* | pw32*)
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    # hardcode_libdir_flag_spec is actually meaningless, as there is
+    # no search path for DLLs.
+    hardcode_libdir_flag_spec=' '
+    allow_undefined_flag=unsupported
+    # Tell ltmain to make .lib files, not .a files.
+    libext=lib
+    # FIXME: Setting linknames here is a bad hack.
+    archive_cmds='$CC -o $lib $libobjs $compiler_flags `echo "$deplibs" | sed -e '\''s/ -lc$//'\''` -link -dll~linknames='
+    # The linker will automatically build a .lib file if we build a DLL.
+    old_archive_from_new_cmds='true'
+    # FIXME: Should let the user specify the lib program.
+    old_archive_cmds='lib /OUT:$oldlib$oldobjs$old_deplibs'
+    fix_srcfile_path='`cygpath -w "$srcfile"`'
+    ;;
+
+  darwin* | rhapsody*)
+    case "$host_os" in
+    rhapsody* | darwin1.[012])
+      allow_undefined_flag='-undefined suppress'
+      ;;
+    *) # Darwin 1.3 on
+      allow_undefined_flag='-flat_namespace -undefined suppress'
+      ;;
+    esac
+    # FIXME: Relying on posixy $() will cause problems for
+    #        cross-compilation, but unfortunately the echo tests do not
+    #        yet detect zsh echo's removal of \ escapes.  Also zsh mangles
+    #	     `"' quotes if we put them in here... so don't!
+    archive_cmds='$CC -r -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs && $CC $(test .$module = .yes && echo -bundle || echo -dynamiclib) $allow_undefined_flag -o $lib ${lib}-master.o $deplibs$linker_flags $(test .$module != .yes && echo -install_name $rpath/$soname $verstring)'
+    # We need to add '_' to the symbols in $export_symbols first
+    #archive_expsym_cmds="$archive_cmds"' && strip -s $export_symbols'
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    whole_archive_flag_spec='-all_load $convenience'
+    ;;
+
+  freebsd1*)
+    ld_shlibs=no
+    ;;
+
+  # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+  # support.  Future versions do this automatically, but an explicit c++rt0.o
+  # does not break anything, and helps significantly (at the cost of a little
+  # extra space).
+  freebsd2.2*)
+    archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+    hardcode_libdir_flag_spec='-R$libdir'
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+  freebsd2*)
+    archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_direct=yes
+    hardcode_minus_L=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+  freebsd*)
+    archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+    hardcode_libdir_flag_spec='-R$libdir'
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  hpux9* | hpux10* | hpux11*)
+    case $host_os in
+    hpux9*) archive_cmds='$rm $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib' ;;
+    *) archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags' ;;
+    esac
+    hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+    hardcode_libdir_separator=:
+    hardcode_direct=yes
+    hardcode_minus_L=yes # Not in the search PATH, but as the default
+			 # location of the library.
+    export_dynamic_flag_spec='${wl}-E'
+    ;;
+
+  irix5* | irix6* | nonstopux*)
+    if test "$GCC" = yes; then
+      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    else
+      archive_cmds='$LD -shared $libobjs $deplibs $linker_flags -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+      hardcode_libdir_flag_spec='-rpath $libdir'
+    fi
+    hardcode_libdir_separator=:
+    link_all_deplibs=yes
+    ;;
+
+  netbsd*)
+    if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+    else
+      archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+    fi
+    hardcode_libdir_flag_spec='-R$libdir'
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  newsos6)
+    archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_direct=yes
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    hardcode_libdir_separator=:
+    hardcode_shlibpath_var=no
+    ;;
+
+  openbsd*)
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+      archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      export_dynamic_flag_spec='${wl}-E'
+    else
+      case "$host_os" in
+      openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	hardcode_libdir_flag_spec='-R$libdir'
+        ;;
+      *)
+        archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+        hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+        ;;
+      esac
+    fi
+    ;;
+
+  os2*)
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_minus_L=yes
+    allow_undefined_flag=unsupported
+    archive_cmds='$echo "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$echo "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~$echo DATA >> $output_objdir/$libname.def~$echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~$echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+    old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+    ;;
+
+  osf3*)
+    if test "$GCC" = yes; then
+      allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+      archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+    else
+      allow_undefined_flag=' -expect_unresolved \*'
+      archive_cmds='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+    fi
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    hardcode_libdir_separator=:
+    ;;
+
+  osf4* | osf5*)	# as osf3* with the addition of -msym flag
+    if test "$GCC" = yes; then
+      allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+      archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    else
+      allow_undefined_flag=' -expect_unresolved \*'
+      archive_cmds='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -msym -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+      archive_expsym_cmds='for i in `cat $export_symbols`; do printf "-exported_symbol " >> $lib.exp; echo "\$i" >> $lib.exp; done; echo "-hidden">> $lib.exp~
+      $LD -shared${allow_undefined_flag} -input $lib.exp $linker_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${objdir}/so_locations -o $lib~$rm $lib.exp'
+
+      #Both c and cxx compiler support -rpath directly
+      hardcode_libdir_flag_spec='-rpath $libdir'
+    fi
+    hardcode_libdir_separator=:
+    ;;
+
+  sco3.2v5*)
+    archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_shlibpath_var=no
+    runpath_var=LD_RUN_PATH
+    hardcode_runpath_var=yes
+    export_dynamic_flag_spec='${wl}-Bexport'
+    ;;
+
+  solaris*)
+    # gcc --version < 3.0 without binutils cannot create self contained
+    # shared libraries reliably, requiring libgcc.a to resolve some of
+    # the object symbols generated in some cases.  Libraries that use
+    # assert need libgcc.a to resolve __eprintf, for example.  Linking
+    # a copy of libgcc.a into every shared library to guarantee resolving
+    # such symbols causes other problems:  According to Tim Van Holder
+    # <tim.van.holder@pandora.be>, C++ libraries end up with a separate
+    # (to the application) exception stack for one thing.
+    no_undefined_flag=' -z defs'
+    if test "$GCC" = yes; then
+      case `$CC --version 2>/dev/null` in
+      [12].*)
+	cat <<EOF 1>&2
+
+*** Warning: Releases of GCC earlier than version 3.0 cannot reliably
+*** create self contained shared libraries on Solaris systems, without
+*** introducing a dependency on libgcc.a.  Therefore, libtool is disabling
+*** -no-undefined support, which will at least allow you to build shared
+*** libraries.  However, you may find that when you link such libraries
+*** into an application without using GCC, you have to manually add
+*** \`gcc --print-libgcc-file-name\` to the link command.  We urge you to
+*** upgrade to a newer version of GCC.  Another option is to rebuild your
+*** current GCC to use the GNU linker from GNU binutils 2.9.1 or newer.
+
+EOF
+        no_undefined_flag=
+	;;
+      esac
+    fi
+    # $CC -shared without GNU ld will not create a library from C++
+    # object files and a static libstdc++, better avoid it by now
+    archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    archive_expsym_cmds='$echo "{ global:" > $lib.exp~cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+		$LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$rm $lib.exp'
+    hardcode_libdir_flag_spec='-R$libdir'
+    hardcode_shlibpath_var=no
+    case $host_os in
+    solaris2.[0-5] | solaris2.[0-5].*) ;;
+    *) # Supported since Solaris 2.6 (maybe 2.5.1?)
+      whole_archive_flag_spec='-z allextract$convenience -z defaultextract' ;;
+    esac
+    link_all_deplibs=yes
+    ;;
+
+  sunos4*)
+    if test "x$host_vendor" = xsequent; then
+      # Use $CC to link under sequent, because it throws in some extra .o
+      # files that make .init and .fini sections work.
+      archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+    else
+      archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+    fi
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_direct=yes
+    hardcode_minus_L=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  sysv4)
+    case $host_vendor in
+      sni)
+        archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+        hardcode_direct=yes # is this really true???
+        ;;
+      siemens)
+        ## LD is ld it makes a PLAMLIB
+        ## CC just makes a GrossModule.
+        archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+        reload_cmds='$CC -r -o $output$reload_objs'
+        hardcode_direct=no
+        ;;
+      motorola)
+        archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+        hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+        ;;
+    esac
+    runpath_var='LD_RUN_PATH'
+    hardcode_shlibpath_var=no
+    ;;
+
+  sysv4.3*)
+    archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_shlibpath_var=no
+    export_dynamic_flag_spec='-Bexport'
+    ;;
+
+  sysv5*)
+    no_undefined_flag=' -z text'
+    # $CC -shared without GNU ld will not create a library from C++
+    # object files and a static libstdc++, better avoid it by now
+    archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    archive_expsym_cmds='$echo "{ global:" > $lib.exp~cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+		$LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$rm $lib.exp'
+    hardcode_libdir_flag_spec=
+    hardcode_shlibpath_var=no
+    runpath_var='LD_RUN_PATH'
+    ;;
+
+  uts4*)
+    archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_shlibpath_var=no
+    ;;
+
+  dgux*)
+    archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_shlibpath_var=no
+    ;;
+
+  sysv4*MP*)
+    if test -d /usr/nec; then
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_shlibpath_var=no
+      runpath_var=LD_RUN_PATH
+      hardcode_runpath_var=yes
+      ld_shlibs=yes
+    fi
+    ;;
+
+  sysv4.2uw2*)
+    archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_direct=yes
+    hardcode_minus_L=no
+    hardcode_shlibpath_var=no
+    hardcode_runpath_var=yes
+    runpath_var=LD_RUN_PATH
+    ;;
+
+  sysv5uw7* | unixware7*)
+    no_undefined_flag='${wl}-z ${wl}text'
+    if test "$GCC" = yes; then
+      archive_cmds='$CC -shared ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+    else
+      archive_cmds='$CC -G ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+    fi
+    runpath_var='LD_RUN_PATH'
+    hardcode_shlibpath_var=no
+    ;;
+
+  *)
+    ld_shlibs=no
+    ;;
+  esac
+fi
+echo "$as_me:$LINENO: result: $ld_shlibs" >&5
+echo "${ECHO_T}$ld_shlibs" >&6
+test "$ld_shlibs" = no && can_build_shared=no
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+# Check hardcoding attributes.
+echo "$as_me:$LINENO: checking how to hardcode library paths into programs" >&5
+echo $ECHO_N "checking how to hardcode library paths into programs... $ECHO_C" >&6
+hardcode_action=
+if test -n "$hardcode_libdir_flag_spec" || \
+   test -n "$runpath_var"; then
+
+  # We can hardcode non-existant directories.
+  if test "$hardcode_direct" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$hardcode_shlibpath_var" != no &&
+     test "$hardcode_minus_L" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action=unsupported
+fi
+echo "$as_me:$LINENO: result: $hardcode_action" >&5
+echo "${ECHO_T}$hardcode_action" >&6
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+striplib=
+old_striplib=
+echo "$as_me:$LINENO: checking whether stripping libraries is possible" >&5
+echo $ECHO_N "checking whether stripping libraries is possible... $ECHO_C" >&6
+if test -n "$STRIP" && $STRIP -V 2>&1 | grep "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+##
+## END FIXME
+
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+## FIXME: this should be a separate macro
+##
+# PORTME Fill in your ld.so characteristics
+echo "$as_me:$LINENO: checking dynamic linker characteristics" >&5
+echo $ECHO_N "checking dynamic linker characteristics... $ECHO_C" >&6
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}.so$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}.so$major'
+  ;;
+
+aix4* | aix5*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}.so$major ${libname}${release}.so$versuffix $libname.so'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+	if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	     echo ' yes '
+	     echo '#endif'; } | ${CC} -E - | grep yes > /dev/null; then
+	  :
+	else
+	  can_build_shared=no
+	fi
+	;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can
+    # not hardcode correct soname into executable. Probably we can
+    # add versioning support to collect2, so additional links can
+    # be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}.so$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  hardcode_into_libs=yes
+  ;;
+
+amigaos*)
+  library_names_spec='$libname.ixlibrary $libname.a'
+  # Create ${libname}_ixlibrary.a entries in /sys/libs.
+  finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$echo "X$lib" | $Xsed -e '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $rm /sys/libs/${libname}_ixlibrary.a; $show "(cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a)"; (cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a) || exit 1; done'
+  ;;
+
+beos*)
+  library_names_spec='${libname}.so'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi4*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  export_dynamic_flag_spec=-rdynamic
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32*)
+  version_type=windows
+  need_version=no
+  need_lib_prefix=no
+  case $GCC,$host_os in
+  yes,cygwin*)
+    library_names_spec='$libname.dll.a'
+    soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | sed -e 's/[.]/-/g'`${versuffix}.dll'
+    postinstall_cmds='dlpath=`bash 2>&1 -c '\''. $dir/${file}i;echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog .libs/$dlname \$dldir/$dlname'
+    postuninstall_cmds='dldll=`bash 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $rm \$dlpath'
+    ;;
+  yes,mingw*)
+    library_names_spec='${libname}`echo ${release} | sed -e 's/[.]/-/g'`${versuffix}.dll'
+    sys_lib_search_path_spec=`$CC -print-search-dirs | grep "^libraries:" | sed -e "s/^libraries://" -e "s/;/ /g" -e "s,=/,/,g"`
+    ;;
+  yes,pw32*)
+    library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | sed -e 's/./-/g'`${versuffix}.dll'
+    ;;
+  *)
+    library_names_spec='${libname}`echo ${release} | sed -e 's/[.]/-/g'`${versuffix}.dll $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  # FIXME: Relying on posixy $() will cause problems for
+  #        cross-compilation, but unfortunately the echo tests do not
+  #        yet detect zsh echo's removal of \ escapes.
+  library_names_spec='${libname}${release}${versuffix}.$(test .$module = .yes && echo so || echo dylib) ${libname}${release}${major}.$(test .$module = .yes && echo so || echo dylib) ${libname}.$(test .$module = .yes && echo so || echo dylib)'
+  soname_spec='${libname}${release}${major}.$(test .$module = .yes && echo so || echo dylib)'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  ;;
+
+freebsd1*)
+  dynamic_linker=no
+  ;;
+
+freebsd*)
+  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so $libname.so'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}.so$versuffix $libname.so$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  *)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so${major} ${libname}.so'
+  soname_spec='${libname}${release}.so$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  dynamic_linker="$host_os dld.sl"
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  shlibpath_var=SHLIB_PATH
+  shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+  library_names_spec='${libname}${release}.sl$versuffix ${libname}${release}.sl$major $libname.sl'
+  soname_spec='${libname}${release}.sl$major'
+  # HP-UX runs *really* slowly unless shared libraries are mode 555.
+  postinstall_cmds='chmod 555 $lib'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)          version_type=irix ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}.so$major'
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major ${libname}${release}.so $libname.so'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 ") libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 ") libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 ") libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux-gnuoldld* | linux-gnuaout* | linux-gnucoff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux-gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}.so$versuffix ${libname}.so$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major ${libname}${release}.so ${libname}.so'
+    soname_spec='${libname}${release}.so$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+openbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case "$host_os" in
+    openbsd2.[89] | openbsd2.[89].*)
+      shlibpath_overrides_runpath=no
+      ;;
+    *)
+      shlibpath_overrides_runpath=yes
+      ;;
+    esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  library_names_spec='${libname}${release}.so$versuffix ${libname}.so$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+os2*)
+  libname_spec='$name'
+  need_lib_prefix=no
+  library_names_spec='$libname.dll $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_version=no
+  soname_spec='${libname}${release}.so$major'
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  hardcode_into_libs=yes
+  ;;
+
+sco3.2v5*)
+  version_type=osf
+  soname_spec='${libname}${release}.so$major'
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}.so$versuffix ${libname}.so$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+  version_type=linux
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      export_dynamic_flag_spec='${wl}-Blargedynsym'
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname.so.$versuffix $libname.so.$major $libname.so'
+    soname_spec='$libname.so.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+echo "$as_me:$LINENO: result: $dynamic_linker" >&5
+echo "${ECHO_T}$dynamic_linker" >&6
+test "$dynamic_linker" = no && can_build_shared=no
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+# Report the final consequences.
+echo "$as_me:$LINENO: checking if libtool supports shared libraries" >&5
+echo $ECHO_N "checking if libtool supports shared libraries... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $can_build_shared" >&5
+echo "${ECHO_T}$can_build_shared" >&6
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+echo "$as_me:$LINENO: checking whether to build shared libraries" >&5
+echo $ECHO_N "checking whether to build shared libraries... $ECHO_C" >&6
+test "$can_build_shared" = "no" && enable_shared=no
+
+# On AIX, shared libraries and static libraries use the same namespace, and
+# are all built from PIC.
+case "$host_os" in
+aix3*)
+  test "$enable_shared" = yes && enable_static=no
+  if test -n "$RANLIB"; then
+    archive_cmds="$archive_cmds~\$RANLIB \$lib"
+    postinstall_cmds='$RANLIB $lib'
+  fi
+  ;;
+
+aix4*)
+  if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+    test "$enable_shared" = yes && enable_static=no
+  fi
+  ;;
+esac
+echo "$as_me:$LINENO: result: $enable_shared" >&5
+echo "${ECHO_T}$enable_shared" >&6
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+echo "$as_me:$LINENO: checking whether to build static libraries" >&5
+echo $ECHO_N "checking whether to build static libraries... $ECHO_C" >&6
+# Make sure either enable_shared or enable_static is yes.
+test "$enable_shared" = yes || enable_static=yes
+echo "$as_me:$LINENO: result: $enable_static" >&5
+echo "${ECHO_T}$enable_static" >&6
+##
+## END FIXME
+
+if test "$hardcode_action" = relink; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  cygwin* | mingw* | pw32*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+   ;;
+
+  *)
+    echo "$as_me:$LINENO: checking for shl_load" >&5
+echo $ECHO_N "checking for shl_load... $ECHO_C" >&6
+if test "${ac_cv_func_shl_load+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char shl_load (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char shl_load ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_shl_load) || defined (__stub___shl_load)
+choke me
+#else
+char (*f) () = shl_load;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != shl_load;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_shl_load=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_shl_load=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_shl_load" >&5
+echo "${ECHO_T}$ac_cv_func_shl_load" >&6
+if test $ac_cv_func_shl_load = yes; then
+  lt_cv_dlopen="shl_load"
+else
+  echo "$as_me:$LINENO: checking for shl_load in -ldld" >&5
+echo $ECHO_N "checking for shl_load in -ldld... $ECHO_C" >&6
+if test "${ac_cv_lib_dld_shl_load+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char shl_load ();
+int
+main ()
+{
+shl_load ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dld_shl_load=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_dld_shl_load=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_dld_shl_load" >&5
+echo "${ECHO_T}$ac_cv_lib_dld_shl_load" >&6
+if test $ac_cv_lib_dld_shl_load = yes; then
+  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-dld"
+else
+  echo "$as_me:$LINENO: checking for dlopen" >&5
+echo $ECHO_N "checking for dlopen... $ECHO_C" >&6
+if test "${ac_cv_func_dlopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char dlopen (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dlopen ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_dlopen) || defined (__stub___dlopen)
+choke me
+#else
+char (*f) () = dlopen;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != dlopen;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_dlopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_dlopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_dlopen" >&5
+echo "${ECHO_T}$ac_cv_func_dlopen" >&6
+if test $ac_cv_func_dlopen = yes; then
+  lt_cv_dlopen="dlopen"
+else
+  echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
+echo $ECHO_N "checking for dlopen in -ldl... $ECHO_C" >&6
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dlopen ();
+int
+main ()
+{
+dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dl_dlopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_dl_dlopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
+echo "${ECHO_T}$ac_cv_lib_dl_dlopen" >&6
+if test $ac_cv_lib_dl_dlopen = yes; then
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+  echo "$as_me:$LINENO: checking for dlopen in -lsvld" >&5
+echo $ECHO_N "checking for dlopen in -lsvld... $ECHO_C" >&6
+if test "${ac_cv_lib_svld_dlopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsvld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dlopen ();
+int
+main ()
+{
+dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_svld_dlopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_svld_dlopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_svld_dlopen" >&5
+echo "${ECHO_T}$ac_cv_lib_svld_dlopen" >&6
+if test $ac_cv_lib_svld_dlopen = yes; then
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
+else
+  echo "$as_me:$LINENO: checking for dld_link in -ldld" >&5
+echo $ECHO_N "checking for dld_link in -ldld... $ECHO_C" >&6
+if test "${ac_cv_lib_dld_dld_link+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dld_link ();
+int
+main ()
+{
+dld_link ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dld_dld_link=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_dld_dld_link=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_dld_dld_link" >&5
+echo "${ECHO_T}$ac_cv_lib_dld_dld_link" >&6
+if test $ac_cv_lib_dld_dld_link = yes; then
+  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-dld"
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+        test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    echo "$as_me:$LINENO: checking whether a program can dlopen itself" >&5
+echo $ECHO_N "checking whether a program can dlopen itself... $ECHO_C" >&6
+if test "${lt_cv_dlopen_self+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self=cross
+else
+    lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<EOF
+#line 7552 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+#ifdef __cplusplus
+extern "C" void exit (int);
+#endif
+
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
+
+    exit (status);
+}
+EOF
+  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_unknown|x*) lt_cv_dlopen_self=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+echo "$as_me:$LINENO: result: $lt_cv_dlopen_self" >&5
+echo "${ECHO_T}$lt_cv_dlopen_self" >&6
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      LDFLAGS="$LDFLAGS $link_static_flag"
+      echo "$as_me:$LINENO: checking whether a statically linked program can dlopen itself" >&5
+echo $ECHO_N "checking whether a statically linked program can dlopen itself... $ECHO_C" >&6
+if test "${lt_cv_dlopen_self_static+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self_static=cross
+else
+    lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<EOF
+#line 7650 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+#ifdef __cplusplus
+extern "C" void exit (int);
+#endif
+
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
+
+    exit (status);
+}
+EOF
+  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_unknown|x*) lt_cv_dlopen_self_static=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self_static=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+echo "$as_me:$LINENO: result: $lt_cv_dlopen_self_static" >&5
+echo "${ECHO_T}$lt_cv_dlopen_self_static" >&6
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+
+
+## FIXME: this should be a separate macro
+##
+if test "$enable_shared" = yes && test "$GCC" = yes; then
+  case $archive_cmds in
+  *'~'*)
+    # FIXME: we may have to deal with multi-command sequences.
+    ;;
+  '$CC '*)
+    # Test whether the compiler implicitly links with -lc since on some
+    # systems, -lgcc has to come before -lc. If gcc already passes -lc
+    # to ld, don't add -lc before -lgcc.
+    echo "$as_me:$LINENO: checking whether -lc should be explicitly linked in" >&5
+echo $ECHO_N "checking whether -lc should be explicitly linked in... $ECHO_C" >&6
+    if test "${lt_cv_archive_cmds_need_lc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  $rm conftest*
+    echo 'static int dummy;' > conftest.$ac_ext
+
+    if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+      soname=conftest
+      lib=conftest
+      libobjs=conftest.$ac_objext
+      deplibs=
+      wl=$lt_cv_prog_cc_wl
+      compiler_flags=-v
+      linker_flags=-v
+      verstring=
+      output_objdir=.
+      libname=conftest
+      save_allow_undefined_flag=$allow_undefined_flag
+      allow_undefined_flag=
+      if { (eval echo "$as_me:$LINENO: \"$archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\"") >&5
+  (eval $archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+      then
+	lt_cv_archive_cmds_need_lc=no
+      else
+	lt_cv_archive_cmds_need_lc=yes
+      fi
+      allow_undefined_flag=$save_allow_undefined_flag
+    else
+      cat conftest.err 1>&5
+    fi
+fi
+
+    echo "$as_me:$LINENO: result: $lt_cv_archive_cmds_need_lc" >&5
+echo "${ECHO_T}$lt_cv_archive_cmds_need_lc" >&6
+    ;;
+  esac
+fi
+need_lc=${lt_cv_archive_cmds_need_lc-yes}
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+# The second clause should only fire when bootstrapping the
+# libtool distribution, otherwise you forgot to ship ltmain.sh
+# with your package, and you will get complaints that there are
+# no rules to generate ltmain.sh.
+if test -f "$ltmain"; then
+  :
+else
+  # If there is no Makefile yet, we rely on a make rule to execute
+  # `config.status --recheck' to rerun these tests and create the
+  # libtool script then.
+  test -f Makefile && make "$ltmain"
+fi
+
+if test -f "$ltmain"; then
+  trap "$rm \"${ofile}T\"; exit 1" 1 2 15
+  $rm -f "${ofile}T"
+
+  echo creating $ofile
+
+  # Now quote all the things that may contain metacharacters while being
+  # careful not to overquote the AC_SUBSTed values.  We take copies of the
+  # variables and quote the copies for generation of the libtool script.
+  for var in echo old_CC old_CFLAGS SED \
+    AR AR_FLAGS CC LD LN_S NM SHELL \
+    reload_flag reload_cmds wl \
+    pic_flag link_static_flag no_builtin_flag export_dynamic_flag_spec \
+    thread_safe_flag_spec whole_archive_flag_spec libname_spec \
+    library_names_spec soname_spec \
+    RANLIB old_archive_cmds old_archive_from_new_cmds old_postinstall_cmds \
+    old_postuninstall_cmds archive_cmds archive_expsym_cmds postinstall_cmds \
+    postuninstall_cmds extract_expsyms_cmds old_archive_from_expsyms_cmds \
+    old_striplib striplib file_magic_cmd export_symbols_cmds \
+    deplibs_check_method allow_undefined_flag no_undefined_flag \
+    finish_cmds finish_eval global_symbol_pipe global_symbol_to_cdecl \
+    global_symbol_to_c_name_address \
+    hardcode_libdir_flag_spec hardcode_libdir_separator  \
+    sys_lib_search_path_spec sys_lib_dlsearch_path_spec \
+    compiler_c_o compiler_o_lo need_locks exclude_expsyms include_expsyms; do
+
+    case $var in
+    reload_cmds | old_archive_cmds | old_archive_from_new_cmds | \
+    old_postinstall_cmds | old_postuninstall_cmds | \
+    export_symbols_cmds | archive_cmds | archive_expsym_cmds | \
+    extract_expsyms_cmds | old_archive_from_expsyms_cmds | \
+    postinstall_cmds | postuninstall_cmds | \
+    finish_cmds | sys_lib_search_path_spec | sys_lib_dlsearch_path_spec)
+      # Double-quote double-evaled strings.
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$double_quote_subst\" -e \"\$sed_quote_subst\" -e \"\$delay_variable_subst\"\`\\\""
+      ;;
+    *)
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$sed_quote_subst\"\`\\\""
+      ;;
+    esac
+  done
+
+  cat <<__EOF__ > "${ofile}T"
+#! $SHELL
+
+# `$echo "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $PROGRAM (GNU $PACKAGE $VERSION$TIMESTAMP)
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+# Copyright (C) 1996-2000 Free Software Foundation, Inc.
+# Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# A sed that does not truncate output.
+SED=$lt_SED
+
+# Sed that helps us avoid accidentally triggering echo(1) options like -n.
+Xsed="${SED} -e s/^X//"
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+if test "X\${CDPATH+set}" = Xset; then CDPATH=:; export CDPATH; fi
+
+# ### BEGIN LIBTOOL CONFIG
+
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
+
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
+
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$need_lc
+
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
+
+# The host system.
+host_alias=$host_alias
+host=$host
+
+# An echo program that does not interpret backslashes.
+echo=$lt_echo
+
+# The archiver.
+AR=$lt_AR
+AR_FLAGS=$lt_AR_FLAGS
+
+# The default C compiler.
+CC=$lt_CC
+
+# Is the compiler the GNU C compiler?
+with_gcc=$GCC
+
+# The linker used to build libraries.
+LD=$lt_LD
+
+# Whether we need hard or soft links.
+LN_S=$lt_LN_S
+
+# A BSD-compatible nm program.
+NM=$lt_NM
+
+# A symbol stripping program
+STRIP=$STRIP
+
+# Used to examine libraries when file_magic_cmd begins "file"
+MAGIC_CMD=$MAGIC_CMD
+
+# Used on cygwin: DLL creation program.
+DLLTOOL="$DLLTOOL"
+
+# Used on cygwin: object dumper.
+OBJDUMP="$OBJDUMP"
+
+# Used on cygwin: assembler.
+AS="$AS"
+
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
+
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
+
+# How to pass a linker flag through the compiler.
+wl=$lt_wl
+
+# Object file suffix (normally "o").
+objext="$ac_objext"
+
+# Old archive suffix (normally "a").
+libext="$libext"
+
+# Executable file suffix (normally "").
+exeext="$exeext"
+
+# Additional compiler flags for building library objects.
+pic_flag=$lt_pic_flag
+pic_mode=$pic_mode
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_compiler_c_o
+
+# Can we write directly to a .lo ?
+compiler_o_lo=$lt_compiler_o_lo
+
+# Must we lock files when doing compilation ?
+need_locks=$lt_need_locks
+
+# Do we need the lib prefix for modules?
+need_lib_prefix=$need_lib_prefix
+
+# Do we need a version for libraries?
+need_version=$need_version
+
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
+
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
+
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_link_static_flag
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_no_builtin_flag
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec
+
+# Compiler flag to generate thread-safe objects.
+thread_safe_flag_spec=$lt_thread_safe_flag_spec
+
+# Library versioning type.
+version_type=$version_type
+
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME.
+library_names_spec=$lt_library_names_spec
+
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
+
+# Commands used to build and install an old-style archive.
+RANLIB=$lt_RANLIB
+old_archive_cmds=$lt_old_archive_cmds
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
+
+# Commands used to build and install a shared archive.
+archive_cmds=$lt_archive_cmds
+archive_expsym_cmds=$lt_archive_expsym_cmds
+postinstall_cmds=$lt_postinstall_cmds
+postuninstall_cmds=$lt_postuninstall_cmds
+
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
+
+# Command to use when deplibs_check_method == file_magic.
+file_magic_cmd=$lt_file_magic_cmd
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag
+
+# Flag that forces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
+
+# Same as above, but a single script fragment to be evaled but not shown.
+finish_eval=$lt_finish_eval
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_global_symbol_pipe
+
+# Transform the output of nm in a proper C declaration
+global_symbol_to_cdecl=$lt_global_symbol_to_cdecl
+
+# Transform the output of nm in a C name address pair
+global_symbol_to_c_name_address=$lt_global_symbol_to_c_name_address
+
+# This is the shared library runtime path variable.
+runpath_var=$runpath_var
+
+# This is the shared library path variable.
+shlibpath_var=$shlibpath_var
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator
+
+# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct=$hardcode_direct
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L=$hardcode_minus_L
+
+# Set to yes if using SHLIBPATH_VAR=DIR during linking hardcodes DIR into
+# the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at relink time.
+variables_saved_for_relink="$variables_saved_for_relink"
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs
+
+# Compile-time system search path for libraries
+sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
+
+# Run-time system search path for libraries
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
+
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path="$fix_srcfile_path"
+
+# Set to yes if exported symbols are required.
+always_export_symbols=$always_export_symbols
+
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms
+
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms
+
+# ### END LIBTOOL CONFIG
+
+__EOF__
+
+  case $host_os in
+  aix3*)
+    cat <<\EOF >> "${ofile}T"
+
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+EOF
+    ;;
+  esac
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | os2*)
+    cat <<'EOF' >> "${ofile}T"
+      # This is a source program that is used to create dlls on Windows
+      # Don't remove nor modify the starting and closing comments
+# /* ltdll.c starts here */
+# #define WIN32_LEAN_AND_MEAN
+# #include <windows.h>
+# #undef WIN32_LEAN_AND_MEAN
+# #include <stdio.h>
+#
+# #ifndef __CYGWIN__
+# #  ifdef __CYGWIN32__
+# #    define __CYGWIN__ __CYGWIN32__
+# #  endif
+# #endif
+#
+# #ifdef __cplusplus
+# extern "C" {
+# #endif
+# BOOL APIENTRY DllMain (HINSTANCE hInst, DWORD reason, LPVOID reserved);
+# #ifdef __cplusplus
+# }
+# #endif
+#
+# #ifdef __CYGWIN__
+# #include <cygwin/cygwin_dll.h>
+# DECLARE_CYGWIN_DLL( DllMain );
+# #endif
+# HINSTANCE __hDllInstance_base;
+#
+# BOOL APIENTRY
+# DllMain (HINSTANCE hInst, DWORD reason, LPVOID reserved)
+# {
+#   __hDllInstance_base = hInst;
+#   return TRUE;
+# }
+# /* ltdll.c ends here */
+	# This is a source program that is used to create import libraries
+	# on Windows for dlls which lack them. Don't remove nor modify the
+	# starting and closing comments
+# /* impgen.c starts here */
+# /*   Copyright (C) 1999-2000 Free Software Foundation, Inc.
+#
+#  This file is part of GNU libtool.
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 2 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program; if not, write to the Free Software
+#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#  */
+#
+# #include <stdio.h>		/* for printf() */
+# #include <unistd.h>		/* for open(), lseek(), read() */
+# #include <fcntl.h>		/* for O_RDONLY, O_BINARY */
+# #include <string.h>		/* for strdup() */
+#
+# /* O_BINARY isn't required (or even defined sometimes) under Unix */
+# #ifndef O_BINARY
+# #define O_BINARY 0
+# #endif
+#
+# static unsigned int
+# pe_get16 (fd, offset)
+#      int fd;
+#      int offset;
+# {
+#   unsigned char b[2];
+#   lseek (fd, offset, SEEK_SET);
+#   read (fd, b, 2);
+#   return b[0] + (b[1]<<8);
+# }
+#
+# static unsigned int
+# pe_get32 (fd, offset)
+#     int fd;
+#     int offset;
+# {
+#   unsigned char b[4];
+#   lseek (fd, offset, SEEK_SET);
+#   read (fd, b, 4);
+#   return b[0] + (b[1]<<8) + (b[2]<<16) + (b[3]<<24);
+# }
+#
+# static unsigned int
+# pe_as32 (ptr)
+#      void *ptr;
+# {
+#   unsigned char *b = ptr;
+#   return b[0] + (b[1]<<8) + (b[2]<<16) + (b[3]<<24);
+# }
+#
+# int
+# main (argc, argv)
+#     int argc;
+#     char *argv[];
+# {
+#     int dll;
+#     unsigned long pe_header_offset, opthdr_ofs, num_entries, i;
+#     unsigned long export_rva, export_size, nsections, secptr, expptr;
+#     unsigned long name_rvas, nexp;
+#     unsigned char *expdata, *erva;
+#     char *filename, *dll_name;
+#
+#     filename = argv[1];
+#
+#     dll = open(filename, O_RDONLY|O_BINARY);
+#     if (dll < 1)
+# 	return 1;
+#
+#     dll_name = filename;
+#
+#     for (i=0; filename[i]; i++)
+# 	if (filename[i] == '/' || filename[i] == '\\'  || filename[i] == ':')
+# 	    dll_name = filename + i +1;
+#
+#     pe_header_offset = pe_get32 (dll, 0x3c);
+#     opthdr_ofs = pe_header_offset + 4 + 20;
+#     num_entries = pe_get32 (dll, opthdr_ofs + 92);
+#
+#     if (num_entries < 1) /* no exports */
+# 	return 1;
+#
+#     export_rva = pe_get32 (dll, opthdr_ofs + 96);
+#     export_size = pe_get32 (dll, opthdr_ofs + 100);
+#     nsections = pe_get16 (dll, pe_header_offset + 4 +2);
+#     secptr = (pe_header_offset + 4 + 20 +
+# 	      pe_get16 (dll, pe_header_offset + 4 + 16));
+#
+#     expptr = 0;
+#     for (i = 0; i < nsections; i++)
+#     {
+# 	char sname[8];
+# 	unsigned long secptr1 = secptr + 40 * i;
+# 	unsigned long vaddr = pe_get32 (dll, secptr1 + 12);
+# 	unsigned long vsize = pe_get32 (dll, secptr1 + 16);
+# 	unsigned long fptr = pe_get32 (dll, secptr1 + 20);
+# 	lseek(dll, secptr1, SEEK_SET);
+# 	read(dll, sname, 8);
+# 	if (vaddr <= export_rva && vaddr+vsize > export_rva)
+# 	{
+# 	    expptr = fptr + (export_rva - vaddr);
+# 	    if (export_rva + export_size > vaddr + vsize)
+# 		export_size = vsize - (export_rva - vaddr);
+# 	    break;
+# 	}
+#     }
+#
+#     expdata = (unsigned char*)malloc(export_size);
+#     lseek (dll, expptr, SEEK_SET);
+#     read (dll, expdata, export_size);
+#     erva = expdata - export_rva;
+#
+#     nexp = pe_as32 (expdata+24);
+#     name_rvas = pe_as32 (expdata+32);
+#
+#     printf ("EXPORTS\n");
+#     for (i = 0; i<nexp; i++)
+#     {
+# 	unsigned long name_rva = pe_as32 (erva+name_rvas+i*4);
+# 	printf ("\t%s @ %ld ;\n", erva+name_rva, 1+ i);
+#     }
+#
+#     return 0;
+# }
+# /* impgen.c ends here */
+
+EOF
+    ;;
+  esac
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '$q' "$ltmain" >> "${ofile}T" || (rm -f "${ofile}T"; exit 1)
+
+  mv -f "${ofile}T" "$ofile" || \
+    (rm -f "$ofile" && cp "${ofile}T" "$ofile" && rm -f "${ofile}T")
+  chmod +x "$ofile"
+fi
+##
+## END FIXME
+
+
+
+
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ac_aux_dir/ltmain.sh"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+
+# Prevent multiple expansion
+
+
+
+
+# Checks for programs.
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# ./install, which can be erroneously created by make from ./install.sh.
+echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+        if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+          if test $ac_prog = install &&
+            grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+            # AIX install.  It has an incompatible calling convention.
+            :
+          elif test $ac_prog = install &&
+            grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+            # program-specific install script used by HP pwplus--don't use.
+            :
+          else
+            ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+            break 3
+          fi
+        fi
+      done
+    done
+    ;;
+esac
+done
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL=$ac_install_sh
+  fi
+fi
+echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+echo "$as_me:$LINENO: checking whether ln -s works" >&5
+echo $ECHO_N "checking whether ln -s works... $ECHO_C" >&6
+LN_S=$as_ln_s
+if test "$LN_S" = "ln -s"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+  echo "$as_me:$LINENO: result: no, using $LN_S" >&5
+echo "${ECHO_T}no, using $LN_S" >&6
+fi
+
+echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,./+-,__p_,'`
+if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.make <<\_ACEOF
+all:
+	@echo 'ac_maketemp="$(MAKE)"'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+eval `${MAKE-make} -f conftest.make 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
+rm -f conftest.make
+fi
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  SET_MAKE=
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+# Extract the first word of "ps", so it can be a program name with args.
+set dummy ps; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_PSPROG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $PSPROG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PSPROG="$PSPROG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_PSPROG="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  ;;
+esac
+fi
+PSPROG=$ac_cv_path_PSPROG
+
+if test -n "$PSPROG"; then
+  echo "$as_me:$LINENO: result: $PSPROG" >&5
+echo "${ECHO_T}$PSPROG" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+# Extract the first word of "perl", so it can be a program name with args.
+set dummy perl; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_PERLPROG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $PERLPROG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PERLPROG="$PERLPROG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_PERLPROG="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  ;;
+esac
+fi
+PERLPROG=$ac_cv_path_PERLPROG
+
+if test -n "$PERLPROG"; then
+  echo "$as_me:$LINENO: result: $PERLPROG" >&5
+echo "${ECHO_T}$PERLPROG" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+for ac_prog in whoami logname
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_WHOAMI+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$WHOAMI"; then
+  ac_cv_prog_WHOAMI="$WHOAMI" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_WHOAMI="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+WHOAMI=$ac_cv_prog_WHOAMI
+if test -n "$WHOAMI"; then
+  echo "$as_me:$LINENO: result: $WHOAMI" >&5
+echo "${ECHO_T}$WHOAMI" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$WHOAMI" && break
+done
+test -n "$WHOAMI" || WHOAMI="whoami"
+
+for ac_prog in sed gsed
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_SED+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$SED"; then
+  ac_cv_prog_SED="$SED" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_SED="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+SED=$ac_cv_prog_SED
+if test -n "$SED"; then
+  echo "$as_me:$LINENO: result: $SED" >&5
+echo "${ECHO_T}$SED" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$SED" && break
+done
+
+# Extract the first word of "autoconf", so it can be a program name with args.
+set dummy autoconf; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_AUTOCONF+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$AUTOCONF"; then
+  ac_cv_prog_AUTOCONF="$AUTOCONF" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AUTOCONF=""
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+AUTOCONF=$ac_cv_prog_AUTOCONF
+if test -n "$AUTOCONF"; then
+  echo "$as_me:$LINENO: result: $AUTOCONF" >&5
+echo "${ECHO_T}$AUTOCONF" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+# Extract the first word of "autoheader", so it can be a program name with args.
+set dummy autoheader; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_AUTOHEADER+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$AUTOHEADER"; then
+  ac_cv_prog_AUTOHEADER="$AUTOHEADER" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AUTOHEADER=""
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+AUTOHEADER=$ac_cv_prog_AUTOHEADER
+if test -n "$AUTOHEADER"; then
+  echo "$as_me:$LINENO: result: $AUTOHEADER" >&5
+echo "${ECHO_T}$AUTOHEADER" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+if test "x$ac_cv_prog_AUTOCONF" = "x"; then
+	AUTOCONF=":"
+
+fi
+if test "x$ac_cv_prog_AUTOHEADER" = "x"; then
+	AUTOHEADER=":"
+
+fi
+
+# Extract the first word of "uname", so it can be a program name with args.
+set dummy uname; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_UNAMEPROG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $UNAMEPROG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_UNAMEPROG="$UNAMEPROG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_UNAMEPROG="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  ;;
+esac
+fi
+UNAMEPROG=$ac_cv_path_UNAMEPROG
+
+if test -n "$UNAMEPROG"; then
+  echo "$as_me:$LINENO: result: $UNAMEPROG" >&5
+echo "${ECHO_T}$UNAMEPROG" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define UNAMEPROG "$UNAMEPROG"
+_ACEOF
+
+
+echo "$as_me:$LINENO: checking for an ANSI C-conforming const" >&5
+echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6
+if test "${ac_cv_c_const+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+/* FIXME: Include the comments suggested by Paul. */
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this.  */
+  typedef int charset[2];
+  const charset x;
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *ccp;
+  char **p;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = "string";
+  ccp = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++ccp;
+  p = (char**) ccp;
+  ccp = (char const *const *) p;
+  { /* SCO 3.2v4 cc rejects this.  */
+    char *t;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this saying
+       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; };
+    struct s *b; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+  }
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_const=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_c_const=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
+echo "${ECHO_T}$ac_cv_c_const" >&6
+if test $ac_cv_c_const = no; then
+
+cat >>confdefs.h <<\_ACEOF
+#define const
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for inline" >&5
+echo $ECHO_N "checking for inline... $ECHO_C" >&6
+if test "${ac_cv_c_inline+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifndef __cplusplus
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
+#endif
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_inline=$ac_kw; break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+done
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
+echo "${ECHO_T}$ac_cv_c_inline" >&6
+case $ac_cv_c_inline in
+  inline | yes) ;;
+  no)
+cat >>confdefs.h <<\_ACEOF
+#define inline
+_ACEOF
+ ;;
+  *)  cat >>confdefs.h <<_ACEOF
+#define inline $ac_cv_c_inline
+_ACEOF
+ ;;
+esac
+
+
+# get version number.
+echo "$as_me:$LINENO: checking for net-snmp version number" >&5
+echo $ECHO_N "checking for net-snmp version number... $ECHO_C" >&6
+VERSION=`grep NetSnmpVersionInfo.*= $srcdir/snmplib/snmp_version.c | sed 's/";.*//;s/.*"//;s/pre/0./;'`
+
+RELEASEVERSION=`echo $VERSION | sed 's/^\([0-9]\)\.\([0-9]\)/\1:\2:0/'`
+
+
+
+echo "$as_me:$LINENO: result: $VERSION" >&5
+echo "${ECHO_T}$VERSION" >&6
+
+  cat >> configure-summary << EOF
+  Net-SNMP Version:           $VERSION
+EOF
+
+
+# super type checking
+# WWWXXX
+echo "$as_me:$LINENO: checking for developer gcc flags" >&5
+echo $ECHO_N "checking for developer gcc flags... $ECHO_C" >&6
+if test "x$developer" = "xyes" -a "x$GCC" = "xyes"; then
+  DEVFLAGS="-Wall -Winline -Wstrict-prototypes -Wwrite-strings -Wcast-qual -Wno-char-subscripts"
+else
+  DEVFLAGS=""
+fi
+echo "$as_me:$LINENO: result: $DEVFLAGS" >&5
+echo "${ECHO_T}$DEVFLAGS" >&6
+
+
+# system check
+echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6
+if test "${ac_cv_target+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_target_alias=$target_alias
+test "x$ac_cv_target_alias" = "x" &&
+  ac_cv_target_alias=$ac_cv_host_alias
+ac_cv_target=`$ac_config_sub $ac_cv_target_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_target_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6
+target=$ac_cv_target
+target_cpu=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+PARTIALTARGETOS=`echo $target_os | sed 's/[-._].*//'`
+CFLAGS="$CFLAGS -D$PARTIALTARGETOS" -Os -mips2 -mtune=4kc -Wall
+
+
+  cat >> configure-summary << EOF
+  Building for:               $PARTIALTARGETOS
+EOF
+
+
+#
+# check for special includes and pick one
+#
+
+echo "$as_me:$LINENO: checking for system include file" >&5
+echo $ECHO_N "checking for system include file... $ECHO_C" >&6
+
+filebase=$target_os
+# ignore binary format indication
+filebase=`echo $filebase | sed 's/elf//'`
+filebase=`echo $filebase | sed 's/aout//'`
+filebase=`echo $filebase | sed 's/ecoff//'`
+filebase=`echo $filebase | sed 's/coff//'`
+while test "x$filebase" != "x$last" -a ! -f $srcdir/include/net-snmp/system/$filebase.h
+do
+    last=$filebase
+    filebase=`echo $filebase | sed 's/[-._][^-._]*$//'`
+    if test "x$filebase" = "x$last"; then
+	filebase=`echo $filebase | sed 's/[0-9]*$//'`
+    fi
+done
+
+if test "x$filebase" = "x$last"; then
+    filebase="generic"
+fi
+ac_cv_SYSTEM_INCLUDE_FILE="net-snmp/system/$filebase.h"
+
+
+echo "$as_me:$LINENO: result: $ac_cv_SYSTEM_INCLUDE_FILE" >&5
+echo "${ECHO_T}$ac_cv_SYSTEM_INCLUDE_FILE" >&6
+cat >>confdefs.h <<_ACEOF
+#define SYSTEM_INCLUDE_FILE "$ac_cv_SYSTEM_INCLUDE_FILE"
+_ACEOF
+
+
+# second part, the CPU type.
+
+echo "$as_me:$LINENO: checking for machine-type include file" >&5
+echo $ECHO_N "checking for machine-type include file... $ECHO_C" >&6
+
+filebase=$target_cpu
+while test "x$filebase" != "x$last" -a ! -f $srcdir/include/net-snmp/machine/$filebase.h
+do
+    last=$filebase
+    filebase=`echo $filebase | sed 's/[-._][^-._]*$//'`
+done
+
+if test "x$filebase" = "x$last"; then
+    filebase="generic"
+fi
+ac_cv_MACHINE_INCLUDE_FILE="net-snmp/machine/$filebase.h"
+
+echo "$as_me:$LINENO: result: $ac_cv_MACHINE_INCLUDE_FILE" >&5
+echo "${ECHO_T}$ac_cv_MACHINE_INCLUDE_FILE" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define MACHINE_INCLUDE_FILE "$ac_cv_MACHINE_INCLUDE_FILE"
+_ACEOF
+
+
+# Extract the first word of "$CC", so it can be a program name with args.
+set dummy $CC; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_CCPATH+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $CCPATH in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_CCPATH="$CCPATH" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_CCPATH="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  ;;
+esac
+fi
+CCPATH=$ac_cv_path_CCPATH
+
+if test -n "$CCPATH"; then
+  echo "$as_me:$LINENO: result: $CCPATH" >&5
+echo "${ECHO_T}$CCPATH" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+# watch out for /usr/ucb/cc on solaris, it doesn't work with this package.
+case $target_os in
+    bsdi*)
+	if test "x$CCPATH" = "x/usr/ucb/cc" -o "x$CCPATH" = "x/usr/bin/cc"; then
+	    { { echo "$as_me:$LINENO: error:
+
+*** The BSDI /usr/ucb/cc compiler does not work with this package.
+*** Please run configure with --with-cc=gcc
+" >&5
+echo "$as_me: error:
+
+*** The BSDI /usr/ucb/cc compiler does not work with this package.
+*** Please run configure with --with-cc=gcc
+" >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+    ;;
+    solaris*)
+	if test "x$CCPATH" = "x/usr/ucb/cc"; then
+	    { { echo "$as_me:$LINENO: error:
+
+*** The solaris /usr/ucb/cc compiler does not work with this package.
+*** Please put a different compiler in your path first or run
+*** configure with --with-cc=XX, where XX is the compiler you want to use.
+" >&5
+echo "$as_me: error:
+
+*** The solaris /usr/ucb/cc compiler does not work with this package.
+*** Please put a different compiler in your path first or run
+*** configure with --with-cc=XX, where XX is the compiler you want to use.
+" >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+    ;;
+esac
+
+echo "$as_me:$LINENO: checking for additional cpp flags" >&5
+echo $ECHO_N "checking for additional cpp flags... $ECHO_C" >&6
+# gcc extra CPPFLAGS
+if test "x$GCC" = "xyes" -a "x$CPP" = "x$CC -E"; then
+  # extra cpp flags for gnu c compiler to allow .in file extensions.
+  EXTRACPPFLAGS="-x c"
+else
+  EXTRACPPFLAGS=""
+fi
+
+# Solaris extra cpp flags.
+if test "x$GCC" != "xyes"; then
+  case $target_os in
+    solaris*) EXTRACPPFLAGS="$EXTRACPPFLAGS -Xs" ;;
+  esac
+fi
+
+
+echo "$as_me:$LINENO: result: $EXTRACPPFLAGS" >&5
+echo "${ECHO_T}$EXTRACPPFLAGS" >&6
+
+# Prefixes must begin with "/"
+
+if test "x$prefix" = "xNONE"; then
+  prefix=/usr/local
+fi
+
+fch=`echo $prefix | sed 's/\(.\).*/\1/'`
+if test $fch != "/" ; then
+   prefix=`pwd`/$prefix
+   echo "adjusting prefix to $prefix"
+fi
+
+if test "x$exec_prefix" = "xNONE"; then
+  exec_prefix=$prefix
+fi
+
+fch=`echo $exec_prefix | sed 's/\(.\).*/\1/'`
+if test $fch != "/" ; then
+   exec_prefix=`pwd`/$exec_prefix
+   echo "adjusting exec_prefix to $exec_prefix"
+fi
+
+# Set SNMPLIBPATH & SNMPSHAREPATH
+
+SNMPLIBPATH=""
+tmpset="$libdir/snmp"
+while test "x$tmpset" != "x$SNMPLIBPATH"; do
+  SNMPLIBPATH="$tmpset"
+  eval tmpset="$tmpset"
+done
+cat >>confdefs.h <<_ACEOF
+#define SNMPLIBPATH "$SNMPLIBPATH"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define SNMPDLMODPATH "$SNMPLIBPATH/dlmod"
+_ACEOF
+
+
+SNMPSHAREPATH=""
+tmpset="$datadir/snmp"
+while test "x$tmpset" != "x$SNMPSHAREPATH"; do
+  SNMPSHAREPATH="$tmpset"
+  eval tmpset="$tmpset"
+done
+cat >>confdefs.h <<_ACEOF
+#define SNMPSHAREPATH "$SNMPSHAREPATH"
+_ACEOF
+
+
+if test "x$DEFAULT_MIBDIRS" = "x"; then
+  cat >>confdefs.h <<_ACEOF
+#define DEFAULT_MIBDIRS "\$HOME/.snmp/mibs:$SNMPSHAREPATH/mibs"
+_ACEOF
+
+fi
+
+SNMPCONFPATH=""
+tmpset="$sysconfdir/snmp"
+while test "x$tmpset" != "x$SNMPCONFPATH"; do
+  SNMPCONFPATH="$tmpset"
+  eval tmpset="$tmpset"
+done
+cat >>confdefs.h <<_ACEOF
+#define SNMPCONFPATH "$SNMPCONFPATH"
+_ACEOF
+
+
+
+# guess IPv6 stack type.
+if test "x$enable_ipv6" = "xyes"; then
+	v6type=unknown
+	v6lib=none
+	v6trylibc=no
+
+	echo "$as_me:$LINENO: checking ipv6 stack type" >&5
+echo $ECHO_N "checking ipv6 stack type... $ECHO_C" >&6
+	for i in v6d toshiba kame inria zeta linux-glibc linux-inet6; do
+		case $i in
+		v6d)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include </usr/local/v6/include/sys/types.h>
+#ifdef __V6D__
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i; v6lib=v6;
+				v6libdir=/usr/local/v6/lib;
+				CFLAGS="-I/usr/local/v6/include $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		toshiba)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <sys/param.h>
+#ifdef _TOSHIBA_INET6
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i; v6lib=inet6;
+				v6libdir=/usr/local/v6/lib;
+				CFLAGS="-DINET6 $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		kame)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <netinet/in.h>
+#ifdef __KAME__
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i; v6lib=inet6;
+				v6libdir=/usr/local/v6/lib;
+				v6trylibc=yes;
+				CFLAGS="-DINET6 $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		inria)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <netinet/in.h>
+#ifdef IPV6_INRIA_VERSION
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i;
+				v6lib=dummy;
+				v6libdir=none;
+				v6trylibc=yes;
+				CFLAGS="-DINET6 $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		zeta)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <sys/param.h>
+#ifdef _ZETA_MINAMI_INET6
+A
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i; v6lib=inet6;
+				v6libdir=/usr/local/v6/lib;
+				CFLAGS="-DINET6 $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		linux-glibc)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <features.h>
+#if defined(__GLIBC__) && ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1) || (__GLIBC_ > 2))
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i;
+				v6lib=dummy;
+				v6libdir=none;
+				v6trylibc=yes;
+				CFLAGS="-DINET6 $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		linux-inet6)
+			if test -d /usr/inet6; then
+				v6type=$i
+				v6lib=inet6
+				v6libdir=/usr/inet6/lib
+				CFLAGS="-DINET6 $CFLAGS"
+			fi
+			;;
+		esac
+		if test "$v6type" != "unknown"; then
+			break
+		fi
+	done
+
+	if test "$v6lib" != "none"; then
+		if test -d $v6libdir -a -f $v6libdir/lib$v6lib.a; then
+			LIBS="-L$v6libdir -l$v6lib $LIBS"
+			enable_ipv6="yes"
+			echo "$as_me:$LINENO: result: \"$v6type, $enable_ipv6, using lib$v6lib\"" >&5
+echo "${ECHO_T}\"$v6type, $enable_ipv6, using lib$v6lib\"" >&6
+		elif test "$v6trylibc" = "yes"; then
+			enable_ipv6="yes"
+			echo "$as_me:$LINENO: result: \"$v6type, $enable_ipv6, using libc\"" >&5
+echo "${ECHO_T}\"$v6type, $enable_ipv6, using libc\"" >&6
+		else
+			{ { echo "$as_me:$LINENO: error: no IPv6 library lib$v6lib.a found." >&5
+echo "$as_me: error: no IPv6 library lib$v6lib.a found." >&2;}
+   { (exit 1); exit 1; }; }
+			exit 1
+		fi
+	else
+		enable_ipv6="no"
+		echo "$as_me:$LINENO: result: \"$v6type, $enable_ipv6\"" >&5
+echo "${ECHO_T}\"$v6type, $enable_ipv6\"" >&6
+	fi
+fi
+
+#
+# Maybe add library extensions for thread mutex locking.
+#
+
+if test "x$with_res_locks" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define NS_REENTRANT 1
+_ACEOF
+
+EOF
+
+    case $target_os in
+
+    aix*)
+	CC_RUNTIME_ARG="$CC_RUNTIME_ARG -lpthreads"
+	;;
+
+    *)
+	;;
+
+    esac
+fi
+
+echo "$as_me:$LINENO: checking whether we have to build PIC code" >&5
+echo $ECHO_N "checking whether we have to build PIC code... $ECHO_C" >&6
+echo "$with_mib_modules" | grep "ucd-snmp/dlmod" >/dev/null
+if test $? -eq 0 ; then
+	DLLIBS="-ldl"
+        LIB_CFLAGS="$LIB_CFLAGS $SHLIB_CFLAGS"
+	echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+	DLLIBS=""
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+#
+# Do transport module processing.
+#
+echo "$as_me:$LINENO: checking for and configuring transport modules to use" >&5
+echo $ECHO_N "checking for and configuring transport modules to use... $ECHO_C" >&6
+transport_src_list=""
+transport_hdr_list=""
+transport_def_list=""
+transport_result_list=""
+transport_add_list=""
+transport_callback_disabled=""
+new_with_transport_list=`echo $with_transports | sed 's/,/ /g;'`
+new_with_out_transport_list=`echo $with_out_transports | sed 's/,/ /g;'`
+
+#
+# Add the default transports to the list
+#
+if test "x$PARTIALTARGETOS" = "xcygwin"; then
+  transport_default_list="UDP TCP Callback"
+else
+  transport_default_list="UDP TCP Unix Callback"
+fi
+if test "x$enable_ipv6" = "xyes"; then
+  transport_default_list="UDPIPv6 TCPIPv6 $transport_default_list"
+fi
+for i in $transport_default_list; do
+  if echo " $new_with_transport_list " | grep " $i " >/dev/null; then
+    :
+  else
+    transport_add_list="$i $transport_add_list"
+  fi
+done
+new_transport_list="$transport_add_list $new_with_transport_list"
+
+for i in $new_transport_list; do
+  if echo " $new_with_out_transport_list " | grep " $i " >/dev/null; then
+    if test "x$i" = "xUDP"; then
+      echo
+      { { echo "$as_me:$LINENO: error: It is not possible to compile without UDP/IP support." >&5
+echo "$as_me: error: It is not possible to compile without UDP/IP support." >&2;}
+   { (exit 1); exit 1; }; }
+    elif test "x$i" = "xCallback"; then
+      echo
+      transport_callback_disabled="yes"
+    fi
+  else
+    if test "x$i" = "xAAL5PVC"; then
+      if test "x$PARTIALTARGETOS" != "xlinux"; then
+        echo
+        { { echo "$as_me:$LINENO: error: AAL5 PVC support unavailable for this platform (Linux only)" >&5
+echo "$as_me: error: AAL5 PVC support unavailable for this platform (Linux only)" >&2;}
+   { (exit 1); exit 1; }; }
+      fi
+    fi
+    if test "x$i" = "xIPX"; then
+      if test "x$PARTIALTARGETOS" != "xlinux"; then
+        echo
+        { { echo "$as_me:$LINENO: error: IPX support unavailable for this platform (Linux only)" >&5
+echo "$as_me: error: IPX support unavailable for this platform (Linux only)" >&2;}
+   { (exit 1); exit 1; }; }
+      fi
+    fi
+    if test "x$i" = "xUnix"; then
+      if test "x$PARTIALTARGETOS" = "xcygwin"; then
+        echo
+        { { echo "$as_me:$LINENO: error: Unix domain protocol support unavailable for this platform" >&5
+echo "$as_me: error: Unix domain protocol support unavailable for this platform" >&2;}
+   { (exit 1); exit 1; }; }
+      fi
+    fi
+    transport_src="snmp"$i"Domain.c"
+    transport_hdr="snmp"$i"Domain.h"
+    rel_transport_src="snmplib/"$transport_src
+    rel_transport_hdr="include/net-snmp/library/"$transport_hdr
+    if test -f "$srcdir/$rel_transport_src"; then
+      transport_result_list="$transport_result_list $i"
+      transport_src_list="$transport_src $transport_src_list"
+      if test -f "$srcdir/$rel_transport_hdr"; then
+        transport_hdr_list="$transport_hdr $transport_hdr_list"
+      fi
+      transport_def=`echo $i | sed 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+      transport_def_list="SNMP_TRANSPORT_"$transport_def"_DOMAIN $transport_def_list"
+    else
+      echo
+      { { echo "$as_me:$LINENO: error: Cannot find file $transport_src to support SNMP transport domain $i." >&5
+echo "$as_me: error: Cannot find file $transport_src to support SNMP transport domain $i." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+done
+
+
+for i in $transport_def_list; do
+  cat >>confdefs.h <<_ACEOF
+#define $i 1
+_ACEOF
+
+done
+echo "$as_me:$LINENO: result: $transport_result_list." >&5
+echo "${ECHO_T}$transport_result_list." >&6
+
+  cat >> configure-summary << EOF
+  Network transport support: $transport_result_list
+EOF
+
+
+#
+# Security modules to use
+#
+
+echo "$as_me:$LINENO: checking for security modules to use" >&5
+echo $ECHO_N "checking for security modules to use... $ECHO_C" >&6
+security_def_list=""
+security_src_list=""
+security_init_file="snmplib/snmpsm_init.h"
+security_incl_file="include/net-snmp/library/snmpv3-security-includes.h"
+new_with_security=`echo $with_security_modules | sed 's/,/ /g;'`
+new_with_out_security=`echo $with_out_security_modules | sed 's/,/ /g;'`
+
+if test ! -d include; then
+  mkdir include
+fi
+if test ! -d include/net-snmp; then
+  mkdir include/net-snmp
+fi
+if test ! -d include/net-snmp/agent; then
+  mkdir include/net-snmp/agent
+fi
+if test ! -d include/net-snmp/library; then
+  mkdir include/net-snmp/library
+fi
+if test ! -d include/ucd-snmp; then
+  mkdir include/ucd-snmp
+fi
+
+if test ! -d snmplib; then
+  mkdir snmplib
+fi
+echo "/* This file is automatically generated by configure.  Do not modify by hand. */" > $security_init_file
+echo "/* This file is automatically generated by configure.  Do not modify by hand. */" > $security_incl_file
+
+for i in $security_def_list; do
+  if echo " $new_with_out_security " | grep " $i " > /dev/null; then
+     :
+     #if test "x$i" = "xusm"; then
+	#echo
+          #AC_MSG_ERROR(The USM security module is mandatory)
+    #fi
+  else
+    new_with_security="$new_with_security $i"
+  fi
+done
+
+for i in $new_with_security; do
+  cfile="snmp"$i".c"
+  hfile="snmp"$i".h"
+
+  # make sure support exists for it
+  if test -f $srcdir"/snmplib/"$cfile -a -f $srcdir"/include/net-snmp/library/"$hfile; then
+    :
+  else
+    echo
+    { { echo "$as_me:$LINENO: error: No such security module: $i / $cfile / $hfile" >&5
+echo "$as_me: error: No such security module: $i / $cfile / $hfile" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+
+  # define a bunch of stuff to enable it
+  security_src_list="$security_src_list $cfile"
+  security_hdr_list="$security_hdr_list $hfile"
+  def_name="SNMP_SECMOD_"`echo $i | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  echo "init_"$i"();" >> $security_init_file
+  echo "#include <net-snmp/library/$hfile>" >> $security_incl_file
+  cat >>confdefs.h <<_ACEOF
+#define $def_name 1
+_ACEOF
+
+done
+
+
+
+echo "$as_me:$LINENO: result: $new_with_security" >&5
+echo "${ECHO_T}$new_with_security" >&6
+
+  cat >> configure-summary << EOF
+  SNMPv3 Security Modules:   $new_with_security
+EOF
+
+
+#
+# Handle the special case of KSM to see which crypto API we support
+#
+
+for sec in $new_with_security
+do
+  if test x$sec = xksm; then
+    echo "$as_me:$LINENO: checking to see which crypto API we need to use" >&5
+echo $ECHO_N "checking to see which crypto API we need to use... $ECHO_C" >&6
+
+    echo "$as_me:$LINENO: checking for krb5_c_encrypt" >&5
+echo $ECHO_N "checking for krb5_c_encrypt... $ECHO_C" >&6
+if test "${ac_cv_func_krb5_c_encrypt+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char krb5_c_encrypt (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char krb5_c_encrypt ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_krb5_c_encrypt) || defined (__stub___krb5_c_encrypt)
+choke me
+#else
+char (*f) () = krb5_c_encrypt;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != krb5_c_encrypt;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_krb5_c_encrypt=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_krb5_c_encrypt=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_krb5_c_encrypt" >&5
+echo "${ECHO_T}$ac_cv_func_krb5_c_encrypt" >&6
+if test $ac_cv_func_krb5_c_encrypt = yes; then
+
+      echo "$as_me:$LINENO: result: new MIT crypto API" >&5
+echo "${ECHO_T}new MIT crypto API" >&6
+      cat >>confdefs.h <<\_ACEOF
+#define MIT_NEW_CRYPTO 1
+_ACEOF
+
+else
+
+      echo "$as_me:$LINENO: result: old MIT crypto API" >&5
+echo "${ECHO_T}old MIT crypto API" >&6
+fi
+
+  fi
+done
+
+#
+# Do hairy agent module processing.
+#
+echo "$as_me:$LINENO: checking for and configuring mib modules to use" >&5
+echo $ECHO_N "checking for and configuring mib modules to use... $ECHO_C" >&6
+
+
+mibdir="agent/mibgroup"
+module_list=""
+module_list_code=""
+new_with_mib_modules=`echo $with_mib_modules | sed 's/,/ /g;'`
+new_with_out_mib_modules=`echo $with_out_mib_modules | sed 's/,/ /g;'`
+new_module_list="mibII ucd_snmp snmpv3mibs notification target agent_mibs agentx agent_mibs utilities $new_with_mib_modules"
+default_mibs=IP-MIB:IF-MIB:TCP-MIB:UDP-MIB:HOST-RESOURCES-MIB:SNMPv2-MIB:RFC1213-MIB:NOTIFICATION-LOG-MIB
+
+if test "x$mini_agent" = "xyes"; then
+new_with_out_mib_modules="mibII $new_with_out_mib_modules"
+new_module_list="snmpv3mibs mibII/snmp_mib mibII/system_mib mibII/sysORTable mibII/vacm_vars $new_with_mib_modules"
+default_mibs=SNMPv2-MIB:RFC1213-MIB
+default_mibs_install=" "
+fi
+
+if test "x$transport_callback_disabled" = "xyes"; then
+
+        { echo "$as_me:$LINENO: WARNING: Disabling Callback transport will disable AgentX support." >&5
+echo "$as_me: WARNING: Disabling Callback transport will disable AgentX support." >&2;}
+
+        new_with_out_mib_modules="agentx $new_with_out_mib_modules"
+fi
+
+if test "x$enable_ipv6" = "xyes"; then
+	new_module_list="$new_module_list mibII/ipv6"
+fi
+
+# Create include file list for snmp_vars.h to use.
+if test ! -d agent; then
+  mkdir agent
+fi
+if test ! -d agent/mibgroup; then
+  mkdir agent/mibgroup
+fi
+for i in $mibdir/mib_module_includes.h $mibdir/mib_module_inits.h $mibdir/mib_module_shutdown.h include/net-snmp/agent/mib_module_config.h $mibdir/mib_module_dot_conf.h; do
+  rm -f $i
+  echo "/* This file is automatically generated by configure.  Do not modify by hand. */" > $i
+done
+
+test_modules="$new_module_list"
+new_module_list=""
+module_list_h=""
+
+for i in $test_modules
+ do
+  if echo " $new_with_out_mib_modules " | grep " $i " > /dev/null; then
+    :
+  else
+    new_module_list="$new_module_list $i"
+  fi
+done
+
+
+echo "$as_me:$LINENO: result: $new_module_list." >&5
+echo "${ECHO_T}$new_module_list." >&6
+
+  cat >> configure-summary << EOF
+  Agent MIB code:            $new_module_list
+EOF
+
+
+MODULECPP="$CPP -I${srcdir}/include -I${srcdir}/agent/mibgroup"
+echo "$as_me:$LINENO: checking for and configuring mib modules pieces to use" >&5
+echo $ECHO_N "checking for and configuring mib modules pieces to use... $ECHO_C" >&6
+
+while test "x$new_module_list" != "x"; do
+  for i in $new_module_list
+    do
+    if echo " $new_with_out_mib_modules " | grep " $i " > /dev/null; then
+      :
+    else
+      if test -f $srcdir/$mibdir/$i.h; then
+        new_list=""
+        new_list_arch=`grep config_arch_require $srcdir/$mibdir/$i.h | sed 's/.*config_arch_require(\(.*\), *\(.*\)).*/\1-xarchx-\2/'`
+	if test "x$new_list_arch" != "x"; then
+          for j in $new_list_arch
+	    do
+	    archtest=`echo $j | sed 's/-xarchx-.*//'`
+	    if test "x$target_os" = "x$archtest" -o "x$PARTIALTARGETOS" = "x$archtest"; then
+	      new_list="$new_list `echo $j | sed 's/.*-xarchx-//'`"
+	    fi
+	  done
+	fi
+	new_list="$new_list `$MODULECPP $srcdir/$mibdir/$i.h | grep config_require | sed 's/.*config_require(\(.*\)).*/\1/'`"
+	if test "x$new_list" != "x"; then
+	  for j in $new_list
+	    do
+	    if test ! -f $srcdir/$mibdir/$j.h; then
+
+	      { { echo "$as_me:$LINENO: error: mib module \"$i\" requires module \"$j\" but $j.h or $j.c could not be found in $srcdir/$mibdir" >&5
+echo "$as_me: error: mib module \"$i\" requires module \"$j\" but $j.h or $j.c could not be found in $srcdir/$mibdir" >&2;}
+   { (exit 1); exit 1; }; }
+
+	    elif echo " $new_with_out_mib_modules " | grep " $j " > /dev/null; then
+
+	      { echo "$as_me:$LINENO: WARNING: mib module \"$i\" requires module \"$j\" but you told me to compile without it" >&5
+echo "$as_me: WARNING: mib module \"$i\" requires module \"$j\" but you told me to compile without it" >&2;}
+
+	    elif echo " $module_list $new_list_two $new_module_list " | grep " $j " > /dev/null; then
+	      :
+	    else
+	      new_list_two="$new_list_two $j"
+	    fi
+	  done
+	fi
+	new_mibs=`$MODULECPP $srcdir/$mibdir/$i.h | grep config_add_mib | sed 's/.*config_add_mib(\(.*\)).*/\1/'`
+	if test "x$new_mibs" != "x"; then
+	    for j in $new_mibs
+		do
+		if test "x`echo :$default_mibs: | grep :$j:`" = "x"; then
+		    default_mibs="$default_mibs:$j"
+		fi
+		if test -f $srcdir/mibs/$j.txt; then
+		    if echo $default_mibs_install | grep " $j " > /dev/null; then
+			    :
+		    else
+			    default_mibs_install="$default_mibs_install $j.txt"
+		    fi
+		fi
+	    done
+	fi
+      else
+
+	{ { echo "$as_me:$LINENO: error: module files $i.h or $i.c could not be found in $srcdir/$mibdir" >&5
+echo "$as_me: error: module files $i.h or $i.c could not be found in $srcdir/$mibdir" >&2;}
+   { (exit 1); exit 1; }; }
+
+      fi
+      module_list="$module_list $i"
+      echo '#include "'"mibgroup/$i.h"'"' >> $mibdir/mib_module_includes.h
+      module_list_h="$module_list_h mibgroup/$i.h"
+      if test -f $srcdir/$mibdir/$i.c; then
+        module_list_code="$module_list_code $i"
+        mnm=`echo $i | sed 's/.*\///;s/\.c$//;'`
+        temp_init=`grep init_$mnm $srcdir/$mibdir/$i.c | grep -v _init_$mnm`
+	if test "x$temp_init" != "x"; then
+	    echo "  if (should_init(\"$mnm\")) init_$mnm();" >> $mibdir/mib_module_inits.h
+	fi
+	if grep shutdown_`basename $i` $srcdir/$mibdir/$i.c > /dev/null; then
+	    echo "  if (should_init(\"`basename $i`\")) shutdown_`basename $i`();" >> $mibdir/mib_module_shutdown.h
+	fi
+      fi
+      if test "x`echo $i | sed 's/\///g;'`" != "x$i"; then
+	mnd=`echo $i | sed 's/\/[^/]*$//;'`
+	if test ! -d ./$mibdir/$mnd; then
+	    module_directories="$module_directories ./$mibdir/$mnd"
+	fi
+      fi
+      if $MODULECPP $srcdir/$mibdir/$i.h | grep config_load_mib > /dev/null 2>&1; then
+
+      	{ echo "$as_me:$LINENO: WARNING: mib module \"$i\" uses the \"config_load_mib\" directive, which is no longer supported.  It probably won't work." >&5
+echo "$as_me: WARNING: mib module \"$i\" uses the \"config_load_mib\" directive, which is no longer supported.  It probably won't work." >&2;}
+
+      fi
+      $MODULECPP $srcdir/$mibdir/$i.h | grep config_parse_dot_conf | sed 's@.*config_parse_dot_conf(\([^)]*\), *\([^),]*\), *\([^),]*\), *\([^),]*\)).*@register_config_handler("snmpd",\1, \2, \3, \4);@' >> $mibdir/mib_module_dot_conf.h
+      sym="`echo ${i} | sed 's/[^a-zA-Z0-9_]/_/g' | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`"
+      echo "/* Define if compiling with the ${i} module files.  */" >> include/net-snmp/agent/mib_module_config.h
+      echo "#define USING_${sym}_MODULE 1" >> include/net-snmp/agent/mib_module_config.h
+      echo " " >> include/net-snmp/agent/mib_module_config.h
+
+      echo $ECHO_N " $i$ECHO_C"
+
+    fi
+  done
+  new_module_list="$new_list_two"
+  new_list_two=""
+done
+module_list_o=`echo "$module_list_code " | sed 's/\([^ ]\) /\1.o /g'`
+module_list_lo=`echo "$module_list_code " | sed 's/\([^ ]\) /\1.lo /g'`
+module_list_c=`echo "$module_list_code " | sed 's/\([^ ]\) /\1.c /g'`
+mibgroup_list_o=`echo " $module_list_o " | sed 's@ \([^ ]*\)\.o@ mibgroup/\1.o @g'`
+mibgroup_list_lo=`echo " $module_list_lo " | sed 's@ \([^ ]*\)\.lo@ mibgroup/\1.lo @g'`
+
+MODULE_LIST=$module_list_code
+
+
+
+
+
+
+
+
+
+
+echo "$as_me:$LINENO: result: ." >&5
+echo "${ECHO_T}." >&6
+
+echo "$as_me:$LINENO: checking if directories need to be created" >&5
+echo $ECHO_N "checking if directories need to be created... $ECHO_C" >&6
+for i in $module_directories; do
+  $srcdir/mkinstalldirs $i
+done
+echo "$as_me:$LINENO: result: ." >&5
+echo "${ECHO_T}." >&6
+
+echo "$as_me:$LINENO: checking default mib files to read" >&5
+echo $ECHO_N "checking default mib files to read... $ECHO_C" >&6
+if test "x$DEFAULT_MIBS" = "x"; then
+  DEFAULT_MIBS="$default_mibs"
+fi
+cat >>confdefs.h <<_ACEOF
+#define DEFAULT_MIBS "$DEFAULT_MIBS"
+_ACEOF
+
+echo "$as_me:$LINENO: result: $DEFAULT_MIBS" >&5
+echo "${ECHO_T}$DEFAULT_MIBS" >&6
+
+#
+# Check for kernel location
+#
+
+echo "$as_me:$LINENO: checking for location of system kernel" >&5
+echo $ECHO_N "checking for location of system kernel... $ECHO_C" >&6
+if test "${ac_cv_KERNEL_LOC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_KERNEL_LOC="unknown"
+# First determine if test expects a -f or a -c (character device (SYSV))
+
+if test -c /dev/null; then
+  CFLAG="-c"
+elif test -f /dev/null; then
+  CFLAG="-f"
+else
+  # fall back
+  CFLAG="-f"
+fi
+for i in /vmunix /hp-ux /stand/vmunix /dev/ksyms /kernel/unix /kernel/genunix /netbsd /unix /kernel /bsd /mach_kernel
+  do
+  if test -f $i -o $CFLAG $i; then
+    ac_cv_KERNEL_LOC="$i"
+    break;
+  fi
+done
+if test $i = "unknown"; then
+  { echo "$as_me:$LINENO: WARNING: Can't find system kernel...  Setting to /vmunix" >&5
+echo "$as_me: WARNING: Can't find system kernel...  Setting to /vmunix" >&2;}
+  ac_cv_KERNEL_LOC="/vmunix"
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_KERNEL_LOC" >&5
+echo "${ECHO_T}$ac_cv_KERNEL_LOC" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define KERNEL_LOC "$ac_cv_KERNEL_LOC"
+_ACEOF
+
+
+#
+# Check for mount table location
+#
+
+echo "$as_me:$LINENO: checking for mount table location" >&5
+echo $ECHO_N "checking for mount table location... $ECHO_C" >&6
+if test "${ac_cv_ETC_MNTTAB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_ETC_MNTTAB="unknown"
+for i in /etc/mnttab /etc/mtab /etc/filesystems
+  do
+  if test -f $i; then
+    ac_cv_ETC_MNTTAB="$i"
+    break;
+  fi
+done
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_ETC_MNTTAB" >&5
+echo "${ECHO_T}$ac_cv_ETC_MNTTAB" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define ETC_MNTTAB "$ac_cv_ETC_MNTTAB"
+_ACEOF
+
+
+# Check for /dev/dmem or /dev/drum location
+echo "$as_me:$LINENO: checking for location of swap device" >&5
+echo $ECHO_N "checking for location of swap device... $ECHO_C" >&6
+if test "${ac_cv_DMEM_LOC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+# First determine if test expects a -f or a -c (character device (SYSV))
+
+if test -f /dev/kmem; then
+  CTEST="test -f"
+elif test -c /dev/kmem; then
+  CTEST="test -c"
+else
+  # fall back
+  CTEST="test -f"
+fi
+
+if $CTEST /dev/dmem; then
+  ac_cv_DMEM_LOC="/dev/dmem"
+elif $CTEST /dev/drum; then
+  ac_cv_DMEM_LOC="/dev/drum"
+else
+  ac_cv_DMEM_LOC="none"
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_DMEM_LOC" >&5
+echo "${ECHO_T}$ac_cv_DMEM_LOC" >&6
+
+if test "x$ac_cv_DMEM_LOC" != "xnone"; then
+  cat >>confdefs.h <<_ACEOF
+#define DMEM_LOC "$ac_cv_DMEM_LOC"
+_ACEOF
+
+fi
+
+# forced efence turned off.
+# if test "x$developer" = "xyes" -a "x$use_efence" != "xno"; then
+#    use_efence="yes"
+# fi
+
+if test "x$use_efence" = "xyes"; then
+
+echo "$as_me:$LINENO: checking for EF_Exit in -lefence" >&5
+echo $ECHO_N "checking for EF_Exit in -lefence... $ECHO_C" >&6
+if test "${ac_cv_lib_efence_EF_Exit+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lefence  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char EF_Exit ();
+int
+main ()
+{
+EF_Exit ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_efence_EF_Exit=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_efence_EF_Exit=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_efence_EF_Exit" >&5
+echo "${ECHO_T}$ac_cv_lib_efence_EF_Exit" >&6
+if test $ac_cv_lib_efence_EF_Exit = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBEFENCE 1
+_ACEOF
+
+  LIBS="-lefence $LIBS"
+
+fi
+
+fi
+
+# Checks for libraries.
+# AC_CHECK_LIB(des, main)
+
+echo "$as_me:$LINENO: checking for asin in -lm" >&5
+echo $ECHO_N "checking for asin in -lm... $ECHO_C" >&6
+if test "${ac_cv_lib_m_asin+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char asin ();
+int
+main ()
+{
+asin ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_m_asin=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_m_asin=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_m_asin" >&5
+echo "${ECHO_T}$ac_cv_lib_m_asin" >&6
+if test $ac_cv_lib_m_asin = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBM 1
+_ACEOF
+
+  LIBS="-lm $LIBS"
+
+fi
+
+# nlist is needed for uptime on some sytems in the generic library
+
+echo "$as_me:$LINENO: checking for nlist in -lelf" >&5
+echo $ECHO_N "checking for nlist in -lelf... $ECHO_C" >&6
+if test "${ac_cv_lib_elf_nlist+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lelf  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char nlist ();
+int
+main ()
+{
+nlist ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_elf_nlist=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_elf_nlist=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_elf_nlist" >&5
+echo "${ECHO_T}$ac_cv_lib_elf_nlist" >&6
+if test $ac_cv_lib_elf_nlist = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBELF 1
+_ACEOF
+
+  LIBS="-lelf $LIBS"
+
+fi
+
+
+# On some platforms (Irix) libnsl and libsocket should not be used.
+echo "$as_me:$LINENO: checking for gethostbyname" >&5
+echo $ECHO_N "checking for gethostbyname... $ECHO_C" >&6
+if test "${ac_cv_func_gethostbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char gethostbyname (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_gethostbyname) || defined (__stub___gethostbyname)
+choke me
+#else
+char (*f) () = gethostbyname;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != gethostbyname;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_gethostbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_gethostbyname=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_gethostbyname" >&5
+echo "${ECHO_T}$ac_cv_func_gethostbyname" >&6
+if test $ac_cv_func_gethostbyname = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETHOSTBYNAME 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: checking for gethostbyname in -lnsl" >&5
+echo $ECHO_N "checking for gethostbyname in -lnsl... $ECHO_C" >&6
+if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
+echo "${ECHO_T}$ac_cv_lib_nsl_gethostbyname" >&6
+if test $ac_cv_lib_nsl_gethostbyname = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETHOSTBYNAME 1
+_ACEOF
+
+	LIBS="${LIBS} -lnsl"
+fi
+
+fi
+
+echo "$as_me:$LINENO: checking for getservbyname" >&5
+echo $ECHO_N "checking for getservbyname... $ECHO_C" >&6
+if test "${ac_cv_func_getservbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char getservbyname (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getservbyname ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_getservbyname) || defined (__stub___getservbyname)
+choke me
+#else
+char (*f) () = getservbyname;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != getservbyname;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_getservbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_getservbyname=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_getservbyname" >&5
+echo "${ECHO_T}$ac_cv_func_getservbyname" >&6
+if test $ac_cv_func_getservbyname = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETSERVBYNAME 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: checking for getservbyname in -lsocket" >&5
+echo $ECHO_N "checking for getservbyname in -lsocket... $ECHO_C" >&6
+if test "${ac_cv_lib_socket_getservbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getservbyname ();
+int
+main ()
+{
+getservbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_socket_getservbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_socket_getservbyname=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_socket_getservbyname" >&5
+echo "${ECHO_T}$ac_cv_lib_socket_getservbyname" >&6
+if test $ac_cv_lib_socket_getservbyname = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETSERVBYNAME 1
+_ACEOF
+
+	LIBS="${LIBS} -lsocket"
+fi
+
+fi
+
+
+# Replace `main' with a function in -lkstat:
+
+echo "$as_me:$LINENO: checking for kstat_lookup in -lkstat" >&5
+echo $ECHO_N "checking for kstat_lookup in -lkstat... $ECHO_C" >&6
+if test "${ac_cv_lib_kstat_kstat_lookup+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lkstat  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char kstat_lookup ();
+int
+main ()
+{
+kstat_lookup ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_kstat_kstat_lookup=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_kstat_kstat_lookup=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_kstat_kstat_lookup" >&5
+echo "${ECHO_T}$ac_cv_lib_kstat_kstat_lookup" >&6
+if test $ac_cv_lib_kstat_kstat_lookup = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBKSTAT 1
+_ACEOF
+
+  LIBS="-lkstat $LIBS"
+
+fi
+
+# Check for nlist in mld (irix)
+
+echo "$as_me:$LINENO: checking for nlist in -lmld" >&5
+echo $ECHO_N "checking for nlist in -lmld... $ECHO_C" >&6
+if test "${ac_cv_lib_mld_nlist+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lmld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char nlist ();
+int
+main ()
+{
+nlist ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_mld_nlist=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_mld_nlist=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_mld_nlist" >&5
+echo "${ECHO_T}$ac_cv_lib_mld_nlist" >&6
+if test $ac_cv_lib_mld_nlist = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBMLD 1
+_ACEOF
+
+  LIBS="-lmld $LIBS"
+
+fi
+
+
+# Check for security related functions
+if test "x$tryopenssl" != "xno"; then
+    if test "x$tryrsaref" != "xno"; then
+
+echo "$as_me:$LINENO: checking for RSAPrivateDecrypt in -lrsaref" >&5
+echo $ECHO_N "checking for RSAPrivateDecrypt in -lrsaref... $ECHO_C" >&6
+if test "${ac_cv_lib_rsaref_RSAPrivateDecrypt+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrsaref  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char RSAPrivateDecrypt ();
+int
+main ()
+{
+RSAPrivateDecrypt ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_rsaref_RSAPrivateDecrypt=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_rsaref_RSAPrivateDecrypt=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_rsaref_RSAPrivateDecrypt" >&5
+echo "${ECHO_T}$ac_cv_lib_rsaref_RSAPrivateDecrypt" >&6
+if test $ac_cv_lib_rsaref_RSAPrivateDecrypt = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBRSAREF 1
+_ACEOF
+
+  LIBS="-lrsaref $LIBS"
+
+fi
+
+
+echo "$as_me:$LINENO: checking for RSA_PKCS1_RSAref in -lRSAglue" >&5
+echo $ECHO_N "checking for RSA_PKCS1_RSAref in -lRSAglue... $ECHO_C" >&6
+if test "${ac_cv_lib_RSAglue_RSA_PKCS1_RSAref+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lRSAglue  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char RSA_PKCS1_RSAref ();
+int
+main ()
+{
+RSA_PKCS1_RSAref ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_RSAglue_RSA_PKCS1_RSAref=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_RSAglue_RSA_PKCS1_RSAref=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_RSAglue_RSA_PKCS1_RSAref" >&5
+echo "${ECHO_T}$ac_cv_lib_RSAglue_RSA_PKCS1_RSAref" >&6
+if test $ac_cv_lib_RSAglue_RSA_PKCS1_RSAref = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBRSAGLUE 1
+_ACEOF
+
+  LIBS="-lRSAglue $LIBS"
+
+fi
+
+    fi
+
+
+echo "$as_me:$LINENO: checking for EVP_md5 in -lcrypto" >&5
+echo $ECHO_N "checking for EVP_md5 in -lcrypto... $ECHO_C" >&6
+if test "${ac_cv_lib_crypto_EVP_md5+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lcrypto  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char EVP_md5 ();
+int
+main ()
+{
+EVP_md5 ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_crypto_EVP_md5=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_crypto_EVP_md5=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_crypto_EVP_md5" >&5
+echo "${ECHO_T}$ac_cv_lib_crypto_EVP_md5" >&6
+if test $ac_cv_lib_crypto_EVP_md5 = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBCRYPTO 1
+_ACEOF
+
+  LIBS="-lcrypto $LIBS"
+
+fi
+
+
+for ac_func in AES_cfb128_encrypt
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+fi
+
+# Check for libraries that the agent needs
+# saving old libraries
+NONAGENTLIBS=$LIBS
+
+# check for tcp wrapper support
+_cppflags="${CPPFLAGS}"
+_ldflags="${LDFLAGS}"
+
+
+# Check whether --with-libwrap or --without-libwrap was given.
+if test "${with_libwrap+set}" = set; then
+  withval="$with_libwrap"
+
+  if test "$with_libwrap" != "no"; then
+    if test "$with_libwrap" != "yes"; then
+      CPPFLAGS="${CPPFLAGS} -I$with_libwrap/include"
+      LDFLAGS="${LDFLAGS} -L$with_libwrap/lib"
+    fi
+
+    _libs=${LIBS}
+    if test "${ac_cv_header_tcpd_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for tcpd.h" >&5
+echo $ECHO_N "checking for tcpd.h... $ECHO_C" >&6
+if test "${ac_cv_header_tcpd_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_tcpd_h" >&5
+echo "${ECHO_T}$ac_cv_header_tcpd_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking tcpd.h usability" >&5
+echo $ECHO_N "checking tcpd.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <tcpd.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking tcpd.h presence" >&5
+echo $ECHO_N "checking tcpd.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <tcpd.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: tcpd.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: tcpd.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: tcpd.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: tcpd.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: tcpd.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: tcpd.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: tcpd.h: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: tcpd.h: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: tcpd.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: tcpd.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for tcpd.h" >&5
+echo $ECHO_N "checking for tcpd.h... $ECHO_C" >&6
+if test "${ac_cv_header_tcpd_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_tcpd_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_tcpd_h" >&5
+echo "${ECHO_T}$ac_cv_header_tcpd_h" >&6
+
+fi
+if test $ac_cv_header_tcpd_h = yes; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: Asked to use libwrap but I couldn't find tcpd.h." >&5
+echo "$as_me: error: Asked to use libwrap but I couldn't find tcpd.h." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+
+
+    LIBS="$LIBS -lwrap"
+	echo "$as_me:$LINENO: checking for TCP wrappers library -lwrap" >&5
+echo $ECHO_N "checking for TCP wrappers library -lwrap... $ECHO_C" >&6
+	cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <tcpd.h>
+		     int allow_severity = 0;
+		     int deny_severity  = 0;
+
+int
+main ()
+{
+hosts_access((void *)0)
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+
+	    echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	    cat >>confdefs.h <<\_ACEOF
+#define USE_LIBWRAP 1
+_ACEOF
+
+	    test "$with_libwrap" != no -a "$with_libwrap" != yes && WRAPLIBS="-L$with_libwrap/lib"
+	    WRAPLIBS="$WRAPLIBS -lwrap"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+	    echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	    # Linux RedHat 6.1 won't link libwrap without libnsl
+	    echo "$as_me:$LINENO: checking for yp_get_default_domain" >&5
+echo $ECHO_N "checking for yp_get_default_domain... $ECHO_C" >&6
+if test "${ac_cv_func_yp_get_default_domain+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char yp_get_default_domain (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char yp_get_default_domain ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_yp_get_default_domain) || defined (__stub___yp_get_default_domain)
+choke me
+#else
+char (*f) () = yp_get_default_domain;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != yp_get_default_domain;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_yp_get_default_domain=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_yp_get_default_domain=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_yp_get_default_domain" >&5
+echo "${ECHO_T}$ac_cv_func_yp_get_default_domain" >&6
+if test $ac_cv_func_yp_get_default_domain = yes; then
+  :
+else
+
+echo "$as_me:$LINENO: checking for yp_get_default_domain in -lnsl" >&5
+echo $ECHO_N "checking for yp_get_default_domain in -lnsl... $ECHO_C" >&6
+if test "${ac_cv_lib_nsl_yp_get_default_domain+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char yp_get_default_domain ();
+int
+main ()
+{
+yp_get_default_domain ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_yp_get_default_domain=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_nsl_yp_get_default_domain=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_yp_get_default_domain" >&5
+echo "${ECHO_T}$ac_cv_lib_nsl_yp_get_default_domain" >&6
+if test $ac_cv_lib_nsl_yp_get_default_domain = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBNSL 1
+_ACEOF
+
+  LIBS="-lnsl $LIBS"
+
+fi
+
+fi
+
+	    echo "$as_me:$LINENO: checking for TCP wrappers library -lwrap linked with -lnsl" >&5
+echo $ECHO_N "checking for TCP wrappers library -lwrap linked with -lnsl... $ECHO_C" >&6
+	    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <tcpd.h>
+		         int allow_severity = 0;
+	                 int deny_severity  = 0;
+
+int
+main ()
+{
+hosts_access((void *)0)
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+			cat >>confdefs.h <<\_ACEOF
+#define USE_LIBWRAP 1
+_ACEOF
+
+			test "$with_libwrap" != no -a "$with_libwrap" != yes && WRAPLIBS="-L$with_libwrap/lib"
+			WRAPLIBS="$WRAPLIBS -lwrap -lnsl"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+			{ { echo "$as_me:$LINENO: error: Asked to use libwrap but I couldn't find it." >&5
+echo "$as_me: error: Asked to use libwrap but I couldn't find it." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+    CPPFLAGS=${_cppflags}
+    LDFLAGS=${_ldflags}
+    LIBS=${_libs}
+  fi
+
+fi;
+
+#
+# rpm libraries only needed for the host resources mib software
+# installed tables (on linux in particular)
+#
+if test "x$with_rpm" != "xno" && \
+        echo " $module_list " | grep " host/hr_swinst " > /dev/null; then
+  # ARG.  RPM is a real pain.
+  # FWIW librpm.la, librpmio.la, and libpopt.la have correct dependencies.
+  _rpmlibs=""
+
+  # zlib is required for newer versions of rpm
+  _cppflags="${CPPFLAGS}"
+  _ldflags="${LDFLAGS}"
+
+
+# Check whether --with-zlib or --without-zlib was given.
+if test "${with_zlib+set}" = set; then
+  withval="$with_zlib"
+
+    if test -d "$withval"; then
+      CPPFLAGS="${CPPFLAGS} -I$withval/include"
+      LDFLAGS="${LDFLAGS} -L$withval/lib"
+    fi
+
+fi;
+
+  # dunno if this is needed for rpm-4.0.x, earlier probably needs.
+  if test "${ac_cv_header_zlib_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for zlib.h" >&5
+echo $ECHO_N "checking for zlib.h... $ECHO_C" >&6
+if test "${ac_cv_header_zlib_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_zlib_h" >&5
+echo "${ECHO_T}$ac_cv_header_zlib_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking zlib.h usability" >&5
+echo $ECHO_N "checking zlib.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <zlib.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking zlib.h presence" >&5
+echo $ECHO_N "checking zlib.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <zlib.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: zlib.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: zlib.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: zlib.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: zlib.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: zlib.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: zlib.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: zlib.h: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: zlib.h: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: zlib.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: zlib.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for zlib.h" >&5
+echo $ECHO_N "checking for zlib.h... $ECHO_C" >&6
+if test "${ac_cv_header_zlib_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_zlib_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_zlib_h" >&5
+echo "${ECHO_T}$ac_cv_header_zlib_h" >&6
+
+fi
+if test $ac_cv_header_zlib_h = yes; then
+
+echo "$as_me:$LINENO: checking for gzread in -lz" >&5
+echo $ECHO_N "checking for gzread in -lz... $ECHO_C" >&6
+if test "${ac_cv_lib_z_gzread+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lz  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gzread ();
+int
+main ()
+{
+gzread ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_z_gzread=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_z_gzread=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_z_gzread" >&5
+echo "${ECHO_T}$ac_cv_lib_z_gzread" >&6
+if test $ac_cv_lib_z_gzread = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBZ 1
+_ACEOF
+
+  LIBS="-lz $LIBS"
+
+else
+  CPPFLAGS=${_cppflags} LDFLAGS=${_ldflags}
+fi
+
+else
+  CPPFLAGS=${_cppflags} LDFLAGS=${_ldflags}
+fi
+
+
+
+  # two variants of bzip2 need checking.
+  echo "$as_me:$LINENO: checking for bzread in -lbz2" >&5
+echo $ECHO_N "checking for bzread in -lbz2... $ECHO_C" >&6
+if test "${ac_cv_lib_bz2_bzread+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lbz2  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char bzread ();
+int
+main ()
+{
+bzread ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_bz2_bzread=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_bz2_bzread=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_bz2_bzread" >&5
+echo "${ECHO_T}$ac_cv_lib_bz2_bzread" >&6
+if test $ac_cv_lib_bz2_bzread = yes; then
+  _rpmlibs="$_rpmlibs -lbz2"
+else
+  echo "$as_me:$LINENO: checking for BZ2_bzread in -lbz2" >&5
+echo $ECHO_N "checking for BZ2_bzread in -lbz2... $ECHO_C" >&6
+if test "${ac_cv_lib_bz2_BZ2_bzread+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lbz2  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char BZ2_bzread ();
+int
+main ()
+{
+BZ2_bzread ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_bz2_BZ2_bzread=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_bz2_BZ2_bzread=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_bz2_BZ2_bzread" >&5
+echo "${ECHO_T}$ac_cv_lib_bz2_BZ2_bzread" >&6
+if test $ac_cv_lib_bz2_BZ2_bzread = yes; then
+  _rpmlibs="$_rpmlibs -lbz2"
+fi
+
+fi
+
+
+  # two variants of db1 need checking.
+  echo "$as_me:$LINENO: checking for dbopen in -ldb1" >&5
+echo $ECHO_N "checking for dbopen in -ldb1... $ECHO_C" >&6
+if test "${ac_cv_lib_db1_dbopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldb1  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dbopen ();
+int
+main ()
+{
+dbopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_db1_dbopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_db1_dbopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_db1_dbopen" >&5
+echo "${ECHO_T}$ac_cv_lib_db1_dbopen" >&6
+if test $ac_cv_lib_db1_dbopen = yes; then
+  _rpmlibs="-ldb1 $_rpmlibs"
+else
+  echo "$as_me:$LINENO: checking for dbopen in -ldb" >&5
+echo $ECHO_N "checking for dbopen in -ldb... $ECHO_C" >&6
+if test "${ac_cv_lib_db_dbopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldb  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dbopen ();
+int
+main ()
+{
+dbopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_db_dbopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_db_dbopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_db_dbopen" >&5
+echo "${ECHO_T}$ac_cv_lib_db_dbopen" >&6
+if test $ac_cv_lib_db_dbopen = yes; then
+  _rpmlibs="-ldb $_rpmlibs"
+fi
+
+fi
+
+
+  # two variants of db3 need checking.
+  echo "$as_me:$LINENO: checking for db_create in -ldb-3.1" >&5
+echo $ECHO_N "checking for db_create in -ldb-3.1... $ECHO_C" >&6
+if test "${ac_cv_lib_db_3_1_db_create+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldb-3.1  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char db_create ();
+int
+main ()
+{
+db_create ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_db_3_1_db_create=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_db_3_1_db_create=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_db_3_1_db_create" >&5
+echo "${ECHO_T}$ac_cv_lib_db_3_1_db_create" >&6
+if test $ac_cv_lib_db_3_1_db_create = yes; then
+  _rpmlibs="-ldb-3.1 $_rpmlibs"
+else
+  echo "$as_me:$LINENO: checking for db_create in -ldb-3.0" >&5
+echo $ECHO_N "checking for db_create in -ldb-3.0... $ECHO_C" >&6
+if test "${ac_cv_lib_db_3_0_db_create+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldb-3.0  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char db_create ();
+int
+main ()
+{
+db_create ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_db_3_0_db_create=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_db_3_0_db_create=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_db_3_0_db_create" >&5
+echo "${ECHO_T}$ac_cv_lib_db_3_0_db_create" >&6
+if test $ac_cv_lib_db_3_0_db_create = yes; then
+  _rpmlibs="-ldb-3.0 $_rpmlibs"
+fi
+
+fi
+
+
+  # rpm-3.0.5 and later needs popt.
+  echo "$as_me:$LINENO: checking for poptParseArgvString in -lpopt" >&5
+echo $ECHO_N "checking for poptParseArgvString in -lpopt... $ECHO_C" >&6
+if test "${ac_cv_lib_popt_poptParseArgvString+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpopt  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char poptParseArgvString ();
+int
+main ()
+{
+poptParseArgvString ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_popt_poptParseArgvString=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_popt_poptParseArgvString=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_popt_poptParseArgvString" >&5
+echo "${ECHO_T}$ac_cv_lib_popt_poptParseArgvString" >&6
+if test $ac_cv_lib_popt_poptParseArgvString = yes; then
+  _rpmlibs="-lpopt $_rpmlibs"
+fi
+
+
+  # rpm-4.0.x needs rpmio.
+  echo "$as_me:$LINENO: checking for Fopen in -lrpmio" >&5
+echo $ECHO_N "checking for Fopen in -lrpmio... $ECHO_C" >&6
+if test "${ac_cv_lib_rpmio_Fopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrpmio $_rpmlibs $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char Fopen ();
+int
+main ()
+{
+Fopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_rpmio_Fopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_rpmio_Fopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_rpmio_Fopen" >&5
+echo "${ECHO_T}$ac_cv_lib_rpmio_Fopen" >&6
+if test $ac_cv_lib_rpmio_Fopen = yes; then
+  _rpmlibs="-lrpmio $_rpmlibs"
+fi
+
+
+  # now check for rpm using the appropriate libraries.
+  echo "$as_me:$LINENO: checking for rpmGetFilesystemList in -lrpm" >&5
+echo $ECHO_N "checking for rpmGetFilesystemList in -lrpm... $ECHO_C" >&6
+if test "${ac_cv_lib_rpm_rpmGetFilesystemList+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrpm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char rpmGetFilesystemList ();
+int
+main ()
+{
+rpmGetFilesystemList ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_rpm_rpmGetFilesystemList=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_rpm_rpmGetFilesystemList=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_rpm_rpmGetFilesystemList" >&5
+echo "${ECHO_T}$ac_cv_lib_rpm_rpmGetFilesystemList" >&6
+if test $ac_cv_lib_rpm_rpmGetFilesystemList = yes; then
+
+    cat >>confdefs.h <<\_ACEOF
+#define HAVE_LIBRPM 1
+_ACEOF
+
+    LIBS="-lrpm $_rpmlibs $LIBS"
+    CFLAGS="$CFLAGS -I/usr/include/rpm"
+
+else
+
+    # rpm-4.0.3 librpmdb actually contains what we need.
+    echo "$as_me:$LINENO: checking for rpmdbOpen in -lrpmdb" >&5
+echo $ECHO_N "checking for rpmdbOpen in -lrpmdb... $ECHO_C" >&6
+if test "${ac_cv_lib_rpmdb_rpmdbOpen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrpmdb -lrpm $_rpmlibs $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char rpmdbOpen ();
+int
+main ()
+{
+rpmdbOpen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_rpmdb_rpmdbOpen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_rpmdb_rpmdbOpen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_rpmdb_rpmdbOpen" >&5
+echo "${ECHO_T}$ac_cv_lib_rpmdb_rpmdbOpen" >&6
+if test $ac_cv_lib_rpmdb_rpmdbOpen = yes; then
+
+      cat >>confdefs.h <<\_ACEOF
+#define HAVE_LIBRPM 1
+_ACEOF
+
+      LIBS="-lrpmdb -lrpm $_rpmlibs $LIBS"
+      CFLAGS="$CFLAGS -I/usr/include/rpm"
+
+fi
+
+
+fi
+
+fi
+
+# Replace `main' with a function in -lkvm:
+
+echo "$as_me:$LINENO: checking for kvm_read in -lkvm" >&5
+echo $ECHO_N "checking for kvm_read in -lkvm... $ECHO_C" >&6
+if test "${ac_cv_lib_kvm_kvm_read+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lkvm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char kvm_read ();
+int
+main ()
+{
+kvm_read ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_kvm_kvm_read=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_kvm_kvm_read=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_kvm_kvm_read" >&5
+echo "${ECHO_T}$ac_cv_lib_kvm_kvm_read" >&6
+if test $ac_cv_lib_kvm_kvm_read = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBKVM 1
+_ACEOF
+
+  LIBS="-lkvm $LIBS"
+
+fi
+
+# DYNAMIC MODULE SUPPORT
+
+echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
+echo $ECHO_N "checking for dlopen in -ldl... $ECHO_C" >&6
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dlopen ();
+int
+main ()
+{
+dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dl_dlopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_dl_dlopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
+echo "${ECHO_T}$ac_cv_lib_dl_dlopen" >&6
+if test $ac_cv_lib_dl_dlopen = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBDL 1
+_ACEOF
+
+  LIBS="-ldl $LIBS"
+
+fi
+
+
+for ac_func in dlopen
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+for ac_func in kvm_openfiles nlist knlist kvm_getprocs
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+echo "$with_mib_modules" | grep "ucd-snmp/diskio" >/dev/null
+# whether we need -ldevstat for diskio MIB
+if test $? -eq 0 ; then
+	echo "$as_me:$LINENO: checking for getdevs" >&5
+echo $ECHO_N "checking for getdevs... $ECHO_C" >&6
+if test "${ac_cv_func_getdevs+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char getdevs (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getdevs ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_getdevs) || defined (__stub___getdevs)
+choke me
+#else
+char (*f) () = getdevs;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != getdevs;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_getdevs=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_getdevs=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_getdevs" >&5
+echo "${ECHO_T}$ac_cv_func_getdevs" >&6
+if test $ac_cv_func_getdevs = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETDEVS 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: checking for getdevs in -ldevstat" >&5
+echo $ECHO_N "checking for getdevs in -ldevstat... $ECHO_C" >&6
+if test "${ac_cv_lib_devstat_getdevs+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldevstat  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getdevs ();
+int
+main ()
+{
+getdevs ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_devstat_getdevs=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_devstat_getdevs=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_devstat_getdevs" >&5
+echo "${ECHO_T}$ac_cv_lib_devstat_getdevs" >&6
+if test $ac_cv_lib_devstat_getdevs = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETDEVS 1
+_ACEOF
+
+		LIBS="${LIBS} -ldevstat"
+fi
+
+fi
+
+fi
+
+# LM-SENSORS-MIB support
+echo " $with_mib_modules " | grep " ucd-snmp/lmSensors " > /dev/null
+if test $? -eq 0 ; then
+        if test "${ac_cv_header_sensors_sensors_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for sensors/sensors.h" >&5
+echo $ECHO_N "checking for sensors/sensors.h... $ECHO_C" >&6
+if test "${ac_cv_header_sensors_sensors_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_sensors_sensors_h" >&5
+echo "${ECHO_T}$ac_cv_header_sensors_sensors_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking sensors/sensors.h usability" >&5
+echo $ECHO_N "checking sensors/sensors.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <sensors/sensors.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking sensors/sensors.h presence" >&5
+echo $ECHO_N "checking sensors/sensors.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sensors/sensors.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: sensors/sensors.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: sensors/sensors.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sensors/sensors.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: sensors/sensors.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: sensors/sensors.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: sensors/sensors.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sensors/sensors.h: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: sensors/sensors.h: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sensors/sensors.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: sensors/sensors.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for sensors/sensors.h" >&5
+echo $ECHO_N "checking for sensors/sensors.h... $ECHO_C" >&6
+if test "${ac_cv_header_sensors_sensors_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_sensors_sensors_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_sensors_sensors_h" >&5
+echo "${ECHO_T}$ac_cv_header_sensors_sensors_h" >&6
+
+fi
+
+
+
+echo "$as_me:$LINENO: checking for sensors_get_detected_chips in -lsensors" >&5
+echo $ECHO_N "checking for sensors_get_detected_chips in -lsensors... $ECHO_C" >&6
+if test "${ac_cv_lib_sensors_sensors_get_detected_chips+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsensors  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char sensors_get_detected_chips ();
+int
+main ()
+{
+sensors_get_detected_chips ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_sensors_sensors_get_detected_chips=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_sensors_sensors_get_detected_chips=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_sensors_sensors_get_detected_chips" >&5
+echo "${ECHO_T}$ac_cv_lib_sensors_sensors_get_detected_chips" >&6
+if test $ac_cv_lib_sensors_sensors_get_detected_chips = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBSENSORS 1
+_ACEOF
+
+  LIBS="-lsensors $LIBS"
+
+fi
+
+fi
+
+#
+# Install the various perl modules
+#
+
+if test "x$embed_perl" = "xyes" -a "x$install_perl" = "xno" ; then
+  install_perl="yes"
+fi
+if test "x$install_perl" != "x" -a "x$install_perl" != "xno"; then
+    PERLTARGS="perlmodules"
+    PERLINSTALLTARGS="perlinstall"
+    PERLUNINSTALLTARGS="perluninstall"
+
+
+
+
+
+  cat >> configure-summary << EOF
+  SNMP Perl modules:          enabled
+EOF
+
+else
+
+  cat >> configure-summary << EOF
+  SNMP Perl modules:          disabled
+EOF
+
+fi
+
+#
+# Embedded Perl specific stuff
+#
+if test "x$embed_perl" = "xyes"; then
+    myperl=$ac_cv_path_PERLPROG
+    if test $myperl = "no"; then
+      { { echo "$as_me:$LINENO: error: --enable-embedded-perl requested but no perl executable found" >&5
+echo "$as_me: error: --enable-embedded-perl requested but no perl executable found" >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+
+    echo "$as_me:$LINENO: checking for perl CFLAGS" >&5
+echo $ECHO_N "checking for perl CFLAGS... $ECHO_C" >&6
+    perlcflags=`$myperl -MExtUtils::Embed -e ccopts`
+    echo "$as_me:$LINENO: result: $perlcflags" >&5
+echo "${ECHO_T}$perlcflags" >&6
+    CPPFLAGS="$CPPFLAGS $perlcflags"
+
+    echo "$as_me:$LINENO: checking for perl LDFLAGS" >&5
+echo $ECHO_N "checking for perl LDFLAGS... $ECHO_C" >&6
+    perlldopts=`$myperl -MExtUtils::Embed -e ldopts`
+    echo "$as_me:$LINENO: result: $perlldopts" >&5
+echo "${ECHO_T}$perlldopts" >&6
+    LIBS="$LIBS $perlldopts"
+
+    # newer perl vs older perl call functions
+
+
+for ac_func in eval_pv perl_eval_pv
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+    cat >>confdefs.h <<\_ACEOF
+#define NETSNMP_EMBEDDED_PERL 1
+_ACEOF
+
+    OTHERAGENTLIBOBJS="snmp_perl.o"
+    OTHERAGENTLIBLOBJS="snmp_perl.lo"
+
+    EMBEDPERLINSTALL="embedperlinstall"
+    EMBEDPERLUNINSTALL="embedperluninstall"
+
+  cat >> configure-summary << EOF
+  Embedded perl support:      enabled
+EOF
+
+else
+    EMBEDPERLINSTALL=""
+    EMBEDPERLUNINSTALL=""
+
+  cat >> configure-summary << EOF
+  Embedded perl support:      disabled
+EOF
+
+fi
+
+
+
+# reset libs
+AGENTLIBS=$LIBS
+LIBS=$NONAGENTLIBS
+
+# Checks for header files.
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_stdc=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+                   (('a' <= (c) && (c) <= 'i') \
+                     || ('j' <= (c) && (c) <= 'r') \
+                     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+        || toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+
+
+
+
+
+ac_header_dirent=no
+for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h; do
+  as_ac_Header=`echo "ac_cv_header_dirent_$ac_hdr" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_hdr that defines DIR" >&5
+echo $ECHO_N "checking for $ac_hdr that defines DIR... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <$ac_hdr>
+
+int
+main ()
+{
+if ((DIR *) 0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_Header=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
+_ACEOF
+
+ac_header_dirent=$ac_hdr; break
+fi
+
+done
+# Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
+if test $ac_header_dirent = dirent.h; then
+  echo "$as_me:$LINENO: checking for library containing opendir" >&5
+echo $ECHO_N "checking for library containing opendir... $ECHO_C" >&6
+if test "${ac_cv_search_opendir+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_opendir=no
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char opendir ();
+int
+main ()
+{
+opendir ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_opendir="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_opendir" = no; then
+  for ac_lib in dir; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char opendir ();
+int
+main ()
+{
+opendir ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_opendir="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_opendir" >&5
+echo "${ECHO_T}$ac_cv_search_opendir" >&6
+if test "$ac_cv_search_opendir" != no; then
+  test "$ac_cv_search_opendir" = "none required" || LIBS="$ac_cv_search_opendir $LIBS"
+
+fi
+
+else
+  echo "$as_me:$LINENO: checking for library containing opendir" >&5
+echo $ECHO_N "checking for library containing opendir... $ECHO_C" >&6
+if test "${ac_cv_search_opendir+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_opendir=no
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char opendir ();
+int
+main ()
+{
+opendir ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_opendir="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_opendir" = no; then
+  for ac_lib in x; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char opendir ();
+int
+main ()
+{
+opendir ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_opendir="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_opendir" >&5
+echo "${ECHO_T}$ac_cv_search_opendir" >&6
+if test "$ac_cv_search_opendir" != no; then
+  test "$ac_cv_search_opendir" = "none required" || LIBS="$ac_cv_search_opendir $LIBS"
+
+fi
+
+fi
+
+echo "$as_me:$LINENO: checking for sys/wait.h that is POSIX.1 compatible" >&5
+echo $ECHO_N "checking for sys/wait.h that is POSIX.1 compatible... $ECHO_C" >&6
+if test "${ac_cv_header_sys_wait_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/wait.h>
+#ifndef WEXITSTATUS
+# define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
+#endif
+#ifndef WIFEXITED
+# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
+#endif
+
+int
+main ()
+{
+  int s;
+  wait (&s);
+  s = WIFEXITED (s) ? WEXITSTATUS (s) : 1;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_sys_wait_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_sys_wait_h=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_sys_wait_h" >&5
+echo "${ECHO_T}$ac_cv_header_sys_wait_h" >&6
+if test $ac_cv_header_sys_wait_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_SYS_WAIT_H 1
+_ACEOF
+
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in stdarg.h string.h fcntl.h limits.h sys/file.h sys/ioctl.h syslog.h unistd.h netinet/tcpip.h netinet/in.h netinet/ip.h netinet/ip_icmp.h net/if.h netdb.h sys/dmap.h machine/pte.h xti.h sys/sockio.h sys/socket.h sys/un.h fstab.h sys/fs.h mtab.h ufs/fs.h ufs/ffs/fs.h sys/fixpoint.h machine/param.h sys/vm.h vm/vm.h sys/vmmeter.h sys/vmparam.h sys/vmmac.h sys/vmsystm.h sys/mbuf.h sys/time.h sys/swap.h inet/mib2.h sys/statvfs.h sys/vfs.h sys/mnttab.h sys/user.h sys/proc.h sys/select.h mntent.h sys/mntent.h kstat.h utsname.h sys/utsname.h sys/cdefs.h getopt.h locale.h pthread.h sys/loadavg.h regex.h linux/tasks.h pwd.h grp.h utmpx.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# FreeBSD required headers
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in malloc.h sys/param.h net/if_dl.h sys/sysctl.h stdlib.h net/if_mib.h net/if_types.h net/if_var.h sys/queue.h osreldate.h machine/types.h sys/socketvar.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# Linux
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in sys/conf.h netinet/in_systm.h netinet/tcp.h netinet/udp.h netinet/in_var.h netinet/if_ether.h netinet/ip_var.h netinet/tcp_timer.h netinet/tcp_var.h netinet/tcp_fsm.h netinet/udp_var.h netinet/icmp_var.h sys/protosw.h nlist.h ioctls.h asm/page.h netipx/ipx.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# NetBSD required headers
+
+
+
+
+
+
+
+for ac_header in arpa/inet.h kvm.h sys/pool.h uvm/uvm_param.h uvm/uvm_extern.h vm/vm_param.h vm/vm_extern.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# BSDi2 headers
+
+
+
+for ac_header in sys/mount.h vm/swap_pager.h ufs/ufs/dinode.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# BSDi3 headers
+
+
+
+
+for ac_header in sys/stat.h sys/vnode.h ufs/ufs/quota.h ufs/ufs/inode.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# irix headers
+
+
+
+for ac_header in sys/hashing.h sys/tcpipstats.h sys/sysmp.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# from smux stuff
+
+
+
+for ac_header in err.h sys/filio.h sgtty.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# AIX needs this for statfs func
+
+for ac_header in sys/statfs.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# Dynix
+
+for ac_header in net/route.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# for HostRes (HP-UX at least)
+
+
+
+
+
+for ac_header in sys/dkio.h sys/diskio.h sys/pstat.h linux/hdreg.h pkglocs.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# for HostRes (Solaris 2.x at least)
+
+for ac_header in pkginfo.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ echo "$as_me:$LINENO: checking for pkginfo in -ladm" >&5
+echo $ECHO_N "checking for pkginfo in -ladm... $ECHO_C" >&6
+if test "${ac_cv_lib_adm_pkginfo+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ladm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char pkginfo ();
+int
+main ()
+{
+pkginfo ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_adm_pkginfo=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_adm_pkginfo=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_adm_pkginfo" >&5
+echo "${ECHO_T}$ac_cv_lib_adm_pkginfo" >&6
+if test $ac_cv_lib_adm_pkginfo = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_PKGINFO 1
+_ACEOF
+
+    LIBS="${LIBS} -ladm"
+    AGENTLIBS="${AGENTLIBS} -ladm"
+fi
+
+fi
+
+done
+
+# AIX perfstat library, needed for CPU/memory statistics
+case $target_os in
+    aix*)
+
+for ac_header in libperfstat.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ echo "$as_me:$LINENO: checking for perfstat_cpu_total in -lperfstat" >&5
+echo $ECHO_N "checking for perfstat_cpu_total in -lperfstat... $ECHO_C" >&6
+if test "${ac_cv_lib_perfstat_perfstat_cpu_total+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lperfstat  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char perfstat_cpu_total ();
+int
+main ()
+{
+perfstat_cpu_total ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_perfstat_perfstat_cpu_total=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_perfstat_perfstat_cpu_total=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_perfstat_perfstat_cpu_total" >&5
+echo "${ECHO_T}$ac_cv_lib_perfstat_perfstat_cpu_total" >&6
+if test $ac_cv_lib_perfstat_perfstat_cpu_total = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_PERFSTAT 1
+_ACEOF
+
+            AGENTLIBS="${AGENTLIBS} -lperfstat"
+fi
+
+else
+  { { echo "$as_me:$LINENO: error:
+
+*** To monitor CPU/memory values in AIX you need to install
+*** libperfstat which can be found in bos.perf
+" >&5
+echo "$as_me: error:
+
+*** To monitor CPU/memory values in AIX you need to install
+*** libperfstat which can be found in bos.perf
+" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+done
+
+        ;;
+    *)
+        ;;
+esac
+# WIN32
+
+for ac_header in winsock.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ AGENTLIBS="${AGENTLIBS} -liphlpapi"
+fi
+
+done
+
+
+for ac_header in io.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# SCO
+
+for ac_header in sys/stream.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# KAME
+
+
+
+
+
+
+
+
+
+for ac_header in netinet/ip6.h netinet6/in6_var.h netinet6/in6_pcb.h netinet6/ip6_var.h netinet6/tcp6.h netinet6/tcp6_fsm.h netinet6/nd6.h netinet6/tcp6_timer.h netinet6/tcp6_var.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# DYNAMIC MODULE SUPPORT
+
+for ac_header in dlfcn.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# table_array helper support
+
+for ac_header in search.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+# RPM subdirectory path (sigh)
+if test "x$with_rpm" != "xno" && \
+        echo " $module_list " | grep " host/hr_swinst " > /dev/null; then
+
+for ac_header in rpmio.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+else
+
+
+for ac_header in rpm/rpmio.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ CFLAGS="-I/usr/include/rpm $CFLAGS"
+fi
+
+done
+
+
+fi
+
+done
+
+fi
+
+# OpenBSD 2.6 needs netinet/in.h before netinet/in_pcb.h
+echo "$as_me:$LINENO: checking for netinet/in_pcb.h" >&5
+echo $ECHO_N "checking for netinet/in_pcb.h... $ECHO_C" >&6
+if test "${cv_have_netinet_in_pcb_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+   cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <netinet/in.h>
+#include <netinet/in_pcb.h>
+
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  cv_have_netinet_in_pcb_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  cv_have_netinet_in_pcb_h=no
+fi
+rm -f conftest.err conftest.$ac_ext
+fi
+
+echo "$as_me:$LINENO: result: $cv_have_netinet_in_pcb_h" >&5
+echo "${ECHO_T}$cv_have_netinet_in_pcb_h" >&6
+if test $cv_have_netinet_in_pcb_h = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_NETINET_IN_PCB_H 1
+_ACEOF
+
+fi
+
+# NetBSD needs machine/types.h before sys/disklabel.h
+echo "$as_me:$LINENO: checking for sys/disklabel.h" >&5
+echo $ECHO_N "checking for sys/disklabel.h... $ECHO_C" >&6
+if test "${cv_have_sys_disklabel_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+   cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <machine/types.h>
+#include <sys/disklabel.h>
+
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  cv_have_sys_disklabel_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  cv_have_sys_disklabel_h=no
+fi
+rm -f conftest.err conftest.$ac_ext
+fi
+
+echo "$as_me:$LINENO: result: $cv_have_sys_disklabel_h" >&5
+echo "${ECHO_T}$cv_have_sys_disklabel_h" >&6
+if test $cv_have_sys_disklabel_h = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_SYS_DISKLABEL_H 1
+_ACEOF
+
+fi
+
+# OpenSSL
+
+
+
+
+for ac_header in openssl/hmac.h openssl/evp.h openssl/aes.h openssl/des.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+# Printing
+# Extract the first word of "lpstat", so it can be a program name with args.
+set dummy lpstat; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_LPSTAT_PATH+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $LPSTAT_PATH in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_LPSTAT_PATH="$LPSTAT_PATH" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_LPSTAT_PATH="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  ;;
+esac
+fi
+LPSTAT_PATH=$ac_cv_path_LPSTAT_PATH
+
+if test -n "$LPSTAT_PATH"; then
+  echo "$as_me:$LINENO: result: $LPSTAT_PATH" >&5
+echo "${ECHO_T}$LPSTAT_PATH" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+if test x$LPSTAT_PATH != x; then
+    cat >>confdefs.h <<_ACEOF
+#define LPSTAT_PATH "$LPSTAT_PATH"
+_ACEOF
+
+    cat >>confdefs.h <<\_ACEOF
+#define HAVE_LPSTAT 1
+_ACEOF
+
+fi
+
+for ac_func in cgetnext
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+if test -r /etc/printcap; then
+    cat >>confdefs.h <<\_ACEOF
+#define HAVE_PRINTCAP 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for authentication support" >&5
+echo $ECHO_N "checking for authentication support... $ECHO_C" >&6
+if test "x$ac_cv_lib_crypto_EVP_md5" != "xyes" -o "x$ac_cv_header_openssl_hmac_h" != "xyes" -o "x$ac_cv_header_openssl_hmac_h" != "xyes"; then
+# if OpenSSL is not found, default to using internal md5 support.
+    cat >>confdefs.h <<\_ACEOF
+#define USE_INTERNAL_MD5 1
+_ACEOF
+
+    authmodes="MD5"
+    encrmodes=""
+    echo "$as_me:$LINENO: result: Internal MD5 Support" >&5
+echo "${ECHO_T}Internal MD5 Support" >&6
+    if test "x$askedopenssl" = "xyes"; then
+	{ { echo "$as_me:$LINENO: error: Asked to use OpenSSL but I couldn't find it." >&5
+echo "$as_me: error: Asked to use OpenSSL but I couldn't find it." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+else
+    if test "x$tryopenssl" = "xno"; then
+        authmodes="MD5"
+        encrmodes=""
+	cat >>confdefs.h <<\_ACEOF
+#define USE_INTERNAL_MD5 1
+_ACEOF
+
+	echo "$as_me:$LINENO: result: Internal MD5 Support" >&5
+echo "${ECHO_T}Internal MD5 Support" >&6
+    else
+        authmodes="MD5 SHA1"
+        if test "x$enable_privacy" != "xno" ; then
+	    if test $ac_cv_header_openssl_aes_h = "yes" ; then
+	        encrmodes="DES AES128 AES192 AES256"
+	    else
+	        encrmodes="DES"
+	    fi
+        else
+	    encrmodes="disabled"
+        fi
+	cat >>confdefs.h <<\_ACEOF
+#define USE_OPENSSL 1
+_ACEOF
+
+	echo "$as_me:$LINENO: result: OpenSSL Support" >&5
+echo "${ECHO_T}OpenSSL Support" >&6
+    fi
+fi
+
+
+  cat >> configure-summary << EOF
+  Authentication support:     $authmodes
+EOF
+
+
+  cat >> configure-summary << EOF
+  Encryption support:         $encrmodes
+EOF
+
+
+# Checks for typedefs, structures, and compiler characteristics.
+echo "$as_me:$LINENO: checking for off_t" >&5
+echo $ECHO_N "checking for off_t... $ECHO_C" >&6
+if test "${ac_cv_type_off_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((off_t *) 0)
+  return 0;
+if (sizeof (off_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_off_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_off_t=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
+echo "${ECHO_T}$ac_cv_type_off_t" >&6
+if test $ac_cv_type_off_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define off_t long
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for pid_t" >&5
+echo $ECHO_N "checking for pid_t... $ECHO_C" >&6
+if test "${ac_cv_type_pid_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((pid_t *) 0)
+  return 0;
+if (sizeof (pid_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_pid_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_pid_t=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_pid_t" >&5
+echo "${ECHO_T}$ac_cv_type_pid_t" >&6
+if test $ac_cv_type_pid_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define pid_t int
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking whether time.h and sys/time.h may both be included" >&5
+echo $ECHO_N "checking whether time.h and sys/time.h may both be included... $ECHO_C" >&6
+if test "${ac_cv_header_time+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+
+int
+main ()
+{
+if ((struct tm *) 0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_time=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_time=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_time" >&5
+echo "${ECHO_T}$ac_cv_header_time" >&6
+if test $ac_cv_header_time = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define TIME_WITH_SYS_TIME 1
+_ACEOF
+
+fi
+
+
+# this should use AC_CHECK_TYPE, but it's broken at least in 2.13-14
+# so we do it by hand.
+echo "$as_me:$LINENO: checking for socklen_t" >&5
+echo $ECHO_N "checking for socklen_t... $ECHO_C" >&6
+if eval "test \"\${ac_cv_type_$1+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "socklen_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  ac_cv_type_socklen_t=yes
+else
+  ac_cv_type_socklen_t=no
+fi
+rm -f conftest*
+
+fi
+
+
+echo "$as_me:$LINENO: result: $ac_cv_type_socklen_t" >&5
+echo "${ECHO_T}$ac_cv_type_socklen_t" >&6
+if test $ac_cv_type_socklen_t = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_SOCKLEN_T 1
+_ACEOF
+
+fi
+
+# AIX keeps in_addr_t in /usr/include/netinet/in.h
+echo "$as_me:$LINENO: checking for in_addr_t" >&5
+echo $ECHO_N "checking for in_addr_t... $ECHO_C" >&6
+if eval "test \"\${ac_cv_type_$1+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "in_addr_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  ac_cv_type_in_addr_t=yes
+else
+  ac_cv_type_in_addr_t=no
+fi
+rm -f conftest*
+
+fi
+
+
+echo "$as_me:$LINENO: result: $ac_cv_type_in_addr_t" >&5
+echo "${ECHO_T}$ac_cv_type_in_addr_t" >&6
+if test $ac_cv_type_in_addr_t = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_IN_ADDR_T 1
+_ACEOF
+
+fi
+
+# Check ps args
+echo "$as_me:$LINENO: checking for correct flags to ps" >&5
+echo $ECHO_N "checking for correct flags to ps... $ECHO_C" >&6
+if test "${ac_cv_ps_flags+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "`($PSPROG -e 2>&1) | egrep ' (ps) *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="-e"
+elif test "`($PSPROG -el 2>&1) | egrep ' (ps) *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="-el"
+elif test "`($PSPROG acx 2>&1) | egrep ' (ps) *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="acx"
+elif test "`($PSPROG -acx 2>&1) | egrep ' (ps) *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="-acx"
+elif test "`($PSPROG -o pid,tt,state,time,ucomm 2>&1) | egrep ' ps *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="-o pid,tt,state,time,ucomm"
+elif test "`($PSPROG ax 2>&1) | egrep ' (ps) *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="ax"
+else
+  { echo "$as_me:$LINENO: WARNING: Unable to determine valid ps flags...  defaulting..." >&5
+echo "$as_me: WARNING: Unable to determine valid ps flags...  defaulting..." >&2;}
+  ac_cv_ps_flags="-acx"
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_ps_flags" >&5
+echo "${ECHO_T}$ac_cv_ps_flags" >&6
+
+PSCMD="$PSPROG $ac_cv_ps_flags"
+
+cat >>confdefs.h <<_ACEOF
+#define PSCMD "$PSPROG $ac_cv_ps_flags"
+_ACEOF
+
+
+# Checks for byte order
+if test $cross_compiling = yes; then
+  if test $with_endianness = "big"; then
+    cat >>confdefs.h <<\_ACEOF
+#define WORDS_BIGENDIAN 1
+_ACEOF
+
+  elif test -z $with_endianness; then
+    { { echo "$as_me:$LINENO: error: You are cross-compiling, but you have not specified the target's endianness" >&5
+echo "$as_me: error: You are cross-compiling, but you have not specified the target's endianness" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+else
+  if test $with_endianness; then
+    { { echo "$as_me:$LINENO: error: Endianness has been specified, but you are not cross-compiling." >&5
+echo "$as_me: error: Endianness has been specified, but you are not cross-compiling." >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  echo "$as_me:$LINENO: checking whether byte ordering is bigendian" >&5
+echo $ECHO_N "checking whether byte ordering is bigendian... $ECHO_C" >&6
+if test "${ac_cv_c_bigendian+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # See if sys/param.h defines the BYTE_ORDER macro.
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/param.h>
+
+int
+main ()
+{
+#if !BYTE_ORDER || !BIG_ENDIAN || !LITTLE_ENDIAN
+ bogus endian macros
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  # It does; now see whether it defined to BIG_ENDIAN or not.
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/param.h>
+
+int
+main ()
+{
+#if BYTE_ORDER != BIG_ENDIAN
+ not big endian
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_bigendian=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_c_bigendian=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+# It does not; compile a test program.
+if test "$cross_compiling" = yes; then
+  # try to guess the endianness by grepping values into an object file
+  ac_cv_c_bigendian=unknown
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
+short ascii_ii[] = { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
+void _ascii () { char *s = (char *) ascii_mm; s = (char *) ascii_ii; }
+short ebcdic_ii[] = { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
+short ebcdic_mm[] = { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
+void _ebcdic () { char *s = (char *) ebcdic_mm; s = (char *) ebcdic_ii; }
+int
+main ()
+{
+ _ascii (); _ebcdic ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if grep BIGenDianSyS conftest.$ac_objext >/dev/null ; then
+  ac_cv_c_bigendian=yes
+fi
+if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
+  if test "$ac_cv_c_bigendian" = unknown; then
+    ac_cv_c_bigendian=no
+  else
+    # finding both strings is unlikely to happen, but who knows?
+    ac_cv_c_bigendian=unknown
+  fi
+fi
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+int
+main ()
+{
+  /* Are we little or big endian?  From Harbison&Steele.  */
+  union
+  {
+    long l;
+    char c[sizeof (long)];
+  } u;
+  u.l = 1;
+  exit (u.c[sizeof (long) - 1] == 1);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_bigendian=no
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_c_bigendian=yes
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_bigendian" >&5
+echo "${ECHO_T}$ac_cv_c_bigendian" >&6
+case $ac_cv_c_bigendian in
+  yes)
+
+cat >>confdefs.h <<\_ACEOF
+#define WORDS_BIGENDIAN 1
+_ACEOF
+ ;;
+  no)
+     ;;
+  *)
+    { { echo "$as_me:$LINENO: error: unknown endianness
+presetting ac_cv_c_bigendian=no (or yes) will help" >&5
+echo "$as_me: error: unknown endianness
+presetting ac_cv_c_bigendian=no (or yes) will help" >&2;}
+   { (exit 1); exit 1; }; } ;;
+esac
+
+fi
+
+# Checks for library functions.
+# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+# for constant arguments.  Useless!
+echo "$as_me:$LINENO: checking for working alloca.h" >&5
+echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6
+if test "${ac_cv_working_alloca_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <alloca.h>
+int
+main ()
+{
+char *p = (char *) alloca (2 * sizeof (int));
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_working_alloca_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_working_alloca_h=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_working_alloca_h" >&5
+echo "${ECHO_T}$ac_cv_working_alloca_h" >&6
+if test $ac_cv_working_alloca_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA_H 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for alloca" >&5
+echo $ECHO_N "checking for alloca... $ECHO_C" >&6
+if test "${ac_cv_func_alloca_works+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+#else
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  if HAVE_ALLOCA_H
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+int
+main ()
+{
+char *p = (char *) alloca (1);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_alloca_works=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_alloca_works=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_alloca_works" >&5
+echo "${ECHO_T}$ac_cv_func_alloca_works" >&6
+
+if test $ac_cv_func_alloca_works = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA 1
+_ACEOF
+
+else
+  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+# that cause trouble.  Some versions do not even contain alloca or
+# contain a buggy version.  If you still want to use their alloca,
+# use ar to extract alloca.o from them instead of compiling alloca.c.
+
+ALLOCA=alloca.$ac_objext
+
+cat >>confdefs.h <<\_ACEOF
+#define C_ALLOCA 1
+_ACEOF
+
+
+echo "$as_me:$LINENO: checking whether \`alloca.c' needs Cray hooks" >&5
+echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6
+if test "${ac_cv_os_cray+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined(CRAY) && ! defined(CRAY2)
+webecray
+#else
+wenotbecray
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "webecray" >/dev/null 2>&1; then
+  ac_cv_os_cray=yes
+else
+  ac_cv_os_cray=no
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_os_cray" >&5
+echo "${ECHO_T}$ac_cv_os_cray" >&6
+if test $ac_cv_os_cray = yes; then
+  for ac_func in _getb67 GETB67 getb67; do
+    as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define CRAY_STACKSEG_END $ac_func
+_ACEOF
+
+    break
+fi
+
+  done
+fi
+
+echo "$as_me:$LINENO: checking stack direction for C alloca" >&5
+echo $ECHO_N "checking stack direction for C alloca... $ECHO_C" >&6
+if test "${ac_cv_c_stack_direction+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_c_stack_direction=0
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+int
+find_stack_direction ()
+{
+  static char *addr = 0;
+  auto char dummy;
+  if (addr == 0)
+    {
+      addr = &dummy;
+      return find_stack_direction ();
+    }
+  else
+    return (&dummy > addr) ? 1 : -1;
+}
+
+int
+main ()
+{
+  exit (find_stack_direction () < 0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_stack_direction=1
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_c_stack_direction=-1
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
+echo "${ECHO_T}$ac_cv_c_stack_direction" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define STACK_DIRECTION $ac_cv_c_stack_direction
+_ACEOF
+
+
+fi
+
+if test $ac_cv_c_compiler_gnu = yes; then
+    echo "$as_me:$LINENO: checking whether $CC needs -traditional" >&5
+echo $ECHO_N "checking whether $CC needs -traditional... $ECHO_C" >&6
+if test "${ac_cv_prog_gcc_traditional+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+    ac_pattern="Autoconf.*'x'"
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sgtty.h>
+Autoconf TIOCGETP
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "$ac_pattern" >/dev/null 2>&1; then
+  ac_cv_prog_gcc_traditional=yes
+else
+  ac_cv_prog_gcc_traditional=no
+fi
+rm -f conftest*
+
+
+  if test $ac_cv_prog_gcc_traditional = no; then
+    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <termio.h>
+Autoconf TCGETA
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "$ac_pattern" >/dev/null 2>&1; then
+  ac_cv_prog_gcc_traditional=yes
+fi
+rm -f conftest*
+
+  fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_gcc_traditional" >&5
+echo "${ECHO_T}$ac_cv_prog_gcc_traditional" >&6
+  if test $ac_cv_prog_gcc_traditional = yes; then
+    CC="$CC -traditional"
+  fi
+fi
+
+echo "$as_me:$LINENO: checking for working memcmp" >&5
+echo $ECHO_N "checking for working memcmp... $ECHO_C" >&6
+if test "${ac_cv_func_memcmp_working+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_memcmp_working=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  /* Some versions of memcmp are not 8-bit clean.  */
+  char c0 = 0x40, c1 = 0x80, c2 = 0x81;
+  if (memcmp(&c0, &c2, 1) >= 0 || memcmp(&c1, &c2, 1) >= 0)
+    exit (1);
+
+  /* The Next x86 OpenStep bug shows up only when comparing 16 bytes
+     or more and with at least one buffer not starting on a 4-byte boundary.
+     William Lewis provided this test program.   */
+  {
+    char foo[21];
+    char bar[21];
+    int i;
+    for (i = 0; i < 4; i++)
+      {
+        char *a = foo + i;
+        char *b = bar + i;
+        strcpy (a, "--------01111111");
+        strcpy (b, "--------10000000");
+        if (memcmp (a, b, 16) >= 0)
+          exit (1);
+      }
+    exit (0);
+  }
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_memcmp_working=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_func_memcmp_working=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_memcmp_working" >&5
+echo "${ECHO_T}$ac_cv_func_memcmp_working" >&6
+test $ac_cv_func_memcmp_working = no && LIBOBJS="$LIBOBJS memcmp.$ac_objext"
+
+echo "$as_me:$LINENO: checking return type of signal handlers" >&5
+echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6
+if test "${ac_cv_type_signal+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+# undef signal
+#endif
+#ifdef __cplusplus
+extern "C" void (*signal (int, void (*)(int)))(int);
+#else
+void (*signal ()) ();
+#endif
+
+int
+main ()
+{
+int i;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_signal=void
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_signal=int
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_signal" >&5
+echo "${ECHO_T}$ac_cv_type_signal" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define RETSIGTYPE $ac_cv_type_signal
+_ACEOF
+
+
+# getmntent is in -lsun on Irix 4, -lseq on Dynix/PTX, -lgen on Unixware.
+echo "$as_me:$LINENO: checking for getmntent in -lsun" >&5
+echo $ECHO_N "checking for getmntent in -lsun... $ECHO_C" >&6
+if test "${ac_cv_lib_sun_getmntent+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsun  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getmntent ();
+int
+main ()
+{
+getmntent ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_sun_getmntent=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_sun_getmntent=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_sun_getmntent" >&5
+echo "${ECHO_T}$ac_cv_lib_sun_getmntent" >&6
+if test $ac_cv_lib_sun_getmntent = yes; then
+  LIBS="-lsun $LIBS"
+else
+  echo "$as_me:$LINENO: checking for getmntent in -lseq" >&5
+echo $ECHO_N "checking for getmntent in -lseq... $ECHO_C" >&6
+if test "${ac_cv_lib_seq_getmntent+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lseq  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getmntent ();
+int
+main ()
+{
+getmntent ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_seq_getmntent=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_seq_getmntent=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_seq_getmntent" >&5
+echo "${ECHO_T}$ac_cv_lib_seq_getmntent" >&6
+if test $ac_cv_lib_seq_getmntent = yes; then
+  LIBS="-lseq $LIBS"
+else
+  echo "$as_me:$LINENO: checking for getmntent in -lgen" >&5
+echo $ECHO_N "checking for getmntent in -lgen... $ECHO_C" >&6
+if test "${ac_cv_lib_gen_getmntent+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgen  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getmntent ();
+int
+main ()
+{
+getmntent ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_gen_getmntent=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_gen_getmntent=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_gen_getmntent" >&5
+echo "${ECHO_T}$ac_cv_lib_gen_getmntent" >&6
+if test $ac_cv_lib_gen_getmntent = yes; then
+  LIBS="-lgen $LIBS"
+fi
+
+fi
+
+fi
+
+
+for ac_func in getmntent
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+
+
+
+
+
+for ac_func in setmntent gethostname uname gettimeofday select socket strtol strtoul strlcpy
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+
+
+
+for ac_func in strchr strdup memcpy memmove index bcopy strcasestr regcomp
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+
+
+
+
+for ac_func in signal setsid sigset sigblock sighold strerror setenv vsnprintf snprintf
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in sigaction
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+for ac_func in snprintf strtoul
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+for ac_func in random lrand48 rand
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+
+for ac_func in execv system fork getpid strncasecmp sigalrm
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+if test "x$with_rpm" != "xno" && \
+        echo " $module_list " | grep " host/hr_swinst " > /dev/null; then
+  OLDLIBS=$LIBS
+  LIBS=$AGENTLIBS
+
+for ac_func in rpmGetPath
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+  LIBS=$OLDLIBS
+fi
+
+
+for ac_func in getloadavg
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+for ac_func in getaddrinfo getipnodebyname
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+# BSDi2 functions differ
+
+
+for ac_func in statvfs statfs
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in getdtablesize
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+# freebsd2 checks
+
+for ac_func in getfsstat
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in usleep
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in setlocale
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in tcgetattr
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+for ac_func in if_nameindex if_freenameindex
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+# solaris checks
+
+for ac_func in getpagesize
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in mkstemp
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+for ac_func in getpwnam getgrnam setgid setuid setgroups
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+# High resolution alarm support
+
+for ac_func in setitimer
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+echo "$as_me:$LINENO: checking for SIOCGIFADDR in sys/ioctl.h" >&5
+echo $ECHO_N "checking for SIOCGIFADDR in sys/ioctl.h... $ECHO_C" >&6
+if test "${cv_sys_ioctl_h_has_SIOCGIFADDR+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+   cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
+#ifdef SIOCGIFADDR
+xxxyesxxx
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "xxxyesxxx" >/dev/null 2>&1; then
+  cv_sys_ioctl_h_has_SIOCGIFADDR=yes
+else
+  cv_sys_ioctl_h_has_SIOCGIFADDR=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$as_me:$LINENO: result: $cv_sys_ioctl_h_has_SIOCGIFADDR" >&5
+echo "${ECHO_T}$cv_sys_ioctl_h_has_SIOCGIFADDR" >&6
+if test $cv_sys_ioctl_h_has_SIOCGIFADDR = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define SYS_IOCTL_H_HAS_SIOCGIFADDR 1
+_ACEOF
+
+fi
+
+# ultrix
+echo "$as_me:$LINENO: checking for two-argument statfs with struct fs_data (Ultrix)" >&5
+echo $ECHO_N "checking for two-argument statfs with struct fs_data (Ultrix)... $ECHO_C" >&6
+if test "${fu_cv_sys_stat_fs_data+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  fu_cv_sys_stat_fs_data=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+#ifdef HAVE_SYS_FS_TYPES_H
+#include <sys/fs_types.h>
+#endif
+main ()
+{
+struct fs_data fsd;
+/* Ultrix's statfs returns 1 for success,
+   0 for not mounted, -1 for failure.  */
+exit (statfs (".", &fsd) != 1);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  fu_cv_sys_stat_fs_data=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+fu_cv_sys_stat_fs_data=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+
+echo "$as_me:$LINENO: result: $fu_cv_sys_stat_fs_data" >&5
+echo "${ECHO_T}$fu_cv_sys_stat_fs_data" >&6
+if test $fu_cv_sys_stat_fs_data = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define STAT_STATFS_FS_DATA 1
+_ACEOF
+
+fi
+
+# check if compiler pre-processor defines __FUNCTION__
+echo "$as_me:$LINENO: checking if __FUNCTION__ is defined" >&5
+echo $ECHO_N "checking if __FUNCTION__ is defined... $ECHO_C" >&6
+if test "${ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+    char *cp = __FUNCTION__;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED" >&5
+echo "${ECHO_T}$ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED" >&6
+
+if test "x$ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_CPP_UNDERBAR_FUNCTION_DEFINED 1
+_ACEOF
+
+fi
+
+
+
+ac_safe_struct=`echo "sigaction" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "sa_sigaction" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for sigaction.sa_sigaction" >&5
+echo $ECHO_N "checking for sigaction.sa_sigaction... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "xno" = "x"; then
+  defineit="= 0"
+elif test "xno" = "xno"; then
+  defineit=""
+else
+  defineit="no"
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <sys/signal.h>
+
+
+int
+main ()
+{
+
+struct sigaction testit;
+testit.sa_sigaction $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "sockaddr" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "sa_len" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for sockaddr.sa_len" >&5
+echo $ECHO_N "checking for sockaddr.sa_len... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "xno" = "x"; then
+  defineit="= 0"
+elif test "xno" = "xno"; then
+  defineit=""
+else
+  defineit="no"
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+
+
+int
+main ()
+{
+
+struct sockaddr testit;
+testit.sa_len $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "sockaddr" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "sa_union.sa_generic.sa_family2" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for sockaddr.sa_union.sa_generic.sa_family2" >&5
+echo $ECHO_N "checking for sockaddr.sa_union.sa_generic.sa_family2... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "xno" = "x"; then
+  defineit="= 0"
+elif test "xno" = "xno"; then
+  defineit=""
+else
+  defineit="no"
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+
+
+int
+main ()
+{
+
+struct sockaddr testit;
+testit.sa_union.sa_generic.sa_family2 $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "rtentry" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "rt_dst" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for rtentry.rt_dst" >&5
+echo $ECHO_N "checking for rtentry.rt_dst... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "xno" = "x"; then
+  defineit="= 0"
+elif test "xno" = "xno"; then
+  defineit=""
+else
+  defineit="no"
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+
+int
+main ()
+{
+
+struct rtentry testit;
+testit.rt_dst $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# checking for 4.3 vs 4.4 rtentry.
+echo "$as_me:$LINENO: checking type of rtentry structure" >&5
+echo $ECHO_N "checking type of rtentry structure... $ECHO_C" >&6
+if test "${ac_cv_RTENTRY_TYPE+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+
+# 4.4 compat
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+int
+main ()
+{
+
+
+#ifndef STRUCT_RTENTRY_HAS_RT_DST
+#define rt_dst rt_nodes->rn_key
+#endif
+
+  struct rtentry rt;
+  rt.rt_nodes[0].rn_flags = 1;
+  rt.rt_dst;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_RTENTRY_TYPE="BSD-4.4"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+# 4.3 compat
+if test "x$ac_cv_RTENTRY_TYPE" = "x"; then
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+int
+main ()
+{
+
+struct rtentry rt;
+rt.rt_hash;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_RTENTRY_TYPE="BSD-4.3"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+
+# else ack.
+if test "x$ac_cv_RTENTRY_TYPE" = "x"; then
+  echo "$as_me:$LINENO: result: Unknown" >&5
+echo "${ECHO_T}Unknown" >&6
+  ac_cv_RTENTRY_TYPE="unknown"
+fi
+
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_RTENTRY_TYPE" >&5
+echo "${ECHO_T}$ac_cv_RTENTRY_TYPE" >&6
+
+if test "x$ac_cv_RTENTRY_TYPE" = "xBSD-4.4"; then
+  cat >>confdefs.h <<\_ACEOF
+#define RTENTRY_4_4 1
+_ACEOF
+
+fi
+
+# checking for alpha's ortentry vs rtentry
+if test "x$ac_cv_RTENTRY_TYPE" = "xunknown"; then
+echo "$as_me:$LINENO: checking for struct rtentry" >&5
+echo $ECHO_N "checking for struct rtentry... $ECHO_C" >&6
+if test "${ac_cv_struct_rtentry+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#define KERNEL
+#include <net/route.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "ortentry" >/dev/null 2>&1; then
+  ac_cv_struct_rtentry=ortentry
+else
+  ac_cv_struct_rtentry=rtentry
+fi
+rm -f conftest*
+
+if test "x$ac_cv_struct_rtentry" = "xrtentry" ; then
+  ac_cv_struct_rtentry="rtentry"
+else
+  ac_cv_struct_rtentry="ortentry"
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_struct_rtentry" >&5
+echo "${ECHO_T}$ac_cv_struct_rtentry" >&6
+else
+  RTENTRY_TYPE="rtentry"
+  ac_cv_struct_rtentry="rtentry"
+fi
+
+if test "x$ac_cv_struct_rtentry" != "x"; then
+  cat >>confdefs.h <<_ACEOF
+#define RTENTRY struct ${ac_cv_struct_rtentry}
+_ACEOF
+
+else
+  cat >>confdefs.h <<\_ACEOF
+#define RTENTRY struct rtentry
+_ACEOF
+
+fi
+
+# check for 4.3's rtentry->rt_next
+if test "x$ac_cv_RTENTRY_TYPE" = "xBSD-4.3"; then
+echo "$as_me:$LINENO: checking for struct rtentry has a rt_next node" >&5
+echo $ECHO_N "checking for struct rtentry has a rt_next node... $ECHO_C" >&6
+if test "${ac_cv_struct_rtentry_rt_next+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+int
+main ()
+{
+
+struct rtentry rt;
+rt.rt_next;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_struct_rtentry_rt_next=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_struct_rtentry_rt_next=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_struct_rtentry_rt_next" >&5
+echo "${ECHO_T}$ac_cv_struct_rtentry_rt_next" >&6
+
+if test "x$ac_cv_struct_rtentry_rt_next" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define RTENTRY_RT_NEXT 1
+_ACEOF
+
+fi
+
+fi
+
+# Check struct rtentry for various things.
+
+
+ac_safe_struct=`echo "rtentry" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "rt_unit" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for rtentry.rt_unit" >&5
+echo $ECHO_N "checking for rtentry.rt_unit... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+
+int
+main ()
+{
+
+struct rtentry testit;
+testit.rt_unit $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "rtentry" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "rt_refcnt" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for rtentry.rt_refcnt" >&5
+echo $ECHO_N "checking for rtentry.rt_refcnt... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+
+int
+main ()
+{
+
+struct rtentry testit;
+testit.rt_refcnt $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "rtentry" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "rt_hash" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for rtentry.rt_hash" >&5
+echo $ECHO_N "checking for rtentry.rt_hash... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+
+int
+main ()
+{
+
+struct rtentry testit;
+testit.rt_hash $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "rtentry" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "rt_use" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for rtentry.rt_use" >&5
+echo $ECHO_N "checking for rtentry.rt_use... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+
+int
+main ()
+{
+
+struct rtentry testit;
+testit.rt_use $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# Check tcpstat for tcpstat.tcp_rcvmemdrop
+
+
+ac_safe_struct=`echo "tcpstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "tcp_rcvmemdrop" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for tcpstat.tcp_rcvmemdrop" >&5
+echo $ECHO_N "checking for tcpstat.tcp_rcvmemdrop... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <netinet/tcp.h>
+#ifdef HAVE_NETINET_TCP_TIMER_H
+#include <netinet/tcp_timer.h>
+#endif
+
+#ifdef HAVE_NETINET_TCP_VAR_H
+#include <netinet/tcp_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct tcpstat testit;
+testit.tcp_rcvmemdrop $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# irix checks
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_mtu" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_mtu" >&5
+echo $ECHO_N "checking for ifnet.if_mtu... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_mtu $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+if test "x$ac_cv_struct_ifnet_has_if_mtu" = "xno"; then
+echo "$as_me:$LINENO: checking if _KERNEL needs to be defined for if_mtu" >&5
+echo $ECHO_N "checking if _KERNEL needs to be defined for if_mtu... $ECHO_C" >&6
+if test "${ac_cv_IFNET_NEEDS_KERNEL+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x$ac_cv_struct_ifnet_has_if_mtu" = "xyes"; then
+  ac_cv_IFNET_NEEDS_KERNEL=no
+else
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#define _KERNEL 1
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_mtu = 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_IFNET_NEEDS_KERNEL=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_IFNET_NEEDS_KERNEL=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_IFNET_NEEDS_KERNEL" >&5
+echo "${ECHO_T}$ac_cv_IFNET_NEEDS_KERNEL" >&6
+
+if test "x$ac_cv_IFNET_NEEDS_KERNEL" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define IFNET_NEEDS_KERNEL 1
+_ACEOF
+
+fi
+fi
+
+
+
+ac_safe_struct=`echo "ifaddr" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ifa_next" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifaddr.ifa_next" >&5
+echo $ECHO_N "checking for ifaddr.ifa_next... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ifaddr testit;
+testit.ifa_next $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# Check ifnet entries using macro defined in aclocal.m4.
+#
+# XXX  Broken on FreeBSD where these are #define'd in <net/if.h>
+#
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_baudrate" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_baudrate" >&5
+echo $ECHO_N "checking for ifnet.if_baudrate... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_baudrate $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_baudrate.ifs_value" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_baudrate.ifs_value" >&5
+echo $ECHO_N "checking for ifnet.if_baudrate.ifs_value... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_baudrate.ifs_value $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_speed" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_speed" >&5
+echo $ECHO_N "checking for ifnet.if_speed... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_speed $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_type" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_type" >&5
+echo $ECHO_N "checking for ifnet.if_type... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_type $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_imcasts" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_imcasts" >&5
+echo $ECHO_N "checking for ifnet.if_imcasts... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_imcasts $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_iqdrops" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_iqdrops" >&5
+echo $ECHO_N "checking for ifnet.if_iqdrops... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_iqdrops $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_noproto" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_noproto" >&5
+echo $ECHO_N "checking for ifnet.if_noproto... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_noproto $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_omcasts" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_omcasts" >&5
+echo $ECHO_N "checking for ifnet.if_omcasts... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_omcasts $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_xname" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_xname" >&5
+echo $ECHO_N "checking for ifnet.if_xname... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "xno" = "x"; then
+  defineit="= 0"
+elif test "xno" = "xno"; then
+  defineit=""
+else
+  defineit="no"
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_xname $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_lastchange.tv_sec" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_lastchange.tv_sec" >&5
+echo $ECHO_N "checking for ifnet.if_lastchange.tv_sec... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_lastchange.tv_sec $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_obytes" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_obytes" >&5
+echo $ECHO_N "checking for ifnet.if_obytes... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_obytes $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_ibytes" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_ibytes" >&5
+echo $ECHO_N "checking for ifnet.if_ibytes... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_ibytes $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_addrlist" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_addrlist" >&5
+echo $ECHO_N "checking for ifnet.if_addrlist... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_addrlist $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_addrhead.tqh_first" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_addrhead.tqh_first" >&5
+echo $ECHO_N "checking for ifnet.if_addrhead.tqh_first... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_addrhead.tqh_first $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "udpstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "udps_discard" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for udpstat.udps_discard" >&5
+echo $ECHO_N "checking for udpstat.udps_discard... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+#if HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
+#if HAVE_NETINET_UDP_VAR_H
+#include <netinet/udp_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct udpstat testit;
+testit.udps_discard $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "udpstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "udps_noport" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for udpstat.udps_noport" >&5
+echo $ECHO_N "checking for udpstat.udps_noport... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+#if HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
+#if HAVE_NETINET_UDP_VAR_H
+#include <netinet/udp_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct udpstat testit;
+testit.udps_noport $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "udpstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "udps_noportbcast" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for udpstat.udps_noportbcast" >&5
+echo $ECHO_N "checking for udpstat.udps_noportbcast... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+#if HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
+#if HAVE_NETINET_UDP_VAR_H
+#include <netinet/udp_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct udpstat testit;
+testit.udps_noportbcast $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "udpstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "udps_fullsock" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for udpstat.udps_fullsock" >&5
+echo $ECHO_N "checking for udpstat.udps_fullsock... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+#if HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
+#if HAVE_NETINET_UDP_VAR_H
+#include <netinet/udp_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct udpstat testit;
+testit.udps_fullsock $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "arphd" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "at_next" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for arphd.at_next" >&5
+echo $ECHO_N "checking for arphd.at_next... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IF_ETHER_H
+#include <netinet/if_ether.h>
+#endif
+
+
+int
+main ()
+{
+
+struct arphd testit;
+testit.at_next $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "swdevt" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "sw_nblksenabled" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for swdevt.sw_nblksenabled" >&5
+echo $ECHO_N "checking for swdevt.sw_nblksenabled... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#if HAVE_SYS_CONF_H
+#include <sys/conf.h>
+#endif
+
+
+int
+main ()
+{
+
+struct swdevt testit;
+testit.sw_nblksenabled $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "statvfs" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "f_frsize" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for statvfs.f_frsize" >&5
+echo $ECHO_N "checking for statvfs.f_frsize... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#if HAVE_SYS_STATVFS_H
+#include <sys/statvfs.h>
+#endif
+
+
+int
+main ()
+{
+
+struct statvfs testit;
+testit.f_frsize $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "statvfs" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "f_files" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for statvfs.f_files" >&5
+echo $ECHO_N "checking for statvfs.f_files... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#if HAVE_SYS_STATVFS_H
+#include <sys/statvfs.h>
+#endif
+
+
+int
+main ()
+{
+
+struct statvfs testit;
+testit.f_files $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "statfs" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "f_files" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for statfs.f_files" >&5
+echo $ECHO_N "checking for statfs.f_files... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+
+
+int
+main ()
+{
+
+struct statfs testit;
+testit.f_files $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "statfs" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "f_ffree" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for statfs.f_ffree" >&5
+echo $ECHO_N "checking for statfs.f_ffree... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+
+
+int
+main ()
+{
+
+struct statfs testit;
+testit.f_ffree $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "statfs" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "f_favail" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for statfs.f_favail" >&5
+echo $ECHO_N "checking for statfs.f_favail... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+
+
+int
+main ()
+{
+
+struct statfs testit;
+testit.f_favail $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "nlist" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "n_value" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for nlist.n_value" >&5
+echo $ECHO_N "checking for nlist.n_value... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#if HAVE_NLIST_H
+#include <nlist.h>
+#endif
+
+
+int
+main ()
+{
+
+struct nlist testit;
+testit.n_value $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# check struct ipstat for various things
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_cantforward" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_cantforward" >&5
+echo $ECHO_N "checking for ipstat.ips_cantforward... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_cantforward $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_cantfrag" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_cantfrag" >&5
+echo $ECHO_N "checking for ipstat.ips_cantfrag... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_cantfrag $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_delivered" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_delivered" >&5
+echo $ECHO_N "checking for ipstat.ips_delivered... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_delivered $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_fragdropped" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_fragdropped" >&5
+echo $ECHO_N "checking for ipstat.ips_fragdropped... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_fragdropped $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_fragtimeout" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_fragtimeout" >&5
+echo $ECHO_N "checking for ipstat.ips_fragtimeout... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_fragtimeout $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_localout" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_localout" >&5
+echo $ECHO_N "checking for ipstat.ips_localout... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_localout $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_noproto" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_noproto" >&5
+echo $ECHO_N "checking for ipstat.ips_noproto... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_noproto $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_noroute" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_noroute" >&5
+echo $ECHO_N "checking for ipstat.ips_noroute... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_noroute $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_odropped" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_odropped" >&5
+echo $ECHO_N "checking for ipstat.ips_odropped... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_odropped $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_ofragments" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_ofragments" >&5
+echo $ECHO_N "checking for ipstat.ips_ofragments... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_ofragments $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_reassembled" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_reassembled" >&5
+echo $ECHO_N "checking for ipstat.ips_reassembled... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_reassembled $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# check for the des_ks_struct.weak_key attribute, which indicates the
+# older opensll version is being used.
+if test "x$ac_cv_header_openssl_des_h" = "xyes" ; then
+
+
+ac_safe_struct=`echo "des_ks_struct" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "weak_key" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for des_ks_struct.weak_key" >&5
+echo $ECHO_N "checking for des_ks_struct.weak_key... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <openssl/des.h>
+
+
+int
+main ()
+{
+
+struct des_ks_struct testit;
+testit.weak_key $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+fi
+
+# attempt to figure out if sysctl is usable
+
+if test $cross_compiling = yes; then
+  { echo "$as_me:$LINENO: WARNING: Can't check sysctl, manually define CAN_USE_SYSCTL if platform support available" >&5
+echo "$as_me: WARNING: Can't check sysctl, manually define CAN_USE_SYSCTL if platform support available" >&2;}
+else
+  echo "$as_me:$LINENO: checking if sysctl can read kernel information" >&5
+echo $ECHO_N "checking if sysctl can read kernel information... $ECHO_C" >&6
+if test "${ac_cv_CAN_USE_SYSCTL+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_CAN_USE_SYSCTL=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#if TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# if HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+#if HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+#include <sys/types.h>
+#if HAVE_SYS_SYSCTL_H
+# include <sys/sysctl.h>
+#endif
+
+main() {
+  int                 mib[2];
+  size_t              len;
+  struct timeval boottime;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_BOOTTIME;
+
+  len = sizeof(boottime);
+  sysctl(mib, 2, &boottime, &len, NULL, NULL);
+  if (boottime.tv_sec != 0)
+    exit(0);
+  else
+    exit(1);
+}
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_CAN_USE_SYSCTL=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_CAN_USE_SYSCTL=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_CAN_USE_SYSCTL" >&5
+echo "${ECHO_T}$ac_cv_CAN_USE_SYSCTL" >&6
+fi
+
+if test "x$ac_cv_CAN_USE_SYSCTL" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define CAN_USE_SYSCTL 1
+_ACEOF
+
+fi
+
+#
+# In FreeBSD 4.x, the TCP timer constants aren't.  They are defined
+# in terms of `hz', the kernel clock tick.  In this case,
+# we need to have a local variable `hz' in scope and set to a useful
+# value whenever we use one of these constants.
+#
+echo "$as_me:$LINENO: checking whether TCP timers depend on \`hz'" >&5
+echo $ECHO_N "checking whether TCP timers depend on \`hz'... $ECHO_C" >&6
+if test "${ac_cv_TCPTV_NEEDS_HZ+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <netinet/tcp_timer.h>
+TCPTV_SRTTDFLT
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "hz" >/dev/null 2>&1; then
+  ac_cv_TCPTV_NEEDS_HZ=yes
+else
+  ac_cv_TCPTV_NEEDS_HZ=no
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_TCPTV_NEEDS_HZ" >&5
+echo "${ECHO_T}$ac_cv_TCPTV_NEEDS_HZ" >&6
+
+if test "x$ac_cv_TCPTV_NEEDS_HZ" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define TCPTV_NEEDS_HZ 1
+_ACEOF
+
+fi
+
+#
+# define the agent libraries variable
+#
+
+
+
+
+#
+# Prompt for various bits of user information
+#
+
+if test "x$ac_cv_user_prompt_LOGFILE" = "x" -o "x$ac_cv_user_prompt_SYS_LOC" = "x" -o "x$ac_cv_user_prompt_SYS_CONTACT" = "x" -o "x$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" = "x"; then
+echo "$as_me:$LINENO: checking if you have run configure before" >&5
+echo $ECHO_N "checking if you have run configure before... $ECHO_C" >&6
+if test "${ac_cv_have_warned+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x$defaults" = "xno"; then
+cat << EOF
+
+	 ************** Configuration Section **************
+
+	You are about to be prompted with a series of questions.  Answer
+them carefully, as they determine how the SNMP agent and related
+applications are to function.
+
+	After the configure script finishes, you can browse the newly
+created config.h file for further - less important - parameters to
+modify.  Be careful if you re-run configure though, since config.h will
+be overwritten.
+
+-Press return to continue-
+EOF
+
+read tmpinput
+ac_cv_have_warned="yes"
+echo $ECHO_N "disabling above prompt for future runs...  $ECHO_C"
+else
+  ac_cv_have_warned="no"
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_have_warned" >&5
+echo "${ECHO_T}$ac_cv_have_warned" >&6
+else
+  ac_cv_have_warned="yes"
+fi
+
+ME=`$WHOAMI`
+if test -f /etc/resolv.conf; then
+  LOC=`cat /etc/resolv.conf | grep '^domain' | tail -1 | awk '{print $NF}'`
+else
+  LOC="@no.where"
+fi
+
+
+MSG_CHECK=`echo "
+
+*** Default SNMP Version:
+
+	Starting with Net-SNMP 5.0, you can choose the default version of
+the SNMP protocol to use when no version is given explicitly on the
+command line, or via an 'snmp.conf' file.  In the past this was set to
+SNMPv1, but you can use this to switch to SNMPv3 if desired.  SNMPv3
+will provide a more secure management environment (and thus you're
+encouraged to switch to SNMPv3), but may break existing scripts that
+rely on the old behaviour.  (Though such scripts will probably need to
+be changed to use the '-c' community flag anyway, as the SNMPv1
+command line usage has changed as well.).
+   At this prompt you can select \"1\", \"2\" (for SNMPv2c), or \"3\" as
+the default version for the command tools (snmpget, ...) to use.  This
+can always be overridden at runtime using the -v flag to the tools, or
+by using the \"defVersion\" token in your snmp.conf file.
+   Providing the --with-default-snmp-version=\"x\" parameter to ./configure
+will avoid this prompt.
+
+Default version of SNMP to use" | tail -1`
+echo "$as_me:$LINENO: checking $MSG_CHECK" >&5
+echo $ECHO_N "checking $MSG_CHECK... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_DEFAULT_SNMP_VERSION+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  echo "" >&6
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** Default SNMP Version:
+
+	Starting with Net-SNMP 5.0, you can choose the default version of
+the SNMP protocol to use when no version is given explicitly on the
+command line, or via an 'snmp.conf' file.  In the past this was set to
+SNMPv1, but you can use this to switch to SNMPv3 if desired.  SNMPv3
+will provide a more secure management environment (and thus you're
+encouraged to switch to SNMPv3), but may break existing scripts that
+rely on the old behaviour.  (Though such scripts will probably need to
+be changed to use the '-c' community flag anyway, as the SNMPv1
+command line usage has changed as well.).
+   At this prompt you can select \"1\", \"2\" (for SNMPv2c), or \"3\" as
+the default version for the command tools (snmpget, ...) to use.  This
+can always be overridden at runtime using the -v flag to the tools, or
+by using the \"defVersion\" token in your snmp.conf file.
+   Providing the --with-default-snmp-version=\"x\" parameter to ./configure
+will avoid this prompt.
+
+Default version of SNMP to use (3): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a "3" != ""; then
+  tmpinput="3"
+fi
+eval DEFAULT_SNMP_VERSION=\"$tmpinput\"
+else
+tmpinput="3"
+eval DEFAULT_SNMP_VERSION=\"$tmpinput\"
+fi
+
+
+eval ac_cv_user_prompt_DEFAULT_SNMP_VERSION=\$DEFAULT_SNMP_VERSION
+echo $ECHO_N "setting $MSG_CHECK to...  $ECHO_C" >&6
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_DEFAULT_SNMP_VERSION" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" >&6
+if test "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "none"; then
+  if test "xunquoted" = "xquoted" -o "xunquoted" = "xQUOTED"; then
+    cat >>confdefs.h <<_ACEOF
+#define DEFAULT_SNMP_VERSION "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION"
+_ACEOF
+
+  else
+    cat >>confdefs.h <<_ACEOF
+#define DEFAULT_SNMP_VERSION $ac_cv_user_prompt_DEFAULT_SNMP_VERSION
+_ACEOF
+
+  fi
+fi
+
+
+# we tested this above before the prompt, but the prompt may give a new value.
+if test "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "1" -a "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "2" -a "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "3"; then
+  { { echo "$as_me:$LINENO: error: Illegal version number.  Only 1, 2 (for SNMPv2c) and 3 are supported." >&5
+echo "$as_me: error: Illegal version number.  Only 1, 2 (for SNMPv2c) and 3 are supported." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+
+MSG_CHECK=`echo "
+
+*** System Contact Information:
+
+	Describes who should be contacted about the host the agent is
+running on.  This information is available in the MIB-II tree.  This
+can also be over-ridden using the \"syscontact\" syntax in the agent's
+configuration files.
+  Providing the --with-sys-contact=\"contact\" parameter to ./configure
+will avoid this prompt.
+
+System Contact Information" | tail -1`
+echo "$as_me:$LINENO: checking $MSG_CHECK" >&5
+echo $ECHO_N "checking $MSG_CHECK... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_SYS_CONTACT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  echo "" >&6
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** System Contact Information:
+
+	Describes who should be contacted about the host the agent is
+running on.  This information is available in the MIB-II tree.  This
+can also be over-ridden using the \"syscontact\" syntax in the agent's
+configuration files.
+  Providing the --with-sys-contact=\"contact\" parameter to ./configure
+will avoid this prompt.
+
+System Contact Information ($ME@$LOC): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a "$ME@$LOC" != ""; then
+  tmpinput="$ME@$LOC"
+fi
+eval SYS_CONTACT=\"$tmpinput\"
+else
+tmpinput="$ME@$LOC"
+eval SYS_CONTACT=\"$tmpinput\"
+fi
+
+
+eval ac_cv_user_prompt_SYS_CONTACT=\$SYS_CONTACT
+echo $ECHO_N "setting $MSG_CHECK to...  $ECHO_C" >&6
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_SYS_CONTACT" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_SYS_CONTACT" >&6
+if test "$ac_cv_user_prompt_SYS_CONTACT" != "none"; then
+  if test "xquoted" = "xquoted" -o "xquoted" = "xQUOTED"; then
+    cat >>confdefs.h <<_ACEOF
+#define SYS_CONTACT "$ac_cv_user_prompt_SYS_CONTACT"
+_ACEOF
+
+  else
+    cat >>confdefs.h <<_ACEOF
+#define SYS_CONTACT $ac_cv_user_prompt_SYS_CONTACT
+_ACEOF
+
+  fi
+fi
+
+
+
+MSG_CHECK=`echo "
+
+*** System Location:
+
+	Describes the location of the system.  This information is
+available in the MIB-II tree.  this can also be over-ridden using the
+\"syslocation\" syntax in the agent's configuration files.
+  Providing the --with-sys-location=\"location\" parameter to ./configure
+will avoid this prompt.
+
+System Location" | tail -1`
+echo "$as_me:$LINENO: checking $MSG_CHECK" >&5
+echo $ECHO_N "checking $MSG_CHECK... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_SYS_LOC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  echo "" >&6
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** System Location:
+
+	Describes the location of the system.  This information is
+available in the MIB-II tree.  this can also be over-ridden using the
+\"syslocation\" syntax in the agent's configuration files.
+  Providing the --with-sys-location=\"location\" parameter to ./configure
+will avoid this prompt.
+
+System Location (Unknown): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a "Unknown" != ""; then
+  tmpinput="Unknown"
+fi
+eval SYS_LOC=\"$tmpinput\"
+else
+tmpinput="Unknown"
+eval SYS_LOC=\"$tmpinput\"
+fi
+
+
+eval ac_cv_user_prompt_SYS_LOC=\$SYS_LOC
+echo $ECHO_N "setting $MSG_CHECK to...  $ECHO_C" >&6
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_SYS_LOC" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_SYS_LOC" >&6
+if test "$ac_cv_user_prompt_SYS_LOC" != "none"; then
+  if test "xquoted" = "xquoted" -o "xquoted" = "xQUOTED"; then
+    cat >>confdefs.h <<_ACEOF
+#define SYS_LOC "$ac_cv_user_prompt_SYS_LOC"
+_ACEOF
+
+  else
+    cat >>confdefs.h <<_ACEOF
+#define SYS_LOC $ac_cv_user_prompt_SYS_LOC
+_ACEOF
+
+  fi
+fi
+
+
+if test -d /var/log; then
+  defaultlog="/var/log/snmpd.log"
+else
+  defaultlog="/usr/adm/snmpd.log"
+fi
+
+
+MSG_CHECK=`echo "
+
+*** Logfile location:
+
+	Enter the default location for the snmpd agent to dump
+information & errors to.  If not defined (enter the keyword \"none\"
+at the prompt below) the agent will use stdout and stderr instead.
+(Note: This value can be over-ridden using command line options.)
+  Providing the --with-logfile=\"path\" parameter to ./configure
+will avoid this prompt.
+
+Location to write logfile" | tail -1`
+echo "$as_me:$LINENO: checking $MSG_CHECK" >&5
+echo $ECHO_N "checking $MSG_CHECK... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_LOGFILE+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  echo "" >&6
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** Logfile location:
+
+	Enter the default location for the snmpd agent to dump
+information & errors to.  If not defined (enter the keyword \"none\"
+at the prompt below) the agent will use stdout and stderr instead.
+(Note: This value can be over-ridden using command line options.)
+  Providing the --with-logfile=\"path\" parameter to ./configure
+will avoid this prompt.
+
+Location to write logfile ($defaultlog): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a "$defaultlog" != ""; then
+  tmpinput="$defaultlog"
+fi
+eval LOGFILE=\"$tmpinput\"
+else
+tmpinput="$defaultlog"
+eval LOGFILE=\"$tmpinput\"
+fi
+
+
+eval ac_cv_user_prompt_LOGFILE=\$LOGFILE
+echo $ECHO_N "setting $MSG_CHECK to...  $ECHO_C" >&6
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_LOGFILE" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_LOGFILE" >&6
+if test "$ac_cv_user_prompt_LOGFILE" != "none"; then
+  if test "xquoted" = "xquoted" -o "xquoted" = "xQUOTED"; then
+    cat >>confdefs.h <<_ACEOF
+#define LOGFILE "$ac_cv_user_prompt_LOGFILE"
+_ACEOF
+
+  else
+    cat >>confdefs.h <<_ACEOF
+#define LOGFILE $ac_cv_user_prompt_LOGFILE
+_ACEOF
+
+  fi
+fi
+
+
+if test -d /var; then
+  defaultstore="/var/net-snmp"
+  ucddefaultstore="/var/ucd-snmp"
+else
+  defaultstore="/etc/net-snmp"
+  ucddefaultstore="/etc/ucd-snmp"
+fi
+
+
+MSG_CHECK=`echo "
+
+*** snmpd persistent storage location:
+
+	Enter a directory for the SNMP library to store persistent
+data in the form of a configuration file.  This default location is
+different than the old default location (which was for ucd-snmp).  If
+you stay with the new path, I'll ask you in a second if you wish to
+copy your files over to the new location (once only).  If you pick
+some other path than the default, you'll have to copy them yourself.
+There is nothing wrong with picking the old path ($ucddefaultstore) if
+you'd rather.
+  Providing the --with-persistent-directory=\"path\" parameter to
+./configure will avoid this prompt.
+
+Location to write persistent information" | tail -1`
+echo "$as_me:$LINENO: checking $MSG_CHECK" >&5
+echo $ECHO_N "checking $MSG_CHECK... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_PERSISTENT_DIRECTORY+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  echo "" >&6
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** snmpd persistent storage location:
+
+	Enter a directory for the SNMP library to store persistent
+data in the form of a configuration file.  This default location is
+different than the old default location (which was for ucd-snmp).  If
+you stay with the new path, I'll ask you in a second if you wish to
+copy your files over to the new location (once only).  If you pick
+some other path than the default, you'll have to copy them yourself.
+There is nothing wrong with picking the old path ($ucddefaultstore) if
+you'd rather.
+  Providing the --with-persistent-directory=\"path\" parameter to
+./configure will avoid this prompt.
+
+Location to write persistent information ($defaultstore): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a "$defaultstore" != ""; then
+  tmpinput="$defaultstore"
+fi
+eval PERSISTENT_DIRECTORY=\"$tmpinput\"
+else
+tmpinput="$defaultstore"
+eval PERSISTENT_DIRECTORY=\"$tmpinput\"
+fi
+
+
+eval ac_cv_user_prompt_PERSISTENT_DIRECTORY=\$PERSISTENT_DIRECTORY
+echo $ECHO_N "setting $MSG_CHECK to...  $ECHO_C" >&6
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_PERSISTENT_DIRECTORY" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_PERSISTENT_DIRECTORY" >&6
+if test "$ac_cv_user_prompt_PERSISTENT_DIRECTORY" != "none"; then
+  if test "xquoted" = "xquoted" -o "xquoted" = "xQUOTED"; then
+    cat >>confdefs.h <<_ACEOF
+#define PERSISTENT_DIRECTORY "$ac_cv_user_prompt_PERSISTENT_DIRECTORY"
+_ACEOF
+
+  else
+    cat >>confdefs.h <<_ACEOF
+#define PERSISTENT_DIRECTORY $ac_cv_user_prompt_PERSISTENT_DIRECTORY
+_ACEOF
+
+  fi
+fi
+
+
+PERSISTENT_DIRECTORY=$ac_cv_user_prompt_PERSISTENT_DIRECTORY
+
+UCDPERSISTENT_DIRECTORY=$ucddefaultstore
+
+
+if test $PERSISTENT_DIRECTORY = "$defaultstore" -a -d "$ucddefaultstore" -a ! -d "$defaultstore" ; then
+echo "$as_me:$LINENO: checking If we should copy the old persistent directory" >&5
+echo $ECHO_N "checking If we should copy the old persistent directory... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_COPY_PERSISTENT_FILES+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** Copying old ucd-snmp persistent files to net-snmp persistent directory:
+
+	Would you like to copy the older ucd-snmp persistent files
+into your new net-snmp persistent file path?  This will functionally
+save all your ucd-snmp data and let it be used within the net-snmp
+tools.  This will only be done once when you run make install.  If you
+wish to do this, enter "yes" at the prompt.
+  Providing the --with-copy-persistent-files=\"no\" (or \"yes\")
+parameters to ./configure will avoid this prompt.
+
+Copy ucd-snmp data into the net-snmp data directory ("yes"): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a ""yes"" != ""; then
+  tmpinput=""yes""
+fi
+eval ac_cv_user_prompt_COPY_PERSISTENT_FILES=\"$tmpinput\"
+else
+tmpinput=""yes""
+eval ac_cv_user_prompt_COPY_PERSISTENT_FILES=\"$tmpinput\"
+fi
+
+
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_COPY_PERSISTENT_FILES" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_COPY_PERSISTENT_FILES" >&6
+else
+ac_cv_user_prompt_COPY_PERSISTENT_FILES="no"
+fi
+COPY_PERSISTENT_FILES="$ac_cv_user_prompt_COPY_PERSISTENT_FILES"
+
+
+
+
+          ac_config_files="$ac_config_files Makefile:Makefile.top:Makefile.in:Makefile.rules"
+
+          ac_config_files="$ac_config_files snmplib/Makefile:Makefile.top:snmplib/Makefile.in:Makefile.rules:snmplib/Makefile.depend"
+
+          ac_config_files="$ac_config_files apps/Makefile:Makefile.top:apps/Makefile.in:Makefile.rules:apps/Makefile.depend"
+
+          ac_config_files="$ac_config_files apps/snmpnetstat/Makefile:Makefile.top:apps/snmpnetstat/Makefile.in:Makefile.rules:apps/snmpnetstat/Makefile.depend"
+
+          ac_config_files="$ac_config_files agent/Makefile:Makefile.top:agent/Makefile.in:Makefile.rules:agent/Makefile.depend"
+
+          ac_config_files="$ac_config_files agent/helpers/Makefile:Makefile.top:agent/helpers/Makefile.in:Makefile.rules:agent/helpers/Makefile.depend"
+
+          ac_config_files="$ac_config_files agent/mibgroup/Makefile:Makefile.top:agent/mibgroup/Makefile.in:Makefile.rules:agent/mibgroup/Makefile.depend"
+
+          ac_config_files="$ac_config_files local/Makefile:Makefile.top:local/Makefile.in:Makefile.rules"
+
+          ac_config_files="$ac_config_files testing/Makefile:Makefile.top:testing/Makefile.in"
+
+          ac_config_files="$ac_config_files man/Makefile:Makefile.top:man/Makefile.in:Makefile.rules"
+
+          ac_config_files="$ac_config_files mibs/Makefile:Makefile.top:mibs/Makefile.in:Makefile.rules"
+
+          ac_config_files="$ac_config_files net-snmp-config:net-snmp-config.in"
+
+
+          ac_config_commands="$ac_config_commands default"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2>&1 |
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+        "s/'/'\\\\''/g;
+    	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+        "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
+    cat confcache >$cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[ 	]*VPATH[ 	]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[ 	]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[ 	]*$//;
+}'
+fi
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+         sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+
+# Support unset when possible.
+if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by Net-SNMP $as_me 5.1-pre1a, which was
+generated by GNU Autoconf 2.57.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+  --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration commands:
+$config_commands
+
+Report bugs to <bug-autoconf@gnu.org>."
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+Net-SNMP config.status 5.1-pre1a
+configured by $0, generated by GNU Autoconf 2.57,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
+Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=$srcdir
+INSTALL="$INSTALL"
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile:Makefile.top:Makefile.in:Makefile.rules" ;;
+  "snmplib/Makefile" ) CONFIG_FILES="$CONFIG_FILES snmplib/Makefile:Makefile.top:snmplib/Makefile.in:Makefile.rules:snmplib/Makefile.depend" ;;
+  "apps/Makefile" ) CONFIG_FILES="$CONFIG_FILES apps/Makefile:Makefile.top:apps/Makefile.in:Makefile.rules:apps/Makefile.depend" ;;
+  "apps/snmpnetstat/Makefile" ) CONFIG_FILES="$CONFIG_FILES apps/snmpnetstat/Makefile:Makefile.top:apps/snmpnetstat/Makefile.in:Makefile.rules:apps/snmpnetstat/Makefile.depend" ;;
+  "agent/Makefile" ) CONFIG_FILES="$CONFIG_FILES agent/Makefile:Makefile.top:agent/Makefile.in:Makefile.rules:agent/Makefile.depend" ;;
+  "agent/helpers/Makefile" ) CONFIG_FILES="$CONFIG_FILES agent/helpers/Makefile:Makefile.top:agent/helpers/Makefile.in:Makefile.rules:agent/helpers/Makefile.depend" ;;
+  "agent/mibgroup/Makefile" ) CONFIG_FILES="$CONFIG_FILES agent/mibgroup/Makefile:Makefile.top:agent/mibgroup/Makefile.in:Makefile.rules:agent/mibgroup/Makefile.depend" ;;
+  "local/Makefile" ) CONFIG_FILES="$CONFIG_FILES local/Makefile:Makefile.top:local/Makefile.in:Makefile.rules" ;;
+  "testing/Makefile" ) CONFIG_FILES="$CONFIG_FILES testing/Makefile:Makefile.top:testing/Makefile.in" ;;
+  "man/Makefile" ) CONFIG_FILES="$CONFIG_FILES man/Makefile:Makefile.top:man/Makefile.in:Makefile.rules" ;;
+  "mibs/Makefile" ) CONFIG_FILES="$CONFIG_FILES mibs/Makefile:Makefile.top:mibs/Makefile.in:Makefile.rules" ;;
+  "net-snmp-config" ) CONFIG_FILES="$CONFIG_FILES net-snmp-config:net-snmp-config.in" ;;
+  "default" ) CONFIG_COMMANDS="$CONFIG_COMMANDS default" ;;
+  "include/net-snmp/net-snmp-config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS include/net-snmp/net-snmp-config.h" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@CONFIGURE_OPTIONS@,$CONFIGURE_OPTIONS,;t t
+s,@LIBTOOLFLAGS@,$LIBTOOLFLAGS,;t t
+s,@INSTALL_PREFIX@,$INSTALL_PREFIX,;t t
+s,@MAINSUBS@,$MAINSUBS,;t t
+s,@HAVE_DMALLOC_H@,$HAVE_DMALLOC_H,;t t
+s,@WRAPLIBS@,$WRAPLIBS,;t t
+s,@installucdheaders@,$installucdheaders,;t t
+s,@installucdlibs@,$installucdlibs,;t t
+s,@CC@,$CC,;t t
+s,@CFLAGS@,$CFLAGS,;t t
+s,@LDFLAGS@,$LDFLAGS,;t t
+s,@CPPFLAGS@,$CPPFLAGS,;t t
+s,@ac_ct_CC@,$ac_ct_CC,;t t
+s,@EXEEXT@,$EXEEXT,;t t
+s,@OBJEXT@,$OBJEXT,;t t
+s,@CPP@,$CPP,;t t
+s,@EGREP@,$EGREP,;t t
+s,@build@,$build,;t t
+s,@build_cpu@,$build_cpu,;t t
+s,@build_vendor@,$build_vendor,;t t
+s,@build_os@,$build_os,;t t
+s,@host@,$host,;t t
+s,@host_cpu@,$host_cpu,;t t
+s,@host_vendor@,$host_vendor,;t t
+s,@host_os@,$host_os,;t t
+s,@LN_S@,$LN_S,;t t
+s,@ECHO@,$ECHO,;t t
+s,@RANLIB@,$RANLIB,;t t
+s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
+s,@STRIP@,$STRIP,;t t
+s,@ac_ct_STRIP@,$ac_ct_STRIP,;t t
+s,@LIBTOOL@,$LIBTOOL,;t t
+s,@LIBTOOL_DEPS@,$LIBTOOL_DEPS,;t t
+s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
+s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
+s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+s,@SET_MAKE@,$SET_MAKE,;t t
+s,@PSPROG@,$PSPROG,;t t
+s,@PERLPROG@,$PERLPROG,;t t
+s,@WHOAMI@,$WHOAMI,;t t
+s,@SED@,$SED,;t t
+s,@AUTOCONF@,$AUTOCONF,;t t
+s,@AUTOHEADER@,$AUTOHEADER,;t t
+s,@UNAMEPROG@,$UNAMEPROG,;t t
+s,@VERSION@,$VERSION,;t t
+s,@RELEASEVERSION@,$RELEASEVERSION,;t t
+s,@DEVFLAGS@,$DEVFLAGS,;t t
+s,@target@,$target,;t t
+s,@target_cpu@,$target_cpu,;t t
+s,@target_vendor@,$target_vendor,;t t
+s,@target_os@,$target_os,;t t
+s,@CCPATH@,$CCPATH,;t t
+s,@EXTRACPPFLAGS@,$EXTRACPPFLAGS,;t t
+s,@SNMPCONFPATH@,$SNMPCONFPATH,;t t
+s,@transport_hdr_list@,$transport_hdr_list,;t t
+s,@transport_src_list@,$transport_src_list,;t t
+s,@security_src_list@,$security_src_list,;t t
+s,@security_hdr_list@,$security_hdr_list,;t t
+s,@MODULE_LIST@,$MODULE_LIST,;t t
+s,@module_list_c@,$module_list_c,;t t
+s,@module_list_h@,$module_list_h,;t t
+s,@module_list_o@,$module_list_o,;t t
+s,@module_list_lo@,$module_list_lo,;t t
+s,@mibgroup_list_o@,$mibgroup_list_o,;t t
+s,@mibgroup_list_lo@,$mibgroup_list_lo,;t t
+s,@module_list@,$module_list,;t t
+s,@default_mibs_install@,$default_mibs_install,;t t
+s,@PERLTARGS@,$PERLTARGS,;t t
+s,@PERLINSTALLTARGS@,$PERLINSTALLTARGS,;t t
+s,@PERLUNINSTALLTARGS@,$PERLUNINSTALLTARGS,;t t
+s,@PERLARGS@,$PERLARGS,;t t
+s,@EMBEDPERLINSTALL@,$EMBEDPERLINSTALL,;t t
+s,@EMBEDPERLUNINSTALL@,$EMBEDPERLUNINSTALL,;t t
+s,@LPSTAT_PATH@,$LPSTAT_PATH,;t t
+s,@PSCMD@,$PSCMD,;t t
+s,@ALLOCA@,$ALLOCA,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@AGENTLIBS@,$AGENTLIBS,;t t
+s,@OTHERAGENTLIBOBJS@,$OTHERAGENTLIBOBJS,;t t
+s,@OTHERAGENTLIBLOBJS@,$OTHERAGENTLIBLOBJS,;t t
+s,@PERSISTENT_DIRECTORY@,$PERSISTENT_DIRECTORY,;t t
+s,@UCDPERSISTENT_DIRECTORY@,$UCDPERSISTENT_DIRECTORY,;t t
+s,@COPY_PERSISTENT_FILES@,$COPY_PERSISTENT_FILES,;t t
+s,@DLLIBS@,$DLLIBS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+  	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+  	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+        cat >$tmp/stdin
+        ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$ac_file" : 'X\(//\)[^/]' \| \
+         X"$ac_file" : 'X\(//\)$' \| \
+         X"$ac_file" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$as_dir" : 'X\(//\)[^/]' \| \
+         X"$as_dir" : 'X\(//\)$' \| \
+         X"$as_dir" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
+# absolute.
+ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
+ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
+ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
+ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+                                     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+         # Absolute (can't be DOS-style, as IFS=:)
+         test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         echo $f;;
+      *) # Relative
+         if test -f "$f"; then
+           # Build tree
+           echo $f
+         elif test -f "$srcdir/$f"; then
+           # Source tree
+           echo $srcdir/$f
+         else
+           # /dev/null tree
+           { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+  # Run the commands associated with the file.
+  case $ac_file in
+    net-snmp-config ) chmod +x net-snmp-config ;;
+  esac
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_HEADER section.
+#
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s,^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
+ac_dB='[ 	].*$,\1#\2'
+ac_dC=' '
+ac_dD=',;t'
+# ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_uA='s,^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_uB='$,\1#\2define\3'
+ac_uC=' '
+ac_uD=',;t'
+
+for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+        cat >$tmp/stdin
+        ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  test x"$ac_file" != x- && { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+         # Absolute (can't be DOS-style, as IFS=:)
+         test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         echo $f;;
+      *) # Relative
+         if test -f "$f"; then
+           # Build tree
+           echo $f
+         elif test -f "$srcdir/$f"; then
+           # Source tree
+           echo $srcdir/$f
+         else
+           # /dev/null tree
+           { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  # Remove the trailing spaces.
+  sed 's/[ 	]*$//' $ac_file_inputs >$tmp/in
+
+_ACEOF
+
+# Transform confdefs.h into two sed scripts, `conftest.defines' and
+# `conftest.undefs', that substitutes the proper values into
+# config.h.in to produce config.h.  The first handles `#define'
+# templates, and the second `#undef' templates.
+# And first: Protect against being on the right side of a sed subst in
+# config.status.  Protect against being in an unquoted here document
+# in config.status.
+rm -f conftest.defines conftest.undefs
+# Using a here document instead of a string reduces the quoting nightmare.
+# Putting comments in sed scripts is not portable.
+#
+# `end' is used to avoid that the second main sed command (meant for
+# 0-ary CPP macros) applies to n-ary macro definitions.
+# See the Autoconf documentation for `clear'.
+cat >confdef2sed.sed <<\_ACEOF
+s/[\\&,]/\\&/g
+s,[\\$`],\\&,g
+t clear
+: clear
+s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	(][^ 	(]*\)\(([^)]*)\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
+t end
+s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	][^ 	]*\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
+: end
+_ACEOF
+# If some macros were called several times there might be several times
+# the same #defines, which is useless.  Nevertheless, we may not want to
+# sort them, since we want the *last* AC-DEFINE to be honored.
+uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines
+sed 's/ac_d/ac_u/g' conftest.defines >conftest.undefs
+rm -f confdef2sed.sed
+
+# This sed command replaces #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+cat >>conftest.undefs <<\_ACEOF
+s,^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
+_ACEOF
+
+# Break up conftest.defines because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
+echo '  if grep "^[ 	]*#[ 	]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
+echo '  :' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.defines >/dev/null
+do
+  # Write a limited-size here document to $tmp/defines.sed.
+  echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#define' lines.
+  echo '/^[ 	]*#[ 	]*define/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/defines.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail
+  rm -f conftest.defines
+  mv conftest.tail conftest.defines
+done
+rm -f conftest.defines
+echo '  fi # grep' >>$CONFIG_STATUS
+echo >>$CONFIG_STATUS
+
+# Break up conftest.undefs because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #undef templates' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.undefs >/dev/null
+do
+  # Write a limited-size here document to $tmp/undefs.sed.
+  echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#undef'
+  echo '/^[ 	]*#[ 	]*undef/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/undefs.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.undefs >conftest.tail
+  rm -f conftest.undefs
+  mv conftest.tail conftest.undefs
+done
+rm -f conftest.undefs
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    echo "/* Generated by configure.  */" >$tmp/config.h
+  else
+    echo "/* $ac_file.  Generated by configure.  */" >$tmp/config.h
+  fi
+  cat $tmp/in >>$tmp/config.h
+  rm -f $tmp/in
+  if test x"$ac_file" != x-; then
+    if diff $ac_file $tmp/config.h >/dev/null 2>&1; then
+      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$ac_file" : 'X\(//\)[^/]' \| \
+         X"$ac_file" : 'X\(//\)$' \| \
+         X"$ac_file" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+      { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$as_dir" : 'X\(//\)[^/]' \| \
+         X"$as_dir" : 'X\(//\)$' \| \
+         X"$as_dir" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+      rm -f $ac_file
+      mv $tmp/config.h $ac_file
+    fi
+  else
+    cat $tmp/config.h
+    rm -f $tmp/config.h
+  fi
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_COMMANDS section.
+#
+for ac_file in : $CONFIG_COMMANDS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+  ac_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$ac_dest" : 'X\(//\)[^/]' \| \
+         X"$ac_dest" : 'X\(//\)$' \| \
+         X"$ac_dest" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
+# absolute.
+ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
+ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
+ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
+ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+
+  { echo "$as_me:$LINENO: executing $ac_dest commands" >&5
+echo "$as_me: executing $ac_dest commands" >&6;}
+  case $ac_dest in
+    default ) echo timestamp > stamp-h ;;
+  esac
+done
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
+
+
+  echo ""
+  echo "---------------------------------------------------------"
+  echo "            Net-SNMP configuration summary:"
+  echo "---------------------------------------------------------"
+  echo ""
+  cat configure-summary
+  echo ""
+  echo "---------------------------------------------------------"
+  echo ""
+
+# Local Variables:
+# mode: Autoconf
+# comment-start: "#"
+# End:
diff -Naur net-snmp-5.1/configure_2MB_pkg open_snmp/configure_2MB_pkg
--- net-snmp-5.1/configure_2MB_pkg	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/configure_2MB_pkg	2009-12-16 13:00:12.000000000 +0530
@@ -0,0 +1 @@
+./configure '--host=mips-hardhat-linux' CC=mips-linux-gcc 'CFLAGS=-Os -mips2 -mtune=r4600 -DHAVE_MINIMAL_LIBSUPPORT -DHAVE_MINIMAL_HELPERS -DHAVE_OPTIMIZED_CODE' '--with-endianness=big' 'CPP=mips-linux-cpp' 'host_alias=mips-hardhat-linux' --disable-debugging --disable-mib-loading --enable-mini-agent --without-kmem-usage --with-mib-modules="mibII mibII/interfaces" --with-out-mib-modules="adslMIB snmpv3mibs agentx utilities agent_mibs ucd_snmp notification target" --with-default-snmp-version=1 --with-transports="AAL5PVC UDP" --enable-internal-md5=no  --with-out-security-modules="usm ksm" --with-out-transports="Callback UDPIPv6 TCPIPv6 TCP Unix IPX" --disable-manuals --disable-scripts --disable-applications --disable-mibs --disable-privacy '--enable-shared=no' '--enable-static' --prefix=  --with-install-prefix=${BUILD_ROOTFS_DIR}usr --with-sys-contact="root@infineon" --with-logfile="/var/log/snmpd.log" --with-copy-persistent-files="no" --with-persistent-directory="/var/net-snmp" --with-sys-location="/"
diff -Naur net-snmp-5.1/configure_2MB_pkg_cpeDSLMIB open_snmp/configure_2MB_pkg_cpeDSLMIB
--- net-snmp-5.1/configure_2MB_pkg_cpeDSLMIB	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/configure_2MB_pkg_cpeDSLMIB	2009-12-16 13:00:12.000000000 +0530
@@ -0,0 +1 @@
+./configure '--host=mips-hardhat-linux' CC=mips-linux-gcc 'CFLAGS=-Os -mips2 -mtune=r4600 -DHAVE_MINIMAL_LIBSUPPORT -DHAVE_MINIMAL_HELPERS -DHAVE_OPTIMIZED_CODE' '--with-endianness=big' 'CPP=mips-linux-cpp' 'host_alias=mips-hardhat-linux' --disable-debugging --disable-mib-loading --enable-mini-agent --without-kmem-usage --with-mib-modules="mibII mibII/interfaces CPE-DSL-MIB" --with-out-mib-modules="adslMIB snmpv3mibs agentx utilities agent_mibs ucd_snmp notification target" --with-default-snmp-version=1 --with-transports="AAL5PVC UDP" --enable-internal-md5=no  --with-out-security-modules="usm ksm" --with-out-transports="Callback UDPIPv6 TCPIPv6 TCP Unix IPX" --disable-manuals --disable-scripts --disable-applications --disable-mibs --disable-privacy '--enable-shared=no' '--enable-static' --prefix=  --with-install-prefix=${BUILD_ROOTFS_DIR}usr --with-sys-contact="root@infineon" --with-logfile="/var/log/snmpd.log" --with-copy-persistent-files="no" --with-persistent-directory="/var/net-snmp" --with-sys-location="/"
diff -Naur net-snmp-5.1/configure_full open_snmp/configure_full
--- net-snmp-5.1/configure_full	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/configure_full	2009-12-16 13:00:13.000000000 +0530
@@ -0,0 +1,27660 @@
+#! /bin/sh
+# From configure.in Revision: 5.64 .
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.57 for Net-SNMP 5.1-pre1a.
+#
+# Report bugs to <net-snmp-coders@lists.sourceforge.net>.
+#
+# Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
+# Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+. sysconfig.sh
+. config.sh
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+
+# Support unset when possible.
+if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Find the correct PATH separator.  Usually this is `:', but
+# DJGPP uses `;' like DOS.
+if test "X${PATH_SEPARATOR+set}" != Xset; then
+  UNAME=${UNAME-`uname 2>/dev/null`}
+  case X$UNAME in
+    *-DOS) lt_cv_sys_path_separator=';' ;;
+    *)     lt_cv_sys_path_separator=':' ;;
+  esac
+  PATH_SEPARATOR=$lt_cv_sys_path_separator
+fi
+
+
+# Check that we are running under the correct shell.
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+case X$ECHO in
+X*--fallback-echo)
+  # Remove one level of quotation (which was required for Make).
+  ECHO=`echo "$ECHO" | sed 's,\\\\\$\\$0,'$0','`
+  ;;
+esac
+
+echo=${ECHO-echo}
+if test "X$1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X$1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`($echo '\t') 2>/dev/null`" = 'X\t'; then
+  # Yippee, $echo works!
+  :
+else
+  # Restart under the correct shell.
+  exec $SHELL "$0" --no-reexec ${1+"$@"}
+fi
+
+if test "X$1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<EOF
+
+EOF
+  exit 0
+fi
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+if test "X${CDPATH+set}" = Xset; then CDPATH=:; export CDPATH; fi
+
+if test -z "$ECHO"; then
+if test "X${echo_test_string+set}" != Xset; then
+# find a string as large as possible, as long as the shell can cope with it
+  for cmd in 'sed 50q "$0"' 'sed 20q "$0"' 'sed 10q "$0"' 'sed 2q "$0"' 'echo test'; do
+    # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...
+    if (echo_test_string="`eval $cmd`") 2>/dev/null &&
+       echo_test_string="`eval $cmd`" &&
+       (test "X$echo_test_string" = "X$echo_test_string") 2>/dev/null
+    then
+      break
+    fi
+  done
+fi
+
+if test "X`($echo '\t') 2>/dev/null`" = 'X\t' &&
+   echo_testing_string=`($echo "$echo_test_string") 2>/dev/null` &&
+   test "X$echo_testing_string" = "X$echo_test_string"; then
+  :
+else
+  # The Solaris, AIX, and Digital Unix default echo programs unquote
+  # backslashes.  This makes it impossible to quote backslashes using
+  #   echo "$something" | sed 's/\\/\\\\/g'
+  #
+  # So, first we look for a working echo in the user's PATH.
+
+  IFS="${IFS= 	}"; save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for dir in $PATH /usr/ucb; do
+    if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&
+       test "X`($dir/echo '\t') 2>/dev/null`" = 'X\t' &&
+       echo_testing_string=`($dir/echo "$echo_test_string") 2>/dev/null` &&
+       test "X$echo_testing_string" = "X$echo_test_string"; then
+      echo="$dir/echo"
+      break
+    fi
+  done
+  IFS="$save_ifs"
+
+  if test "X$echo" = Xecho; then
+    # We didn't find a better echo, so look for alternatives.
+    if test "X`(print -r '\t') 2>/dev/null`" = 'X\t' &&
+       echo_testing_string=`(print -r "$echo_test_string") 2>/dev/null` &&
+       test "X$echo_testing_string" = "X$echo_test_string"; then
+      # This shell has a builtin print -r that does the trick.
+      echo='print -r'
+    elif (test -f /bin/ksh || test -f /bin/ksh$ac_exeext) &&
+	 test "X$CONFIG_SHELL" != X/bin/ksh; then
+      # If we have ksh, try running configure again with it.
+      ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+      export ORIGINAL_CONFIG_SHELL
+      CONFIG_SHELL=/bin/ksh
+      export CONFIG_SHELL
+      exec $CONFIG_SHELL "$0" --no-reexec ${1+"$@"}
+    else
+      # Try using printf.
+      echo='printf %s\n'
+      if test "X`($echo '\t') 2>/dev/null`" = 'X\t' &&
+	 echo_testing_string=`($echo "$echo_test_string") 2>/dev/null` &&
+	 test "X$echo_testing_string" = "X$echo_test_string"; then
+	# Cool, printf works
+	:
+      elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
+	   test "X$echo_testing_string" = 'X\t' &&
+	   echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	   test "X$echo_testing_string" = "X$echo_test_string"; then
+	CONFIG_SHELL=$ORIGINAL_CONFIG_SHELL
+	export CONFIG_SHELL
+	SHELL="$CONFIG_SHELL"
+	export SHELL
+	echo="$CONFIG_SHELL $0 --fallback-echo"
+      elif echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
+	   test "X$echo_testing_string" = 'X\t' &&
+	   echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	   test "X$echo_testing_string" = "X$echo_test_string"; then
+	echo="$CONFIG_SHELL $0 --fallback-echo"
+      else
+	# maybe with a smaller string...
+	prev=:
+
+	for cmd in 'echo test' 'sed 2q "$0"' 'sed 10q "$0"' 'sed 20q "$0"' 'sed 50q "$0"'; do
+	  if (test "X$echo_test_string" = "X`eval $cmd`") 2>/dev/null
+	  then
+	    break
+	  fi
+	  prev="$cmd"
+	done
+
+	if test "$prev" != 'sed 50q "$0"'; then
+	  echo_test_string=`eval $prev`
+	  export echo_test_string
+	  exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} "$0" ${1+"$@"}
+	else
+	  # Oops.  We lost completely, so just stick with echo.
+	  echo=echo
+	fi
+      fi
+    fi
+  fi
+fi
+fi
+
+# Copy echo and quote the copy suitably for passing to libtool from
+# the Makefile, instead of quoting the original, which is used later.
+ECHO=$echo
+if test "X$ECHO" = "X$CONFIG_SHELL $0 --fallback-echo"; then
+   ECHO="$CONFIG_SHELL \\\$\$0 --fallback-echo"
+fi
+
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+exec 6>&1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME='Net-SNMP'
+PACKAGE_TARNAME='net-snmp'
+PACKAGE_VERSION='5.1-pre1a'
+PACKAGE_STRING='Net-SNMP 5.1-pre1a'
+PACKAGE_BUGREPORT='net-snmp-coders@lists.sourceforge.net'
+
+ac_unique_file="agent/mibgroup/ucd-snmp/extensible.c"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# if HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#if HAVE_STRING_H
+# if !STDC_HEADERS && HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#if HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#if HAVE_INTTYPES_H
+# include <inttypes.h>
+#else
+# if HAVE_STDINT_H
+#  include <stdint.h>
+# endif
+#endif
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CONFIGURE_OPTIONS LIBTOOLFLAGS INSTALL_PREFIX MAINSUBS HAVE_DMALLOC_H WRAPLIBS installucdheaders installucdlibs CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP EGREP build build_cpu build_vendor build_os host host_cpu host_vendor host_os LN_S ECHO RANLIB ac_ct_RANLIB STRIP ac_ct_STRIP LIBTOOL LIBTOOL_DEPS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA SET_MAKE PSPROG PERLPROG WHOAMI SED AUTOCONF AUTOHEADER UNAMEPROG VERSION RELEASEVERSION DEVFLAGS target target_cpu target_vendor target_os CCPATH EXTRACPPFLAGS SNMPCONFPATH transport_hdr_list transport_src_list security_src_list security_hdr_list MODULE_LIST module_list_c module_list_h module_list_o module_list_lo mibgroup_list_o mibgroup_list_lo module_list default_mibs_install PERLTARGS PERLINSTALLTARGS PERLUNINSTALLTARGS PERLARGS EMBEDPERLINSTALL EMBEDPERLUNINSTALL LPSTAT_PATH PSCMD ALLOCA LIBOBJS AGENTLIBS OTHERAGENTLIBOBJS OTHERAGENTLIBLOBJS PERSISTENT_DIRECTORY UCDPERSISTENT_DIRECTORY COPY_PERSISTENT_FILES DLLIBS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+              localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$0" : 'X\(//\)[^/]' \| \
+         X"$0" : 'X\(//\)$' \| \
+         X"$0" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+ac_env_CC_set=${CC+set}
+ac_env_CC_value=$CC
+ac_cv_env_CC_set=${CC+set}
+ac_cv_env_CC_value=$CC
+ac_env_CFLAGS_set=${CFLAGS+set}
+ac_env_CFLAGS_value=$CFLAGS
+ac_cv_env_CFLAGS_set=${CFLAGS+set}
+ac_cv_env_CFLAGS_value=$CFLAGS
+ac_env_LDFLAGS_set=${LDFLAGS+set}
+ac_env_LDFLAGS_value=$LDFLAGS
+ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
+ac_cv_env_LDFLAGS_value=$LDFLAGS
+ac_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_env_CPPFLAGS_value=$CPPFLAGS
+ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_cv_env_CPPFLAGS_value=$CPPFLAGS
+ac_env_CPP_set=${CPP+set}
+ac_env_CPP_value=$CPP
+ac_cv_env_CPP_set=${CPP+set}
+ac_cv_env_CPP_value=$CPP
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures Net-SNMP 5.1-pre1a to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat <<_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat <<\_ACEOF
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+  case $ac_init_help in
+     short | recursive ) echo "Configuration of Net-SNMP 5.1-pre1a:";;
+   esac
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-silent-libtool         Pass --silent to libtool.
+  --enable-mini-agent             Build a minimal agent.
+  --disable-agent                 Do not build the agent (snmpd).
+  --disable-applications          Do not build the apps (snmpget, ...).
+  --disable-manuals               Do not install the manuals.
+  --disable-scripts               Do not install the scripts (mib2c, ...).
+  --disable-mibs                  Do not install the mib files.
+  --disable-mib-loading            Do not include code that parses and
+                                   manipulates the mib files.
+  --enable-ipv6                   Generate IPv6 ready version.
+  --enable-local-smux             Restrict SMUX connections to localhost (by default).
+  --enable-debugging              Outputs extra debugging information at all
+                                  times.  Normally, you should not enable this,
+                                  but instead use the -D flag of the commands,
+                                  which toggles debbuging output at runtime.
+  --disable-debugging             Disallows debugging code to be built in.
+                                  This might provide some speed benefits.
+  --enable-developer              Turns on super-duper-extra-compile-warnings
+                                  when using gcc.
+  --disable-privacy               Don't compile in support for privacy.
+  --enable-internal-md5           Use the internal MD5 support.
+  --enable-testing-code           Enables some code sections that should
+                                  only be used for testing of certain
+                                  SNMP functionalities.  This should *not*
+                                  be turned on for production use.  Ever.
+  --enable-reentrant              Enables locking functions that protect
+                                  library resources in some multi-threading
+                                  environments.  This does not guarantee
+                                  thread-safe operation.
+                                  Currently an experimental setting.
+
+  --enable-embedded-perl          Embed perl in the SNMP agent.
+                                  forces --with-perl-modules as well.
+
+--enable-ucd-snmp-compatibility  Install ucd-snmp look-alike headers and libs.
+  --enable-shared=PKGS  build shared libraries default=yes
+  --enable-static=PKGS  build static libraries default=yes
+  --enable-fast-install=PKGS  optimize for fast installation default=yes
+  --disable-libtool-lock  avoid locking (might break parallel builds)
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+
+Compiler Options:
+  --with-cc=CC                    use CC to compile (default=gcc).
+  --with-ar=AR                    use AR as the archiver.
+  --with-endianness=big|little    define endianness of target platform when
+                                  cross-compiling.
+  --with-cflags=CFLAGS            use CFLAGS as compile time arguments.
+  --with-ldflags=LDFLAGS          use LDFLAGS as link time arguments to ld.
+  --with-libs=LIBS                use LIBS as link time arguments to ld.
+  --with-install-prefix=PATH      Just for installing, prefix all
+                                  directories with PATH.  This is known not
+                                  to work on some systems with shared
+                                  libraries (eg, HPUX)
+  --with-dmalloc=PATH             Use dmalloc library (www.dmalloc.com)
+  --with-efence                   Look for and use libefence (malloc).
+  --with-rsaref=PATH              Look for librsaref in PATH/lib.
+  --with-openssl=PATH             Look for openssl in PATH/lib.
+  --without-rpm                  Don't include support for the RPM package
+                                 management system when building the host MIB
+                                 module.
+  --without-opaque-special-types  Don't use special opaque encodings.
+                                  SNMP normally cannot handle
+                                  floating numbers, nor large 64 bit
+                                  integers well.  By default, the
+                                  net-snmp package compiles in
+                                  support for these extra datatypes
+                                  (in a legal way)
+  --with-mibdirs=\"dir1:dir2:\"     Default directories to look for mibs.
+                                    (Default: \$HOME/.snmp/mibs:DATADIR/snmp/mibs)
+  --with-mibs=\"item1:item2:\"      Default mib IDs to read.
+                                    (The default list is \"IP-MIB:IF-MIB:
+                                    TCP-MIB:UDP-MIB:SNMPv2-MIB:RFC1213-MIB\"
+                                    with the addition of any mibs used
+                                    by the mib modules the agent is
+                                    configured with)
+  --with-mibfiles=\"file1:file2\"   Default mib files to load.
+                                    (Default:  none.  uses IDs above instead.)
+
+Configuring the agent:
+  --without-root-access           The snmpd agent won't require root access to
+                                  run it.  The information it returns in the
+                                  mib-II tree may not be correct, however.
+
+Configuring the agent:
+  --without-kmem-usage            Do not include any code related to the use
+                                  of kmem. This option can only be used with
+                                  the option --enable-mini-agent.
+  --with-dummy-values             Provide 'placeholder' dummy values where
+                                  the necessary information is not available.
+                                  This is technically not compliant with the
+                                  SNMP specifications, but was how the agent
+                                  operated for versions < 4.0.
+  --with-persistent-directory=\"directory\"
+                                  Default directory for persistent data storage.
+  --with-copy-persistent-files=\"no\" Don't copy persistent files
+                                       (or use \"yes\" to copy them).
+                                       (Default: yes)
+  --with-default-snmp-version=\"3\" Default version of SNMP to use.
+                                  (Default: 3)
+                                  Legal values: 1, 2 (for SNMPv2c) or 3.
+  --with-sys-contact=\"who@where\"  Default system contact.
+                                    (Default: LOGIN@DOMAINNAME)
+  --with-sys-location=\"location\"  Default system location.
+                                    (Default: Unknown)
+  --with-logfile=\"location\"       Default log file location for snmpd.
+  --with-transports=\"t1 t2 ...\"   Compile in the given SNMP transport
+                                    modules (space separated list).
+  --with-out-transports=\"t1 ...\"  Exclude listed SNMP transports
+                                    (space separated list).
+
+  Available SNMP transport modules are:
+
+    UDP         support for SNMP over UDP/IP.
+                This transport is always compiled in.
+    UDPIPv6     support for SNMP over UDP/IPv6.
+                This transport is available for Linux, Solaris and
+                FreeBSD.
+                It is never compiled in by default.
+    TCPIPv6     support for SNMP over UDP/IPv6.
+                This transport is available for Linux, Solaris and
+                FreeBSD.
+                It is never compiled in by default.
+    TCP         support for SNMP over TCP/IP.
+                This transport is compiled in by default, but may be omitted.
+    Unix        support for SNMP over Unix domain protocols.
+                This transport is compiled in by default except on Win32
+                platforms, and may be omitted.
+    Callback    support for SNMP over an internal locally connected pair
+                of snmp_sessions.
+    AAL5PVC     support for SNMP over AAL5 PVCs.
+                This transport is presently only available for Linux,
+                is never compiled in by default and may be omitted.
+    IPX         support for SNMP over IPX per RFC 1420.
+                This transport is presently only available for Linux,
+                is never compiled in by default and may be omitted.
+
+
+  --with-security-modules=\"s1 s2 ...\"   Compile in the given SNMP security
+                                    module services (space separated list).
+
+  Available SNMP security services:
+
+        usm                support for user based SNMP security
+                           (required and always compiled in)
+        ksm                support for kerberos based SNMP security
+
+  --with-mib-modules=\"item1 ...\"  Compile with additional mib modules
+                                    (Space separated list).
+  --with-out-mib-modules=\"list\"   Compile without these mib modules.
+
+  Default mib modules compiled into the agent (which can be removed):
+
+    mibII                  support for the mib-II tree.
+    snmpv3mibs             support for the snmpv3 mib modules.
+    ucd_snmp               UCD-SNMP-MIB specific extensions.
+    agent_mibs             NET-SNMP-AGENT-MIB extensions
+    agentx                 (see below)
+    notification           mibs supporting specification of trap destinations.
+    target                 Support for the SNMP WGs TARGET-MIB.
+    utilities              general agent configuration utilities.
+
+  Optional mib modules that can be built into the agent include:
+    host                   host resources mib support.
+    disman/event-mib       support for the DISMAN-EVENT-MIB (beta)
+                             (supports self monitoring and notification
+                              delivery when error conditions are found)
+    smux                   smux support to allow subagents to attach to snmpd.
+    mibII/mta_sendmail     Sendmail statistics monitoring (MTA-MIB)
+    misc/ipfwacc           accounting rules IP firewall information (linux).
+    ipfwchains/ipfwchains  firewall chains under ipfw for linux.
+                           (Download separately from the ucd-snmp ftp site.)
+    ucd-snmp/diskio        Table of io-devices and how much data they have
+                           read/written.  (only tested on Solaris, Linux)
+    tunnel                 Linux TUNNEL-MIB support (ifTable extension)
+
+  AgentX support:
+    agentx/subagent        allows the agent to run as either a snmp agent
+                           or as an agentX sub-agent.
+    agentx/master          makes the agent run as an agentX master agent
+                           as well as a normal snmp agent.
+    agentx                 includes both agentx/master and agentx/client.
+
+  Optional modules for C coders to look at and/or include as extension examples:
+
+    examples/ucdDemoPublic  SNMPv3 interoperability testing mib.
+    examples/example        example C code extension.
+Enterprise OIDs:  (warning: this should be used with caution.)
+
+  --with-enterprise-oid              The enterprise number assigned to the
+                                     vendor by IANA.  See
+                                     http://www.iana.org/cgi-bin/enterprise.pl
+                                     to get one, though using the default is
+                                     probably the right choice is most cases.
+                                     (default 8072 = "enterprise.net-snmp")
+
+  --with-enterprise-sysoid           The base OID for the sysObjectID
+                                     of the system group
+                                     (default .1.3.6.1.4.1.8072.3.2... =
+                                      "netSnmpAgentOIDs...")
+
+  --with-enterprise-notification-oid The OID used for the root of
+				     enterprise specific notifications.
+                                     (default .1.3.6.1.4.1.2021 = "enterprise.ucdavis")
+
+Perl:
+  --with-perl-modules=ARGS      Install the perl modules along with the rest
+                                  of the net-snmp toolkit.  If ARGS is
+                                  specified, they're passed to the
+                                  Makefile.PL script.
+
+Miscellaneous:
+  --with-defaults          Use defaults for prompted values.
+  --with-gnu-ld           assume the C compiler uses GNU ld default=no
+  --with-pic              try to use only PIC/non-PIC objects default=use both
+  --with-libwrap=LIBPATH Compile in libwrap (tcp_wrappers) support.
+  --with-zlib=DIR        use libz in DIR
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
+              headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to <net-snmp-coders@lists.sourceforge.net>.
+_ACEOF
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
+# absolute.
+ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
+ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
+ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
+ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+           test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n "$ac_init_help" && exit 0
+if $ac_init_version; then
+  cat <<\_ACEOF
+Net-SNMP configure 5.1-pre1a
+generated by GNU Autoconf 2.57
+
+Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
+Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5>config.log
+cat >&5 <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by Net-SNMP $as_me 5.1-pre1a, which was
+generated by GNU Autoconf 2.57.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+        ac_must_keep_next=false # Got value, back to normal.
+      else
+        case $ac_arg in
+          *=* | --config-cache | -C | -disable-* | --disable-* \
+          | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+          | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+          | -with-* | --with-* | -without-* | --without-* | --x)
+            case "$ac_configure_args0 " in
+              "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+            esac
+            ;;
+          -* ) ac_must_keep_next=true ;;
+        esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2>&1 |
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      sed -n \
+        "s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+    	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
+    *)
+      sed -n \
+        "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+}
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+        echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed "/^$/d" confdefs.h | sort
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core core.* *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2>&1 |
+               sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+        { echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+        { echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+        { echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+        ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+ac_config_headers="$ac_config_headers include/net-snmp/net-snmp-config.h"
+rm -f configure-summary
+
+
+#
+# save the configure arguments
+#
+cat >>confdefs.h <<_ACEOF
+#define CONFIGURE_OPTIONS "\"$ac_configure_args\""
+_ACEOF
+
+CONFIGURE_OPTIONS="\"$ac_configure_args\""
+
+
+#
+# Compilation setup
+#
+
+# Check whether --with-cc or --without-cc was given.
+if test "${with_cc+set}" = set; then
+  withval="$with_cc"
+  CC=$with_cc;export CC
+fi;
+
+
+# Check whether --with-ar or --without-ar was given.
+if test "${with_ar+set}" = set; then
+  withval="$with_ar"
+  AR=$with_ar; export AR
+fi;
+
+
+# Check whether --with-endianness or --without-endianness was given.
+if test "${with_endianness+set}" = set; then
+  withval="$with_endianness"
+  if test $with_endianness != "big" -a $with_endianness != "little" ; then
+       { { echo "$as_me:$LINENO: error: Endianness must be big or little, not \"$with_endianness\"." >&5
+echo "$as_me: error: Endianness must be big or little, not \"$with_endianness\"." >&2;}
+   { (exit 1); exit 1; }; };
+     fi
+
+fi;
+
+
+# Check whether --with-cflags or --without-cflags was given.
+if test "${with_cflags+set}" = set; then
+  withval="$with_cflags"
+  CFLAGS=$with_cflags; export CFLAGS
+fi;
+
+
+# Check whether --with-ldflags or --without-ldflags was given.
+if test "${with_ldflags+set}" = set; then
+  withval="$with_ldflags"
+  LDFLAGS=$with_ldflags; export LDFLAGS
+fi;
+
+
+# Check whether --with-libs or --without-libs was given.
+if test "${with_libs+set}" = set; then
+  withval="$with_libs"
+  LIBS=$with_libs; export LIBS
+fi;
+
+# Check whether --enable-silent-libtool or --disable-silent-libtool was given.
+if test "${enable_silent_libtool+set}" = set; then
+  enableval="$enable_silent_libtool"
+  LIBTOOLFLAGS=--silent
+fi;
+
+
+
+# Check whether --with-install-prefix or --without-install-prefix was given.
+if test "${with_install_prefix+set}" = set; then
+  withval="$with_install_prefix"
+  INSTALL_PREFIX="$withval"
+fi;
+
+if test "x$INSTALL_PREFIX" = "xyes" ; then
+  { { echo "$as_me:$LINENO: error: --with-install-prefix requires an argument" >&5
+echo "$as_me: error: --with-install-prefix requires an argument" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test "x$INSTALL_PREFIX" = "xno" ; then
+  INSTALL_PREFIX=""
+fi
+
+
+# Check whether --enable-mini_agent or --disable-mini_agent was given.
+if test "${enable_mini_agent+set}" = set; then
+  enableval="$enable_mini_agent"
+  mini_agent="yes"
+else
+  mini_agent="no"
+fi;
+
+# Check whether --enable-agent or --disable-agent was given.
+if test "${enable_agent+set}" = set; then
+  enableval="$enable_agent"
+
+fi;
+if test "x$enable_agent" != "xno"; then
+   MAINSUBS="$MAINSUBS agent"
+fi
+
+# Check whether --enable-applications or --disable-applications was given.
+if test "${enable_applications+set}" = set; then
+  enableval="$enable_applications"
+
+fi;
+if test "x$enable_applications" != "xno"; then
+   MAINSUBS="$MAINSUBS apps"
+fi
+
+# Check whether --enable-manuals or --disable-manuals was given.
+if test "${enable_manuals+set}" = set; then
+  enableval="$enable_manuals"
+
+fi;
+if test "x$enable_manuals" != "xno"; then
+   MAINSUBS="$MAINSUBS man"
+fi
+
+# Check whether --enable-scripts or --disable-scripts was given.
+if test "${enable_scripts+set}" = set; then
+  enableval="$enable_scripts"
+
+fi;
+if test "x$enable_scripts" != "xno"; then
+   MAINSUBS="$MAINSUBS local"
+fi
+
+# Check whether --enable-mibs or --disable-mibs was given.
+if test "${enable_mibs+set}" = set; then
+  enableval="$enable_mibs"
+
+fi;
+if test "x$enable_mibs" != "xno"; then
+   MAINSUBS="$MAINSUBS mibs"
+fi
+
+
+echo "$as_me:$LINENO: checking what to build and install" >&5
+echo $ECHO_N "checking what to build and install... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $MAINSUBS" >&5
+echo "${ECHO_T}$MAINSUBS" >&6
+
+# Check whether --enable-mib-loading or --disable-mib-loading was given.
+if test "${enable_mib_loading+set}" = set; then
+  enableval="$enable_mib_loading"
+
+fi;
+if test "x$enable_mib_loading" = "xno"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define DISABLE_MIB_LOADING 1
+_ACEOF
+
+fi
+
+# Check whether --enable-ipv6 or --disable-ipv6 was given.
+if test "${enable_ipv6+set}" = set; then
+  enableval="$enable_ipv6"
+  if test "x$enable_ipv6" = "xyes"; then
+      cat >>confdefs.h <<\_ACEOF
+#define INET6 1
+_ACEOF
+
+    fi
+fi;
+
+# Check whether --enable-local-smux or --disable-local-smux was given.
+if test "${enable_local_smux+set}" = set; then
+  enableval="$enable_local_smux"
+  if test "x$local_smux" = "xyes"; then
+      cat >>confdefs.h <<\_ACEOF
+#define LOCAL_SMUX 1
+_ACEOF
+
+    fi
+fi;
+
+# Check whether --enable-debugging or --disable-debugging was given.
+if test "${enable_debugging+set}" = set; then
+  enableval="$enable_debugging"
+  cat >>confdefs.h <<\_ACEOF
+#define SNMP_ALWAYS_DEBUG 1
+_ACEOF
+
+fi;
+
+# Check whether --enable-developer or --disable-developer was given.
+if test "${enable_developer+set}" = set; then
+  enableval="$enable_developer"
+  developer=yes
+fi;
+
+if test "x$enable_debugging" = "xno"; then
+    cat >>confdefs.h <<\_ACEOF
+#define SNMP_NO_DEBUGGING 1
+_ACEOF
+
+fi
+
+
+# Check whether --with-dmalloc or --without-dmalloc was given.
+if test "${with_dmalloc+set}" = set; then
+  withval="$with_dmalloc"
+  if test "x$withval" = "xyes"; then
+      LIBS="$LIBS -ldmalloc"
+      cat >>confdefs.h <<\_ACEOF
+#define HAVE_DMALLOC_H 1
+_ACEOF
+
+    elif test -d "$withval"; then
+
+  if test "x$withval" != x -a -d $withval; then
+     if test -d $withval/lib; then
+       LDFLAGS="-L$withval/lib $LDFLAGS"
+     fi
+     if test -d $withval/include; then
+	CPPFLAGS="-I$withval/include $CPPFLAGS"
+     fi
+  fi
+
+      LIBS="$LIBS -ldmalloc"
+      cat >>confdefs.h <<\_ACEOF
+#define HAVE_DMALLOC_H 1
+_ACEOF
+
+    fi
+
+fi;
+
+
+
+# Check whether --with-efence or --without-efence was given.
+if test "${with_efence+set}" = set; then
+  withval="$with_efence"
+  use_efence="$withval"
+fi;
+
+tryrsaref=no
+
+# Check whether --with-rsaref or --without-rsaref was given.
+if test "${with_rsaref+set}" = set; then
+  withval="$with_rsaref"
+  if test "x$withval" = "xyes"; then
+      tryrsaref=yes
+    elif test "x$withval" = "xno"; then
+      tryrsaref=no
+    elif test -d "$withval"; then
+
+  if test "x$withval" != x -a -d $withval; then
+     if test -d $withval/lib; then
+       LDFLAGS="-L$withval/lib $LDFLAGS"
+     fi
+     if test -d $withval/include; then
+	CPPFLAGS="-I$withval/include $CPPFLAGS"
+     fi
+  fi
+
+      tryrsaref=yes
+    fi
+fi;
+
+tryopenssl=defaultyes
+askedopenssl=no
+
+# Check whether --with-openssl or --without-openssl was given.
+if test "${with_openssl+set}" = set; then
+  withval="$with_openssl"
+  if test "x$withval" = "xyes"; then
+      tryopenssl=yes
+      askedopenssl=yes
+    elif test "x$withval" = "xno"; then
+      tryopenssl=no
+    elif test -d "$withval"; then
+
+  if test "x$withval" != x -a -d $withval; then
+     if test -d $withval/lib; then
+       LDFLAGS="-L$withval/lib $LDFLAGS"
+     fi
+     if test -d $withval/include; then
+	CPPFLAGS="-I$withval/include $CPPFLAGS"
+     fi
+  fi
+
+      tryopenssl=yes
+      askedopenssl=yes
+    fi
+fi;
+if test "x$tryopenssl" = "xdefaultyes"; then
+
+  if test "x/usr/local/ssl" != x -a -d /usr/local/ssl; then
+     if test -d /usr/local/ssl/lib; then
+       LDFLAGS="-L/usr/local/ssl/lib $LDFLAGS"
+     fi
+     if test -d /usr/local/ssl/include; then
+	CPPFLAGS="-I/usr/local/ssl/include $CPPFLAGS"
+     fi
+  fi
+
+      tryopenssl=yes
+fi
+
+
+# Check whether --with-rpm or --without-rpm was given.
+if test "${with_rpm+set}" = set; then
+  withval="$with_rpm"
+
+fi;
+
+# Check whether --enable-privacy or --disable-privacy was given.
+if test "${enable_privacy+set}" = set; then
+  enableval="$enable_privacy"
+
+fi;
+if test "x$enable_privacy" != "xno"; then
+  cat >>confdefs.h <<\_ACEOF
+#define SCAPI_AUTHPRIV 1
+_ACEOF
+
+fi
+
+# Check whether --enable-internal-md5 or --disable-internal-md5 was given.
+if test "${enable_internal_md5+set}" = set; then
+  enableval="$enable_internal_md5"
+  cat >>confdefs.h <<\_ACEOF
+#define USE_INTERNAL_MD5 1
+_ACEOF
+
+fi;
+
+
+
+# Check whether --with-opaque-special-types or --without-opaque-special-types was given.
+if test "${with_opaque_special_types+set}" = set; then
+  withval="$with_opaque_special_types"
+
+fi;
+
+
+# Check whether --with-mibdirs or --without-mibdirs was given.
+if test "${with_mibdirs+set}" = set; then
+  withval="$with_mibdirs"
+  DEFAULT_MIBDIRS="$with_mibdirs"
+    cat >>confdefs.h <<_ACEOF
+#define DEFAULT_MIBDIRS "$with_mibdirs"
+_ACEOF
+
+fi;
+
+
+# Check whether --with-mibs or --without-mibs was given.
+if test "${with_mibs+set}" = set; then
+  withval="$with_mibs"
+  DEFAULT_MIBS="$with_mibs"
+fi;
+
+
+# Check whether --with-mibfiles or --without-mibfiles was given.
+if test "${with_mibfiles+set}" = set; then
+  withval="$with_mibfiles"
+  cat >>confdefs.h <<_ACEOF
+#define DEFAULT_MIBFILES "$with_mibfiles"
+_ACEOF
+
+fi;
+
+
+# Check whether --enable-testing-code or --disable-testing-code was given.
+if test "${enable_testing_code+set}" = set; then
+  enableval="$enable_testing_code"
+  cat >>confdefs.h <<\_ACEOF
+#define SNMP_TESTING_CODE 1
+_ACEOF
+
+fi;
+
+# Check whether --enable-reentrant or --disable-reentrant was given.
+if test "${enable_reentrant+set}" = set; then
+  enableval="$enable_reentrant"
+  with_res_locks="yes"
+else
+  with_res_locks="no"
+fi;
+
+
+# Check whether --with-root-access or --without-root-access was given.
+if test "${with_root_access+set}" = set; then
+  withval="$with_root_access"
+
+fi;
+
+
+# Check whether --with-kmem-usage or --without-kmem-usage was given.
+if test "${with_kmem_usage+set}" = set; then
+  withval="$with_kmem_usage"
+
+fi;
+
+
+# Check whether --with-dummy-values or --without-dummy-values was given.
+if test "${with_dummy_values+set}" = set; then
+  withval="$with_dummy_values"
+
+fi;
+
+
+# Check whether --with-persistent-directory or --without-persistent-directory was given.
+if test "${with_persistent_directory+set}" = set; then
+  withval="$with_persistent_directory"
+  ac_cv_user_prompt_PERSISTENT_DIRECTORY="$with_persistent_directory"
+fi;
+
+
+# Check whether --with-copy_persistent_files or --without-copy_persistent_files was given.
+if test "${with_copy_persistent_files+set}" = set; then
+  withval="$with_copy_persistent_files"
+  ac_cv_user_prompt_COPY_PERSISTENT_FILES="$with_copy_persistent_files"
+fi;
+
+
+# Check whether --with-default-snmp-version or --without-default-snmp-version was given.
+if test "${with_default_snmp_version+set}" = set; then
+  withval="$with_default_snmp_version"
+  ac_cv_user_prompt_DEFAULT_SNMP_VERSION="$with_default_snmp_version"
+fi;
+
+# we test this now and later as well.  we test it now so configure can die
+# early on with an error rather than waiting till the end of the script.
+if test "x$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "x"; then
+  if test "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "1" -a "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "2" -a "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "3"; then
+    { { echo "$as_me:$LINENO: error: Illegal version number passed to --with-default-snmp-version" >&5
+echo "$as_me: error: Illegal version number passed to --with-default-snmp-version" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+fi
+
+
+# Check whether --with-sys_contact or --without-sys_contact was given.
+if test "${with_sys_contact+set}" = set; then
+  withval="$with_sys_contact"
+  ac_cv_user_prompt_SYS_CONTACT="$with_sys_contact"
+fi;
+
+
+# Check whether --with-sys_location or --without-sys_location was given.
+if test "${with_sys_location+set}" = set; then
+  withval="$with_sys_location"
+  ac_cv_user_prompt_SYS_LOC="$with_sys_location"
+fi;
+
+
+# Check whether --with-logfile or --without-logfile was given.
+if test "${with_logfile+set}" = set; then
+  withval="$with_logfile"
+  ac_cv_user_prompt_LOGFILE="$with_logfile"
+fi;
+
+# This can't be within AC_ARG_WITH.  I don't want to read autoconf m4
+# to find out why.
+
+
+
+# Check whether --with-transports or --without-transports was given.
+if test "${with_transports+set}" = set; then
+  withval="$with_transports"
+
+fi;
+
+# Check whether --with-out_transports or --without-out_transports was given.
+if test "${with_out_transports+set}" = set; then
+  withval="$with_out_transports"
+
+fi;
+
+#
+# Catch common mistakes in transport options
+#
+
+# Check whether --with-transport or --without-transport was given.
+if test "${with_transport+set}" = set; then
+  withval="$with_transport"
+  { { echo "$as_me:$LINENO: error:  Invalid option. Use --with-transports instead " >&5
+echo "$as_me: error:  Invalid option. Use --with-transports instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+# Check whether --with-out-transport or --without-out-transport was given.
+if test "${with_out_transport+set}" = set; then
+  withval="$with_out_transport"
+  { { echo "$as_me:$LINENO: error:  Invalid option. Use --with-out-transports instead " >&5
+echo "$as_me: error:  Invalid option. Use --with-out-transports instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+#
+# security modules
+#
+
+
+# Check whether --with-security-modules or --without-security-modules was given.
+if test "${with_security_modules+set}" = set; then
+  withval="$with_security_modules"
+
+fi;
+
+#
+# mib modules
+#
+
+
+# Check whether --with-mib_modules or --without-mib_modules was given.
+if test "${with_mib_modules+set}" = set; then
+  withval="$with_mib_modules"
+
+fi;
+
+
+# Check whether --with-out_mib_modules or --without-out_mib_modules was given.
+if test "${with_out_mib_modules+set}" = set; then
+  withval="$with_out_mib_modules"
+
+fi;
+
+
+#
+
+# Check whether --with-enterprise-oid or --without-enterprise-oid was given.
+if test "${with_enterprise_oid+set}" = set; then
+  withval="$with_enterprise_oid"
+
+  if test "$withval" = yes; then
+    { { echo "$as_me:$LINENO: error:  Please provide a value for the enterprise number " >&5
+echo "$as_me: error:  Please provide a value for the enterprise number " >&2;}
+   { (exit 1); exit 1; }; };
+  fi
+  cat >>confdefs.h <<_ACEOF
+#define ENTERPRISE_OID $withval
+_ACEOF
+
+  ent_oid="1,3,6,1,4,1,$withval"
+  cat >>confdefs.h <<_ACEOF
+#define ENTERPRISE_MIB $ent_oid
+_ACEOF
+
+  ent_dot_oid="1.3.6.1.4.1.$withval"
+  cat >>confdefs.h <<_ACEOF
+#define ENTERPRISE_DOT_MIB $ent_dot_oid
+_ACEOF
+
+  echo "$as_me:$LINENO: result: using enterprise number $withval" >&5
+echo "${ECHO_T}using enterprise number $withval" >&6
+
+else
+
+  echo "$as_me:$LINENO: result: using default \"enterprise.net-snmp\"" >&5
+echo "${ECHO_T}using default \"enterprise.net-snmp\"" >&6
+
+fi;
+
+
+# Check whether --with-enterprise-sysoid or --without-enterprise-sysoid was given.
+if test "${with_enterprise_sysoid+set}" = set; then
+  withval="$with_enterprise_sysoid"
+
+  if test "$withval" = yes; then
+    { { echo "$as_me:$LINENO: error:  Please provide a base OID value " >&5
+echo "$as_me: error:  Please provide a base OID value " >&2;}
+   { (exit 1); exit 1; }; };
+  fi
+  sys_oid=`echo "$withval" | sed 's/^\.//' | sed 's/\./\,/g'`
+  cat >>confdefs.h <<_ACEOF
+#define SYSTEM_MIB $sys_oid
+_ACEOF
+
+  sys_dot_oid=`echo "$withval" | sed 's/^\.//'`
+  cat >>confdefs.h <<_ACEOF
+#define SYSTEM_DOT_MIB $sys_dot_oid
+_ACEOF
+
+  sysoid_len=`echo "$withval" | sed 's/^\.//g' | awk -F\. '{ print NF }'`
+  cat >>confdefs.h <<_ACEOF
+#define SYSTEM_DOT_MIB_LENGTH $sysoid_len
+_ACEOF
+
+  echo "$as_me:$LINENO: result: using enterprise sysOID $withval ...." >&5
+echo "${ECHO_T}using enterprise sysOID $withval ...." >&6
+
+else
+
+  echo "$as_me:$LINENO: result: using default enterprise sysOID \"NET-SNMP-MIB::netSnmpAgentOIDs...\"" >&5
+echo "${ECHO_T}using default enterprise sysOID \"NET-SNMP-MIB::netSnmpAgentOIDs...\"" >&6
+
+fi;
+
+
+# Check whether --with-enterprise-notification-oid or --without-enterprise-notification-oid was given.
+if test "${with_enterprise_notification_oid+set}" = set; then
+  withval="$with_enterprise_notification_oid"
+
+  if test "$withval" = yes; then
+    { { echo "$as_me:$LINENO: error:  Please provide a base OID value " >&5
+echo "$as_me: error:  Please provide a base OID value " >&2;}
+   { (exit 1); exit 1; }; };
+  fi
+  notification_oid=`echo "$withval" | sed 's/^\.//' | sed 's/\./\,/g'`
+  cat >>confdefs.h <<_ACEOF
+#define NOTIFICATION_MIB $notification_oid
+_ACEOF
+
+  notification_dot_oid=`echo "$withval" | sed 's/^\.//'`
+  cat >>confdefs.h <<_ACEOF
+#define NOTIFICATION_DOT_MIB $notification_dot_oid
+_ACEOF
+
+  notificationoid_len=`echo "$withval" | sed 's/^\.//g' | awk -F\. '{ print NF }'`
+  cat >>confdefs.h <<_ACEOF
+#define NOTIFICATION_DOT_MIB_LENGTH $notificationoid_len
+_ACEOF
+
+  echo "$as_me:$LINENO: result: using enterprise notifications $withval" >&5
+echo "${ECHO_T}using enterprise notifications $withval" >&6
+
+else
+
+  echo "$as_me:$LINENO: result: using default notifications \"NET-SNMP-MIB::netSnmpNotifications\"" >&5
+echo "${ECHO_T}using default notifications \"NET-SNMP-MIB::netSnmpNotifications\"" >&6
+
+fi;
+#
+# Catch common mistakes in configure options
+#
+
+# Check whether --with-mib-module or --without-mib-module was given.
+if test "${with_mib_module+set}" = set; then
+  withval="$with_mib_module"
+  { { echo "$as_me:$LINENO: error:  Invalid option1. Use --with-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option1. Use --with-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+# Check whether --with-module or --without-module was given.
+if test "${with_module+set}" = set; then
+  withval="$with_module"
+  { { echo "$as_me:$LINENO: error:  Invalid option3. Use --with-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option3. Use --with-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+# Check whether --with-modules or --without-modules was given.
+if test "${with_modules+set}" = set; then
+  withval="$with_modules"
+  { { echo "$as_me:$LINENO: error:  Invalid option4. Use --with-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option4. Use --with-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+
+# Check whether --with-out-mib-module or --without-out-mib-module was given.
+if test "${with_out_mib_module+set}" = set; then
+  withval="$with_out_mib_module"
+  { { echo "$as_me:$LINENO: error:  Invalid option5. Use --with-out-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option5. Use --with-out-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+# Check whether --with-out-modules or --without-out-modules was given.
+if test "${with_out_modules+set}" = set; then
+  withval="$with_out_modules"
+  { { echo "$as_me:$LINENO: error:  Invalid option7. Use --with-out-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option7. Use --with-out-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+# Check whether --with-out-module or --without-out-module was given.
+if test "${with_out_module+set}" = set; then
+  withval="$with_out_module"
+  { { echo "$as_me:$LINENO: error:  Invalid option8. Use --with-out-mib-modules instead " >&5
+echo "$as_me: error:  Invalid option8. Use --with-out-mib-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+#
+# Perl specific
+#
+
+# Check whether --with-perl-modules or --without-perl-modules was given.
+if test "${with_perl_modules+set}" = set; then
+  withval="$with_perl_modules"
+
+    install_perl=yes
+    if test "$withval" = yes; then
+      PERLARGS=""
+    else
+      PERLARGS="$withval"
+    fi
+
+fi;
+
+# Check whether --enable-embedded-perl or --disable-embedded-perl was given.
+if test "${enable_embedded_perl+set}" = set; then
+  enableval="$enable_embedded_perl"
+  embed_perl="yes"
+else
+  embed_perl="no"
+fi;
+
+# Common perl mistakes
+# Check whether --enable-perl-modules or --disable-perl-modules was given.
+if test "${enable_perl_modules+set}" = set; then
+  enableval="$enable_perl_modules"
+  { { echo "$as_me:$LINENO: error:  Invalid option. Use --with-perl-modules instead " >&5
+echo "$as_me: error:  Invalid option. Use --with-perl-modules instead " >&2;}
+   { (exit 1); exit 1; }; }
+fi;
+
+#
+# otherwise prompted information
+#
+
+# Check whether --with-defaults or --without-defaults was given.
+if test "${with_defaults+set}" = set; then
+  withval="$with_defaults"
+  defaults="yes"
+else
+  defaults="no"
+fi;
+
+# Check whether --enable-ucd-snmp-compatibility or --disable-ucd-snmp-compatibility was given.
+if test "${enable_ucd_snmp_compatibility+set}" = set; then
+  enableval="$enable_ucd_snmp_compatibility"
+  ucd_compat=yes
+else
+  ucd_compat=no
+fi;
+#
+# setup install targets
+#
+if test "x$ucd_compat" != "xno" ; then
+  installucdheaders=installucdheaders
+  installucdlibs=installucdlibs
+
+  cat >> configure-summary << EOF
+  UCD-SNMP compatability:     enabled
+EOF
+
+fi
+
+
+
+# Only define if specifically chosen as --without (i.e., default to true).
+if test "x$with_root_access" = "xno"; then
+  cat >>confdefs.h <<\_ACEOF
+#define NO_ROOT_ACCESS 1
+_ACEOF
+
+fi
+
+# Only define if specifically chosen as --without (i.e., default to true).
+if test "x$with_kmem_usage" = "xno"; then
+  cat >>confdefs.h <<\_ACEOF
+#define NO_KMEM_USAGE 1
+_ACEOF
+
+fi
+
+# Define unless specifically suppressed (i.e., option defaults to false).
+if test "x$with_dummy_values" != "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define NO_DUMMY_VALUES 1
+_ACEOF
+
+fi
+
+# Only define if specifically chosen as --without (i.e., default to true).
+if test "x$with_opaque_special_types" != "xno"; then
+  cat >>confdefs.h <<\_ACEOF
+#define OPAQUE_SPECIAL_TYPES 1
+_ACEOF
+
+fi
+
+
+# overflow problems with hpux's sh
+# taken from Perl's Configure script
+
+echo "$as_me:$LINENO: checking if I need to feed myself to ksh" >&5
+echo $ECHO_N "checking if I need to feed myself to ksh... $ECHO_C" >&6
+if test -f /hp-ux -a -f /bin/ksh; then
+  if (PATH=.; alias -x) >/dev/null 2>&1; then
+    echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+  else
+    echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+    if test "x$1" = "x"; then
+      exec /bin/ksh $0
+    else
+      exec /bin/ksh $0 "$@"
+    fi
+  fi
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+if test "x$developer" != "xno" -a -f $srcdir/remove-files; then
+  # turn on the developer flag when taken from a CVS checkout (not a release)
+  developer="yes"
+fi
+
+# disable --enable-shared by default in cvs/developer cases.
+if test "x$developer" = "xyes"; then
+  # don't do anything if option set via cmdline
+  if test "${enable_shared+set}" != set; then
+    enable_shared=no
+  fi
+fi
+
+# perl requires shared libs
+if test "x$embed_perl" = "xyes"; then
+    if test "x$enable_shared" != "xyes"; then
+      { { echo "$as_me:$LINENO: error: --enable-embedded-perl requires --enable-shared" >&5
+echo "$as_me: error: --enable-embedded-perl requires --enable-shared" >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+fi
+
+# AIX has problems with shared libs
+case $target_os in
+    aix*)
+        echo "$as_me:$LINENO: checking whether using AIX and if we should disable shared libraries" >&5
+echo $ECHO_N "checking whether using AIX and if we should disable shared libraries... $ECHO_C" >&6
+	echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	enable_shared=no
+        ;;
+    *)
+        ;;
+esac
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$ac_ct_CC" && break
+done
+
+  CC=$ac_ct_CC
+fi
+
+fi
+
+
+test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+
+# Provide some information about the compiler.
+echo "$as_me:$LINENO:" \
+     "checking for C compiler version" >&5
+ac_compiler=`set X $ac_compile; echo $2`
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
+  (eval $ac_compiler --version </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -v </dev/null >&5\"") >&5
+  (eval $ac_compiler -v </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -V </dev/null >&5\"") >&5
+  (eval $ac_compiler -V </dev/null >&5) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+echo "$as_me:$LINENO: checking for C compiler default output" >&5
+echo $ECHO_N "checking for C compiler default output... $ECHO_C" >&6
+ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
+  (eval $ac_link_default) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # Find the output, starting from the most likely.  This scheme is
+# not robust to junk in `.', hence go to wildcards (a.*) only as a last
+# resort.
+
+# Be careful to initialize this variable, since it used to be cached.
+# Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
+ac_cv_exeext=
+# b.out is created by i960 compilers.
+for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
+        ;;
+    conftest.$ac_ext )
+        # This is the source file.
+        ;;
+    [ab].out )
+        # We found the default executable, but exeext='' is most
+        # certainly right.
+        break;;
+    *.* )
+        ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+        # FIXME: I believe we export ac_cv_exeext for Libtool,
+        # but it would be cool to find out if it's true.  Does anybody
+        # maintain Libtool? --akim.
+        export ac_cv_exeext
+        break;;
+    * )
+        break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
+See \`config.log' for more details." >&5
+echo "$as_me: error: C compiler cannot create executables
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }
+fi
+
+ac_exeext=$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_file" >&5
+echo "${ECHO_T}$ac_file" >&6
+
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
+# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+fi
+echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+# Check the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $cross_compiling" >&5
+echo "${ECHO_T}$cross_compiling" >&6
+
+echo "$as_me:$LINENO: checking for suffix of executables" >&5
+echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+          export ac_cv_exeext
+          break;;
+    * ) break;;
+  esac
+done
+else
+  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+echo "${ECHO_T}$ac_cv_exeext" >&6
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+echo "$as_me:$LINENO: checking for suffix of object files" >&5
+echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6
+if test "${ac_cv_objext+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+  for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+echo "${ECHO_T}$ac_cv_objext" >&6
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_compiler_gnu=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_compiler_gnu=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
+GCC=`test $ac_compiler_gnu = yes && echo yes`
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+CFLAGS="-g"
+echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_prog_cc_g=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+echo "$as_me:$LINENO: checking for $CC option to accept ANSI C" >&5
+echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_prog_cc_stdc=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_stdc=$ac_arg
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext
+done
+rm -f conftest.$ac_ext conftest.$ac_objext
+CC=$ac_save_CC
+
+fi
+
+case "x$ac_cv_prog_cc_stdc" in
+  x|xno)
+    echo "$as_me:$LINENO: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6 ;;
+  *)
+    echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
+    CC="$CC $ac_cv_prog_cc_stdc" ;;
+esac
+
+# Some people use a C++ compiler to compile C.  Since we use `exit',
+# in C++ we need to declare it.  In case someone uses the same compiler
+# for both compiling C and C++ we need to have the C++ compiler decide
+# the declaration of exit, since it's the most demanding environment.
+cat >conftest.$ac_ext <<_ACEOF
+#ifndef __cplusplus
+  choke me
+#endif
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  for ac_declaration in \
+   ''\
+   '#include <stdlib.h>' \
+   'extern "C" void std::exit (int) throw (); using std::exit;' \
+   'extern "C" void std::exit (int); using std::exit;' \
+   'extern "C" void exit (int) throw ();' \
+   'extern "C" void exit (int);' \
+   'void exit (int);'
+do
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+continue
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n "$ac_declaration"; then
+  echo '#ifdef __cplusplus' >>confdefs.h
+  echo $ac_declaration      >>confdefs.h
+  echo '#endif'             >>confdefs.h
+fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+                     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+echo "$as_me:$LINENO: result: $CPP" >&5
+echo "${ECHO_T}$CPP" >&6
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+                     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
+
+echo "$as_me:$LINENO: checking for AIX" >&5
+echo $ECHO_N "checking for AIX... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef _AIX
+  yes
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+cat >>confdefs.h <<\_ACEOF
+#define _ALL_SOURCE 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+rm -f conftest*
+
+
+
+
+# libtool stuff for shared/static libraries.
+
+
+# Check whether --enable-shared or --disable-shared was given.
+if test "${enable_shared+set}" = set; then
+  enableval="$enable_shared"
+  p=${PACKAGE-default}
+case $enableval in
+yes) enable_shared=yes ;;
+no) enable_shared=no ;;
+*)
+  enable_shared=no
+  # Look at the argument we got.  We use all the common list separators.
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:,"
+  for pkg in $enableval; do
+    if test "X$pkg" = "X$p"; then
+      enable_shared=yes
+    fi
+  done
+  IFS="$ac_save_ifs"
+  ;;
+esac
+else
+  enable_shared=yes
+fi;
+# Check whether --enable-static or --disable-static was given.
+if test "${enable_static+set}" = set; then
+  enableval="$enable_static"
+  p=${PACKAGE-default}
+case $enableval in
+yes) enable_static=yes ;;
+no) enable_static=no ;;
+*)
+  enable_static=no
+  # Look at the argument we got.  We use all the common list separators.
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:,"
+  for pkg in $enableval; do
+    if test "X$pkg" = "X$p"; then
+      enable_static=yes
+    fi
+  done
+  IFS="$ac_save_ifs"
+  ;;
+esac
+else
+  enable_static=yes
+fi;
+# Check whether --enable-fast-install or --disable-fast-install was given.
+if test "${enable_fast_install+set}" = set; then
+  enableval="$enable_fast_install"
+  p=${PACKAGE-default}
+case $enableval in
+yes) enable_fast_install=yes ;;
+no) enable_fast_install=no ;;
+*)
+  enable_fast_install=no
+  # Look at the argument we got.  We use all the common list separators.
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:,"
+  for pkg in $enableval; do
+    if test "X$pkg" = "X$p"; then
+      enable_fast_install=yes
+    fi
+  done
+  IFS="$ac_save_ifs"
+  ;;
+esac
+else
+  enable_fast_install=yes
+fi;
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&5
+echo "$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"
+ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
+
+# Make sure we can run config.sub.
+$ac_config_sub sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
+echo "$as_me: error: cannot run $ac_config_sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_build_alias=$build_alias
+test -z "$ac_cv_build_alias" &&
+  ac_cv_build_alias=`$ac_config_guess`
+test -z "$ac_cv_build_alias" &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6
+build=$ac_cv_build
+build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_host_alias=$host_alias
+test -z "$ac_cv_host_alias" &&
+  ac_cv_host_alias=$ac_cv_build_alias
+ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6
+host=$ac_cv_host
+host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+# Find the correct PATH separator.  Usually this is `:', but
+# DJGPP uses `;' like DOS.
+if test "X${PATH_SEPARATOR+set}" != Xset; then
+  UNAME=${UNAME-`uname 2>/dev/null`}
+  case X$UNAME in
+    *-DOS) lt_cv_sys_path_separator=';' ;;
+    *)     lt_cv_sys_path_separator=':' ;;
+  esac
+  PATH_SEPARATOR=$lt_cv_sys_path_separator
+fi
+
+
+# Check whether --with-gnu-ld or --without-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then
+  withval="$with_gnu_ld"
+  test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi;
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  echo "$as_me:$LINENO: checking for ld used by GCC" >&5
+echo $ECHO_N "checking for ld used by GCC... $ECHO_C" >&6
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | [A-Za-z]:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the path of ld
+      ac_prog=`echo $ac_prog| sed 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| sed "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  echo "$as_me:$LINENO: checking for GNU ld" >&5
+echo $ECHO_N "checking for GNU ld... $ECHO_C" >&6
+else
+  echo "$as_me:$LINENO: checking for non-GNU ld" >&5
+echo $ECHO_N "checking for non-GNU ld... $ECHO_C" >&6
+fi
+if test "${lt_cv_path_LD+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      if "$lt_cv_path_LD" -v 2>&1 < /dev/null | egrep '(GNU|with BFD)' > /dev/null; then
+	test "$with_gnu_ld" != no && break
+      else
+	test "$with_gnu_ld" != yes && break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
+
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  echo "$as_me:$LINENO: result: $LD" >&5
+echo "${ECHO_T}$LD" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+test -z "$LD" && { { echo "$as_me:$LINENO: error: no acceptable ld found in \$PATH" >&5
+echo "$as_me: error: no acceptable ld found in \$PATH" >&2;}
+   { (exit 1); exit 1; }; }
+echo "$as_me:$LINENO: checking if the linker ($LD) is GNU ld" >&5
+echo $ECHO_N "checking if the linker ($LD) is GNU ld... $ECHO_C" >&6
+if test "${lt_cv_prog_gnu_ld+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # I'd rather use --version here, but apparently some GNU ld's only accept -v.
+if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
+  lt_cv_prog_gnu_ld=yes
+else
+  lt_cv_prog_gnu_ld=no
+fi
+fi
+echo "$as_me:$LINENO: result: $lt_cv_prog_gnu_ld" >&5
+echo "${ECHO_T}$lt_cv_prog_gnu_ld" >&6
+with_gnu_ld=$lt_cv_prog_gnu_ld
+
+
+echo "$as_me:$LINENO: checking for $LD option to reload object files" >&5
+echo $ECHO_N "checking for $LD option to reload object files... $ECHO_C" >&6
+if test "${lt_cv_ld_reload_flag+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  lt_cv_ld_reload_flag='-r'
+fi
+echo "$as_me:$LINENO: result: $lt_cv_ld_reload_flag" >&5
+echo "${ECHO_T}$lt_cv_ld_reload_flag" >&6
+reload_flag=$lt_cv_ld_reload_flag
+test -n "$reload_flag" && reload_flag=" $reload_flag"
+
+echo "$as_me:$LINENO: checking for BSD-compatible nm" >&5
+echo $ECHO_N "checking for BSD-compatible nm... $ECHO_C" >&6
+if test "${lt_cv_path_NM+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH /usr/ccs/bin /usr/ucb /bin; do
+    test -z "$ac_dir" && ac_dir=.
+    tmp_nm=$ac_dir/${ac_tool_prefix}nm
+    if test -f $tmp_nm || test -f $tmp_nm$ac_exeext ; then
+      # Check to see if the nm accepts a BSD-compat flag.
+      # Adding the `sed 1q' prevents false positives on HP-UX, which says:
+      #   nm: unknown option "B" ignored
+      # Tru64's nm complains that /dev/null is an invalid object file
+      if ($tmp_nm -B /dev/null 2>&1 | sed '1q'; exit 0) | egrep '(/dev/null|Invalid file or object type)' >/dev/null; then
+	lt_cv_path_NM="$tmp_nm -B"
+	break
+      elif ($tmp_nm -p /dev/null 2>&1 | sed '1q'; exit 0) | egrep /dev/null >/dev/null; then
+	lt_cv_path_NM="$tmp_nm -p"
+	break
+      else
+	lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	continue # so that we can try to find one that supports BSD flags
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$lt_cv_path_NM" && lt_cv_path_NM=nm
+fi
+fi
+
+NM="$lt_cv_path_NM"
+echo "$as_me:$LINENO: result: $NM" >&5
+echo "${ECHO_T}$NM" >&6
+
+echo "$as_me:$LINENO: checking for a sed that does not truncate output" >&5
+echo $ECHO_N "checking for a sed that does not truncate output... $ECHO_C" >&6
+if test "${lt_cv_path_SED+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # Loop through the user's path and test for sed and gsed.
+# Then use that list of sed's as ones to test for truncation.
+as_executable_p="test -f"
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+        _sed_list="$_sed_list $as_dir/$ac_prog$ac_exec_ext"
+      fi
+    done
+  done
+done
+
+  # Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+: ${TMPDIR=/tmp}
+{
+  tmp=`(umask 077 && mktemp -d -q "$TMPDIR/sedXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=$TMPDIR/sed$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in $TMPDIR" >&2
+   { (exit 1); exit 1; }
+}
+  _max=0
+  _count=0
+  # Add /usr/xpg4/bin/sed as it is typically found on Solaris
+  # along with /bin/sed that truncates output.
+  for _sed in $_sed_list /usr/xpg4/bin/sed; do
+    test ! -f ${_sed} && break
+    cat /dev/null > "$tmp/sed.in"
+    _count=0
+    echo ${ECHO_N-$ac_n} "0123456789${ECHO_C-$ac_c}" >"$tmp/sed.in"
+    # Check for GNU sed and select it if it is found.
+    if "${_sed}" --version 2>&1 < /dev/null | egrep '(GNU)' > /dev/null; then
+      lt_cv_path_SED=${_sed}
+      break
+    fi
+    while true; do
+      cat "$tmp/sed.in" "$tmp/sed.in" >"$tmp/sed.tmp"
+      mv "$tmp/sed.tmp" "$tmp/sed.in"
+      cp "$tmp/sed.in" "$tmp/sed.nl"
+      echo >>"$tmp/sed.nl"
+      ${_sed} -e 's/a$//' < "$tmp/sed.nl" >"$tmp/sed.out" || break
+      cmp -s "$tmp/sed.out" "$tmp/sed.nl" || break
+      # 40000 chars as input seems more than enough
+      test $_count -gt 10 && break
+      _count=`expr $_count + 1`
+      if test $_count -gt $_max; then
+        _max=$_count
+        lt_cv_path_SED=$_sed
+      fi
+    done
+  done
+  rm -rf "$tmp"
+
+fi
+
+if test "X$SED" != "X"; then
+  lt_cv_path_SED=$SED
+else
+  SED=$lt_cv_path_SED
+fi
+echo "$as_me:$LINENO: result: $SED" >&5
+echo "${ECHO_T}$SED" >&6
+
+echo "$as_me:$LINENO: checking whether ln -s works" >&5
+echo $ECHO_N "checking whether ln -s works... $ECHO_C" >&6
+LN_S=$as_ln_s
+if test "$LN_S" = "ln -s"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+  echo "$as_me:$LINENO: result: no, using $LN_S" >&5
+echo "${ECHO_T}no, using $LN_S" >&6
+fi
+
+echo "$as_me:$LINENO: checking how to recognise dependent libraries" >&5
+echo $ECHO_N "checking how to recognise dependent libraries... $ECHO_C" >&6
+if test "${lt_cv_deplibs_check_method+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given egrep regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix4* | aix5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi4*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin* | mingw* | pw32*)
+  lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method='file_magic Mach-O dynamically linked shared library'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  case "$host_os" in
+  rhapsody* | darwin1.[012])
+    lt_cv_file_magic_test_file=`echo /System/Library/Frameworks/System.framework/Versions/*/System | head -1`
+    ;;
+  *) # Darwin 1.3 on
+    lt_cv_file_magic_test_file='/usr/lib/libSystem.dylib'
+    ;;
+  esac
+  ;;
+
+freebsd*)
+  if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD)/i[3-9]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20*|hpux11*)
+  lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9].[0-9]) shared library'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libc.sl
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+  irix5* | nonstopux*)
+    # this will be overridden with pass_all, but let us keep it just in case
+    lt_cv_deplibs_check_method="file_magic ELF 32-bit MSB dynamic lib MIPS - version 1"
+    ;;
+  *)
+    case $LD in
+    *-32|*"-32 ") libmagic=32-bit;;
+    *-n32|*"-n32 ") libmagic=N32;;
+    *-64|*"-64 ") libmagic=64-bit;;
+    *) libmagic=never-match;;
+    esac
+    # this will be overridden with pass_all, but let us keep it just in case
+    lt_cv_deplibs_check_method="file_magic ELF ${libmagic} MSB mips-[1234] dynamic lib MIPS - version 1"
+    ;;
+  esac
+  lt_cv_file_magic_test_file=`echo /lib${libsuff}/libc.so*`
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be Linux ELF.
+linux-gnu*)
+  case $host_cpu in
+  alpha* | hppa* | i*86 | mips | mipsel | powerpc* | sparc* | ia64*)
+    lt_cv_deplibs_check_method=pass_all ;;
+  *)
+    # glibc up to 2.1.1 does not perform some relocations on ARM
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
+  esac
+  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  ;;
+
+netbsd*)
+  if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/\.]+\.so\.[0-9]+\.[0-9]+$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/\.]+\.so$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+openbsd*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB shared object'
+  else
+    lt_cv_deplibs_check_method='file_magic OpenBSD.* shared library'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  # this will be overridden with pass_all, but let us keep it just in case
+  lt_cv_deplibs_check_method='file_magic COFF format alpha shared library'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sco3.2v5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  lt_cv_file_magic_test_file=/lib/libc.so
+  ;;
+
+sysv5uw[78]* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+esac
+
+fi
+echo "$as_me:$LINENO: result: $lt_cv_deplibs_check_method" >&5
+echo "${ECHO_T}$lt_cv_deplibs_check_method" >&6
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+
+
+
+
+
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+echo "$as_me:$LINENO: checking command to parse $NM output" >&5
+echo $ECHO_N "checking command to parse $NM output... $ECHO_C" >&6
+if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[BCDEGRST]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
+
+# Transform the above into a raw symbol and a C symbol.
+symxfrm='\1 \2\3 \3'
+
+# Transform an extracted symbol line into a proper C declaration
+lt_cv_global_symbol_to_cdecl="sed -n -e 's/^. .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (lt_ptr) 0},/p' -e 's/^$symcode \([^ ]*\) \([^ ]*\)$/  {\"\2\", (lt_ptr) \&\2},/p'"
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[BCDT]'
+  ;;
+cygwin* | mingw* | pw32*)
+  symcode='[ABCDGISTW]'
+  ;;
+hpux*) # Its linker distinguishes data from code symbols
+  lt_cv_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern char \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+  lt_cv_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (lt_ptr) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (lt_ptr) \&\2},/p'"
+  ;;
+irix* | nonstopux*)
+  symcode='[BCDEGRST]'
+  ;;
+osf*)
+  symcode='[BCDEGQRST]'
+  ;;
+solaris* | sysv5*)
+  symcode='[BDT]'
+  ;;
+sysv4)
+  symcode='[DFNSTU]'
+  ;;
+esac
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $host_os in
+mingw*)
+  opt_cr=`echo 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+if $NM -V 2>&1 | egrep '(GNU|with BFD)' > /dev/null; then
+  symcode='[ABCDGISTW]'
+fi
+
+# Try without a prefix undercore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Write the raw and C identifiers.
+lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[ 	]\($symcode$symcode*\)[ 	][ 	]*\($ac_symprfx\)$sympat$opt_cr$/$symxfrm/p'"
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+  rm -f conftest*
+  cat > conftest.$ac_ext <<EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+EOF
+
+  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if { (eval echo "$as_me:$LINENO: \"$NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist\"") >&5
+  (eval $NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if egrep ' nm_test_var$' "$nlist" >/dev/null; then
+	if egrep ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<EOF > conftest.$ac_ext
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_global_symbol_to_cdecl"' < "$nlist" >> conftest.$ac_ext'
+
+	  cat <<EOF >> conftest.$ac_ext
+#if defined (__STDC__) && __STDC__
+# define lt_ptr void *
+#else
+# define lt_ptr char *
+# define const
+#endif
+
+/* The mapping between symbol names and symbols. */
+const struct {
+  const char *name;
+  lt_ptr address;
+}
+lt_preloaded_symbols[] =
+{
+EOF
+	  sed "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (lt_ptr) \&\2},/" < "$nlist" >> conftest.$ac_ext
+	  cat <<\EOF >> conftest.$ac_ext
+  {0, (lt_ptr) 0}
+};
+
+#ifdef __cplusplus
+}
+#endif
+EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  save_LIBS="$LIBS"
+	  save_CFLAGS="$CFLAGS"
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$no_builtin_flag"
+	  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s conftest$ac_exeext; then
+	    pipe_works=yes
+	  fi
+	  LIBS="$save_LIBS"
+	  CFLAGS="$save_CFLAGS"
+	else
+	  echo "cannot find nm_test_func in $nlist" >&5
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&5
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
+    fi
+  else
+    echo "$progname: failed program was:" >&5
+    cat conftest.$ac_ext >&5
+  fi
+  rm -f conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+
+fi
+
+global_symbol_pipe="$lt_cv_sys_global_symbol_pipe"
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  global_symbol_to_cdecl=
+  global_symbol_to_c_name_address=
+else
+  global_symbol_to_cdecl="$lt_cv_global_symbol_to_cdecl"
+  global_symbol_to_c_name_address="$lt_cv_global_symbol_to_c_name_address"
+fi
+if test -z "$global_symbol_pipe$global_symbol_to_cdec$global_symbol_to_c_name_address";
+then
+  echo "$as_me:$LINENO: result: failed" >&5
+echo "${ECHO_T}failed" >&6
+else
+  echo "$as_me:$LINENO: result: ok" >&5
+echo "${ECHO_T}ok" >&6
+fi
+
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_stdc=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+                   (('a' <= (c) && (c) <= 'i') \
+                     || ('j' <= (c) && (c) <= 'r') \
+                     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+        || toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+
+
+
+
+
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+                  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_Header=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in dlfcn.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+
+# Only perform the check for file, if the check method requires it
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    echo "$as_me:$LINENO: checking for ${ac_tool_prefix}file" >&5
+echo $ECHO_N "checking for ${ac_tool_prefix}file... $ECHO_C" >&6
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $MAGIC_CMD in
+  /*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+  ?:/*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a dos path.
+  ;;
+  *)
+  ac_save_MAGIC_CMD="$MAGIC_CMD"
+  IFS="${IFS=   }"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="/usr/bin:$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/${ac_tool_prefix}file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex="`expr \"$deplibs_check_method\" : \"file_magic \(.*\)\"`"
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    egrep "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  MAGIC_CMD="$ac_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  echo "$as_me:$LINENO: result: $MAGIC_CMD" >&5
+echo "${ECHO_T}$MAGIC_CMD" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    echo "$as_me:$LINENO: checking for file" >&5
+echo $ECHO_N "checking for file... $ECHO_C" >&6
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $MAGIC_CMD in
+  /*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+  ?:/*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a dos path.
+  ;;
+  *)
+  ac_save_MAGIC_CMD="$MAGIC_CMD"
+  IFS="${IFS=   }"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="/usr/bin:$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex="`expr \"$deplibs_check_method\" : \"file_magic \(.*\)\"`"
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    egrep "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  MAGIC_CMD="$ac_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  echo "$as_me:$LINENO: result: $MAGIC_CMD" >&5
+echo "${ECHO_T}$MAGIC_CMD" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  else
+    MAGIC_CMD=:
+  fi
+fi
+
+  fi
+  ;;
+esac
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  echo "$as_me:$LINENO: result: $RANLIB" >&5
+echo "${ECHO_T}$RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_RANLIB" && ac_cv_prog_ac_ct_RANLIB=":"
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+echo "${ECHO_T}$ac_ct_RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  RANLIB=$ac_ct_RANLIB
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_STRIP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  echo "$as_me:$LINENO: result: $STRIP" >&5
+echo "${ECHO_T}$STRIP" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_STRIP" && ac_cv_prog_ac_ct_STRIP=":"
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
+echo "${ECHO_T}$ac_ct_STRIP" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  STRIP=$ac_ct_STRIP
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+
+enable_dlopen=no
+enable_win32_dll=no
+
+# Check whether --enable-libtool-lock or --disable-libtool-lock was given.
+if test "${enable_libtool_lock+set}" = set; then
+  enableval="$enable_libtool_lock"
+
+fi;
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '#line 5139 "configure"' > conftest.$ac_ext
+  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+    case `/usr/bin/file conftest.$ac_objext` in
+    *32-bit*)
+      LD="${LD-ld} -32"
+      ;;
+    *N32*)
+      LD="${LD-ld} -n32"
+      ;;
+    *64-bit*)
+      LD="${LD-ld} -64"
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  echo "$as_me:$LINENO: checking whether the C compiler needs -belf" >&5
+echo $ECHO_N "checking whether the C compiler needs -belf... $ECHO_C" >&6
+if test "${lt_cv_cc_needs_belf+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+
+     ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+     cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  lt_cv_cc_needs_belf=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+lt_cv_cc_needs_belf=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+     ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+fi
+echo "$as_me:$LINENO: result: $lt_cv_cc_needs_belf" >&5
+echo "${ECHO_T}$lt_cv_cc_needs_belf" >&6
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+
+
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed='sed -e s/^X//'
+sed_quote_subst='s/\([\\"\\`$\\\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\([\\"\\`\\\\]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Constants:
+rm="rm -f"
+
+# Global variables:
+default_ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except M$VC,
+# which needs '.lib').
+libext=a
+ltmain="$ac_aux_dir/ltmain.sh"
+ofile="$default_ofile"
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+need_locks="$enable_libtool_lock"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$AR" && AR=ar
+test -z "$AR_FLAGS" && AR_FLAGS=cru
+test -z "$AS" && AS=as
+test -z "$CC" && CC=cc
+test -z "$DLLTOOL" && DLLTOOL=dlltool
+test -z "$LD" && LD=ld
+test -z "$LN_S" && LN_S="ln -s"
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+test -z "$NM" && NM=nm
+test -z "$OBJDUMP" && OBJDUMP=objdump
+test -z "$RANLIB" && RANLIB=:
+test -z "$STRIP" && STRIP=:
+test -z "$ac_objext" && ac_objext=o
+
+if test x"$host" != x"$build"; then
+  ac_tool_prefix=${host_alias}-
+else
+  ac_tool_prefix=
+fi
+
+# Transform linux* to *-*-linux-gnu*, to support old configure scripts.
+case $host_os in
+linux-gnu*) ;;
+linux*) host=`echo $host | sed 's/^\(.*-.*-linux\)\(.*\)$/\1-gnu\2/'`
+esac
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="\$RANLIB -t \$oldlib~$old_postinstall_cmds"
+    ;;
+  *)
+    old_postinstall_cmds="\$RANLIB \$oldlib~$old_postinstall_cmds"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+fi
+
+# Allow CC to be a program name with arguments.
+set dummy $CC
+compiler="$2"
+
+## FIXME: this should be a separate macro
+##
+echo "$as_me:$LINENO: checking for objdir" >&5
+echo $ECHO_N "checking for objdir... $ECHO_C" >&6
+rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  objdir=_libs
+fi
+rmdir .libs 2>/dev/null
+echo "$as_me:$LINENO: result: $objdir" >&5
+echo "${ECHO_T}$objdir" >&6
+##
+## END FIXME
+
+
+## FIXME: this should be a separate macro
+##
+
+# Check whether --with-pic or --without-pic was given.
+if test "${with_pic+set}" = set; then
+  withval="$with_pic"
+  pic_mode="$withval"
+else
+  pic_mode=default
+fi;
+test -z "$pic_mode" && pic_mode=default
+
+# We assume here that the value for lt_cv_prog_cc_pic will not be cached
+# in isolation, and that seeing it set (from the cache) indicates that
+# the associated values are set (in the cache) correctly too.
+echo "$as_me:$LINENO: checking for $compiler option to produce PIC" >&5
+echo $ECHO_N "checking for $compiler option to produce PIC... $ECHO_C" >&6
+if test "${lt_cv_prog_cc_pic+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+   lt_cv_prog_cc_pic=
+  lt_cv_prog_cc_shlib=
+  lt_cv_prog_cc_wl=
+  lt_cv_prog_cc_static=
+  lt_cv_prog_cc_no_builtin=
+  lt_cv_prog_cc_can_build_shared=$can_build_shared
+
+  if test "$GCC" = yes; then
+    lt_cv_prog_cc_wl='-Wl,'
+    lt_cv_prog_cc_static='-static'
+
+    case $host_os in
+    aix*)
+      # Below there is a dirty hack to force normal static linking with -ldl
+      # The problem is because libdl dynamically linked with both libc and
+      # libC (AIX C++ library), which obviously doesn't included in libraries
+      # list by gcc. This cause undefined symbols with -static flags.
+      # This hack allows C programs to be linked with "-static -ldl", but
+      # not sure about C++ programs.
+      lt_cv_prog_cc_static="$lt_cv_prog_cc_static ${lt_cv_prog_cc_wl}-lC"
+      ;;
+    amigaos*)
+      # FIXME: we need at least 68020 code to build shared libraries, but
+      # adding the `-m68020' flag to GCC prevents building anything better,
+      # like `-m68040'.
+      lt_cv_prog_cc_pic='-m68020 -resident32 -malways-restore-a4'
+      ;;
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_cv_prog_cc_pic='-fno-common'
+      ;;
+    cygwin* | mingw* | pw32* | os2*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_cv_prog_cc_pic='-DDLL_EXPORT'
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	 lt_cv_prog_cc_pic=-Kconform_pic
+      fi
+      ;;
+    *)
+      lt_cv_prog_cc_pic='-fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for PIC flags for the system compiler.
+    case $host_os in
+    aix3* | aix4* | aix5*)
+      lt_cv_prog_cc_wl='-Wl,'
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_cv_prog_cc_static='-Bstatic'
+      else
+	lt_cv_prog_cc_static='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      # Is there a better lt_cv_prog_cc_static that works with the bundled CC?
+      lt_cv_prog_cc_wl='-Wl,'
+      lt_cv_prog_cc_static="${lt_cv_prog_cc_wl}-a ${lt_cv_prog_cc_wl}archive"
+      lt_cv_prog_cc_pic='+Z'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      lt_cv_prog_cc_wl='-Wl,'
+      lt_cv_prog_cc_static='-non_shared'
+      # PIC (with -KPIC) is the default.
+      ;;
+
+    cygwin* | mingw* | pw32* | os2*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_cv_prog_cc_pic='-DDLL_EXPORT'
+      ;;
+
+    newsos6)
+      lt_cv_prog_cc_pic='-KPIC'
+      lt_cv_prog_cc_static='-Bstatic'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      # All OSF/1 code is PIC.
+      lt_cv_prog_cc_wl='-Wl,'
+      lt_cv_prog_cc_static='-non_shared'
+      ;;
+
+    sco3.2v5*)
+      lt_cv_prog_cc_pic='-Kpic'
+      lt_cv_prog_cc_static='-dn'
+      lt_cv_prog_cc_shlib='-belf'
+      ;;
+
+    solaris*)
+      lt_cv_prog_cc_pic='-KPIC'
+      lt_cv_prog_cc_static='-Bstatic'
+      lt_cv_prog_cc_wl='-Wl,'
+      ;;
+
+    sunos4*)
+      lt_cv_prog_cc_pic='-PIC'
+      lt_cv_prog_cc_static='-Bstatic'
+      lt_cv_prog_cc_wl='-Qoption ld '
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+      lt_cv_prog_cc_pic='-KPIC'
+      lt_cv_prog_cc_static='-Bstatic'
+      lt_cv_prog_cc_wl='-Wl,'
+      ;;
+
+    uts4*)
+      lt_cv_prog_cc_pic='-pic'
+      lt_cv_prog_cc_static='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	lt_cv_prog_cc_pic='-Kconform_pic'
+	lt_cv_prog_cc_static='-Bstatic'
+      fi
+      ;;
+
+    *)
+      lt_cv_prog_cc_can_build_shared=no
+      ;;
+    esac
+  fi
+
+fi
+
+if test -z "$lt_cv_prog_cc_pic"; then
+  echo "$as_me:$LINENO: result: none" >&5
+echo "${ECHO_T}none" >&6
+else
+  echo "$as_me:$LINENO: result: $lt_cv_prog_cc_pic" >&5
+echo "${ECHO_T}$lt_cv_prog_cc_pic" >&6
+
+  # Check to make sure the pic_flag actually works.
+  echo "$as_me:$LINENO: checking if $compiler PIC flag $lt_cv_prog_cc_pic works" >&5
+echo $ECHO_N "checking if $compiler PIC flag $lt_cv_prog_cc_pic works... $ECHO_C" >&6
+  if test "${lt_cv_prog_cc_pic_works+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      save_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS $lt_cv_prog_cc_pic -DPIC"
+    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+        case $host_os in
+      hpux9* | hpux10* | hpux11*)
+	# On HP-UX, both CC and GCC only warn that PIC is supported... then
+	# they create non-PIC objects.  So, if there were any warnings, we
+	# assume that PIC is not supported.
+	if test -s conftest.err; then
+	  lt_cv_prog_cc_pic_works=no
+	else
+	  lt_cv_prog_cc_pic_works=yes
+	fi
+	;;
+      *)
+	lt_cv_prog_cc_pic_works=yes
+	;;
+      esac
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+      lt_cv_prog_cc_pic_works=no
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+    CFLAGS="$save_CFLAGS"
+
+fi
+
+
+  if test "X$lt_cv_prog_cc_pic_works" = Xno; then
+    lt_cv_prog_cc_pic=
+    lt_cv_prog_cc_can_build_shared=no
+  else
+    lt_cv_prog_cc_pic=" $lt_cv_prog_cc_pic"
+  fi
+
+  echo "$as_me:$LINENO: result: $lt_cv_prog_cc_pic_works" >&5
+echo "${ECHO_T}$lt_cv_prog_cc_pic_works" >&6
+fi
+##
+## END FIXME
+
+# Check for any special shared library compilation flags.
+if test -n "$lt_cv_prog_cc_shlib"; then
+  { echo "$as_me:$LINENO: WARNING: \`$CC' requires \`$lt_cv_prog_cc_shlib' to build shared libraries" >&5
+echo "$as_me: WARNING: \`$CC' requires \`$lt_cv_prog_cc_shlib' to build shared libraries" >&2;}
+  if echo "$old_CC $old_CFLAGS " | egrep -e "[ 	]$lt_cv_prog_cc_shlib[ 	]" >/dev/null; then :
+  else
+   { echo "$as_me:$LINENO: WARNING: add \`$lt_cv_prog_cc_shlib' to the CC or CFLAGS env variable and reconfigure" >&5
+echo "$as_me: WARNING: add \`$lt_cv_prog_cc_shlib' to the CC or CFLAGS env variable and reconfigure" >&2;}
+    lt_cv_prog_cc_can_build_shared=no
+  fi
+fi
+
+## FIXME: this should be a separate macro
+##
+echo "$as_me:$LINENO: checking if $compiler static flag $lt_cv_prog_cc_static works" >&5
+echo $ECHO_N "checking if $compiler static flag $lt_cv_prog_cc_static works... $ECHO_C" >&6
+if test "${lt_cv_prog_cc_static_works+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+    lt_cv_prog_cc_static_works=no
+  save_LDFLAGS="$LDFLAGS"
+  LDFLAGS="$LDFLAGS $lt_cv_prog_cc_static"
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  lt_cv_prog_cc_static_works=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+  LDFLAGS="$save_LDFLAGS"
+
+fi
+
+
+# Belt *and* braces to stop my trousers falling down:
+test "X$lt_cv_prog_cc_static_works" = Xno && lt_cv_prog_cc_static=
+echo "$as_me:$LINENO: result: $lt_cv_prog_cc_static_works" >&5
+echo "${ECHO_T}$lt_cv_prog_cc_static_works" >&6
+
+pic_flag="$lt_cv_prog_cc_pic"
+special_shlib_compile_flags="$lt_cv_prog_cc_shlib"
+wl="$lt_cv_prog_cc_wl"
+link_static_flag="$lt_cv_prog_cc_static"
+no_builtin_flag="$lt_cv_prog_cc_no_builtin"
+can_build_shared="$lt_cv_prog_cc_can_build_shared"
+##
+## END FIXME
+
+
+## FIXME: this should be a separate macro
+##
+# Check to see if options -o and -c are simultaneously supported by compiler
+echo "$as_me:$LINENO: checking if $compiler supports -c -o file.$ac_objext" >&5
+echo $ECHO_N "checking if $compiler supports -c -o file.$ac_objext... $ECHO_C" >&6
+if test "${lt_cv_compiler_c_o+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+$rm -r conftest 2>/dev/null
+mkdir conftest
+cd conftest
+echo "int some_variable = 0;" > conftest.$ac_ext
+mkdir out
+# According to Tom Tromey, Ian Lance Taylor reported there are C compilers
+# that will create temporary files in the current directory regardless of
+# the output directory.  Thus, making CWD read-only will cause this test
+# to fail, enabling locking or at least warning the user not to do parallel
+# builds.
+chmod -w .
+save_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS -o out/conftest2.$ac_objext"
+compiler_c_o=no
+if { (eval echo configure:5682: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>out/conftest.err; } && test -s out/conftest2.$ac_objext; then
+  # The compiler can only warn and ignore the option if not recognized
+  # So say no if there are warnings
+  if test -s out/conftest.err; then
+    lt_cv_compiler_c_o=no
+  else
+    lt_cv_compiler_c_o=yes
+  fi
+else
+  # Append any errors to the config.log.
+  cat out/conftest.err 1>&5
+  lt_cv_compiler_c_o=no
+fi
+CFLAGS="$save_CFLAGS"
+chmod u+w .
+$rm conftest* out/*
+rmdir out
+cd ..
+rmdir conftest
+$rm -r conftest 2>/dev/null
+
+fi
+
+compiler_c_o=$lt_cv_compiler_c_o
+echo "$as_me:$LINENO: result: $compiler_c_o" >&5
+echo "${ECHO_T}$compiler_c_o" >&6
+
+if test x"$compiler_c_o" = x"yes"; then
+  # Check to see if we can write to a .lo
+  echo "$as_me:$LINENO: checking if $compiler supports -c -o file.lo" >&5
+echo $ECHO_N "checking if $compiler supports -c -o file.lo... $ECHO_C" >&6
+  if test "${lt_cv_compiler_o_lo+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+  lt_cv_compiler_o_lo=no
+  save_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -c -o conftest.lo"
+  save_objext="$ac_objext"
+  ac_objext=lo
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+int some_variable = 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+      # The compiler can only warn and ignore the option if not recognized
+    # So say no if there are warnings
+    if test -s conftest.err; then
+      lt_cv_compiler_o_lo=no
+    else
+      lt_cv_compiler_o_lo=yes
+    fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+  ac_objext="$save_objext"
+  CFLAGS="$save_CFLAGS"
+
+fi
+
+  compiler_o_lo=$lt_cv_compiler_o_lo
+  echo "$as_me:$LINENO: result: $compiler_o_lo" >&5
+echo "${ECHO_T}$compiler_o_lo" >&6
+else
+  compiler_o_lo=no
+fi
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+# Check to see if we can do hard links to lock some files if needed
+hard_links="nottested"
+if test "$compiler_c_o" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  echo "$as_me:$LINENO: checking if we can lock with hard links" >&5
+echo $ECHO_N "checking if we can lock with hard links... $ECHO_C" >&6
+  hard_links=yes
+  $rm conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  echo "$as_me:$LINENO: result: $hard_links" >&5
+echo "${ECHO_T}$hard_links" >&6
+  if test "$hard_links" = no; then
+    { echo "$as_me:$LINENO: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+if test "$GCC" = yes; then
+  # Check to see if options -fno-rtti -fno-exceptions are supported by compiler
+  echo "$as_me:$LINENO: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+echo $ECHO_N "checking if $compiler supports -fno-rtti -fno-exceptions... $ECHO_C" >&6
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  save_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -fno-rtti -fno-exceptions -c conftest.$ac_ext"
+  compiler_rtti_exceptions=no
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+int some_variable = 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+      # The compiler can only warn and ignore the option if not recognized
+    # So say no if there are warnings
+    if test -s conftest.err; then
+      compiler_rtti_exceptions=no
+    else
+      compiler_rtti_exceptions=yes
+    fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+  CFLAGS="$save_CFLAGS"
+  echo "$as_me:$LINENO: result: $compiler_rtti_exceptions" >&5
+echo "${ECHO_T}$compiler_rtti_exceptions" >&6
+
+  if test "$compiler_rtti_exceptions" = "yes"; then
+    no_builtin_flag=' -fno-builtin -fno-rtti -fno-exceptions'
+  else
+    no_builtin_flag=' -fno-builtin'
+  fi
+fi
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+# See if the linker supports building shared libraries.
+echo "$as_me:$LINENO: checking whether the linker ($LD) supports shared libraries" >&5
+echo $ECHO_N "checking whether the linker ($LD) supports shared libraries... $ECHO_C" >&6
+
+allow_undefined_flag=
+no_undefined_flag=
+need_lib_prefix=unknown
+need_version=unknown
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+archive_cmds=
+archive_expsym_cmds=
+old_archive_from_new_cmds=
+old_archive_from_expsyms_cmds=
+export_dynamic_flag_spec=
+whole_archive_flag_spec=
+thread_safe_flag_spec=
+hardcode_into_libs=no
+hardcode_libdir_flag_spec=
+hardcode_libdir_separator=
+hardcode_direct=no
+hardcode_minus_L=no
+hardcode_shlibpath_var=unsupported
+runpath_var=
+link_all_deplibs=unknown
+always_export_symbols=no
+export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | sed '\''s/.* //'\'' | sort | uniq > $export_symbols'
+# include_expsyms should be a list of space-separated symbols to be *always*
+# included in the symbol list
+include_expsyms=
+# exclude_expsyms can be an egrep regular expression of symbols to exclude
+# it will be wrapped by ` (' and `)$', so one must not match beginning or
+# end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+# as well as any symbol that contains `d'.
+exclude_expsyms="_GLOBAL_OFFSET_TABLE_"
+# Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+# platforms (ab)use it in PIC code, but their linkers get confused if
+# the symbol is explicitly referenced.  Since portable code cannot
+# rely on this symbol name, it's probably fine to never include it in
+# preloaded symbol tables.
+extract_expsyms_cmds=
+
+case $host_os in
+cygwin* | mingw* | pw32*)
+  # FIXME: the MSVC++ port hasn't been tested in a loooong time
+  # When not using gcc, we currently assume that we are using
+  # Microsoft Visual C++.
+  if test "$GCC" != yes; then
+    with_gnu_ld=no
+  fi
+  ;;
+openbsd*)
+  with_gnu_ld=no
+  ;;
+esac
+
+ld_shlibs=yes
+if test "$with_gnu_ld" = yes; then
+  # If archive_cmds runs LD, not CC, wlarc should be empty
+  wlarc='${wl}'
+
+  # See if GNU ld supports shared libraries.
+  case $host_os in
+  aix3* | aix4* | aix5*)
+    # On AIX, the GNU linker is very broken
+    # Note:Check GNU linker on AIX 5-IA64 when/if it becomes available.
+    ld_shlibs=no
+    cat <<EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.9.1, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to modify your PATH
+*** so that a non-GNU linker is found, and then restart.
+
+EOF
+    ;;
+
+  amigaos*)
+    archive_cmds='$rm $output_objdir/a2ixlibrary.data~$echo "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$echo "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$echo "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$echo "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_minus_L=yes
+
+    # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports
+    # that the semantics of dynamic libraries on AmigaOS, at least up
+    # to version 4, is to share data among multiple programs linked
+    # with the same dynamic library.  Since this doesn't match the
+    # behavior of shared libraries on other platforms, we can use
+    # them.
+    ld_shlibs=no
+    ;;
+
+  beos*)
+    if $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then
+      allow_undefined_flag=unsupported
+      # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+      # support --undefined.  This deserves some investigation.  FIXME
+      archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+    else
+      ld_shlibs=no
+    fi
+    ;;
+
+  cygwin* | mingw* | pw32*)
+    # hardcode_libdir_flag_spec is actually meaningless, as there is
+    # no search path for DLLs.
+    hardcode_libdir_flag_spec='-L$libdir'
+    allow_undefined_flag=unsupported
+    always_export_symbols=yes
+
+    extract_expsyms_cmds='test -f $output_objdir/impgen.c || \
+      sed -e "/^# \/\* impgen\.c starts here \*\//,/^# \/\* impgen.c ends here \*\// { s/^# //;s/^# *$//; p; }" -e d < $''0 > $output_objdir/impgen.c~
+      test -f $output_objdir/impgen.exe || (cd $output_objdir && \
+      if test "x$HOST_CC" != "x" ; then $HOST_CC -o impgen impgen.c ; \
+      else $CC -o impgen impgen.c ; fi)~
+      $output_objdir/impgen $dir/$soroot > $output_objdir/$soname-def'
+
+    old_archive_from_expsyms_cmds='$DLLTOOL --as=$AS --dllname $soname --def $output_objdir/$soname-def --output-lib $output_objdir/$newlib'
+
+    # cygwin and mingw dlls have different entry points and sets of symbols
+    # to exclude.
+    # FIXME: what about values for MSVC?
+    dll_entry=__cygwin_dll_entry@12
+    dll_exclude_symbols=DllMain@12,_cygwin_dll_entry@12,_cygwin_noncygwin_dll_entry@12~
+    case $host_os in
+    mingw*)
+      # mingw values
+      dll_entry=_DllMainCRTStartup@12
+      dll_exclude_symbols=DllMain@12,DllMainCRTStartup@12,DllEntryPoint@12~
+      ;;
+    esac
+
+    # mingw and cygwin differ, and it's simplest to just exclude the union
+    # of the two symbol sets.
+    dll_exclude_symbols=DllMain@12,_cygwin_dll_entry@12,_cygwin_noncygwin_dll_entry@12,DllMainCRTStartup@12,DllEntryPoint@12
+
+    # recent cygwin and mingw systems supply a stub DllMain which the user
+    # can override, but on older systems we have to supply one (in ltdll.c)
+    if test "x$lt_cv_need_dllmain" = "xyes"; then
+      ltdll_obj='$output_objdir/$soname-ltdll.'"$ac_objext "
+      ltdll_cmds='test -f $output_objdir/$soname-ltdll.c || sed -e "/^# \/\* ltdll\.c starts here \*\//,/^# \/\* ltdll.c ends here \*\// { s/^# //; p; }" -e d < $''0 > $output_objdir/$soname-ltdll.c~
+	test -f $output_objdir/$soname-ltdll.$ac_objext || (cd $output_objdir && $CC -c $soname-ltdll.c)~'
+    else
+      ltdll_obj=
+      ltdll_cmds=
+    fi
+
+    # Extract the symbol export list from an `--export-all' def file,
+    # then regenerate the def file from the symbol export list, so that
+    # the compiled dll only exports the symbol export list.
+    # Be careful not to strip the DATA tag left be newer dlltools.
+    export_symbols_cmds="$ltdll_cmds"'
+      $DLLTOOL --export-all --exclude-symbols '$dll_exclude_symbols' --output-def $output_objdir/$soname-def '$ltdll_obj'$libobjs $convenience~
+      sed -e "1,/EXPORTS/d" -e "s/ @ [0-9]*//" -e "s/ *;.*$//" < $output_objdir/$soname-def > $export_symbols'
+
+    # If the export-symbols file already is a .def file (1st line
+    # is EXPORTS), use it as is.
+    # If DATA tags from a recent dlltool are present, honour them!
+    archive_expsym_cmds='if test "x`sed 1q $export_symbols`" = xEXPORTS; then
+	cp $export_symbols $output_objdir/$soname-def;
+      else
+	echo EXPORTS > $output_objdir/$soname-def;
+	_lt_hint=1;
+	cat $export_symbols | while read symbol; do
+	 set dummy \$symbol;
+	 case \$# in
+	   2) echo "   \$2 @ \$_lt_hint ; " >> $output_objdir/$soname-def;;
+	   4) echo "   \$2 \$3 \$4 ; " >> $output_objdir/$soname-def; _lt_hint=`expr \$_lt_hint - 1`;;
+	   *) echo "     \$2 @ \$_lt_hint \$3 ; " >> $output_objdir/$soname-def;;
+	 esac;
+	 _lt_hint=`expr 1 + \$_lt_hint`;
+	done;
+      fi~
+      '"$ltdll_cmds"'
+      $CC -Wl,--base-file,$output_objdir/$soname-base '$lt_cv_cc_dll_switch' -Wl,-e,'$dll_entry' -o $output_objdir/$soname '$ltdll_obj'$libobjs $deplibs $compiler_flags~
+      $DLLTOOL --as=$AS --dllname $soname --exclude-symbols '$dll_exclude_symbols' --def $output_objdir/$soname-def --base-file $output_objdir/$soname-base --output-exp $output_objdir/$soname-exp~
+      $CC -Wl,--base-file,$output_objdir/$soname-base $output_objdir/$soname-exp '$lt_cv_cc_dll_switch' -Wl,-e,'$dll_entry' -o $output_objdir/$soname '$ltdll_obj'$libobjs $deplibs $compiler_flags~
+      $DLLTOOL --as=$AS --dllname $soname --exclude-symbols '$dll_exclude_symbols' --def $output_objdir/$soname-def --base-file $output_objdir/$soname-base --output-exp $output_objdir/$soname-exp --output-lib $output_objdir/$libname.dll.a~
+      $CC $output_objdir/$soname-exp '$lt_cv_cc_dll_switch' -Wl,-e,'$dll_entry' -o $output_objdir/$soname '$ltdll_obj'$libobjs $deplibs $compiler_flags'
+    ;;
+
+  netbsd*)
+    if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+      archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+      wlarc=
+    else
+      archive_cmds='$CC -shared -nodefaultlibs $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      archive_expsym_cmds='$CC -shared -nodefaultlibs $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+    fi
+    ;;
+
+  solaris* | sysv5*)
+    if $LD -v 2>&1 | egrep 'BFD 2\.8' > /dev/null; then
+      ld_shlibs=no
+      cat <<EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+EOF
+    elif $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then
+      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+    else
+      ld_shlibs=no
+    fi
+    ;;
+
+  sunos4*)
+    archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+    wlarc=
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  *)
+    if $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then
+      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+    else
+      ld_shlibs=no
+    fi
+    ;;
+  esac
+
+  if test "$ld_shlibs" = yes; then
+    runpath_var=LD_RUN_PATH
+    hardcode_libdir_flag_spec='${wl}--rpath ${wl}$libdir'
+    export_dynamic_flag_spec='${wl}--export-dynamic'
+    case $host_os in
+    cygwin* | mingw* | pw32*)
+      # dlltool doesn't understand --whole-archive et. al.
+      whole_archive_flag_spec=
+      ;;
+    *)
+      # ancient GNU ld didn't support --whole-archive et. al.
+      if $LD --help 2>&1 | egrep 'no-whole-archive' > /dev/null; then
+	whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+      else
+	whole_archive_flag_spec=
+      fi
+      ;;
+    esac
+  fi
+else
+  # PORTME fill in a description of your system's linker (not GNU ld)
+  case $host_os in
+  aix3*)
+    allow_undefined_flag=unsupported
+    always_export_symbols=yes
+    archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+    # Note: this linker hardcodes the directories in LIBPATH if there
+    # are no directories specified by -L.
+    hardcode_minus_L=yes
+    if test "$GCC" = yes && test -z "$link_static_flag"; then
+      # Neither direct hardcoding nor static linking is supported with a
+      # broken collect2.
+      hardcode_direct=unsupported
+    fi
+    ;;
+
+  aix4* | aix5*)
+    if test "$host_cpu" = ia64; then
+      # On IA64, the linker does run time linking by default, so we don't
+      # have to do anything special.
+      aix_use_runtimelinking=no
+      exp_sym_flag='-Bexport'
+      no_entry_flag=""
+    else
+      aix_use_runtimelinking=no
+
+      # Test if we are trying to use run time linking or normal
+      # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+      # need to do runtime linking.
+      case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+	for ld_flag in $LDFLAGS; do
+	  case $ld_flag in
+	  *-brtl*)
+	    aix_use_runtimelinking=yes
+	    break
+	  ;;
+	  esac
+	done
+      esac
+
+      exp_sym_flag='-bexport'
+      no_entry_flag='-bnoentry'
+    fi
+
+    # When large executables or shared objects are built, AIX ld can
+    # have problems creating the table of contents.  If linking a library
+    # or program results in "error TOC overflow" add -mminimal-toc to
+    # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+    # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+    hardcode_direct=yes
+    archive_cmds=''
+    hardcode_libdir_separator=':'
+    if test "$GCC" = yes; then
+      case $host_os in aix4.[012]|aix4.[012].*)
+	collect2name=`${CC} -print-prog-name=collect2`
+	if test -f "$collect2name" && \
+	  strings "$collect2name" | grep resolve_lib_name >/dev/null
+	then
+	  # We have reworked collect2
+	  hardcode_direct=yes
+	else
+	  # We have old collect2
+	  hardcode_direct=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  hardcode_minus_L=yes
+	  hardcode_libdir_flag_spec='-L$libdir'
+	  hardcode_libdir_separator=
+	fi
+      esac
+
+      shared_flag='-shared'
+    else
+      # not using gcc
+      if test "$host_cpu" = ia64; then
+	shared_flag='${wl}-G'
+      else
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag='${wl}-G'
+	else
+	  shared_flag='${wl}-bM:SRE'
+	fi
+      fi
+    fi
+
+    # It seems that -bexpall can do strange things, so it is better to
+    # generate a list of symbols to export.
+    always_export_symbols=yes
+    if test "$aix_use_runtimelinking" = yes; then
+      # Warning - without using the other runtime loading flags (-brtl),
+      # -berok will link without error, but may produce a broken library.
+      allow_undefined_flag='-berok'
+      hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:/usr/lib:/lib'
+      archive_expsym_cmds="\$CC"' -o $output_objdir/$soname $libobjs $deplibs $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then echo "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$no_entry_flag \${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+    else
+      if test "$host_cpu" = ia64; then
+	hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+	allow_undefined_flag="-z nodefs"
+	archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname ${wl}-h$soname $libobjs $deplibs $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$no_entry_flag \${wl}$exp_sym_flag:\$export_symbols"
+      else
+	hardcode_libdir_flag_spec='${wl}-bnolibpath ${wl}-blibpath:$libdir:/usr/lib:/lib'
+	# Warning - without using the other run time loading flags,
+	# -berok will link without error, but may produce a broken library.
+	allow_undefined_flag='${wl}-berok'
+	# This is a bit strange, but is similar to how AIX traditionally builds
+	# it's shared libraries.
+	archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs $compiler_flags ${allow_undefined_flag} '"\${wl}$no_entry_flag \${wl}$exp_sym_flag:\$export_symbols"' ~$AR -crlo $objdir/$libname$release.a $objdir/$soname'
+      fi
+    fi
+    ;;
+
+  amigaos*)
+    archive_cmds='$rm $output_objdir/a2ixlibrary.data~$echo "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$echo "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$echo "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$echo "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_minus_L=yes
+    # see comment about different semantics on the GNU ld section
+    ld_shlibs=no
+    ;;
+
+  cygwin* | mingw* | pw32*)
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    # hardcode_libdir_flag_spec is actually meaningless, as there is
+    # no search path for DLLs.
+    hardcode_libdir_flag_spec=' '
+    allow_undefined_flag=unsupported
+    # Tell ltmain to make .lib files, not .a files.
+    libext=lib
+    # FIXME: Setting linknames here is a bad hack.
+    archive_cmds='$CC -o $lib $libobjs $compiler_flags `echo "$deplibs" | sed -e '\''s/ -lc$//'\''` -link -dll~linknames='
+    # The linker will automatically build a .lib file if we build a DLL.
+    old_archive_from_new_cmds='true'
+    # FIXME: Should let the user specify the lib program.
+    old_archive_cmds='lib /OUT:$oldlib$oldobjs$old_deplibs'
+    fix_srcfile_path='`cygpath -w "$srcfile"`'
+    ;;
+
+  darwin* | rhapsody*)
+    case "$host_os" in
+    rhapsody* | darwin1.[012])
+      allow_undefined_flag='-undefined suppress'
+      ;;
+    *) # Darwin 1.3 on
+      allow_undefined_flag='-flat_namespace -undefined suppress'
+      ;;
+    esac
+    # FIXME: Relying on posixy $() will cause problems for
+    #        cross-compilation, but unfortunately the echo tests do not
+    #        yet detect zsh echo's removal of \ escapes.  Also zsh mangles
+    #	     `"' quotes if we put them in here... so don't!
+    archive_cmds='$CC -r -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs && $CC $(test .$module = .yes && echo -bundle || echo -dynamiclib) $allow_undefined_flag -o $lib ${lib}-master.o $deplibs$linker_flags $(test .$module != .yes && echo -install_name $rpath/$soname $verstring)'
+    # We need to add '_' to the symbols in $export_symbols first
+    #archive_expsym_cmds="$archive_cmds"' && strip -s $export_symbols'
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    whole_archive_flag_spec='-all_load $convenience'
+    ;;
+
+  freebsd1*)
+    ld_shlibs=no
+    ;;
+
+  # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+  # support.  Future versions do this automatically, but an explicit c++rt0.o
+  # does not break anything, and helps significantly (at the cost of a little
+  # extra space).
+  freebsd2.2*)
+    archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+    hardcode_libdir_flag_spec='-R$libdir'
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+  freebsd2*)
+    archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_direct=yes
+    hardcode_minus_L=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+  freebsd*)
+    archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+    hardcode_libdir_flag_spec='-R$libdir'
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  hpux9* | hpux10* | hpux11*)
+    case $host_os in
+    hpux9*) archive_cmds='$rm $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib' ;;
+    *) archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags' ;;
+    esac
+    hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+    hardcode_libdir_separator=:
+    hardcode_direct=yes
+    hardcode_minus_L=yes # Not in the search PATH, but as the default
+			 # location of the library.
+    export_dynamic_flag_spec='${wl}-E'
+    ;;
+
+  irix5* | irix6* | nonstopux*)
+    if test "$GCC" = yes; then
+      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    else
+      archive_cmds='$LD -shared $libobjs $deplibs $linker_flags -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+      hardcode_libdir_flag_spec='-rpath $libdir'
+    fi
+    hardcode_libdir_separator=:
+    link_all_deplibs=yes
+    ;;
+
+  netbsd*)
+    if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+    else
+      archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+    fi
+    hardcode_libdir_flag_spec='-R$libdir'
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  newsos6)
+    archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_direct=yes
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    hardcode_libdir_separator=:
+    hardcode_shlibpath_var=no
+    ;;
+
+  openbsd*)
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+      archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      export_dynamic_flag_spec='${wl}-E'
+    else
+      case "$host_os" in
+      openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	hardcode_libdir_flag_spec='-R$libdir'
+        ;;
+      *)
+        archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+        hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+        ;;
+      esac
+    fi
+    ;;
+
+  os2*)
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_minus_L=yes
+    allow_undefined_flag=unsupported
+    archive_cmds='$echo "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$echo "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~$echo DATA >> $output_objdir/$libname.def~$echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~$echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+    old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+    ;;
+
+  osf3*)
+    if test "$GCC" = yes; then
+      allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+      archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+    else
+      allow_undefined_flag=' -expect_unresolved \*'
+      archive_cmds='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+    fi
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    hardcode_libdir_separator=:
+    ;;
+
+  osf4* | osf5*)	# as osf3* with the addition of -msym flag
+    if test "$GCC" = yes; then
+      allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+      archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    else
+      allow_undefined_flag=' -expect_unresolved \*'
+      archive_cmds='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -msym -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+      archive_expsym_cmds='for i in `cat $export_symbols`; do printf "-exported_symbol " >> $lib.exp; echo "\$i" >> $lib.exp; done; echo "-hidden">> $lib.exp~
+      $LD -shared${allow_undefined_flag} -input $lib.exp $linker_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${objdir}/so_locations -o $lib~$rm $lib.exp'
+
+      #Both c and cxx compiler support -rpath directly
+      hardcode_libdir_flag_spec='-rpath $libdir'
+    fi
+    hardcode_libdir_separator=:
+    ;;
+
+  sco3.2v5*)
+    archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_shlibpath_var=no
+    runpath_var=LD_RUN_PATH
+    hardcode_runpath_var=yes
+    export_dynamic_flag_spec='${wl}-Bexport'
+    ;;
+
+  solaris*)
+    # gcc --version < 3.0 without binutils cannot create self contained
+    # shared libraries reliably, requiring libgcc.a to resolve some of
+    # the object symbols generated in some cases.  Libraries that use
+    # assert need libgcc.a to resolve __eprintf, for example.  Linking
+    # a copy of libgcc.a into every shared library to guarantee resolving
+    # such symbols causes other problems:  According to Tim Van Holder
+    # <tim.van.holder@pandora.be>, C++ libraries end up with a separate
+    # (to the application) exception stack for one thing.
+    no_undefined_flag=' -z defs'
+    if test "$GCC" = yes; then
+      case `$CC --version 2>/dev/null` in
+      [12].*)
+	cat <<EOF 1>&2
+
+*** Warning: Releases of GCC earlier than version 3.0 cannot reliably
+*** create self contained shared libraries on Solaris systems, without
+*** introducing a dependency on libgcc.a.  Therefore, libtool is disabling
+*** -no-undefined support, which will at least allow you to build shared
+*** libraries.  However, you may find that when you link such libraries
+*** into an application without using GCC, you have to manually add
+*** \`gcc --print-libgcc-file-name\` to the link command.  We urge you to
+*** upgrade to a newer version of GCC.  Another option is to rebuild your
+*** current GCC to use the GNU linker from GNU binutils 2.9.1 or newer.
+
+EOF
+        no_undefined_flag=
+	;;
+      esac
+    fi
+    # $CC -shared without GNU ld will not create a library from C++
+    # object files and a static libstdc++, better avoid it by now
+    archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    archive_expsym_cmds='$echo "{ global:" > $lib.exp~cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+		$LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$rm $lib.exp'
+    hardcode_libdir_flag_spec='-R$libdir'
+    hardcode_shlibpath_var=no
+    case $host_os in
+    solaris2.[0-5] | solaris2.[0-5].*) ;;
+    *) # Supported since Solaris 2.6 (maybe 2.5.1?)
+      whole_archive_flag_spec='-z allextract$convenience -z defaultextract' ;;
+    esac
+    link_all_deplibs=yes
+    ;;
+
+  sunos4*)
+    if test "x$host_vendor" = xsequent; then
+      # Use $CC to link under sequent, because it throws in some extra .o
+      # files that make .init and .fini sections work.
+      archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+    else
+      archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+    fi
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_direct=yes
+    hardcode_minus_L=yes
+    hardcode_shlibpath_var=no
+    ;;
+
+  sysv4)
+    case $host_vendor in
+      sni)
+        archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+        hardcode_direct=yes # is this really true???
+        ;;
+      siemens)
+        ## LD is ld it makes a PLAMLIB
+        ## CC just makes a GrossModule.
+        archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+        reload_cmds='$CC -r -o $output$reload_objs'
+        hardcode_direct=no
+        ;;
+      motorola)
+        archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+        hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+        ;;
+    esac
+    runpath_var='LD_RUN_PATH'
+    hardcode_shlibpath_var=no
+    ;;
+
+  sysv4.3*)
+    archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_shlibpath_var=no
+    export_dynamic_flag_spec='-Bexport'
+    ;;
+
+  sysv5*)
+    no_undefined_flag=' -z text'
+    # $CC -shared without GNU ld will not create a library from C++
+    # object files and a static libstdc++, better avoid it by now
+    archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    archive_expsym_cmds='$echo "{ global:" > $lib.exp~cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+		$LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$rm $lib.exp'
+    hardcode_libdir_flag_spec=
+    hardcode_shlibpath_var=no
+    runpath_var='LD_RUN_PATH'
+    ;;
+
+  uts4*)
+    archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_shlibpath_var=no
+    ;;
+
+  dgux*)
+    archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_libdir_flag_spec='-L$libdir'
+    hardcode_shlibpath_var=no
+    ;;
+
+  sysv4*MP*)
+    if test -d /usr/nec; then
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_shlibpath_var=no
+      runpath_var=LD_RUN_PATH
+      hardcode_runpath_var=yes
+      ld_shlibs=yes
+    fi
+    ;;
+
+  sysv4.2uw2*)
+    archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+    hardcode_direct=yes
+    hardcode_minus_L=no
+    hardcode_shlibpath_var=no
+    hardcode_runpath_var=yes
+    runpath_var=LD_RUN_PATH
+    ;;
+
+  sysv5uw7* | unixware7*)
+    no_undefined_flag='${wl}-z ${wl}text'
+    if test "$GCC" = yes; then
+      archive_cmds='$CC -shared ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+    else
+      archive_cmds='$CC -G ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+    fi
+    runpath_var='LD_RUN_PATH'
+    hardcode_shlibpath_var=no
+    ;;
+
+  *)
+    ld_shlibs=no
+    ;;
+  esac
+fi
+echo "$as_me:$LINENO: result: $ld_shlibs" >&5
+echo "${ECHO_T}$ld_shlibs" >&6
+test "$ld_shlibs" = no && can_build_shared=no
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+# Check hardcoding attributes.
+echo "$as_me:$LINENO: checking how to hardcode library paths into programs" >&5
+echo $ECHO_N "checking how to hardcode library paths into programs... $ECHO_C" >&6
+hardcode_action=
+if test -n "$hardcode_libdir_flag_spec" || \
+   test -n "$runpath_var"; then
+
+  # We can hardcode non-existant directories.
+  if test "$hardcode_direct" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$hardcode_shlibpath_var" != no &&
+     test "$hardcode_minus_L" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action=unsupported
+fi
+echo "$as_me:$LINENO: result: $hardcode_action" >&5
+echo "${ECHO_T}$hardcode_action" >&6
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+striplib=
+old_striplib=
+echo "$as_me:$LINENO: checking whether stripping libraries is possible" >&5
+echo $ECHO_N "checking whether stripping libraries is possible... $ECHO_C" >&6
+if test -n "$STRIP" && $STRIP -V 2>&1 | grep "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+##
+## END FIXME
+
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+## FIXME: this should be a separate macro
+##
+# PORTME Fill in your ld.so characteristics
+echo "$as_me:$LINENO: checking dynamic linker characteristics" >&5
+echo $ECHO_N "checking dynamic linker characteristics... $ECHO_C" >&6
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}.so$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}.so$major'
+  ;;
+
+aix4* | aix5*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}.so$major ${libname}${release}.so$versuffix $libname.so'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+	if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	     echo ' yes '
+	     echo '#endif'; } | ${CC} -E - | grep yes > /dev/null; then
+	  :
+	else
+	  can_build_shared=no
+	fi
+	;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can
+    # not hardcode correct soname into executable. Probably we can
+    # add versioning support to collect2, so additional links can
+    # be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}.so$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  hardcode_into_libs=yes
+  ;;
+
+amigaos*)
+  library_names_spec='$libname.ixlibrary $libname.a'
+  # Create ${libname}_ixlibrary.a entries in /sys/libs.
+  finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$echo "X$lib" | $Xsed -e '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $rm /sys/libs/${libname}_ixlibrary.a; $show "(cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a)"; (cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a) || exit 1; done'
+  ;;
+
+beos*)
+  library_names_spec='${libname}.so'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi4*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  export_dynamic_flag_spec=-rdynamic
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32*)
+  version_type=windows
+  need_version=no
+  need_lib_prefix=no
+  case $GCC,$host_os in
+  yes,cygwin*)
+    library_names_spec='$libname.dll.a'
+    soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | sed -e 's/[.]/-/g'`${versuffix}.dll'
+    postinstall_cmds='dlpath=`bash 2>&1 -c '\''. $dir/${file}i;echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog .libs/$dlname \$dldir/$dlname'
+    postuninstall_cmds='dldll=`bash 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $rm \$dlpath'
+    ;;
+  yes,mingw*)
+    library_names_spec='${libname}`echo ${release} | sed -e 's/[.]/-/g'`${versuffix}.dll'
+    sys_lib_search_path_spec=`$CC -print-search-dirs | grep "^libraries:" | sed -e "s/^libraries://" -e "s/;/ /g" -e "s,=/,/,g"`
+    ;;
+  yes,pw32*)
+    library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | sed -e 's/./-/g'`${versuffix}.dll'
+    ;;
+  *)
+    library_names_spec='${libname}`echo ${release} | sed -e 's/[.]/-/g'`${versuffix}.dll $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  # FIXME: Relying on posixy $() will cause problems for
+  #        cross-compilation, but unfortunately the echo tests do not
+  #        yet detect zsh echo's removal of \ escapes.
+  library_names_spec='${libname}${release}${versuffix}.$(test .$module = .yes && echo so || echo dylib) ${libname}${release}${major}.$(test .$module = .yes && echo so || echo dylib) ${libname}.$(test .$module = .yes && echo so || echo dylib)'
+  soname_spec='${libname}${release}${major}.$(test .$module = .yes && echo so || echo dylib)'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  ;;
+
+freebsd1*)
+  dynamic_linker=no
+  ;;
+
+freebsd*)
+  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so $libname.so'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}.so$versuffix $libname.so$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  *)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so${major} ${libname}.so'
+  soname_spec='${libname}${release}.so$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  dynamic_linker="$host_os dld.sl"
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  shlibpath_var=SHLIB_PATH
+  shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+  library_names_spec='${libname}${release}.sl$versuffix ${libname}${release}.sl$major $libname.sl'
+  soname_spec='${libname}${release}.sl$major'
+  # HP-UX runs *really* slowly unless shared libraries are mode 555.
+  postinstall_cmds='chmod 555 $lib'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)          version_type=irix ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}.so$major'
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major ${libname}${release}.so $libname.so'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 ") libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 ") libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 ") libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux-gnuoldld* | linux-gnuaout* | linux-gnucoff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux-gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}.so$versuffix ${libname}.so$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major ${libname}${release}.so ${libname}.so'
+    soname_spec='${libname}${release}.so$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+openbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case "$host_os" in
+    openbsd2.[89] | openbsd2.[89].*)
+      shlibpath_overrides_runpath=no
+      ;;
+    *)
+      shlibpath_overrides_runpath=yes
+      ;;
+    esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  library_names_spec='${libname}${release}.so$versuffix ${libname}.so$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+os2*)
+  libname_spec='$name'
+  need_lib_prefix=no
+  library_names_spec='$libname.dll $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_version=no
+  soname_spec='${libname}${release}.so$major'
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  hardcode_into_libs=yes
+  ;;
+
+sco3.2v5*)
+  version_type=osf
+  soname_spec='${libname}${release}.so$major'
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}.so$versuffix ${libname}.so$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+  version_type=linux
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      export_dynamic_flag_spec='${wl}-Blargedynsym'
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname.so.$versuffix $libname.so.$major $libname.so'
+    soname_spec='$libname.so.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+echo "$as_me:$LINENO: result: $dynamic_linker" >&5
+echo "${ECHO_T}$dynamic_linker" >&6
+test "$dynamic_linker" = no && can_build_shared=no
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+# Report the final consequences.
+echo "$as_me:$LINENO: checking if libtool supports shared libraries" >&5
+echo $ECHO_N "checking if libtool supports shared libraries... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $can_build_shared" >&5
+echo "${ECHO_T}$can_build_shared" >&6
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+echo "$as_me:$LINENO: checking whether to build shared libraries" >&5
+echo $ECHO_N "checking whether to build shared libraries... $ECHO_C" >&6
+test "$can_build_shared" = "no" && enable_shared=no
+
+# On AIX, shared libraries and static libraries use the same namespace, and
+# are all built from PIC.
+case "$host_os" in
+aix3*)
+  test "$enable_shared" = yes && enable_static=no
+  if test -n "$RANLIB"; then
+    archive_cmds="$archive_cmds~\$RANLIB \$lib"
+    postinstall_cmds='$RANLIB $lib'
+  fi
+  ;;
+
+aix4*)
+  if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+    test "$enable_shared" = yes && enable_static=no
+  fi
+  ;;
+esac
+echo "$as_me:$LINENO: result: $enable_shared" >&5
+echo "${ECHO_T}$enable_shared" >&6
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+echo "$as_me:$LINENO: checking whether to build static libraries" >&5
+echo $ECHO_N "checking whether to build static libraries... $ECHO_C" >&6
+# Make sure either enable_shared or enable_static is yes.
+test "$enable_shared" = yes || enable_static=yes
+echo "$as_me:$LINENO: result: $enable_static" >&5
+echo "${ECHO_T}$enable_static" >&6
+##
+## END FIXME
+
+if test "$hardcode_action" = relink; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  cygwin* | mingw* | pw32*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+   ;;
+
+  *)
+    echo "$as_me:$LINENO: checking for shl_load" >&5
+echo $ECHO_N "checking for shl_load... $ECHO_C" >&6
+if test "${ac_cv_func_shl_load+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char shl_load (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char shl_load ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_shl_load) || defined (__stub___shl_load)
+choke me
+#else
+char (*f) () = shl_load;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != shl_load;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_shl_load=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_shl_load=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_shl_load" >&5
+echo "${ECHO_T}$ac_cv_func_shl_load" >&6
+if test $ac_cv_func_shl_load = yes; then
+  lt_cv_dlopen="shl_load"
+else
+  echo "$as_me:$LINENO: checking for shl_load in -ldld" >&5
+echo $ECHO_N "checking for shl_load in -ldld... $ECHO_C" >&6
+if test "${ac_cv_lib_dld_shl_load+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char shl_load ();
+int
+main ()
+{
+shl_load ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dld_shl_load=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_dld_shl_load=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_dld_shl_load" >&5
+echo "${ECHO_T}$ac_cv_lib_dld_shl_load" >&6
+if test $ac_cv_lib_dld_shl_load = yes; then
+  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-dld"
+else
+  echo "$as_me:$LINENO: checking for dlopen" >&5
+echo $ECHO_N "checking for dlopen... $ECHO_C" >&6
+if test "${ac_cv_func_dlopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char dlopen (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dlopen ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_dlopen) || defined (__stub___dlopen)
+choke me
+#else
+char (*f) () = dlopen;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != dlopen;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_dlopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_dlopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_dlopen" >&5
+echo "${ECHO_T}$ac_cv_func_dlopen" >&6
+if test $ac_cv_func_dlopen = yes; then
+  lt_cv_dlopen="dlopen"
+else
+  echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
+echo $ECHO_N "checking for dlopen in -ldl... $ECHO_C" >&6
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dlopen ();
+int
+main ()
+{
+dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dl_dlopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_dl_dlopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
+echo "${ECHO_T}$ac_cv_lib_dl_dlopen" >&6
+if test $ac_cv_lib_dl_dlopen = yes; then
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+  echo "$as_me:$LINENO: checking for dlopen in -lsvld" >&5
+echo $ECHO_N "checking for dlopen in -lsvld... $ECHO_C" >&6
+if test "${ac_cv_lib_svld_dlopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsvld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dlopen ();
+int
+main ()
+{
+dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_svld_dlopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_svld_dlopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_svld_dlopen" >&5
+echo "${ECHO_T}$ac_cv_lib_svld_dlopen" >&6
+if test $ac_cv_lib_svld_dlopen = yes; then
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
+else
+  echo "$as_me:$LINENO: checking for dld_link in -ldld" >&5
+echo $ECHO_N "checking for dld_link in -ldld... $ECHO_C" >&6
+if test "${ac_cv_lib_dld_dld_link+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dld_link ();
+int
+main ()
+{
+dld_link ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dld_dld_link=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_dld_dld_link=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_dld_dld_link" >&5
+echo "${ECHO_T}$ac_cv_lib_dld_dld_link" >&6
+if test $ac_cv_lib_dld_dld_link = yes; then
+  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-dld"
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+        test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    echo "$as_me:$LINENO: checking whether a program can dlopen itself" >&5
+echo $ECHO_N "checking whether a program can dlopen itself... $ECHO_C" >&6
+if test "${lt_cv_dlopen_self+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self=cross
+else
+    lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<EOF
+#line 7552 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+#ifdef __cplusplus
+extern "C" void exit (int);
+#endif
+
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
+
+    exit (status);
+}
+EOF
+  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_unknown|x*) lt_cv_dlopen_self=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+echo "$as_me:$LINENO: result: $lt_cv_dlopen_self" >&5
+echo "${ECHO_T}$lt_cv_dlopen_self" >&6
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      LDFLAGS="$LDFLAGS $link_static_flag"
+      echo "$as_me:$LINENO: checking whether a statically linked program can dlopen itself" >&5
+echo $ECHO_N "checking whether a statically linked program can dlopen itself... $ECHO_C" >&6
+if test "${lt_cv_dlopen_self_static+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self_static=cross
+else
+    lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<EOF
+#line 7650 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+#ifdef __cplusplus
+extern "C" void exit (int);
+#endif
+
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
+
+    exit (status);
+}
+EOF
+  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_unknown|x*) lt_cv_dlopen_self_static=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self_static=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+echo "$as_me:$LINENO: result: $lt_cv_dlopen_self_static" >&5
+echo "${ECHO_T}$lt_cv_dlopen_self_static" >&6
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+
+
+## FIXME: this should be a separate macro
+##
+if test "$enable_shared" = yes && test "$GCC" = yes; then
+  case $archive_cmds in
+  *'~'*)
+    # FIXME: we may have to deal with multi-command sequences.
+    ;;
+  '$CC '*)
+    # Test whether the compiler implicitly links with -lc since on some
+    # systems, -lgcc has to come before -lc. If gcc already passes -lc
+    # to ld, don't add -lc before -lgcc.
+    echo "$as_me:$LINENO: checking whether -lc should be explicitly linked in" >&5
+echo $ECHO_N "checking whether -lc should be explicitly linked in... $ECHO_C" >&6
+    if test "${lt_cv_archive_cmds_need_lc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  $rm conftest*
+    echo 'static int dummy;' > conftest.$ac_ext
+
+    if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+      soname=conftest
+      lib=conftest
+      libobjs=conftest.$ac_objext
+      deplibs=
+      wl=$lt_cv_prog_cc_wl
+      compiler_flags=-v
+      linker_flags=-v
+      verstring=
+      output_objdir=.
+      libname=conftest
+      save_allow_undefined_flag=$allow_undefined_flag
+      allow_undefined_flag=
+      if { (eval echo "$as_me:$LINENO: \"$archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\"") >&5
+  (eval $archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }
+      then
+	lt_cv_archive_cmds_need_lc=no
+      else
+	lt_cv_archive_cmds_need_lc=yes
+      fi
+      allow_undefined_flag=$save_allow_undefined_flag
+    else
+      cat conftest.err 1>&5
+    fi
+fi
+
+    echo "$as_me:$LINENO: result: $lt_cv_archive_cmds_need_lc" >&5
+echo "${ECHO_T}$lt_cv_archive_cmds_need_lc" >&6
+    ;;
+  esac
+fi
+need_lc=${lt_cv_archive_cmds_need_lc-yes}
+##
+## END FIXME
+
+## FIXME: this should be a separate macro
+##
+# The second clause should only fire when bootstrapping the
+# libtool distribution, otherwise you forgot to ship ltmain.sh
+# with your package, and you will get complaints that there are
+# no rules to generate ltmain.sh.
+if test -f "$ltmain"; then
+  :
+else
+  # If there is no Makefile yet, we rely on a make rule to execute
+  # `config.status --recheck' to rerun these tests and create the
+  # libtool script then.
+  test -f Makefile && make "$ltmain"
+fi
+
+if test -f "$ltmain"; then
+  trap "$rm \"${ofile}T\"; exit 1" 1 2 15
+  $rm -f "${ofile}T"
+
+  echo creating $ofile
+
+  # Now quote all the things that may contain metacharacters while being
+  # careful not to overquote the AC_SUBSTed values.  We take copies of the
+  # variables and quote the copies for generation of the libtool script.
+  for var in echo old_CC old_CFLAGS SED \
+    AR AR_FLAGS CC LD LN_S NM SHELL \
+    reload_flag reload_cmds wl \
+    pic_flag link_static_flag no_builtin_flag export_dynamic_flag_spec \
+    thread_safe_flag_spec whole_archive_flag_spec libname_spec \
+    library_names_spec soname_spec \
+    RANLIB old_archive_cmds old_archive_from_new_cmds old_postinstall_cmds \
+    old_postuninstall_cmds archive_cmds archive_expsym_cmds postinstall_cmds \
+    postuninstall_cmds extract_expsyms_cmds old_archive_from_expsyms_cmds \
+    old_striplib striplib file_magic_cmd export_symbols_cmds \
+    deplibs_check_method allow_undefined_flag no_undefined_flag \
+    finish_cmds finish_eval global_symbol_pipe global_symbol_to_cdecl \
+    global_symbol_to_c_name_address \
+    hardcode_libdir_flag_spec hardcode_libdir_separator  \
+    sys_lib_search_path_spec sys_lib_dlsearch_path_spec \
+    compiler_c_o compiler_o_lo need_locks exclude_expsyms include_expsyms; do
+
+    case $var in
+    reload_cmds | old_archive_cmds | old_archive_from_new_cmds | \
+    old_postinstall_cmds | old_postuninstall_cmds | \
+    export_symbols_cmds | archive_cmds | archive_expsym_cmds | \
+    extract_expsyms_cmds | old_archive_from_expsyms_cmds | \
+    postinstall_cmds | postuninstall_cmds | \
+    finish_cmds | sys_lib_search_path_spec | sys_lib_dlsearch_path_spec)
+      # Double-quote double-evaled strings.
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$double_quote_subst\" -e \"\$sed_quote_subst\" -e \"\$delay_variable_subst\"\`\\\""
+      ;;
+    *)
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$sed_quote_subst\"\`\\\""
+      ;;
+    esac
+  done
+
+  cat <<__EOF__ > "${ofile}T"
+#! $SHELL
+
+# `$echo "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $PROGRAM (GNU $PACKAGE $VERSION$TIMESTAMP)
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+# Copyright (C) 1996-2000 Free Software Foundation, Inc.
+# Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# A sed that does not truncate output.
+SED=$lt_SED
+
+# Sed that helps us avoid accidentally triggering echo(1) options like -n.
+Xsed="${SED} -e s/^X//"
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+if test "X\${CDPATH+set}" = Xset; then CDPATH=:; export CDPATH; fi
+
+# ### BEGIN LIBTOOL CONFIG
+
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
+
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
+
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$need_lc
+
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
+
+# The host system.
+host_alias=$host_alias
+host=$host
+
+# An echo program that does not interpret backslashes.
+echo=$lt_echo
+
+# The archiver.
+AR=$lt_AR
+AR_FLAGS=$lt_AR_FLAGS
+
+# The default C compiler.
+CC=$lt_CC
+
+# Is the compiler the GNU C compiler?
+with_gcc=$GCC
+
+# The linker used to build libraries.
+LD=$lt_LD
+
+# Whether we need hard or soft links.
+LN_S=$lt_LN_S
+
+# A BSD-compatible nm program.
+NM=$lt_NM
+
+# A symbol stripping program
+STRIP=$STRIP
+
+# Used to examine libraries when file_magic_cmd begins "file"
+MAGIC_CMD=$MAGIC_CMD
+
+# Used on cygwin: DLL creation program.
+DLLTOOL="$DLLTOOL"
+
+# Used on cygwin: object dumper.
+OBJDUMP="$OBJDUMP"
+
+# Used on cygwin: assembler.
+AS="$AS"
+
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
+
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
+
+# How to pass a linker flag through the compiler.
+wl=$lt_wl
+
+# Object file suffix (normally "o").
+objext="$ac_objext"
+
+# Old archive suffix (normally "a").
+libext="$libext"
+
+# Executable file suffix (normally "").
+exeext="$exeext"
+
+# Additional compiler flags for building library objects.
+pic_flag=$lt_pic_flag
+pic_mode=$pic_mode
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_compiler_c_o
+
+# Can we write directly to a .lo ?
+compiler_o_lo=$lt_compiler_o_lo
+
+# Must we lock files when doing compilation ?
+need_locks=$lt_need_locks
+
+# Do we need the lib prefix for modules?
+need_lib_prefix=$need_lib_prefix
+
+# Do we need a version for libraries?
+need_version=$need_version
+
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
+
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
+
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_link_static_flag
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_no_builtin_flag
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec
+
+# Compiler flag to generate thread-safe objects.
+thread_safe_flag_spec=$lt_thread_safe_flag_spec
+
+# Library versioning type.
+version_type=$version_type
+
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME.
+library_names_spec=$lt_library_names_spec
+
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
+
+# Commands used to build and install an old-style archive.
+RANLIB=$lt_RANLIB
+old_archive_cmds=$lt_old_archive_cmds
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
+
+# Commands used to build and install a shared archive.
+archive_cmds=$lt_archive_cmds
+archive_expsym_cmds=$lt_archive_expsym_cmds
+postinstall_cmds=$lt_postinstall_cmds
+postuninstall_cmds=$lt_postuninstall_cmds
+
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
+
+# Command to use when deplibs_check_method == file_magic.
+file_magic_cmd=$lt_file_magic_cmd
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag
+
+# Flag that forces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
+
+# Same as above, but a single script fragment to be evaled but not shown.
+finish_eval=$lt_finish_eval
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_global_symbol_pipe
+
+# Transform the output of nm in a proper C declaration
+global_symbol_to_cdecl=$lt_global_symbol_to_cdecl
+
+# Transform the output of nm in a C name address pair
+global_symbol_to_c_name_address=$lt_global_symbol_to_c_name_address
+
+# This is the shared library runtime path variable.
+runpath_var=$runpath_var
+
+# This is the shared library path variable.
+shlibpath_var=$shlibpath_var
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator
+
+# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct=$hardcode_direct
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L=$hardcode_minus_L
+
+# Set to yes if using SHLIBPATH_VAR=DIR during linking hardcodes DIR into
+# the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at relink time.
+variables_saved_for_relink="$variables_saved_for_relink"
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs
+
+# Compile-time system search path for libraries
+sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
+
+# Run-time system search path for libraries
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
+
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path="$fix_srcfile_path"
+
+# Set to yes if exported symbols are required.
+always_export_symbols=$always_export_symbols
+
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms
+
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms
+
+# ### END LIBTOOL CONFIG
+
+__EOF__
+
+  case $host_os in
+  aix3*)
+    cat <<\EOF >> "${ofile}T"
+
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+EOF
+    ;;
+  esac
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | os2*)
+    cat <<'EOF' >> "${ofile}T"
+      # This is a source program that is used to create dlls on Windows
+      # Don't remove nor modify the starting and closing comments
+# /* ltdll.c starts here */
+# #define WIN32_LEAN_AND_MEAN
+# #include <windows.h>
+# #undef WIN32_LEAN_AND_MEAN
+# #include <stdio.h>
+#
+# #ifndef __CYGWIN__
+# #  ifdef __CYGWIN32__
+# #    define __CYGWIN__ __CYGWIN32__
+# #  endif
+# #endif
+#
+# #ifdef __cplusplus
+# extern "C" {
+# #endif
+# BOOL APIENTRY DllMain (HINSTANCE hInst, DWORD reason, LPVOID reserved);
+# #ifdef __cplusplus
+# }
+# #endif
+#
+# #ifdef __CYGWIN__
+# #include <cygwin/cygwin_dll.h>
+# DECLARE_CYGWIN_DLL( DllMain );
+# #endif
+# HINSTANCE __hDllInstance_base;
+#
+# BOOL APIENTRY
+# DllMain (HINSTANCE hInst, DWORD reason, LPVOID reserved)
+# {
+#   __hDllInstance_base = hInst;
+#   return TRUE;
+# }
+# /* ltdll.c ends here */
+	# This is a source program that is used to create import libraries
+	# on Windows for dlls which lack them. Don't remove nor modify the
+	# starting and closing comments
+# /* impgen.c starts here */
+# /*   Copyright (C) 1999-2000 Free Software Foundation, Inc.
+#
+#  This file is part of GNU libtool.
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 2 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program; if not, write to the Free Software
+#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#  */
+#
+# #include <stdio.h>		/* for printf() */
+# #include <unistd.h>		/* for open(), lseek(), read() */
+# #include <fcntl.h>		/* for O_RDONLY, O_BINARY */
+# #include <string.h>		/* for strdup() */
+#
+# /* O_BINARY isn't required (or even defined sometimes) under Unix */
+# #ifndef O_BINARY
+# #define O_BINARY 0
+# #endif
+#
+# static unsigned int
+# pe_get16 (fd, offset)
+#      int fd;
+#      int offset;
+# {
+#   unsigned char b[2];
+#   lseek (fd, offset, SEEK_SET);
+#   read (fd, b, 2);
+#   return b[0] + (b[1]<<8);
+# }
+#
+# static unsigned int
+# pe_get32 (fd, offset)
+#     int fd;
+#     int offset;
+# {
+#   unsigned char b[4];
+#   lseek (fd, offset, SEEK_SET);
+#   read (fd, b, 4);
+#   return b[0] + (b[1]<<8) + (b[2]<<16) + (b[3]<<24);
+# }
+#
+# static unsigned int
+# pe_as32 (ptr)
+#      void *ptr;
+# {
+#   unsigned char *b = ptr;
+#   return b[0] + (b[1]<<8) + (b[2]<<16) + (b[3]<<24);
+# }
+#
+# int
+# main (argc, argv)
+#     int argc;
+#     char *argv[];
+# {
+#     int dll;
+#     unsigned long pe_header_offset, opthdr_ofs, num_entries, i;
+#     unsigned long export_rva, export_size, nsections, secptr, expptr;
+#     unsigned long name_rvas, nexp;
+#     unsigned char *expdata, *erva;
+#     char *filename, *dll_name;
+#
+#     filename = argv[1];
+#
+#     dll = open(filename, O_RDONLY|O_BINARY);
+#     if (dll < 1)
+# 	return 1;
+#
+#     dll_name = filename;
+#
+#     for (i=0; filename[i]; i++)
+# 	if (filename[i] == '/' || filename[i] == '\\'  || filename[i] == ':')
+# 	    dll_name = filename + i +1;
+#
+#     pe_header_offset = pe_get32 (dll, 0x3c);
+#     opthdr_ofs = pe_header_offset + 4 + 20;
+#     num_entries = pe_get32 (dll, opthdr_ofs + 92);
+#
+#     if (num_entries < 1) /* no exports */
+# 	return 1;
+#
+#     export_rva = pe_get32 (dll, opthdr_ofs + 96);
+#     export_size = pe_get32 (dll, opthdr_ofs + 100);
+#     nsections = pe_get16 (dll, pe_header_offset + 4 +2);
+#     secptr = (pe_header_offset + 4 + 20 +
+# 	      pe_get16 (dll, pe_header_offset + 4 + 16));
+#
+#     expptr = 0;
+#     for (i = 0; i < nsections; i++)
+#     {
+# 	char sname[8];
+# 	unsigned long secptr1 = secptr + 40 * i;
+# 	unsigned long vaddr = pe_get32 (dll, secptr1 + 12);
+# 	unsigned long vsize = pe_get32 (dll, secptr1 + 16);
+# 	unsigned long fptr = pe_get32 (dll, secptr1 + 20);
+# 	lseek(dll, secptr1, SEEK_SET);
+# 	read(dll, sname, 8);
+# 	if (vaddr <= export_rva && vaddr+vsize > export_rva)
+# 	{
+# 	    expptr = fptr + (export_rva - vaddr);
+# 	    if (export_rva + export_size > vaddr + vsize)
+# 		export_size = vsize - (export_rva - vaddr);
+# 	    break;
+# 	}
+#     }
+#
+#     expdata = (unsigned char*)malloc(export_size);
+#     lseek (dll, expptr, SEEK_SET);
+#     read (dll, expdata, export_size);
+#     erva = expdata - export_rva;
+#
+#     nexp = pe_as32 (expdata+24);
+#     name_rvas = pe_as32 (expdata+32);
+#
+#     printf ("EXPORTS\n");
+#     for (i = 0; i<nexp; i++)
+#     {
+# 	unsigned long name_rva = pe_as32 (erva+name_rvas+i*4);
+# 	printf ("\t%s @ %ld ;\n", erva+name_rva, 1+ i);
+#     }
+#
+#     return 0;
+# }
+# /* impgen.c ends here */
+
+EOF
+    ;;
+  esac
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '$q' "$ltmain" >> "${ofile}T" || (rm -f "${ofile}T"; exit 1)
+
+  mv -f "${ofile}T" "$ofile" || \
+    (rm -f "$ofile" && cp "${ofile}T" "$ofile" && rm -f "${ofile}T")
+  chmod +x "$ofile"
+fi
+##
+## END FIXME
+
+
+
+
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ac_aux_dir/ltmain.sh"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+
+# Prevent multiple expansion
+
+
+
+
+# Checks for programs.
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# ./install, which can be erroneously created by make from ./install.sh.
+echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+        if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+          if test $ac_prog = install &&
+            grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+            # AIX install.  It has an incompatible calling convention.
+            :
+          elif test $ac_prog = install &&
+            grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+            # program-specific install script used by HP pwplus--don't use.
+            :
+          else
+            ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+            break 3
+          fi
+        fi
+      done
+    done
+    ;;
+esac
+done
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL=$ac_install_sh
+  fi
+fi
+echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+echo "$as_me:$LINENO: checking whether ln -s works" >&5
+echo $ECHO_N "checking whether ln -s works... $ECHO_C" >&6
+LN_S=$as_ln_s
+if test "$LN_S" = "ln -s"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+  echo "$as_me:$LINENO: result: no, using $LN_S" >&5
+echo "${ECHO_T}no, using $LN_S" >&6
+fi
+
+echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,./+-,__p_,'`
+if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.make <<\_ACEOF
+all:
+	@echo 'ac_maketemp="$(MAKE)"'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+eval `${MAKE-make} -f conftest.make 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
+rm -f conftest.make
+fi
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  SET_MAKE=
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+# Extract the first word of "ps", so it can be a program name with args.
+set dummy ps; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_PSPROG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $PSPROG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PSPROG="$PSPROG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_PSPROG="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  ;;
+esac
+fi
+PSPROG=$ac_cv_path_PSPROG
+
+if test -n "$PSPROG"; then
+  echo "$as_me:$LINENO: result: $PSPROG" >&5
+echo "${ECHO_T}$PSPROG" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+# Extract the first word of "perl", so it can be a program name with args.
+set dummy perl; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_PERLPROG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $PERLPROG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PERLPROG="$PERLPROG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_PERLPROG="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  ;;
+esac
+fi
+PERLPROG=$ac_cv_path_PERLPROG
+
+if test -n "$PERLPROG"; then
+  echo "$as_me:$LINENO: result: $PERLPROG" >&5
+echo "${ECHO_T}$PERLPROG" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+for ac_prog in whoami logname
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_WHOAMI+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$WHOAMI"; then
+  ac_cv_prog_WHOAMI="$WHOAMI" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_WHOAMI="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+WHOAMI=$ac_cv_prog_WHOAMI
+if test -n "$WHOAMI"; then
+  echo "$as_me:$LINENO: result: $WHOAMI" >&5
+echo "${ECHO_T}$WHOAMI" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$WHOAMI" && break
+done
+test -n "$WHOAMI" || WHOAMI="whoami"
+
+for ac_prog in sed gsed
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_SED+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$SED"; then
+  ac_cv_prog_SED="$SED" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_SED="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+SED=$ac_cv_prog_SED
+if test -n "$SED"; then
+  echo "$as_me:$LINENO: result: $SED" >&5
+echo "${ECHO_T}$SED" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$SED" && break
+done
+
+# Extract the first word of "autoconf", so it can be a program name with args.
+set dummy autoconf; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_AUTOCONF+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$AUTOCONF"; then
+  ac_cv_prog_AUTOCONF="$AUTOCONF" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AUTOCONF=""
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+AUTOCONF=$ac_cv_prog_AUTOCONF
+if test -n "$AUTOCONF"; then
+  echo "$as_me:$LINENO: result: $AUTOCONF" >&5
+echo "${ECHO_T}$AUTOCONF" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+# Extract the first word of "autoheader", so it can be a program name with args.
+set dummy autoheader; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_AUTOHEADER+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$AUTOHEADER"; then
+  ac_cv_prog_AUTOHEADER="$AUTOHEADER" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AUTOHEADER=""
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+AUTOHEADER=$ac_cv_prog_AUTOHEADER
+if test -n "$AUTOHEADER"; then
+  echo "$as_me:$LINENO: result: $AUTOHEADER" >&5
+echo "${ECHO_T}$AUTOHEADER" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+if test "x$ac_cv_prog_AUTOCONF" = "x"; then
+	AUTOCONF=":"
+
+fi
+if test "x$ac_cv_prog_AUTOHEADER" = "x"; then
+	AUTOHEADER=":"
+
+fi
+
+# Extract the first word of "uname", so it can be a program name with args.
+set dummy uname; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_UNAMEPROG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $UNAMEPROG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_UNAMEPROG="$UNAMEPROG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_UNAMEPROG="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  ;;
+esac
+fi
+UNAMEPROG=$ac_cv_path_UNAMEPROG
+
+if test -n "$UNAMEPROG"; then
+  echo "$as_me:$LINENO: result: $UNAMEPROG" >&5
+echo "${ECHO_T}$UNAMEPROG" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define UNAMEPROG "$UNAMEPROG"
+_ACEOF
+
+
+echo "$as_me:$LINENO: checking for an ANSI C-conforming const" >&5
+echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6
+if test "${ac_cv_c_const+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+/* FIXME: Include the comments suggested by Paul. */
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this.  */
+  typedef int charset[2];
+  const charset x;
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *ccp;
+  char **p;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = "string";
+  ccp = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++ccp;
+  p = (char**) ccp;
+  ccp = (char const *const *) p;
+  { /* SCO 3.2v4 cc rejects this.  */
+    char *t;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this saying
+       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; };
+    struct s *b; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+  }
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_const=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_c_const=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
+echo "${ECHO_T}$ac_cv_c_const" >&6
+if test $ac_cv_c_const = no; then
+
+cat >>confdefs.h <<\_ACEOF
+#define const
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for inline" >&5
+echo $ECHO_N "checking for inline... $ECHO_C" >&6
+if test "${ac_cv_c_inline+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifndef __cplusplus
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
+#endif
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_inline=$ac_kw; break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+done
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
+echo "${ECHO_T}$ac_cv_c_inline" >&6
+case $ac_cv_c_inline in
+  inline | yes) ;;
+  no)
+cat >>confdefs.h <<\_ACEOF
+#define inline
+_ACEOF
+ ;;
+  *)  cat >>confdefs.h <<_ACEOF
+#define inline $ac_cv_c_inline
+_ACEOF
+ ;;
+esac
+
+
+# get version number.
+echo "$as_me:$LINENO: checking for net-snmp version number" >&5
+echo $ECHO_N "checking for net-snmp version number... $ECHO_C" >&6
+VERSION=`grep NetSnmpVersionInfo.*= $srcdir/snmplib/snmp_version.c | sed 's/";.*//;s/.*"//;s/pre/0./;'`
+
+RELEASEVERSION=`echo $VERSION | sed 's/^\([0-9]\)\.\([0-9]\)/\1:\2:0/'`
+
+
+
+echo "$as_me:$LINENO: result: $VERSION" >&5
+echo "${ECHO_T}$VERSION" >&6
+
+  cat >> configure-summary << EOF
+  Net-SNMP Version:           $VERSION
+EOF
+
+
+# super type checking
+# WWWXXX
+echo "$as_me:$LINENO: checking for developer gcc flags" >&5
+echo $ECHO_N "checking for developer gcc flags... $ECHO_C" >&6
+if test "x$developer" = "xyes" -a "x$GCC" = "xyes"; then
+  DEVFLAGS="-Wall -Winline -Wstrict-prototypes -Wwrite-strings -Wcast-qual -Wno-char-subscripts"
+else
+  DEVFLAGS=""
+fi
+echo "$as_me:$LINENO: result: $DEVFLAGS" >&5
+echo "${ECHO_T}$DEVFLAGS" >&6
+
+
+# system check
+echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6
+if test "${ac_cv_target+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_target_alias=$target_alias
+test "x$ac_cv_target_alias" = "x" &&
+  ac_cv_target_alias=$ac_cv_host_alias
+ac_cv_target=`$ac_config_sub $ac_cv_target_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_target_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6
+target=$ac_cv_target
+target_cpu=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+PARTIALTARGETOS=`echo $target_os | sed 's/[-._].*//'`
+CFLAGS="$CFLAGS -D$PARTIALTARGETOS -Os -mips2 -mtune=4kc -Wall"
+
+
+  cat >> configure-summary << EOF
+  Building for:               $PARTIALTARGETOS
+EOF
+
+
+#
+# check for special includes and pick one
+#
+
+echo "$as_me:$LINENO: checking for system include file" >&5
+echo $ECHO_N "checking for system include file... $ECHO_C" >&6
+
+filebase=$target_os
+# ignore binary format indication
+filebase=`echo $filebase | sed 's/elf//'`
+filebase=`echo $filebase | sed 's/aout//'`
+filebase=`echo $filebase | sed 's/ecoff//'`
+filebase=`echo $filebase | sed 's/coff//'`
+while test "x$filebase" != "x$last" -a ! -f $srcdir/include/net-snmp/system/$filebase.h
+do
+    last=$filebase
+    filebase=`echo $filebase | sed 's/[-._][^-._]*$//'`
+    if test "x$filebase" = "x$last"; then
+	filebase=`echo $filebase | sed 's/[0-9]*$//'`
+    fi
+done
+
+if test "x$filebase" = "x$last"; then
+    filebase="generic"
+fi
+ac_cv_SYSTEM_INCLUDE_FILE="net-snmp/system/$filebase.h"
+
+
+echo "$as_me:$LINENO: result: $ac_cv_SYSTEM_INCLUDE_FILE" >&5
+echo "${ECHO_T}$ac_cv_SYSTEM_INCLUDE_FILE" >&6
+cat >>confdefs.h <<_ACEOF
+#define SYSTEM_INCLUDE_FILE "$ac_cv_SYSTEM_INCLUDE_FILE"
+_ACEOF
+
+
+# second part, the CPU type.
+
+echo "$as_me:$LINENO: checking for machine-type include file" >&5
+echo $ECHO_N "checking for machine-type include file... $ECHO_C" >&6
+
+filebase=$target_cpu
+while test "x$filebase" != "x$last" -a ! -f $srcdir/include/net-snmp/machine/$filebase.h
+do
+    last=$filebase
+    filebase=`echo $filebase | sed 's/[-._][^-._]*$//'`
+done
+
+if test "x$filebase" = "x$last"; then
+    filebase="generic"
+fi
+ac_cv_MACHINE_INCLUDE_FILE="net-snmp/machine/$filebase.h"
+
+echo "$as_me:$LINENO: result: $ac_cv_MACHINE_INCLUDE_FILE" >&5
+echo "${ECHO_T}$ac_cv_MACHINE_INCLUDE_FILE" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define MACHINE_INCLUDE_FILE "$ac_cv_MACHINE_INCLUDE_FILE"
+_ACEOF
+
+
+# Extract the first word of "$CC", so it can be a program name with args.
+set dummy $CC; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_CCPATH+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $CCPATH in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_CCPATH="$CCPATH" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_CCPATH="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  ;;
+esac
+fi
+CCPATH=$ac_cv_path_CCPATH
+
+if test -n "$CCPATH"; then
+  echo "$as_me:$LINENO: result: $CCPATH" >&5
+echo "${ECHO_T}$CCPATH" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+# watch out for /usr/ucb/cc on solaris, it doesn't work with this package.
+case $target_os in
+    bsdi*)
+	if test "x$CCPATH" = "x/usr/ucb/cc" -o "x$CCPATH" = "x/usr/bin/cc"; then
+	    { { echo "$as_me:$LINENO: error:
+
+*** The BSDI /usr/ucb/cc compiler does not work with this package.
+*** Please run configure with --with-cc=gcc
+" >&5
+echo "$as_me: error:
+
+*** The BSDI /usr/ucb/cc compiler does not work with this package.
+*** Please run configure with --with-cc=gcc
+" >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+    ;;
+    solaris*)
+	if test "x$CCPATH" = "x/usr/ucb/cc"; then
+	    { { echo "$as_me:$LINENO: error:
+
+*** The solaris /usr/ucb/cc compiler does not work with this package.
+*** Please put a different compiler in your path first or run
+*** configure with --with-cc=XX, where XX is the compiler you want to use.
+" >&5
+echo "$as_me: error:
+
+*** The solaris /usr/ucb/cc compiler does not work with this package.
+*** Please put a different compiler in your path first or run
+*** configure with --with-cc=XX, where XX is the compiler you want to use.
+" >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+    ;;
+esac
+
+echo "$as_me:$LINENO: checking for additional cpp flags" >&5
+echo $ECHO_N "checking for additional cpp flags... $ECHO_C" >&6
+# gcc extra CPPFLAGS
+if test "x$GCC" = "xyes" -a "x$CPP" = "x$CC -E"; then
+  # extra cpp flags for gnu c compiler to allow .in file extensions.
+  EXTRACPPFLAGS="-x c"
+else
+  EXTRACPPFLAGS=""
+fi
+
+# Solaris extra cpp flags.
+if test "x$GCC" != "xyes"; then
+  case $target_os in
+    solaris*) EXTRACPPFLAGS="$EXTRACPPFLAGS -Xs" ;;
+  esac
+fi
+
+
+echo "$as_me:$LINENO: result: $EXTRACPPFLAGS" >&5
+echo "${ECHO_T}$EXTRACPPFLAGS" >&6
+
+# Prefixes must begin with "/"
+
+if test "x$prefix" = "xNONE"; then
+  prefix=/usr/local
+fi
+
+fch=`echo $prefix | sed 's/\(.\).*/\1/'`
+if test $fch != "/" ; then
+   prefix=`pwd`/$prefix
+   echo "adjusting prefix to $prefix"
+fi
+
+if test "x$exec_prefix" = "xNONE"; then
+  exec_prefix=$prefix
+fi
+
+fch=`echo $exec_prefix | sed 's/\(.\).*/\1/'`
+if test $fch != "/" ; then
+   exec_prefix=`pwd`/$exec_prefix
+   echo "adjusting exec_prefix to $exec_prefix"
+fi
+
+# Set SNMPLIBPATH & SNMPSHAREPATH
+
+SNMPLIBPATH=""
+tmpset="$libdir/snmp"
+while test "x$tmpset" != "x$SNMPLIBPATH"; do
+  SNMPLIBPATH="$tmpset"
+  eval tmpset="$tmpset"
+done
+cat >>confdefs.h <<_ACEOF
+#define SNMPLIBPATH "$SNMPLIBPATH"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define SNMPDLMODPATH "$SNMPLIBPATH/dlmod"
+_ACEOF
+
+
+SNMPSHAREPATH=""
+tmpset="$datadir/snmp"
+while test "x$tmpset" != "x$SNMPSHAREPATH"; do
+  SNMPSHAREPATH="$tmpset"
+  eval tmpset="$tmpset"
+done
+cat >>confdefs.h <<_ACEOF
+#define SNMPSHAREPATH "$SNMPSHAREPATH"
+_ACEOF
+
+
+if test "x$DEFAULT_MIBDIRS" = "x"; then
+  cat >>confdefs.h <<_ACEOF
+#define DEFAULT_MIBDIRS "\$HOME/.snmp/mibs:$SNMPSHAREPATH/mibs"
+_ACEOF
+
+fi
+
+SNMPCONFPATH=""
+tmpset="$sysconfdir/snmp"
+while test "x$tmpset" != "x$SNMPCONFPATH"; do
+  SNMPCONFPATH="$tmpset"
+  eval tmpset="$tmpset"
+done
+cat >>confdefs.h <<_ACEOF
+#define SNMPCONFPATH "$SNMPCONFPATH"
+_ACEOF
+
+
+
+# guess IPv6 stack type.
+if test "x$enable_ipv6" = "xyes"; then
+	v6type=unknown
+	v6lib=none
+	v6trylibc=no
+
+	echo "$as_me:$LINENO: checking ipv6 stack type" >&5
+echo $ECHO_N "checking ipv6 stack type... $ECHO_C" >&6
+	for i in v6d toshiba kame inria zeta linux-glibc linux-inet6; do
+		case $i in
+		v6d)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include </usr/local/v6/include/sys/types.h>
+#ifdef __V6D__
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i; v6lib=v6;
+				v6libdir=/usr/local/v6/lib;
+				CFLAGS="-I/usr/local/v6/include $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		toshiba)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <sys/param.h>
+#ifdef _TOSHIBA_INET6
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i; v6lib=inet6;
+				v6libdir=/usr/local/v6/lib;
+				CFLAGS="-DINET6 $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		kame)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <netinet/in.h>
+#ifdef __KAME__
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i; v6lib=inet6;
+				v6libdir=/usr/local/v6/lib;
+				v6trylibc=yes;
+				CFLAGS="-DINET6 $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		inria)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <netinet/in.h>
+#ifdef IPV6_INRIA_VERSION
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i;
+				v6lib=dummy;
+				v6libdir=none;
+				v6trylibc=yes;
+				CFLAGS="-DINET6 $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		zeta)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <sys/param.h>
+#ifdef _ZETA_MINAMI_INET6
+A
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i; v6lib=inet6;
+				v6libdir=/usr/local/v6/lib;
+				CFLAGS="-DINET6 $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		linux-glibc)
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <features.h>
+#if defined(__GLIBC__) && ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1) || (__GLIBC_ > 2))
+yes
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then
+  v6type=$i;
+				v6lib=dummy;
+				v6libdir=none;
+				v6trylibc=yes;
+				CFLAGS="-DINET6 $CFLAGS"
+fi
+rm -f conftest*
+
+			;;
+		linux-inet6)
+			if test -d /usr/inet6; then
+				v6type=$i
+				v6lib=inet6
+				v6libdir=/usr/inet6/lib
+				CFLAGS="-DINET6 $CFLAGS"
+			fi
+			;;
+		esac
+		if test "$v6type" != "unknown"; then
+			break
+		fi
+	done
+
+	if test "$v6lib" != "none"; then
+		if test -d $v6libdir -a -f $v6libdir/lib$v6lib.a; then
+			LIBS="-L$v6libdir -l$v6lib $LIBS"
+			enable_ipv6="yes"
+			echo "$as_me:$LINENO: result: \"$v6type, $enable_ipv6, using lib$v6lib\"" >&5
+echo "${ECHO_T}\"$v6type, $enable_ipv6, using lib$v6lib\"" >&6
+		elif test "$v6trylibc" = "yes"; then
+			enable_ipv6="yes"
+			echo "$as_me:$LINENO: result: \"$v6type, $enable_ipv6, using libc\"" >&5
+echo "${ECHO_T}\"$v6type, $enable_ipv6, using libc\"" >&6
+		else
+			{ { echo "$as_me:$LINENO: error: no IPv6 library lib$v6lib.a found." >&5
+echo "$as_me: error: no IPv6 library lib$v6lib.a found." >&2;}
+   { (exit 1); exit 1; }; }
+			exit 1
+		fi
+	else
+		enable_ipv6="no"
+		echo "$as_me:$LINENO: result: \"$v6type, $enable_ipv6\"" >&5
+echo "${ECHO_T}\"$v6type, $enable_ipv6\"" >&6
+	fi
+fi
+
+#
+# Maybe add library extensions for thread mutex locking.
+#
+
+if test "x$with_res_locks" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define NS_REENTRANT 1
+_ACEOF
+
+EOF
+
+    case $target_os in
+
+    aix*)
+	CC_RUNTIME_ARG="$CC_RUNTIME_ARG -lpthreads"
+	;;
+
+    *)
+	;;
+
+    esac
+fi
+
+echo "$as_me:$LINENO: checking whether we have to build PIC code" >&5
+echo $ECHO_N "checking whether we have to build PIC code... $ECHO_C" >&6
+echo "$with_mib_modules" | grep "ucd-snmp/dlmod" >/dev/null
+if test $? -eq 0 ; then
+	DLLIBS="-ldl"
+        LIB_CFLAGS="$LIB_CFLAGS $SHLIB_CFLAGS"
+	echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+	DLLIBS=""
+	echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+#
+# Do transport module processing.
+#
+echo "$as_me:$LINENO: checking for and configuring transport modules to use" >&5
+echo $ECHO_N "checking for and configuring transport modules to use... $ECHO_C" >&6
+transport_src_list=""
+transport_hdr_list=""
+transport_def_list=""
+transport_result_list=""
+transport_add_list=""
+transport_callback_disabled=""
+new_with_transport_list=`echo $with_transports | sed 's/,/ /g;'`
+new_with_out_transport_list=`echo $with_out_transports | sed 's/,/ /g;'`
+
+#
+# Add the default transports to the list
+#
+if test "x$PARTIALTARGETOS" = "xcygwin"; then
+  transport_default_list="UDP TCP Callback"
+else
+  transport_default_list="UDP TCP Unix Callback"
+fi
+if test "x$enable_ipv6" = "xyes"; then
+  transport_default_list="UDPIPv6 TCPIPv6 $transport_default_list"
+fi
+for i in $transport_default_list; do
+  if echo " $new_with_transport_list " | grep " $i " >/dev/null; then
+    :
+  else
+    transport_add_list="$i $transport_add_list"
+  fi
+done
+new_transport_list="$transport_add_list $new_with_transport_list"
+
+for i in $new_transport_list; do
+  if echo " $new_with_out_transport_list " | grep " $i " >/dev/null; then
+    if test "x$i" = "xUDP"; then
+      echo
+      { { echo "$as_me:$LINENO: error: It is not possible to compile without UDP/IP support." >&5
+echo "$as_me: error: It is not possible to compile without UDP/IP support." >&2;}
+   { (exit 1); exit 1; }; }
+    elif test "x$i" = "xCallback"; then
+      echo
+      transport_callback_disabled="yes"
+    fi
+  else
+    if test "x$i" = "xAAL5PVC"; then
+      if test "x$PARTIALTARGETOS" != "xlinux"; then
+        echo
+        { { echo "$as_me:$LINENO: error: AAL5 PVC support unavailable for this platform (Linux only)" >&5
+echo "$as_me: error: AAL5 PVC support unavailable for this platform (Linux only)" >&2;}
+   { (exit 1); exit 1; }; }
+      fi
+    fi
+    if test "x$i" = "xIPX"; then
+      if test "x$PARTIALTARGETOS" != "xlinux"; then
+        echo
+        { { echo "$as_me:$LINENO: error: IPX support unavailable for this platform (Linux only)" >&5
+echo "$as_me: error: IPX support unavailable for this platform (Linux only)" >&2;}
+   { (exit 1); exit 1; }; }
+      fi
+    fi
+    if test "x$i" = "xUnix"; then
+      if test "x$PARTIALTARGETOS" = "xcygwin"; then
+        echo
+        { { echo "$as_me:$LINENO: error: Unix domain protocol support unavailable for this platform" >&5
+echo "$as_me: error: Unix domain protocol support unavailable for this platform" >&2;}
+   { (exit 1); exit 1; }; }
+      fi
+    fi
+    transport_src="snmp"$i"Domain.c"
+    transport_hdr="snmp"$i"Domain.h"
+    rel_transport_src="snmplib/"$transport_src
+    rel_transport_hdr="include/net-snmp/library/"$transport_hdr
+    if test -f "$srcdir/$rel_transport_src"; then
+      transport_result_list="$transport_result_list $i"
+      transport_src_list="$transport_src $transport_src_list"
+      if test -f "$srcdir/$rel_transport_hdr"; then
+        transport_hdr_list="$transport_hdr $transport_hdr_list"
+      fi
+      transport_def=`echo $i | sed 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+      transport_def_list="SNMP_TRANSPORT_"$transport_def"_DOMAIN $transport_def_list"
+    else
+      echo
+      { { echo "$as_me:$LINENO: error: Cannot find file $transport_src to support SNMP transport domain $i." >&5
+echo "$as_me: error: Cannot find file $transport_src to support SNMP transport domain $i." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+  fi
+done
+
+
+for i in $transport_def_list; do
+  cat >>confdefs.h <<_ACEOF
+#define $i 1
+_ACEOF
+
+done
+echo "$as_me:$LINENO: result: $transport_result_list." >&5
+echo "${ECHO_T}$transport_result_list." >&6
+
+  cat >> configure-summary << EOF
+  Network transport support: $transport_result_list
+EOF
+
+
+#
+# Security modules to use
+#
+
+echo "$as_me:$LINENO: checking for security modules to use" >&5
+echo $ECHO_N "checking for security modules to use... $ECHO_C" >&6
+if test "$IFX_CONFIG_SNMPv3" = "1" ; then
+	security_def_list="usm"
+else
+	security_def_list=""
+fi
+security_src_list=""
+security_init_file="snmplib/snmpsm_init.h"
+security_incl_file="include/net-snmp/library/snmpv3-security-includes.h"
+new_with_security=`echo $with_security_modules | sed 's/,/ /g;'`
+new_with_out_security=`echo $with_out_security_modules | sed 's/,/ /g;'`
+
+if test ! -d include; then
+  mkdir include
+fi
+if test ! -d include/net-snmp; then
+  mkdir include/net-snmp
+fi
+if test ! -d include/net-snmp/agent; then
+  mkdir include/net-snmp/agent
+fi
+if test ! -d include/net-snmp/library; then
+  mkdir include/net-snmp/library
+fi
+if test ! -d include/ucd-snmp; then
+  mkdir include/ucd-snmp
+fi
+
+if test ! -d snmplib; then
+  mkdir snmplib
+fi
+echo "/* This file is automatically generated by configure.  Do not modify by hand. */" > $security_init_file
+echo "/* This file is automatically generated by configure.  Do not modify by hand. */" > $security_incl_file
+
+for i in $security_def_list; do
+  if echo " $new_with_out_security " | grep " $i " > /dev/null; then
+	if test "$IFX_CONFIG_SNMPv3" = "1" ; then
+	     if test "x$i" = "xusm"; then
+		echo
+		{ { echo "$as_me:$LINENO: error: The USM security module is mandatory" >&5
+			echo "$as_me: error: The USM security module is mandatory" >&2;}
+			   { (exit 1); exit 1; }; }
+	    fi
+	fi
+  else
+    new_with_security="$new_with_security $i"
+  fi
+done
+
+for i in $new_with_security; do
+  cfile="snmp"$i".c"
+  hfile="snmp"$i".h"
+
+  # make sure support exists for it
+  if test -f $srcdir"/snmplib/"$cfile -a -f $srcdir"/include/net-snmp/library/"$hfile; then
+    :
+  else
+    echo
+    { { echo "$as_me:$LINENO: error: No such security module: $i / $cfile / $hfile" >&5
+echo "$as_me: error: No such security module: $i / $cfile / $hfile" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+
+  # define a bunch of stuff to enable it
+  security_src_list="$security_src_list $cfile"
+  security_hdr_list="$security_hdr_list $hfile"
+  def_name="SNMP_SECMOD_"`echo $i | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  echo "init_"$i"();" >> $security_init_file
+  echo "#include <net-snmp/library/$hfile>" >> $security_incl_file
+  cat >>confdefs.h <<_ACEOF
+#define $def_name 1
+_ACEOF
+
+done
+
+
+
+echo "$as_me:$LINENO: result: $new_with_security" >&5
+echo "${ECHO_T}$new_with_security" >&6
+
+  cat >> configure-summary << EOF
+  SNMPv3 Security Modules:   $new_with_security
+EOF
+
+
+#
+# Handle the special case of KSM to see which crypto API we support
+#
+
+for sec in $new_with_security
+do
+  if test x$sec = xksm; then
+    echo "$as_me:$LINENO: checking to see which crypto API we need to use" >&5
+echo $ECHO_N "checking to see which crypto API we need to use... $ECHO_C" >&6
+
+    echo "$as_me:$LINENO: checking for krb5_c_encrypt" >&5
+echo $ECHO_N "checking for krb5_c_encrypt... $ECHO_C" >&6
+if test "${ac_cv_func_krb5_c_encrypt+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char krb5_c_encrypt (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char krb5_c_encrypt ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_krb5_c_encrypt) || defined (__stub___krb5_c_encrypt)
+choke me
+#else
+char (*f) () = krb5_c_encrypt;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != krb5_c_encrypt;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_krb5_c_encrypt=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_krb5_c_encrypt=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_krb5_c_encrypt" >&5
+echo "${ECHO_T}$ac_cv_func_krb5_c_encrypt" >&6
+if test $ac_cv_func_krb5_c_encrypt = yes; then
+
+      echo "$as_me:$LINENO: result: new MIT crypto API" >&5
+echo "${ECHO_T}new MIT crypto API" >&6
+      cat >>confdefs.h <<\_ACEOF
+#define MIT_NEW_CRYPTO 1
+_ACEOF
+
+else
+
+      echo "$as_me:$LINENO: result: old MIT crypto API" >&5
+echo "${ECHO_T}old MIT crypto API" >&6
+fi
+
+  fi
+done
+
+#
+# Do hairy agent module processing.
+#
+echo "$as_me:$LINENO: checking for and configuring mib modules to use" >&5
+echo $ECHO_N "checking for and configuring mib modules to use... $ECHO_C" >&6
+
+
+mibdir="agent/mibgroup"
+module_list=""
+module_list_code=""
+new_with_mib_modules=`echo $with_mib_modules | sed 's/,/ /g;'`
+new_with_out_mib_modules=`echo $with_out_mib_modules | sed 's/,/ /g;'`
+new_module_list="mibII ucd_snmp snmpv3mibs notification target agent_mibs agentx agent_mibs utilities $new_with_mib_modules"
+default_mibs=IP-MIB:IF-MIB:TCP-MIB:UDP-MIB:HOST-RESOURCES-MIB:SNMPv2-MIB:RFC1213-MIB:NOTIFICATION-LOG-MIB
+
+if test "x$mini_agent" = "xyes"; then
+new_with_out_mib_modules="mibII $new_with_out_mib_modules"
+new_module_list="snmpv3mibs mibII/snmp_mib mibII/system_mib mibII/sysORTable mibII/vacm_vars utilities/execute $new_with_mib_modules"
+default_mibs=SNMPv2-MIB:RFC1213-MIB
+default_mibs_install=" "
+fi
+
+if test "x$transport_callback_disabled" = "xyes"; then
+
+        { echo "$as_me:$LINENO: WARNING: Disabling Callback transport will disable AgentX support." >&5
+echo "$as_me: WARNING: Disabling Callback transport will disable AgentX support." >&2;}
+
+        new_with_out_mib_modules="agentx $new_with_out_mib_modules"
+fi
+
+if test "x$enable_ipv6" = "xyes"; then
+	new_module_list="$new_module_list mibII/ipv6"
+fi
+
+# Create include file list for snmp_vars.h to use.
+if test ! -d agent; then
+  mkdir agent
+fi
+if test ! -d agent/mibgroup; then
+  mkdir agent/mibgroup
+fi
+for i in $mibdir/mib_module_includes.h $mibdir/mib_module_inits.h $mibdir/mib_module_shutdown.h include/net-snmp/agent/mib_module_config.h $mibdir/mib_module_dot_conf.h; do
+  rm -f $i
+  echo "/* This file is automatically generated by configure.  Do not modify by hand. */" > $i
+done
+
+test_modules="$new_module_list"
+new_module_list=""
+module_list_h=""
+
+for i in $test_modules
+ do
+  if echo " $new_with_out_mib_modules " | grep " $i " > /dev/null; then
+    :
+  else
+    new_module_list="$new_module_list $i"
+  fi
+done
+
+
+echo "$as_me:$LINENO: result: $new_module_list." >&5
+echo "${ECHO_T}$new_module_list." >&6
+
+  cat >> configure-summary << EOF
+  Agent MIB code:            $new_module_list
+EOF
+
+
+MODULECPP="$CPP -I${srcdir}/include -I${srcdir}/agent/mibgroup -I${IFX_APIS_DIR}include"
+echo "$as_me:$LINENO: checking for and configuring mib modules pieces to use" >&5
+echo $ECHO_N "checking for and configuring mib modules pieces to use... $ECHO_C" >&6
+
+while test "x$new_module_list" != "x"; do
+  for i in $new_module_list
+    do
+    if echo " $new_with_out_mib_modules " | grep " $i " > /dev/null; then
+      :
+    else
+      if test -f $srcdir/$mibdir/$i.h; then
+        new_list=""
+        new_list_arch=`grep config_arch_require $srcdir/$mibdir/$i.h | sed 's/.*config_arch_require(\(.*\), *\(.*\)).*/\1-xarchx-\2/'`
+	if test "x$new_list_arch" != "x"; then
+          for j in $new_list_arch
+	    do
+	    archtest=`echo $j | sed 's/-xarchx-.*//'`
+	    if test "x$target_os" = "x$archtest" -o "x$PARTIALTARGETOS" = "x$archtest"; then
+	      new_list="$new_list `echo $j | sed 's/.*-xarchx-//'`"
+	    fi
+	  done
+	fi
+	new_list="$new_list `$MODULECPP $srcdir/$mibdir/$i.h | grep config_require | sed 's/.*config_require(\(.*\)).*/\1/'`"
+	new_list="$new_list `$MODULECPP $srcdir/$mibdir/$i.h | grep config_require | sed 's/.*config_require(\(.*\)).*/\1/'`"
+	if test "x$new_list" != "x"; then
+	  for j in $new_list
+	    do
+	    if test ! -f $srcdir/$mibdir/$j.h; then
+
+	      { { echo "$as_me:$LINENO: error: mib module \"$i\" requires module \"$j\" but $j.h or $j.c could not be found in $srcdir/$mibdir" >&5
+echo "$as_me: error: mib module \"$i\" requires module \"$j\" but $j.h or $j.c could not be found in $srcdir/$mibdir" >&2;}
+   { (exit 1); exit 1; }; }
+
+	    elif echo " $new_with_out_mib_modules " | grep " $j " > /dev/null; then
+
+	      { echo "$as_me:$LINENO: WARNING: mib module \"$i\" requires module \"$j\" but you told me to compile without it" >&5
+echo "$as_me: WARNING: mib module \"$i\" requires module \"$j\" but you told me to compile without it" >&2;}
+
+	    elif echo " $module_list $new_list_two $new_module_list " | grep " $j " > /dev/null; then
+	      :
+	    else
+	      new_list_two="$new_list_two $j"
+	    fi
+	  done
+	fi
+	new_mibs=`$MODULECPP $srcdir/$mibdir/$i.h | grep config_add_mib | sed 's/.*config_add_mib(\(.*\)).*/\1/'`
+	if test "x$new_mibs" != "x"; then
+	    for j in $new_mibs
+		do
+		if test "x`echo :$default_mibs: | grep :$j:`" = "x"; then
+		    default_mibs="$default_mibs:$j"
+		fi
+		if test -f $srcdir/mibs/$j.txt; then
+		    if echo $default_mibs_install | grep " $j " > /dev/null; then
+			    :
+		    else
+			    default_mibs_install="$default_mibs_install $j.txt"
+		    fi
+		fi
+	    done
+	fi
+      else
+
+	{ { echo "$as_me:$LINENO: error: module files $i.h or $i.c could not be found in $srcdir/$mibdir" >&5
+echo "$as_me: error: module files $i.h or $i.c could not be found in $srcdir/$mibdir" >&2;}
+   { (exit 1); exit 1; }; }
+
+      fi
+      module_list="$module_list $i"
+      echo '#include "'"mibgroup/$i.h"'"' >> $mibdir/mib_module_includes.h
+      module_list_h="$module_list_h mibgroup/$i.h"
+      if test -f $srcdir/$mibdir/$i.c; then
+        module_list_code="$module_list_code $i"
+        mnm=`echo $i | sed 's/.*\///;s/\.c$//;'`
+        temp_init=`grep init_$mnm $srcdir/$mibdir/$i.c | grep -v _init_$mnm`
+	if test "x$temp_init" != "x"; then
+	    echo "  if (should_init(\"$mnm\")) init_$mnm();" >> $mibdir/mib_module_inits.h
+	fi
+	if grep shutdown_`basename $i` $srcdir/$mibdir/$i.c > /dev/null; then
+	    echo "  if (should_init(\"`basename $i`\")) shutdown_`basename $i`();" >> $mibdir/mib_module_shutdown.h
+	fi
+      fi
+      if test "x`echo $i | sed 's/\///g;'`" != "x$i"; then
+	mnd=`echo $i | sed 's/\/[^/]*$//;'`
+	if test ! -d ./$mibdir/$mnd; then
+	    module_directories="$module_directories ./$mibdir/$mnd"
+	fi
+      fi
+      if $MODULECPP $srcdir/$mibdir/$i.h | grep config_load_mib > /dev/null 2>&1; then
+
+      	{ echo "$as_me:$LINENO: WARNING: mib module \"$i\" uses the \"config_load_mib\" directive, which is no longer supported.  It probably won't work." >&5
+echo "$as_me: WARNING: mib module \"$i\" uses the \"config_load_mib\" directive, which is no longer supported.  It probably won't work." >&2;}
+
+      fi
+      $MODULECPP $srcdir/$mibdir/$i.h | grep config_parse_dot_conf | sed 's@.*config_parse_dot_conf(\([^)]*\), *\([^),]*\), *\([^),]*\), *\([^),]*\)).*@register_config_handler("snmpd",\1, \2, \3, \4);@' >> $mibdir/mib_module_dot_conf.h
+      sym="`echo ${i} | sed 's/[^a-zA-Z0-9_]/_/g' | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`"
+      echo "/* Define if compiling with the ${i} module files.  */" >> include/net-snmp/agent/mib_module_config.h
+      echo "#define USING_${sym}_MODULE 1" >> include/net-snmp/agent/mib_module_config.h
+      echo " " >> include/net-snmp/agent/mib_module_config.h
+
+      echo $ECHO_N " $i$ECHO_C"
+
+    fi
+  done
+  new_module_list="$new_list_two"
+  new_list_two=""
+done
+module_list_o=`echo "$module_list_code " | sed 's/\([^ ]\) /\1.o /g'`
+module_list_lo=`echo "$module_list_code " | sed 's/\([^ ]\) /\1.lo /g'`
+module_list_c=`echo "$module_list_code " | sed 's/\([^ ]\) /\1.c /g'`
+mibgroup_list_o=`echo " $module_list_o " | sed 's@ \([^ ]*\)\.o@ mibgroup/\1.o @g'`
+mibgroup_list_lo=`echo " $module_list_lo " | sed 's@ \([^ ]*\)\.lo@ mibgroup/\1.lo @g'`
+
+MODULE_LIST=$module_list_code
+
+
+
+
+
+
+
+
+
+
+echo "$as_me:$LINENO: result: ." >&5
+echo "${ECHO_T}." >&6
+
+echo "$as_me:$LINENO: checking if directories need to be created" >&5
+echo $ECHO_N "checking if directories need to be created... $ECHO_C" >&6
+for i in $module_directories; do
+  $srcdir/mkinstalldirs $i
+done
+echo "$as_me:$LINENO: result: ." >&5
+echo "${ECHO_T}." >&6
+
+echo "$as_me:$LINENO: checking default mib files to read" >&5
+echo $ECHO_N "checking default mib files to read... $ECHO_C" >&6
+if test "x$DEFAULT_MIBS" = "x"; then
+  DEFAULT_MIBS="$default_mibs"
+fi
+cat >>confdefs.h <<_ACEOF
+#define DEFAULT_MIBS "$DEFAULT_MIBS"
+_ACEOF
+
+echo "$as_me:$LINENO: result: $DEFAULT_MIBS" >&5
+echo "${ECHO_T}$DEFAULT_MIBS" >&6
+
+#
+# Check for kernel location
+#
+
+echo "$as_me:$LINENO: checking for location of system kernel" >&5
+echo $ECHO_N "checking for location of system kernel... $ECHO_C" >&6
+if test "${ac_cv_KERNEL_LOC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_KERNEL_LOC="unknown"
+# First determine if test expects a -f or a -c (character device (SYSV))
+
+if test -c /dev/null; then
+  CFLAG="-c"
+elif test -f /dev/null; then
+  CFLAG="-f"
+else
+  # fall back
+  CFLAG="-f"
+fi
+for i in /vmunix /hp-ux /stand/vmunix /dev/ksyms /kernel/unix /kernel/genunix /netbsd /unix /kernel /bsd /mach_kernel
+  do
+  if test -f $i -o $CFLAG $i; then
+    ac_cv_KERNEL_LOC="$i"
+    break;
+  fi
+done
+if test $i = "unknown"; then
+  { echo "$as_me:$LINENO: WARNING: Can't find system kernel...  Setting to /vmunix" >&5
+echo "$as_me: WARNING: Can't find system kernel...  Setting to /vmunix" >&2;}
+  ac_cv_KERNEL_LOC="/vmunix"
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_KERNEL_LOC" >&5
+echo "${ECHO_T}$ac_cv_KERNEL_LOC" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define KERNEL_LOC "$ac_cv_KERNEL_LOC"
+_ACEOF
+
+
+#
+# Check for mount table location
+#
+
+echo "$as_me:$LINENO: checking for mount table location" >&5
+echo $ECHO_N "checking for mount table location... $ECHO_C" >&6
+if test "${ac_cv_ETC_MNTTAB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_ETC_MNTTAB="unknown"
+for i in /etc/mnttab /etc/mtab /etc/filesystems
+  do
+  if test -f $i; then
+    ac_cv_ETC_MNTTAB="$i"
+    break;
+  fi
+done
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_ETC_MNTTAB" >&5
+echo "${ECHO_T}$ac_cv_ETC_MNTTAB" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define ETC_MNTTAB "$ac_cv_ETC_MNTTAB"
+_ACEOF
+
+
+# Check for /dev/dmem or /dev/drum location
+echo "$as_me:$LINENO: checking for location of swap device" >&5
+echo $ECHO_N "checking for location of swap device... $ECHO_C" >&6
+if test "${ac_cv_DMEM_LOC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+# First determine if test expects a -f or a -c (character device (SYSV))
+
+if test -f /dev/kmem; then
+  CTEST="test -f"
+elif test -c /dev/kmem; then
+  CTEST="test -c"
+else
+  # fall back
+  CTEST="test -f"
+fi
+
+if $CTEST /dev/dmem; then
+  ac_cv_DMEM_LOC="/dev/dmem"
+elif $CTEST /dev/drum; then
+  ac_cv_DMEM_LOC="/dev/drum"
+else
+  ac_cv_DMEM_LOC="none"
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_DMEM_LOC" >&5
+echo "${ECHO_T}$ac_cv_DMEM_LOC" >&6
+
+if test "x$ac_cv_DMEM_LOC" != "xnone"; then
+  cat >>confdefs.h <<_ACEOF
+#define DMEM_LOC "$ac_cv_DMEM_LOC"
+_ACEOF
+
+fi
+
+# forced efence turned off.
+# if test "x$developer" = "xyes" -a "x$use_efence" != "xno"; then
+#    use_efence="yes"
+# fi
+
+if test "x$use_efence" = "xyes"; then
+
+echo "$as_me:$LINENO: checking for EF_Exit in -lefence" >&5
+echo $ECHO_N "checking for EF_Exit in -lefence... $ECHO_C" >&6
+if test "${ac_cv_lib_efence_EF_Exit+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lefence  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char EF_Exit ();
+int
+main ()
+{
+EF_Exit ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_efence_EF_Exit=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_efence_EF_Exit=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_efence_EF_Exit" >&5
+echo "${ECHO_T}$ac_cv_lib_efence_EF_Exit" >&6
+if test $ac_cv_lib_efence_EF_Exit = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBEFENCE 1
+_ACEOF
+
+  LIBS="-lefence $LIBS"
+
+fi
+
+fi
+
+# Checks for libraries.
+# AC_CHECK_LIB(des, main)
+
+echo "$as_me:$LINENO: checking for asin in -lm" >&5
+echo $ECHO_N "checking for asin in -lm... $ECHO_C" >&6
+if test "${ac_cv_lib_m_asin+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char asin ();
+int
+main ()
+{
+asin ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_m_asin=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_m_asin=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_m_asin" >&5
+echo "${ECHO_T}$ac_cv_lib_m_asin" >&6
+if test $ac_cv_lib_m_asin = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBM 1
+_ACEOF
+
+  LIBS="-lm $LIBS"
+
+fi
+
+# nlist is needed for uptime on some sytems in the generic library
+
+echo "$as_me:$LINENO: checking for nlist in -lelf" >&5
+echo $ECHO_N "checking for nlist in -lelf... $ECHO_C" >&6
+if test "${ac_cv_lib_elf_nlist+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lelf  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char nlist ();
+int
+main ()
+{
+nlist ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_elf_nlist=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_elf_nlist=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_elf_nlist" >&5
+echo "${ECHO_T}$ac_cv_lib_elf_nlist" >&6
+if test $ac_cv_lib_elf_nlist = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBELF 1
+_ACEOF
+
+  LIBS="-lelf $LIBS"
+
+fi
+
+
+# On some platforms (Irix) libnsl and libsocket should not be used.
+echo "$as_me:$LINENO: checking for gethostbyname" >&5
+echo $ECHO_N "checking for gethostbyname... $ECHO_C" >&6
+if test "${ac_cv_func_gethostbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char gethostbyname (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_gethostbyname) || defined (__stub___gethostbyname)
+choke me
+#else
+char (*f) () = gethostbyname;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != gethostbyname;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_gethostbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_gethostbyname=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_gethostbyname" >&5
+echo "${ECHO_T}$ac_cv_func_gethostbyname" >&6
+if test $ac_cv_func_gethostbyname = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETHOSTBYNAME 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: checking for gethostbyname in -lnsl" >&5
+echo $ECHO_N "checking for gethostbyname in -lnsl... $ECHO_C" >&6
+if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
+echo "${ECHO_T}$ac_cv_lib_nsl_gethostbyname" >&6
+if test $ac_cv_lib_nsl_gethostbyname = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETHOSTBYNAME 1
+_ACEOF
+
+	LIBS="${LIBS} -lnsl"
+fi
+
+fi
+
+echo "$as_me:$LINENO: checking for getservbyname" >&5
+echo $ECHO_N "checking for getservbyname... $ECHO_C" >&6
+if test "${ac_cv_func_getservbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char getservbyname (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getservbyname ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_getservbyname) || defined (__stub___getservbyname)
+choke me
+#else
+char (*f) () = getservbyname;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != getservbyname;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_getservbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_getservbyname=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_getservbyname" >&5
+echo "${ECHO_T}$ac_cv_func_getservbyname" >&6
+if test $ac_cv_func_getservbyname = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETSERVBYNAME 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: checking for getservbyname in -lsocket" >&5
+echo $ECHO_N "checking for getservbyname in -lsocket... $ECHO_C" >&6
+if test "${ac_cv_lib_socket_getservbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getservbyname ();
+int
+main ()
+{
+getservbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_socket_getservbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_socket_getservbyname=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_socket_getservbyname" >&5
+echo "${ECHO_T}$ac_cv_lib_socket_getservbyname" >&6
+if test $ac_cv_lib_socket_getservbyname = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETSERVBYNAME 1
+_ACEOF
+
+	LIBS="${LIBS} -lsocket"
+fi
+
+fi
+
+
+# Replace `main' with a function in -lkstat:
+
+echo "$as_me:$LINENO: checking for kstat_lookup in -lkstat" >&5
+echo $ECHO_N "checking for kstat_lookup in -lkstat... $ECHO_C" >&6
+if test "${ac_cv_lib_kstat_kstat_lookup+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lkstat  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char kstat_lookup ();
+int
+main ()
+{
+kstat_lookup ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_kstat_kstat_lookup=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_kstat_kstat_lookup=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_kstat_kstat_lookup" >&5
+echo "${ECHO_T}$ac_cv_lib_kstat_kstat_lookup" >&6
+if test $ac_cv_lib_kstat_kstat_lookup = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBKSTAT 1
+_ACEOF
+
+  LIBS="-lkstat $LIBS"
+
+fi
+
+# Check for nlist in mld (irix)
+
+echo "$as_me:$LINENO: checking for nlist in -lmld" >&5
+echo $ECHO_N "checking for nlist in -lmld... $ECHO_C" >&6
+if test "${ac_cv_lib_mld_nlist+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lmld  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char nlist ();
+int
+main ()
+{
+nlist ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_mld_nlist=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_mld_nlist=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_mld_nlist" >&5
+echo "${ECHO_T}$ac_cv_lib_mld_nlist" >&6
+if test $ac_cv_lib_mld_nlist = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBMLD 1
+_ACEOF
+
+  LIBS="-lmld $LIBS"
+
+fi
+
+
+# Check for security related functions
+if test "x$tryopenssl" != "xno"; then
+    if test "x$tryrsaref" != "xno"; then
+
+echo "$as_me:$LINENO: checking for RSAPrivateDecrypt in -lrsaref" >&5
+echo $ECHO_N "checking for RSAPrivateDecrypt in -lrsaref... $ECHO_C" >&6
+if test "${ac_cv_lib_rsaref_RSAPrivateDecrypt+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrsaref  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char RSAPrivateDecrypt ();
+int
+main ()
+{
+RSAPrivateDecrypt ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_rsaref_RSAPrivateDecrypt=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_rsaref_RSAPrivateDecrypt=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_rsaref_RSAPrivateDecrypt" >&5
+echo "${ECHO_T}$ac_cv_lib_rsaref_RSAPrivateDecrypt" >&6
+if test $ac_cv_lib_rsaref_RSAPrivateDecrypt = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBRSAREF 1
+_ACEOF
+
+  LIBS="-lrsaref $LIBS"
+
+fi
+
+
+echo "$as_me:$LINENO: checking for RSA_PKCS1_RSAref in -lRSAglue" >&5
+echo $ECHO_N "checking for RSA_PKCS1_RSAref in -lRSAglue... $ECHO_C" >&6
+if test "${ac_cv_lib_RSAglue_RSA_PKCS1_RSAref+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lRSAglue  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char RSA_PKCS1_RSAref ();
+int
+main ()
+{
+RSA_PKCS1_RSAref ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_RSAglue_RSA_PKCS1_RSAref=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_RSAglue_RSA_PKCS1_RSAref=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_RSAglue_RSA_PKCS1_RSAref" >&5
+echo "${ECHO_T}$ac_cv_lib_RSAglue_RSA_PKCS1_RSAref" >&6
+if test $ac_cv_lib_RSAglue_RSA_PKCS1_RSAref = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBRSAGLUE 1
+_ACEOF
+
+  LIBS="-lRSAglue $LIBS"
+
+fi
+
+    fi
+
+
+echo "$as_me:$LINENO: checking for EVP_md5 in -lcrypto" >&5
+echo $ECHO_N "checking for EVP_md5 in -lcrypto... $ECHO_C" >&6
+if test "${ac_cv_lib_crypto_EVP_md5+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lcrypto  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char EVP_md5 ();
+int
+main ()
+{
+EVP_md5 ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_crypto_EVP_md5=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_crypto_EVP_md5=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_crypto_EVP_md5" >&5
+echo "${ECHO_T}$ac_cv_lib_crypto_EVP_md5" >&6
+if test $ac_cv_lib_crypto_EVP_md5 = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBCRYPTO 1
+_ACEOF
+
+if test "$IFX_CONFIG_SNMPv3" = "1" ; then
+	LIBS="-lcrypto $LIBS"
+fi
+# LIBS="$USER_OPENSOURCE_DIR/openssl-0.9.7e/libcrypto.a $LIBS"
+fi
+
+
+for ac_func in AES_cfb128_encrypt
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+fi
+
+# Check for libraries that the agent needs
+# saving old libraries
+NONAGENTLIBS=$LIBS
+
+# check for tcp wrapper support
+_cppflags="${CPPFLAGS}"
+_ldflags="${LDFLAGS}"
+
+
+# Check whether --with-libwrap or --without-libwrap was given.
+if test "${with_libwrap+set}" = set; then
+  withval="$with_libwrap"
+
+  if test "$with_libwrap" != "no"; then
+    if test "$with_libwrap" != "yes"; then
+      CPPFLAGS="${CPPFLAGS} -I$with_libwrap/include"
+      LDFLAGS="${LDFLAGS} -L$with_libwrap/lib"
+    fi
+
+    _libs=${LIBS}
+    if test "${ac_cv_header_tcpd_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for tcpd.h" >&5
+echo $ECHO_N "checking for tcpd.h... $ECHO_C" >&6
+if test "${ac_cv_header_tcpd_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_tcpd_h" >&5
+echo "${ECHO_T}$ac_cv_header_tcpd_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking tcpd.h usability" >&5
+echo $ECHO_N "checking tcpd.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <tcpd.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking tcpd.h presence" >&5
+echo $ECHO_N "checking tcpd.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <tcpd.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: tcpd.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: tcpd.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: tcpd.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: tcpd.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: tcpd.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: tcpd.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: tcpd.h: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: tcpd.h: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: tcpd.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: tcpd.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for tcpd.h" >&5
+echo $ECHO_N "checking for tcpd.h... $ECHO_C" >&6
+if test "${ac_cv_header_tcpd_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_tcpd_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_tcpd_h" >&5
+echo "${ECHO_T}$ac_cv_header_tcpd_h" >&6
+
+fi
+if test $ac_cv_header_tcpd_h = yes; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: Asked to use libwrap but I couldn't find tcpd.h." >&5
+echo "$as_me: error: Asked to use libwrap but I couldn't find tcpd.h." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+
+
+    LIBS="$LIBS -lwrap"
+	echo "$as_me:$LINENO: checking for TCP wrappers library -lwrap" >&5
+echo $ECHO_N "checking for TCP wrappers library -lwrap... $ECHO_C" >&6
+	cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <tcpd.h>
+		     int allow_severity = 0;
+		     int deny_severity  = 0;
+
+int
+main ()
+{
+hosts_access((void *)0)
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+
+	    echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	    cat >>confdefs.h <<\_ACEOF
+#define USE_LIBWRAP 1
+_ACEOF
+
+	    test "$with_libwrap" != no -a "$with_libwrap" != yes && WRAPLIBS="-L$with_libwrap/lib"
+	    WRAPLIBS="$WRAPLIBS -lwrap"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+	    echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+	    # Linux RedHat 6.1 won't link libwrap without libnsl
+	    echo "$as_me:$LINENO: checking for yp_get_default_domain" >&5
+echo $ECHO_N "checking for yp_get_default_domain... $ECHO_C" >&6
+if test "${ac_cv_func_yp_get_default_domain+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char yp_get_default_domain (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char yp_get_default_domain ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_yp_get_default_domain) || defined (__stub___yp_get_default_domain)
+choke me
+#else
+char (*f) () = yp_get_default_domain;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != yp_get_default_domain;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_yp_get_default_domain=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_yp_get_default_domain=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_yp_get_default_domain" >&5
+echo "${ECHO_T}$ac_cv_func_yp_get_default_domain" >&6
+if test $ac_cv_func_yp_get_default_domain = yes; then
+  :
+else
+
+echo "$as_me:$LINENO: checking for yp_get_default_domain in -lnsl" >&5
+echo $ECHO_N "checking for yp_get_default_domain in -lnsl... $ECHO_C" >&6
+if test "${ac_cv_lib_nsl_yp_get_default_domain+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char yp_get_default_domain ();
+int
+main ()
+{
+yp_get_default_domain ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_yp_get_default_domain=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_nsl_yp_get_default_domain=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_yp_get_default_domain" >&5
+echo "${ECHO_T}$ac_cv_lib_nsl_yp_get_default_domain" >&6
+if test $ac_cv_lib_nsl_yp_get_default_domain = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBNSL 1
+_ACEOF
+
+  LIBS="-lnsl $LIBS"
+
+fi
+
+fi
+
+	    echo "$as_me:$LINENO: checking for TCP wrappers library -lwrap linked with -lnsl" >&5
+echo $ECHO_N "checking for TCP wrappers library -lwrap linked with -lnsl... $ECHO_C" >&6
+	    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <tcpd.h>
+		         int allow_severity = 0;
+	                 int deny_severity  = 0;
+
+int
+main ()
+{
+hosts_access((void *)0)
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+			cat >>confdefs.h <<\_ACEOF
+#define USE_LIBWRAP 1
+_ACEOF
+
+			test "$with_libwrap" != no -a "$with_libwrap" != yes && WRAPLIBS="-L$with_libwrap/lib"
+			WRAPLIBS="$WRAPLIBS -lwrap -lnsl"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+			{ { echo "$as_me:$LINENO: error: Asked to use libwrap but I couldn't find it." >&5
+echo "$as_me: error: Asked to use libwrap but I couldn't find it." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+    CPPFLAGS=${_cppflags}
+    LDFLAGS=${_ldflags}
+    LIBS=${_libs}
+  fi
+
+fi;
+
+#
+# rpm libraries only needed for the host resources mib software
+# installed tables (on linux in particular)
+#
+if test "x$with_rpm" != "xno" && \
+        echo " $module_list " | grep " host/hr_swinst " > /dev/null; then
+  # ARG.  RPM is a real pain.
+  # FWIW librpm.la, librpmio.la, and libpopt.la have correct dependencies.
+  _rpmlibs=""
+
+  # zlib is required for newer versions of rpm
+  _cppflags="${CPPFLAGS}"
+  _ldflags="${LDFLAGS}"
+
+
+# Check whether --with-zlib or --without-zlib was given.
+if test "${with_zlib+set}" = set; then
+  withval="$with_zlib"
+
+    if test -d "$withval"; then
+      CPPFLAGS="${CPPFLAGS} -I$withval/include"
+      LDFLAGS="${LDFLAGS} -L$withval/lib"
+    fi
+
+fi;
+
+  # dunno if this is needed for rpm-4.0.x, earlier probably needs.
+  if test "${ac_cv_header_zlib_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for zlib.h" >&5
+echo $ECHO_N "checking for zlib.h... $ECHO_C" >&6
+if test "${ac_cv_header_zlib_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_zlib_h" >&5
+echo "${ECHO_T}$ac_cv_header_zlib_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking zlib.h usability" >&5
+echo $ECHO_N "checking zlib.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <zlib.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking zlib.h presence" >&5
+echo $ECHO_N "checking zlib.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <zlib.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: zlib.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: zlib.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: zlib.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: zlib.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: zlib.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: zlib.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: zlib.h: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: zlib.h: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: zlib.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: zlib.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for zlib.h" >&5
+echo $ECHO_N "checking for zlib.h... $ECHO_C" >&6
+if test "${ac_cv_header_zlib_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_zlib_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_zlib_h" >&5
+echo "${ECHO_T}$ac_cv_header_zlib_h" >&6
+
+fi
+if test $ac_cv_header_zlib_h = yes; then
+
+echo "$as_me:$LINENO: checking for gzread in -lz" >&5
+echo $ECHO_N "checking for gzread in -lz... $ECHO_C" >&6
+if test "${ac_cv_lib_z_gzread+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lz  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gzread ();
+int
+main ()
+{
+gzread ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_z_gzread=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_z_gzread=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_z_gzread" >&5
+echo "${ECHO_T}$ac_cv_lib_z_gzread" >&6
+if test $ac_cv_lib_z_gzread = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBZ 1
+_ACEOF
+
+  LIBS="-lz $LIBS"
+
+else
+  CPPFLAGS=${_cppflags} LDFLAGS=${_ldflags}
+fi
+
+else
+  CPPFLAGS=${_cppflags} LDFLAGS=${_ldflags}
+fi
+
+
+
+  # two variants of bzip2 need checking.
+  echo "$as_me:$LINENO: checking for bzread in -lbz2" >&5
+echo $ECHO_N "checking for bzread in -lbz2... $ECHO_C" >&6
+if test "${ac_cv_lib_bz2_bzread+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lbz2  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char bzread ();
+int
+main ()
+{
+bzread ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_bz2_bzread=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_bz2_bzread=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_bz2_bzread" >&5
+echo "${ECHO_T}$ac_cv_lib_bz2_bzread" >&6
+if test $ac_cv_lib_bz2_bzread = yes; then
+  _rpmlibs="$_rpmlibs -lbz2"
+else
+  echo "$as_me:$LINENO: checking for BZ2_bzread in -lbz2" >&5
+echo $ECHO_N "checking for BZ2_bzread in -lbz2... $ECHO_C" >&6
+if test "${ac_cv_lib_bz2_BZ2_bzread+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lbz2  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char BZ2_bzread ();
+int
+main ()
+{
+BZ2_bzread ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_bz2_BZ2_bzread=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_bz2_BZ2_bzread=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_bz2_BZ2_bzread" >&5
+echo "${ECHO_T}$ac_cv_lib_bz2_BZ2_bzread" >&6
+if test $ac_cv_lib_bz2_BZ2_bzread = yes; then
+  _rpmlibs="$_rpmlibs -lbz2"
+fi
+
+fi
+
+
+  # two variants of db1 need checking.
+  echo "$as_me:$LINENO: checking for dbopen in -ldb1" >&5
+echo $ECHO_N "checking for dbopen in -ldb1... $ECHO_C" >&6
+if test "${ac_cv_lib_db1_dbopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldb1  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dbopen ();
+int
+main ()
+{
+dbopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_db1_dbopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_db1_dbopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_db1_dbopen" >&5
+echo "${ECHO_T}$ac_cv_lib_db1_dbopen" >&6
+if test $ac_cv_lib_db1_dbopen = yes; then
+  _rpmlibs="-ldb1 $_rpmlibs"
+else
+  echo "$as_me:$LINENO: checking for dbopen in -ldb" >&5
+echo $ECHO_N "checking for dbopen in -ldb... $ECHO_C" >&6
+if test "${ac_cv_lib_db_dbopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldb  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dbopen ();
+int
+main ()
+{
+dbopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_db_dbopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_db_dbopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_db_dbopen" >&5
+echo "${ECHO_T}$ac_cv_lib_db_dbopen" >&6
+if test $ac_cv_lib_db_dbopen = yes; then
+  _rpmlibs="-ldb $_rpmlibs"
+fi
+
+fi
+
+
+  # two variants of db3 need checking.
+  echo "$as_me:$LINENO: checking for db_create in -ldb-3.1" >&5
+echo $ECHO_N "checking for db_create in -ldb-3.1... $ECHO_C" >&6
+if test "${ac_cv_lib_db_3_1_db_create+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldb-3.1  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char db_create ();
+int
+main ()
+{
+db_create ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_db_3_1_db_create=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_db_3_1_db_create=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_db_3_1_db_create" >&5
+echo "${ECHO_T}$ac_cv_lib_db_3_1_db_create" >&6
+if test $ac_cv_lib_db_3_1_db_create = yes; then
+  _rpmlibs="-ldb-3.1 $_rpmlibs"
+else
+  echo "$as_me:$LINENO: checking for db_create in -ldb-3.0" >&5
+echo $ECHO_N "checking for db_create in -ldb-3.0... $ECHO_C" >&6
+if test "${ac_cv_lib_db_3_0_db_create+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldb-3.0  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char db_create ();
+int
+main ()
+{
+db_create ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_db_3_0_db_create=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_db_3_0_db_create=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_db_3_0_db_create" >&5
+echo "${ECHO_T}$ac_cv_lib_db_3_0_db_create" >&6
+if test $ac_cv_lib_db_3_0_db_create = yes; then
+  _rpmlibs="-ldb-3.0 $_rpmlibs"
+fi
+
+fi
+
+
+  # rpm-3.0.5 and later needs popt.
+  echo "$as_me:$LINENO: checking for poptParseArgvString in -lpopt" >&5
+echo $ECHO_N "checking for poptParseArgvString in -lpopt... $ECHO_C" >&6
+if test "${ac_cv_lib_popt_poptParseArgvString+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpopt  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char poptParseArgvString ();
+int
+main ()
+{
+poptParseArgvString ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_popt_poptParseArgvString=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_popt_poptParseArgvString=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_popt_poptParseArgvString" >&5
+echo "${ECHO_T}$ac_cv_lib_popt_poptParseArgvString" >&6
+if test $ac_cv_lib_popt_poptParseArgvString = yes; then
+  _rpmlibs="-lpopt $_rpmlibs"
+fi
+
+
+  # rpm-4.0.x needs rpmio.
+  echo "$as_me:$LINENO: checking for Fopen in -lrpmio" >&5
+echo $ECHO_N "checking for Fopen in -lrpmio... $ECHO_C" >&6
+if test "${ac_cv_lib_rpmio_Fopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrpmio $_rpmlibs $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char Fopen ();
+int
+main ()
+{
+Fopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_rpmio_Fopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_rpmio_Fopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_rpmio_Fopen" >&5
+echo "${ECHO_T}$ac_cv_lib_rpmio_Fopen" >&6
+if test $ac_cv_lib_rpmio_Fopen = yes; then
+  _rpmlibs="-lrpmio $_rpmlibs"
+fi
+
+
+  # now check for rpm using the appropriate libraries.
+  echo "$as_me:$LINENO: checking for rpmGetFilesystemList in -lrpm" >&5
+echo $ECHO_N "checking for rpmGetFilesystemList in -lrpm... $ECHO_C" >&6
+if test "${ac_cv_lib_rpm_rpmGetFilesystemList+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrpm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char rpmGetFilesystemList ();
+int
+main ()
+{
+rpmGetFilesystemList ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_rpm_rpmGetFilesystemList=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_rpm_rpmGetFilesystemList=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_rpm_rpmGetFilesystemList" >&5
+echo "${ECHO_T}$ac_cv_lib_rpm_rpmGetFilesystemList" >&6
+if test $ac_cv_lib_rpm_rpmGetFilesystemList = yes; then
+
+    cat >>confdefs.h <<\_ACEOF
+#define HAVE_LIBRPM 1
+_ACEOF
+
+    LIBS="-lrpm $_rpmlibs $LIBS"
+    CFLAGS="$CFLAGS -I/usr/include/rpm"
+
+else
+
+    # rpm-4.0.3 librpmdb actually contains what we need.
+    echo "$as_me:$LINENO: checking for rpmdbOpen in -lrpmdb" >&5
+echo $ECHO_N "checking for rpmdbOpen in -lrpmdb... $ECHO_C" >&6
+if test "${ac_cv_lib_rpmdb_rpmdbOpen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrpmdb -lrpm $_rpmlibs $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char rpmdbOpen ();
+int
+main ()
+{
+rpmdbOpen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_rpmdb_rpmdbOpen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_rpmdb_rpmdbOpen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_rpmdb_rpmdbOpen" >&5
+echo "${ECHO_T}$ac_cv_lib_rpmdb_rpmdbOpen" >&6
+if test $ac_cv_lib_rpmdb_rpmdbOpen = yes; then
+
+      cat >>confdefs.h <<\_ACEOF
+#define HAVE_LIBRPM 1
+_ACEOF
+
+      LIBS="-lrpmdb -lrpm $_rpmlibs $LIBS"
+      CFLAGS="$CFLAGS -I/usr/include/rpm"
+
+fi
+
+
+fi
+
+fi
+
+# Replace `main' with a function in -lkvm:
+
+echo "$as_me:$LINENO: checking for kvm_read in -lkvm" >&5
+echo $ECHO_N "checking for kvm_read in -lkvm... $ECHO_C" >&6
+if test "${ac_cv_lib_kvm_kvm_read+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lkvm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char kvm_read ();
+int
+main ()
+{
+kvm_read ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_kvm_kvm_read=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_kvm_kvm_read=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_kvm_kvm_read" >&5
+echo "${ECHO_T}$ac_cv_lib_kvm_kvm_read" >&6
+if test $ac_cv_lib_kvm_kvm_read = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBKVM 1
+_ACEOF
+
+  LIBS="-lkvm $LIBS"
+
+fi
+
+# DYNAMIC MODULE SUPPORT
+
+echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
+echo $ECHO_N "checking for dlopen in -ldl... $ECHO_C" >&6
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dlopen ();
+int
+main ()
+{
+dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dl_dlopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_dl_dlopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
+echo "${ECHO_T}$ac_cv_lib_dl_dlopen" >&6
+if test $ac_cv_lib_dl_dlopen = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBDL 1
+_ACEOF
+
+  LIBS="-ldl $LIBS"
+
+fi
+
+
+for ac_func in dlopen
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+for ac_func in kvm_openfiles nlist knlist kvm_getprocs
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+echo "$with_mib_modules" | grep "ucd-snmp/diskio" >/dev/null
+# whether we need -ldevstat for diskio MIB
+if test $? -eq 0 ; then
+	echo "$as_me:$LINENO: checking for getdevs" >&5
+echo $ECHO_N "checking for getdevs... $ECHO_C" >&6
+if test "${ac_cv_func_getdevs+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char getdevs (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getdevs ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_getdevs) || defined (__stub___getdevs)
+choke me
+#else
+char (*f) () = getdevs;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != getdevs;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_getdevs=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_getdevs=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_getdevs" >&5
+echo "${ECHO_T}$ac_cv_func_getdevs" >&6
+if test $ac_cv_func_getdevs = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETDEVS 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: checking for getdevs in -ldevstat" >&5
+echo $ECHO_N "checking for getdevs in -ldevstat... $ECHO_C" >&6
+if test "${ac_cv_lib_devstat_getdevs+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldevstat  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getdevs ();
+int
+main ()
+{
+getdevs ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_devstat_getdevs=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_devstat_getdevs=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_devstat_getdevs" >&5
+echo "${ECHO_T}$ac_cv_lib_devstat_getdevs" >&6
+if test $ac_cv_lib_devstat_getdevs = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETDEVS 1
+_ACEOF
+
+		LIBS="${LIBS} -ldevstat"
+fi
+
+fi
+
+fi
+
+# LM-SENSORS-MIB support
+echo " $with_mib_modules " | grep " ucd-snmp/lmSensors " > /dev/null
+if test $? -eq 0 ; then
+        if test "${ac_cv_header_sensors_sensors_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for sensors/sensors.h" >&5
+echo $ECHO_N "checking for sensors/sensors.h... $ECHO_C" >&6
+if test "${ac_cv_header_sensors_sensors_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_sensors_sensors_h" >&5
+echo "${ECHO_T}$ac_cv_header_sensors_sensors_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking sensors/sensors.h usability" >&5
+echo $ECHO_N "checking sensors/sensors.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <sensors/sensors.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking sensors/sensors.h presence" >&5
+echo $ECHO_N "checking sensors/sensors.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sensors/sensors.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: sensors/sensors.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: sensors/sensors.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sensors/sensors.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: sensors/sensors.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: sensors/sensors.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: sensors/sensors.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sensors/sensors.h: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: sensors/sensors.h: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sensors/sensors.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: sensors/sensors.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for sensors/sensors.h" >&5
+echo $ECHO_N "checking for sensors/sensors.h... $ECHO_C" >&6
+if test "${ac_cv_header_sensors_sensors_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_sensors_sensors_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_sensors_sensors_h" >&5
+echo "${ECHO_T}$ac_cv_header_sensors_sensors_h" >&6
+
+fi
+
+
+
+echo "$as_me:$LINENO: checking for sensors_get_detected_chips in -lsensors" >&5
+echo $ECHO_N "checking for sensors_get_detected_chips in -lsensors... $ECHO_C" >&6
+if test "${ac_cv_lib_sensors_sensors_get_detected_chips+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsensors  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char sensors_get_detected_chips ();
+int
+main ()
+{
+sensors_get_detected_chips ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_sensors_sensors_get_detected_chips=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_sensors_sensors_get_detected_chips=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_sensors_sensors_get_detected_chips" >&5
+echo "${ECHO_T}$ac_cv_lib_sensors_sensors_get_detected_chips" >&6
+if test $ac_cv_lib_sensors_sensors_get_detected_chips = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBSENSORS 1
+_ACEOF
+
+  LIBS="-lsensors $LIBS"
+
+fi
+
+fi
+
+#
+# Install the various perl modules
+#
+
+if test "x$embed_perl" = "xyes" -a "x$install_perl" = "xno" ; then
+  install_perl="yes"
+fi
+if test "x$install_perl" != "x" -a "x$install_perl" != "xno"; then
+    PERLTARGS="perlmodules"
+    PERLINSTALLTARGS="perlinstall"
+    PERLUNINSTALLTARGS="perluninstall"
+
+
+
+
+
+  cat >> configure-summary << EOF
+  SNMP Perl modules:          enabled
+EOF
+
+else
+
+  cat >> configure-summary << EOF
+  SNMP Perl modules:          disabled
+EOF
+
+fi
+
+#
+# Embedded Perl specific stuff
+#
+if test "x$embed_perl" = "xyes"; then
+    myperl=$ac_cv_path_PERLPROG
+    if test $myperl = "no"; then
+      { { echo "$as_me:$LINENO: error: --enable-embedded-perl requested but no perl executable found" >&5
+echo "$as_me: error: --enable-embedded-perl requested but no perl executable found" >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+
+    echo "$as_me:$LINENO: checking for perl CFLAGS" >&5
+echo $ECHO_N "checking for perl CFLAGS... $ECHO_C" >&6
+    perlcflags=`$myperl -MExtUtils::Embed -e ccopts`
+    echo "$as_me:$LINENO: result: $perlcflags" >&5
+echo "${ECHO_T}$perlcflags" >&6
+    CPPFLAGS="$CPPFLAGS $perlcflags"
+
+    echo "$as_me:$LINENO: checking for perl LDFLAGS" >&5
+echo $ECHO_N "checking for perl LDFLAGS... $ECHO_C" >&6
+    perlldopts=`$myperl -MExtUtils::Embed -e ldopts`
+    echo "$as_me:$LINENO: result: $perlldopts" >&5
+echo "${ECHO_T}$perlldopts" >&6
+    LIBS="$LIBS $perlldopts"
+
+    # newer perl vs older perl call functions
+
+
+for ac_func in eval_pv perl_eval_pv
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+    cat >>confdefs.h <<\_ACEOF
+#define NETSNMP_EMBEDDED_PERL 1
+_ACEOF
+
+    OTHERAGENTLIBOBJS="snmp_perl.o"
+    OTHERAGENTLIBLOBJS="snmp_perl.lo"
+
+    EMBEDPERLINSTALL="embedperlinstall"
+    EMBEDPERLUNINSTALL="embedperluninstall"
+
+  cat >> configure-summary << EOF
+  Embedded perl support:      enabled
+EOF
+
+else
+    EMBEDPERLINSTALL=""
+    EMBEDPERLUNINSTALL=""
+
+  cat >> configure-summary << EOF
+  Embedded perl support:      disabled
+EOF
+
+fi
+
+
+
+# reset libs
+AGENTLIBS=$LIBS
+LIBS=$NONAGENTLIBS
+
+# Checks for header files.
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_stdc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_stdc=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+                   (('a' <= (c) && (c) <= 'i') \
+                     || ('j' <= (c) && (c) <= 'r') \
+                     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+        || toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_header_stdc=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
+_ACEOF
+
+fi
+
+
+
+
+
+
+ac_header_dirent=no
+for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h; do
+  as_ac_Header=`echo "ac_cv_header_dirent_$ac_hdr" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_hdr that defines DIR" >&5
+echo $ECHO_N "checking for $ac_hdr that defines DIR... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <$ac_hdr>
+
+int
+main ()
+{
+if ((DIR *) 0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_Header=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
+_ACEOF
+
+ac_header_dirent=$ac_hdr; break
+fi
+
+done
+# Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
+if test $ac_header_dirent = dirent.h; then
+  echo "$as_me:$LINENO: checking for library containing opendir" >&5
+echo $ECHO_N "checking for library containing opendir... $ECHO_C" >&6
+if test "${ac_cv_search_opendir+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_opendir=no
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char opendir ();
+int
+main ()
+{
+opendir ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_opendir="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_opendir" = no; then
+  for ac_lib in dir; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char opendir ();
+int
+main ()
+{
+opendir ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_opendir="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_opendir" >&5
+echo "${ECHO_T}$ac_cv_search_opendir" >&6
+if test "$ac_cv_search_opendir" != no; then
+  test "$ac_cv_search_opendir" = "none required" || LIBS="$ac_cv_search_opendir $LIBS"
+
+fi
+
+else
+  echo "$as_me:$LINENO: checking for library containing opendir" >&5
+echo $ECHO_N "checking for library containing opendir... $ECHO_C" >&6
+if test "${ac_cv_search_opendir+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_opendir=no
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char opendir ();
+int
+main ()
+{
+opendir ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_opendir="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_opendir" = no; then
+  for ac_lib in x; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char opendir ();
+int
+main ()
+{
+opendir ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_opendir="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_opendir" >&5
+echo "${ECHO_T}$ac_cv_search_opendir" >&6
+if test "$ac_cv_search_opendir" != no; then
+  test "$ac_cv_search_opendir" = "none required" || LIBS="$ac_cv_search_opendir $LIBS"
+
+fi
+
+fi
+
+echo "$as_me:$LINENO: checking for sys/wait.h that is POSIX.1 compatible" >&5
+echo $ECHO_N "checking for sys/wait.h that is POSIX.1 compatible... $ECHO_C" >&6
+if test "${ac_cv_header_sys_wait_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/wait.h>
+#ifndef WEXITSTATUS
+# define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
+#endif
+#ifndef WIFEXITED
+# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
+#endif
+
+int
+main ()
+{
+  int s;
+  wait (&s);
+  s = WIFEXITED (s) ? WEXITSTATUS (s) : 1;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_sys_wait_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_sys_wait_h=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_sys_wait_h" >&5
+echo "${ECHO_T}$ac_cv_header_sys_wait_h" >&6
+if test $ac_cv_header_sys_wait_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_SYS_WAIT_H 1
+_ACEOF
+
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in stdarg.h string.h fcntl.h limits.h sys/file.h sys/ioctl.h syslog.h unistd.h netinet/tcpip.h netinet/in.h netinet/ip.h netinet/ip_icmp.h net/if.h netdb.h sys/dmap.h machine/pte.h xti.h sys/sockio.h sys/socket.h sys/un.h fstab.h sys/fs.h mtab.h ufs/fs.h ufs/ffs/fs.h sys/fixpoint.h machine/param.h sys/vm.h vm/vm.h sys/vmmeter.h sys/vmparam.h sys/vmmac.h sys/vmsystm.h sys/mbuf.h sys/time.h sys/swap.h inet/mib2.h sys/statvfs.h sys/vfs.h sys/mnttab.h sys/user.h sys/proc.h sys/select.h mntent.h sys/mntent.h kstat.h utsname.h sys/utsname.h sys/cdefs.h getopt.h locale.h pthread.h sys/loadavg.h regex.h linux/tasks.h pwd.h grp.h utmpx.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# FreeBSD required headers
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in malloc.h sys/param.h net/if_dl.h sys/sysctl.h stdlib.h net/if_mib.h net/if_types.h net/if_var.h sys/queue.h osreldate.h machine/types.h sys/socketvar.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# Linux
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in sys/conf.h netinet/in_systm.h netinet/tcp.h netinet/udp.h netinet/in_var.h netinet/if_ether.h netinet/ip_var.h netinet/tcp_timer.h netinet/tcp_var.h netinet/tcp_fsm.h netinet/udp_var.h netinet/icmp_var.h sys/protosw.h nlist.h ioctls.h asm/page.h netipx/ipx.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# NetBSD required headers
+
+
+
+
+
+
+
+for ac_header in arpa/inet.h kvm.h sys/pool.h uvm/uvm_param.h uvm/uvm_extern.h vm/vm_param.h vm/vm_extern.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# BSDi2 headers
+
+
+
+for ac_header in sys/mount.h vm/swap_pager.h ufs/ufs/dinode.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# BSDi3 headers
+
+
+
+
+for ac_header in sys/stat.h sys/vnode.h ufs/ufs/quota.h ufs/ufs/inode.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# irix headers
+
+
+
+for ac_header in sys/hashing.h sys/tcpipstats.h sys/sysmp.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# from smux stuff
+
+
+
+for ac_header in err.h sys/filio.h sgtty.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# AIX needs this for statfs func
+
+for ac_header in sys/statfs.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# Dynix
+
+for ac_header in net/route.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# for HostRes (HP-UX at least)
+
+
+
+
+
+for ac_header in sys/dkio.h sys/diskio.h sys/pstat.h linux/hdreg.h pkglocs.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# for HostRes (Solaris 2.x at least)
+
+for ac_header in pkginfo.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ echo "$as_me:$LINENO: checking for pkginfo in -ladm" >&5
+echo $ECHO_N "checking for pkginfo in -ladm... $ECHO_C" >&6
+if test "${ac_cv_lib_adm_pkginfo+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ladm  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char pkginfo ();
+int
+main ()
+{
+pkginfo ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_adm_pkginfo=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_adm_pkginfo=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_adm_pkginfo" >&5
+echo "${ECHO_T}$ac_cv_lib_adm_pkginfo" >&6
+if test $ac_cv_lib_adm_pkginfo = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_PKGINFO 1
+_ACEOF
+
+    LIBS="${LIBS} -ladm"
+    AGENTLIBS="${AGENTLIBS} -ladm"
+fi
+
+fi
+
+done
+
+# AIX perfstat library, needed for CPU/memory statistics
+case $target_os in
+    aix*)
+
+for ac_header in libperfstat.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ echo "$as_me:$LINENO: checking for perfstat_cpu_total in -lperfstat" >&5
+echo $ECHO_N "checking for perfstat_cpu_total in -lperfstat... $ECHO_C" >&6
+if test "${ac_cv_lib_perfstat_perfstat_cpu_total+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lperfstat  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char perfstat_cpu_total ();
+int
+main ()
+{
+perfstat_cpu_total ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_perfstat_perfstat_cpu_total=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_perfstat_perfstat_cpu_total=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_perfstat_perfstat_cpu_total" >&5
+echo "${ECHO_T}$ac_cv_lib_perfstat_perfstat_cpu_total" >&6
+if test $ac_cv_lib_perfstat_perfstat_cpu_total = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_PERFSTAT 1
+_ACEOF
+
+            AGENTLIBS="${AGENTLIBS} -lperfstat"
+fi
+
+else
+  { { echo "$as_me:$LINENO: error:
+
+*** To monitor CPU/memory values in AIX you need to install
+*** libperfstat which can be found in bos.perf
+" >&5
+echo "$as_me: error:
+
+*** To monitor CPU/memory values in AIX you need to install
+*** libperfstat which can be found in bos.perf
+" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+done
+
+        ;;
+    *)
+        ;;
+esac
+# WIN32
+
+for ac_header in winsock.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ AGENTLIBS="${AGENTLIBS} -liphlpapi"
+fi
+
+done
+
+
+for ac_header in io.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# SCO
+
+for ac_header in sys/stream.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# KAME
+
+
+
+
+
+
+
+
+
+for ac_header in netinet/ip6.h netinet6/in6_var.h netinet6/in6_pcb.h netinet6/ip6_var.h netinet6/tcp6.h netinet6/tcp6_fsm.h netinet6/nd6.h netinet6/tcp6_timer.h netinet6/tcp6_var.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# DYNAMIC MODULE SUPPORT
+
+for ac_header in dlfcn.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+# table_array helper support
+
+for ac_header in search.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+# RPM subdirectory path (sigh)
+if test "x$with_rpm" != "xno" && \
+        echo " $module_list " | grep " host/hr_swinst " > /dev/null; then
+
+for ac_header in rpmio.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+else
+
+
+for ac_header in rpm/rpmio.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ CFLAGS="-I/usr/include/rpm $CFLAGS"
+fi
+
+done
+
+
+fi
+
+done
+
+fi
+
+# OpenBSD 2.6 needs netinet/in.h before netinet/in_pcb.h
+echo "$as_me:$LINENO: checking for netinet/in_pcb.h" >&5
+echo $ECHO_N "checking for netinet/in_pcb.h... $ECHO_C" >&6
+if test "${cv_have_netinet_in_pcb_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+   cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <netinet/in.h>
+#include <netinet/in_pcb.h>
+
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  cv_have_netinet_in_pcb_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  cv_have_netinet_in_pcb_h=no
+fi
+rm -f conftest.err conftest.$ac_ext
+fi
+
+echo "$as_me:$LINENO: result: $cv_have_netinet_in_pcb_h" >&5
+echo "${ECHO_T}$cv_have_netinet_in_pcb_h" >&6
+if test $cv_have_netinet_in_pcb_h = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_NETINET_IN_PCB_H 1
+_ACEOF
+
+fi
+
+# NetBSD needs machine/types.h before sys/disklabel.h
+echo "$as_me:$LINENO: checking for sys/disklabel.h" >&5
+echo $ECHO_N "checking for sys/disklabel.h... $ECHO_C" >&6
+if test "${cv_have_sys_disklabel_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+   cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <machine/types.h>
+#include <sys/disklabel.h>
+
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  cv_have_sys_disklabel_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  cv_have_sys_disklabel_h=no
+fi
+rm -f conftest.err conftest.$ac_ext
+fi
+
+echo "$as_me:$LINENO: result: $cv_have_sys_disklabel_h" >&5
+echo "${ECHO_T}$cv_have_sys_disklabel_h" >&6
+if test $cv_have_sys_disklabel_h = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_SYS_DISKLABEL_H 1
+_ACEOF
+
+fi
+
+# OpenSSL
+
+
+
+
+for ac_header in openssl/hmac.h openssl/evp.h openssl/aes.h openssl/des.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+# Printing
+# Extract the first word of "lpstat", so it can be a program name with args.
+set dummy lpstat; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_LPSTAT_PATH+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $LPSTAT_PATH in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_LPSTAT_PATH="$LPSTAT_PATH" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_LPSTAT_PATH="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  ;;
+esac
+fi
+LPSTAT_PATH=$ac_cv_path_LPSTAT_PATH
+
+if test -n "$LPSTAT_PATH"; then
+  echo "$as_me:$LINENO: result: $LPSTAT_PATH" >&5
+echo "${ECHO_T}$LPSTAT_PATH" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+if test x$LPSTAT_PATH != x; then
+    cat >>confdefs.h <<_ACEOF
+#define LPSTAT_PATH "$LPSTAT_PATH"
+_ACEOF
+
+    cat >>confdefs.h <<\_ACEOF
+#define HAVE_LPSTAT 1
+_ACEOF
+
+fi
+
+for ac_func in cgetnext
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+if test -r /etc/printcap; then
+    cat >>confdefs.h <<\_ACEOF
+#define HAVE_PRINTCAP 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for authentication support" >&5
+echo $ECHO_N "checking for authentication support... $ECHO_C" >&6
+if test "x$ac_cv_lib_crypto_EVP_md5" != "xyes" -o "x$ac_cv_header_openssl_hmac_h" != "xyes" -o "x$ac_cv_header_openssl_hmac_h" != "xyes"; then
+# if OpenSSL is not found, default to using internal md5 support.
+    cat >>confdefs.h <<\_ACEOF
+#define USE_INTERNAL_MD5 1
+_ACEOF
+
+    authmodes="MD5"
+    encrmodes=""
+    echo "$as_me:$LINENO: result: Internal MD5 Support" >&5
+echo "${ECHO_T}Internal MD5 Support" >&6
+    if test "x$askedopenssl" = "xyes"; then
+	{ { echo "$as_me:$LINENO: error: Asked to use OpenSSL but I couldn't find it." >&5
+echo "$as_me: error: Asked to use OpenSSL but I couldn't find it." >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+else
+    if test "x$tryopenssl" = "xno"; then
+        authmodes="MD5"
+        encrmodes=""
+	cat >>confdefs.h <<\_ACEOF
+#define USE_INTERNAL_MD5 1
+_ACEOF
+
+	echo "$as_me:$LINENO: result: Internal MD5 Support" >&5
+echo "${ECHO_T}Internal MD5 Support" >&6
+    else
+        authmodes="MD5 SHA1"
+        if test "x$enable_privacy" != "xno" ; then
+	    if test $ac_cv_header_openssl_aes_h = "yes" ; then
+	        encrmodes="DES AES128 AES192 AES256"
+	    else
+	        encrmodes="DES"
+	    fi
+        else
+	    encrmodes="disabled"
+        fi
+	cat >>confdefs.h <<\_ACEOF
+#define USE_OPENSSL 1
+_ACEOF
+
+	echo "$as_me:$LINENO: result: OpenSSL Support" >&5
+echo "${ECHO_T}OpenSSL Support" >&6
+    fi
+fi
+
+
+  cat >> configure-summary << EOF
+  Authentication support:     $authmodes
+EOF
+
+
+  cat >> configure-summary << EOF
+  Encryption support:         $encrmodes
+EOF
+
+
+# Checks for typedefs, structures, and compiler characteristics.
+echo "$as_me:$LINENO: checking for off_t" >&5
+echo $ECHO_N "checking for off_t... $ECHO_C" >&6
+if test "${ac_cv_type_off_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((off_t *) 0)
+  return 0;
+if (sizeof (off_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_off_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_off_t=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
+echo "${ECHO_T}$ac_cv_type_off_t" >&6
+if test $ac_cv_type_off_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define off_t long
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for pid_t" >&5
+echo $ECHO_N "checking for pid_t... $ECHO_C" >&6
+if test "${ac_cv_type_pid_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((pid_t *) 0)
+  return 0;
+if (sizeof (pid_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_pid_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_pid_t=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_pid_t" >&5
+echo "${ECHO_T}$ac_cv_type_pid_t" >&6
+if test $ac_cv_type_pid_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define pid_t int
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking whether time.h and sys/time.h may both be included" >&5
+echo $ECHO_N "checking whether time.h and sys/time.h may both be included... $ECHO_C" >&6
+if test "${ac_cv_header_time+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+
+int
+main ()
+{
+if ((struct tm *) 0)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_time=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_time=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_time" >&5
+echo "${ECHO_T}$ac_cv_header_time" >&6
+if test $ac_cv_header_time = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define TIME_WITH_SYS_TIME 1
+_ACEOF
+
+fi
+
+
+# this should use AC_CHECK_TYPE, but it's broken at least in 2.13-14
+# so we do it by hand.
+echo "$as_me:$LINENO: checking for socklen_t" >&5
+echo $ECHO_N "checking for socklen_t... $ECHO_C" >&6
+if eval "test \"\${ac_cv_type_$1+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "socklen_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  ac_cv_type_socklen_t=yes
+else
+  ac_cv_type_socklen_t=no
+fi
+rm -f conftest*
+
+fi
+
+
+echo "$as_me:$LINENO: result: $ac_cv_type_socklen_t" >&5
+echo "${ECHO_T}$ac_cv_type_socklen_t" >&6
+if test $ac_cv_type_socklen_t = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_SOCKLEN_T 1
+_ACEOF
+
+fi
+
+# AIX keeps in_addr_t in /usr/include/netinet/in.h
+echo "$as_me:$LINENO: checking for in_addr_t" >&5
+echo $ECHO_N "checking for in_addr_t... $ECHO_C" >&6
+if eval "test \"\${ac_cv_type_$1+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "in_addr_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  ac_cv_type_in_addr_t=yes
+else
+  ac_cv_type_in_addr_t=no
+fi
+rm -f conftest*
+
+fi
+
+
+echo "$as_me:$LINENO: result: $ac_cv_type_in_addr_t" >&5
+echo "${ECHO_T}$ac_cv_type_in_addr_t" >&6
+if test $ac_cv_type_in_addr_t = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_IN_ADDR_T 1
+_ACEOF
+
+fi
+
+# Check ps args
+echo "$as_me:$LINENO: checking for correct flags to ps" >&5
+echo $ECHO_N "checking for correct flags to ps... $ECHO_C" >&6
+if test "${ac_cv_ps_flags+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "`($PSPROG -e 2>&1) | egrep ' (ps) *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="-e"
+elif test "`($PSPROG -el 2>&1) | egrep ' (ps) *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="-el"
+elif test "`($PSPROG acx 2>&1) | egrep ' (ps) *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="acx"
+elif test "`($PSPROG -acx 2>&1) | egrep ' (ps) *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="-acx"
+elif test "`($PSPROG -o pid,tt,state,time,ucomm 2>&1) | egrep ' ps *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="-o pid,tt,state,time,ucomm"
+elif test "`($PSPROG ax 2>&1) | egrep ' (ps) *$' | awk '{print $NF}'`" = "ps" ; then
+  ac_cv_ps_flags="ax"
+else
+  { echo "$as_me:$LINENO: WARNING: Unable to determine valid ps flags...  defaulting..." >&5
+echo "$as_me: WARNING: Unable to determine valid ps flags...  defaulting..." >&2;}
+  ac_cv_ps_flags="-acx"
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_ps_flags" >&5
+echo "${ECHO_T}$ac_cv_ps_flags" >&6
+
+PSCMD="$PSPROG $ac_cv_ps_flags"
+
+cat >>confdefs.h <<_ACEOF
+#define PSCMD "$PSPROG $ac_cv_ps_flags"
+_ACEOF
+
+
+# Checks for byte order
+if test $cross_compiling = yes; then
+  if test $with_endianness = "big"; then
+    cat >>confdefs.h <<\_ACEOF
+#define WORDS_BIGENDIAN 1
+_ACEOF
+
+  elif test -z $with_endianness; then
+    { { echo "$as_me:$LINENO: error: You are cross-compiling, but you have not specified the target's endianness" >&5
+echo "$as_me: error: You are cross-compiling, but you have not specified the target's endianness" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+else
+  if test $with_endianness; then
+    { { echo "$as_me:$LINENO: error: Endianness has been specified, but you are not cross-compiling." >&5
+echo "$as_me: error: Endianness has been specified, but you are not cross-compiling." >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  echo "$as_me:$LINENO: checking whether byte ordering is bigendian" >&5
+echo $ECHO_N "checking whether byte ordering is bigendian... $ECHO_C" >&6
+if test "${ac_cv_c_bigendian+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # See if sys/param.h defines the BYTE_ORDER macro.
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/param.h>
+
+int
+main ()
+{
+#if !BYTE_ORDER || !BIG_ENDIAN || !LITTLE_ENDIAN
+ bogus endian macros
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  # It does; now see whether it defined to BIG_ENDIAN or not.
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/param.h>
+
+int
+main ()
+{
+#if BYTE_ORDER != BIG_ENDIAN
+ not big endian
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_bigendian=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_c_bigendian=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+# It does not; compile a test program.
+if test "$cross_compiling" = yes; then
+  # try to guess the endianness by grepping values into an object file
+  ac_cv_c_bigendian=unknown
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
+short ascii_ii[] = { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
+void _ascii () { char *s = (char *) ascii_mm; s = (char *) ascii_ii; }
+short ebcdic_ii[] = { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
+short ebcdic_mm[] = { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
+void _ebcdic () { char *s = (char *) ebcdic_mm; s = (char *) ebcdic_ii; }
+int
+main ()
+{
+ _ascii (); _ebcdic ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if grep BIGenDianSyS conftest.$ac_objext >/dev/null ; then
+  ac_cv_c_bigendian=yes
+fi
+if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
+  if test "$ac_cv_c_bigendian" = unknown; then
+    ac_cv_c_bigendian=no
+  else
+    # finding both strings is unlikely to happen, but who knows?
+    ac_cv_c_bigendian=unknown
+  fi
+fi
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+int
+main ()
+{
+  /* Are we little or big endian?  From Harbison&Steele.  */
+  union
+  {
+    long l;
+    char c[sizeof (long)];
+  } u;
+  u.l = 1;
+  exit (u.c[sizeof (long) - 1] == 1);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_bigendian=no
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_c_bigendian=yes
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_bigendian" >&5
+echo "${ECHO_T}$ac_cv_c_bigendian" >&6
+case $ac_cv_c_bigendian in
+  yes)
+
+cat >>confdefs.h <<\_ACEOF
+#define WORDS_BIGENDIAN 1
+_ACEOF
+ ;;
+  no)
+     ;;
+  *)
+    { { echo "$as_me:$LINENO: error: unknown endianness
+presetting ac_cv_c_bigendian=no (or yes) will help" >&5
+echo "$as_me: error: unknown endianness
+presetting ac_cv_c_bigendian=no (or yes) will help" >&2;}
+   { (exit 1); exit 1; }; } ;;
+esac
+
+fi
+
+# Checks for library functions.
+# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+# for constant arguments.  Useless!
+echo "$as_me:$LINENO: checking for working alloca.h" >&5
+echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6
+if test "${ac_cv_working_alloca_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <alloca.h>
+int
+main ()
+{
+char *p = (char *) alloca (2 * sizeof (int));
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_working_alloca_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_working_alloca_h=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_working_alloca_h" >&5
+echo "${ECHO_T}$ac_cv_working_alloca_h" >&6
+if test $ac_cv_working_alloca_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA_H 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for alloca" >&5
+echo $ECHO_N "checking for alloca... $ECHO_C" >&6
+if test "${ac_cv_func_alloca_works+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+#else
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  if HAVE_ALLOCA_H
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+int
+main ()
+{
+char *p = (char *) alloca (1);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_alloca_works=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_alloca_works=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_alloca_works" >&5
+echo "${ECHO_T}$ac_cv_func_alloca_works" >&6
+
+if test $ac_cv_func_alloca_works = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA 1
+_ACEOF
+
+else
+  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+# that cause trouble.  Some versions do not even contain alloca or
+# contain a buggy version.  If you still want to use their alloca,
+# use ar to extract alloca.o from them instead of compiling alloca.c.
+
+ALLOCA=alloca.$ac_objext
+
+cat >>confdefs.h <<\_ACEOF
+#define C_ALLOCA 1
+_ACEOF
+
+
+echo "$as_me:$LINENO: checking whether \`alloca.c' needs Cray hooks" >&5
+echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6
+if test "${ac_cv_os_cray+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined(CRAY) && ! defined(CRAY2)
+webecray
+#else
+wenotbecray
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "webecray" >/dev/null 2>&1; then
+  ac_cv_os_cray=yes
+else
+  ac_cv_os_cray=no
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_os_cray" >&5
+echo "${ECHO_T}$ac_cv_os_cray" >&6
+if test $ac_cv_os_cray = yes; then
+  for ac_func in _getb67 GETB67 getb67; do
+    as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define CRAY_STACKSEG_END $ac_func
+_ACEOF
+
+    break
+fi
+
+  done
+fi
+
+echo "$as_me:$LINENO: checking stack direction for C alloca" >&5
+echo $ECHO_N "checking stack direction for C alloca... $ECHO_C" >&6
+if test "${ac_cv_c_stack_direction+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_c_stack_direction=0
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+int
+find_stack_direction ()
+{
+  static char *addr = 0;
+  auto char dummy;
+  if (addr == 0)
+    {
+      addr = &dummy;
+      return find_stack_direction ();
+    }
+  else
+    return (&dummy > addr) ? 1 : -1;
+}
+
+int
+main ()
+{
+  exit (find_stack_direction () < 0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_stack_direction=1
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_c_stack_direction=-1
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
+echo "${ECHO_T}$ac_cv_c_stack_direction" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define STACK_DIRECTION $ac_cv_c_stack_direction
+_ACEOF
+
+
+fi
+
+if test $ac_cv_c_compiler_gnu = yes; then
+    echo "$as_me:$LINENO: checking whether $CC needs -traditional" >&5
+echo $ECHO_N "checking whether $CC needs -traditional... $ECHO_C" >&6
+if test "${ac_cv_prog_gcc_traditional+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+    ac_pattern="Autoconf.*'x'"
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sgtty.h>
+Autoconf TIOCGETP
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "$ac_pattern" >/dev/null 2>&1; then
+  ac_cv_prog_gcc_traditional=yes
+else
+  ac_cv_prog_gcc_traditional=no
+fi
+rm -f conftest*
+
+
+  if test $ac_cv_prog_gcc_traditional = no; then
+    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <termio.h>
+Autoconf TCGETA
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "$ac_pattern" >/dev/null 2>&1; then
+  ac_cv_prog_gcc_traditional=yes
+fi
+rm -f conftest*
+
+  fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_gcc_traditional" >&5
+echo "${ECHO_T}$ac_cv_prog_gcc_traditional" >&6
+  if test $ac_cv_prog_gcc_traditional = yes; then
+    CC="$CC -traditional"
+  fi
+fi
+
+echo "$as_me:$LINENO: checking for working memcmp" >&5
+echo $ECHO_N "checking for working memcmp... $ECHO_C" >&6
+if test "${ac_cv_func_memcmp_working+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_memcmp_working=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  /* Some versions of memcmp are not 8-bit clean.  */
+  char c0 = 0x40, c1 = 0x80, c2 = 0x81;
+  if (memcmp(&c0, &c2, 1) >= 0 || memcmp(&c1, &c2, 1) >= 0)
+    exit (1);
+
+  /* The Next x86 OpenStep bug shows up only when comparing 16 bytes
+     or more and with at least one buffer not starting on a 4-byte boundary.
+     William Lewis provided this test program.   */
+  {
+    char foo[21];
+    char bar[21];
+    int i;
+    for (i = 0; i < 4; i++)
+      {
+        char *a = foo + i;
+        char *b = bar + i;
+        strcpy (a, "--------01111111");
+        strcpy (b, "--------10000000");
+        if (memcmp (a, b, 16) >= 0)
+          exit (1);
+      }
+    exit (0);
+  }
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_memcmp_working=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_func_memcmp_working=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_memcmp_working" >&5
+echo "${ECHO_T}$ac_cv_func_memcmp_working" >&6
+test $ac_cv_func_memcmp_working = no && LIBOBJS="$LIBOBJS memcmp.$ac_objext"
+
+echo "$as_me:$LINENO: checking return type of signal handlers" >&5
+echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6
+if test "${ac_cv_type_signal+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+# undef signal
+#endif
+#ifdef __cplusplus
+extern "C" void (*signal (int, void (*)(int)))(int);
+#else
+void (*signal ()) ();
+#endif
+
+int
+main ()
+{
+int i;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_signal=void
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_signal=int
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_signal" >&5
+echo "${ECHO_T}$ac_cv_type_signal" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define RETSIGTYPE $ac_cv_type_signal
+_ACEOF
+
+
+# getmntent is in -lsun on Irix 4, -lseq on Dynix/PTX, -lgen on Unixware.
+echo "$as_me:$LINENO: checking for getmntent in -lsun" >&5
+echo $ECHO_N "checking for getmntent in -lsun... $ECHO_C" >&6
+if test "${ac_cv_lib_sun_getmntent+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsun  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getmntent ();
+int
+main ()
+{
+getmntent ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_sun_getmntent=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_sun_getmntent=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_sun_getmntent" >&5
+echo "${ECHO_T}$ac_cv_lib_sun_getmntent" >&6
+if test $ac_cv_lib_sun_getmntent = yes; then
+  LIBS="-lsun $LIBS"
+else
+  echo "$as_me:$LINENO: checking for getmntent in -lseq" >&5
+echo $ECHO_N "checking for getmntent in -lseq... $ECHO_C" >&6
+if test "${ac_cv_lib_seq_getmntent+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lseq  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getmntent ();
+int
+main ()
+{
+getmntent ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_seq_getmntent=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_seq_getmntent=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_seq_getmntent" >&5
+echo "${ECHO_T}$ac_cv_lib_seq_getmntent" >&6
+if test $ac_cv_lib_seq_getmntent = yes; then
+  LIBS="-lseq $LIBS"
+else
+  echo "$as_me:$LINENO: checking for getmntent in -lgen" >&5
+echo $ECHO_N "checking for getmntent in -lgen... $ECHO_C" >&6
+if test "${ac_cv_lib_gen_getmntent+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgen  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getmntent ();
+int
+main ()
+{
+getmntent ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_gen_getmntent=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_gen_getmntent=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_gen_getmntent" >&5
+echo "${ECHO_T}$ac_cv_lib_gen_getmntent" >&6
+if test $ac_cv_lib_gen_getmntent = yes; then
+  LIBS="-lgen $LIBS"
+fi
+
+fi
+
+fi
+
+
+for ac_func in getmntent
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+
+
+
+
+
+for ac_func in setmntent gethostname uname gettimeofday select socket strtol strtoul strlcpy
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+
+
+
+for ac_func in strchr strdup memcpy memmove index bcopy strcasestr regcomp
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+
+
+
+
+for ac_func in signal setsid sigset sigblock sighold strerror setenv vsnprintf snprintf
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in sigaction
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+for ac_func in snprintf strtoul
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+for ac_func in random lrand48 rand
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+
+for ac_func in execv system fork getpid strncasecmp sigalrm
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+if test "x$with_rpm" != "xno" && \
+        echo " $module_list " | grep " host/hr_swinst " > /dev/null; then
+  OLDLIBS=$LIBS
+  LIBS=$AGENTLIBS
+
+for ac_func in rpmGetPath
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+  LIBS=$OLDLIBS
+fi
+
+
+for ac_func in getloadavg
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+for ac_func in getaddrinfo getipnodebyname
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+# BSDi2 functions differ
+
+
+for ac_func in statvfs statfs
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in getdtablesize
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+# freebsd2 checks
+
+for ac_func in getfsstat
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in usleep
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in setlocale
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in tcgetattr
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+for ac_func in if_nameindex if_freenameindex
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+# solaris checks
+
+for ac_func in getpagesize
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in mkstemp
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+for ac_func in getpwnam getgrnam setgid setuid setgroups
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+# High resolution alarm support
+
+for ac_func in setitimer
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+echo "$as_me:$LINENO: checking for SIOCGIFADDR in sys/ioctl.h" >&5
+echo $ECHO_N "checking for SIOCGIFADDR in sys/ioctl.h... $ECHO_C" >&6
+if test "${cv_sys_ioctl_h_has_SIOCGIFADDR+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+   cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
+#ifdef SIOCGIFADDR
+xxxyesxxx
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "xxxyesxxx" >/dev/null 2>&1; then
+  cv_sys_ioctl_h_has_SIOCGIFADDR=yes
+else
+  cv_sys_ioctl_h_has_SIOCGIFADDR=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$as_me:$LINENO: result: $cv_sys_ioctl_h_has_SIOCGIFADDR" >&5
+echo "${ECHO_T}$cv_sys_ioctl_h_has_SIOCGIFADDR" >&6
+if test $cv_sys_ioctl_h_has_SIOCGIFADDR = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define SYS_IOCTL_H_HAS_SIOCGIFADDR 1
+_ACEOF
+
+fi
+
+# ultrix
+echo "$as_me:$LINENO: checking for two-argument statfs with struct fs_data (Ultrix)" >&5
+echo $ECHO_N "checking for two-argument statfs with struct fs_data (Ultrix)... $ECHO_C" >&6
+if test "${fu_cv_sys_stat_fs_data+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  fu_cv_sys_stat_fs_data=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+#ifdef HAVE_SYS_FS_TYPES_H
+#include <sys/fs_types.h>
+#endif
+main ()
+{
+struct fs_data fsd;
+/* Ultrix's statfs returns 1 for success,
+   0 for not mounted, -1 for failure.  */
+exit (statfs (".", &fsd) != 1);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  fu_cv_sys_stat_fs_data=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+fu_cv_sys_stat_fs_data=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+
+echo "$as_me:$LINENO: result: $fu_cv_sys_stat_fs_data" >&5
+echo "${ECHO_T}$fu_cv_sys_stat_fs_data" >&6
+if test $fu_cv_sys_stat_fs_data = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define STAT_STATFS_FS_DATA 1
+_ACEOF
+
+fi
+
+# check if compiler pre-processor defines __FUNCTION__
+echo "$as_me:$LINENO: checking if __FUNCTION__ is defined" >&5
+echo $ECHO_N "checking if __FUNCTION__ is defined... $ECHO_C" >&6
+if test "${ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+    char *cp = __FUNCTION__;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED" >&5
+echo "${ECHO_T}$ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED" >&6
+
+if test "x$ac_cv_HAVE_CPP_UNDERBAR_FUNCTION_DEFINED" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_CPP_UNDERBAR_FUNCTION_DEFINED 1
+_ACEOF
+
+fi
+
+
+
+ac_safe_struct=`echo "sigaction" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "sa_sigaction" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for sigaction.sa_sigaction" >&5
+echo $ECHO_N "checking for sigaction.sa_sigaction... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "xno" = "x"; then
+  defineit="= 0"
+elif test "xno" = "xno"; then
+  defineit=""
+else
+  defineit="no"
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <sys/signal.h>
+
+
+int
+main ()
+{
+
+struct sigaction testit;
+testit.sa_sigaction $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "sockaddr" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "sa_len" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for sockaddr.sa_len" >&5
+echo $ECHO_N "checking for sockaddr.sa_len... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "xno" = "x"; then
+  defineit="= 0"
+elif test "xno" = "xno"; then
+  defineit=""
+else
+  defineit="no"
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+
+
+int
+main ()
+{
+
+struct sockaddr testit;
+testit.sa_len $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "sockaddr" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "sa_union.sa_generic.sa_family2" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for sockaddr.sa_union.sa_generic.sa_family2" >&5
+echo $ECHO_N "checking for sockaddr.sa_union.sa_generic.sa_family2... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "xno" = "x"; then
+  defineit="= 0"
+elif test "xno" = "xno"; then
+  defineit=""
+else
+  defineit="no"
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+
+
+int
+main ()
+{
+
+struct sockaddr testit;
+testit.sa_union.sa_generic.sa_family2 $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "rtentry" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "rt_dst" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for rtentry.rt_dst" >&5
+echo $ECHO_N "checking for rtentry.rt_dst... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "xno" = "x"; then
+  defineit="= 0"
+elif test "xno" = "xno"; then
+  defineit=""
+else
+  defineit="no"
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+
+int
+main ()
+{
+
+struct rtentry testit;
+testit.rt_dst $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# checking for 4.3 vs 4.4 rtentry.
+echo "$as_me:$LINENO: checking type of rtentry structure" >&5
+echo $ECHO_N "checking type of rtentry structure... $ECHO_C" >&6
+if test "${ac_cv_RTENTRY_TYPE+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+
+# 4.4 compat
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+int
+main ()
+{
+
+
+#ifndef STRUCT_RTENTRY_HAS_RT_DST
+#define rt_dst rt_nodes->rn_key
+#endif
+
+  struct rtentry rt;
+  rt.rt_nodes[0].rn_flags = 1;
+  rt.rt_dst;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_RTENTRY_TYPE="BSD-4.4"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+# 4.3 compat
+if test "x$ac_cv_RTENTRY_TYPE" = "x"; then
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+int
+main ()
+{
+
+struct rtentry rt;
+rt.rt_hash;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_RTENTRY_TYPE="BSD-4.3"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+
+# else ack.
+if test "x$ac_cv_RTENTRY_TYPE" = "x"; then
+  echo "$as_me:$LINENO: result: Unknown" >&5
+echo "${ECHO_T}Unknown" >&6
+  ac_cv_RTENTRY_TYPE="unknown"
+fi
+
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_RTENTRY_TYPE" >&5
+echo "${ECHO_T}$ac_cv_RTENTRY_TYPE" >&6
+
+if test "x$ac_cv_RTENTRY_TYPE" = "xBSD-4.4"; then
+  cat >>confdefs.h <<\_ACEOF
+#define RTENTRY_4_4 1
+_ACEOF
+
+fi
+
+# checking for alpha's ortentry vs rtentry
+if test "x$ac_cv_RTENTRY_TYPE" = "xunknown"; then
+echo "$as_me:$LINENO: checking for struct rtentry" >&5
+echo $ECHO_N "checking for struct rtentry... $ECHO_C" >&6
+if test "${ac_cv_struct_rtentry+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#define KERNEL
+#include <net/route.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "ortentry" >/dev/null 2>&1; then
+  ac_cv_struct_rtentry=ortentry
+else
+  ac_cv_struct_rtentry=rtentry
+fi
+rm -f conftest*
+
+if test "x$ac_cv_struct_rtentry" = "xrtentry" ; then
+  ac_cv_struct_rtentry="rtentry"
+else
+  ac_cv_struct_rtentry="ortentry"
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_struct_rtentry" >&5
+echo "${ECHO_T}$ac_cv_struct_rtentry" >&6
+else
+  RTENTRY_TYPE="rtentry"
+  ac_cv_struct_rtentry="rtentry"
+fi
+
+if test "x$ac_cv_struct_rtentry" != "x"; then
+  cat >>confdefs.h <<_ACEOF
+#define RTENTRY struct ${ac_cv_struct_rtentry}
+_ACEOF
+
+else
+  cat >>confdefs.h <<\_ACEOF
+#define RTENTRY struct rtentry
+_ACEOF
+
+fi
+
+# check for 4.3's rtentry->rt_next
+if test "x$ac_cv_RTENTRY_TYPE" = "xBSD-4.3"; then
+echo "$as_me:$LINENO: checking for struct rtentry has a rt_next node" >&5
+echo $ECHO_N "checking for struct rtentry has a rt_next node... $ECHO_C" >&6
+if test "${ac_cv_struct_rtentry_rt_next+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+int
+main ()
+{
+
+struct rtentry rt;
+rt.rt_next;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_struct_rtentry_rt_next=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_struct_rtentry_rt_next=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_struct_rtentry_rt_next" >&5
+echo "${ECHO_T}$ac_cv_struct_rtentry_rt_next" >&6
+
+if test "x$ac_cv_struct_rtentry_rt_next" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define RTENTRY_RT_NEXT 1
+_ACEOF
+
+fi
+
+fi
+
+# Check struct rtentry for various things.
+
+
+ac_safe_struct=`echo "rtentry" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "rt_unit" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for rtentry.rt_unit" >&5
+echo $ECHO_N "checking for rtentry.rt_unit... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+
+int
+main ()
+{
+
+struct rtentry testit;
+testit.rt_unit $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "rtentry" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "rt_refcnt" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for rtentry.rt_refcnt" >&5
+echo $ECHO_N "checking for rtentry.rt_refcnt... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+
+int
+main ()
+{
+
+struct rtentry testit;
+testit.rt_refcnt $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "rtentry" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "rt_hash" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for rtentry.rt_hash" >&5
+echo $ECHO_N "checking for rtentry.rt_hash... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+
+int
+main ()
+{
+
+struct rtentry testit;
+testit.rt_hash $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "rtentry" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "rt_use" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for rtentry.rt_use" >&5
+echo $ECHO_N "checking for rtentry.rt_use... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#define KERNEL
+#define _KERNEL
+#include <sys/socket.h>
+#undef KERNEL
+#undef _KERNEL
+#include <net/route.h>
+
+
+int
+main ()
+{
+
+struct rtentry testit;
+testit.rt_use $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# Check tcpstat for tcpstat.tcp_rcvmemdrop
+
+
+ac_safe_struct=`echo "tcpstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "tcp_rcvmemdrop" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for tcpstat.tcp_rcvmemdrop" >&5
+echo $ECHO_N "checking for tcpstat.tcp_rcvmemdrop... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <netinet/tcp.h>
+#ifdef HAVE_NETINET_TCP_TIMER_H
+#include <netinet/tcp_timer.h>
+#endif
+
+#ifdef HAVE_NETINET_TCP_VAR_H
+#include <netinet/tcp_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct tcpstat testit;
+testit.tcp_rcvmemdrop $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# irix checks
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_mtu" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_mtu" >&5
+echo $ECHO_N "checking for ifnet.if_mtu... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_mtu $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+if test "x$ac_cv_struct_ifnet_has_if_mtu" = "xno"; then
+echo "$as_me:$LINENO: checking if _KERNEL needs to be defined for if_mtu" >&5
+echo $ECHO_N "checking if _KERNEL needs to be defined for if_mtu... $ECHO_C" >&6
+if test "${ac_cv_IFNET_NEEDS_KERNEL+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x$ac_cv_struct_ifnet_has_if_mtu" = "xyes"; then
+  ac_cv_IFNET_NEEDS_KERNEL=no
+else
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#define _KERNEL 1
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_mtu = 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_IFNET_NEEDS_KERNEL=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_IFNET_NEEDS_KERNEL=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_IFNET_NEEDS_KERNEL" >&5
+echo "${ECHO_T}$ac_cv_IFNET_NEEDS_KERNEL" >&6
+
+if test "x$ac_cv_IFNET_NEEDS_KERNEL" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define IFNET_NEEDS_KERNEL 1
+_ACEOF
+
+fi
+fi
+
+
+
+ac_safe_struct=`echo "ifaddr" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ifa_next" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifaddr.ifa_next" >&5
+echo $ECHO_N "checking for ifaddr.ifa_next... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ifaddr testit;
+testit.ifa_next $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# Check ifnet entries using macro defined in aclocal.m4.
+#
+# XXX  Broken on FreeBSD where these are #define'd in <net/if.h>
+#
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_baudrate" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_baudrate" >&5
+echo $ECHO_N "checking for ifnet.if_baudrate... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_baudrate $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_baudrate.ifs_value" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_baudrate.ifs_value" >&5
+echo $ECHO_N "checking for ifnet.if_baudrate.ifs_value... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_baudrate.ifs_value $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_speed" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_speed" >&5
+echo $ECHO_N "checking for ifnet.if_speed... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_speed $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_type" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_type" >&5
+echo $ECHO_N "checking for ifnet.if_type... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_type $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_imcasts" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_imcasts" >&5
+echo $ECHO_N "checking for ifnet.if_imcasts... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_imcasts $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_iqdrops" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_iqdrops" >&5
+echo $ECHO_N "checking for ifnet.if_iqdrops... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_iqdrops $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_noproto" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_noproto" >&5
+echo $ECHO_N "checking for ifnet.if_noproto... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_noproto $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_omcasts" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_omcasts" >&5
+echo $ECHO_N "checking for ifnet.if_omcasts... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_omcasts $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_xname" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_xname" >&5
+echo $ECHO_N "checking for ifnet.if_xname... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "xno" = "x"; then
+  defineit="= 0"
+elif test "xno" = "xno"; then
+  defineit=""
+else
+  defineit="no"
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_xname $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_lastchange.tv_sec" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_lastchange.tv_sec" >&5
+echo $ECHO_N "checking for ifnet.if_lastchange.tv_sec... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_lastchange.tv_sec $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_obytes" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_obytes" >&5
+echo $ECHO_N "checking for ifnet.if_obytes... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_obytes $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_ibytes" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_ibytes" >&5
+echo $ECHO_N "checking for ifnet.if_ibytes... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_ibytes $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_addrlist" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_addrlist" >&5
+echo $ECHO_N "checking for ifnet.if_addrlist... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_addrlist $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "ifnet" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "if_addrhead.tqh_first" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ifnet.if_addrhead.tqh_first" >&5
+echo $ECHO_N "checking for ifnet.if_addrhead.tqh_first... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef IFNET_NEEDS_KERNEL
+#define _KERNEL 1
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#ifdef HAVE_NET_IF_VAR_H
+#include <net/if_var.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef linux
+struct ifnet {
+	char	*if_name;		/* name, e.g. "en" or "lo" */
+	short	if_unit;		/* sub-unit for lower level driver */
+	short	if_mtu;			/* maximum transmission unit */
+	short	if_flags;		/* up/down, broadcast, etc. */
+	int	if_metric;		/* routing metric (external only) */
+	char    if_hwaddr [6];		/* ethernet address */
+	int	if_type;		/* interface type: 1=generic,
+					   28=slip, ether=6, loopback=24 */
+	int	if_speed;		/* interface speed: in bits/sec */
+
+	struct sockaddr if_addr;	/* interface's address */
+	struct sockaddr ifu_broadaddr;	/* broadcast address */
+	struct sockaddr ia_subnetmask; 	/* interface's mask */
+
+	struct	ifqueue {
+		int	ifq_len;
+		int	ifq_drops;
+	} if_snd;			/* output queue */
+	int	if_ibytes;		/* octets received on interface */
+	int	if_ipackets;		/* packets received on interface */
+	int	if_ierrors;		/* input errors on interface */
+        int     if_iqdrops;             /* input queue overruns */
+	int	if_obytes;		/* octets sent on interface */
+	int	if_opackets;		/* packets sent on interface */
+	int	if_oerrors;		/* output errors on interface */
+	int	if_collisions;		/* collisions on csma interfaces */
+/* end statistics */
+	struct	ifnet *if_next;
+};
+#endif
+
+
+int
+main ()
+{
+
+struct ifnet testit;
+testit.if_addrhead.tqh_first $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+
+ac_safe_struct=`echo "udpstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "udps_discard" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for udpstat.udps_discard" >&5
+echo $ECHO_N "checking for udpstat.udps_discard... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+#if HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
+#if HAVE_NETINET_UDP_VAR_H
+#include <netinet/udp_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct udpstat testit;
+testit.udps_discard $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "udpstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "udps_noport" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for udpstat.udps_noport" >&5
+echo $ECHO_N "checking for udpstat.udps_noport... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+#if HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
+#if HAVE_NETINET_UDP_VAR_H
+#include <netinet/udp_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct udpstat testit;
+testit.udps_noport $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "udpstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "udps_noportbcast" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for udpstat.udps_noportbcast" >&5
+echo $ECHO_N "checking for udpstat.udps_noportbcast... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+#if HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
+#if HAVE_NETINET_UDP_VAR_H
+#include <netinet/udp_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct udpstat testit;
+testit.udps_noportbcast $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "udpstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "udps_fullsock" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for udpstat.udps_fullsock" >&5
+echo $ECHO_N "checking for udpstat.udps_fullsock... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+#if HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
+#if HAVE_NETINET_UDP_VAR_H
+#include <netinet/udp_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct udpstat testit;
+testit.udps_fullsock $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "arphd" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "at_next" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for arphd.at_next" >&5
+echo $ECHO_N "checking for arphd.at_next... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <net/if.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IF_ETHER_H
+#include <netinet/if_ether.h>
+#endif
+
+
+int
+main ()
+{
+
+struct arphd testit;
+testit.at_next $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "swdevt" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "sw_nblksenabled" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for swdevt.sw_nblksenabled" >&5
+echo $ECHO_N "checking for swdevt.sw_nblksenabled... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#if HAVE_SYS_CONF_H
+#include <sys/conf.h>
+#endif
+
+
+int
+main ()
+{
+
+struct swdevt testit;
+testit.sw_nblksenabled $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "statvfs" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "f_frsize" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for statvfs.f_frsize" >&5
+echo $ECHO_N "checking for statvfs.f_frsize... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#if HAVE_SYS_STATVFS_H
+#include <sys/statvfs.h>
+#endif
+
+
+int
+main ()
+{
+
+struct statvfs testit;
+testit.f_frsize $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "statvfs" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "f_files" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for statvfs.f_files" >&5
+echo $ECHO_N "checking for statvfs.f_files... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#if HAVE_SYS_STATVFS_H
+#include <sys/statvfs.h>
+#endif
+
+
+int
+main ()
+{
+
+struct statvfs testit;
+testit.f_files $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "statfs" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "f_files" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for statfs.f_files" >&5
+echo $ECHO_N "checking for statfs.f_files... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+
+
+int
+main ()
+{
+
+struct statfs testit;
+testit.f_files $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "statfs" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "f_ffree" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for statfs.f_ffree" >&5
+echo $ECHO_N "checking for statfs.f_ffree... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+
+
+int
+main ()
+{
+
+struct statfs testit;
+testit.f_ffree $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "statfs" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "f_favail" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for statfs.f_favail" >&5
+echo $ECHO_N "checking for statfs.f_favail... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#if HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+
+
+int
+main ()
+{
+
+struct statfs testit;
+testit.f_favail $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "nlist" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "n_value" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for nlist.n_value" >&5
+echo $ECHO_N "checking for nlist.n_value... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#if HAVE_NLIST_H
+#include <nlist.h>
+#endif
+
+
+int
+main ()
+{
+
+struct nlist testit;
+testit.n_value $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# check struct ipstat for various things
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_cantforward" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_cantforward" >&5
+echo $ECHO_N "checking for ipstat.ips_cantforward... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_cantforward $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_cantfrag" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_cantfrag" >&5
+echo $ECHO_N "checking for ipstat.ips_cantfrag... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_cantfrag $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_delivered" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_delivered" >&5
+echo $ECHO_N "checking for ipstat.ips_delivered... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_delivered $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_fragdropped" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_fragdropped" >&5
+echo $ECHO_N "checking for ipstat.ips_fragdropped... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_fragdropped $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_fragtimeout" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_fragtimeout" >&5
+echo $ECHO_N "checking for ipstat.ips_fragtimeout... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_fragtimeout $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_localout" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_localout" >&5
+echo $ECHO_N "checking for ipstat.ips_localout... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_localout $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_noproto" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_noproto" >&5
+echo $ECHO_N "checking for ipstat.ips_noproto... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_noproto $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_noroute" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_noroute" >&5
+echo $ECHO_N "checking for ipstat.ips_noroute... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_noroute $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_odropped" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_odropped" >&5
+echo $ECHO_N "checking for ipstat.ips_odropped... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_odropped $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_ofragments" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_ofragments" >&5
+echo $ECHO_N "checking for ipstat.ips_ofragments... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_ofragments $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+
+
+ac_safe_struct=`echo "ipstat" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "ips_reassembled" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for ipstat.ips_reassembled" >&5
+echo $ECHO_N "checking for ipstat.ips_reassembled... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+
+
+int
+main ()
+{
+
+struct ipstat testit;
+testit.ips_reassembled $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+
+# check for the des_ks_struct.weak_key attribute, which indicates the
+# older opensll version is being used.
+if test "x$ac_cv_header_openssl_des_h" = "xyes" ; then
+
+
+ac_safe_struct=`echo "des_ks_struct" | sed 'y%./+-%__p_%'`
+ac_safe_member=`echo "weak_key" | sed 'y%./+-%__p_%'`
+ac_safe_all="ac_cv_struct_${ac_safe_struct}_has_${ac_safe_member}"
+  ac_uc_define=STRUCT_`echo "${ac_safe_struct}_HAS_${ac_safe_member}" | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+
+echo "$as_me:$LINENO: checking for des_ks_struct.weak_key" >&5
+echo $ECHO_N "checking for des_ks_struct.weak_key... $ECHO_C" >&6
+if eval "test \"\${$ac_safe_all+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x" = "x"; then
+  defineit="= 0"
+elif test "x" = "xno"; then
+  defineit=""
+else
+  defineit=""
+fi
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+#include <openssl/des.h>
+
+
+int
+main ()
+{
+
+struct des_ks_struct testit;
+testit.weak_key $defineit;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "${ac_safe_all}=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "${ac_safe_all}=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if eval "test \"x$`echo ${ac_safe_all}`\" = \"xyes\""; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  cat >>confdefs.h <<_ACEOF
+#define $ac_uc_define 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+fi
+
+# attempt to figure out if sysctl is usable
+
+if test $cross_compiling = yes; then
+  { echo "$as_me:$LINENO: WARNING: Can't check sysctl, manually define CAN_USE_SYSCTL if platform support available" >&5
+echo "$as_me: WARNING: Can't check sysctl, manually define CAN_USE_SYSCTL if platform support available" >&2;}
+else
+  echo "$as_me:$LINENO: checking if sysctl can read kernel information" >&5
+echo $ECHO_N "checking if sysctl can read kernel information... $ECHO_C" >&6
+if test "${ac_cv_CAN_USE_SYSCTL+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_CAN_USE_SYSCTL=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#if TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# if HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+#if HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+#include <sys/types.h>
+#if HAVE_SYS_SYSCTL_H
+# include <sys/sysctl.h>
+#endif
+
+main() {
+  int                 mib[2];
+  size_t              len;
+  struct timeval boottime;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_BOOTTIME;
+
+  len = sizeof(boottime);
+  sysctl(mib, 2, &boottime, &len, NULL, NULL);
+  if (boottime.tv_sec != 0)
+    exit(0);
+  else
+    exit(1);
+}
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_CAN_USE_SYSCTL=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_CAN_USE_SYSCTL=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_CAN_USE_SYSCTL" >&5
+echo "${ECHO_T}$ac_cv_CAN_USE_SYSCTL" >&6
+fi
+
+if test "x$ac_cv_CAN_USE_SYSCTL" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define CAN_USE_SYSCTL 1
+_ACEOF
+
+fi
+
+#
+# In FreeBSD 4.x, the TCP timer constants aren't.  They are defined
+# in terms of `hz', the kernel clock tick.  In this case,
+# we need to have a local variable `hz' in scope and set to a useful
+# value whenever we use one of these constants.
+#
+echo "$as_me:$LINENO: checking whether TCP timers depend on \`hz'" >&5
+echo $ECHO_N "checking whether TCP timers depend on \`hz'... $ECHO_C" >&6
+if test "${ac_cv_TCPTV_NEEDS_HZ+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <netinet/tcp_timer.h>
+TCPTV_SRTTDFLT
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "hz" >/dev/null 2>&1; then
+  ac_cv_TCPTV_NEEDS_HZ=yes
+else
+  ac_cv_TCPTV_NEEDS_HZ=no
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_TCPTV_NEEDS_HZ" >&5
+echo "${ECHO_T}$ac_cv_TCPTV_NEEDS_HZ" >&6
+
+if test "x$ac_cv_TCPTV_NEEDS_HZ" = "xyes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define TCPTV_NEEDS_HZ 1
+_ACEOF
+
+fi
+
+#
+# define the agent libraries variable
+#
+
+
+
+
+#
+# Prompt for various bits of user information
+#
+
+if test "x$ac_cv_user_prompt_LOGFILE" = "x" -o "x$ac_cv_user_prompt_SYS_LOC" = "x" -o "x$ac_cv_user_prompt_SYS_CONTACT" = "x" -o "x$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" = "x"; then
+echo "$as_me:$LINENO: checking if you have run configure before" >&5
+echo $ECHO_N "checking if you have run configure before... $ECHO_C" >&6
+if test "${ac_cv_have_warned+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "x$defaults" = "xno"; then
+cat << EOF
+
+	 ************** Configuration Section **************
+
+	You are about to be prompted with a series of questions.  Answer
+them carefully, as they determine how the SNMP agent and related
+applications are to function.
+
+	After the configure script finishes, you can browse the newly
+created config.h file for further - less important - parameters to
+modify.  Be careful if you re-run configure though, since config.h will
+be overwritten.
+
+-Press return to continue-
+EOF
+
+read tmpinput
+ac_cv_have_warned="yes"
+echo $ECHO_N "disabling above prompt for future runs...  $ECHO_C"
+else
+  ac_cv_have_warned="no"
+fi
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_have_warned" >&5
+echo "${ECHO_T}$ac_cv_have_warned" >&6
+else
+  ac_cv_have_warned="yes"
+fi
+
+ME=`$WHOAMI`
+if test -f /etc/resolv.conf; then
+  LOC=`cat /etc/resolv.conf | grep '^domain' | tail -1 | awk '{print $NF}'`
+else
+  LOC="@no.where"
+fi
+
+
+MSG_CHECK=`echo "
+
+*** Default SNMP Version:
+
+	Starting with Net-SNMP 5.0, you can choose the default version of
+the SNMP protocol to use when no version is given explicitly on the
+command line, or via an 'snmp.conf' file.  In the past this was set to
+SNMPv1, but you can use this to switch to SNMPv3 if desired.  SNMPv3
+will provide a more secure management environment (and thus you're
+encouraged to switch to SNMPv3), but may break existing scripts that
+rely on the old behaviour.  (Though such scripts will probably need to
+be changed to use the '-c' community flag anyway, as the SNMPv1
+command line usage has changed as well.).
+   At this prompt you can select \"1\", \"2\" (for SNMPv2c), or \"3\" as
+the default version for the command tools (snmpget, ...) to use.  This
+can always be overridden at runtime using the -v flag to the tools, or
+by using the \"defVersion\" token in your snmp.conf file.
+   Providing the --with-default-snmp-version=\"x\" parameter to ./configure
+will avoid this prompt.
+
+Default version of SNMP to use" | tail -1`
+echo "$as_me:$LINENO: checking $MSG_CHECK" >&5
+echo $ECHO_N "checking $MSG_CHECK... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_DEFAULT_SNMP_VERSION+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  echo "" >&6
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** Default SNMP Version:
+
+	Starting with Net-SNMP 5.0, you can choose the default version of
+the SNMP protocol to use when no version is given explicitly on the
+command line, or via an 'snmp.conf' file.  In the past this was set to
+SNMPv1, but you can use this to switch to SNMPv3 if desired.  SNMPv3
+will provide a more secure management environment (and thus you're
+encouraged to switch to SNMPv3), but may break existing scripts that
+rely on the old behaviour.  (Though such scripts will probably need to
+be changed to use the '-c' community flag anyway, as the SNMPv1
+command line usage has changed as well.).
+   At this prompt you can select \"1\", \"2\" (for SNMPv2c), or \"3\" as
+the default version for the command tools (snmpget, ...) to use.  This
+can always be overridden at runtime using the -v flag to the tools, or
+by using the \"defVersion\" token in your snmp.conf file.
+   Providing the --with-default-snmp-version=\"x\" parameter to ./configure
+will avoid this prompt.
+
+Default version of SNMP to use (3): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a "3" != ""; then
+  tmpinput="3"
+fi
+eval DEFAULT_SNMP_VERSION=\"$tmpinput\"
+else
+tmpinput="3"
+eval DEFAULT_SNMP_VERSION=\"$tmpinput\"
+fi
+
+
+eval ac_cv_user_prompt_DEFAULT_SNMP_VERSION=\$DEFAULT_SNMP_VERSION
+echo $ECHO_N "setting $MSG_CHECK to...  $ECHO_C" >&6
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_DEFAULT_SNMP_VERSION" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" >&6
+if test "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "none"; then
+  if test "xunquoted" = "xquoted" -o "xunquoted" = "xQUOTED"; then
+    cat >>confdefs.h <<_ACEOF
+#define DEFAULT_SNMP_VERSION "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION"
+_ACEOF
+
+  else
+    cat >>confdefs.h <<_ACEOF
+#define DEFAULT_SNMP_VERSION $ac_cv_user_prompt_DEFAULT_SNMP_VERSION
+_ACEOF
+
+  fi
+fi
+
+
+# we tested this above before the prompt, but the prompt may give a new value.
+if test "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "1" -a "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "2" -a "$ac_cv_user_prompt_DEFAULT_SNMP_VERSION" != "3"; then
+  { { echo "$as_me:$LINENO: error: Illegal version number.  Only 1, 2 (for SNMPv2c) and 3 are supported." >&5
+echo "$as_me: error: Illegal version number.  Only 1, 2 (for SNMPv2c) and 3 are supported." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+
+MSG_CHECK=`echo "
+
+*** System Contact Information:
+
+	Describes who should be contacted about the host the agent is
+running on.  This information is available in the MIB-II tree.  This
+can also be over-ridden using the \"syscontact\" syntax in the agent's
+configuration files.
+  Providing the --with-sys-contact=\"contact\" parameter to ./configure
+will avoid this prompt.
+
+System Contact Information" | tail -1`
+echo "$as_me:$LINENO: checking $MSG_CHECK" >&5
+echo $ECHO_N "checking $MSG_CHECK... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_SYS_CONTACT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  echo "" >&6
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** System Contact Information:
+
+	Describes who should be contacted about the host the agent is
+running on.  This information is available in the MIB-II tree.  This
+can also be over-ridden using the \"syscontact\" syntax in the agent's
+configuration files.
+  Providing the --with-sys-contact=\"contact\" parameter to ./configure
+will avoid this prompt.
+
+System Contact Information ($ME@$LOC): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a "$ME@$LOC" != ""; then
+  tmpinput="$ME@$LOC"
+fi
+eval SYS_CONTACT=\"$tmpinput\"
+else
+tmpinput="$ME@$LOC"
+eval SYS_CONTACT=\"$tmpinput\"
+fi
+
+
+eval ac_cv_user_prompt_SYS_CONTACT=\$SYS_CONTACT
+echo $ECHO_N "setting $MSG_CHECK to...  $ECHO_C" >&6
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_SYS_CONTACT" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_SYS_CONTACT" >&6
+if test "$ac_cv_user_prompt_SYS_CONTACT" != "none"; then
+  if test "xquoted" = "xquoted" -o "xquoted" = "xQUOTED"; then
+    cat >>confdefs.h <<_ACEOF
+#define SYS_CONTACT "$ac_cv_user_prompt_SYS_CONTACT"
+_ACEOF
+
+  else
+    cat >>confdefs.h <<_ACEOF
+#define SYS_CONTACT $ac_cv_user_prompt_SYS_CONTACT
+_ACEOF
+
+  fi
+fi
+
+
+
+MSG_CHECK=`echo "
+
+*** System Location:
+
+	Describes the location of the system.  This information is
+available in the MIB-II tree.  this can also be over-ridden using the
+\"syslocation\" syntax in the agent's configuration files.
+  Providing the --with-sys-location=\"location\" parameter to ./configure
+will avoid this prompt.
+
+System Location" | tail -1`
+echo "$as_me:$LINENO: checking $MSG_CHECK" >&5
+echo $ECHO_N "checking $MSG_CHECK... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_SYS_LOC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  echo "" >&6
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** System Location:
+
+	Describes the location of the system.  This information is
+available in the MIB-II tree.  this can also be over-ridden using the
+\"syslocation\" syntax in the agent's configuration files.
+  Providing the --with-sys-location=\"location\" parameter to ./configure
+will avoid this prompt.
+
+System Location (Unknown): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a "Unknown" != ""; then
+  tmpinput="Unknown"
+fi
+eval SYS_LOC=\"$tmpinput\"
+else
+tmpinput="Unknown"
+eval SYS_LOC=\"$tmpinput\"
+fi
+
+
+eval ac_cv_user_prompt_SYS_LOC=\$SYS_LOC
+echo $ECHO_N "setting $MSG_CHECK to...  $ECHO_C" >&6
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_SYS_LOC" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_SYS_LOC" >&6
+if test "$ac_cv_user_prompt_SYS_LOC" != "none"; then
+  if test "xquoted" = "xquoted" -o "xquoted" = "xQUOTED"; then
+    cat >>confdefs.h <<_ACEOF
+#define SYS_LOC "$ac_cv_user_prompt_SYS_LOC"
+_ACEOF
+
+  else
+    cat >>confdefs.h <<_ACEOF
+#define SYS_LOC $ac_cv_user_prompt_SYS_LOC
+_ACEOF
+
+  fi
+fi
+
+
+if test -d /var/log; then
+  defaultlog="/var/log/snmpd.log"
+else
+  defaultlog="/usr/adm/snmpd.log"
+fi
+
+
+MSG_CHECK=`echo "
+
+*** Logfile location:
+
+	Enter the default location for the snmpd agent to dump
+information & errors to.  If not defined (enter the keyword \"none\"
+at the prompt below) the agent will use stdout and stderr instead.
+(Note: This value can be over-ridden using command line options.)
+  Providing the --with-logfile=\"path\" parameter to ./configure
+will avoid this prompt.
+
+Location to write logfile" | tail -1`
+echo "$as_me:$LINENO: checking $MSG_CHECK" >&5
+echo $ECHO_N "checking $MSG_CHECK... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_LOGFILE+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  echo "" >&6
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** Logfile location:
+
+	Enter the default location for the snmpd agent to dump
+information & errors to.  If not defined (enter the keyword \"none\"
+at the prompt below) the agent will use stdout and stderr instead.
+(Note: This value can be over-ridden using command line options.)
+  Providing the --with-logfile=\"path\" parameter to ./configure
+will avoid this prompt.
+
+Location to write logfile ($defaultlog): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a "$defaultlog" != ""; then
+  tmpinput="$defaultlog"
+fi
+eval LOGFILE=\"$tmpinput\"
+else
+tmpinput="$defaultlog"
+eval LOGFILE=\"$tmpinput\"
+fi
+
+
+eval ac_cv_user_prompt_LOGFILE=\$LOGFILE
+echo $ECHO_N "setting $MSG_CHECK to...  $ECHO_C" >&6
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_LOGFILE" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_LOGFILE" >&6
+if test "$ac_cv_user_prompt_LOGFILE" != "none"; then
+  if test "xquoted" = "xquoted" -o "xquoted" = "xQUOTED"; then
+    cat >>confdefs.h <<_ACEOF
+#define LOGFILE "$ac_cv_user_prompt_LOGFILE"
+_ACEOF
+
+  else
+    cat >>confdefs.h <<_ACEOF
+#define LOGFILE $ac_cv_user_prompt_LOGFILE
+_ACEOF
+
+  fi
+fi
+
+
+if test -d /var; then
+  defaultstore="/var/net-snmp"
+  ucddefaultstore="/var/ucd-snmp"
+else
+  defaultstore="/etc/net-snmp"
+  ucddefaultstore="/etc/ucd-snmp"
+fi
+
+
+MSG_CHECK=`echo "
+
+*** snmpd persistent storage location:
+
+	Enter a directory for the SNMP library to store persistent
+data in the form of a configuration file.  This default location is
+different than the old default location (which was for ucd-snmp).  If
+you stay with the new path, I'll ask you in a second if you wish to
+copy your files over to the new location (once only).  If you pick
+some other path than the default, you'll have to copy them yourself.
+There is nothing wrong with picking the old path ($ucddefaultstore) if
+you'd rather.
+  Providing the --with-persistent-directory=\"path\" parameter to
+./configure will avoid this prompt.
+
+Location to write persistent information" | tail -1`
+echo "$as_me:$LINENO: checking $MSG_CHECK" >&5
+echo $ECHO_N "checking $MSG_CHECK... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_PERSISTENT_DIRECTORY+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  echo "" >&6
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** snmpd persistent storage location:
+
+	Enter a directory for the SNMP library to store persistent
+data in the form of a configuration file.  This default location is
+different than the old default location (which was for ucd-snmp).  If
+you stay with the new path, I'll ask you in a second if you wish to
+copy your files over to the new location (once only).  If you pick
+some other path than the default, you'll have to copy them yourself.
+There is nothing wrong with picking the old path ($ucddefaultstore) if
+you'd rather.
+  Providing the --with-persistent-directory=\"path\" parameter to
+./configure will avoid this prompt.
+
+Location to write persistent information ($defaultstore): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a "$defaultstore" != ""; then
+  tmpinput="$defaultstore"
+fi
+eval PERSISTENT_DIRECTORY=\"$tmpinput\"
+else
+tmpinput="$defaultstore"
+eval PERSISTENT_DIRECTORY=\"$tmpinput\"
+fi
+
+
+eval ac_cv_user_prompt_PERSISTENT_DIRECTORY=\$PERSISTENT_DIRECTORY
+echo $ECHO_N "setting $MSG_CHECK to...  $ECHO_C" >&6
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_PERSISTENT_DIRECTORY" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_PERSISTENT_DIRECTORY" >&6
+if test "$ac_cv_user_prompt_PERSISTENT_DIRECTORY" != "none"; then
+  if test "xquoted" = "xquoted" -o "xquoted" = "xQUOTED"; then
+    cat >>confdefs.h <<_ACEOF
+#define PERSISTENT_DIRECTORY "$ac_cv_user_prompt_PERSISTENT_DIRECTORY"
+_ACEOF
+
+  else
+    cat >>confdefs.h <<_ACEOF
+#define PERSISTENT_DIRECTORY $ac_cv_user_prompt_PERSISTENT_DIRECTORY
+_ACEOF
+
+  fi
+fi
+
+
+PERSISTENT_DIRECTORY=$ac_cv_user_prompt_PERSISTENT_DIRECTORY
+
+UCDPERSISTENT_DIRECTORY=$ucddefaultstore
+
+
+if test $PERSISTENT_DIRECTORY = "$defaultstore" -a -d "$ucddefaultstore" -a ! -d "$defaultstore" ; then
+echo "$as_me:$LINENO: checking If we should copy the old persistent directory" >&5
+echo $ECHO_N "checking If we should copy the old persistent directory... $ECHO_C" >&6
+if test "${ac_cv_user_prompt_COPY_PERSISTENT_FILES+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+
+if test "x$defaults" = "xno"; then
+echo $ECHO_N "
+
+*** Copying old ucd-snmp persistent files to net-snmp persistent directory:
+
+	Would you like to copy the older ucd-snmp persistent files
+into your new net-snmp persistent file path?  This will functionally
+save all your ucd-snmp data and let it be used within the net-snmp
+tools.  This will only be done once when you run make install.  If you
+wish to do this, enter "yes" at the prompt.
+  Providing the --with-copy-persistent-files=\"no\" (or \"yes\")
+parameters to ./configure will avoid this prompt.
+
+Copy ucd-snmp data into the net-snmp data directory ("yes"): $ECHO_C"
+read tmpinput
+if test "$tmpinput" = "" -a ""yes"" != ""; then
+  tmpinput=""yes""
+fi
+eval ac_cv_user_prompt_COPY_PERSISTENT_FILES=\"$tmpinput\"
+else
+tmpinput=""yes""
+eval ac_cv_user_prompt_COPY_PERSISTENT_FILES=\"$tmpinput\"
+fi
+
+
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_user_prompt_COPY_PERSISTENT_FILES" >&5
+echo "${ECHO_T}$ac_cv_user_prompt_COPY_PERSISTENT_FILES" >&6
+else
+ac_cv_user_prompt_COPY_PERSISTENT_FILES="no"
+fi
+COPY_PERSISTENT_FILES="$ac_cv_user_prompt_COPY_PERSISTENT_FILES"
+
+
+
+
+          ac_config_files="$ac_config_files Makefile:Makefile.top:Makefile.in:Makefile.rules"
+
+          ac_config_files="$ac_config_files snmplib/Makefile:Makefile.top:snmplib/Makefile.in:Makefile.rules:snmplib/Makefile.depend"
+
+          ac_config_files="$ac_config_files apps/Makefile:Makefile.top:apps/Makefile.in:Makefile.rules:apps/Makefile.depend"
+
+          ac_config_files="$ac_config_files apps/snmpnetstat/Makefile:Makefile.top:apps/snmpnetstat/Makefile.in:Makefile.rules:apps/snmpnetstat/Makefile.depend"
+
+          ac_config_files="$ac_config_files agent/Makefile:Makefile.top:agent/Makefile.in:Makefile.rules:agent/Makefile.depend"
+
+          ac_config_files="$ac_config_files agent/helpers/Makefile:Makefile.top:agent/helpers/Makefile.in:Makefile.rules:agent/helpers/Makefile.depend"
+
+          ac_config_files="$ac_config_files agent/mibgroup/Makefile:Makefile.top:agent/mibgroup/Makefile.in:Makefile.rules:agent/mibgroup/Makefile.depend"
+
+          ac_config_files="$ac_config_files local/Makefile:Makefile.top:local/Makefile.in:Makefile.rules"
+
+          ac_config_files="$ac_config_files testing/Makefile:Makefile.top:testing/Makefile.in"
+
+          ac_config_files="$ac_config_files man/Makefile:Makefile.top:man/Makefile.in:Makefile.rules"
+
+          ac_config_files="$ac_config_files mibs/Makefile:Makefile.top:mibs/Makefile.in:Makefile.rules"
+
+          ac_config_files="$ac_config_files net-snmp-config:net-snmp-config.in"
+
+
+          ac_config_commands="$ac_config_commands default"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2>&1 |
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+        "s/'/'\\\\''/g;
+    	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+        "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
+    cat confcache >$cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[ 	]*VPATH[ 	]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[ 	]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[ 	]*$//;
+}'
+fi
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+         sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+
+# Support unset when possible.
+if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by Net-SNMP $as_me 5.1-pre1a, which was
+generated by GNU Autoconf 2.57.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+  --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration commands:
+$config_commands
+
+Report bugs to <bug-autoconf@gnu.org>."
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+Net-SNMP config.status 5.1-pre1a
+configured by $0, generated by GNU Autoconf 2.57,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
+Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=$srcdir
+INSTALL="$INSTALL"
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile:Makefile.top:Makefile.in:Makefile.rules" ;;
+  "snmplib/Makefile" ) CONFIG_FILES="$CONFIG_FILES snmplib/Makefile:Makefile.top:snmplib/Makefile.in:Makefile.rules:snmplib/Makefile.depend" ;;
+  "apps/Makefile" ) CONFIG_FILES="$CONFIG_FILES apps/Makefile:Makefile.top:apps/Makefile.in:Makefile.rules:apps/Makefile.depend" ;;
+  "apps/snmpnetstat/Makefile" ) CONFIG_FILES="$CONFIG_FILES apps/snmpnetstat/Makefile:Makefile.top:apps/snmpnetstat/Makefile.in:Makefile.rules:apps/snmpnetstat/Makefile.depend" ;;
+  "agent/Makefile" ) CONFIG_FILES="$CONFIG_FILES agent/Makefile:Makefile.top:agent/Makefile.in:Makefile.rules:agent/Makefile.depend" ;;
+  "agent/helpers/Makefile" ) CONFIG_FILES="$CONFIG_FILES agent/helpers/Makefile:Makefile.top:agent/helpers/Makefile.in:Makefile.rules:agent/helpers/Makefile.depend" ;;
+  "agent/mibgroup/Makefile" ) CONFIG_FILES="$CONFIG_FILES agent/mibgroup/Makefile:Makefile.top:agent/mibgroup/Makefile.in:Makefile.rules:agent/mibgroup/Makefile.depend" ;;
+  "local/Makefile" ) CONFIG_FILES="$CONFIG_FILES local/Makefile:Makefile.top:local/Makefile.in:Makefile.rules" ;;
+  "testing/Makefile" ) CONFIG_FILES="$CONFIG_FILES testing/Makefile:Makefile.top:testing/Makefile.in" ;;
+  "man/Makefile" ) CONFIG_FILES="$CONFIG_FILES man/Makefile:Makefile.top:man/Makefile.in:Makefile.rules" ;;
+  "mibs/Makefile" ) CONFIG_FILES="$CONFIG_FILES mibs/Makefile:Makefile.top:mibs/Makefile.in:Makefile.rules" ;;
+  "net-snmp-config" ) CONFIG_FILES="$CONFIG_FILES net-snmp-config:net-snmp-config.in" ;;
+  "default" ) CONFIG_COMMANDS="$CONFIG_COMMANDS default" ;;
+  "include/net-snmp/net-snmp-config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS include/net-snmp/net-snmp-config.h" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@CONFIGURE_OPTIONS@,$CONFIGURE_OPTIONS,;t t
+s,@LIBTOOLFLAGS@,$LIBTOOLFLAGS,;t t
+s,@INSTALL_PREFIX@,$INSTALL_PREFIX,;t t
+s,@MAINSUBS@,$MAINSUBS,;t t
+s,@HAVE_DMALLOC_H@,$HAVE_DMALLOC_H,;t t
+s,@WRAPLIBS@,$WRAPLIBS,;t t
+s,@installucdheaders@,$installucdheaders,;t t
+s,@installucdlibs@,$installucdlibs,;t t
+s,@CC@,$CC,;t t
+s,@CFLAGS@,$CFLAGS,;t t
+s,@LDFLAGS@,$LDFLAGS,;t t
+s,@CPPFLAGS@,$CPPFLAGS,;t t
+s,@ac_ct_CC@,$ac_ct_CC,;t t
+s,@EXEEXT@,$EXEEXT,;t t
+s,@OBJEXT@,$OBJEXT,;t t
+s,@CPP@,$CPP,;t t
+s,@EGREP@,$EGREP,;t t
+s,@build@,$build,;t t
+s,@build_cpu@,$build_cpu,;t t
+s,@build_vendor@,$build_vendor,;t t
+s,@build_os@,$build_os,;t t
+s,@host@,$host,;t t
+s,@host_cpu@,$host_cpu,;t t
+s,@host_vendor@,$host_vendor,;t t
+s,@host_os@,$host_os,;t t
+s,@LN_S@,$LN_S,;t t
+s,@ECHO@,$ECHO,;t t
+s,@RANLIB@,$RANLIB,;t t
+s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
+s,@STRIP@,$STRIP,;t t
+s,@ac_ct_STRIP@,$ac_ct_STRIP,;t t
+s,@LIBTOOL@,$LIBTOOL,;t t
+s,@LIBTOOL_DEPS@,$LIBTOOL_DEPS,;t t
+s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
+s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
+s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+s,@SET_MAKE@,$SET_MAKE,;t t
+s,@PSPROG@,$PSPROG,;t t
+s,@PERLPROG@,$PERLPROG,;t t
+s,@WHOAMI@,$WHOAMI,;t t
+s,@SED@,$SED,;t t
+s,@AUTOCONF@,$AUTOCONF,;t t
+s,@AUTOHEADER@,$AUTOHEADER,;t t
+s,@UNAMEPROG@,$UNAMEPROG,;t t
+s,@VERSION@,$VERSION,;t t
+s,@RELEASEVERSION@,$RELEASEVERSION,;t t
+s,@DEVFLAGS@,$DEVFLAGS,;t t
+s,@target@,$target,;t t
+s,@target_cpu@,$target_cpu,;t t
+s,@target_vendor@,$target_vendor,;t t
+s,@target_os@,$target_os,;t t
+s,@CCPATH@,$CCPATH,;t t
+s,@EXTRACPPFLAGS@,$EXTRACPPFLAGS,;t t
+s,@SNMPCONFPATH@,$SNMPCONFPATH,;t t
+s,@transport_hdr_list@,$transport_hdr_list,;t t
+s,@transport_src_list@,$transport_src_list,;t t
+s,@security_src_list@,$security_src_list,;t t
+s,@security_hdr_list@,$security_hdr_list,;t t
+s,@MODULE_LIST@,$MODULE_LIST,;t t
+s,@module_list_c@,$module_list_c,;t t
+s,@module_list_h@,$module_list_h,;t t
+s,@module_list_o@,$module_list_o,;t t
+s,@module_list_lo@,$module_list_lo,;t t
+s,@mibgroup_list_o@,$mibgroup_list_o,;t t
+s,@mibgroup_list_lo@,$mibgroup_list_lo,;t t
+s,@module_list@,$module_list,;t t
+s,@default_mibs_install@,$default_mibs_install,;t t
+s,@PERLTARGS@,$PERLTARGS,;t t
+s,@PERLINSTALLTARGS@,$PERLINSTALLTARGS,;t t
+s,@PERLUNINSTALLTARGS@,$PERLUNINSTALLTARGS,;t t
+s,@PERLARGS@,$PERLARGS,;t t
+s,@EMBEDPERLINSTALL@,$EMBEDPERLINSTALL,;t t
+s,@EMBEDPERLUNINSTALL@,$EMBEDPERLUNINSTALL,;t t
+s,@LPSTAT_PATH@,$LPSTAT_PATH,;t t
+s,@PSCMD@,$PSCMD,;t t
+s,@ALLOCA@,$ALLOCA,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@AGENTLIBS@,$AGENTLIBS,;t t
+s,@OTHERAGENTLIBOBJS@,$OTHERAGENTLIBOBJS,;t t
+s,@OTHERAGENTLIBLOBJS@,$OTHERAGENTLIBLOBJS,;t t
+s,@PERSISTENT_DIRECTORY@,$PERSISTENT_DIRECTORY,;t t
+s,@UCDPERSISTENT_DIRECTORY@,$UCDPERSISTENT_DIRECTORY,;t t
+s,@COPY_PERSISTENT_FILES@,$COPY_PERSISTENT_FILES,;t t
+s,@DLLIBS@,$DLLIBS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+  	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+  	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+        cat >$tmp/stdin
+        ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$ac_file" : 'X\(//\)[^/]' \| \
+         X"$ac_file" : 'X\(//\)$' \| \
+         X"$ac_file" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$as_dir" : 'X\(//\)[^/]' \| \
+         X"$as_dir" : 'X\(//\)$' \| \
+         X"$as_dir" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
+# absolute.
+ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
+ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
+ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
+ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+                                     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+         # Absolute (can't be DOS-style, as IFS=:)
+         test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         echo $f;;
+      *) # Relative
+         if test -f "$f"; then
+           # Build tree
+           echo $f
+         elif test -f "$srcdir/$f"; then
+           # Source tree
+           echo $srcdir/$f
+         else
+           # /dev/null tree
+           { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+  # Run the commands associated with the file.
+  case $ac_file in
+    net-snmp-config ) chmod +x net-snmp-config ;;
+  esac
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_HEADER section.
+#
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s,^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
+ac_dB='[ 	].*$,\1#\2'
+ac_dC=' '
+ac_dD=',;t'
+# ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_uA='s,^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_uB='$,\1#\2define\3'
+ac_uC=' '
+ac_uD=',;t'
+
+for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+        cat >$tmp/stdin
+        ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+        ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  test x"$ac_file" != x- && { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+         # Absolute (can't be DOS-style, as IFS=:)
+         test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         echo $f;;
+      *) # Relative
+         if test -f "$f"; then
+           # Build tree
+           echo $f
+         elif test -f "$srcdir/$f"; then
+           # Source tree
+           echo $srcdir/$f
+         else
+           # /dev/null tree
+           { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+         fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  # Remove the trailing spaces.
+  sed 's/[ 	]*$//' $ac_file_inputs >$tmp/in
+
+_ACEOF
+
+# Transform confdefs.h into two sed scripts, `conftest.defines' and
+# `conftest.undefs', that substitutes the proper values into
+# config.h.in to produce config.h.  The first handles `#define'
+# templates, and the second `#undef' templates.
+# And first: Protect against being on the right side of a sed subst in
+# config.status.  Protect against being in an unquoted here document
+# in config.status.
+rm -f conftest.defines conftest.undefs
+# Using a here document instead of a string reduces the quoting nightmare.
+# Putting comments in sed scripts is not portable.
+#
+# `end' is used to avoid that the second main sed command (meant for
+# 0-ary CPP macros) applies to n-ary macro definitions.
+# See the Autoconf documentation for `clear'.
+cat >confdef2sed.sed <<\_ACEOF
+s/[\\&,]/\\&/g
+s,[\\$`],\\&,g
+t clear
+: clear
+s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	(][^ 	(]*\)\(([^)]*)\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
+t end
+s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	][^ 	]*\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
+: end
+_ACEOF
+# If some macros were called several times there might be several times
+# the same #defines, which is useless.  Nevertheless, we may not want to
+# sort them, since we want the *last* AC-DEFINE to be honored.
+uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines
+sed 's/ac_d/ac_u/g' conftest.defines >conftest.undefs
+rm -f confdef2sed.sed
+
+# This sed command replaces #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+cat >>conftest.undefs <<\_ACEOF
+s,^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
+_ACEOF
+
+# Break up conftest.defines because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
+echo '  if grep "^[ 	]*#[ 	]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
+echo '  :' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.defines >/dev/null
+do
+  # Write a limited-size here document to $tmp/defines.sed.
+  echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#define' lines.
+  echo '/^[ 	]*#[ 	]*define/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/defines.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail
+  rm -f conftest.defines
+  mv conftest.tail conftest.defines
+done
+rm -f conftest.defines
+echo '  fi # grep' >>$CONFIG_STATUS
+echo >>$CONFIG_STATUS
+
+# Break up conftest.undefs because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #undef templates' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.undefs >/dev/null
+do
+  # Write a limited-size here document to $tmp/undefs.sed.
+  echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#undef'
+  echo '/^[ 	]*#[ 	]*undef/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/undefs.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.undefs >conftest.tail
+  rm -f conftest.undefs
+  mv conftest.tail conftest.undefs
+done
+rm -f conftest.undefs
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    echo "/* Generated by configure.  */" >$tmp/config.h
+  else
+    echo "/* $ac_file.  Generated by configure.  */" >$tmp/config.h
+  fi
+  cat $tmp/in >>$tmp/config.h
+  rm -f $tmp/in
+  if test x"$ac_file" != x-; then
+    if diff $ac_file $tmp/config.h >/dev/null 2>&1; then
+      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$ac_file" : 'X\(//\)[^/]' \| \
+         X"$ac_file" : 'X\(//\)$' \| \
+         X"$ac_file" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+      { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$as_dir" : 'X\(//\)[^/]' \| \
+         X"$as_dir" : 'X\(//\)$' \| \
+         X"$as_dir" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+      rm -f $ac_file
+      mv $tmp/config.h $ac_file
+    fi
+  else
+    cat $tmp/config.h
+    rm -f $tmp/config.h
+  fi
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_COMMANDS section.
+#
+for ac_file in : $CONFIG_COMMANDS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+  ac_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$ac_dest" : 'X\(//\)[^/]' \| \
+         X"$ac_dest" : 'X\(//\)$' \| \
+         X"$ac_dest" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
+# absolute.
+ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
+ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
+ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
+ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+
+  { echo "$as_me:$LINENO: executing $ac_dest commands" >&5
+echo "$as_me: executing $ac_dest commands" >&6;}
+  case $ac_dest in
+    default ) echo timestamp > stamp-h ;;
+  esac
+done
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
+
+  LIBS="$LIBS"
+
+  echo ""
+  echo "---------------------------------------------------------"
+  echo "            Net-SNMP configuration summary:"
+  echo "---------------------------------------------------------"
+  echo ""
+  cat configure-summary
+  echo ""
+  echo "---------------------------------------------------------"
+  echo ""
+
+# Local Variables:
+# mode: Autoconf
+# comment-start: "#"
+# End:
diff -Naur net-snmp-5.1/configure_snmpv1_pkg open_snmp/configure_snmpv1_pkg
--- net-snmp-5.1/configure_snmpv1_pkg	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/configure_snmpv1_pkg	2009-12-16 13:00:13.000000000 +0530
@@ -0,0 +1 @@
+./configure '--host=mips-hardhat-linux' CC=mips-linux-gcc 'CFLAGS=-Os -mips2 -mtune=r4600 -DAmazon' '--with-endianness=big' 'CPP=mips-linux-cpp' 'host_alias=mips-hardhat-linux' --disable-debugging --disable-mib-loading --with-mib-modules="mibII ${IFX_CONFIG_MIB_MODULES}" --with-out-mib-modules="snmpv3mibs agentx utilities agent_mibs ucd_snmp notification target" --with-default-snmp-version=1 --with-transports="UDP ${IFX_CONFIG_SNMP_TRANSPORTS}" --with-out-transports="Callback UDPIPv6 TCPIPv6 TCP Unix IPX" --disable-manuals --disable-scripts --disable-applications --disable-mibs --disable-privacy --prefix=  --with-install-prefix=${BUILD_ROOTFS_DIR}usr --with-sys-contact="root@infineon" --with-logfile="/var/log/snmpd.log" --with-persistent-directory="/var/net-snmp" --with-sys-location="/" 
diff -Naur net-snmp-5.1/configure_snmpv3_pkg open_snmp/configure_snmpv3_pkg
--- net-snmp-5.1/configure_snmpv3_pkg	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/configure_snmpv3_pkg	2009-12-16 13:00:13.000000000 +0530
@@ -0,0 +1,2 @@
+./configure '--host=mips-hardhat-linux' CC=mips-linux-gcc 'CFLAGS=-Os -mips2 -mtune=r4600 -DAmazon' '--with-endianness=big' 'CPP=mips-linux-cpp' 'host_alias=mips-hardhat-linux' --disable-debugging --disable-mib-loading --with-mib-modules="mibII snmpv3mibs ${IFX_CONFIG_MIB_MODULES}" --with-out-mib-modules="agentx utilities agent_mibs ucd_snmp notification target" --with-default-snmp-version=3 --with-transports="UDP ${IFX_CONFIG_SNMP_TRANSPORTS}" --with-out-transports="Callback UDPIPv6 TCPIPv6 TCP Unix IPX" --disable-manuals --disable-scripts --disable-applications --disable-mibs --prefix=  --with-install-prefix=${BUILD_ROOTFS_DIR}usr --with-openssl="../openssl-0.9.8a" --with-sys-contact="root@infineon" --with-logfile="/var/log/snmpd.log" --with-persistent-directory="/var/net-snmp" --with-sys-location="/"
+
diff -Naur net-snmp-5.1/create_customer_package.sh open_snmp/create_customer_package.sh
--- net-snmp-5.1/create_customer_package.sh	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/create_customer_package.sh	2009-12-16 13:00:13.000000000 +0530
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+if [ ! -n "$1" ] ; then
+	echo "Usage : create_customer_package.sh SOURCE_PATH"
+	exit 0
+fi
+
+rm -rf *
+cp $1/build.sh build.sh
+cp $1/agent/.libs/snmpd snmpd
+cp $1/agent/.libs/libnetsnmpagent.so.5.1.0 libnetsnmpagent.so.5.1.0
+cp $1/agent/.libs/libnetsnmpmibs.so.5.1.0 libnetsnmpmibs.so.5.1.0
+cp $1/agent/helpers/.libs/libnetsnmphelpers.so.5.1.0 libnetsnmphelpers.so.5.1.0
+cp $1/snmplib/.libs/libnetsnmp.so.5.1.0 libnetsnmp.so.5.1.0
+
+sed -i -e 's/^CONFIG_FULL_PACKAGE/#CONFIG_FULL_PACKAGE/g' build.sh 
diff -Naur net-snmp-5.1/dotgdbinit open_snmp/dotgdbinit
--- net-snmp-5.1/dotgdbinit	2002-04-20 12:59:58.000000000 +0530
+++ open_snmp/dotgdbinit	1970-01-01 05:30:00.000000000 +0530
@@ -1,129 +0,0 @@
-#
-# this file defines some utilities for printing various structures
-# found in the net-snmp source code.  You can source it from within
-# gdb and then use it to print variable chains, oids, etc directly
-# from memory.
-# 
-# as an example, consider the variables:
-#
-#   oid    *name;
-#   size_t name_len;
-#
-# normally display oids is difficult under gdb, and the best you can
-# do is to use x/12dw name or so to print the first 12 numbers of the
-# oid array.  however, with this file you can now use:
-#
-#   gdb> printoid name_len name
-#   .1.3.6.1.2.1.1.0
-#
-# which will print oids in a more readable fashion.  etc...
-#
-
-define initme
-  set $varindent = ""
-end
-
-define hookpost-run
-  initme
-end
-
-define printvarval
-  printf "value: "
-  if $arg0->type == 2
-    printf "int: %d\n", $arg0->val.integer
-  end
-  if $arg0->type == 4
-    printf "string: %s\n", $arg0->val.string
-  end
-  if $arg0->type == 5
-    printf "ASN NULL\n"
-  end
-  if $arg0->type == 6
-    printoid (($arg0->val_len)/sizeof(oid)) $arg0->val.objid
-  end
-  if $arg0->type == 128
-    printf "NO SUCH NAME\n"
-  end
-  if $arg0->type == 129
-    printf "NO SUCH INSTANCE\n"
-  end
-  if $arg0->type == 130
-    printf "END OF MIB VIEW\n"
-  end
-  if $arg0->type == 194
-    printf "AGENTX INCL RANGE: "
-    printoid (($arg0->val_len)/sizeof(oid)) $arg0->val.objid
-  end
-  if $arg0->type == 195
-    printf "AGENTX EXCL RANGE: "
-    printoid (($arg0->val_len)/sizeof(oid)) $arg0->val.objid
-  end
-end
-document printvarval
-  printvarval VARPTR
-  prints the value part of a net-snmp "struct variable".
-  This is called from inside printvar.
-end
-
-  
-
-define printvar
-  printf "%stype: %d\n", $varindent, $arg0->type
-  printf "%soid: ", $varindent
-  printoid $arg0->name_length $arg0->name
-  printf "%s", $varindent
-  printvarval $arg0
-end
-document printvar
-  printvar VARPTR
-  prints the variable information contained in a net-snmp struct
-  variable.  printvarval POINTER will print it's oid, value type and
-  value contents
-end
-
-define printvars
-  set $tmpcount = 1
-  set $tmpvar = $arg0
-  set $varindent = "  "
-  while $tmpvar != 0
-    printf "VARIABLE #%d\n", $tmpcount
-    printvar $tmpvar
-    set $tmpvar = $tmpvar->next_variable
-    set $tmpcount = $tmpcount + 1
-  end
-  set $varindent = ""
-end
-document printvars
-  printvars VARPTR
-  calls printvar repeatedly on a chain of variables, displaying all
-  the variables in a net-snmp struct variable chain.
-end
-
-define printoid
-  set $printoid_tmp = 0
-  while $printoid_tmp < $arg0
-    printf ".%d", $arg1[$printoid_tmp]
-    set $printoid_tmp = $printoid_tmp + 1
-  end
-  printf "\n"
-end
-document printoid
-  printoid LENGTH OIDPTR
-  prints an oid (.x.y.z...) given it's length and a pointer.
-end
-
-define poid
-  printoid $arg0_len $arg0
-end
-document poid
-  poid NAME
-  shorthand for 'printoid NAME_len NAME"
-end
-
-define poidl
-  printoid $arg0_length $arg0
-end
-document poidl
-  poid NAME
-  shorthand for 'printoid NAME_length NAME"
-end
diff -Naur net-snmp-5.1/include/net-snmp/library/snmpEOCDomain.h open_snmp/include/net-snmp/library/snmpEOCDomain.h
--- net-snmp-5.1/include/net-snmp/library/snmpEOCDomain.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/include/net-snmp/library/snmpEOCDomain.h	2009-12-16 13:00:24.000000000 +0530
@@ -0,0 +1,33 @@
+#ifndef _SNMPAAL5PVCDOMAIN_H
+#define _SNMPAAL5PVCDOMAIN_H
+
+#ifdef SNMP_TRANSPORT_AAL5PVC_DOMAIN
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+
+#include <net-snmp/library/snmp_transport.h>
+#include <net-snmp/library/asn1.h>
+
+extern oid  netsnmp_EOCDomain[]; /* = { ENTERPRISE_MIB, 3, 3, 3 }; */
+
+netsnmp_transport *netsnmp_eoc_transport(struct sockaddr_atmpvc *addr,
+                                             int local);
+
+/*
+ * "Constructor" for transport domain object.  
+ */
+
+void            netsnmp_eoc_ctor(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /*SNMP_TRANSPORT_AAL5PVC_DOMAIN */
+
+#endif/*_SNMPAAL5PVCDOMAIN_H*/
diff -Naur net-snmp-5.1/include/net-snmp/library/snmp_impl.h open_snmp/include/net-snmp/library/snmp_impl.h
--- net-snmp-5.1/include/net-snmp/library/snmp_impl.h	2002-04-20 13:00:12.000000000 +0530
+++ open_snmp/include/net-snmp/library/snmp_impl.h	2009-12-16 13:00:25.000000000 +0530
@@ -38,13 +38,19 @@
 #include<stdio.h>
 #include<net-snmp/types.h>      /* for 'u_char', etc */
 
-#define COMMUNITY_MAX_LEN	256
+#if defined(HAVE_OPTIMIZED_CODE)
+#define COMMUNITY_MAX_LEN	 64
+#define SPRINT_MAX_LEN		128	
 
+#else
+#define COMMUNITY_MAX_LEN	256
     /*
      * Space for character representation of an object identifier 
      */
 #define SPRINT_MAX_LEN		2560
 
+#endif
+
 
 #ifndef NULL
 #define NULL 0
diff -Naur net-snmp-5.1/include/net-snmp/memory_trace.h open_snmp/include/net-snmp/memory_trace.h
--- net-snmp-5.1/include/net-snmp/memory_trace.h	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/include/net-snmp/memory_trace.h	2009-12-16 13:00:27.000000000 +0530
@@ -0,0 +1,29 @@
+#ifndef __MEMORY_TRACE
+#define __MEMORY_TRACE
+
+#include <stdlib.h>
+
+#define calloc(n,s) ({ void *_ptr;                      \
+                   _ptr = calloc(n,s);                          \
+               printf(" calloc ptr/size <0x%x: %d bytes> from <%s: line %d> !\n",_ptr,s*n,__FILE__,__LINE__); \
+                   _ptr; })
+
+
+#define malloc(s) calloc(1,s)
+
+
+
+#define realloc(old_ptr,s) ({ void *new_ptr;         \
+          printf("realloc::free ptr <0x%x:> from <%s: line %d> !\n",old_ptr,__FILE__,__LINE__); \
+                        new_ptr = realloc(old_ptr,s); \
+          printf("realloc::calloc ptr/size <0x%x: %d bytes> from <%s: line %d> !\n",new_ptr,s,__FILE__,__LINE__); \
+                   new_ptr; })
+
+
+
+#define free(_ptr) ({                           \
+          printf(" free ptr <0x%x:> from <%s: line %d> !\n",_ptr,__FILE__,__LINE__); \
+                  free(_ptr);   })
+
+
+#endif
diff -Naur net-snmp-5.1/include/net-snmp/session_api.h open_snmp/include/net-snmp/session_api.h
--- net-snmp-5.1/include/net-snmp/session_api.h	2002-04-20 13:00:11.000000000 +0530
+++ open_snmp/include/net-snmp/session_api.h	2009-12-16 13:00:28.000000000 +0530
@@ -45,6 +45,9 @@
 #endif
 #ifdef SNMP_TRANSPORT_AAL5PVC_DOMAIN
 #include <net-snmp/library/snmpAAL5PVCDomain.h>
+#ifdef SNMP_TRANSPORT_EOC_DOMAIN
+#include <net-snmp/library/snmpEOCDomain.h>
+#endif
 #endif
 
 #include <net-snmp/library/ucd_compat.h>
diff -Naur net-snmp-5.1/local/snmp.conf open_snmp/local/snmp.conf
--- net-snmp-5.1/local/snmp.conf	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/local/snmp.conf	2009-12-16 13:00:48.000000000 +0530
@@ -0,0 +1,62 @@
+###########################################################################
+#
+# snmp.conf
+#
+#   - created by the snmpconf configuration program
+#
+###########################################################################
+# SECTION: Default Authentication Options
+#
+#   This section defines the default authentication
+#   information.  Setting these up properly in your
+#   ~/.snmp/snmp.conf file will greatly reduce the amount of
+#   command line arguments you need to type (especially for snmpv3).
+
+# defversion: The default snmp version number to use.
+#   override: with -v on the command line.
+#   arguments: 1|2c|3
+
+defversion  3
+
+# defsecurityname: The default snmpv3 security name to use when using snmpv3
+#   override: with -u on the command line.
+#   arguments: securityname
+
+defsecurityname  defsecnamev3
+
+# defcontext: The default snmpv3 context name to use
+#   override: with -n on the command line.
+#   arguments: contextname
+
+defcontext  defconnamev3
+
+# defsecuritylevel: The default snmpv3 security level to use
+#   override: with -l on the command line.
+#   arguments: noAuthNoPriv|authNoPriv|authPriv
+
+defsecuritylevel  authNoPriv
+
+# defauthtype: The default snmpv3 authentication type name to use
+#   override: with -a on the command line.
+#   arguments: authtype
+
+defauthtype  MD5
+
+# defauthpassphrase: The default snmpv3 authentication pass phrase to use
+#   Note: It must be at least 8 characters long.
+#   override: with -A on the command line.
+#   arguments: passphrase
+
+defauthpassphrase  subbuauth
+
+
+
+
+
+
+
+
+
+
+
+
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmp-data/authopts open_snmp/local/snmpconf.dir/snmp-data/authopts
--- net-snmp-5.1/local/snmpconf.dir/snmp-data/authopts	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmp-data/authopts	1970-01-01 05:30:00.000000000 +0530
@@ -1,77 +0,0 @@
-title Default Authentication Options
-description This section defines the default authentication
-description information.  Setting these up properly in your
-description ~/.snmp/snmp.conf file will greatly reduce the amount of
-description command line arguments you need to type (especially for snmpv3).
-
-token defaultPort
-info  The default port number to use
-info  This token specifies the default port number you want packets to 
-info  be sent to and received from.
-info  override: with -p on the command line.
-info  arguments: portnum
-question 1 Enter the default port number to use
-
-token defVersion
-info  The default snmp version number to use.
-info  override: with -v on the command line.
-info  arguments: 1|2c|3
-question 1 Enter the default snmp version number to use (1|2c|3)
-validanswer 1 ^(1|2c|3)$
-
-token defCommunity
-info  The default snmpv1 and snmpv2c community name to use when needed.
-info  If this is specified, you don't need to include the community
-info  name as an argument to the snmp applications.  
-info  override: with -c on the command line.
-info  arguments: communityname
-question 1 Enter the default community name to use
-
-token defSecurityName
-info  The default snmpv3 security name to use when using snmpv3
-info  override: with -u on the command line.
-info  arguments: securityname
-question 1 Enter the default security name to use
-
-token defContext
-info  The default snmpv3 context name to use
-info  override: with -n on the command line.
-info  arguments: contextname
-question 1 Enter the default context name to use
-
-token defSecurityLevel
-info  The default snmpv3 security level to use
-info  override: with -l on the command line.
-info  arguments: noAuthNoPriv|authNoPriv|authPriv
-question 1 Enter the default privacy pass phrase to use
-validanswer 1 ^(noAuthNoPriv|authNoPriv|authPriv|nanp|anp|ap)$
-
-token defAuthType
-info  The default snmpv3 authentication type name to use
-info  override: with -a on the command line.
-info  arguments: authtype
-question 1 Enter the default authentication type to use (MD5|SHA)
-validanswer 1 ^(MD5|SHA)$
-
-token defAuthPassphrase
-info  The default snmpv3 authentication pass phrase to use
-info  Note: It must be at least 8 characters long.
-info  override: with -A on the command line.
-info  arguments: passphrase
-question 1 Enter the default authentication pass phrase to use
-
-token defPrivType
-info  The default snmpv3 privacy (encryption) type name to use
-info  override: with -x on the command line.
-info  arguments: privtype
-question 1 Enter the default privacy type to use (DES)
-validanswer 1 ^(DES)$
-
-token defPrivPassphrase
-info  The default snmpv3 privacy pass phrase to use
-info  Note: It must be at least 8 characters long.
-info  override: with -X on the command line.
-info  arguments: passphrase
-question 1 Enter the default privacy pass phrase to use
-
-
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmp-data/debugging open_snmp/local/snmpconf.dir/snmp-data/debugging
--- net-snmp-5.1/local/snmpconf.dir/snmp-data/debugging	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmp-data/debugging	1970-01-01 05:30:00.000000000 +0530
@@ -1,39 +0,0 @@
-title Debugging output options
-description This section allows debugging output of various kinds to
-description be turned on or off.
-
-token doDebugging
-info  Turns debugging output on or off (0|1)
-info  arguments: (0|1)
-question 1 Turn debugging on (0|1)
-validanswer 1 ^(0|1)$
-
-token debugTokens
-info  Debugging tokens specify which lines of debugging
-info  output you'd actually like to see.  Each section of code is most
-info  likely instrumented with a particular "tag".  So, to see that tag you
-info  would specify it here.  Specifying a tag will match against all
-info  tags that begin with that prefix, so the tag "test" will match
-info  "test_function" and "test_something" and...
-info  There are a few special tokens as well:
-info    - ALL:   turns on all the tokens (which generates lots of output)
-info    - trace: prints 'trace' lines showing source code files and
-info    -        line numbers as they're traversed.
-info    - dump:  Nicely breaks down packets as they're parsed or sent out.
-info  command line equivelent: -Dtoken[,token...]
-info  arguments: token[,token...]
-question 1 Enter the tokens (comma seperated) you wish to see output for
-
-token dumpPacket
-info  Print packets as they are received or sent
-info  arguments: (1|yes|true|0|no|false)
-info  command line equivelent: -d
-validanswer 1 ^(1|yes|true|0|no|false)$
-question 1 Print packets as they are received or sent
-
-
-token noTokenWarnings
-info Silence warnings about unknown tokens in configuration files
-question 1 Silence warnings about unknown tokens in configuration files
-info  arguments: (1|yes|true|0|no|false)
-validanswer 1 ^(1|yes|true|0|no|false)$
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmp-data/mibs open_snmp/local/snmpconf.dir/snmp-data/mibs
--- net-snmp-5.1/local/snmpconf.dir/snmp-data/mibs	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmp-data/mibs	1970-01-01 05:30:00.000000000 +0530
@@ -1,56 +0,0 @@
-title Textual mib parsing
-description This section controls the textual mib parser.  Textual
-description mibs are parsed in order to convert OIDs, enumerated
-description lists, and ... to and from textual representations
-description and numerical representations.
-
-token mibdirs
-info  Specifies directories to be searched for mibs.
-info  Adding a '+' sign to the front of the argument appends the new
-info  directory to the list of directories already being searched.
-info  arguments: [+]directory[:directory...]
-question 1 Enter the list of directories to search through for mibs
-
-token mibs
-info  Specifies a list of mibs to be searched for and loaded.
-info  Adding a '+' sign to the front of the argument appends the new
-info  mib name to the list of mibs already being searched for.
-info  arguments: [+]mibname[:mibname...]
-question 1 Enter the list of mibs to read
-
-token mibfile
-info  Loads a particular mib file from a particualar path
-info  arguments: /path/to/mibfile
-question 1 Enter the mib file name to read
-
-token showMibErrors
-info  Should errors in mibs be displayed when the mibs are loaded
-question 1  Should errors in mibs be displayed when the mibs are loaded
-info  arguments: (1|yes|true|0|no|false)
-validanswer 1 ^(1|yes|true|0|no|false)$
-
-token mibWarningLevel
-info  Should warnings about mibs be displayed when the mibs are loaded
-question 1  Should warnings about mibs be displayed when the mibs are loaded
-info  arguments: 1|2
-validanswer 1 ^(1|2)$
-
-token strictCommentTerm
-info  Be strict about about mib comment termination.
-info  Strictly follow comment rules about parsing mibs.
-info  arguments: (1|yes|true|0|no|false)
-validanswer 1 ^(1|yes|true|0|no|false)$
-question 1 Be strict about about mib comment termination
-
-token mibAllowUnderline
-info  Should underlines be allowed in mib symbols (illegal)
-info  arguments: (1|yes|true|0|no|false)
-validanswer 1 ^(1|yes|true|0|no|false)$
-question 1 Should underlines be allowed in mib symbols
-
-token mibReplaceWithLatest
-info  Force replacement of older mibs with known updated ones
-question 1  Force replacement of older mibs with known updated ones
-info  arguments: (1|yes|true|0|no|false)
-validanswer 1 ^(1|yes|true|0|no|false)$
-
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmp-data/output open_snmp/local/snmpconf.dir/snmp-data/output
--- net-snmp-5.1/local/snmpconf.dir/snmp-data/output	2002-07-30 20:56:19.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmp-data/output	1970-01-01 05:30:00.000000000 +0530
@@ -1,79 +0,0 @@
-title Output style options
-description This section allows you to control how the output of the
-description various commands will be formated
-
-token logTimestamp
-info  Should timestamps be shown on the output
-info  arguments: (1|yes|true|0|no|false)
-question 1  Should timestamps be shown on the output
-validanswer 1 ^(1|yes|true|0|no|false)$
-
-token printNumericEnums
-info  Print enums numericly or textually
-info  command line equivelent: -Oe
-question 1 Print enums numericly
-info  arguments: (1|yes|true|0|no|false)
-validanswer 1 ^(1|yes|true|0|no|false)$
-
-token printNumericOids
-info  Print OIDs numericly or textually
-info  command line equivelent: -On
-question 1 Print enums numericly
-info  arguments: (1|yes|true|0|no|false)
-validanswer 1 ^(1|yes|true|0|no|false)$
-
-token dontBreakdownOids
-info When OIDs contain a index to a table, they are broken
-info into the displayable pieces and shown to you.
-info For example the oid vacmSecurityModel.0.3.119.101.115
-info is nicely broken down by
-info default and the string hidden in the oid is shown
-info to you as vacmSecurityModel.0."wes". This token and the -Ob
-info option diables this feature and displays it as
-info vacmSecurityModel.0.3.119.101.115 again.
-info  command line equivelent: -Ob
-info  arguments: (1|yes|true|0|no|false)
-validanswer 1 ^(1|yes|true|0|no|false)$
-question 1 Disable the breaking-down of OIDs?
-
-token escapeQuotes
-info  Should the quotation marks in broken down oids be escaped
-info  If you want to cut and paste oids that have been broken down
-info  into indexes and strings, this will put a backslash in front of them
-info  so your shell will pass them rather than interpret them.
-info  arguments: (1|yes|true|0|no|false)
-question 1  Should the quotation marks in broken down oids be escaped
-validanswer 1 ^(1|yes|true|0|no|false)$
-
-token quickPrinting
-info  Make the output simple for quick parsing
-info  This option removes the equal sign and value identifies leaving
-info  just the oid and the value on the output for easier parsing in scripts
-info  command line equivelent: -Oq
-info  arguments: (1|yes|true|0|no|false)
-validanswer 1 ^(1|yes|true|0|no|false)$
-question 1  Make the output simple for quick parsing
-
-token numericTimeticks
-info  Print timeticks as a number and not a time-string
-info  command line equivelent:
-info  arguments: (1|yes|true|0|no|false)
-question 1 Print timeticks as a number and not a time-string
-validanswer 1 ^(1|yes|true|0|no|false)$
-
-token suffixPrinting
-info Shorten OIDs printed to the screen
-info possible values:
-info -  0:  UCD-style.  OIDs are displayed like:
-info -        system.sysUpTime.0
-info -  1:  deletes all by the last symbolic part of the OID:
-info -        system.sysUpTime.0 becomes sysUpTime.0
-info -  2:  is  a  variant  of this, adding the name of the MIB
-info -      that defined this object:
-info -        system.sysUpTime.0 becomes SNMPv2-MIB::sysUpTime.0
-info -      (This is the default with net-snmp v5)
-info  command line equivelent: 0 = -Ou,  1 = -Os, 2 = -OS
-info  arguments: (1|2)
-question 1 Shorten OIDs (0|1|2)
-validanswer 1 ^(0|1|2)$
-
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmp-data/snmpconf-config open_snmp/local/snmpconf.dir/snmp-data/snmpconf-config
--- net-snmp-5.1/local/snmpconf.dir/snmp-data/snmpconf-config	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmp-data/snmpconf-config	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-forconffile: snmp.conf
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmpd-data/acl open_snmp/local/snmpconf.dir/snmpd-data/acl
--- net-snmp-5.1/local/snmpconf.dir/snmpd-data/acl	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmpd-data/acl	1970-01-01 05:30:00.000000000 +0530
@@ -1,36 +0,0 @@
-title   Access Control Setup
-description	This section defines who is allowed to talk to your running
-description	snmp agent.
-
-token	rwuser
-info	a SNMPv3 read-write user
-info	arguments:  user [noauth|auth|priv] [restriction_oid]
-question 1 The SNMPv3 user that should have read-write access
-question 2 The minimum security level required for that user [noauth|auth|priv, default = auth]
-validanswer 2 (noauth|auth|priv|)
-question 3 The OID that this community should be restricted to [if appropriate]
-
-token	rouser
-info	a SNMPv3 read-only user
-info	arguments:  user [noauth|auth|priv] [restriction_oid]
-steal	rwuser
-question 1 Enter the SNMPv3 user that should have read-only access to the system
-
-token	rocommunity
-info	a SNMPv1/SNMPv2c read-only access community name
-info	arguments:  community [default|hostname|network/bits] [oid]
-question 1 The community name to add read-only access for
-question 2 The hostname or network address to accept this community name from [RETURN for all]
-question 3 The OID that this community should be restricted to [RETURN for no-restriction]
-
-token	rwcommunity
-info	a SNMPv1/SNMPv2c read-write access community name
-info	arguments:  community [default|hostname|network/bits] [oid]
-steal rocommunity
-question 1 Enter the community name to add read-write access for
-
-group access_control
-multiple rwuser Do you want to allow SNMPv3 read-write user based access
-multiple rouser Do you want to allow SNMPv3 read-only user based access
-multiple rwcommunity Do you want to allow SNMPv1/v2c read-write community access
-multiple rocommunity Do you want to allow SNMPv1/v2c read-only community access
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmpd-data/basic_setup open_snmp/local/snmpconf.dir/snmpd-data/basic_setup
--- net-snmp-5.1/local/snmpconf.dir/snmpd-data/basic_setup	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmpd-data/basic_setup	1970-01-01 05:30:00.000000000 +0530
@@ -1,17 +0,0 @@
-group basic_setup
-message ************************************************
-message *** Beginning basic system information setup ***
-message ************************************************
-subgroup system_setup Do you want to configure the information returned in the system MIB group (contact info, etc)?
-message **************************************
-message *** BEGINNING ACCESS CONTROL SETUP ***
-message **************************************
-subgroup access_control Do you want to configure the agent's access control?
-message ****************************************
-message *** Beginning trap destination setup ***
-message ****************************************
-subgroup trapsinks Do you want to configure where and if the agent will send traps?
-message ****************************************
-message *** Beginning monitoring setup ***
-message ****************************************
-subgroup monitoring_services Do you want to configure the agent's ability to monitor various aspects of your system?
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmpd-data/extending open_snmp/local/snmpconf.dir/snmpd-data/extending
--- net-snmp-5.1/local/snmpconf.dir/snmpd-data/extending	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmpd-data/extending	1970-01-01 05:30:00.000000000 +0530
@@ -1,68 +0,0 @@
-title   Extending the Agent
-description	You can extend the snmp agent to have it return information
-description	that you yourself define.
-
-token	exec
-info	run a simple command using exec()
-info	arguments:  [oid] name /path/to/executable arguments
-question 1 The OID where the results table should be display [default=extTable]
-question 2 The "name" to associate with this command when displaying the results.
-question 3 The path to the program to be run.
-question 4 The arguments to pass to $3
-
-token	 pass
-info	 Run a command that intepretes the request for an entire tree.
-info	 The pass program defined here will get called for all
-info	 requests below a certain point in the mib tree.  It is then
-info	 responsible for returning the right data beyond that point.
-info	 #
-info	 arguments: miboid program
-info	 #
-info	 example: pass .1.3.6.1.4.1.2021.255 /path/to/local/passtest
-info	 #
-info	 See the snmpd.conf manual page for further information.
-info	 #
-info	 Consider using "pass_persist" for a performance increase.
-question 1 The OID where the script should take control of
-question 2 The path to the program that should be called 
-
-token pass_persist
-info	 Run a persistant process that intepretes the request for an entire tree.
-info	 The pass program defined here will get called for all
-info	 requests below a certain point in the mib tree.  It is then
-info	 responsible for returning the right data beyond that point.
-info	 The pass_persist scripts must be able to stay running and accept input
-info	 from stdin.
-info	 #
-info	 arguments: miboid program
-info	 #
-info	 example: pass_persist .1.3.6.1.4.1.2021.255 /path/to/local/pass_persisttest
-info	 #
-info	 See the snmpd.conf manual page for further information.
-steal pass
-
-token proxy
-info  Proxy requests to an external agent running somewhere else
-info  This passes all requests for a certain point of the mib tree to
-info  an external agent using snmp requests and then returning the
-info  results to the caller that spoke to our agent.
-info  arguments: [snmpcmd args] host oid [remoteoid]
-question 1 Enter the "snmpcmd" arguments that specify how to talk to the remote host
-question 2 The host you want to pass the requests to
-qusetion 3 The oid that we should pass beyond
-question 4 The oid of the remote site that we should talk to if different from $3 
-
-token	sh
-info	run a simple command using system()
-info	arguments:  [oid] name command arguments
-info	similar to exec, but implemented using system() instead of exec()
-info	#
-info	For security reasons, exec should be preferred.
-steal exec
-
-token dlmod
-info dynamically extend the agent using a shared-object
-info	arguments:  module-name module-path
-question 1 Enter the name of the module
-question 2 Enter the path to the $1 module
-
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmpd-data/monitor open_snmp/local/snmpconf.dir/snmpd-data/monitor
--- net-snmp-5.1/local/snmpconf.dir/snmpd-data/monitor	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmpd-data/monitor	1970-01-01 05:30:00.000000000 +0530
@@ -1,72 +0,0 @@
-title Monitor Various Aspects of the Running Host
-description The following check up on various aspects of a host.
-
-token proc
-info Check for processes that should be running.
-info #  proc NAME [MAX=0] [MIN=0]
-info #
-info #  NAME:  the name of the process to check for.  It must match
-info #         exactly (ie, http will not find httpd processes).
-info #  MAX:   the maximum number allowed to be running.  Defaults to 0.
-info #  MIN:   the minimum number to be running.  Defaults to 0.
-info #
-info The results are reported in the prTable section of the UCD-SNMP-MIB tree
-info Special Case:  When the min and max numbers are both 0, it assumes
-info you want a max of infinity and a min of 1.
-question 1 Name of the process you want to check on
-question 2 Maximum number of processes named '$1' that should be running [default = 0]
-question 3 Minimum number of processes named '$1' that should be running [default = 0]
-
-token disk
-info Check for disk space usage of a partition.
-info The agent can check the amount of available disk space, and make
-info sure it is above a set limit.  
-info
-info # disk PATH [MIN=100000]
-info #
-info # PATH:  mount path to the disk in question.
-info # MIN:   Disks with space below this value will have the Mib's errorFlag set.
-info #        Can be a raw byte value or a percentage followed by the %
-info #        symbol.  Default value = 100000.
-info #
-info The results are reported in the dskTable section of the UCD-SNMP-MIB tree
-question 1 Enter the mount point for the disk partion to be checked on
-question 2 Enter the minimum amount of space that should be available on $1
-
-token load
-info Check for unreasonable load average values.
-info Watch the load average levels on the machine.
-info
-info # load [1MAX=12.0] [5MAX=12.0] [15MAX=12.0]
-info #
-info # 1MAX:   If the 1 minute load average is above this limit at query
-info #         time, the errorFlag will be set.
-info # 5MAX:   Similar, but for 5 min average.
-info # 15MAX:  Similar, but for 15 min average.
-info #
-info The results are reported in the laTable section of the UCD-SNMP-MIB tree
-question 1 Enter the maximum allowable value for the 1 minute load average
-question 2 Enter the maximum allowable value for the 5 minute load average
-question 3 Enter the maximum allowable value for the 15 minute load average
-validanswer 1 ^[\d\.]+$
-validanswer 2 ^([\d\.]+|)$
-validanswer 3 ^([\d\.]+|)$
-
-token file
-info Check on the size of a file.
-info Display a files size statistics.
-info If it grows to be too large, report an error about it.
-info
-info # file /path/to/file [maxsize_in_bytes]
-info #
-info #   if maxsize is not specified, assume only size reporting is needed.
-info #
-info The results are reported in the fileTable section of the UCD-SNMP-MIB tree
-question 1 Enter the path to the file you wish to monitor
-question 2 Enter the maximum size (in bytes) allowable for $1
-
-group monitoring_services
-multiple proc Do you want to configure the agents ability to monitor processes?
-multiple disk Do you want to configure the agents ability to monitor disk space?
-multiple load Do you want to configure the agents ability to monitor load average?
-multiple file Do you want to configure the agents ability to monitor file sizes?
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmpd-data/operation open_snmp/local/snmpconf.dir/snmpd-data/operation
--- net-snmp-5.1/local/snmpconf.dir/snmpd-data/operation	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmpd-data/operation	1970-01-01 05:30:00.000000000 +0530
@@ -1,32 +0,0 @@
-title Agent Operating Mode
-description  This section defines how the agent will operate when it
-description  is running.
-
-token master
-info  Should the agent operate as a master agent or not.
-info  Currently, the only supported master agent type for this token
-info  is "agentx".
-info  #
-info  arguments: (on|yes|agentx|all|off|no)
-question 1 Should the agent run as a AgentX master agent?
-validanswer 1 ^(on|yes|agentx|all|off|no)$
-
-token agentuser
-info  The system user that the agent runs as.
-info  arguments: name|#uid
-question 1 Enter the name of the user that you want the agent to run as
-
-token agentgroup
-info  The system group that the agent runs as.
-info  arguments: group|#GID
-question 1 Enter the name of the group that you want the agent to run as
-
-token agentaddress
-info  The IP address and port number that the agent will listen on.
-info  By default the agent listens to any and all traffic from any
-info  interface on the default SNMP port (161).  This allows you to
-info  specify which address, interface, transport type and port(s) that you
-info  want the agent to listen on.  Multiple definitions of this token
-info  are concatenated together (using ':'s).
-info  arguments: [transport:]port[@interface/address],...
-question 1 Enter the port numbers, etc that you want the agent to listen to
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmpd-data/snmpconf-config open_snmp/local/snmpconf.dir/snmpd-data/snmpconf-config
--- net-snmp-5.1/local/snmpconf.dir/snmpd-data/snmpconf-config	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmpd-data/snmpconf-config	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-forconffile: snmpd.conf
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmpd-data/system open_snmp/local/snmpconf.dir/snmpd-data/system
--- net-snmp-5.1/local/snmpconf.dir/snmpd-data/system	2002-06-25 20:06:18.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmpd-data/system	1970-01-01 05:30:00.000000000 +0530
@@ -1,43 +0,0 @@
-title System Information Setup
-description  This section defines some of the information reported in
-description  the "system" mib group in the mibII tree.
-
-token syslocation
-info  The [typically physical] location of the system.
-info  Note that setting this value here means that when trying to
-info  perform an snmp SET operation to the sysLocation.0 variable will make
-info  the agent return the "notWritable" error code.  IE, including
-info  this token in the snmpd.conf file will disable write access to
-info  the variable.
-info  arguments:  location_string
-question 1 The location of the system
-
-token syscontact
-info  The contact information for the administrator
-info  Note that setting this value here means that when trying to
-info  perform an snmp SET operation to the sysContact.0 variable will make
-info  the agent return the "notWritable" error code.  IE, including
-info  this token in the snmpd.conf file will disable write access to
-info  the variable.
-info  arguments:  contact_string
-question 1 The contact information
-
-token sysservices
-info  The proper value for the sysServices object.
-info  arguments:  sysservices_number
-question 1 does this host offer physical services (eg, like a repeater) [answer 0 or 1]
-question 2 does this host offer datalink/subnetwork services (eg, like a bridge)
-question 3 does this host offer internet services (eg, supports IP)
-question 4 does this host offer end-to-end services (eg, supports TCP)
-question 7 does this host offer application services (eg, supports SMTP)
-validanswer 1 ^(0|1)$
-validanswer 2 ^(0|1)$
-validanswer 3 ^(0|1)$
-validanswer 4 ^(0|1)$
-validanswer 7 ^(0|1)$
-line eval $1*1 + $2*2 + $3*4 + $4*8 + $7*64
-
-group system_setup
-single syslocation
-single syscontact
-single sysservices Do you want to properly set the value of the sysServices.0 OID (if you don't know, just say no)?
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmpd-data/trapsinks open_snmp/local/snmpconf.dir/snmpd-data/trapsinks
--- net-snmp-5.1/local/snmpconf.dir/snmpd-data/trapsinks	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmpd-data/trapsinks	1970-01-01 05:30:00.000000000 +0530
@@ -1,46 +0,0 @@
-title		Trap Destinations
-description	Here we define who the agent will send traps to.
-
-token	    trapsink
-info	    A SNMPv1 trap receiver
-info	    arguments: host [community] [portnum]
-question 1  A host name that should receive the trap
-question 2  The community to be used in the trap sent [optional]
-question 3  The port number the trap should be sent to [optional]
-validanswer 3 ^(\d+|)$
-
-token	    trap2sink
-info	    A SNMPv2c trap receiver
-info	    arguments: host [community] [portnum]
-steal	    trapsink
-
-token	    informsink
-info	    A SNMPv2c inform (acknowledged trap) receiver
-info	    arguments: host [community] [portnum]
-steal	    trapsink
-
-token	    trapsess
-info	    A generic trap receiver defined using snmpcmd style arguments.
-info	    Read the snmpcmd manual page for further information.
-info	    arguments: [snmpcmdargs] host
-question 1  Specify the command line snmpcmd style options for this host
-question 2  Specify the host name
-
-token	    trapcommunity
-info	    Default trap sink community to use
-info	    arguments: community-string
-question 1  The default community name to use when sending traps
-
-
-token	    authtrapenable
-info	    Should we send traps when authentication failures occur
-info	    arguments: 1 | 2   (1 = yes, 2 = no)
-question 1  Should traps be sent when authentication failures occur? (1=yes, 2=no)
-validanswer 1 ^(1|2)$
-
-group trapsinks
-single authtrapenable Do you want the agent to send snmp traps on snmp authentication failures?
-single trapcommunity
-multiple informsink Do you want the agent to send snmpv2c informs to a trap receiver
-multiple trap2sink Do you want the agent to send snmpv2c traps to a trap receiver
-multiple trapsink Do you want the agent to send snmpv1 traps to a trap receiver
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmptrapd-data/formatting open_snmp/local/snmpconf.dir/snmptrapd-data/formatting
--- net-snmp-5.1/local/snmpconf.dir/snmptrapd-data/formatting	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmptrapd-data/formatting	1970-01-01 05:30:00.000000000 +0530
@@ -1,15 +0,0 @@
-title		Output formatting for traps received.
-description	Output from snmptrapd is formatted according to the
-description	rules defined by the formatting configuration directives.
-
-token	    format1
-info	    How SNMPv1 traps are formatted.
-info	    See the snmptrapd.conf manual page for format string details.
-info	    arguments: formatstring
-question 1  The format specification string for SNMPv1 traps
-
-token	    format2
-info	    How SNMPv2 and SNMPv3 traps are formatted.
-info	    See the snmptrapd.conf manual page for format string details.
-info	    arguments: formatstring
-question 1  The format specification string for SNMPv2 and SNMPv3 traps.
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmptrapd-data/snmpconf-config open_snmp/local/snmpconf.dir/snmptrapd-data/snmpconf-config
--- net-snmp-5.1/local/snmpconf.dir/snmptrapd-data/snmpconf-config	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmptrapd-data/snmpconf-config	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-forconffile: snmptrapd.conf
diff -Naur net-snmp-5.1/local/snmpconf.dir/snmptrapd-data/traphandle open_snmp/local/snmpconf.dir/snmptrapd-data/traphandle
--- net-snmp-5.1/local/snmpconf.dir/snmptrapd-data/traphandle	2002-04-20 13:00:13.000000000 +0530
+++ open_snmp/local/snmpconf.dir/snmptrapd-data/traphandle	1970-01-01 05:30:00.000000000 +0530
@@ -1,17 +0,0 @@
-title		Trap Handlers
-description	Here we define what programs are run when a trap is
-description	received by the trap receiver.
-
-token	    traphandle
-info	    When traps are received, a program can be run.
-info	    When traps are received, the list of configured trap
-info	    handles is consulted and any configured program is run.
-info	    If no handler is found, any handler with "default" as the
-info	    traphandle type is run instead.  The information contained
-info	    in trap is passed to the program via standard input (see
-info	    the snmptrapd.conf manual page for details).
-info	    #
-info	    arguments: oid|"default" program args
-question 1  The oid of the trap you want to handle.
-question 2  The program you want to run  If the program is a script, specify the script program first (ie /bin/sh /path/to/script).
-question 3  Arguments that you want passed to the program
diff -Naur net-snmp-5.1/mibs/ADSL-LINE-MIB.txt open_snmp/mibs/ADSL-LINE-MIB.txt
--- net-snmp-5.1/mibs/ADSL-LINE-MIB.txt	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/mibs/ADSL-LINE-MIB.txt	2009-12-16 13:01:10.000000000 +0530
@@ -0,0 +1,4305 @@
+ADSL-LINE-MIB DEFINITIONS ::= BEGIN
+
+   IMPORTS
+       MODULE-IDENTITY, OBJECT-TYPE,
+       Counter32, Gauge32,
+       NOTIFICATION-TYPE,
+       transmission, Unsigned32          FROM SNMPv2-SMI
+       RowStatus,
+       TruthValue, VariablePointer       FROM SNMPv2-TC
+       MODULE-COMPLIANCE, OBJECT-GROUP,
+       NOTIFICATION-GROUP                FROM SNMPv2-CONF
+       ifIndex                           FROM IF-MIB
+       SnmpAdminString                   FROM SNMP-FRAMEWORK-MIB
+       AdslPerfCurrDayCount,
+       AdslPerfPrevDayCount,
+       AdslPerfTimeElapsed,
+       AdslLineCodingType                FROM ADSL-TC-MIB
+       ;
+
+   adslMIB MODULE-IDENTITY
+
+   LAST-UPDATED "9908190000Z"
+
+   ORGANIZATION "IETF ADSL MIB Working Group"
+
+   CONTACT-INFO
+       "
+       Gregory Bathrick
+       AG Communication Systems
+       A Subsidiary of Lucent Technologies
+       2500 W Utopia Rd.
+       Phoenix, AZ 85027 USA
+       Tel: +1 602-582-7679
+       Fax: +1 602-582-7697
+       E-mail: bathricg@agcs.com
+
+       Faye Ly
+       Copper Mountain Networks
+       Norcal Office
+       2470 Embarcadero Way
+       Palo Alto, CA 94303
+       Tel: +1 650-858-8500
+       Fax: +1 650-858-8085
+       E-Mail: faye@coppermountain.com
+
+       (ADSL Forum input only)
+       John Burgess
+       Predictive Systems, Inc.
+       25A Vreeland Rd.
+       Florham Park, NJ 07932 USA
+       Tel: +1 973-301-5610
+       Fax: +1 973-301-5699
+       E-mail: jtburgess@predictive.com
+
+       IETF ADSL MIB Working Group (adsl@xlist.agcs.com)
+       "
+
+   DESCRIPTION
+       "The MIB module defining objects for the management of a pair of
+       ADSL modems at each end of the ADSL line.  Each such line has
+       an entry in an ifTable which may include multiple modem lines.
+       An agent may reside at either end of the ADSL line however the
+       MIB is designed to require no management communication between
+       them beyond that inherent in the low-level ADSL line protocol.
+       The agent may monitor and control this protocol for its needs.
+
+       ADSL lines may support optional Fast or Interleaved channels.
+       If these are supported, additional entries corresponding to the
+       supported channels must be created in the ifTable. Thus an ADSL
+       line that supports both channels will have three entries in the
+       ifTable, one for each physical, fast, and interleaved, whose
+       ifType values are equal to adsl(94), fast(125), and
+       interleaved(124), respectively. The ifStackTable is used to
+       represent the relationship between the entries.
+
+       Naming Conventions:
+                 Atuc -- (ATUC) modem at near (Central) end of line
+                 Atur -- (ATUR) modem at Remote end of line
+                 Curr -- Current
+                 Prev -- Previous
+                 Atn -- Attenuation
+                 ES  -- Errored Second.
+                 LCS -- Line Code Specific
+                 Lof -- Loss of Frame
+                 Lol -- Loss of Link
+                 Los -- Loss of Signal
+                 Lpr -- Loss of Power
+                 xxxs-- interval of Seconds in which xxx occurs
+                         (e.g., xxx=Lof, Los, Lpr)
+                 Max -- Maximum
+                 Mgn -- Margin
+                 Min -- Minimum
+                 Psd -- Power Spectral Density
+                 Snr -- Signal to Noise Ratio
+                 Tx  -- Transmit
+                 Blks-- Blocks, a data unit, see
+                        adslAtuXChanCrcBlockLength
+         "
+         --  Revision history
+         REVISION     "9908190000Z"  -- 19 August 1999, midnight
+         DESCRIPTION  "Initial Version, published as RFC 2662"
+
+   ::= { transmission 94 }
+
+   adslLineMib OBJECT IDENTIFIER ::= { adslMIB 1 }
+
+   adslMibObjects OBJECT IDENTIFIER ::= { adslLineMib 1 }
+
+   -- objects
+         adslLineTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslLineEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table includes common attributes describing
+                 both ends of the line.  It is required for all ADSL
+                 physical interfaces.  ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 1 }
+
+         adslLineEntry   OBJECT-TYPE
+             SYNTAX          AdslLineEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in adslLineTable."
+             INDEX           { ifIndex }
+         ::= { adslLineTable 1 }
+
+         AdslLineEntry ::=
+             SEQUENCE {
+             adslLineCoding           AdslLineCodingType,
+             adslLineType             INTEGER,
+             adslLineSpecific         VariablePointer,
+             adslLineConfProfile      SnmpAdminString,
+             adslLineAlarmConfProfile SnmpAdminString
+             }
+
+         adslLineCoding OBJECT-TYPE
+             SYNTAX      AdslLineCodingType
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Specifies the ADSL coding type used on this
+                 line."
+         ::= { adslLineEntry 1 }
+
+        adslLineType OBJECT-TYPE
+             SYNTAX      INTEGER {
+                 noChannel (1),        -- no channels exist
+                 fastOnly (2),         -- fast channel exists only
+                 interleavedOnly (3),  -- interleaved channel exists
+                                       -- only
+                 fastOrInterleaved (4),-- either fast or interleaved
+                                       -- channels can exist, but
+                                       -- only one at any time
+                 fastAndInterleaved (5)-- both fast or interleaved
+                                       -- channels exist
+             }
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Defines the type of ADSL physical line
+                 entity that exists, by defining whether and how
+                 the line is channelized.  If the line is channelized,
+                 the value will be other than noChannel(1).  This
+                 object defines which channel type(s) are supported.
+
+                 In the case that the line is channelized, the manager
+                 can use the ifStackTable to determine the ifIndex for
+                 the associated channel(s)."
+         ::= { adslLineEntry 2 }
+
+         adslLineSpecific OBJECT-TYPE
+             SYNTAX      VariablePointer
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "OID instance in vendor-specific MIB. The Instance may
+                 be used to determine shelf/slot/port of the ATUC
+                 interface in a DSLAM."
+         ::= { adslLineEntry 3 }
+
+        adslLineConfProfile OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (1..32))
+             MAX-ACCESS  read-write
+             STATUS      current
+             DESCRIPTION
+                 "The value of this object identifies the row
+                 in the ADSL Line Configuration Profile Table,
+                 (adslLineConfProfileTable), which applies for this
+                 ADSL line, and channels if applicable.
+
+                 For `dynamic' mode, in the case which the
+                 configuration profile has not been set, the
+                 value will be set to `DEFVAL'.
+
+                 If the implementator of this MIB has chosen not
+                 to implement `dynamic assignment' of profiles, this
+                 object's MIN-ACCESS is read-only."
+         ::= { adslLineEntry 4 }
+
+        adslLineAlarmConfProfile OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (1..32))
+             MAX-ACCESS  read-write
+             STATUS      current
+             DESCRIPTION
+                 "The value of this object identifies the row
+                 in the ADSL Line Alarm Configuration Profile Table,
+                 (adslLineAlarmConfProfileTable), which applies to this
+                 ADSL line, and channels if applicable.
+
+                 For `dynamic' mode, in the case which the
+                 alarm profile has not been set, the
+                 value will be set to `DEFVAL'.
+
+                 If the implementator of this MIB has chosen not
+                 to implement `dynamic assignment' of profiles, this
+                 object's MIN-ACCESS is read-only."
+         ::= { adslLineEntry 5 }
+
+         adslAtucPhysTable       OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucPhysEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC.
+                 Each row contains the Physical Layer Parameters
+                 table for that ATUC. ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 2 }
+
+         adslAtucPhysEntry       OBJECT-TYPE
+             SYNTAX          AdslAtucPhysEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAtucPhysTable."
+             INDEX           { ifIndex }
+         ::= { adslAtucPhysTable 1 }
+
+         AdslAtucPhysEntry ::=
+             SEQUENCE {
+             adslAtucInvSerialNumber         SnmpAdminString,
+             adslAtucInvVendorID             SnmpAdminString,
+             adslAtucInvVersionNumber        SnmpAdminString,
+             adslAtucCurrSnrMgn              INTEGER,
+             adslAtucCurrAtn                 Gauge32,
+             adslAtucCurrStatus              BITS,
+             adslAtucCurrOutputPwr           INTEGER,
+             adslAtucCurrAttainableRate      Gauge32
+             }
+
+         -- inventory group
+         --
+         -- These items should describe the lowest level identifiable
+         -- component, be it a stand-alone modem, a card in a rack,
+         -- a child-board, etc.
+         --
+         adslAtucInvSerialNumber OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..32))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor specific string that identifies the
+                 vendor equipment."
+         ::= { adslAtucPhysEntry 1 }
+
+         adslAtucInvVendorID OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..16))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor ID code is a copy of the binary
+                 vendor identification field defined by the
+                 PHY[10] and expressed as readable characters."
+
+             REFERENCE "ANSI T1.413[10]"
+         ::= { adslAtucPhysEntry 2 }
+
+         adslAtucInvVersionNumber OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..16))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor specific version number sent by this ATU
+                 as part of the initialization messages.  It is a copy
+                 of the binary version number field defined by the
+                 PHY[10] and expressed as readable characters."
+             REFERENCE "ANSI T1.413[10]"
+         ::= { adslAtucPhysEntry 3 }
+
+         -- current status group
+         --
+         adslAtucCurrSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (-640..640)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Noise Margin as seen by this ATU with respect to its
+                 received signal in tenth dB."
+         ::= { adslAtucPhysEntry 4 }
+
+         adslAtucCurrAtn OBJECT-TYPE
+             SYNTAX      Gauge32(0..630)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Measured difference in the total power transmitted by
+                 the peer ATU and the total power received by this ATU."
+         ::= { adslAtucPhysEntry 5 }
+
+        adslAtucCurrStatus OBJECT-TYPE
+             SYNTAX      BITS {
+                               noDefect(0),
+                               lossOfFraming(1),
+                               lossOfSignal(2),
+                               lossOfPower(3),
+                               lossOfSignalQuality(4),
+                               lossOfLink(5),
+                               dataInitFailure(6),
+                               configInitFailure(7),
+                               protocolInitFailure(8),
+                               noPeerAtuPresent(9)
+                              }
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates current state of the ATUC line.  This is a
+                 bit-map of possible conditions.  The various bit
+                 positions are:
+
+          0      noDefect             There no defects on the line
+
+          1      lossOfFraming        ATUC failure due to not
+                                      receiving valid frame.
+
+          2      lossOfSignal         ATUC failure due to not
+                                      receiving signal.
+
+          3      lossOfPower          ATUC failure due to loss of
+                                      power.
+                                      Note: the Agent may still
+                                      function.
+
+          4      lossOfSignalQuality  Loss of Signal Quality is
+                                      declared when the Noise Margin
+                                      falls below the Minimum Noise
+                                      Margin, or the bit-error-rate
+                                      exceeds 10^-7.
+
+          5      lossOfLink           ATUC failure due to inability
+                                      to link with ATUR.
+
+          6      dataInitFailure      ATUC failure during
+                                      initialization due to bit
+                                      errors corrupting startup
+                                      exchange data.
+
+          7      configInitFailure    ATUC failure during
+                                      initialization due to peer
+                                      ATU not able to support
+                                      requested configuration
+
+          8      protocolInitFailure  ATUC failure during
+                                      initialization due to
+                                      incompatible protocol used by
+                                      the peer ATU.
+
+          9      noPeerAtuPresent     ATUC failure during
+                                      initialization due to no
+                                      activation sequence detected
+                                      from peer ATU.
+
+                 This is intended to supplement ifOperStatus."
+         ::= { adslAtucPhysEntry 6 }
+
+         adslAtucCurrOutputPwr OBJECT-TYPE
+             SYNTAX      INTEGER (-310..310)
+             UNITS       "tenth dBm"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Measured total output power transmitted by this ATU.
+                 This is the measurement that was reported during
+                 the last activation sequence."
+         ::= { adslAtucPhysEntry 7 }
+
+         adslAtucCurrAttainableRate OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates the maximum currently attainable data rate
+                 by the ATU.  This value will be equal or greater than
+                 the current line rate."
+         ::= { adslAtucPhysEntry 8 }
+
+         adslAturPhysTable        OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturPhysEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR
+                 Each row contains the Physical Layer Parameters
+                 table for that ATUR. ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 3 }
+
+         adslAturPhysEntry       OBJECT-TYPE
+             SYNTAX          AdslAturPhysEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAturPhysTable."
+             INDEX           { ifIndex }
+         ::= { adslAturPhysTable 1 }
+
+         AdslAturPhysEntry ::=
+             SEQUENCE {
+             adslAturInvSerialNumber         SnmpAdminString,
+             adslAturInvVendorID             SnmpAdminString,
+             adslAturInvVersionNumber        SnmpAdminString,
+             adslAturCurrSnrMgn              INTEGER,
+             adslAturCurrAtn                 Gauge32,
+             adslAturCurrStatus              BITS,
+             adslAturCurrOutputPwr           INTEGER,
+             adslAturCurrAttainableRate      Gauge32
+             }
+
+         -- inventory group
+         --
+         adslAturInvSerialNumber OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..32))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor specific string that identifies the
+                 vendor equipment."
+         ::= { adslAturPhysEntry 1 }
+
+         adslAturInvVendorID OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..16))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor ID code is a copy of the binary
+                 vendor identification field defined by the
+                 PHY[10] and expressed as readable characters."
+             REFERENCE "ANSI T1.413"
+         ::= { adslAturPhysEntry 2 }
+
+         adslAturInvVersionNumber OBJECT-TYPE
+             SYNTAX      SnmpAdminString (SIZE (0..16))
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The vendor specific version number sent by this ATU
+                 as part of the initialization messages.  It is a copy
+                 of the binary version number field defined by the
+                 PHY[10] and expressed as readable characters."
+             REFERENCE "ANSI T1.413"
+         ::= { adslAturPhysEntry 3 }
+
+         -- current status group
+         --
+         adslAturCurrSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (-640..640)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Noise Margin as seen by this ATU with respect to its
+                 received signal in tenth dB."
+         ::= { adslAturPhysEntry 4 }
+
+         adslAturCurrAtn OBJECT-TYPE
+             SYNTAX      Gauge32(0..630)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Measured difference in the total power transmitted by
+                 the peer ATU and the total power received by this ATU."
+         ::= { adslAturPhysEntry 5 }
+
+        adslAturCurrStatus OBJECT-TYPE
+             SYNTAX     BITS {
+                              noDefect(0),
+                              lossOfFraming(1),
+                              lossOfSignal(2),
+                              lossOfPower(3),
+                              lossOfSignalQuality(4)
+                             }
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates current state of the ATUR line.  This is a
+                 bit-map of possible conditions.  Due to the isolation
+                 of the ATUR when line problems occur, many state
+                 conditions like loss of power, loss of quality signal,
+                 and initialization errors,  can not be determined.
+                 While trouble shooting ATUR, also use object,
+                 adslAtucCurrStatus.  The various bit positions are:
+
+          0      noDefect             There no defects on the line
+
+          1      lossOfFraming        ATUR failure due to not
+                                      receiving valid frame
+
+          2      lossOfSignal         ATUR failure due to not
+                                      receiving signal
+
+          3      lossOfPower          ATUR failure due to loss of
+                                      power
+
+          4      lossOfSignalQuality  Loss of Signal Quality is
+                                      declared when the Noise Margin
+                                      falls below the Minimum Noise
+                                      Margin, or the
+                                      bit-error-rate exceeds 10^-7.
+
+                 This is intended to supplement ifOperStatus."
+         ::= { adslAturPhysEntry 6 }
+
+         adslAturCurrOutputPwr OBJECT-TYPE
+             SYNTAX      INTEGER (-310..310)
+             UNITS       "tenth dBm"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Measured total output power transmitted by this ATU.
+                 This is the measurement that was reported during
+                 the last activation sequence."
+         ::= { adslAturPhysEntry 7 }
+
+         adslAturCurrAttainableRate OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates the maximum currently attainable data rate
+                 by the ATU.  This value will be equal or greater than
+                 the current line rate."
+         ::= { adslAturPhysEntry 8 }
+
+         adslAtucChanTable       OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucChanEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC channel.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 4 }
+
+         adslAtucChanEntry       OBJECT-TYPE
+             SYNTAX          AdslAtucChanEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAtucChanTable."
+             INDEX           { ifIndex }
+         ::= { adslAtucChanTable 1 }
+
+         AdslAtucChanEntry ::=
+             SEQUENCE {
+             adslAtucChanInterleaveDelay     Gauge32,
+             adslAtucChanCurrTxRate          Gauge32,
+             adslAtucChanPrevTxRate          Gauge32,
+             adslAtucChanCrcBlockLength      Gauge32
+             }
+
+         -- current group
+         --
+         adslAtucChanInterleaveDelay OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "milli-seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Interleave Delay for this channel.
+
+                 Interleave delay applies only to the
+                 interleave channel and defines the mapping
+                 (relative spacing) between subsequent input
+                 bytes at the interleaver input and their placement
+                 in the bit stream at the interleaver output.
+                 Larger numbers provide greater separation between
+                 consecutive input bytes in the output bit stream
+                 allowing for improved impulse noise immunity at
+                 the expense of payload latency.
+
+                 In the case where the ifType is Fast(125), use
+                 noSuchObject."
+         ::= { adslAtucChanEntry 1 }
+
+         adslAtucChanCurrTxRate  OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Actual transmit rate on this channel."
+         ::= { adslAtucChanEntry 2 }
+
+         adslAtucChanPrevTxRate OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS        "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The rate at the time of the last
+                 adslAtucRateChangeTrap event. It is also set at
+                 initialization to prevent a trap being sent.
+
+                 Rate changes less than adslAtucThresh(*)RateDown
+                 or less than adslAtucThresh(*)RateUp will not
+                 cause a trap or cause this object to change.
+                 (*) == Fast or Interleave.
+                 See AdslLineAlarmConfProfileEntry."
+         ::= { adslAtucChanEntry 3 }
+
+         adslAtucChanCrcBlockLength OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS        "byte"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates the length of the channel data-block
+                 on which the CRC operates.  Refer to Line Code
+                 Specific MIBs, [11] and [12] for more
+                 information."
+         ::= { adslAtucChanEntry 4 }
+
+        adslAturChanTable       OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturChanEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR channel.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 5 }
+
+         adslAturChanEntry       OBJECT-TYPE
+             SYNTAX          AdslAturChanEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAturChanTable."
+             INDEX           { ifIndex }
+         ::= { adslAturChanTable 1 }
+
+         AdslAturChanEntry ::=
+             SEQUENCE {
+             adslAturChanInterleaveDelay     Gauge32,
+             adslAturChanCurrTxRate          Gauge32,
+             adslAturChanPrevTxRate          Gauge32,
+             adslAturChanCrcBlockLength      Gauge32
+             }
+
+         -- current group
+         --
+         adslAturChanInterleaveDelay OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "milli-seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Interleave Delay for this channel.
+
+                 Interleave delay applies only to the
+                 interleave channel and defines the mapping
+                 (relative spacing) between subsequent input
+                 bytes at the interleaver input and their placement
+                 in the bit stream at the interleaver output.
+                 Larger numbers provide greater separation between
+                 consecutive input bytes in the output bit stream
+                 allowing for improved impulse noise immunity at
+                 the expense of payload latency.
+
+                 In the case where the ifType is Fast(125), use
+                 noSuchObject."
+         ::= { adslAturChanEntry 1 }
+
+         adslAturChanCurrTxRate  OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Actual transmit rate on this channel."
+         ::= { adslAturChanEntry 2 }
+
+         adslAturChanPrevTxRate OBJECT-TYPE
+             SYNTAX      Gauge32
+             UNITS       "bps"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                "The rate at the time of the last
+                 adslAturRateChangeTrap event. It is also set at
+                 initialization to prevent a trap being sent.
+                 Rate changes less than adslAturThresh(*)RateDown
+                 or less than adslAturThresh(*)RateUp will not
+                 cause a trap or cause this object to change.
+                 (*) == Fast or Interleave.
+                 See AdslLineAlarmConfProfileEntry."
+         ::= { adslAturChanEntry 3 }
+
+         adslAturChanCrcBlockLength OBJECT-TYPE
+             SYNTAX      Gauge32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Indicates the length of the channel data-block
+                 on which the CRC operates.  Refer to Line Code
+                 Specific MIBs, [11] and [12] for more
+                 information."
+         ::= { adslAturChanEntry 4 }
+
+         adslAtucPerfDataTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC.
+                 ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 6 }
+         adslAtucPerfDataEntry       OBJECT-TYPE
+             SYNTAX          AdslAtucPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in adslAtucPerfDataTable."
+             INDEX           { ifIndex }
+         ::= { adslAtucPerfDataTable 1 }
+
+         AdslAtucPerfDataEntry ::=
+             SEQUENCE {
+             adslAtucPerfLofs                 Counter32,
+             adslAtucPerfLoss                 Counter32,
+             adslAtucPerfLols                 Counter32,
+             adslAtucPerfLprs                 Counter32,
+             adslAtucPerfESs                  Counter32,
+             adslAtucPerfInits                Counter32,
+             adslAtucPerfValidIntervals       INTEGER,
+             adslAtucPerfInvalidIntervals     INTEGER,
+             adslAtucPerfCurr15MinTimeElapsed AdslPerfTimeElapsed,
+             adslAtucPerfCurr15MinLofs        PerfCurrentCount,
+             adslAtucPerfCurr15MinLoss        PerfCurrentCount,
+             adslAtucPerfCurr15MinLols        PerfCurrentCount,
+             adslAtucPerfCurr15MinLprs        PerfCurrentCount,
+             adslAtucPerfCurr15MinESs         PerfCurrentCount,
+             adslAtucPerfCurr15MinInits       PerfCurrentCount,
+             adslAtucPerfCurr1DayTimeElapsed  AdslPerfTimeElapsed,
+             adslAtucPerfCurr1DayLofs         AdslPerfCurrDayCount,
+             adslAtucPerfCurr1DayLoss         AdslPerfCurrDayCount,
+             adslAtucPerfCurr1DayLols         AdslPerfCurrDayCount,
+             adslAtucPerfCurr1DayLprs         AdslPerfCurrDayCount,
+             adslAtucPerfCurr1DayESs          AdslPerfCurrDayCount,
+             adslAtucPerfCurr1DayInits        AdslPerfCurrDayCount,
+             adslAtucPerfPrev1DayMoniSecs     INTEGER,
+             adslAtucPerfPrev1DayLofs         AdslPerfPrevDayCount,
+             adslAtucPerfPrev1DayLoss         AdslPerfPrevDayCount,
+             adslAtucPerfPrev1DayLols         AdslPerfPrevDayCount,
+             adslAtucPerfPrev1DayLprs         AdslPerfPrevDayCount,
+             adslAtucPerfPrev1DayESs          AdslPerfPrevDayCount,
+             adslAtucPerfPrev1DayInits        AdslPerfPrevDayCount
+             }
+
+         -- Event Counters
+         --
+         -- Also see adslAtucIntervalTable for 15 minute interval
+         -- elapsed counters.
+         --
+         adslAtucPerfLofs OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Framing failures since
+                 agent reset."
+         ::= { adslAtucPerfDataEntry 1 }
+
+         adslAtucPerfLoss  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Signal failures since
+                 agent reset."
+         ::= { adslAtucPerfDataEntry 2 }
+
+         adslAtucPerfLols OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Link failures since
+                 agent reset."
+         ::= { adslAtucPerfDataEntry 3 }
+
+         adslAtucPerfLprs OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Power failures since
+                 agent reset."
+         ::= { adslAtucPerfDataEntry 4 }
+
+         adslAtucPerfESs OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Errored Seconds since agent
+                 reset.  The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAtucPerfDataEntry 5 }
+
+         adslAtucPerfInits OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the line initialization attempts since
+                 agent reset. Includes both successful and failed
+                 attempts."
+         ::= { adslAtucPerfDataEntry 6 }
+
+         -- general 15 min interval information
+         --
+
+         adslAtucPerfValidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of previous 15-minute intervals in the
+                 interval table for which data was collected.  Given
+                 that <n> is the maximum # of intervals supported.
+                 The value will be <n> unless the measurement was
+                 (re-)started within the last (<n>*15) minutes, in which
+                 case the value will be the number of complete 15
+                 minute intervals for which the agent has at least
+                 some data. In certain cases (e.g., in the case
+                 where the agent is a proxy) it is possible that some
+                 intervals are unavailable.  In this case, this
+                 interval is the maximum interval number for
+                 which data is available."
+         ::= { adslAtucPerfDataEntry 7 }
+
+         adslAtucPerfInvalidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of intervals in the range from
+                 0 to the value of adslAtucPerfValidIntervals
+                 for which no data is available. This object
+                 will typically be zero except in cases where
+                 the data for some intervals are not available
+                 (e.g., in proxy situations)."
+         ::= { adslAtucPerfDataEntry 8 }
+
+         -- 15 min current performance group
+         --
+         adslAtucPerfCurr15MinTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..899)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Total elapsed seconds in this interval."
+         ::= { adslAtucPerfDataEntry 9 }
+
+         adslAtucPerfCurr15MinLofs OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Framing."
+         ::= { adslAtucPerfDataEntry 10 }
+
+         adslAtucPerfCurr15MinLoss  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Signal."
+         ::= { adslAtucPerfDataEntry 11 }
+
+         adslAtucPerfCurr15MinLols  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Link."
+         ::= { adslAtucPerfDataEntry 12 }
+
+         adslAtucPerfCurr15MinLprs  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Power."
+         ::= { adslAtucPerfDataEntry 13 }
+
+         adslAtucPerfCurr15MinESs OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds in the current 15 minute
+                 interval.  The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAtucPerfDataEntry 14 }
+
+         adslAtucPerfCurr15MinInits  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the line initialization attempts in the
+                 current 15 minute interval. Includes both successful
+                 and failed attempts."
+         ::= { adslAtucPerfDataEntry 15 }
+
+         -- 1-day current and previous performance group
+         --
+         adslAtucPerfCurr1DayTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..86399)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Number of seconds that have elapsed since the
+                 beginning of the current 1-day interval."
+         ::= { adslAtucPerfDataEntry 16 }
+
+         adslAtucPerfCurr1DayLofs  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss of
+                 Framing during the current day as measured by
+                 adslAtucPerfCurr1DayTimeElapsed."
+         ::= { adslAtucPerfDataEntry 17 }
+
+         adslAtucPerfCurr1DayLoss  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss of
+                 Signal during the current day as measured by
+                 adslAtucPerfCurr1DayTimeElapsed."
+         ::= { adslAtucPerfDataEntry 18 }
+
+         adslAtucPerfCurr1DayLols  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss of
+                 Link during the current day as measured by
+                 adslAtucPerfCurr1DayTimeElapsed."
+         ::= { adslAtucPerfDataEntry 19 }
+
+         adslAtucPerfCurr1DayLprs  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss of
+                 Power during the current day as measured by
+                 adslAtucPerfCurr1DayTimeElapsed."
+         ::= { adslAtucPerfDataEntry 20 }
+
+         adslAtucPerfCurr1DayESs OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds during the current day as
+                 measured by adslAtucPerfCurr1DayTimeElapsed.
+                 The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAtucPerfDataEntry 21 }
+
+         adslAtucPerfCurr1DayInits  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the line initialization attempts in the
+                 day as measured by adslAtucPerfCurr1DayTimeElapsed.
+                 Includes both successful and failed attempts."
+         ::= { adslAtucPerfDataEntry 22 }
+
+         adslAtucPerfPrev1DayMoniSecs OBJECT-TYPE
+             SYNTAX      INTEGER(0..86400)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The amount of time in the previous 1-day interval
+                 over which the performance monitoring information
+                 is actually counted. This value will be the same as
+                 the interval duration except in a situation where
+                 performance monitoring data could not be collected
+                 for any reason."
+         ::= { adslAtucPerfDataEntry 23 }
+
+         adslAtucPerfPrev1DayLofs  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Framing within the most recent previous
+                 1-day period."
+         ::= { adslAtucPerfDataEntry 24 }
+
+         adslAtucPerfPrev1DayLoss  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Signal within the most recent previous
+                 1-day period."
+         ::= { adslAtucPerfDataEntry 25 }
+
+         adslAtucPerfPrev1DayLols  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Link within the most recent previous
+                 1-day period."
+         ::= { adslAtucPerfDataEntry 26 }
+         adslAtucPerfPrev1DayLprs  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Power within the most recent previous
+                 1-day period."
+         ::= { adslAtucPerfDataEntry 27 }
+
+         adslAtucPerfPrev1DayESs OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds within the most recent
+                 previous 1-day period. The errored second parameter is
+                 a count of one-second intervals containing one or more
+                 crc anomalies, or one or more los or sef defects."
+         ::= { adslAtucPerfDataEntry 28 }
+
+         adslAtucPerfPrev1DayInits  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the line initialization attempts in the most
+                 recent previous 1-day period. Includes both successful
+                 and failed attempts."
+         ::= { adslAtucPerfDataEntry 29 }
+
+         adslAturPerfDataTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR.
+                 ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 7 }
+
+         adslAturPerfDataEntry       OBJECT-TYPE
+             SYNTAX          AdslAturPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in adslAturPerfDataTable."
+             INDEX           { ifIndex }
+         ::= { adslAturPerfDataTable 1 }
+
+         AdslAturPerfDataEntry ::=
+             SEQUENCE {
+             adslAturPerfLofs                 Counter32,
+             adslAturPerfLoss                 Counter32,
+             adslAturPerfLprs                 Counter32,
+             adslAturPerfESs                  Counter32,
+             adslAturPerfValidIntervals       INTEGER,
+             adslAturPerfInvalidIntervals     INTEGER,
+             adslAturPerfCurr15MinTimeElapsed AdslPerfTimeElapsed,
+             adslAturPerfCurr15MinLofs        PerfCurrentCount,
+             adslAturPerfCurr15MinLoss        PerfCurrentCount,
+             adslAturPerfCurr15MinLprs        PerfCurrentCount,
+             adslAturPerfCurr15MinESs         PerfCurrentCount,
+             adslAturPerfCurr1DayTimeElapsed  AdslPerfTimeElapsed,
+             adslAturPerfCurr1DayLofs         AdslPerfCurrDayCount,
+             adslAturPerfCurr1DayLoss         AdslPerfCurrDayCount,
+             adslAturPerfCurr1DayLprs         AdslPerfCurrDayCount,
+             adslAturPerfCurr1DayESs          AdslPerfCurrDayCount,
+             adslAturPerfPrev1DayMoniSecs     INTEGER,
+             adslAturPerfPrev1DayLofs         AdslPerfPrevDayCount,
+             adslAturPerfPrev1DayLoss         AdslPerfPrevDayCount,
+             adslAturPerfPrev1DayLprs         AdslPerfPrevDayCount,
+             adslAturPerfPrev1DayESs          AdslPerfPrevDayCount
+             }
+
+         -- Event (Raw) Counters
+         --
+         -- Also see adslAturIntervalTable for 15 minute interval
+         -- elapsed counters.
+         --
+         adslAturPerfLofs OBJECT-TYPE
+             SYNTAX      Counter32
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Framing failures since
+                 agent reset."
+         ::= { adslAturPerfDataEntry 1 }
+
+         adslAturPerfLoss  OBJECT-TYPE
+             SYNTAX      Counter32
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Signal failures since
+                 agent reset."
+         ::= { adslAturPerfDataEntry 2 }
+
+        adslAturPerfLprs  OBJECT-TYPE
+             SYNTAX      Counter32
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Loss of Power failures since
+                 agent reset."
+         ::= { adslAturPerfDataEntry 3 }
+
+         adslAturPerfESs  OBJECT-TYPE
+             SYNTAX      Counter32
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of Errored Seconds since agent
+                 reset.  The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAturPerfDataEntry 4 }
+
+         -- general 15 min interval information
+         --
+         adslAturPerfValidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of previous 15-minute intervals in the
+                 interval table for which data was collected.  Given
+                 that <n> is the maximum # of intervals supported.
+                 The value will be <n> unless the measurement was
+                 (re-)started within the last (<n>*15) minutes, in which
+                 case the value will be the number of complete 15
+                 minute intervals for which the agent has at least
+                 some data. In certain cases (e.g., in the case
+                 where the agent is a proxy) it is possible that some
+                 intervals are unavailable.  In this case, this
+                 interval is the maximum interval number for
+                 which data is available."
+         ::= { adslAturPerfDataEntry 5 }
+
+         adslAturPerfInvalidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of intervals in the range from
+                 0 to the value of adslAturPerfValidIntervals
+                 for which no data is available. This object
+                 will typically be zero except in cases where
+                 the data for some intervals are not available
+                 (e.g., in proxy situations)."
+         ::= { adslAturPerfDataEntry 6 }
+
+         -- 15 min current performance group
+         --
+         adslAturPerfCurr15MinTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..899)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Total elapsed seconds in this interval."
+         ::= { adslAturPerfDataEntry 7 }
+
+         adslAturPerfCurr15MinLofs OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Framing."
+         ::= { adslAturPerfDataEntry 8 }
+
+         adslAturPerfCurr15MinLoss  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Signal."
+         ::= { adslAturPerfDataEntry 9 }
+
+         adslAturPerfCurr15MinLprs  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the current 15 minute interval
+                 when there was Loss of Power."
+         ::= { adslAturPerfDataEntry 10 }
+
+         adslAturPerfCurr15MinESs OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                "Count of Errored Seconds in the current 15 minute
+                interval.  The errored second parameter is a count of
+                one-second intervals containing one or more crc
+                anomalies, or one or more los or sef defects."
+
+         ::= { adslAturPerfDataEntry 11 }
+
+         -- 1-day current and previous performance group
+         --
+         adslAturPerfCurr1DayTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..86399)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Number of seconds that have elapsed since the
+                 beginning of the current 1-day interval."
+         ::= { adslAturPerfDataEntry 12 }
+
+         adslAturPerfCurr1DayLofs  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss
+                 of Framing during the current day as measured by
+                 adslAturPerfCurr1DayTimeElapsed."
+         ::= { adslAturPerfDataEntry 13 }
+
+         adslAturPerfCurr1DayLoss  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss
+                 of Signal during the current day as measured by
+                 adslAturPerfCurr1DayTimeElapsed."
+         ::= { adslAturPerfDataEntry 14 }
+
+         adslAturPerfCurr1DayLprs  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the number of seconds when there was Loss
+                 of Power during the current day as measured by
+                 adslAturPerfCurr1DayTimeElapsed."
+         ::= { adslAturPerfDataEntry 15 }
+
+    adslAturPerfCurr1DayESs OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds during the current day as
+                 measured by adslAturPerfCurr1DayTimeElapsed.
+                 The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAturPerfDataEntry 16 }
+
+         adslAturPerfPrev1DayMoniSecs OBJECT-TYPE
+             SYNTAX      INTEGER(0..86400)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The amount of time in the previous 1-day interval
+                 over which the performance monitoring information
+                 is actually counted. This value will be the same as
+                 the interval duration except in a situation where
+                 performance monitoring data could not be collected
+                 for any reason."
+         ::= { adslAturPerfDataEntry 17 }
+
+         adslAturPerfPrev1DayLofs  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Framing within the most recent previous
+                 1-day period."
+         ::= { adslAturPerfDataEntry 18 }
+
+         adslAturPerfPrev1DayLoss  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Signal within the most recent previous
+                 1-day period."
+         ::= { adslAturPerfDataEntry 19 }
+
+         adslAturPerfPrev1DayLprs  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Power within the most recent previous
+                 1-day period."
+         ::= { adslAturPerfDataEntry 20 }
+
+         adslAturPerfPrev1DayESs OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds within the most recent
+                 previous 1-day period. The errored second parameter is
+                 a count of one-second intervals containing one or more
+                 crc anomalies, or one or more los or sef defects."
+         ::= { adslAturPerfDataEntry 21 }
+
+         adslAtucIntervalTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC
+                 performance data collection interval.
+                 ADSL physical interfaces are
+                 those ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 8 }
+
+         adslAtucIntervalEntry   OBJECT-TYPE
+             SYNTAX          AdslAtucIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAtucIntervalTable."
+             INDEX           { ifIndex, adslAtucIntervalNumber }
+         ::= { adslAtucIntervalTable 1 }
+
+         AdslAtucIntervalEntry ::=
+             SEQUENCE {
+             adslAtucIntervalNumber          INTEGER,
+             adslAtucIntervalLofs            PerfIntervalCount,
+             adslAtucIntervalLoss            PerfIntervalCount,
+             adslAtucIntervalLols            PerfIntervalCount,
+             adslAtucIntervalLprs            PerfIntervalCount,
+             adslAtucIntervalESs             PerfIntervalCount,
+             adslAtucIntervalInits           PerfIntervalCount,
+             adslAtucIntervalValidData       TruthValue
+             }
+
+         adslAtucIntervalNumber OBJECT-TYPE
+             SYNTAX      INTEGER(1..96)
+             MAX-ACCESS  not-accessible
+             STATUS      current
+             DESCRIPTION
+                 "Performance Data Interval number 1 is the
+                 the most recent previous interval; interval
+                 96 is 24 hours ago.  Intervals 2..96 are
+                 optional."
+         ::= { adslAtucIntervalEntry 1 }
+
+         adslAtucIntervalLofs OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was Loss
+                 of Framing."
+         ::= { adslAtucIntervalEntry 2 }
+
+         adslAtucIntervalLoss  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was Loss
+                 of Signal."
+         ::= { adslAtucIntervalEntry 3 }
+
+         adslAtucIntervalLols  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was Loss
+                 of Link."
+         ::= { adslAtucIntervalEntry 4 }
+
+         adslAtucIntervalLprs  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was Loss
+                 of Power."
+         ::= { adslAtucIntervalEntry 5 }
+
+         adslAtucIntervalESs OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds in the interval.
+                 The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAtucIntervalEntry 6 }
+
+         adslAtucIntervalInits  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of the line initialization attempts
+                 during the interval. Includes both successful
+                 and failed attempts."
+         ::= { adslAtucIntervalEntry 7 }
+
+         adslAtucIntervalValidData OBJECT-TYPE
+             SYNTAX TruthValue
+             MAX-ACCESS read-only
+             STATUS current
+             DESCRIPTION
+                 "This variable indicates if the data for this
+                 interval is valid."
+         ::= { adslAtucIntervalEntry 8 }
+
+         adslAturIntervalTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR
+                 performance data collection interval.
+                 ADSL physical interfaces are those
+                 ifEntries where ifType is equal to adsl(94)."
+         ::= { adslMibObjects 9 }
+
+         adslAturIntervalEntry   OBJECT-TYPE
+             SYNTAX          AdslAturIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAturIntervalTable."
+             INDEX           { ifIndex, adslAturIntervalNumber }
+         ::= { adslAturIntervalTable 1 }
+
+         AdslAturIntervalEntry ::=
+             SEQUENCE {
+             adslAturIntervalNumber          INTEGER,
+             adslAturIntervalLofs            PerfIntervalCount,
+             adslAturIntervalLoss            PerfIntervalCount,
+             adslAturIntervalLprs            PerfIntervalCount,
+             adslAturIntervalESs             PerfIntervalCount,
+             adslAturIntervalValidData       TruthValue
+             }
+
+         adslAturIntervalNumber OBJECT-TYPE
+             SYNTAX      INTEGER(1..96)
+             MAX-ACCESS  not-accessible
+             STATUS      current
+             DESCRIPTION
+                 "Performance Data Interval number 1 is the
+                 the most recent previous interval; interval
+                 96 is 24 hours ago.  Intervals 2..96 are
+                 optional."
+         ::= { adslAturIntervalEntry 1 }
+         adslAturIntervalLofs OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Framing."
+         ::= { adslAturIntervalEntry 2 }
+
+         adslAturIntervalLoss  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Signal."
+         ::= { adslAturIntervalEntry 3 }
+
+         adslAturIntervalLprs  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of seconds in the interval when there was
+                 Loss of Power."
+         ::= { adslAturIntervalEntry 4 }
+
+         adslAturIntervalESs OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of Errored Seconds in the interval.
+                 The errored second parameter is a count of
+                 one-second intervals containing one or more crc
+                 anomalies, or one or more los or sef defects."
+         ::= { adslAturIntervalEntry 5 }
+
+         adslAturIntervalValidData OBJECT-TYPE
+             SYNTAX TruthValue
+             MAX-ACCESS read-only
+             STATUS current
+             DESCRIPTION
+                 "This variable indicates if the data for this
+                 interval is valid."
+         ::= { adslAturIntervalEntry 6 }
+
+         adslAtucChanPerfDataTable       OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucChanPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC channel.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 10 }
+
+         adslAtucChanPerfDataEntry       OBJECT-TYPE
+
+             SYNTAX          AdslAtucChanPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in adslAtucChanPerfDataTable."
+             INDEX           { ifIndex }
+         ::= { adslAtucChanPerfDataTable 1 }
+
+         AdslAtucChanPerfDataEntry ::=
+          SEQUENCE {
+          adslAtucChanReceivedBlks                 Counter32,
+          adslAtucChanTransmittedBlks              Counter32,
+          adslAtucChanCorrectedBlks                Counter32,
+          adslAtucChanUncorrectBlks                Counter32,
+          adslAtucChanPerfValidIntervals           INTEGER,
+          adslAtucChanPerfInvalidIntervals         INTEGER,
+          adslAtucChanPerfCurr15MinTimeElapsed     AdslPerfTimeElapsed,
+          adslAtucChanPerfCurr15MinReceivedBlks    PerfCurrentCount,
+          adslAtucChanPerfCurr15MinTransmittedBlks PerfCurrentCount,
+          adslAtucChanPerfCurr15MinCorrectedBlks   PerfCurrentCount,
+          adslAtucChanPerfCurr15MinUncorrectBlks   PerfCurrentCount,
+          adslAtucChanPerfCurr1DayTimeElapsed      AdslPerfTimeElapsed,
+          adslAtucChanPerfCurr1DayReceivedBlks     AdslPerfCurrDayCount,
+          adslAtucChanPerfCurr1DayTransmittedBlks  AdslPerfCurrDayCount,
+          adslAtucChanPerfCurr1DayCorrectedBlks    AdslPerfCurrDayCount,
+          adslAtucChanPerfCurr1DayUncorrectBlks    AdslPerfCurrDayCount,
+          adslAtucChanPerfPrev1DayMoniSecs         INTEGER,
+          adslAtucChanPerfPrev1DayReceivedBlks     AdslPerfPrevDayCount,
+          adslAtucChanPerfPrev1DayTransmittedBlks  AdslPerfPrevDayCount,
+          adslAtucChanPerfPrev1DayCorrectedBlks    AdslPerfPrevDayCount,
+          adslAtucChanPerfPrev1DayUncorrectBlks    AdslPerfPrevDayCount
+         }
+         -- performance group
+         --
+         -- Note: block is intended to be the length of the channel
+         --       data-block on which the CRC operates. See
+         --       adslAtucChanCrcBlockLength for more information.
+         --
+         adslAtucChanReceivedBlks OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this channel
+                 since agent reset."
+         ::= { adslAtucChanPerfDataEntry 1 }
+
+         adslAtucChanTransmittedBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel since agent reset."
+         ::= { adslAtucChanPerfDataEntry 2 }
+
+         adslAtucChanCorrectedBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected since agent reset.  These blocks are passed
+                 on as good data."
+         ::= { adslAtucChanPerfDataEntry 3 }
+
+         adslAtucChanUncorrectBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors since agent reset."
+         ::= { adslAtucChanPerfDataEntry 4 }
+
+         -- general 15 min interval information
+         --
+         adslAtucChanPerfValidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of previous 15-minute intervals in the
+                 interval table for which data was collected.  Given
+                 that <n> is the maximum # of intervals supported.
+                 The value will be <n> unless the measurement was
+                 (re-)started within the last (<n>*15) minutes, in which
+                 case the value will be the number of complete 15
+                 minute intervals for which the agent has at least
+                 some data. In certain cases (e.g., in the case
+                 where the agent is a proxy) it is possible that some
+                 intervals are unavailable.  In this case, this
+                 interval is the maximum interval number for
+                 which data is available."
+         ::= { adslAtucChanPerfDataEntry 5 }
+
+         adslAtucChanPerfInvalidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of intervals in the range from
+                 0 to the value of adslAtucChanPerfValidIntervals
+                 for which no data is available. This object
+                 will typically be zero except in cases where
+                 the data for some intervals are not available
+                 (e.g., in proxy situations)."
+         ::= { adslAtucChanPerfDataEntry 6 }
+
+         -- 15 min current performance group
+         --
+         adslAtucChanPerfCurr15MinTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..899)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Total elapsed seconds in this interval."
+         ::= { adslAtucChanPerfDataEntry 7 }
+
+         adslAtucChanPerfCurr15MinReceivedBlks OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this channel
+                 within the current 15 minute interval."
+         ::= { adslAtucChanPerfDataEntry 8 }
+
+         adslAtucChanPerfCurr15MinTransmittedBlks OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel within the current 15 minute interval."
+         ::= { adslAtucChanPerfDataEntry 9 }
+
+         adslAtucChanPerfCurr15MinCorrectedBlks  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel within the current 15 minute
+                 interval."
+         ::= { adslAtucChanPerfDataEntry 10 }
+
+         adslAtucChanPerfCurr15MinUncorrectBlks  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel within the current 15 minute
+                 interval."
+         ::= { adslAtucChanPerfDataEntry 11 }
+
+         -- 1-day current and previous performance group
+         --
+         adslAtucChanPerfCurr1DayTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..86399)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Number of seconds that have elapsed since the
+                 beginning of the current 1-day interval."
+         ::= { adslAtucChanPerfDataEntry 12 }
+
+         adslAtucChanPerfCurr1DayReceivedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this
+                 channel during the current day as measured by
+                 adslAtucChanPerfCurr1DayTimeElapsed."
+         ::= { adslAtucChanPerfDataEntry 13 }
+
+         adslAtucChanPerfCurr1DayTransmittedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel during the current day as measured by
+                 adslAtucChanPerfCurr1DayTimeElapsed."
+         ::= { adslAtucChanPerfDataEntry 14 }
+
+         adslAtucChanPerfCurr1DayCorrectedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel during the current day as
+                 measured by adslAtucChanPerfCurr1DayTimeElapsed."
+         ::= { adslAtucChanPerfDataEntry 15 }
+
+         adslAtucChanPerfCurr1DayUncorrectBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel during the current day as
+                 measured by adslAtucChanPerfCurr1DayTimeElapsed."
+         ::= { adslAtucChanPerfDataEntry 16 }
+
+         adslAtucChanPerfPrev1DayMoniSecs OBJECT-TYPE
+             SYNTAX      INTEGER(0..86400)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The amount of time in the previous 1-day interval
+                 over which the performance monitoring information
+                 is actually counted. This value will be the same as
+                 the interval duration except in a situation where
+                 performance monitoring data could not be collected
+                 for any reason."
+         ::= { adslAtucChanPerfDataEntry 17 }
+
+         adslAtucChanPerfPrev1DayReceivedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this
+                 channel within the most recent previous 1-day
+                 period."
+         ::= { adslAtucChanPerfDataEntry 18 }
+
+         adslAtucChanPerfPrev1DayTransmittedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel within the most recent previous 1-day
+                 period."
+         ::= { adslAtucChanPerfDataEntry 19 }
+
+         adslAtucChanPerfPrev1DayCorrectedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel within the most recent
+                 previous 1-day period."
+         ::= { adslAtucChanPerfDataEntry 20 }
+
+         adslAtucChanPerfPrev1DayUncorrectBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel within the most recent previous
+                 1-day period."
+         ::= { adslAtucChanPerfDataEntry 21 }
+
+         adslAturChanPerfDataTable       OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturChanPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR channel.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 11 }
+
+         adslAturChanPerfDataEntry       OBJECT-TYPE
+             SYNTAX          AdslAturChanPerfDataEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in adslAturChanPerfDataTable."
+             INDEX           { ifIndex }
+         ::= { adslAturChanPerfDataTable 1 }
+
+         AdslAturChanPerfDataEntry ::=
+          SEQUENCE {
+          adslAturChanReceivedBlks                 Counter32,
+          adslAturChanTransmittedBlks              Counter32,
+          adslAturChanCorrectedBlks                Counter32,
+          adslAturChanUncorrectBlks                Counter32,
+          adslAturChanPerfValidIntervals           INTEGER,
+          adslAturChanPerfInvalidIntervals         INTEGER,
+          adslAturChanPerfCurr15MinTimeElapsed     AdslPerfTimeElapsed,
+          adslAturChanPerfCurr15MinReceivedBlks    PerfCurrentCount,
+          adslAturChanPerfCurr15MinTransmittedBlks PerfCurrentCount,
+          adslAturChanPerfCurr15MinCorrectedBlks   PerfCurrentCount,
+          adslAturChanPerfCurr15MinUncorrectBlks   PerfCurrentCount,
+          adslAturChanPerfCurr1DayTimeElapsed      AdslPerfTimeElapsed,
+          adslAturChanPerfCurr1DayReceivedBlks     AdslPerfCurrDayCount,
+          adslAturChanPerfCurr1DayTransmittedBlks  AdslPerfCurrDayCount,
+          adslAturChanPerfCurr1DayCorrectedBlks    AdslPerfCurrDayCount,
+          adslAturChanPerfCurr1DayUncorrectBlks    AdslPerfCurrDayCount,
+          adslAturChanPerfPrev1DayMoniSecs         INTEGER,
+          adslAturChanPerfPrev1DayReceivedBlks     AdslPerfPrevDayCount,
+          adslAturChanPerfPrev1DayTransmittedBlks  AdslPerfPrevDayCount,
+          adslAturChanPerfPrev1DayCorrectedBlks    AdslPerfPrevDayCount,
+          adslAturChanPerfPrev1DayUncorrectBlks    AdslPerfPrevDayCount
+          }
+         -- performance group
+         --
+         -- Note: block is intended to be the length of the channel
+         --       data-block on which the CRC operates. See
+         --       adslAturChanCrcBlockLength for more information.
+         --
+         adslAturChanReceivedBlks OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this channel
+                 since agent reset."
+         ::= { adslAturChanPerfDataEntry 1 }
+         adslAturChanTransmittedBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel since agent reset."
+         ::= { adslAturChanPerfDataEntry 2 }
+
+         adslAturChanCorrectedBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected since agent reset.  These blocks are passed
+                 on as good data."
+         ::= { adslAturChanPerfDataEntry 3 }
+
+         adslAturChanUncorrectBlks  OBJECT-TYPE
+             SYNTAX      Counter32
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors since agent reset."
+         ::= { adslAturChanPerfDataEntry 4 }
+
+         -- general 15 min interval information
+         --
+         adslAturChanPerfValidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of previous 15-minute intervals in the
+                 interval table for which data was collected.  Given
+                 that <n> is the maximum # of intervals supported.
+                 The value will be <n> unless the measurement was
+                 (re-)started within the last (<n>*15) minutes, in which
+                 case the value will be the number of complete 15
+                 minute intervals for which the agent has at least
+                 some data. In certain cases (e.g., in the case
+                 where the agent is a proxy) it is possible that some
+                 intervals are unavailable.  In this case, this
+                 interval is the maximum interval number for
+                 which data is available."
+         ::= { adslAturChanPerfDataEntry 5 }
+         adslAturChanPerfInvalidIntervals OBJECT-TYPE
+             SYNTAX      INTEGER(0..96)
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The number of intervals in the range from
+                 0 to the value of adslAturChanPerfValidIntervals
+                 for which no data is available. This object
+                 will typically be zero except in cases where
+                 the data for some intervals are not available
+                 (e.g., in proxy situations)."
+         ::= { adslAturChanPerfDataEntry 6 }
+
+         -- 15 min current performance group
+         --
+         adslAturChanPerfCurr15MinTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..899)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Total elapsed seconds in this interval.
+                 A full interval is 900 seconds."
+         ::= { adslAturChanPerfDataEntry 7 }
+
+         adslAturChanPerfCurr15MinReceivedBlks OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this
+                 channel within the current 15 minute interval."
+         ::= { adslAturChanPerfDataEntry 8 }
+
+         adslAturChanPerfCurr15MinTransmittedBlks OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel within the current 15 minute interval."
+         ::= { adslAturChanPerfDataEntry 9 }
+
+         adslAturChanPerfCurr15MinCorrectedBlks  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel within the current 15 minute
+                 interval."
+         ::= { adslAturChanPerfDataEntry 10 }
+
+         adslAturChanPerfCurr15MinUncorrectBlks  OBJECT-TYPE
+             SYNTAX      PerfCurrentCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel within the current 15 minute
+                 interval."
+         ::= { adslAturChanPerfDataEntry 11 }
+
+         -- 1-day current and previous performance group
+         --
+         adslAturChanPerfCurr1DayTimeElapsed OBJECT-TYPE
+             SYNTAX      AdslPerfTimeElapsed(0..86399)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Number of seconds that have elapsed since the
+                 beginning of the current 1-day interval."
+         ::= { adslAturChanPerfDataEntry 12 }
+
+         adslAturChanPerfCurr1DayReceivedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this
+                 channel during the current day as measured by
+                 adslAturChanPerfCurr1DayTimeElapsed."
+         ::= { adslAturChanPerfDataEntry 13 }
+
+         adslAturChanPerfCurr1DayTransmittedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel during the current day as measured by
+                 adslAturChanPerfCurr1DayTimeElapsed."
+
+         ::= { adslAturChanPerfDataEntry 14 }
+
+         adslAturChanPerfCurr1DayCorrectedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel during the current day as
+                 measured by adslAturChanPerfCurr1DayTimeElapsed."
+         ::= { adslAturChanPerfDataEntry 15 }
+
+         adslAturChanPerfCurr1DayUncorrectBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfCurrDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel during the current day as
+                 measured by adslAturChanPerfCurr1DayTimeElapsed."
+         ::= { adslAturChanPerfDataEntry 16 }
+
+         adslAturChanPerfPrev1DayMoniSecs OBJECT-TYPE
+             SYNTAX      INTEGER(0..86400)
+             UNITS       "seconds"
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "The amount of time in the previous 1-day interval
+                 over which the performance monitoring information
+                 is actually counted. This value will be the same as
+                 the interval duration except in a situation where
+                 performance monitoring data could not be collected
+                 for any reason."
+         ::= { adslAturChanPerfDataEntry 17 }
+
+         adslAturChanPerfPrev1DayReceivedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this
+                 channel within the most recent previous 1-day
+                 period."
+         ::= { adslAturChanPerfDataEntry 18 }
+
+         adslAturChanPerfPrev1DayTransmittedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel within the most recent previous 1-day
+                 period."
+         ::= { adslAturChanPerfDataEntry 19 }
+
+         adslAturChanPerfPrev1DayCorrectedBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel within the most recent
+                 previous 1-day period."
+         ::= { adslAturChanPerfDataEntry 20 }
+
+         adslAturChanPerfPrev1DayUncorrectBlks  OBJECT-TYPE
+             SYNTAX      AdslPerfPrevDayCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel within the most recent previous
+                 1-day period."
+         ::= { adslAturChanPerfDataEntry 21 }
+
+         adslAtucChanIntervalTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAtucChanIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUC channel's
+                 performance data collection interval.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 12 }
+
+         adslAtucChanIntervalEntry   OBJECT-TYPE
+             SYNTAX          AdslAtucChanIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAtucIntervalTable."
+             INDEX           { ifIndex, adslAtucChanIntervalNumber }
+         ::= { adslAtucChanIntervalTable 1 }
+
+         AdslAtucChanIntervalEntry ::=
+             SEQUENCE {
+             adslAtucChanIntervalNumber          INTEGER,
+             adslAtucChanIntervalReceivedBlks    PerfIntervalCount,
+             adslAtucChanIntervalTransmittedBlks PerfIntervalCount,
+             adslAtucChanIntervalCorrectedBlks   PerfIntervalCount,
+             adslAtucChanIntervalUncorrectBlks   PerfIntervalCount,
+             adslAtucChanIntervalValidData       TruthValue
+             }
+         adslAtucChanIntervalNumber OBJECT-TYPE
+             SYNTAX      INTEGER(1..96)
+             MAX-ACCESS  not-accessible
+             STATUS      current
+             DESCRIPTION
+                 "Performance Data Interval number 1 is the
+                 the most recent previous interval; interval
+                 96 is 24 hours ago.  Intervals 2..96 are
+                 optional."
+         ::= { adslAtucChanIntervalEntry 1 }
+
+         adslAtucChanIntervalReceivedBlks OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this channel
+                 during this interval."
+         ::= { adslAtucChanIntervalEntry 2 }
+
+         adslAtucChanIntervalTransmittedBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel during this interval."
+         ::= { adslAtucChanIntervalEntry 3 }
+
+         adslAtucChanIntervalCorrectedBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel during this interval."
+         ::= { adslAtucChanIntervalEntry 4 }
+
+         adslAtucChanIntervalUncorrectBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel during this interval."
+         ::= { adslAtucChanIntervalEntry 5 }
+
+         adslAtucChanIntervalValidData OBJECT-TYPE
+             SYNTAX TruthValue
+             MAX-ACCESS read-only
+             STATUS current
+             DESCRIPTION
+                 "This variable indicates if the data for this
+                 interval is valid."
+         ::= { adslAtucChanIntervalEntry 6 }
+
+         adslAturChanIntervalTable   OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslAturChanIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table provides one row for each ATUR channel's
+                 performance data collection interval.
+                 ADSL channel interfaces are those ifEntries
+                 where ifType is equal to adslInterleave(124)
+                 or adslFast(125)."
+         ::= { adslMibObjects 13 }
+
+         adslAturChanIntervalEntry   OBJECT-TYPE
+             SYNTAX          AdslAturChanIntervalEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION     "An entry in the adslAturIntervalTable."
+             INDEX           { ifIndex, adslAturChanIntervalNumber }
+         ::= { adslAturChanIntervalTable 1 }
+
+         AdslAturChanIntervalEntry ::=
+             SEQUENCE {
+             adslAturChanIntervalNumber               INTEGER,
+             adslAturChanIntervalReceivedBlks         PerfIntervalCount,
+             adslAturChanIntervalTransmittedBlks      PerfIntervalCount,
+             adslAturChanIntervalCorrectedBlks        PerfIntervalCount,
+             adslAturChanIntervalUncorrectBlks        PerfIntervalCount,
+             adslAturChanIntervalValidData            TruthValue
+             }
+         adslAturChanIntervalNumber OBJECT-TYPE
+             SYNTAX      INTEGER(1..96)
+             MAX-ACCESS  not-accessible
+             STATUS      current
+             DESCRIPTION
+                 "Performance Data Interval number 1 is the
+                 the most recent previous interval; interval
+                 96 is 24 hours ago.  Intervals 2..96 are
+                 optional."
+         ::= { adslAturChanIntervalEntry 1 }
+
+         adslAturChanIntervalReceivedBlks OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks received on this channel
+                 during this interval."
+         ::= { adslAturChanIntervalEntry 2 }
+
+         adslAturChanIntervalTransmittedBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all encoded blocks transmitted on this
+                 channel during this interval."
+         ::= { adslAturChanIntervalEntry 3 }
+
+         adslAturChanIntervalCorrectedBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with errors that were
+                 corrected on this channel during this interval."
+         ::= { adslAturChanIntervalEntry 4 }
+
+         adslAturChanIntervalUncorrectBlks  OBJECT-TYPE
+             SYNTAX      PerfIntervalCount
+             MAX-ACCESS  read-only
+             STATUS      current
+             DESCRIPTION
+                 "Count of all blocks received with uncorrectable
+                 errors on this channel during this interval."
+         ::= { adslAturChanIntervalEntry 5 }
+
+         adslAturChanIntervalValidData OBJECT-TYPE
+             SYNTAX TruthValue
+             MAX-ACCESS read-only
+             STATUS current
+             DESCRIPTION
+                 "This variable indicates if the data for this
+                 interval is valid."
+         ::= { adslAturChanIntervalEntry 6 }
+
+         -- Profile Group
+         --
+
+         adslLineConfProfileTable    OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslLineConfProfileEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table contains information on the ADSL line
+                 configuration.  One entry in this table reflects a
+                 profile defined by a manager which can be used to
+                 configure the ADSL line."
+         ::= { adslMibObjects 14}
+
+         adslLineConfProfileEntry    OBJECT-TYPE
+             SYNTAX          AdslLineConfProfileEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "Each entry consists of a list of parameters that
+                 represents the configuration of an ADSL modem.
+
+                 When `dynamic' profiles are implemented, a default
+                 profile will always exist.  This profile's name will
+                 be set to `DEFVAL' and its parameters will be set
+                 to vendor specific values, unless otherwise specified
+                 in this document.
+
+                 When `static' profiles are implemented, profiles
+                 are automaticly created or destroyed as ADSL
+                 physical lines are discovered and removed by
+                 the system.  The name of the profile will be
+                 equivalent to the decimal value of the line's
+                 interface index.
+                 "
+             INDEX { IMPLIED adslLineConfProfileName}
+         ::= { adslLineConfProfileTable 1}
+
+         AdslLineConfProfileEntry ::=
+             SEQUENCE {
+             adslLineConfProfileName               SnmpAdminString,
+             adslAtucConfRateMode                  INTEGER,
+             adslAtucConfRateChanRatio             INTEGER,
+             adslAtucConfTargetSnrMgn              INTEGER,
+             adslAtucConfMaxSnrMgn                 INTEGER,
+             adslAtucConfMinSnrMgn                 INTEGER,
+             adslAtucConfDownshiftSnrMgn           INTEGER,
+             adslAtucConfUpshiftSnrMgn             INTEGER,
+             adslAtucConfMinUpshiftTime            INTEGER,
+             adslAtucConfMinDownshiftTime          INTEGER,
+             adslAtucChanConfFastMinTxRate         Unsigned32,
+             adslAtucChanConfInterleaveMinTxRate   Unsigned32,
+             adslAtucChanConfFastMaxTxRate         Unsigned32,
+             adslAtucChanConfInterleaveMaxTxRate   Unsigned32,
+             adslAtucChanConfMaxInterleaveDelay    INTEGER,
+             adslAturConfRateMode                  INTEGER,
+             adslAturConfRateChanRatio             INTEGER,
+             adslAturConfTargetSnrMgn              INTEGER,
+             adslAturConfMaxSnrMgn                 INTEGER,
+             adslAturConfMinSnrMgn                 INTEGER,
+             adslAturConfDownshiftSnrMgn           INTEGER,
+             adslAturConfUpshiftSnrMgn             INTEGER,
+             adslAturConfMinUpshiftTime            INTEGER,
+             adslAturConfMinDownshiftTime          INTEGER,
+             adslAturChanConfFastMinTxRate         Unsigned32,
+             adslAturChanConfInterleaveMinTxRate   Unsigned32,
+             adslAturChanConfFastMaxTxRate         Unsigned32,
+             adslAturChanConfInterleaveMaxTxRate   Unsigned32,
+             adslAturChanConfMaxInterleaveDelay    INTEGER,
+             adslLineConfProfileRowStatus          RowStatus
+         }
+
+         adslLineConfProfileName    OBJECT-TYPE
+                 SYNTAX          SnmpAdminString (SIZE (1..32))
+                 MAX-ACCESS      not-accessible
+                 STATUS          current
+                 DESCRIPTION
+                 "This object is used by the line configuration table
+                 in order to identify a row of this table.
+
+                 When `dynamic' profiles are implemented, the profile
+                 name is user specified.  Also, the system will always
+                 provide a default profile whose name is `DEFVAL'.
+
+                 When `static' profiles are implemented, there is an
+                 one-to-one relationship between each line and its
+                 profile.  In which case, the profile name will
+                 need to algorithmicly represent the Line's ifIndex.
+                 Therefore, the profile's name is a decimalized string
+                 of the ifIndex that is fixed-length (i.e., 10) with
+                 leading zero(s).  For example, the profile name for
+                 ifIndex which equals '15' will be '0000000015'."
+         ::= { adslLineConfProfileEntry 1 }
+
+         adslAtucConfRateMode OBJECT-TYPE
+             SYNTAX      INTEGER {
+                 fixed (1),              -- no rate adaptation
+                 adaptAtStartup (2),     -- perform rate adaptation
+                                         -- only at initialization
+                 adaptAtRuntime (3)      -- perform rate adaptation at
+                                         -- any time
+             }
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Defines what form of transmit rate adaptation is
+                 configured on this modem.  See ADSL Forum TR-005 [3]
+                 for more information."
+         ::= { adslLineConfProfileEntry 2 }
+
+         adslAtucConfRateChanRatio OBJECT-TYPE
+             SYNTAX      INTEGER(0..100)
+             UNITS        "%"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured allocation ratio of excess transmit
+                 bandwidth between fast and interleaved channels.  Only
+                 applies when two channel mode and RADSL are supported.
+                 Distribute bandwidth on each channel in excess of the
+                 corresponding ChanConfMinTxRate so that:
+                 adslAtucConfRateChanRatio =
+
+                         [Fast / (Fast + Interleaved)] * 100
+
+                 In other words this value is the fast channel
+                 percentage."
+         ::= { adslLineConfProfileEntry 3 }
+
+       adslAtucConfTargetSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Target Signal/Noise Margin.
+                 This is the Noise Margin the modem must achieve
+                 with a BER of 10-7 or better to successfully complete
+                 initialization."
+         ::= { adslLineConfProfileEntry 4 }
+       adslAtucConfMaxSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum acceptable Signal/Noise Margin.
+                 If the Noise Margin is above this the modem should
+                 attempt to reduce its power output to optimize its
+                 operation."
+         ::= { adslLineConfProfileEntry 5 }
+
+         adslAtucConfMinSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum acceptable Signal/Noise Margin.
+                 If the noise margin falls below this level, the modem
+                 should attempt to increase its power output.  If that
+                 is not possible the modem will attempt to
+                 re-initialize or shut down."
+         ::= { adslLineConfProfileEntry 6 }
+
+         adslAtucConfDownshiftSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Signal/Noise Margin for rate downshift.
+                 If the noise margin falls below this level, the modem
+                 should attempt to decrease its transmit rate.  In
+                 the case that RADSL mode is not present,
+                 the value will be `0'."
+         ::= { adslLineConfProfileEntry 7 }
+
+         adslAtucConfUpshiftSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Signal/Noise Margin for rate upshift.
+                 If the noise margin rises above this level, the modem
+                 should attempt to increase its transmit rate.    In
+                 the case that RADSL is not present, the value will
+                 be `0'."
+         ::= { adslLineConfProfileEntry 8 }
+
+         adslAtucConfMinUpshiftTime OBJECT-TYPE
+             SYNTAX      INTEGER(0..16383)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Minimum time that the current margin is above
+                 UpshiftSnrMgn before an upshift occurs.
+                 In the case that RADSL is not present, the value will
+                 be `0'."
+         ::= { adslLineConfProfileEntry 9 }
+        adslAtucConfMinDownshiftTime OBJECT-TYPE
+             SYNTAX      INTEGER(0..16383)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Minimum time that the current margin is below
+                 DownshiftSnrMgn before a downshift occurs.
+                 In the case that RADSL mode is not present,
+                 the value will be `0'."
+         ::= { adslLineConfProfileEntry 10 }
+
+         adslAtucChanConfFastMinTxRate  OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum Transmit rate for `Fast' channels,
+                 in bps.  See adslAtucConfRateChanRatio for information
+                 regarding RADSL mode and ATUR transmit rate for
+                 ATUC receive rates."
+         ::= { adslLineConfProfileEntry 11 }
+
+         adslAtucChanConfInterleaveMinTxRate OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum Transmit rate for `Interleave'
+                 channels, in bps.  See adslAtucConfRateChanRatio for
+                 information regarding RADSL mode and see
+                 ATUR transmit rate for receive rates."
+         ::= { adslLineConfProfileEntry 12 }
+
+         adslAtucChanConfFastMaxTxRate  OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum Transmit rate for `Fast' channels,
+                 in bps.  See adslAtucConfRateChanRatio for information
+                 regarding RADSL mode and see ATUR transmit rate for
+                 ATUC receive rates."
+         ::= { adslLineConfProfileEntry 13 }
+
+         adslAtucChanConfInterleaveMaxTxRate OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum Transmit rate for `Interleave'
+                 channels, in bps.  See adslAtucConfRateChanRatio for
+                 information regarding RADSL mode and ATUR transmit
+                 rate for ATUC receive rates."
+         ::= { adslLineConfProfileEntry 14 }
+
+         adslAtucChanConfMaxInterleaveDelay OBJECT-TYPE
+             SYNTAX      INTEGER(0..255)
+             UNITS        "milli-seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured maximum Interleave Delay for this channel.
+
+                 Interleave delay applies only to the interleave channel
+                 and defines the mapping (relative spacing) between
+                 subsequent input bytes at the interleaver input and
+                 their placement in the bit stream at the interleaver
+                 output.  Larger numbers provide greater separation
+                 between consecutive input bytes in the output bit
+                 stream allowing for improved impulse noise immunity
+                 at the expense of payload latency."
+         ::= { adslLineConfProfileEntry 15 }
+
+         adslAturConfRateMode OBJECT-TYPE
+             SYNTAX      INTEGER {
+                 fixed (1),              -- no rate adaptation
+                 adaptAtStartup (2),     -- perform rate adaptation
+                                         -- only at initialization
+                 adaptAtRuntime (3)      -- perform rate adaptation at
+                                         -- any time
+             }
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Defines what form of transmit rate adaptation is
+                 configured on this modem.  See ADSL Forum TR-005 [3]
+                 for more information."
+         ::= { adslLineConfProfileEntry 16 }
+
+         adslAturConfRateChanRatio OBJECT-TYPE
+             SYNTAX      INTEGER(0..100)
+             UNITS        "%"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured allocation ratio of excess transmit
+                 bandwidth between fast and interleaved channels.  Only
+                 applies when two channel mode and RADSL are supported.
+                 Distribute bandwidth on each channel in excess of the
+                 corresponding ChanConfMinTxRate so that:
+                 adslAturConfRateChanRatio =
+
+                         [Fast / (Fast + Interleaved)] * 100
+
+                 In other words this value is the fast channel
+                 percentage."
+         ::= { adslLineConfProfileEntry 17 }
+
+       adslAturConfTargetSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Target Signal/Noise Margin.
+                 This is the Noise Margin the modem must achieve
+                 with a BER of 10-7 or better to successfully complete
+                 initialization."
+         ::= { adslLineConfProfileEntry 18 }
+
+       adslAturConfMaxSnrMgn OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum acceptable Signal/Noise Margin.
+                 If the Noise Margin is above this the modem should
+                 attempt to reduce its power output to optimize its
+                 operation."
+         ::= { adslLineConfProfileEntry 19 }
+
+        adslAturConfMinSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum acceptable Signal/Noise Margin.
+                 If the noise margin falls below this level, the modem
+                 should attempt to increase its power output.  If that
+                 is not possible the modem will attempt to
+                 re-initialize or shut down."
+         ::= { adslLineConfProfileEntry 20 }
+
+         adslAturConfDownshiftSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Signal/Noise Margin for rate downshift.
+                 If the noise margin falls below this level, the modem
+                 should attempt to decrease its transmit rate.
+                 In the case that RADSL mode is not present,
+                 the value will be `0'."
+         ::= { adslLineConfProfileEntry 21 }
+
+         adslAturConfUpshiftSnrMgn  OBJECT-TYPE
+             SYNTAX      INTEGER (0..310)
+             UNITS       "tenth dB"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Signal/Noise Margin for rate upshift.
+                 If the noise margin rises above this level, the modem
+                 should attempt to increase its transmit rate.
+                 In the case that RADSL is not present,
+                 the value will be `0'."
+         ::= { adslLineConfProfileEntry 22 }
+
+         adslAturConfMinUpshiftTime OBJECT-TYPE
+             SYNTAX      INTEGER(0..16383)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Minimum time that the current margin is above
+                 UpshiftSnrMgn before an upshift occurs.
+                 In the case that RADSL is not present, the value will
+                 be `0'."
+         ::= { adslLineConfProfileEntry 23 }
+
+        adslAturConfMinDownshiftTime OBJECT-TYPE
+             SYNTAX      INTEGER(0..16383)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Minimum time that the current margin is below
+                 DownshiftSnrMgn before a downshift occurs.
+                 In the case that RADSL mode is not present,
+                 the value will be `0'."
+         ::= { adslLineConfProfileEntry 24 }
+
+         adslAturChanConfFastMinTxRate  OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum Transmit rate for `Fast' channels,
+                 in bps.  See adslAturConfRateChanRatio for information
+                 regarding RADSL mode and ATUC transmit rate
+                 for ATUR receive rates."
+         ::= { adslLineConfProfileEntry 25 }
+
+         adslAturChanConfInterleaveMinTxRate OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Minimum Transmit rate for `Interleave'
+                 channels, in bps.  See adslAturConfRateChanRatio for
+                 information regarding RADSL mode and ATUC transmit rate
+                 for ATUR receive rates."
+         ::= { adslLineConfProfileEntry 26 }
+
+         adslAturChanConfFastMaxTxRate  OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum Transmit rate for `Fast' channels,
+                 in bps.  See adslAturConfRateChanRatio for information
+                 regarding RADSL mode and ATUC transmit rate
+                 for ATUR receive rates."
+         ::= { adslLineConfProfileEntry 27 }
+
+         adslAturChanConfInterleaveMaxTxRate OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured Maximum Transmit rate for `Interleave'
+                 channels, in bps.  See adslAturConfRateChanRatio for
+                 information regarding RADSL mode and see
+                 ATUC transmit rate for ATUR receive rates."
+         ::= { adslLineConfProfileEntry 28 }
+
+         adslAturChanConfMaxInterleaveDelay OBJECT-TYPE
+             SYNTAX      INTEGER(0..255)
+             UNITS        "milli-seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Configured maximum Interleave Delay for this channel.
+
+                 Interleave delay applies only to the interleave channel
+                 and defines the mapping (relative spacing) between
+                 subsequent input bytes at the interleaver input and
+                 their placement in the bit stream at the interleaver
+                 output.  Larger numbers provide greater separation
+                 between consecutive input bytes in the output bit
+                 stream allowing for improved impulse noise immunity
+                 at the expense of payload latency."
+         ::= { adslLineConfProfileEntry 29 }
+
+         adslLineConfProfileRowStatus OBJECT-TYPE
+             SYNTAX          RowStatus
+             MAX-ACCESS      read-create
+             STATUS          current
+             DESCRIPTION
+                 "This object is used to create a new row or modify or
+                 delete an existing row in this table.
+
+                 A profile activated by setting this object to
+                 `active'.  When `active' is set, the system
+                 will validate the profile.
+
+                 Before a profile can be deleted or taken out of
+                 service, (by setting this object to `destroy' or
+                 `outOfService') it must be first unreferenced
+                 from all associated lines.
+
+                 If the implementator of this MIB has chosen not
+                 to implement `dynamic assignment' of profiles, this
+                 object's MIN-ACCESS is read-only and its value
+                 is always to be `active'."
+         ::= { adslLineConfProfileEntry 30 }
+
+         adslLineAlarmConfProfileTable    OBJECT-TYPE
+             SYNTAX          SEQUENCE OF AdslLineAlarmConfProfileEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This table contains information on the ADSL line
+                 configuration.  One entry in this table reflects a
+                 profile defined by a manager which can be used to
+                 configure the modem for a physical line"
+         ::= { adslMibObjects 15}
+
+         adslLineAlarmConfProfileEntry    OBJECT-TYPE
+             SYNTAX          AdslLineAlarmConfProfileEntry
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "Each entry consists of a list of parameters that
+                 represents the configuration of an ADSL modem.
+
+                 When `dynamic' profiles are implemented, a default
+                 profile will always exist.  This profile's name will
+                 be set to `DEFVAL' and its parameters will be set to
+                 vendor specific values, unless otherwise specified
+                 in this document.
+
+                 When `static' profiles are implemented, profiles
+                 are automaticly created or destroyed as ADSL
+                 physical lines are discovered and removed by
+                 the system.  The name of the profile will be
+                 equivalent to the decimal value of the line's
+                 interface index.
+                 "
+             INDEX { IMPLIED adslLineAlarmConfProfileName}
+         ::= { adslLineAlarmConfProfileTable 1}
+
+         AdslLineAlarmConfProfileEntry ::=
+             SEQUENCE {
+             adslLineAlarmConfProfileName          SnmpAdminString,
+             adslAtucThresh15MinLofs               INTEGER,
+             adslAtucThresh15MinLoss               INTEGER,
+             adslAtucThresh15MinLols               INTEGER,
+             adslAtucThresh15MinLprs               INTEGER,
+             adslAtucThresh15MinESs                INTEGER,
+             adslAtucThreshFastRateUp              Unsigned32,
+             adslAtucThreshInterleaveRateUp        Unsigned32,
+             adslAtucThreshFastRateDown            Unsigned32,
+             adslAtucThreshInterleaveRateDown      Unsigned32,
+             adslAtucInitFailureTrapEnable         INTEGER,
+             adslAturThresh15MinLofs               INTEGER,
+             adslAturThresh15MinLoss               INTEGER,
+             adslAturThresh15MinLprs               INTEGER,
+             adslAturThresh15MinESs                INTEGER,
+             adslAturThreshFastRateUp              Unsigned32,
+             adslAturThreshInterleaveRateUp        Unsigned32,
+             adslAturThreshFastRateDown            Unsigned32,
+             adslAturThreshInterleaveRateDown      Unsigned32,
+             adslLineAlarmConfProfileRowStatus     RowStatus
+             }
+
+         adslLineAlarmConfProfileName    OBJECT-TYPE
+             SYNTAX          SnmpAdminString (SIZE (1..32))
+             MAX-ACCESS      not-accessible
+             STATUS          current
+             DESCRIPTION
+                 "This object is used by the line alarm configuration
+                 table in order to identify a row of this table.
+
+                 When `dynamic' profiles are implemented, the profile
+                 name is user specified.  Also, the system will always
+                 provide a default profile whose name is `DEFVAL'.
+
+                 When `static' profiles are implemented, there is an
+                 one-to-one relationship between each line and its
+                 profile.  In which case, the profile name will
+                 need to algorithmicly represent the Line's ifIndex.
+                 Therefore, the profile's name is a decimalized string
+                 of the ifIndex that is fixed-length (i.e., 10) with
+                 leading zero(s).  For example, the profile name for
+                 ifIndex which equals '15' will be '0000000015'."
+         ::= { adslLineAlarmConfProfileEntry 1}
+
+         adslAtucThresh15MinLofs OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Frame Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAtucPerfLofsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 2}
+
+         adslAtucThresh15MinLoss  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Signal Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAtucPerfLossThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 3}
+
+         adslAtucThresh15MinLols  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Link Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAtucPerfLolsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 4}
+
+         adslAtucThresh15MinLprs  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Power Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAtucPerfLprsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 5}
+
+         adslAtucThresh15MinESs  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Errored Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAtucPerfESsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 6}
+
+         adslAtucThreshFastRateUp OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Fast' channels only.
+                 Configured change in rate causing an
+                 adslAtucRateChangeTrap. A trap is produced when:
+                 ChanCurrTxRate >= ChanPrevTxRate plus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 7}
+
+         adslAtucThreshInterleaveRateUp OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Interleave' channels only.
+                 Configured change in rate causing an
+                 adslAtucRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate >= ChanPrevTxRate plus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 8}
+
+         adslAtucThreshFastRateDown OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Fast' channels only.
+                 Configured change in rate causing an
+                 adslAtucRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate <= ChanPrevTxRate minus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 9 }
+
+         adslAtucThreshInterleaveRateDown OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Interleave' channels only.
+                 Configured change in rate causing an
+                 adslAtucRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate <= ChanPrevTxRate minus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 10 }
+
+         adslAtucInitFailureTrapEnable OBJECT-TYPE
+             SYNTAX      INTEGER {
+                 enable (1),
+                 disable (2)
+             }
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Enables and disables the InitFailureTrap.  This
+                 object is defaulted disable(2)."
+         DEFVAL { disable }
+         ::= { adslLineAlarmConfProfileEntry 11 }
+
+         adslAturThresh15MinLofs OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Frame Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAturPerfLofsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 12 }
+
+         adslAturThresh15MinLoss  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Signal Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAturPerfLossThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 13 }
+
+         adslAturThresh15MinLprs  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Loss of Power Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAturPerfLprsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 14 }
+
+         adslAturThresh15MinESs  OBJECT-TYPE
+             SYNTAX      INTEGER(0..900)
+             UNITS       "seconds"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "The number of Errored Seconds
+                 encountered by an ADSL interface within any given 15
+                 minutes performance data collection period, which
+                 causes the SNMP agent to send an
+                 adslAturPerfESsThreshTrap.
+                 One trap will be sent per interval per interface.
+                 A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 15 }
+
+         adslAturThreshFastRateUp OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Fast' channels only.
+                 Configured change in rate causing an
+                 adslAturRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate >= ChanPrevTxRate plus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 16 }
+
+         adslAturThreshInterleaveRateUp OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Interleave' channels only.
+                 configured change in rate causing an
+                 adslAturRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate >= ChanPrevTxRate plus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 17 }
+
+         adslAturThreshFastRateDown OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Fast' channels only.
+                 Configured change in rate causing an
+                 adslAturRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate <= ChanPrevTxRate minus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 18 }
+
+         adslAturThreshInterleaveRateDown OBJECT-TYPE
+             SYNTAX      Unsigned32
+             UNITS       "bps"
+             MAX-ACCESS  read-create
+             STATUS      current
+             DESCRIPTION
+                 "Applies to `Interleave' channels only.
+                 Configured change in rate causing an
+                 adslAturRateChangeTrap.  A trap is produced when:
+                 ChanCurrTxRate <= ChanPrevTxRate minus the value of
+                 this object. A value of `0' will disable the trap."
+         ::= { adslLineAlarmConfProfileEntry 19 }
+
+         adslLineAlarmConfProfileRowStatus OBJECT-TYPE
+             SYNTAX          RowStatus
+             MAX-ACCESS      read-create
+             STATUS          current
+             DESCRIPTION
+                 "This object is used to create a new row or modify or
+                 delete an existing row in this table.
+
+                 A profile activated by setting this object to
+                 `active'.  When `active' is set, the system
+                 will validate the profile.
+
+                 Before a profile can be deleted or taken out of
+                 service, (by setting this object to `destroy' or
+                 `outOfService') it must be first unreferenced
+                 from all associated lines.
+
+                 If the implementator of this MIB has chosen not
+                 to implement `dynamic assignment' of profiles, this
+                 object's MIN-ACCESS is read-only and its value
+                 is always to be `active'."
+         ::= { adslLineAlarmConfProfileEntry 20 }
+
+         -- Line Code Specific Tables
+
+         -- These are place holders for the Line Code Specific MIBs
+         -- once they become available.
+
+         adslLCSMib  OBJECT IDENTIFIER ::= { adslMibObjects 16 }
+
+   -- trap definitions
+
+   adslTraps OBJECT IDENTIFIER ::= { adslLineMib 2 }
+
+   adslAtucTraps OBJECT IDENTIFIER ::= { adslTraps 1 }
+
+         adslAtucPerfLofsThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAtucPerfCurr15MinLofs,
+                       adslAtucThresh15MinLofs }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Framing 15-minute interval threshold reached."
+         ::= { adslAtucTraps 0 1 }
+
+         adslAtucPerfLossThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAtucPerfCurr15MinLoss,
+                       adslAtucThresh15MinLoss }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Signal 15-minute interval threshold reached."
+         ::= { adslAtucTraps 0 2 }
+
+         adslAtucPerfLprsThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAtucPerfCurr15MinLprs,
+                       adslAtucThresh15MinLprs }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Power 15-minute interval threshold reached."
+         ::= { adslAtucTraps 0 3 }
+
+         adslAtucPerfESsThreshTrap       NOTIFICATION-TYPE
+             OBJECTS { adslAtucPerfCurr15MinESs,
+                       adslAtucThresh15MinESs }
+             STATUS  current
+             DESCRIPTION
+                 "Errored Second 15-minute interval threshold reached."
+         ::= { adslAtucTraps 0 4 }
+
+         adslAtucRateChangeTrap  NOTIFICATION-TYPE
+             OBJECTS { adslAtucChanCurrTxRate,
+                       adslAtucChanPrevTxRate }
+             STATUS  current
+             DESCRIPTION
+                 "The ATUCs transmit rate has changed (RADSL mode only)"
+         ::= { adslAtucTraps 0 5 }
+
+         adslAtucPerfLolsThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAtucPerfCurr15MinLols,
+                       adslAtucThresh15MinLols }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Link 15-minute interval threshold reached."
+         ::= { adslAtucTraps 0 6 }
+
+         adslAtucInitFailureTrap NOTIFICATION-TYPE
+             OBJECTS { adslAtucCurrStatus }
+             STATUS  current
+             DESCRIPTION
+                 "ATUC initialization failed. See adslAtucCurrStatus
+                 for potential reasons."
+         ::= { adslAtucTraps 0 7 }
+
+   adslAturTraps OBJECT IDENTIFIER ::= { adslTraps 2 }
+
+         adslAturPerfLofsThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAturPerfCurr15MinLofs,
+                       adslAturThresh15MinLofs }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Framing 15-minute interval threshold reached."
+         ::= { adslAturTraps 0 1 }
+
+         adslAturPerfLossThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAturPerfCurr15MinLoss,
+                       adslAturThresh15MinLoss }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Signal 15-minute interval threshold reached."
+         ::= { adslAturTraps 0 2 }
+
+         adslAturPerfLprsThreshTrap      NOTIFICATION-TYPE
+             OBJECTS { adslAturPerfCurr15MinLprs,
+                       adslAturThresh15MinLprs }
+             STATUS  current
+             DESCRIPTION
+                 "Loss of Power 15-minute interval threshold reached."
+         ::= { adslAturTraps 0 3 }
+
+         adslAturPerfESsThreshTrap       NOTIFICATION-TYPE
+             OBJECTS { adslAturPerfCurr15MinESs,
+                       adslAturThresh15MinESs }
+             STATUS  current
+             DESCRIPTION
+                 "Errored Second 15-minute interval threshold reached."
+         ::= { adslAturTraps 0 4 }
+
+         adslAturRateChangeTrap  NOTIFICATION-TYPE
+             OBJECTS { adslAturChanCurrTxRate,
+                       adslAturChanPrevTxRate }
+             STATUS  current
+             DESCRIPTION
+                 "The ATURs transmit rate has changed (RADSL mode only)"
+         ::= { adslAturTraps 0 5 }
+
+         -- no adslAturPerfLolsThreshTrap possible { 0 6 }
+
+         -- no adslAturInitFailureTrap possible { 0 7 }
+
+   -- conformance information
+
+   adslConformance OBJECT IDENTIFIER ::= { adslLineMib 3 }
+
+   adslGroups OBJECT IDENTIFIER ::= { adslConformance 1 }
+   adslCompliances OBJECT IDENTIFIER ::= { adslConformance 2 }
+
+         -- ATU-C agent compliance statements
+
+         adslLineMibAtucCompliance MODULE-COMPLIANCE
+             STATUS  current
+             DESCRIPTION
+                 "The compliance statement for SNMP entities
+                  which manage ADSL ATU-C interfaces."
+
+             MODULE  -- this module
+             MANDATORY-GROUPS
+                {
+                adslLineGroup, adslPhysicalGroup, adslChannelGroup,
+                adslAtucPhysPerfIntervalGroup,
+                adslAturPhysPerfIntervalGroup, adslLineConfProfileGroup,
+                adslLineAlarmConfProfileGroup,
+                adslLineConfProfileControlGroup
+                }
+
+             GROUP       adslAtucPhysPerfRawCounterGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require continuous ATU-C physical event counters
+                  should implement this group."
+
+             GROUP       adslAturPhysPerfRawCounterGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require continuous ATU-R physical event counters
+                  should implement this group."
+
+             GROUP       adslAtucChanPerformanceGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require ATU-C channel block event counters should
+                  implement this group."
+             GROUP       adslAturChanPerformanceGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require ATU-R channel block event counters should
+                  implement this group."
+
+             OBJECT      adslLineConfProfile
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable when static
+                  profiles are implemented."
+
+             OBJECT      adslAtucConfRateMode
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfRateChanRatio
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfTargetSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfMaxSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfMinSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfDownshiftSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+             OBJECT      adslAtucConfUpshiftSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfMinUpshiftTime
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucConfMinDownshiftTime
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucChanConfFastMinTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucChanConfInterleaveMinTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucChanConfFastMaxTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucChanConfInterleaveMaxTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucChanConfMaxInterleaveDelay
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfRateMode
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfRateChanRatio
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfTargetSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfMaxSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfMinSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfDownshiftSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfUpshiftSnrMgn
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfMinUpshiftTime
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturConfMinDownshiftTime
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturChanConfFastMinTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturChanConfInterleaveMinTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturChanConfFastMaxTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturChanConfInterleaveMaxTxRate
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturChanConfMaxInterleaveDelay
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslLineConfProfileRowStatus
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable only when static
+                  profiles are implemented."
+
+             OBJECT      adslLineAlarmConfProfile
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable only when static
+                  profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLofs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLoss
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLols
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLprs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinESs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshFastRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshInterleaveRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshFastRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshInterleaveRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucInitFailureTrapEnable
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLofs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLoss
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLprs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinESs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshFastRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshInterleaveRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshFastRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshInterleaveRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslLineAlarmConfProfileRowStatus
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable only when static
+                  profiles are implemented."
+
+         ::= { adslCompliances 1 }
+
+         -- ATU-R agent compliance statements
+
+         adslLineMibAturCompliance MODULE-COMPLIANCE
+             STATUS  current
+             DESCRIPTION
+                 "The compliance statement for SNMP entities
+                  which manage ADSL ATU-R interfaces."
+
+             MODULE  -- this module
+             MANDATORY-GROUPS
+                 {
+                 adslAturLineGroup, adslAturPhysicalGroup,
+                 adslAturChannelGroup,
+                 adslAturAtucPhysPerfIntervalGroup,
+                 adslAturAturPhysPerfIntervalGroup,
+                 adslAturLineAlarmConfProfileGroup,
+                 adslAturLineConfProfileControlGroup
+                 }
+
+             GROUP       adslAturAtucPhysPerfRawCounterGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require continuous ATU-C physical event counters
+                  should implement this group."
+
+             GROUP       adslAturAturPhysPerfRawCounterGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require continuous ATU-R physical event counters
+                  should implement this group."
+
+             GROUP       adslAturAtucChanPerformanceGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require ATU-C channel block event counters should
+                  implement this group."
+
+             GROUP       adslAturAturChanPerformanceGroup
+             DESCRIPTION
+                 "This group is optional.  Implementations which
+                  require ATU-R channel block event counters should
+                  implement this group."
+
+             OBJECT      adslLineAlarmConfProfile
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable only when static
+                  profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLofs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinLoss
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThresh15MinESs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshFastRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshInterleaveRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucThreshFastRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAtucInitFailureTrapEnable
+             MIN-ACCESS  read-write
+
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLofs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLoss
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinLprs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThresh15MinESs
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshFastRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshInterleaveRateUp
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshFastRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslAturThreshInterleaveRateDown
+             MIN-ACCESS  read-write
+             DESCRIPTION
+                 "Read-write access is applicable when
+                  static profiles are implemented."
+
+             OBJECT      adslLineAlarmConfProfileRowStatus
+             MIN-ACCESS  read-only
+             DESCRIPTION
+                 "Read-only access is applicable only when static
+                  profiles are implemented."
+
+             OBJECT     adslAtucCurrStatus
+             SYNTAX   BITS {
+                            noDefect(0),
+                            lossOfFraming(1),
+                            lossOfSignal(2)
+                           }
+             DESCRIPTION
+                 "It is allowable to implement only noDefect(0),
+                 lossOfFraming(1) and lossOfSignal(2) by the ATU-R
+                 agent."
+
+        ::= { adslCompliances 2 }
+
+         -- units of conformance
+         adslLineGroup    OBJECT-GROUP
+             OBJECTS {
+                adslLineCoding, adslLineType, adslLineSpecific
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing configuration
+                 information about an ADSL Line."
+         ::= { adslGroups 1 }
+
+         adslPhysicalGroup    OBJECT-GROUP
+             OBJECTS {
+                adslAtucInvSerialNumber, adslAtucInvVendorID,
+                adslAtucInvVersionNumber, adslAtucCurrSnrMgn,
+                adslAtucCurrAtn, adslAtucCurrStatus,
+                adslAtucCurrOutputPwr, adslAtucCurrAttainableRate,
+                adslAturInvSerialNumber, adslAturInvVendorID,
+                adslAturInvVersionNumber, adslAturCurrSnrMgn,
+                adslAturCurrAtn, adslAturCurrStatus,
+                adslAturCurrOutputPwr, adslAturCurrAttainableRate
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing physical
+                 configuration information of the ADSL Line."
+         ::= { adslGroups 2 }
+
+         adslChannelGroup    OBJECT-GROUP
+             OBJECTS {
+                adslAtucChanInterleaveDelay, adslAtucChanCurrTxRate,
+                adslAtucChanPrevTxRate, adslAtucChanCrcBlockLength,
+                adslAturChanInterleaveDelay, adslAturChanCurrTxRate,
+                adslAturChanPrevTxRate, adslAturChanCrcBlockLength
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing configuration
+                 information about an ADSL channel."
+         ::= { adslGroups 3 }
+
+         adslAtucPhysPerfRawCounterGroup OBJECT-GROUP
+             OBJECTS {
+                adslAtucPerfLofs, adslAtucPerfLoss,
+                adslAtucPerfLols, adslAtucPerfLprs,
+                adslAtucPerfESs, adslAtucPerfInits
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing raw performance
+                 counts on an ADSL Line (ATU-C end)."
+         ::= { adslGroups 4 }
+
+         adslAtucPhysPerfIntervalGroup OBJECT-GROUP
+             OBJECTS {
+                adslAtucPerfValidIntervals,
+                adslAtucPerfInvalidIntervals,
+                adslAtucPerfCurr15MinTimeElapsed,
+                adslAtucPerfCurr15MinLofs, adslAtucPerfCurr15MinLoss,
+                adslAtucPerfCurr15MinLols, adslAtucPerfCurr15MinLprs,
+                adslAtucPerfCurr15MinESs, adslAtucPerfCurr15MinInits,
+                adslAtucPerfCurr1DayLofs, adslAtucPerfCurr1DayLoss,
+                adslAtucPerfCurr1DayLols, adslAtucPerfCurr1DayLprs,
+                adslAtucPerfCurr1DayESs, adslAtucPerfCurr1DayInits,
+                adslAtucPerfPrev1DayMoniSecs,
+                adslAtucPerfPrev1DayLofs, adslAtucPerfPrev1DayLoss,
+                adslAtucPerfPrev1DayLols, adslAtucPerfPrev1DayLprs,
+                adslAtucPerfPrev1DayESs, adslAtucPerfPrev1DayInits,
+                adslAtucIntervalLofs, adslAtucIntervalLoss,
+                adslAtucIntervalLols, adslAtucIntervalLprs,
+                adslAtucIntervalESs, adslAtucIntervalInits,
+                adslAtucIntervalValidData
+                }
+
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing current 15-minute,
+                 1-day; and previous 1-day performance counts on
+                 ADSL Line (ATU-C end) ."
+         ::= { adslGroups 5 }
+
+         adslAturPhysPerfRawCounterGroup OBJECT-GROUP
+             OBJECTS {
+                adslAturPerfLofs, adslAturPerfLoss,
+                adslAturPerfLprs, adslAturPerfESs
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing raw performance
+                 counts on an ADSL Line (ATU-R end)."
+         ::= { adslGroups 6 }
+
+         adslAturPhysPerfIntervalGroup OBJECT-GROUP
+             OBJECTS {
+                adslAturPerfValidIntervals,
+                adslAturPerfInvalidIntervals,
+                adslAturPerfCurr15MinTimeElapsed,
+                adslAturPerfCurr15MinLofs, adslAturPerfCurr15MinLoss,
+                adslAturPerfCurr15MinLprs, adslAturPerfCurr15MinESs,
+                adslAturPerfCurr1DayTimeElapsed,
+                adslAturPerfCurr1DayLofs, adslAturPerfCurr1DayLoss,
+                adslAturPerfCurr1DayLprs, adslAturPerfCurr1DayESs,
+                adslAturPerfPrev1DayMoniSecs,
+                adslAturPerfPrev1DayLofs, adslAturPerfPrev1DayLoss,
+                adslAturPerfPrev1DayLprs, adslAturPerfPrev1DayESs,
+                adslAturIntervalLofs,
+                adslAturIntervalLoss, adslAturIntervalLprs,
+                adslAturIntervalESs, adslAturIntervalValidData
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing current 15-minute,
+                 1-day; and previous 1-day performance counts on
+                 ADSL Line (ATU-R end)."
+         ::= { adslGroups 7 }
+
+         adslAtucChanPerformanceGroup OBJECT-GROUP
+             OBJECTS {
+                adslAtucChanReceivedBlks,
+                adslAtucChanTransmittedBlks,
+                adslAtucChanCorrectedBlks,
+                adslAtucChanUncorrectBlks,
+                adslAtucChanPerfValidIntervals,
+                adslAtucChanPerfInvalidIntervals,
+                adslAtucChanPerfCurr15MinTimeElapsed,
+                adslAtucChanPerfCurr15MinReceivedBlks,
+                adslAtucChanPerfCurr15MinTransmittedBlks,
+                adslAtucChanPerfCurr15MinCorrectedBlks,
+                adslAtucChanPerfCurr15MinUncorrectBlks,
+                adslAtucChanPerfCurr1DayTimeElapsed,
+                adslAtucChanPerfCurr1DayReceivedBlks,
+                adslAtucChanPerfCurr1DayTransmittedBlks,
+                adslAtucChanPerfCurr1DayCorrectedBlks,
+                adslAtucChanPerfCurr1DayUncorrectBlks,
+                adslAtucChanPerfPrev1DayMoniSecs,
+                adslAtucChanPerfPrev1DayReceivedBlks,
+                adslAtucChanPerfPrev1DayTransmittedBlks,
+                adslAtucChanPerfPrev1DayCorrectedBlks,
+                adslAtucChanPerfPrev1DayUncorrectBlks,
+                adslAtucChanIntervalReceivedBlks,
+                adslAtucChanIntervalTransmittedBlks,
+                adslAtucChanIntervalCorrectedBlks,
+                adslAtucChanIntervalUncorrectBlks,
+                adslAtucChanIntervalValidData
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing channel block
+                 performance information on an ADSL channel
+                 (ATU-C end)."
+         ::= { adslGroups 8 }
+
+         adslAturChanPerformanceGroup OBJECT-GROUP
+             OBJECTS {
+                adslAturChanReceivedBlks,
+                adslAturChanTransmittedBlks,
+                adslAturChanCorrectedBlks,
+                adslAturChanUncorrectBlks,
+                adslAturChanPerfValidIntervals,
+                adslAturChanPerfInvalidIntervals,
+                adslAturChanPerfCurr15MinTimeElapsed,
+                adslAturChanPerfCurr15MinReceivedBlks,
+                adslAturChanPerfCurr15MinTransmittedBlks,
+                adslAturChanPerfCurr15MinCorrectedBlks,
+                adslAturChanPerfCurr15MinUncorrectBlks,
+                adslAturChanPerfCurr1DayTimeElapsed,
+                adslAturChanPerfCurr1DayReceivedBlks,
+                adslAturChanPerfCurr1DayTransmittedBlks,
+                adslAturChanPerfCurr1DayCorrectedBlks,
+                adslAturChanPerfCurr1DayUncorrectBlks,
+                adslAturChanPerfPrev1DayMoniSecs,
+                adslAturChanPerfPrev1DayReceivedBlks,
+                adslAturChanPerfPrev1DayTransmittedBlks,
+                adslAturChanPerfPrev1DayCorrectedBlks,
+                adslAturChanPerfPrev1DayUncorrectBlks,
+                adslAturChanIntervalReceivedBlks,
+                adslAturChanIntervalTransmittedBlks,
+                adslAturChanIntervalCorrectedBlks,
+                adslAturChanIntervalUncorrectBlks,
+                adslAturChanIntervalValidData
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing channel block
+                 performance information on an ADSL channel
+                 (ATU-C end)."
+         ::= { adslGroups 9 }
+
+         adslLineConfProfileGroup OBJECT-GROUP
+             OBJECTS {
+                adslAtucConfRateMode, adslAtucConfRateChanRatio,
+                adslAtucConfTargetSnrMgn, adslAtucConfMaxSnrMgn,
+                adslAtucConfMinSnrMgn,
+                adslAtucConfDownshiftSnrMgn,
+                adslAtucConfUpshiftSnrMgn,
+                adslAtucConfMinUpshiftTime,
+                adslAtucConfMinDownshiftTime,
+                adslAtucChanConfFastMinTxRate,
+                adslAtucChanConfInterleaveMinTxRate,
+                adslAtucChanConfFastMaxTxRate,
+                adslAtucChanConfInterleaveMaxTxRate,
+                adslAtucChanConfMaxInterleaveDelay,
+                adslAturConfRateMode, adslAturConfRateChanRatio,
+                adslAturConfTargetSnrMgn, adslAturConfMaxSnrMgn,
+                adslAturConfMinSnrMgn, adslAturConfDownshiftSnrMgn,
+                adslAturConfUpshiftSnrMgn,
+                adslAturConfMinUpshiftTime,
+                adslAturConfMinDownshiftTime,
+                adslAturChanConfFastMinTxRate,
+                adslAturChanConfInterleaveMinTxRate,
+                adslAturChanConfFastMaxTxRate,
+                adslAturChanConfInterleaveMaxTxRate,
+                adslAturChanConfMaxInterleaveDelay
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing provisioning
+                 information about an ADSL Line."
+         ::= { adslGroups 10 }
+
+         adslLineAlarmConfProfileGroup OBJECT-GROUP
+             OBJECTS {
+                adslAtucThresh15MinLofs, adslAtucThresh15MinLoss,
+                adslAtucThresh15MinLols, adslAtucThresh15MinLprs,
+                adslAtucThresh15MinESs, adslAtucThreshFastRateUp,
+                adslAtucThreshInterleaveRateUp,
+                adslAtucThreshFastRateDown,
+                adslAtucThreshInterleaveRateDown,
+                adslAtucInitFailureTrapEnable,
+                adslAturThresh15MinLofs, adslAturThresh15MinLoss,
+                adslAturThresh15MinLprs, adslAturThresh15MinESs,
+                adslAturThreshFastRateUp,
+                adslAturThreshInterleaveRateUp,
+                adslAturThreshFastRateDown,
+                adslAturThreshInterleaveRateDown
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing alarm provisioning
+                 information about an ADSL Line."
+         ::= { adslGroups 11 }
+
+         adslLineConfProfileControlGroup OBJECT-GROUP
+             OBJECTS {
+                adslLineConfProfile, adslLineAlarmConfProfile,
+                adslLineConfProfileRowStatus,
+                adslLineAlarmConfProfileRowStatus
+                }
+             STATUS     current
+             DESCRIPTION
+                 "A collection of objects providing profile
+                 control for the ADSL system."
+         ::= { adslGroups 12 }
+         adslNotificationsGroup NOTIFICATION-GROUP
+             NOTIFICATIONS {
+                adslAtucPerfLofsThreshTrap,
+                adslAtucPerfLossThreshTrap,
+                adslAtucPerfLprsThreshTrap,
+                adslAtucPerfESsThreshTrap,
+                adslAtucRateChangeTrap,
+                adslAtucPerfLolsThreshTrap,
+                adslAtucInitFailureTrap,
+                adslAturPerfLofsThreshTrap,
+                adslAturPerfLossThreshTrap,
+                adslAturPerfLprsThreshTrap,
+                adslAturPerfESsThreshTrap,
+                adslAturRateChangeTrap
+                }
+             STATUS        current
+             DESCRIPTION
+                 "The collection of adsl notifications."
+         ::= { adslGroups 13 }
+
+   -- units of conformance for ATU-R agent
+
+            adslAturLineGroup    OBJECT-GROUP
+                OBJECTS {
+                   adslLineCoding
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing configuration
+                    information about an ADSL Line on the ATU-R side."
+            ::= { adslGroups 14 }
+
+            adslAturPhysicalGroup    OBJECT-GROUP
+                OBJECTS {
+                   adslAtucInvVendorID,
+                   adslAtucInvVersionNumber,
+                   adslAtucCurrOutputPwr, adslAtucCurrAttainableRate,
+                   adslAturInvSerialNumber, adslAturInvVendorID,
+                   adslAturInvVersionNumber, adslAturCurrSnrMgn,
+                   adslAturCurrAtn, adslAturCurrStatus,
+                   adslAturCurrOutputPwr, adslAturCurrAttainableRate,
+                   adslAtucCurrStatus
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing physical
+                    configuration information of the ADSL Line on the
+                    ATU-R side."
+            ::= { adslGroups 15 }
+
+            adslAturChannelGroup    OBJECT-GROUP
+                OBJECTS {
+                   adslAtucChanInterleaveDelay, adslAtucChanCurrTxRate,
+                   adslAtucChanPrevTxRate,
+                   adslAturChanInterleaveDelay, adslAturChanCurrTxRate,
+                   adslAturChanPrevTxRate, adslAturChanCrcBlockLength
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing configuration
+                   information about an ADSL channel on the ATU-R
+                   side."
+            ::= { adslGroups 16 }
+
+            adslAturAtucPhysPerfRawCounterGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAtucPerfLofs, adslAtucPerfLoss,
+                   adslAtucPerfESs, adslAtucPerfInits
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing raw performance
+                   counts on an ADSL Line (ATU-C end) provided by the
+                   ATU-R agent."
+            ::= { adslGroups 17 }
+
+            adslAturAtucPhysPerfIntervalGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAtucPerfValidIntervals,
+                   adslAtucPerfInvalidIntervals,
+                   adslAtucPerfCurr15MinTimeElapsed,
+                   adslAtucPerfCurr15MinLofs, adslAtucPerfCurr15MinLoss,
+                   adslAtucPerfCurr15MinESs, adslAtucPerfCurr15MinInits,
+                   adslAtucPerfCurr1DayTimeElapsed,
+                   adslAtucPerfCurr1DayLofs, adslAtucPerfCurr1DayLoss,
+                   adslAtucPerfCurr1DayESs, adslAtucPerfCurr1DayInits,
+                   adslAtucPerfPrev1DayMoniSecs,
+                   adslAtucPerfPrev1DayLofs, adslAtucPerfPrev1DayLoss,
+                   adslAtucPerfPrev1DayESs, adslAtucPerfPrev1DayInits,
+                   adslAtucIntervalLofs, adslAtucIntervalLoss,
+                   adslAtucIntervalESs, adslAtucIntervalInits,
+                   adslAtucIntervalValidData
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing current
+                   15-minute, 1-day; and previous 1-day performance
+                   counts on ADSL Line (ATU-C end) provided by the
+                   ATU-R agent."
+            ::= { adslGroups 18 }
+
+            adslAturAturPhysPerfRawCounterGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAturPerfLofs, adslAturPerfLoss,
+                   adslAturPerfLprs, adslAturPerfESs
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing raw performance
+                   counts on an ADSL Line (ATU-R end) provided by the
+                   ATU-R agent."
+            ::= { adslGroups 19 }
+
+            adslAturAturPhysPerfIntervalGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAturPerfValidIntervals,
+                   adslAturPerfInvalidIntervals,
+                   adslAturPerfCurr15MinTimeElapsed,
+                   adslAturPerfCurr15MinLofs, adslAturPerfCurr15MinLoss,
+                   adslAturPerfCurr15MinLprs, adslAturPerfCurr15MinESs,
+                   adslAturPerfCurr1DayTimeElapsed,
+                   adslAturPerfCurr1DayLofs, adslAturPerfCurr1DayLoss,
+                   adslAturPerfCurr1DayLprs, adslAturPerfCurr1DayESs,
+                   adslAturPerfPrev1DayMoniSecs,
+                   adslAturPerfPrev1DayLofs, adslAturPerfPrev1DayLoss,
+                   adslAturPerfPrev1DayLprs, adslAturPerfPrev1DayESs,
+                   adslAturIntervalLofs,
+                   adslAturIntervalLoss, adslAturIntervalLprs,
+                   adslAturIntervalESs, adslAturIntervalValidData
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing current
+                   15-minute, 1-day; and previous 1-day performance
+                   counts on ADSL Line (ATU-R end) provided by the
+                   ATU-R agent."
+            ::= { adslGroups 20 }
+
+            adslAturAtucChanPerformanceGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAtucChanReceivedBlks,
+                   adslAtucChanTransmittedBlks,
+                   adslAtucChanCorrectedBlks,
+                   adslAtucChanUncorrectBlks,
+                   adslAtucChanPerfCurr15MinTimeElapsed,
+                   adslAtucChanPerfCurr15MinReceivedBlks,
+                   adslAtucChanPerfCurr15MinTransmittedBlks,
+                   adslAtucChanPerfCurr15MinCorrectedBlks,
+                   adslAtucChanPerfCurr15MinUncorrectBlks,
+                   adslAtucChanPerfCurr1DayTimeElapsed,
+                   adslAtucChanPerfCurr1DayReceivedBlks,
+                   adslAtucChanPerfCurr1DayTransmittedBlks,
+                   adslAtucChanPerfCurr1DayCorrectedBlks,
+                   adslAtucChanPerfCurr1DayUncorrectBlks,
+                   adslAtucChanPerfPrev1DayMoniSecs,
+                   adslAtucChanPerfPrev1DayReceivedBlks,
+                   adslAtucChanPerfPrev1DayTransmittedBlks,
+                   adslAtucChanPerfPrev1DayCorrectedBlks,
+                   adslAtucChanPerfPrev1DayUncorrectBlks,
+                   adslAtucChanPerfValidIntervals,
+                   adslAtucChanPerfInvalidIntervals,
+                   adslAtucChanIntervalReceivedBlks,
+                   adslAtucChanIntervalTransmittedBlks,
+                   adslAtucChanIntervalCorrectedBlks,
+                   adslAtucChanIntervalUncorrectBlks,
+                   adslAtucChanIntervalValidData
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing channel block
+                    performance information on an ADSL channel
+                    (ATU-C end) provided by the ATU-R agent."
+            ::= { adslGroups 21 }
+
+            adslAturAturChanPerformanceGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAturChanReceivedBlks,
+                   adslAturChanTransmittedBlks,
+                   adslAturChanCorrectedBlks,
+                   adslAturChanUncorrectBlks,
+                   adslAturChanPerfValidIntervals,
+                   adslAturChanPerfInvalidIntervals,
+                   adslAturChanPerfCurr15MinTimeElapsed,
+                   adslAturChanPerfCurr15MinReceivedBlks,
+                   adslAturChanPerfCurr15MinTransmittedBlks,
+                   adslAturChanPerfCurr15MinCorrectedBlks,
+                   adslAturChanPerfCurr15MinUncorrectBlks,
+                   adslAturChanPerfCurr1DayTimeElapsed,
+                   adslAturChanPerfCurr1DayReceivedBlks,
+                   adslAturChanPerfCurr1DayTransmittedBlks,
+                   adslAturChanPerfCurr1DayCorrectedBlks,
+                   adslAturChanPerfCurr1DayUncorrectBlks,
+                   adslAturChanPerfPrev1DayMoniSecs,
+                   adslAturChanPerfPrev1DayReceivedBlks,
+                   adslAturChanPerfPrev1DayTransmittedBlks,
+                   adslAturChanPerfPrev1DayCorrectedBlks,
+                   adslAturChanPerfPrev1DayUncorrectBlks,
+                   adslAturChanIntervalReceivedBlks,
+                   adslAturChanIntervalTransmittedBlks,
+                   adslAturChanIntervalCorrectedBlks,
+                   adslAturChanIntervalUncorrectBlks,
+                   adslAturChanIntervalValidData
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing channel block
+                    performance information on an ADSL channel
+                    (ATU-R end) provided by the ATU-R agent."
+            ::= { adslGroups 22 }
+
+            adslAturLineAlarmConfProfileGroup OBJECT-GROUP
+                OBJECTS {
+                   adslAtucThresh15MinLofs, adslAtucThresh15MinLoss,
+                   adslAtucThresh15MinESs, adslAtucThreshFastRateUp,
+                   adslAtucThreshInterleaveRateUp,
+                   adslAtucThreshFastRateDown,
+                   adslAtucThreshInterleaveRateDown,
+                   adslAtucInitFailureTrapEnable,
+                   adslAturThresh15MinLofs, adslAturThresh15MinLoss,
+                   adslAturThresh15MinLprs, adslAturThresh15MinESs,
+                   adslAturThreshFastRateUp,
+                   adslAturThreshInterleaveRateUp,
+                   adslAturThreshFastRateDown,
+                   adslAturThreshInterleaveRateDown
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing alarm provisioning
+                    information about an ADSL Line provided by the
+                    ATU-R agent."
+            ::= { adslGroups 23 }
+
+            adslAturLineConfProfileControlGroup OBJECT-GROUP
+                OBJECTS {
+                   adslLineAlarmConfProfile,
+                   adslLineAlarmConfProfileRowStatus
+                   }
+                STATUS     current
+                DESCRIPTION
+                    "A collection of objects providing profile
+                    control for the ADSL system by the ATU-R agent."
+            ::= { adslGroups 24 }
+
+            adslAturNotificationsGroup NOTIFICATION-GROUP
+                NOTIFICATIONS {
+                    adslAtucPerfLofsThreshTrap,
+                    adslAtucPerfLossThreshTrap,
+                    adslAtucPerfESsThreshTrap,
+                    adslAtucRateChangeTrap,
+                    adslAturPerfLofsThreshTrap,
+                    adslAturPerfLossThreshTrap,
+                    adslAturPerfLprsThreshTrap,
+                    adslAturPerfESsThreshTrap,
+                    adslAturRateChangeTrap
+                    }
+                STATUS        current
+                DESCRIPTION
+                    "The collection of ADSL notifications implemented by
+                    the ATU-R agent."
+            ::= { adslGroups 25 }
+
+   END
diff -Naur net-snmp-5.1/mibs/ADSL-TC-MIB.txt open_snmp/mibs/ADSL-TC-MIB.txt
--- net-snmp-5.1/mibs/ADSL-TC-MIB.txt	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/mibs/ADSL-TC-MIB.txt	2009-12-16 13:01:10.000000000 +0530
@@ -0,0 +1,113 @@
+ADSL-TC-MIB DEFINITIONS ::= BEGIN
+
+IMPORTS
+    transmission,
+    MODULE-IDENTITY, Gauge32            FROM SNMPv2-SMI
+    TEXTUAL-CONVENTION                  FROM SNMPv2-TC;
+
+adsltcmib MODULE-IDENTITY
+   LAST-UPDATED "9908190000Z"
+   ORGANIZATION "IETF ADSL MIB Working Group"
+   CONTACT-INFO
+       "
+       Gregory Bathrick
+       AG Communication Systems
+       A Subsidiary of Lucent Technologies
+       2500 W Utopia Rd.
+       Phoenix, AZ 85027 USA
+       Tel: +1 602-582-7679
+       Fax: +1 602-582-7697
+       E-mail: bathricg@agcs.com
+
+       Faye Ly
+       Copper Mountain Networks
+       Norcal Office
+       2470 Embarcadero Way
+       Palo Alto, CA 94303
+       Tel: +1 650-858-8500
+       Fax: +1 650-858-8085
+       E-Mail: faye@coppermountain.com
+
+
+       IETF ADSL MIB Working Group (adsl@xlist.agcs.com)
+       "
+       DESCRIPTION
+           "The MIB module which provides a ADSL
+           Line Coding Textual Convention to be used
+           by ADSL Lines."
+
+       --  Revision history
+       REVISION     "9908190000Z"  -- 19 August 1999, midnight
+       DESCRIPTION  "Initial Version, published as RFC 2662"
+
+       ::= { transmission 94 2 } -- adslMIB 2
+
+       AdslLineCodingType ::= TEXTUAL-CONVENTION
+           STATUS       current
+           DESCRIPTION
+               "This data type is used as the syntax for the ADSL
+               Line Code."
+           SYNTAX  INTEGER {
+               other(1),-- none of the following
+               dmt (2), -- Discrete MultiTone
+               cap (3), -- Carrierless Amplitude & Phase modulation
+               qam (4)  -- Quadrature Amplitude Modulation
+           }
+
+       AdslPerfCurrDayCount ::= TEXTUAL-CONVENTION
+           STATUS  current
+           DESCRIPTION
+               "A counter associated with interface performance
+               measurements in a current 1-day (24 hour) measurement
+               interval.
+
+               The value of this counter starts at zero at the
+               beginning of an interval and is increased when
+               associated events occur, until the end of the
+               1-day interval.  At that time the value of the
+               counter is stored in the previous 1-day history
+               interval, if available, and the current interval
+               counter is restarted at zero.
+
+               In the case where the agent has no valid data available
+               for this interval the corresponding object
+               instance is not available and upon a retrieval
+               request a corresponding error message shall be
+               returned to indicate that this instance does
+               not exist (for example, a noSuchName error for
+               SNMPv1 and a noSuchInstance for SNMPv2 GET
+               operation)."
+            SYNTAX  Gauge32
+
+       AdslPerfPrevDayCount ::= TEXTUAL-CONVENTION
+           STATUS  current
+           DESCRIPTION
+               "A counter associated with interface performance
+               measurements during the most previous 1-day (24 hour)
+               measurement interval.  The value of this counter is
+               equal to the value of the current day counter at
+               the end of its most recent interval.
+
+               In the case where the agent has no valid data available
+               for this interval the corresponding object
+               instance is not available and upon a retrieval
+               request a corresponding error message shall be
+               returned to indicate that this instance does
+               not exist (for example, a noSuchName error for
+               SNMPv1 and a noSuchInstance for SNMPv2 GET
+               operation)."
+           SYNTAX  Gauge32
+
+       AdslPerfTimeElapsed ::= TEXTUAL-CONVENTION
+           STATUS current
+           DESCRIPTION
+               "The number of seconds that have elapsed since
+               the beginning of the current measurement period.
+               If, for some reason, such as an adjustment in the
+               system's time-of-day clock, the current interval
+               exceeds the maximum value, the agent will return
+               the maximum value."
+           SYNTAX  Gauge32
+
+END
+
diff -Naur net-snmp-5.1/snmplib/container.c open_snmp/snmplib/container.c
--- net-snmp-5.1/snmplib/container.c	2003-10-23 21:22:23.000000000 +0530
+++ open_snmp/snmplib/container.c	2009-12-16 13:01:36.000000000 +0530
@@ -53,8 +53,9 @@
      */
     netsnmp_container_binary_array_init();
     netsnmp_container_ssll_init();
+#ifdef SUBBI
     netsnmp_container_null_init();
-
+#endif
     /*
      * default aliases for some containers
      */
diff -Naur net-snmp-5.1/snmplib/container_null.c open_snmp/snmplib/container_null.c
--- net-snmp-5.1/snmplib/container_null.c	2003-10-24 04:24:08.000000000 +0530
+++ open_snmp/snmplib/container_null.c	2009-12-16 13:01:36.000000000 +0530
@@ -5,7 +5,7 @@
  * see comments in header file.
  *
  */
-
+#ifdef SUBBI
 #include <net-snmp/net-snmp-config.h>
 
 #if HAVE_IO_H
@@ -172,3 +172,4 @@
     netsnmp_container_register("null",
                                netsnmp_container_get_null_factory());
 }
+#endif
diff -Naur net-snmp-5.1/snmplib/keytools.c open_snmp/snmplib/keytools.c
--- net-snmp-5.1/snmplib/keytools.c	2002-08-10 04:58:48.000000000 +0530
+++ open_snmp/snmplib/keytools.c	2009-12-16 13:01:37.000000000 +0530
@@ -1,9 +1,9 @@
 /*
  * keytools.c
  */
-
 #include <net-snmp/net-snmp-config.h>
 
+#ifdef SNMP_SECMOD_USM
 #include <stdio.h>
 #include <sys/types.h>
 #if HAVE_WINSOCK_H
@@ -529,3 +529,4 @@
 #else
 _KEYTOOLS_NOT_AVAILABLE
 #endif                          /* internal or openssl */
+#endif /* SNMP_SECMOD_USM */
diff -Naur net-snmp-5.1/snmplib/lcd_time.c open_snmp/snmplib/lcd_time.c
--- net-snmp-5.1/snmplib/lcd_time.c	2003-07-03 01:50:56.000000000 +0530
+++ open_snmp/snmplib/lcd_time.c	2009-12-16 13:01:37.000000000 +0530
@@ -4,9 +4,9 @@
  * XXX  Should etimelist entries with <0,0> time tuples be timed out?
  * XXX  Need a routine to free the memory?  (Perhaps at shutdown?)
  */
-
 #include <net-snmp/net-snmp-config.h>
 
+#ifdef SNMP_SECMOD_USM
 #include <sys/types.h>
 #if HAVE_WINSOCK_H
 #include <winsock.h>
@@ -561,3 +561,4 @@
 
 }                               /* end dump_etimelist() */
 #endif                          /* SNMP_TESTING_CODE */
+#endif /* SNMP_SECMOD_USM */
diff -Naur net-snmp-5.1/snmplib/scapi.c open_snmp/snmplib/scapi.c
--- net-snmp-5.1/snmplib/scapi.c	2003-06-23 01:12:19.000000000 +0530
+++ open_snmp/snmplib/scapi.c	2009-12-16 13:01:38.000000000 +0530
@@ -5,6 +5,7 @@
 
 #include <net-snmp/net-snmp-config.h>
 
+#ifdef SNMP_SECMOD_USM
 #include <sys/types.h>
 #if HAVE_WINSOCK_H
 #include <winsock.h>
@@ -873,3 +874,4 @@
 #endif                          /*  */
 }
 #endif                          /* USE_OPENSSL */
+#endif /* SNMP_SECMOD_USM */
diff -Naur net-snmp-5.1/snmplib/snmpEOCDomain.c open_snmp/snmplib/snmpEOCDomain.c
--- net-snmp-5.1/snmplib/snmpEOCDomain.c	1970-01-01 05:30:00.000000000 +0530
+++ open_snmp/snmplib/snmpEOCDomain.c	2009-12-16 13:01:39.000000000 +0530
@@ -0,0 +1,358 @@
+#include <net-snmp/net-snmp-config.h>
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <errno.h>
+
+#if HAVE_STRING_H
+#include <string.h>
+#else
+#include <strings.h>
+#endif
+#if HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#include "atm.h"
+
+#if HAVE_DMALLOC_H
+#include <dmalloc.h>
+#endif
+
+#include <net-snmp/types.h>
+#include <net-snmp/output_api.h>
+#include <net-snmp/config_api.h>
+
+#include <net-snmp/library/snmp_transport.h>
+#include <net-snmp/library/snmpEOCDomain.h>
+
+
+oid netsnmp_EOCDomain[10] = { ENTERPRISE_MIB, 3, 3, 6 };
+static netsnmp_tdomain eocDomain;
+
+
+/*
+ * Return a string representing the address in data, or else the "far end"
+ * address if data is NULL.  
+ */
+
+static char *
+netsnmp_eoc_fmtaddr(netsnmp_transport *t, void *data, int len)
+{
+    struct sockaddr_atmpvc *to = NULL;
+
+    if (data != NULL && len == sizeof(struct sockaddr_atmpvc)) {
+        to = (struct sockaddr_atmpvc *) data;
+    } else if (t != NULL && t->data != NULL &&
+               t->data_length == sizeof(struct sockaddr_atmpvc)) {
+        to = (struct sockaddr_atmpvc *) t->data;
+    }
+    if (to == NULL) {
+        return strdup("eoc: unknown");
+    } else {
+        char tmp[64];
+        sprintf(tmp, "eoc: %hd.%hd.%d", to->sap_addr.itf,
+                to->sap_addr.vpi, to->sap_addr.vci);
+        return strdup(tmp);
+    }
+}
+
+
+
+/*
+ *  This finction will be called by snmp to wait for eoc message over eoc 
+ *  channel. It is set in f_recv func pointer of transport structure while 
+ *  opening the EOC channel 
+ */
+
+static int
+netsnmp_eoc_recv(netsnmp_transport *t, void *buf, int size,
+		     void **opaque, int *olength)
+{
+    int rc = -1;
+
+    if (t != NULL && t->sock >= 0) {
+	while (rc < 0) {
+	    rc = recv(t->sock, buf, size, 0);
+	    if (rc < 0 && errno != EINTR) {
+		break;
+	    }
+	}
+
+        if (rc >= 0) {
+            char *string = netsnmp_eoc_fmtaddr(t, NULL, 0);
+            DEBUGMSGTL(("netsnmp_eoc",
+			"recv on fd %d got %d bytes (from %s)\n", t->sock,
+                        rc, string));
+            free(string);
+        } else {
+            DEBUGMSGTL(("netsnmp_eoc", "recv on fd %d err %d (\"%s\")\n", 
+			t->sock, errno, strerror(errno)));
+        }
+        *opaque = NULL;
+        *olength = 0;
+    }
+    return rc;
+}
+
+
+/* This finction will be called by snmp to send eoc message over eoc channel. It
+ * is set to f_send func pointer of transport structure while opening the EOC 
+ * channel 
+ */
+
+
+static int
+netsnmp_eoc_send(netsnmp_transport *t, void *buf, int size,
+                  void **opaque, int *olength)
+{
+    int rc = -1;
+    struct sockaddr *to = NULL;
+
+    if (opaque != NULL && *opaque != NULL &&
+        *olength == sizeof(struct sockaddr_atmpvc)) {
+        to = (struct sockaddr *) (*opaque);
+    } else if (t != NULL && t->data != NULL &&
+               t->data_length == sizeof(struct sockaddr_atmpvc)) {
+        to = (struct sockaddr *) (t->data);
+    }
+
+    if (to != NULL && t != NULL && t->sock >= 0) {
+        char *string = netsnmp_eoc_fmtaddr(NULL, (void *)to,
+					    sizeof(struct sockaddr_atmpvc));
+        DEBUGMSGTL(("netsnmp_eoc","send %d bytes from %p to %s on fd %d\n",
+		    size, buf, string, t->sock));
+        free(string);
+	while (rc < 0) {
+	    rc = send(t->sock, buf, size, 0);
+	    if (rc < 0 && errno != EINTR) {
+		break;
+	    }
+	}
+    }
+    return rc;
+}
+
+
+/* This finction will be called by snmp to close eoc channel */
+
+static int
+netsnmp_eoc_close(netsnmp_transport *t)
+{
+    int rc = -1;
+
+    if (t->sock >= 0) {
+        DEBUGMSGTL(("netsnmp_eoc", "close fd %d\n", t->sock));
+#ifndef HAVE_CLOSESOCKET
+        rc = close(t->sock);
+#else
+        rc = closesocket(t->sock);
+#endif
+        t->sock = -1;
+    }
+    return rc;
+}
+
+
+
+/*
+ * Open an eocC transport for SNMP.  Local is TRUE if addr is the local 
+ * NSAP to bind to (i.e. this is a server-type session); otherwise addr is 
+ * the remote NSAP to send things to.  
+ */
+
+netsnmp_transport *
+netsnmp_eoc_transport(struct sockaddr_atmpvc *addr, int local)
+{
+    char           *string = NULL;
+    struct atm_qos  qos;
+    netsnmp_transport *t = NULL;
+
+    if (addr == NULL || addr->sap_family != AF_ATMPVC) {
+        return NULL;
+    }
+
+    t = (netsnmp_transport *) malloc(sizeof(netsnmp_transport));
+    if (t == NULL) {
+        return NULL;
+    }
+
+    string = netsnmp_eoc_fmtaddr(NULL, (void *) addr,
+                                  sizeof(struct sockaddr_atmpvc));
+    DEBUGMSGTL(("netsnmp_eoc", "open %s %s\n", local ? "local" : "remote",
+                string));
+    free(string);
+
+    memset(t, 0, sizeof(netsnmp_transport));
+
+    t->domain = netsnmp_EOCDomain;
+    t->domain_length =
+        sizeof(netsnmp_EOCDomain) / sizeof(netsnmp_EOCDomain[0]);
+
+    t->sock = socket(PF_ATMPVC, SOCK_DGRAM, 0);
+    if (t->sock < 0) {
+        DEBUGMSGTL(("netsnmp_eoc","socket failed (%s)\n",strerror(errno)));
+        netsnmp_transport_free(t);
+        return NULL;
+    }
+    DEBUGMSGTL(("netsnmp_eoc", "fd %d opened\n", t->sock));
+
+    /*
+     * Set up the QOS parameters.  
+     */
+
+    memset(&qos, 0, sizeof(struct atm_qos));
+    qos.aal = ATM_AAL5;
+    qos.rxtp.traffic_class = ATM_UBR;
+    qos.rxtp.max_sdu = SNMP_MAX_LEN;    /*  Hmm -- this is a bit small?  */
+    qos.txtp = qos.rxtp;
+
+    if (setsockopt(t->sock, SOL_ATM, SO_ATMQOS, &qos, sizeof(qos)) < 0) {
+        DEBUGMSGTL(("netsnmp_eoc", "setsockopt failed (%s)\n",
+                    strerror(errno)));
+        netsnmp_eoc_close(t);
+        netsnmp_transport_free(t);
+        return NULL;
+    }
+
+    if (local) {
+        t->local = malloc(8);
+        if (t->local == NULL) {
+            netsnmp_transport_free(t);
+            return NULL;
+        }
+        t->local[0] = (addr->sap_addr.itf & 0xff00) >> 8;
+        t->local[1] = (addr->sap_addr.itf & 0x00ff) >> 0;
+        t->local[2] = (addr->sap_addr.vpi & 0xff00) >> 8;
+        t->local[3] = (addr->sap_addr.vpi & 0x00ff) >> 0;
+        t->local[4] = (addr->sap_addr.vci & 0xff000000) >> 24;
+        t->local[5] = (addr->sap_addr.vci & 0x00ff0000) >> 16;
+        t->local[6] = (addr->sap_addr.vci & 0x0000ff00) >> 8;
+        t->local[7] = (addr->sap_addr.vci & 0x000000ff) >> 0;
+        t->local_length = 8;
+
+        if (bind(t->sock, (struct sockaddr *) addr,
+                 sizeof(struct sockaddr_atmpvc)) < 0) {
+            DEBUGMSGTL(("netsnmp_eoc", "bind failed (%s)\n",
+                        strerror(errno)));
+            netsnmp_eoc_close(t);
+            netsnmp_transport_free(t);
+            return NULL;
+        }
+    } else {
+        t->remote = malloc(8);
+        if (t->remote == NULL) {
+            netsnmp_transport_free(t);
+            return NULL;
+        }
+        t->remote[0] = (addr->sap_addr.itf & 0xff00) >> 8;
+        t->remote[1] = (addr->sap_addr.itf & 0x00ff) >> 0;
+        t->remote[2] = (addr->sap_addr.vpi & 0xff00) >> 8;
+        t->remote[3] = (addr->sap_addr.vpi & 0x00ff) >> 0;
+        t->remote[4] = (addr->sap_addr.vci & 0xff000000) >> 24;
+        t->remote[5] = (addr->sap_addr.vci & 0x00ff0000) >> 16;
+        t->remote[6] = (addr->sap_addr.vci & 0x0000ff00) >> 8;
+        t->remote[7] = (addr->sap_addr.vci & 0x000000ff) >> 0;
+        t->remote_length = 8;
+
+        if (connect(t->sock, (struct sockaddr *) addr,
+                    sizeof(struct sockaddr_atmpvc)) < 0) {
+            DEBUGMSGTL(("netsnmp_eoc", "connect failed (%s)\n",
+                        strerror(errno)));
+            netsnmp_eoc_close(t);
+            netsnmp_transport_free(t);
+            return NULL;
+        }
+    }
+
+    t->data = malloc(sizeof(struct sockaddr_atmpvc));
+    if (t->data == NULL) {
+        netsnmp_transport_free(t);
+        return NULL;
+    }
+    memcpy(t->data, addr, sizeof(struct sockaddr_atmpvc));
+    t->data_length = sizeof(struct sockaddr_atmpvc);
+
+    /*
+     * 16-bit length field in the trailer, no headers.  
+     */
+
+    t->msgMaxSize = 0xffff;
+    t->f_recv     = netsnmp_eoc_recv;
+    t->f_send     = netsnmp_eoc_send;
+    t->f_close    = netsnmp_eoc_close;
+    t->f_accept   = NULL;
+    t->f_fmtaddr  = netsnmp_eoc_fmtaddr;
+
+    return t;
+}
+
+
+
+netsnmp_transport *
+netsnmp_eoc_create_tstring(const char *string, int local)
+{
+    struct sockaddr_atmpvc addr;
+
+    if (string != NULL) {
+        addr.sap_family = AF_ATMPVC;
+
+        if (sscanf(string, "%hd.%hd.%d", &(addr.sap_addr.itf),
+                   &(addr.sap_addr.vpi), &(addr.sap_addr.vci)) == 3) {
+            return netsnmp_eoc_transport(&addr, local);
+        } else if (sscanf(string, "%hd.%d", &(addr.sap_addr.vpi),
+                          &(addr.sap_addr.vci)) == 2) {
+            addr.sap_addr.itf = 100;
+            return netsnmp_eoc_transport(&addr, local);
+        } else if (sscanf(string, "%d", &(addr.sap_addr.vci)) == 1) {
+            addr.sap_addr.itf = 100;
+            addr.sap_addr.vpi = 0;
+            return netsnmp_eoc_transport(&addr, local);
+        } else {
+            return NULL;
+        }
+    } else {
+        return NULL;
+    }
+}
+
+
+
+netsnmp_transport *
+netsnmp_eoc_create_ostring(const u_char * o, size_t o_len, int local)
+{
+    struct sockaddr_atmpvc addr;
+
+    if (o_len == 8) {
+        addr.sap_family = AF_ATMPVC;
+        addr.sap_addr.itf = (o[0] << 8) + (o[1] << 0);
+        addr.sap_addr.vpi = (o[2] << 8) + (o[3] << 0);
+        addr.sap_addr.vci =
+	    (o[4] << 24) + (o[5] << 16) + (o[6] << 8) + (o[7] << 0);
+        return netsnmp_eoc_transport(&addr, local);
+    }
+
+    return NULL;
+}
+
+
+
+void
+netsnmp_eoc_ctor(void)
+{
+    eocDomain.name = netsnmp_EOCDomain;
+    eocDomain.name_length = sizeof(netsnmp_EOCDomain) / sizeof(oid);
+    eocDomain.prefix = calloc(2, sizeof(char *));
+    eocDomain.prefix[0] = "eoc";
+
+    eocDomain.f_create_from_tstring = netsnmp_eoc_create_tstring;
+    eocDomain.f_create_from_ostring = netsnmp_eoc_create_ostring;
+
+    netsnmp_tdomain_register(&eocDomain);
+}
diff -Naur net-snmp-5.1/snmplib/snmpUDPDomain.c open_snmp/snmplib/snmpUDPDomain.c
--- net-snmp-5.1/snmplib/snmpUDPDomain.c	2003-08-18 15:25:50.000000000 +0530
+++ open_snmp/snmplib/snmpUDPDomain.c	2009-12-16 13:01:39.000000000 +0530
@@ -188,7 +188,11 @@
 netsnmp_udp_transport(struct sockaddr_in *addr, int local)
 {
     netsnmp_transport *t = NULL;
+#if defined(HAVE_OPTIMIZED_CODE)
+    int             rc = 0, udpbuf = (1 << 14);
+#else
     int             rc = 0, udpbuf = (1 << 17);
+#endif
     char           *string = NULL;
     char           *client_socket = NULL;
 
diff -Naur net-snmp-5.1/snmplib/snmp_api.c open_snmp/snmplib/snmp_api.c
--- net-snmp-5.1/snmplib/snmp_api.c	2003-10-22 14:38:19.000000000 +0530
+++ open_snmp/snmplib/snmp_api.c	2009-12-16 13:01:40.000000000 +0530
@@ -1,24 +1,24 @@
-/******************************************************************
-	Copyright 1989, 1991, 1992 by Carnegie Mellon University
-
-                      All Rights Reserved
+/* ============================================================================
+ * Copyright (C) 2004[- 2005] -Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon 
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ * 
+ * ============================================================================
+ */
 
-Permission to use, copy, modify, and distribute this software and its
-documentation for any purpose and without fee is hereby granted,
-provided that the above copyright notice appear in all copies and that
-both that copyright notice and this permission notice appear in
-supporting documentation, and that the name of CMU not be
-used in advertising or publicity pertaining to distribution of the
-software without specific, written prior permission.
-
-CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
-ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
-CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
-ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
-WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-SOFTWARE.
-******************************************************************/
+/* ===========================================================================
+ * Revision History:
+ *
+ * $Log$
+ * ===========================================================================
+ */
 
 /** @defgroup library The Net-SNMP library
  *  @{
@@ -178,6 +178,10 @@
 #define DEFAULT_ENTERPRISE  default_enterprise
 #define DEFAULT_TIME	    0
 
+#ifdef ILMI
+#define IFX_ILMI_LEN_ATMF_VCC_CHANGE_TRAP 7
+#endif
+
 /*
  * don't set higher than 0x7fffffff, and I doubt it should be that high
  * * = 4 gig snmp messages max 
@@ -323,6 +327,16 @@
 static char     snmp_detail[192];
 static int      snmp_detail_f = 0;
 
+#ifdef ILMI
+typedef void (*ifx_ilmi_TrapHandler)();
+ifx_ilmi_TrapHandler ifx_ilmi_pfn_trap_callback = NULL;
+
+/*atmfVccChange Trap Enterprise ID = atmForum = {1,3,6,1,4,1,353 } */
+oid ifx_ilmi_AtmfVccChangeTrap[MAX_OID_LEN] = { 1,3,6,1,4,1,353 };
+size_t ifx_ilmi_len_AtmfVccChangeTrap = IFX_ILMI_LEN_ATMF_VCC_CHANGE_TRAP;
+#endif
+
+
 /*
  * Prototypes.
  */
@@ -348,6 +362,16 @@
 void            snmp_synch_reset(netsnmp_session * notused);
 void            snmp_synch_setup(netsnmp_session * notused);
 
+#ifdef ILMI
+
+void
+ifx_ilmi_register_trap_callback(ifx_ilmi_TrapHandler callback)
+{
+  ifx_ilmi_pfn_trap_callback = callback ;
+  syslog(LOG_INFO,"call back for ILMI traps registered with snmplib");
+}
+#endif
+
 #ifndef HAVE_STRERROR
 const char     *
 strerror(int err)
@@ -525,12 +549,12 @@
     strcpy(buf, "");
     snmp_errnumber = psess->s_snmp_errno;
     if (snmp_errnumber >= SNMPERR_MAX && snmp_errnumber <= SNMPERR_GENERR) {
-        strncpy(buf, api_errors[-snmp_errnumber], 256);
+        strncpy(buf, api_errors[-snmp_errnumber], sizeof(buf));
     } else {
         if (snmp_errnumber)
-            snprintf(buf, 256, "Unknown Error %d", snmp_errnumber);
+            snprintf(buf, sizeof(buf), "Unknown Error %d", snmp_errnumber);
     }
-    buf[255] = '\0';
+    buf[sizeof(buf) - 1] = '\0';
 
     /*
      * append a useful system errno interpretation. 
@@ -539,10 +563,10 @@
         const char* error = strerror(psess->s_errno);
         if(error == NULL)
             error = "Unknown Error";
-        snprintf (&buf[strlen(buf)], 256-strlen(buf),
+        snprintf (&buf[strlen(buf)], (sizeof(buf)-strlen(buf)),
                  " (%s)", error);
     }
-    buf[255] = '\0';
+    buf[sizeof(buf) - 1] = '\0';
     *p_str = strdup(buf);
 }
 
@@ -782,12 +806,16 @@
 
     snmp_debug_init();    /* should be done first, to turn on debugging ASAP */
     netsnmp_container_init_list();
+#if !defined (HAVE_MINIMAL_LIBSUPPORT)
     init_callbacks();
+#endif
     init_snmp_logging();
     snmp_init_statistics();
     register_mib_handlers();
     register_default_handlers();
+#ifdef SNMP_SECMOD_USM
     init_snmpv3(type);
+#endif /* SNMP_SECMOD_USM */
     init_snmp_alarm();
     init_snmp_enum(type);
     init_snmp_enums();
@@ -1000,7 +1028,7 @@
         return (NULL);
     }
     session->community = ucp;   /* replace pointer with pointer to new data */
-
+#ifdef SNMP_SECMOD_USM
     if (session->securityLevel <= 0) {
         session->securityLevel =
             netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SECLEVEL);
@@ -1151,6 +1179,7 @@
             return NULL;
         }
     }
+#endif /* SNMP_SECMOD_USM */
 
     if (session->retries == SNMP_DEFAULT_RETRIES)
         session->retries = DEFAULT_RETRIES;
@@ -1160,7 +1189,7 @@
 
     snmp_call_callbacks(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SESSION_INIT,
                         session);
-
+#ifdef SNMP_SECMOD_USM
     if ((sptr = find_sec_mod(session->securityModel)) != NULL &&
         sptr->session_open != NULL) {
         /*
@@ -1168,7 +1197,7 @@
          */
         (*sptr->session_open) (session);
     }
-
+#endif /* SNMP_SECMOD_USM */
     return (slp);
 }
 
@@ -1187,7 +1216,7 @@
 }
 
 
-
+#ifdef SNMP_SECMOD_USM
 int
 snmpv3_engineID_probe(struct session_list *slp,
                       netsnmp_session * in_session)
@@ -1283,7 +1312,7 @@
 
     return 1;
 }
-
+#endif /* SNMP_SECMOD_USM */
 
 
 /*******************************************************************-o-******
@@ -1335,12 +1364,12 @@
     }
 
     session->rcvMsgMaxSize = slp->transport->msgMaxSize;
-
+#ifdef SNMP_SECMOD_USM
     if (!snmpv3_engineID_probe(slp, in_session)) {
         snmp_sess_close(slp);
         return 0;
     }
-
+#endif /* SNMP_SECMOD_USM */
     return (void *) slp;
 }                               /* end snmp_sess_open() */
 
@@ -1461,7 +1490,7 @@
     slp->internal->hook_create_pdu = fcreate_pdu;
 
     slp->session->rcvMsgMaxSize = transport->msgMaxSize;
-
+#ifdef SNMP_SECMOD_USM
     if (slp->session->version == SNMP_VERSION_3) {
         DEBUGMSGTL(("snmp_sess_add",
                     "adding v3 session -- engineID probe now\n"));
@@ -1471,6 +1500,7 @@
             slp = NULL;
         }
     }
+#endif /* SNMP_SECMOD_USM */
 
     return (void *) slp;
 }                               /*  end snmp_sess_add_ex()  */
@@ -1502,7 +1532,7 @@
 }
 
 
-
+#ifdef SNMP_SECMOD_USM
 /*
  * create_user_from_session(netsnmp_session *session):
  * 
@@ -1655,6 +1685,7 @@
 
 
 }                               /* end create_user_from_session() */
+#endif /* SNMP_SECMOD_USM */
 
 /*
  *  Do a "deep free()" of a netsnmp_session.
@@ -1697,11 +1728,12 @@
         return 0;
     }
 
+#ifdef SNMP_SECMOD_USM
     if ((sptr = find_sec_mod(slp->session->securityModel)) != NULL &&
         sptr->session_close != NULL) {
         (*sptr->session_close) (slp->session);
     }
-
+#endif /*SNMP_SECMOD_USM */
     isp = slp->internal;
     slp->internal = 0;
 
@@ -1802,6 +1834,7 @@
     return 1;
 }
 
+#ifdef SNMP_SECMOD_USM
 static int
 snmpv3_build_probe_pdu(netsnmp_pdu **pdu)
 {
@@ -2570,7 +2603,7 @@
     return result;
 
 }                               /* end snmpv3_packet_build() */
-
+#endif /* SNMP_SECMOD_USM */
 
 /*
  * Takes a session and a pdu and serializes the ASN PDU into the area
@@ -2592,10 +2625,12 @@
     session->s_snmp_errno = 0;
     session->s_errno = 0;
 
+#ifdef  SNMP_SECMOD_USM
     if (pdu->version == SNMP_VERSION_3) {
         return snmpv3_build(pkt, pkt_len, offset, session, pdu);
     }
-
+#endif /* SNMP_SECMOD_USM */
+    
     switch (pdu->command) {
     case SNMP_MSG_RESPONSE:
         pdu->flags &= (~UCD_MSG_FLAG_EXPECT_RESPONSE);
@@ -3331,7 +3366,7 @@
     return version;
 }
 
-
+#ifdef  SNMP_SECMOD_USM
 int
 snmpv3_parse(netsnmp_pdu *pdu,
              u_char * data,
@@ -3864,6 +3899,7 @@
     DEBUGMSGTL(("report", "Report type: %d\n", rpt_type));
     return rpt_type;
 }
+#endif /* SNMP_SECMOD_USM */
 
 /*
  * Parses the packet received on the input session, and places the data into
@@ -3880,6 +3916,9 @@
     size_t          community_length = COMMUNITY_MAX_LEN;
     int             result = -1;
 
+#if defined(HAVE_OPTIMIZED_CODE)
+    memset(community, 0x00, sizeof(community));
+#endif
     session->s_snmp_errno = 0;
     session->s_errno = 0;
 
@@ -3933,7 +3972,11 @@
         pdu->community = (u_char *) 0;
         if (community_length) {
             pdu->community_len = community_length;
+#if defined(HAVE_OPTIMIZED_CODE)
+            pdu->community = (u_char *) calloc(1, community_length);
+#else
             pdu->community = (u_char *) malloc(community_length);
+#endif
             if (pdu->community == NULL) {
                 session->s_snmp_errno = SNMPERR_MALLOC;
                 return -1;
@@ -3959,7 +4002,8 @@
         }
         DEBUGINDENTADD(-6);
         break;
-
+	
+#ifdef  SNMP_SECMOD_USM
     case SNMP_VERSION_3:
         result = snmpv3_parse(pdu, data, &length, NULL, session);
         DEBUGMSGTL(("snmp_parse",
@@ -4008,6 +4052,8 @@
             }
         }
         break;
+#endif /* SNMP_SECMOD_USM */
+
     case SNMPERR_BAD_VERSION:
         ERROR_MSG("error parsing snmp message version");
         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
@@ -4311,6 +4357,7 @@
     return badtype;
 }
 
+#ifdef  SNMP_SECMOD_USM
 /*
  * snmp v3 utility function to parse into the scopedPdu. stores contextName
  * and contextEngineID in pdu struct. Also stores pdu->command (handy for 
@@ -4397,6 +4444,7 @@
 
     return data;
 }
+#endif /* SNMP_SECMOD_USM */
 
 /*
  * These functions send PDUs using an active session:
@@ -4776,10 +4824,12 @@
         snmp_log(LOG_WARNING, "snmp_free_pdu probably called twice\n");
         return;
     }
+#ifdef SNMP_SECMOD_USM
     if ((sptr = find_sec_mod(pdu->securityModel)) != NULL &&
         sptr->pdu_free != NULL) {
         (*sptr->pdu_free) (pdu);
     }
+#endif /* SNMP_SECMOD_USM */
     snmp_free_varbind(pdu->variables);
     SNMP_FREE(pdu->enterprise);
     SNMP_FREE(pdu->community);
@@ -4796,11 +4846,14 @@
 snmp_create_sess_pdu(netsnmp_transport *transport, void *opaque,
                      size_t olength)
 {
-    netsnmp_pdu *pdu = (netsnmp_pdu *)calloc(1, sizeof(netsnmp_pdu));
+   // netsnmp_pdu *pdu = (netsnmp_pdu *)calloc(1, sizeof(netsnmp_pdu));
+    netsnmp_pdu *pdu = (netsnmp_pdu *)malloc(sizeof(netsnmp_pdu));
     if (pdu == NULL) {
         DEBUGMSGTL(("sess_process_packet", "can't malloc space for PDU\n"));
         return NULL;
     }
+	else
+		memset(pdu, 0, sizeof(netsnmp_pdu));
 
     /*
      * Save the transport-level data specific to this reception (e.g. UDP
@@ -4900,6 +4953,8 @@
   }
 
   if (ret != SNMP_ERR_NOERROR) {
+
+#ifdef SNMP_SECMOD_USM
     /*
      * Call USM to free any securityStateRef supplied with the message.  
      */
@@ -4920,11 +4975,38 @@
       }
       pdu->securityStateRef = NULL;
     }
+#endif /* SNMP_SECMOD_USM */
     snmp_free_pdu(pdu);
     return -1;
   }
 
+#ifdef ILMI
+    if ( pdu->command == SNMP_MSG_TRAP ||
+         pdu->command == SNMP_MSG_TRAP2 ) {
+           if ( ( pdu->trap_type == SNMP_TRAP_COLDSTART ) ||
+				( snmp_oid_compare( ifx_ilmi_AtmfVccChangeTrap,
+									ifx_ilmi_len_AtmfVccChangeTrap,
+									pdu->enterprise,
+									pdu->enterprise_length ) == 0 )  ) {
+       		   if ( ifx_ilmi_pfn_trap_callback != NULL) {
+                    if ( pdu->trap_type == SNMP_TRAP_COLDSTART ) {
+					 syslog(LOG_INFO,"ILMI:calling callback for ColdStart Trap");
+					} else {
+					 syslog(LOG_INFO,"ILMI:calling callback for AtmVccChange Trap");
+					}
+					
+					ifx_ilmi_pfn_trap_callback();
+			   } else {
+				    syslog(LOG_INFO,"ILMI:Trap callback is NULL");
+			   }
+		   }
+		   
+    }
+#endif
+	   
   if (pdu->flags & UCD_MSG_FLAG_RESPONSE_PDU) {
+
+#ifdef SNMP_SECMOD_USM
     /*
      * Call USM to free any securityStateRef supplied with the message.  
      */
@@ -4945,12 +5027,14 @@
       }
       pdu->securityStateRef = NULL;
     }
+#endif /* SNMP_SECMOD_USM */
 
     for (rp = isp->requests; rp; orp = rp, rp = rp->next_request) {
       snmp_callback   callback;
       void           *magic;
 
       if (pdu->version == SNMP_VERSION_3) {
+#ifdef SNMP_SECMOD_USM
 	/*
 	 * msgId must match for v3 messages.  
 	 */
@@ -4965,6 +5049,7 @@
 	if (!snmpv3_verify_msg(rp, pdu)) {
 	  break;
 	}
+#endif /* SNMP_SECMOD_USM */
       } else {
 	if (rp->request_id != pdu->reqid) {
 	  continue;
@@ -4989,9 +5074,11 @@
 	  || callback(NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE, sp,
 		      pdu->reqid, pdu, magic) == 1) {
 	if (pdu->command == SNMP_MSG_REPORT) {
-	  if (sp->s_snmp_errno == SNMPERR_NOT_IN_TIME_WINDOW ||
-	      snmpv3_get_report_type(pdu) ==
-	      SNMPERR_NOT_IN_TIME_WINDOW) {
+	  if (sp->s_snmp_errno == SNMPERR_NOT_IN_TIME_WINDOW 
+#ifdef SNMP_SECMOD_USM
+	  ||  snmpv3_get_report_type(pdu) ==  SNMPERR_NOT_IN_TIME_WINDOW
+#endif /* SNMP_SECMOD_USM */
+	  	)  {
 	    /*
 	     * trigger immediate retry on recoverable Reports 
 	     * * (notInTimeWindow), incr_retries == TRUE to prevent
@@ -5080,6 +5167,7 @@
     }
   }
 
+#ifdef SNMP_SECMOD_USM
   /*
    * Call USM to free any securityStateRef supplied with the message.  
    */
@@ -5106,7 +5194,7 @@
     snmp_increment_statistic(STAT_SNMPUNKNOWNPDUHANDLERS);
     DEBUGMSGTL(("sess_process_packet", "unhandled PDU\n"));
   }
-
+#endif /* SNMP_SECMOD_USM */
   snmp_free_pdu(pdu);
   return 0;
 }
@@ -5142,7 +5230,11 @@
     netsnmp_session *sp = slp ? slp->session : NULL;
     struct snmp_internal_session *isp = slp ? slp->internal : NULL;
     netsnmp_transport *transport = slp ? slp->transport : NULL;
+#if defined(HAVE_OPTIMIZED_CODE)
+    size_t          pdulen = 0, rxbuf_len = 8192;
+#else
     size_t          pdulen = 0, rxbuf_len = 65536;
+#endif
     u_char         *rxbuf = NULL;
     int             length = 0, olength = 0, rc = 0;
     void           *opaque = NULL;
@@ -5869,6 +5961,7 @@
         }
 
         if ((timercmp(&rp->expire, &now, <))) {
+#ifdef SNMP_SECMOD_USM
             if ((sptr = find_sec_mod(rp->pdu->securityModel)) != NULL &&
                 sptr->pdu_timeout != NULL) {
                 /*
@@ -5876,6 +5969,7 @@
                  */
                 (*sptr->pdu_timeout) (rp->pdu);
             }
+#endif /* SNMP_SECMOD_USM */
 
             /*
              * this timer has expired 
diff -Naur net-snmp-5.1/snmplib/snmp_client.c open_snmp/snmplib/snmp_client.c
--- net-snmp-5.1/snmplib/snmp_client.c	2003-11-06 08:43:55.000000000 +0530
+++ open_snmp/snmplib/snmp_client.c	2009-12-16 13:01:40.000000000 +0530
@@ -156,7 +156,9 @@
 
     if (op == NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE) {
         if (pdu->command == SNMP_MSG_REPORT) {
+#ifdef SNMP_SECMOD_USM 
             rpt_type = snmpv3_get_report_type(pdu);
+#endif
             if (SNMPV3_IGNORE_UNAUTH_REPORTS ||
                 rpt_type == SNMPERR_NOT_IN_TIME_WINDOW) {
                 state->waiting = 1;
@@ -345,6 +347,7 @@
         snmp_free_pdu(newpdu);
         return 0;
     }
+#ifdef SNMP_SECMOD_USM
     if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&
         sptr->pdu_clone != NULL) {
         /*
@@ -352,7 +355,7 @@
          */
         (*sptr->pdu_clone) (pdu, newpdu);
     }
-
+#endif
     return newpdu;
 }
 
diff -Naur net-snmp-5.1/snmplib/snmp_logging.c open_snmp/snmplib/snmp_logging.c
--- net-snmp-5.1/snmplib/snmp_logging.c	2003-07-09 20:36:05.000000000 +0530
+++ open_snmp/snmplib/snmp_logging.c	2009-12-16 13:01:40.000000000 +0530
@@ -285,7 +285,8 @@
     }
 
     switch (*cp) {
-
+	    
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
     /*
      * Log to Standard Error
      */
@@ -339,6 +340,7 @@
             logh->token   = strdup(optarg);
 	}
         break;
+#endif
 
     /*
      * Log to syslog
@@ -376,15 +378,22 @@
 {
     const char *pri1_msg = " for level 'pri' and above";
     const char *pri2_msg = " for levels 'p1' to 'p2'";
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
     fprintf(outf, "%se:           log to standard error\n", lead);
     fprintf(outf, "%so:           log to standard output\n", lead);
     fprintf(outf, "%sf file:      log to the specified file\n", lead);
+#endif
     fprintf(outf, "%ss facility:  log to syslog (via the specified facility)\n", lead);
     fprintf(outf, "\n%s(variants)\n", lead);
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
     fprintf(outf, "%s[EO] pri:    log to standard error/output%s\n", lead, pri1_msg);
     fprintf(outf, "%s[EO] p1-p2:  log to standard error/output%s\n", lead, pri2_msg);
     fprintf(outf, "%s[FS] pri token:    log to file/syslog%s\n", lead, pri1_msg);
     fprintf(outf, "%s[FS] p1-p2 token:  log to file/syslog%s\n", lead, pri2_msg);
+#else
+    fprintf(outf, "%s[S] pri token:    log to syslog%s\n", lead, pri1_msg);
+    fprintf(outf, "%s[S] p1-p2 token:  log to syslog%s\n", lead, pri2_msg);
+#endif
 }
 
 int
@@ -456,6 +465,8 @@
 }
 #endif
 
+
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
 void
 snmp_disable_filelog(void)
 {
@@ -503,6 +514,7 @@
     for (logh = logh_head; logh; logh = logh->next)
         logh->enabled = 0;	/* XXX - any per-handler closedown? */
 }
+#endif
 
 /* ================================================== */
 
@@ -560,6 +572,7 @@
     }
 }
 
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
 void
 netsnmp_enable_filelog(netsnmp_log_handler *logh, int dont_zero_log)
 {
@@ -656,7 +669,7 @@
             logh->token    = strdup("callback");
     }
 }
-
+#endif
 
 
 /* ==================================================== */
@@ -736,6 +749,8 @@
 
     logh->type     = type;
     switch ( type ) {
+
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
     case NETSNMP_LOGHANDLER_STDOUT:
         logh->imagic  = 1;
         /* fallthrough */
@@ -746,12 +761,15 @@
     case NETSNMP_LOGHANDLER_FILE:
         logh->handler = log_handler_file;
         break;
+#endif
     case NETSNMP_LOGHANDLER_SYSLOG:
         logh->handler = log_handler_syslog;
         break;
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
     case NETSNMP_LOGHANDLER_CALLBACK:
         logh->handler = log_handler_callback;
         break;
+#endif
     default:
         free(logh->handler);
         return NULL;
@@ -806,6 +824,7 @@
 
 /* ==================================================== */
 
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
 int
 log_handler_stdouterr(  netsnmp_log_handler* logh, int pri, const char *string)
 {
@@ -826,7 +845,7 @@
 
     return 1;
 }
-
+#endif
 
 #ifdef WIN32
 int
@@ -909,6 +928,7 @@
 #endif /* !WIN32 */
 
 
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
 int
 log_handler_file(    netsnmp_log_handler* logh, int pri, const char *string)
 {
@@ -961,6 +981,7 @@
         snmp_set_do_debugging(dodebug);
     return 1;
 }
+#endif
 
 void
 snmp_log_string(int priority, const char *string)
@@ -970,8 +991,10 @@
     /*
      * Start at the given priority, and work "upwards"....
      */
+#if !defined(HAVE_MINIMAL_LIBSUPPORT)
     if (!logh_head)
 	snmp_enable_stderrlog();
+#endif
     logh = logh_priorities[priority];
     for ( ; logh; logh = logh->next ) {
         /*
diff -Naur net-snmp-5.1/snmplib/snmp_parse_args.c open_snmp/snmplib/snmp_parse_args.c
--- net-snmp-5.1/snmplib/snmp_parse_args.c	2003-08-15 16:54:50.000000000 +0530
+++ open_snmp/snmplib/snmp_parse_args.c	2009-12-16 13:01:40.000000000 +0530
@@ -352,20 +352,20 @@
 		Cpsz = optarg;
 	    }
             break;
-
+#ifdef SNMP_SECMOD_USM
         case '3':
 	    /*  TODO: This needs to zero things too.  */
             if (snmpv3_options(optarg, session, &Apsz, &Xpsz, argc, argv) < 0){
                 return (-1);
             }
             break;
-
+#endif /* SNMP_SECMOD_USM */
         case 'L':
             if (snmp_log_options(optarg, argc, argv) < 0) {
                 return (-1);
             }
             break;
-
+#ifdef SNMP_SECMOD_USM
 #define SNMPV3_CMD_OPTIONS
 #ifdef  SNMPV3_CMD_OPTIONS
         case 'Z':
@@ -537,6 +537,7 @@
 	    }
             break;
 #endif                          /* SNMPV3_CMD_OPTIONS */
+#endif /* SNMP_SECMOD_USM */
 
         case '?':
             return (-1);
@@ -587,6 +588,7 @@
         }
     }
 
+#ifdef SNMP_SECMOD_USM
     /*
      * make master key from pass phrases 
      */
@@ -652,6 +654,8 @@
             return (-2);
         }
     }
+#endif /* SNMP_SECMOD_USM */
+
     /*
      * get the hostname 
      */
diff -Naur net-snmp-5.1/snmplib/snmp_transport.c open_snmp/snmplib/snmp_transport.c
--- net-snmp-5.1/snmplib/snmp_transport.c	2003-07-03 01:59:47.000000000 +0530
+++ open_snmp/snmplib/snmp_transport.c	2009-12-16 13:01:41.000000000 +0530
@@ -201,6 +201,9 @@
 #endif
 #ifdef SNMP_TRANSPORT_AAL5PVC_DOMAIN
     netsnmp_aal5pvc_ctor();
+#ifdef SNMP_TRANSPORT_EOC_DOMAIN
+    netsnmp_eoc_ctor();
+#endif
 #endif
 #ifdef SNMP_TRANSPORT_UDPIPV6_DOMAIN
     netsnmp_udp6_ctor();
diff -Naur net-snmp-5.1/snmplib/snmpusm.c open_snmp/snmplib/snmpusm.c
--- net-snmp-5.1/snmplib/snmpusm.c	2003-10-23 05:40:42.000000000 +0530
+++ open_snmp/snmplib/snmpusm.c	2009-12-16 13:01:41.000000000 +0530
@@ -20,9 +20,9 @@
  * !! Tab stops set to 4 in some parts of this file. !!
  *    (Designated on a per function.)
  */
-
 #include <net-snmp/net-snmp-config.h>
 
+#ifdef SNMP_SECMOD_USM
 #include <sys/types.h>
 #if HAVE_WINSOCK_H
 #include <winsock.h>
@@ -3655,3 +3655,5 @@
         }
     }
 }                               /* end usm_set_password() */
+
+#endif /* SNMP_SECMOD_USM */
diff -Naur net-snmp-5.1/snmplib/snmpv3.c open_snmp/snmplib/snmpv3.c
--- net-snmp-5.1/snmplib/snmpv3.c	2003-07-03 03:15:14.000000000 +0530
+++ open_snmp/snmplib/snmpv3.c	2009-12-16 13:01:41.000000000 +0530
@@ -1,9 +1,66 @@
+/* ============================================================================
+ * Copyright (C) 2004 - Infineon Technologies AG.
+ *
+ * All rights reserved.
+ * ============================================================================
+ *
+ * ============================================================================
+ *
+ * This document contains proprietary information belonging to Infineon
+ * Technologies AG. Passing on and copying of this document, and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * ============================================================================
+ */
+
+/* ===========================================================================
+ *
+ * File Name    : snmpv3.c
+ * Author       : Subbi
+ * Date         : 27-Jul-2004
+ *
+ * ===========================================================================
+ *
+ * Project      : Amazon
+ * Block        : ADSL-MIBs 
+ *
+ * ===========================================================================
+ * Contents: This file contains added/enhanced functions for:
+ *                 1) Authentication Validation
+ *                 2) Encryption Validation
+ *                 3) Modification to  usm_parse_create_usmUser function
+ *                 4) Added functions to create and delete usm User
+ *
+ *
+ * ===========================================================================
+ * References: RFC 2662
+ *
+ */
+
+/* ===========================================================================
+ * Revision History:
+ *                 1) Authentication Validation
+ *                 2) Encryption Validation
+ *                 3) Modification to  usm_parse_create_usmUser function
+ *                 4) Added functions to create and delete usm User
+ *
+ * $Log$
+ * ===========================================================================
+ */
+
 /*
- * snmpv3.c
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
  */
 
+/*
+ * ===========================================================================
+ *                           INCLUDE FILES
+ * ===========================================================================
+ */
 #include <net-snmp/net-snmp-config.h>
 
+#ifdef SNMP_SECMOD_USM 
 #include <stdio.h>
 #include <sys/types.h>
 #if TIME_WITH_SYS_TIME
@@ -97,6 +154,238 @@
 static int      getHwAddress(const char *networkDevice, char *addressOut);
 #endif
 
+
+/* Authentication Type Validation */
+int processAuthType(char *authType, struct usmUser *newuser)
+{
+   /* READ: Authentication Type */
+    if (strncmp(authType, "MD5", 3) == 0) {
+        memcpy(newuser->authProtocol, usmHMACMD5AuthProtocol,
+               sizeof(usmHMACMD5AuthProtocol));
+    } else if (strncmp(authType, "SHA", 3) == 0) {
+        memcpy(newuser->authProtocol, usmHMACSHA1AuthProtocol,
+               sizeof(usmHMACSHA1AuthProtocol));
+    } else {
+        config_perror("Unknown authentication protocol");
+        usm_free_user(newuser);
+        return -1;
+    }
+	return 0;
+}
+
+
+/* Authentication Password Validation */
+int processAuthPassPhrase(char *authPassPhrase, struct usmUser *newuser,
+		char *userKey, int *userKeyLen  )
+{
+	int ret=0;
+
+    /* Convert the user AuthPassPhrase into a localized key */
+    ret = generate_Ku(newuser->authProtocol, newuser->authProtocolLen,
+       (u_char *) authPassPhrase, strlen(authPassPhrase), userKey, userKeyLen);
+    if (ret != SNMPERR_SUCCESS) {
+        config_perror("could not generate the authentication key from the "
+                      "suppiled pass phrase.");
+        usm_free_user(newuser);
+        return -1;
+    }
+    newuser->authKeyLen =
+        sc_get_properlength(newuser->authProtocol,
+                            newuser->authProtocolLen);
+    newuser->authKey = (u_char *) malloc(newuser->authKeyLen);
+    ret = generate_kul(newuser->authProtocol, newuser->authProtocolLen,
+                       newuser->engineID, newuser->engineIDLen,
+                       userKey, *userKeyLen,
+                       newuser->authKey, &newuser->authKeyLen);
+    if (ret != SNMPERR_SUCCESS) {
+        config_perror("could not generate localized authentication key (Kul) "
+                      "from the master key (Ku).");
+        usm_free_user(newuser);
+        return -1;
+    }
+	return 0;
+}
+
+
+/* Encryption Protocol Validation */
+int processEncrType(char *encrType, struct usmUser *newuser)
+{
+    /* READ: Privacy Type */
+    if (strncmp(encrType, "DES", 3) == 0) {
+        memcpy(newuser->privProtocol, usmDESPrivProtocol,
+               sizeof(usmDESPrivProtocol));
+#ifdef HAVE_AES
+    } else if (strncmp(encrType, "AES128", 3) == 0) {
+        memcpy(newuser->privProtocol, usmAES128PrivProtocol,
+               sizeof(usmAES128PrivProtocol));
+    } else if (strncmp(encrType, "AES192", 3) == 0) {
+        memcpy(newuser->privProtocol, usmAES192PrivProtocol,
+               sizeof(usmAES192PrivProtocol));
+    } else if (strncmp(encrType, "AES256", 3) == 0) {
+        memcpy(newuser->privProtocol, usmAES256PrivProtocol,
+               sizeof(usmAES256PrivProtocol));
+#endif
+    } else {
+        config_perror("Unknown privacy protocol");
+        usm_free_user(newuser);
+        return -1;
+    }
+	return 0;
+}
+
+
+/* Encryption Password Validation */
+int processEncrPassPhrase(char *encrPassPhrase, struct usmUser *newuser,
+	char *userKey, int *userKeyLen)
+{
+	int ret = 0;
+
+    /* READ: Encryption Pass Phrase */
+    if (!encrPassPhrase) {
+        /* assume the same as the authentication key */
+        memdup(&newuser->privKey, newuser->authKey, newuser->authKeyLen);
+        newuser->privKeyLen = newuser->authKeyLen;
+    } else {
+        /* And turn it into a localized key */
+        ret = generate_Ku(newuser->authProtocol, newuser->authProtocolLen,
+                          (u_char *) encrPassPhrase, strlen(encrPassPhrase),
+                          userKey, userKeyLen);
+        if (ret != SNMPERR_SUCCESS) {
+            config_perror("could not generate privacy key from the supplied "
+                          "pass phrase.");
+            usm_free_user(newuser);
+            return -1;
+        }
+
+        ret =
+            sc_get_properlength(newuser->authProtocol,
+                                newuser->authProtocolLen);
+        if (ret < 0) {
+            config_perror("could not get proper key length to use for the "
+                          "privacy algorithm.");
+            usm_free_user(newuser);
+            return -1;
+        }
+        newuser->privKeyLen = ret;
+
+        newuser->privKey = (u_char *) malloc(newuser->privKeyLen);
+        ret = generate_kul(newuser->authProtocol, newuser->authProtocolLen,
+                           newuser->engineID, newuser->engineIDLen,
+                           userKey, *userKeyLen,
+                           newuser->privKey, &newuser->privKeyLen);
+        if (ret != SNMPERR_SUCCESS) {
+            config_perror("could not generate the localized privacy key (Kul) "
+                          "from the master key (Ku).");
+            usm_free_user(newuser);
+            return -1;
+        }
+    }
+	return 0;
+}
+
+
+/* This function creates a usmUser and then adds it into the
+ * usmUserList. It also updates the persistence store */
+int
+IFX_create_usmUser(
+	char *username, char *useraccess, char *authProto,
+	char *authPassPhrase, char *encrProto, char *encrPassPhrase,
+	char *type)
+{
+    struct usmUser *newuser;
+    u_char          userKey[SNMP_MAXBUF_SMALL];
+    size_t          userKeyLen = SNMP_MAXBUF_SMALL;
+    size_t          ret;
+
+    newuser = usm_create_user();
+
+	if (newuser == NULL) {
+		return -1;
+	}
+
+    newuser->engineID = snmpv3_generate_engineID(&ret);
+    if (ret == 0) {
+		goto lbl_err;
+    }
+    newuser->engineIDLen = ret;
+    newuser->secName = strdup(username);
+    newuser->name = strdup(username);
+
+	if (authProto == NULL || authProto[0] == '\0') 
+	   goto add; /* NoAuthNoPriv */
+
+	if (processAuthType(authProto, newuser) < 0) {
+		goto lbl_err; /* error */
+	}
+
+	if (processAuthPassPhrase(authPassPhrase, newuser, userKey, &userKeyLen)
+			< 0) {
+		goto lbl_err; /* error */
+	}
+
+	if (encrProto == NULL || encrProto[0] == '\0') 
+	   goto add;  /* no privacy type (which is legal) */
+
+	if (processEncrType(encrProto, newuser) < 0) {
+		goto lbl_err;
+	}
+
+	if (processEncrPassPhrase(encrPassPhrase, newuser, userKey, &userKeyLen)
+			< 0) {
+		goto lbl_err;
+	}
+
+add:
+	DEBUGMSG(("User<%s>, Auth<%s:%s>, Encr<%s:%s>!\n",
+		newuser->name, authProto, authPassPhrase, encrProto, encrPassPhrase));
+    if (usm_add_user(newuser) == NULL) {
+		DEBUGMSG(("usmUser", "User creation failed !\n"));
+		goto lbl_err;
+	}
+    DEBUGMSGTL(("usmUser", "created a new user %s at ", newuser->secName));
+    DEBUGMSGHEX(("usmUser", newuser->engineID, newuser->engineIDLen));
+    DEBUGMSG(("usmUser", "\n"));
+
+    /** Update the persistent store **/
+    snmp_store(type);
+
+	return (0);
+
+lbl_err:
+	usm_free_user(newuser);
+	return -1;
+}
+
+
+/* This function deletes the specified usmUser from the
+ * usmUserList. It also updates the persistence store */
+int
+IFX_delete_usmUser(char *username, char *type)
+{
+  struct usmUser *usmUserList, *user;
+  usmUserList = usm_get_userList();
+
+  for (user=usmUserList; user!=NULL; user=user->next) {
+    if (strcmp(user->name, username) == 0) {
+	/* Match Found for the user - so delete this user */
+		usm_remove_user(user);
+		
+  	/** Update the persistent store **/
+  		snmp_store(type);
+		usm_free_user(user);
+		break;
+    }	
+  }
+  if (user == NULL) {
+    DEBUGMSGTL(("usmUser", "User: (%s) doesn't exist", username));
+	return -1;
+  }
+  
+  return 0;
+}
+
+
+
 void
 snmpv3_authtype_conf(const char *word, char *cptr)
 {
@@ -694,6 +983,7 @@
     if (!cp)
         goto add;               /* no authentication or privacy type */
 
+#if Subbi_Auth
     /*
      * READ: Authentication Type 
      */
@@ -708,6 +998,11 @@
         usm_free_user(newuser);
         return;
     }
+#endif /* Subbi_Auth */
+    
+    if (processAuthType(cp, newuser) < 0) {
+		return; /* error */
+    }
 
     cp = skip_token(cp);
 
@@ -720,6 +1015,8 @@
         return;
     }
     cp = copy_nword(cp, buf, sizeof(buf));
+
+#if Subbi_Key
     /*
      * And turn it into a localized key 
      */
@@ -745,6 +1042,12 @@
         usm_free_user(newuser);
         return;
     }
+#endif /* Subbi_Key */
+
+    if (processAuthPassPhrase(buf, newuser, userKey, &userKeyLen)
+			< 0) {
+		return; /* error */
+    }
 
     if (!cp)
         goto add;               /* no privacy type (which is legal) */
@@ -752,6 +1055,12 @@
     /*
      * READ: Privacy Type 
      */
+
+    if (processEncrType(cp, newuser) < 0) {
+		return; /* error */
+    }
+
+#if Subbi_Encrypt
     if (strncmp(cp, "DES", 3) == 0) {
         memcpy(newuser->privProtocol, usmDESPrivProtocol,
                sizeof(usmDESPrivProtocol));
@@ -771,8 +1080,24 @@
         usm_free_user(newuser);
         return;
     }
+#endif /* Subbi_Encrypt */
 
     cp = skip_token(cp);
+    if (cp == NULL) {
+    	if (processEncrPassPhrase(cp, newuser, userKey, &userKeyLen)
+		< 0) {
+		return; /* error */
+    	}
+    }
+    else {
+        cp = copy_nword(cp, buf, sizeof(buf));
+    	if (processEncrPassPhrase(buf, newuser, userKey, &userKeyLen)
+		< 0) {
+		return; /* error */
+    	}
+    }
+
+#if Subbi_EncryPasswd
     /*
      * READ: Authentication Pass Phrase 
      */
@@ -820,6 +1145,8 @@
             return;
         }
     }
+#endif /* Subbi_Encrypt_Passwd */
+
   add:
     usm_add_user(newuser);
     DEBUGMSGTL(("usmUser", "created a new user %s at ", newuser->secName));
@@ -1389,3 +1716,5 @@
     snmpv3starttime.tv_sec -= ttime;
 }
 #endif
+
+#endif /* SNMP_SECMOD_USM */
diff -Naur net-snmp-5.1/snmplib/tools.c open_snmp/snmplib/tools.c
--- net-snmp-5.1/snmplib/tools.c	2003-02-20 02:41:49.000000000 +0530
+++ open_snmp/snmplib/tools.c	2009-12-16 13:01:42.000000000 +0530
@@ -164,8 +164,9 @@
     u_char         *buf = (u_char *) calloc(1, *size);
 
     if (buf) {
+#ifdef SNMP_SECMOD_USM
         rval = sc_random(buf, size);
-
+#endif
         if (rval < 0) {
             free_zero(buf, *size);
             buf = NULL;
diff -Naur net-snmp-5.1/stamp-h open_snmp/stamp-h
--- net-snmp-5.1/stamp-h	2003-11-14 08:26:34.000000000 +0530
+++ open_snmp/stamp-h	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-timestamp
