# HG changeset patch
# Parent 8f9bbbf2c1a981683bb7b38600bb7e3855d10009
update target/linux/generic/files for compilation with linux kernel-3.10

diff --git a/include/netfilter.mk b/include/netfilter.mk
--- a/include/netfilter.mk
+++ b/include/netfilter.mk
@@ -50,8 +50,8 @@ endef
 $(eval $(call nf_add,IPT_CLUSTER,CONFIG_NETFILTER_XT_MATCH_CLUSTER, $(P_XT)xt_cluster))
 
 $(eval $(call nf_add,IPT_CORE,CONFIG_NETFILTER_XT_TARGET_LOG, $(P_XT)xt_LOG))
-$(eval $(call nf_add,IPT_CORE,CONFIG_NETFILTER_XT_TARGET_LOG, $(P_XT)nf_log_common))
-$(eval $(call nf_add,IPT_CORE,CONFIG_NETFILTER_XT_TARGET_LOG, $(P_V4)nf_log_ipv4))
+#$(eval $(call nf_add,IPT_CORE,CONFIG_NETFILTER_XT_TARGET_LOG, $(P_XT)nf_log_common))
+#$(eval $(call nf_add,IPT_CORE,CONFIG_NETFILTER_XT_TARGET_LOG, $(P_V4)nf_log_ipv4))
 $(eval $(call nf_add,IPT_CORE,CONFIG_NETFILTER_XT_TARGET_TCPMSS, $(P_XT)xt_TCPMSS))
 $(eval $(call nf_add,IPT_CORE,CONFIG_IP_NF_TARGET_REJECT, $(P_V4)ipt_REJECT))
 $(eval $(call nf_add,IPT_CORE,CONFIG_IP_NF_TARGET_REJECT, $(P_V4)nf_reject_ipv4))
@@ -158,7 +158,7 @@ endef
 
 $(eval $(call nf_add,IPT_IPV6,CONFIG_IP6_NF_TARGET_LOG, $(P_V6)ip6t_LOG))
 $(eval $(call nf_add,IPT_IPV6,CONFIG_IP6_NF_TARGET_REJECT, $(P_V6)ip6t_REJECT))
-$(eval $(call nf_add,IPT_IPV6,CONFIG_IP6_NF_TARGET_REJECT, $(P_V6)nf_reject_ipv6))
+#$(eval $(call nf_add,IPT_IPV6,CONFIG_IP6_NF_TARGET_REJECT, $(P_V6)nf_reject_ipv6))
 
 # ipv6 extra
 $(eval $(call nf_add,IPT_IPV6_EXTRA,CONFIG_IP6_NF_MATCH_IPV6HEADER, $(P_V6)ip6t_ipv6header))
diff --git a/package/kernel/linux/modules/usb.mk b/package/kernel/linux/modules/usb.mk
--- a/package/kernel/linux/modules/usb.mk
+++ b/package/kernel/linux/modules/usb.mk
@@ -18,7 +18,7 @@ define KernelPackage/usb-core
   KCONFIG:=CONFIG_USB CONFIG_XPS_USB_HCD_XILINX=n CONFIG_USB_FHCI_HCD=n
   FILES:= \
 	$(LINUX_DIR)/drivers/usb/core/usbcore.ko \
-	$(LINUX_DIR)/drivers/usb/common/usb-common.ko
+	$(LINUX_DIR)/drivers/usb/usb-common.ko
   AUTOLOAD:=$(call AutoLoad,20,usb-common usbcore,1)
   $(call AddDepends/nls)
 endef
diff --git a/target/linux/generic/config-3.10 b/target/linux/generic/config-3.10
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/config-3.10
@@ -0,0 +1,3985 @@
+CONFIG_32BIT=y
+# CONFIG_6PACK is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_9P_FS is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_AB8500_CORE is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_ACENIC is not set
+# CONFIG_ACERHDF is not set
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_ACPI_APEI is not set
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+# CONFIG_ACPI_HED is not set
+# CONFIG_ACPI_POWER_METER is not set
+# CONFIG_ACPI_QUICKSTART is not set
+# CONFIG_AD2S1200 is not set
+# CONFIG_AD2S1210 is not set
+# CONFIG_AD2S90 is not set
+# CONFIG_AD5064 is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_AD5360 is not set
+# CONFIG_AD5380 is not set
+# CONFIG_AD5421 is not set
+# CONFIG_AD5446 is not set
+# CONFIG_AD5449 is not set
+# CONFIG_AD5504 is not set
+# CONFIG_AD5624R_SPI is not set
+# CONFIG_AD5686 is not set
+# CONFIG_AD5755 is not set
+# CONFIG_AD5764 is not set
+# CONFIG_AD5791 is not set
+# CONFIG_AD5930 is not set
+# CONFIG_AD5933 is not set
+# CONFIG_AD7150 is not set
+# CONFIG_AD7152 is not set
+# CONFIG_AD7192 is not set
+# CONFIG_AD7266 is not set
+# CONFIG_AD7280 is not set
+# CONFIG_AD7291 is not set
+# CONFIG_AD7298 is not set
+# CONFIG_AD7476 is not set
+# CONFIG_AD7606 is not set
+# CONFIG_AD7746 is not set
+# CONFIG_AD7780 is not set
+# CONFIG_AD7791 is not set
+# CONFIG_AD7793 is not set
+# CONFIG_AD7816 is not set
+# CONFIG_AD7887 is not set
+# CONFIG_AD7923 is not set
+# CONFIG_AD799X is not set
+# CONFIG_AD8366 is not set
+# CONFIG_AD9523 is not set
+# CONFIG_AD9832 is not set
+# CONFIG_AD9834 is not set
+# CONFIG_AD9850 is not set
+# CONFIG_AD9852 is not set
+# CONFIG_AD9910 is not set
+# CONFIG_AD9951 is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_ADE7753 is not set
+# CONFIG_ADE7754 is not set
+# CONFIG_ADE7758 is not set
+# CONFIG_ADE7759 is not set
+# CONFIG_ADE7854 is not set
+# CONFIG_ADF4350 is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADIS16060 is not set
+# CONFIG_ADIS16080 is not set
+# CONFIG_ADIS16130 is not set
+# CONFIG_ADIS16136 is not set
+# CONFIG_ADIS16201 is not set
+# CONFIG_ADIS16203 is not set
+# CONFIG_ADIS16204 is not set
+# CONFIG_ADIS16209 is not set
+# CONFIG_ADIS16220 is not set
+# CONFIG_ADIS16240 is not set
+# CONFIG_ADIS16255 is not set
+# CONFIG_ADIS16260 is not set
+# CONFIG_ADIS16400 is not set
+# CONFIG_ADIS16480 is not set
+# CONFIG_ADJD_S311 is not set
+# CONFIG_ADM6996_PHY is not set
+# CONFIG_ADM8211 is not set
+# CONFIG_ADT7316 is not set
+# CONFIG_ADXRS450 is not set
+CONFIG_AEABI=y
+# CONFIG_AFFS_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AGP is not set
+CONFIG_AIO=y
+# CONFIG_AIRO is not set
+# CONFIG_AIRO_CS is not set
+# CONFIG_AK8975 is not set
+# CONFIG_ALCHEMY_GPIO_INDIRECT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_ALX is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_AMILO_RFKILL is not set
+# CONFIG_ANDROID is not set
+CONFIG_ANON_INODES=y
+# CONFIG_APDS9802ALS is not set
+# CONFIG_APM8018X is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_AR7 is not set
+# CONFIG_AR8216_PHY is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCM2835 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_EXYNOS is not set
+CONFIG_ARCH_FLATMEM_ENABLE=y
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_OMAP1 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCNET is not set
+# CONFIG_ARM_ARCH_TIMER is not set
+# CONFIG_ARM_AT91_ETHER is not set
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+# CONFIG_ARM_ERRATA_326103 is not set
+# CONFIG_ARM_ERRATA_364296 is not set
+# CONFIG_ARM_ERRATA_411920 is not set
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_643719 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+# CONFIG_ARM_ERRATA_775420 is not set
+# CONFIG_ARM_ERRATA_798181 is not set
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+# CONFIG_ARM_PSCI is not set
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_ARM_VIRT_EXT is not set
+CONFIG_ARPD=y
+# CONFIG_ARTHUR is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_ASYNC_RAID6_TEST is not set
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_ATA is not set
+CONFIG_ATAGS_PROC=y
+# CONFIG_ATALK is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_ATA_ACPI is not set
+CONFIG_ATA_BMDMA=y
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_ATA_NONSTANDARD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_ATA_PIIX is not set
+CONFIG_ATA_SFF=y
+# CONFIG_ATA_VERBOSE_ERROR is not set
+# CONFIG_ATH5K is not set
+# CONFIG_ATH6K_LEGACY is not set
+# CONFIG_ATH79 is not set
+# CONFIG_ATH9K is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1C is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL2 is not set
+# CONFIG_ATM is not set
+# CONFIG_ATMEL is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ATM_AMBASSADOR is not set
+# CONFIG_ATM_BR2684 is not set
+CONFIG_ATM_BR2684_IPFILTER=y
+# CONFIG_ATM_CLIP is not set
+CONFIG_ATM_CLIP_NO_ICMP=y
+# CONFIG_ATM_DRIVERS is not set
+# CONFIG_ATM_DUMMY is not set
+# CONFIG_ATM_ENI is not set
+# CONFIG_ATM_FIRESTREAM is not set
+# CONFIG_ATM_FORE200E is not set
+# CONFIG_ATM_HE is not set
+# CONFIG_ATM_HORIZON is not set
+# CONFIG_ATM_IA is not set
+# CONFIG_ATM_IDT77252 is not set
+# CONFIG_ATM_LANAI is not set
+# CONFIG_ATM_LANE is not set
+# CONFIG_ATM_MPOA is not set
+# CONFIG_ATM_NICSTAR is not set
+# CONFIG_ATM_SOLOS is not set
+# CONFIG_ATM_TCP is not set
+# CONFIG_ATM_ZATM is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_ATP is not set
+# CONFIG_AUDIT is not set
+# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_AUTO_ZRELADDR is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_AVERAGE is not set
+# CONFIG_AX25 is not set
+# CONFIG_AX25_DAMA_SLAVE is not set
+# CONFIG_AX88796 is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_B44 is not set
+# CONFIG_B53 is not set
+# CONFIG_B53_SPI_DRIVER is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_BACKLIGHT_LM3630 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+CONFIG_BASE_FULL=y
+CONFIG_BASE_SMALL=0
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BAYCOM_EPP is not set
+# CONFIG_BAYCOM_PAR is not set
+# CONFIG_BAYCOM_SER_FDX is not set
+# CONFIG_BAYCOM_SER_HDX is not set
+# CONFIG_BCACHE is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_BCM63XX is not set
+# CONFIG_BCM63XX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BCMA is not set
+# CONFIG_BCMA_DRIVER_GPIO is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_BDI_SWITCH is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BE2NET is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_BGMAC is not set
+# CONFIG_BINARY_PRINTF is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_BITREVERSE=y
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_CPQ_DA is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_BLK_DEV_4DRIVES is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI14XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_CS5535 is not set
+# CONFIG_BLK_DEV_CS5536 is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_DELKIN is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_DTC2278 is not set
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_GENERIC is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_HT6560B is not set
+# CONFIG_BLK_DEV_IDEACPI is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_BLK_DEV_IDEPNP is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDE_AU1XXX is not set
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_BLK_DEV_IT8172 is not set
+# CONFIG_BLK_DEV_IT8213 is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_JMICRON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_OFFBOARD is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_PLATFORM is not set
+# CONFIG_BLK_DEV_QD65XX is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_SD is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SL82C105 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_TC86C001 is not set
+# CONFIG_BLK_DEV_THROTTLING is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_UMC8672 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_BLK_DEV_XIP is not set
+CONFIG_BLOCK=y
+# CONFIG_BMP085 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
+# CONFIG_BNA is not set
+# CONFIG_BNX2 is not set
+# CONFIG_BNX2X is not set
+# CONFIG_BONDING is not set
+# CONFIG_BOOKE_WDT is not set
+CONFIG_BOOKE_WDT_DEFAULT_TIMEOUT=3
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_BOOT_RAW=y
+# CONFIG_BPCTL is not set
+# CONFIG_BPF_JIT is not set
+# CONFIG_BPQETHER is not set
+CONFIG_BQL=y
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_BRCMFMAC is not set
+CONFIG_BRIDGE=y
+# CONFIG_BRIDGE_EBT_802_3 is not set
+# CONFIG_BRIDGE_EBT_AMONG is not set
+# CONFIG_BRIDGE_EBT_ARP is not set
+# CONFIG_BRIDGE_EBT_ARPREPLY is not set
+# CONFIG_BRIDGE_EBT_BROUTE is not set
+# CONFIG_BRIDGE_EBT_DNAT is not set
+# CONFIG_BRIDGE_EBT_IP is not set
+# CONFIG_BRIDGE_EBT_IP6 is not set
+# CONFIG_BRIDGE_EBT_LIMIT is not set
+# CONFIG_BRIDGE_EBT_LOG is not set
+# CONFIG_BRIDGE_EBT_MARK is not set
+# CONFIG_BRIDGE_EBT_MARK_T is not set
+# CONFIG_BRIDGE_EBT_NFLOG is not set
+# CONFIG_BRIDGE_EBT_PKTTYPE is not set
+# CONFIG_BRIDGE_EBT_REDIRECT is not set
+# CONFIG_BRIDGE_EBT_SNAT is not set
+# CONFIG_BRIDGE_EBT_STP is not set
+# CONFIG_BRIDGE_EBT_T_FILTER is not set
+# CONFIG_BRIDGE_EBT_T_NAT is not set
+# CONFIG_BRIDGE_EBT_ULOG is not set
+# CONFIG_BRIDGE_EBT_VLAN is not set
+# CONFIG_BRIDGE_IGMP_SNOOPING is not set
+# CONFIG_BRIDGE_NETFILTER is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_BRIDGE_VLAN_FILTERING is not set
+# CONFIG_BROADCOM_PHY is not set
+CONFIG_BROKEN_ON_SMP=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_BT is not set
+# CONFIG_BTRFS_DEBUG is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
+# CONFIG_BT_ATH3K is not set
+# CONFIG_BT_BNEP is not set
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+# CONFIG_BT_CMTP is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIBLUECARD is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBT3C is not set
+# CONFIG_BT_HCIBTSDIO is not set
+# CONFIG_BT_HCIBTUART is not set
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIDTL1 is not set
+# CONFIG_BT_HCIUART is not set
+# CONFIG_BT_HCIUART_3WIRE is not set
+# CONFIG_BT_HCIUART_ATH3K is not set
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_HIDP is not set
+CONFIG_BT_L2CAP=y
+# CONFIG_BT_MRVL is not set
+# CONFIG_BT_RFCOMM is not set
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_SCO=y
+CONFIG_BUG=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+# CONFIG_C2PORT is not set
+# CONFIG_CAIF is not set
+# CONFIG_CAN is not set
+# CONFIG_CAPI_AVM is not set
+# CONFIG_CAPI_EICON is not set
+# CONFIG_CAPI_TRACE is not set
+CONFIG_CARDBUS=y
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_CARMA_FPGA is not set
+# CONFIG_CARMA_FPGA_PROGRAM is not set
+# CONFIG_CASSINI is not set
+CONFIG_CAVIUM_OCTEON_HELPER=y
+# CONFIG_CAVIUM_OCTEON_REFERENCE_BOARD is not set
+# CONFIG_CAVIUM_OCTEON_SIMULATOR is not set
+# CONFIG_CB710_CORE is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_CED1401 is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_CFG80211 is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CIFS is not set
+# CONFIG_CIFS_DEBUG is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_NFSD_EXPORT is not set
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_SMB2 is not set
+CONFIG_CIFS_STATS=y
+# CONFIG_CIFS_STATS2 is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CLEANCACHE is not set
+CONFIG_CLS_U32_MARK=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CMA is not set
+CONFIG_CMDLINE=""
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_CMDLINE_FROM_BOOTLOADER is not set
+# CONFIG_CNIC is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_CODE_PATCHING_SELFTEST is not set
+# CONFIG_COMEDI is not set
+# CONFIG_COMMON_CLK_DEBUG is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMPACTION is not set
+# CONFIG_COMPAL_LAPTOP is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_CONFIGFS_FS is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_CONSTRUCTORS=y
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_COPS is not set
+# CONFIG_CORDIC is not set
+# CONFIG_COREDUMP is not set
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_CPA_DEBUG is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_IDLE is not set
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_CRASHLOG=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_BIT is not set
+CONFIG_CRC32_SARWATE=y
+# CONFIG_CRC32_SELFTEST is not set
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SLICEBY8 is not set
+# CONFIG_CRC7 is not set
+# CONFIG_CRC8 is not set
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC_ITU_T is not set
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CROSS_COMPILE=""
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_AEAD is not set
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_586 is not set
+# CONFIG_CRYPTO_AES_ARM is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_BLKCIPHER is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_MV_CESA is not set
+# CONFIG_CRYPTO_DEV_TALITOS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_FIPS is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+# CONFIG_CRYPTO_HASH is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_PCOMP is not set
+# CONFIG_CRYPTO_PCOMP2 is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_RNG is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_586 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_ARM is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+# CONFIG_CRYPTO_TWOFISH_COMMON is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_VMAC is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_XZ is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYSTALHD is not set
+# CONFIG_CS5535_MFGPT is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_CUSE is not set
+# CONFIG_CXT1E1 is not set
+# CONFIG_CYPRESS_FIRMWARE is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DCB is not set
+# CONFIG_DDR is not set
+# CONFIG_DE600 is not set
+# CONFIG_DE620 is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_DEBUG_INFO is not set
+CONFIG_DEBUG_INFO_REDUCED=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_DEBUG_LOCKDEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_NX_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RODATA is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_DEBUG_SEMIHOSTING is not set
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_ZBOOT is not set
+# CONFIG_DECNET is not set
+CONFIG_DEFAULT_CUBIC=y
+CONFIG_DEFAULT_DEADLINE=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_DEFAULT_IOSCHED="deadline"
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_DEFAULT_NOOP is not set
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_DEVPORT=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_DEVTMPFS is not set
+# CONFIG_DEVTMPFS_MOUNT is not set
+# CONFIG_DGRP is not set
+# CONFIG_DIRECT_IO is not set
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_DL2K is not set
+# CONFIG_DLM is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_DMADEVICES_DEBUG is not set
+# CONFIG_DMASCC is not set
+# CONFIG_DMATEST is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_DMA_ENGINE is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_DM_CACHE is not set
+# CONFIG_DM_DEBUG is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_VERITY is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DNET is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_DNS_RESOLVER is not set
+CONFIG_DQL=y
+# CONFIG_DRAGONRISE_FF is not set
+# CONFIG_DRM is not set
+# CONFIG_DS1682 is not set
+# CONFIG_DTLK is not set
+# CONFIG_DUMMY is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DVB_DUMMY_FE is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_DX_SEP is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_E2100 is not set
+# CONFIG_EASYCAP is not set
+# CONFIG_ECHO is not set
+# CONFIG_ECONET is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_EDAC is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_DIGSY_MTC_CFG is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEXPRESS is not set
+# CONFIG_EEXPRESS_PRO is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_EFS_FS is not set
+# CONFIG_ELF_CORE is not set
+CONFIG_EMBEDDED=y
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+# CONFIG_ENC28J60 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_ENIC is not set
+# CONFIG_EPAPR_PARAVIRT is not set
+# CONFIG_EPIC100 is not set
+CONFIG_EPOLL=y
+# CONFIG_EQUALIZER is not set
+# CONFIG_ET131X is not set
+# CONFIG_ETH16I is not set
+CONFIG_ETHERNET=y
+# CONFIG_ETHOC is not set
+CONFIG_EVENTFD=y
+# CONFIG_EVENT_POWER_TRACING_DEPRECATED is not set
+# CONFIG_EWRK3 is not set
+CONFIG_EXPERIMENTAL=y
+CONFIG_EXPERT=y
+# CONFIG_EXPORTFS is not set
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4_DEBUG is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+# CONFIG_EXTCON is not set
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_EXTRA_TARGETS=""
+# CONFIG_EXYNOS_ADC is not set
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_FAIR_GROUP_SCHED is not set
+# CONFIG_FANOTIFY is not set
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_FS is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_FB is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_GEODE is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_OF is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_PS3 is not set
+# CONFIG_FB_PXA is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_XGI is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+# CONFIG_FDDI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_FHANDLE is not set
+CONFIG_FIB_RULES=y
+CONFIG_FILE_LOCKING=y
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_FIREWIRE_SERIAL is not set
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FIXED_PHY is not set
+CONFIG_FLATMEM=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_FORCEDETH is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_FRAME_POINTER is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_FREEZER is not set
+# CONFIG_FRONTSWAP is not set
+# CONFIG_FSCACHE is not set
+# CONFIG_FSL_XGMAC_MDIO is not set
+CONFIG_FSNOTIFY=y
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_FT1000 is not set
+# CONFIG_FTGMAC100 is not set
+# CONFIG_FTL is not set
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTRACE is not set
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_FTR_FIXUP_SELFTEST is not set
+# CONFIG_FUJITSU_TABLET is not set
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+# CONFIG_FUSION_SPI is not set
+CONFIG_FUTEX=y
+CONFIG_FW_LOADER=y
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_GACT_PROB=y
+# CONFIG_GADGET_UAC1 is not set
+# CONFIG_GAMEPORT is not set
+# CONFIG_GCOV is not set
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_TIME=y
+# CONFIG_GFS2_FS is not set
+# CONFIG_GIGASET_CAPI is not set
+# CONFIG_GIGASET_DEBUG is not set
+# CONFIG_GPIOLIB is not set
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_AMD8111 is not set
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_CS5535 is not set
+# CONFIG_GPIO_EM is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_ICH is not set
+# CONFIG_GPIO_IT8761E is not set
+# CONFIG_GPIO_LANGWELL is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_PCH is not set
+# CONFIG_GPIO_PL061 is not set
+# CONFIG_GPIO_RCAR is not set
+# CONFIG_GPIO_RDC321X is not set
+# CONFIG_GPIO_SCH is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_SYSFS is not set
+# CONFIG_GPIO_TS5500 is not set
+# CONFIG_GPIO_VX855 is not set
+# CONFIG_GPIO_WDT is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GREENASIA_FF is not set
+# CONFIG_HAMACHI is not set
+CONFIG_HAMRADIO=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_HAVE_ARM_ARCH_TIMER is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_HCALL_STATS is not set
+# CONFIG_HDLC is not set
+# CONFIG_HDLC_CISCO is not set
+# CONFIG_HDLC_FR is not set
+# CONFIG_HDLC_PPP is not set
+# CONFIG_HDLC_RAW is not set
+# CONFIG_HDLC_RAW_ETH is not set
+# CONFIG_HDQ_MASTER_OMAP is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_HERMES is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HIBERNATION is not set
+# CONFIG_HID is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_ACRUX_FF is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GENERIC is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PID is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_PS3REMOTE is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_ARVO is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_HIGH_RES_TIMERS=y
+# CONFIG_HIPPI is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_HOSTAP_CS is not set
+# CONFIG_HOSTAP_PCI is not set
+# CONFIG_HOSTAP_PLX is not set
+CONFIG_HOTPLUG=y
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_HP100 is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_HPLAN is not set
+# CONFIG_HPLAN_PLUS is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_HSI is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_HVC_UDBG is not set
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWSPINLOCK_OMAP is not set
+CONFIG_HW_PERF_EVENTS=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HW_RANDOM_AMD is not set
+# CONFIG_HW_RANDOM_ATMEL is not set
+# CONFIG_HW_RANDOM_EXYNOS is not set
+# CONFIG_HW_RANDOM_GEODE is not set
+# CONFIG_HW_RANDOM_INTEL is not set
+# CONFIG_HW_RANDOM_PPC4XX is not set
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_VIA is not set
+# CONFIG_HYPERV is not set
+# CONFIG_HYSDN is not set
+CONFIG_HZ=100
+CONFIG_HZ_100=y
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_48 is not set
+# CONFIG_HZ_PERIODIC is not set
+# CONFIG_I2C is not set
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_COMPAT is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_EG20T is not set
+# CONFIG_I2C_ELEKTOR is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_HID is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_IBM_IIC is not set
+# CONFIG_I2C_INTEL_MID is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_ISMT is not set
+# CONFIG_I2C_MPC is not set
+# CONFIG_I2C_MUX is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MV64XXX is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PCA_ISA is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SCMI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_SMBUS is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_VERSATILE is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I2O is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_IBM_EMAC_DEBUG is not set
+# CONFIG_IBM_EMAC_EMAC4 is not set
+# CONFIG_IBM_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_IBM_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_EMAC_RGMII is not set
+# CONFIG_IBM_EMAC_TAH is not set
+# CONFIG_IBM_EMAC_ZMII is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_IDE is not set
+# CONFIG_IDEAPAD_LAPTOP is not set
+# CONFIG_IDE_GD is not set
+# CONFIG_IDE_PHISON is not set
+# CONFIG_IDE_PROC_FS is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_IFB is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IIO is not set
+# CONFIG_IKCONFIG is not set
+# CONFIG_IKCONFIG_PROC is not set
+# CONFIG_IMAGE_CMDLINE_HACK is not set
+CONFIG_INET=y
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_TCP_DIAG is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_INFTL is not set
+# CONFIG_INITRAMFS_COMPRESSION_BZIP2 is not set
+# CONFIG_INITRAMFS_COMPRESSION_GZIP is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZMA is not set
+CONFIG_INITRAMFS_COMPRESSION_NONE=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_APANEL is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_WISTRON_BTNS is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INTEL_IDLE is not set
+# CONFIG_INTEL_MEI is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_INTEL_OAKTRAIL is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_INV_MPU6050_IIO is not set
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IP1000 is not set
+# CONFIG_IP17XX_PHY is not set
+# CONFIG_IP6_NF_FILTER is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP6_NF_MANGLE is not set
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_RAW is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+# CONFIG_IP6_NF_TARGET_LOG is not set
+# CONFIG_IP6_NF_TARGET_REJECT is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPV6 is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_MROUTE_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_ROUTE_INFO is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_SIT_6RD is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2100_DEBUG is not set
+CONFIG_IPW2100_MONITOR=y
+# CONFIG_IPW2200 is not set
+# CONFIG_IPW2200_DEBUG is not set
+CONFIG_IPW2200_MONITOR=y
+# CONFIG_IPW2200_PROMISCUOUS is not set
+# CONFIG_IPW2200_QOS is not set
+# CONFIG_IPW2200_RADIOTAP is not set
+# CONFIG_IPWIRELESS is not set
+# CONFIG_IPX is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_NF_ARPFILTER is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_NF_ARP_MANGLE is not set
+# CONFIG_IP_NF_FILTER is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_SECURITY is not set
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_LOG is not set
+# CONFIG_IP_NF_TARGET_MASQUERADE is not set
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+# CONFIG_IP_NF_TARGET_REDIRECT is not set
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+# CONFIG_IP_PIMSM_V1 is not set
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_IP_PNP is not set
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_SCTP is not set
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+# CONFIG_IRDA is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_JVC_DECODER is not set
+# CONFIG_IR_LIRC_CODEC is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_NEC_DECODER is not set
+# CONFIG_IR_RC5_DECODER is not set
+# CONFIG_IR_RC5_SZ_DECODER is not set
+# CONFIG_IR_RC6_DECODER is not set
+# CONFIG_IR_SONY_DECODER is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_ISCSI_TCP is not set
+CONFIG_ISDN=y
+# CONFIG_ISDN_AUDIO is not set
+# CONFIG_ISDN_CAPI is not set
+# CONFIG_ISDN_CAPI_CAPIDRV is not set
+# CONFIG_ISDN_DIVERSION is not set
+# CONFIG_ISDN_DRV_ACT2000 is not set
+# CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON is not set
+# CONFIG_ISDN_DRV_GIGASET is not set
+# CONFIG_ISDN_DRV_HISAX is not set
+# CONFIG_ISDN_DRV_ICN is not set
+# CONFIG_ISDN_DRV_LOOP is not set
+# CONFIG_ISDN_DRV_PCBIT is not set
+# CONFIG_ISDN_DRV_SC is not set
+# CONFIG_ISDN_I4L is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_ISO9660_FS is not set
+# CONFIG_ISS4xx is not set
+# CONFIG_ITG3200 is not set
+# CONFIG_IWL3945 is not set
+# CONFIG_IWLAGN is not set
+# CONFIG_IWLWIFI is not set
+# CONFIG_IWMC3200TOP is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD2_DEBUG is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_POSIX_ACL is not set
+# CONFIG_JFFS2_FS_SECURITY is not set
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_JFFS2_LZMA=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_ZLIB is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_POSIX_ACL is not set
+# CONFIG_JFS_SECURITY is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_JME is not set
+CONFIG_JOLIET=y
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_KALLSYMS is not set
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_UNCOMPRESSED is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KEXEC is not set
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_KGDB is not set
+# CONFIG_KMEMCHECK is not set
+# CONFIG_KPROBES is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_KSM is not set
+# CONFIG_KSZ884X_PCI is not set
+CONFIG_KUSER_HELPERS=y
+# CONFIG_KVM_GUEST is not set
+# CONFIG_KXSD9 is not set
+# CONFIG_L2TP is not set
+# CONFIG_L2TP_ETH is not set
+# CONFIG_L2TP_IP is not set
+# CONFIG_L2TP_V3 is not set
+# CONFIG_LANMEDIA is not set
+# CONFIG_LANTIQ is not set
+# CONFIG_LAPB is not set
+# CONFIG_LASAT is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+CONFIG_LBDAF=y
+# CONFIG_LCD_HX8357 is not set
+# CONFIG_LCD_ILI922X is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_LMS501KF03 is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_BLINKM is not set
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_GPIO is not set
+CONFIG_LEDS_GPIO_OF=y
+CONFIG_LEDS_GPIO_PLATFORM=y
+# CONFIG_LEDS_INTEL_SS4200 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3556 is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_NET5501 is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+# CONFIG_LEDS_TRIGGER_CPU is not set
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_IDE_DISK is not set
+# CONFIG_LEDS_TRIGGER_MORSE is not set
+CONFIG_LEDS_TRIGGER_NETDEV=y
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+CONFIG_LEDS_TRIGGER_TIMER=y
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEDS_TRIGGER_USBDEV is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_LIB80211 is not set
+# CONFIG_LIB80211_CRYPT_CCMP is not set
+# CONFIG_LIB80211_CRYPT_TKIP is not set
+# CONFIG_LIB80211_CRYPT_WEP is not set
+# CONFIG_LIB80211_DEBUG is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_LIBERTAS_USB is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_LIBIPW_DEBUG is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_LIRC_STAGING is not set
+# CONFIG_LIS3L02DQ is not set
+# CONFIG_LKDTM is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_LOCKD is not set
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_LOCKD_V4=y
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_LOGFS is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGO is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_LOONGSON_MC146818 is not set
+# CONFIG_LP486E is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_LP_CONSOLE is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_LTPC is not set
+# CONFIG_LXT_PHY is not set
+CONFIG_LZMA_COMPRESS=y
+CONFIG_LZMA_DECOMPRESS=y
+# CONFIG_LZO_COMPRESS is not set
+# CONFIG_LZO_DECOMPRESS is not set
+# CONFIG_M25PXX_PREFER_SMALL_SECTOR_ERASE is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_MACB is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_MACH_JZ4740 is not set
+# CONFIG_MACH_LOONGSON is not set
+# CONFIG_MACH_LOONGSON1 is not set
+# CONFIG_MACH_NO_WESTBRIDGE is not set
+# CONFIG_MACH_TX39XX is not set
+# CONFIG_MACH_TX49XX is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_MACVTAP is not set
+# CONFIG_MAC_EMUMOUSEBTN is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_MAILBOX is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MAX1363 is not set
+# CONFIG_MAX517 is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_MCP4725 is not set
+# CONFIG_MCPM is not set
+# CONFIG_MD is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MD_FAULTY is not set
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_ATTACH is not set
+# CONFIG_MEDIA_CAMERA_SUPPORT is not set
+# CONFIG_MEDIA_CONTROLLER is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_PARPORT_SUPPORT is not set
+# CONFIG_MEDIA_PCI_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_RC_SUPPORT is not set
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+# CONFIG_MEDIA_SUPPORT is not set
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+# CONFIG_MEDIA_USB_SUPPORT is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_MEMORY is not set
+# CONFIG_MEMORY_FAILURE is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MC13783 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_TIMBERDALE is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MIGRATION is not set
+CONFIG_MII=y
+# CONFIG_MIKROTIK_RB532 is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_MINIX_FS_NATIVE_ENDIAN is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_MIPS_ALCHEMY is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MIPS_FPU_EMU is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD3 is not set
+# CONFIG_MIPS_SIM is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_MISDN is not set
+# CONFIG_MISDN_AVMFRITZ is not set
+# CONFIG_MISDN_HFCPCI is not set
+# CONFIG_MISDN_HFCUSB is not set
+# CONFIG_MISDN_INFINEON is not set
+# CONFIG_MISDN_NETJET is not set
+# CONFIG_MISDN_SPEEDFAX is not set
+# CONFIG_MISDN_W6692 is not set
+# CONFIG_MKISS is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_MLX4_EN is not set
+# CONFIG_MMC is not set
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_AU1X is not set
+# CONFIG_MMC_BLOCK is not set
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_CLKGATE is not set
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_MVSDIO is not set
+# CONFIG_MMC_S3C is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDRICOH_CS is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+# CONFIG_MMC_VUB300 is not set
+CONFIG_MMU=y
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_MODULE_STRIPPED=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_INPORT is not set
+# CONFIG_MOUSE_LOGIBM is not set
+# CONFIG_MOUSE_PC110PAD is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+# CONFIG_MSDOS_FS is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_MSI_BITMAP_SELFTEST is not set
+# CONFIG_MSI_LAPTOP is not set
+CONFIG_MTD=y
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_AR7_PARTS is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_MTD_BLOCK2MTD is not set
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_MTD_CHAR=y
+# CONFIG_MTD_CMDLINE_PARTS is not set
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_GPIO_ADDR is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_JEDECPROBE is not set
+# CONFIG_MTD_LATCH_ADDR is not set
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_M25P80 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_MYLOADER_PARTS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_NAND_AMS_DELTA is not set
+# CONFIG_MTD_NAND_AR934X is not set
+# CONFIG_MTD_NAND_ATMEL is not set
+# CONFIG_MTD_NAND_AU1550 is not set
+# CONFIG_MTD_NAND_AUTCPU12 is not set
+# CONFIG_MTD_NAND_BCH is not set
+# CONFIG_MTD_NAND_BCM_UMI is not set
+# CONFIG_MTD_NAND_BF5XX is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_CM_X270 is not set
+# CONFIG_MTD_NAND_CS553X is not set
+# CONFIG_MTD_NAND_DAVINCI is not set
+# CONFIG_MTD_NAND_DENALI is not set
+CONFIG_MTD_NAND_DENALI_SCRATCH_REG_ADDR=0xff108018
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_DOCG4 is not set
+# CONFIG_MTD_NAND_ECC is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_FSL_ELBC is not set
+# CONFIG_MTD_NAND_FSL_IFC is not set
+# CONFIG_MTD_NAND_FSL_UPM is not set
+# CONFIG_MTD_NAND_FSMC is not set
+# CONFIG_MTD_NAND_GPIO is not set
+# CONFIG_MTD_NAND_GPMI_NAND is not set
+# CONFIG_MTD_NAND_H1900 is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_JZ4740 is not set
+# CONFIG_MTD_NAND_MPC5121_NFC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_MXC is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_NDFC is not set
+# CONFIG_MTD_NAND_NOMADIK is not set
+# CONFIG_MTD_NAND_NUC900 is not set
+# CONFIG_MTD_NAND_OMAP2 is not set
+# CONFIG_MTD_NAND_ORION is not set
+# CONFIG_MTD_NAND_PASEMI is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_NAND_PPCHAMELEONEVB is not set
+# CONFIG_MTD_NAND_PXA3xx is not set
+# CONFIG_MTD_NAND_RB4XX is not set
+# CONFIG_MTD_NAND_RB750 is not set
+# CONFIG_MTD_NAND_RICOH is not set
+# CONFIG_MTD_NAND_RTC_FROM4 is not set
+# CONFIG_MTD_NAND_S3C2410 is not set
+# CONFIG_MTD_NAND_SHARPSL is not set
+# CONFIG_MTD_NAND_SH_FLCTL is not set
+# CONFIG_MTD_NAND_SOCRATES is not set
+# CONFIG_MTD_NAND_SPIA is not set
+# CONFIG_MTD_NAND_TMIO is not set
+# CONFIG_MTD_NAND_TXX9NDFMC is not set
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_ONENAND is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_PCI is not set
+# CONFIG_MTD_PCMCIA is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_RAM is not set
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_ROM is not set
+CONFIG_MTD_ROOTFS_ROOT_DEV=y
+CONFIG_MTD_ROOTFS_SPLIT=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_SPLIT_FIRMWARE is not set
+CONFIG_MTD_SPLIT_FIRMWARE_NAME="firmware"
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SWAP is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_UBI is not set
+# CONFIG_MTD_UIMAGE_SPLIT is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_MV643XX_ETH is not set
+# CONFIG_MVMDIO is not set
+# CONFIG_MVSWITCH_PHY is not set
+# CONFIG_MWAVE is not set
+# CONFIG_MWL8K is not set
+# CONFIG_MYRI10GE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NE2000 is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_NEC_MARKEINS is not set
+CONFIG_NET=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NETDEV_1000=y
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_NETLINK is not set
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE_CT is not set
+# CONFIG_NETFILTER_TPROXY is not set
+# CONFIG_NETFILTER_XTABLES is not set
+# CONFIG_NETFILTER_XT_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+# CONFIG_NETFILTER_XT_MATCH_HL is not set
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7 is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_REDIRECT is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NETROM is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_NET_9P is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+CONFIG_NET_CADENCE=y
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_ACT is not set
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_IND=y
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_U32 is not set
+CONFIG_NET_CORE=y
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_TAG_DSA is not set
+# CONFIG_NET_DSA_TAG_EDSA is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_TEXT is not set
+# CONFIG_NET_EMATCH_U32 is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_NET_FC is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_NET_IPGRE_BROADCAST=y
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_IP_TUNNEL is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_KEY is not set
+# CONFIG_NET_KEY_MIGRATE is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+CONFIG_NET_PCI=y
+# CONFIG_NET_PCMCIA is not set
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_POCKET is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_NET_SCHED=y
+# CONFIG_NET_SCH_ATM is not set
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_ESFQ is not set
+CONFIG_NET_SCH_ESFQ_NFCT=y
+CONFIG_NET_SCH_FIFO=y
+CONFIG_NET_SCH_FQ_CODEL=y
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_PLUG is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_NET_TULIP is not set
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_NET_VENDOR_8390=y
+CONFIG_NET_VENDOR_ADAPTEC=y
+CONFIG_NET_VENDOR_ALTEON=y
+CONFIG_NET_VENDOR_AMD=y
+CONFIG_NET_VENDOR_ATHEROS=y
+CONFIG_NET_VENDOR_BROADCOM=y
+CONFIG_NET_VENDOR_BROCADE=y
+CONFIG_NET_VENDOR_CHELSIO=y
+CONFIG_NET_VENDOR_CIRRUS=y
+CONFIG_NET_VENDOR_CISCO=y
+CONFIG_NET_VENDOR_DEC=y
+CONFIG_NET_VENDOR_DLINK=y
+CONFIG_NET_VENDOR_EMULEX=y
+CONFIG_NET_VENDOR_EXAR=y
+CONFIG_NET_VENDOR_FARADAY=y
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_NET_VENDOR_FUJITSU=y
+CONFIG_NET_VENDOR_HP=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_IBM=y
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_NET_VENDOR_MELLANOX=y
+CONFIG_NET_VENDOR_MICREL=y
+CONFIG_NET_VENDOR_MICROCHIP=y
+CONFIG_NET_VENDOR_MYRI=y
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_NVIDIA=y
+CONFIG_NET_VENDOR_OKI=y
+CONFIG_NET_VENDOR_QLOGIC=y
+CONFIG_NET_VENDOR_RDC=y
+CONFIG_NET_VENDOR_REALTEK=y
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NET_VENDOR_SILAN=y
+CONFIG_NET_VENDOR_SILICOM=y
+CONFIG_NET_VENDOR_SIS=y
+CONFIG_NET_VENDOR_SMSC=y
+CONFIG_NET_VENDOR_STMICRO=y
+CONFIG_NET_VENDOR_SUN=y
+CONFIG_NET_VENDOR_TEHUTI=y
+CONFIG_NET_VENDOR_TI=y
+CONFIG_NET_VENDOR_TOSHIBA=y
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_NET_VENDOR_XILINX=y
+CONFIG_NET_VENDOR_XIRCOM=y
+CONFIG_NEW_LEDS=y
+# CONFIG_NFC is not set
+# CONFIG_NFC_DEVICES is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_DEPRECATED is not set
+# CONFIG_NFSD_V2_ACL is not set
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+# CONFIG_NFS_ACL_SUPPORT is not set
+CONFIG_NFS_COMMON=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V2 is not set
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_NFTL is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IPV4 is not set
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_MARK is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_PROC_COMPAT is not set
+# CONFIG_NF_CONNTRACK_RTSP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CONNTRACK_ZONES is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_GRE is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_NF_NAT is not set
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_FTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_NF_NAT_IPV4=m
+# CONFIG_NF_NAT_IPV6 is not set
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_NEEDED is not set
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_PROTO_GRE is not set
+# CONFIG_NF_NAT_RTSP is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_NF_NAT_SNMP_BASIC is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NI52 is not set
+# CONFIG_NI65 is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_NIU is not set
+CONFIG_NLATTR=y
+# CONFIG_NLM_XLP_BOARD is not set
+# CONFIG_NLM_XLR_BOARD is not set
+# CONFIG_NLS is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_NORTEL_HERMES is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_NO_BOOTMEM is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NO_IOPORT is not set
+# CONFIG_NS83820 is not set
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_NTP_PPS is not set
+# CONFIG_NVRAM is not set
+# CONFIG_NV_TCO is not set
+# CONFIG_NXP_STB220 is not set
+# CONFIG_NXP_STB225 is not set
+# CONFIG_N_GSM is not set
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_OBS600 is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_OCF_BENCH is not set
+# CONFIG_OCF_C7108 is not set
+# CONFIG_OCF_CRYPTOCTEON is not set
+# CONFIG_OCF_EP80579 is not set
+# CONFIG_OCF_HIFN is not set
+# CONFIG_OCF_HIFNHIPP is not set
+# CONFIG_OCF_IXP4XX is not set
+# CONFIG_OCF_KIRKWOOD is not set
+# CONFIG_OCF_OCF is not set
+# CONFIG_OCF_OCFNULL is not set
+# CONFIG_OCF_SAFE is not set
+# CONFIG_OCF_TALITOS is not set
+# CONFIG_OCF_UBSEC_SSB is not set
+# CONFIG_OC_ETM is not set
+# CONFIG_OF_SELFTEST is not set
+# CONFIG_OMAP_CONTROL_USB is not set
+# CONFIG_OMAP_OCP2SCP is not set
+# CONFIG_OMAP_USB2 is not set
+# CONFIG_OMAP_USB3 is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_ORION_WATCHDOG is not set
+# CONFIG_OSF_PARTITION is not set
+CONFIG_OVERLAYFS_FS=y
+# CONFIG_P54_COMMON is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_32KB is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PANEL is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+# CONFIG_PANTHERLORD_FF is not set
+# CONFIG_PARPORT is not set
+# CONFIG_PARPORT_1284 is not set
+# CONFIG_PARPORT_AX88796 is not set
+# CONFIG_PARPORT_PC is not set
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARASAN_CF is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5535 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_ISAPNP is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_LEGACY is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OF_PLATFORM is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PCMCIA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_QDI is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SCH is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+# CONFIG_PATA_WINBOND_VLB is not set
+# CONFIG_PC300TOO is not set
+# CONFIG_PCCARD is not set
+# CONFIG_PCH_GBE is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_PCI200SYN is not set
+# CONFIG_PCIEAER_INJECT is not set
+# CONFIG_PCIEASPM is not set
+# CONFIG_PCIEPORTBUS is not set
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_PCI_ATMEL is not set
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_DISABLE_COMMON_QUIRKS is not set
+# CONFIG_PCI_HERMES is not set
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCI_MSI is not set
+# CONFIG_PCI_PASID is not set
+# CONFIG_PCI_PRI is not set
+CONFIG_PCI_QUIRKS=y
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_PCI_SYSCALL=y
+# CONFIG_PCMCIA is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_ATMEL is not set
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_DEBUG is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+# CONFIG_PCMCIA_HERMES is not set
+# CONFIG_PCMCIA_LOAD_CIS is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_PCNET is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_RAYCS is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_SPECTRUM is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+# CONFIG_PCMCIA_WL3501 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_PCNET32 is not set
+# CONFIG_PCSPKR_PLATFORM is not set
+# CONFIG_PD6729 is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_PDC_ADMA is not set
+# CONFIG_PERF_COUNTERS is not set
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_PHONE is not set
+# CONFIG_PHONET is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_PID_NS is not set
+# CONFIG_PINCTRL is not set
+# CONFIG_PINCTRL_EXYNOS is not set
+# CONFIG_PINCTRL_EXYNOS5440 is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_PLIP is not set
+# CONFIG_PLX_HERMES is not set
+# CONFIG_PM is not set
+# CONFIG_PMBUS is not set
+# CONFIG_PMC_MSP is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_PM_RUNTIME is not set
+# CONFIG_PM_WAKELOCKS is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_POHMELFS is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_POWERTV is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PPC4xx_GPIO is not set
+# CONFIG_PPC_16K_PAGES is not set
+# CONFIG_PPC_256K_PAGES is not set
+CONFIG_PPC_4K_PAGES=y
+# CONFIG_PPC_64K_PAGES is not set
+# CONFIG_PPC_DISABLE_WERROR is not set
+# CONFIG_PPC_EMULATED_STATS is not set
+# CONFIG_PPC_EPAPR_HV_BYTECHAN is not set
+# CONFIG_PPP is not set
+# CONFIG_PPPOATM is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_PPP_ASYNC is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_DEFLATE is not set
+CONFIG_PPP_FILTER=y
+# CONFIG_PPP_MPPE is not set
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPS is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_PARPORT is not set
+# CONFIG_PPS_DEBUG is not set
+# CONFIG_PPTP is not set
+# CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_PRINTK=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_PRINT_STACK_DEPTH=64
+# CONFIG_PRISM2_USB is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_PROBE_INITRD_HEADER is not set
+# CONFIG_PROC_DEVICETREE is not set
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+# CONFIG_PROC_PAGE_MONITOR is not set
+CONFIG_PROC_STRIPPED=y
+CONFIG_PROC_SYSCTL=y
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILING is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_PROVE_RCU is not set
+# CONFIG_PROVE_RCU_DELAY is not set
+# CONFIG_PSB6970_PHY is not set
+# CONFIG_PSTORE is not set
+# CONFIG_PTP_1588_CLOCK is not set
+# CONFIG_PTP_1588_CLOCK_IXP46X is not set
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+# CONFIG_PWM is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_R3964 is not set
+# CONFIG_R6040 is not set
+# CONFIG_R8169 is not set
+# CONFIG_R8187SE is not set
+# CONFIG_R8712U is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_RADIO_AZTECH is not set
+# CONFIG_RADIO_CADET is not set
+# CONFIG_RADIO_GEMTEK is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_RTRACK is not set
+# CONFIG_RADIO_RTRACK2 is not set
+# CONFIG_RADIO_SF16FMI is not set
+# CONFIG_RADIO_SF16FMR2 is not set
+# CONFIG_RADIO_TERRATEC is not set
+# CONFIG_RADIO_TRUST is not set
+# CONFIG_RADIO_TYPHOON is not set
+# CONFIG_RADIO_ZOLTRIX is not set
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_RALINK is not set
+# CONFIG_RAMOOPS is not set
+# CONFIG_RAPIDIO is not set
+# CONFIG_RAR_REGISTER is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_RCU_CPU_STALL_INFO is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_RCU_NOCB_CPU is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_USER_QS is not set
+# CONFIG_RC_CORE is not set
+# CONFIG_RC_MAP is not set
+# CONFIG_RDS is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_REDWOOD is not set
+# CONFIG_REGMAP is not set
+# CONFIG_REGMAP_I2C is not set
+# CONFIG_REGMAP_SPI is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_RELAY is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_RFKILL is not set
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_ROSE is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RT2X00 is not set
+# CONFIG_RTC_CLASS is not set
+# CONFIG_RTC_DEBUG is not set
+# CONFIG_RTC_DRV_AU1XXX is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_EP93XX is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_GENERIC is not set
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_MPC5121 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_PS3 is not set
+# CONFIG_RTC_DRV_PT7C4338 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_RTC7301 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_TEST is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_SYSTOHC=y
+# CONFIG_RTL8180 is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_RTL8192E is not set
+# CONFIG_RTL8192U is not set
+# CONFIG_RTL8306_PHY is not set
+# CONFIG_RTL8366RB_PHY is not set
+# CONFIG_RTL8366S_PHY is not set
+# CONFIG_RTL8366_SMI is not set
+# CONFIG_RTL8366_SMI_DEBUG_FS is not set
+# CONFIG_RTL8367B_PHY is not set
+# CONFIG_RTL8367_PHY is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_RTS5139 is not set
+# CONFIG_RTS_PSTOR is not set
+CONFIG_RT_MUTEXES=y
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_RUNTIME_DEBUG is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_S2IO is not set
+# CONFIG_SAMPLES is not set
+# CONFIG_SAMSUNG_LAPTOP is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_DWC is not set
+# CONFIG_SATA_FSL is not set
+# CONFIG_SATA_HIGHBANK is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PMP is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_SX4 is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_SBC_FITPC2_WATCHDOG is not set
+# CONFIG_SBE_2T3E3 is not set
+# CONFIG_SBYPASS is not set
+# CONFIG_SC92031 is not set
+# CONFIG_SCA3000 is not set
+# CONFIG_SCC is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHED_MC is not set
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_SCHED_SMT is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_7000FASST is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CHELSIO_FCOE is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_LOGGING is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_SCSI_LPFC is not set
+CONFIG_SCSI_MOD=y
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVSAS_DEBUG is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_PMCRAID is not set
+CONFIG_SCSI_PROC_FS=y
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_ULTRASTOR is not set
+CONFIG_SCSI_WAIT_SCAN=m
+# CONFIG_SDIO_UART is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SEEQ8005 is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_ACPI_POWER is not set
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_ADT7310 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATK0110 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_GSC is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_HMC5843 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_IIO_HWMON is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_ISL29018 is not set
+# CONFIG_SENSORS_ISL29028 is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_ACCENT is not set
+# CONFIG_SERIAL_8250_BOCA is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_CS is not set
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_DMA=y
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_EM is not set
+# CONFIG_SERIAL_8250_EXAR_ST16C554 is not set
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_FOURPORT is not set
+# CONFIG_SERIAL_8250_HUB6 is not set
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+CONFIG_SERIAL_8250_NR_UARTS=2
+# CONFIG_SERIAL_8250_PCI is not set
+# CONFIG_SERIAL_8250_RSA is not set
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_SYSRQ is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_GRLIB_GAISLER_APBUART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_SERIAL_OF_PLATFORM is not set
+# CONFIG_SERIAL_OF_PLATFORM_NWPSERIAL is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_UARTLITE is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_AMBAKMI is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_PARKBD is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SFC is not set
+# CONFIG_SFI is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP28 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SGI_PARTITION is not set
+CONFIG_SHMEM=y
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIGMA is not set
+CONFIG_SIGNALFD=y
+# CONFIG_SIMPLE_GPIO is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SIS900 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_SKY2_DEBUG is not set
+CONFIG_SLAB=y
+CONFIG_SLABINFO=y
+# CONFIG_SLHC is not set
+# CONFIG_SLICOSS is not set
+# CONFIG_SLIP is not set
+# CONFIG_SLOB is not set
+# CONFIG_SLUB is not set
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_SMARTJOYPLUS_FF is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMC9194 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_SMP is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_SMSC9420 is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_SND is not set
+# CONFIG_SND_AC97_POWER_SAVE is not set
+# CONFIG_SND_AD1816A is not set
+# CONFIG_SND_AD1848 is not set
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ADLIB is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_ALS100 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_ASIHPI is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_ATMEL_AC97C is not set
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT2320 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMI8330 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_CS4231 is not set
+# CONFIG_SND_CS4236 is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5530 is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1688 is not set
+# CONFIG_SND_ES18XX is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FIREWIRE is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_GUSCLASSIC is not set
+# CONFIG_SND_GUSEXTREME is not set
+# CONFIG_SND_GUSMAX is not set
+# CONFIG_SND_HDA_INTEL is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_HWDEP is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_INTERWAVE is not set
+# CONFIG_SND_INTERWAVE_STB is not set
+# CONFIG_SND_ISA is not set
+# CONFIG_SND_KIRKWOOD_SOC is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_MIPS is not set
+# CONFIG_SND_MIRO is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MPC52xx_SOC_EFIKA is not set
+# CONFIG_SND_MPU401 is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_MTS64 is not set
+# CONFIG_SND_MXS_SOC is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_OPL3SA2 is not set
+# CONFIG_SND_OPTI92X_AD1848 is not set
+# CONFIG_SND_OPTI92X_CS4231 is not set
+# CONFIG_SND_OPTI93X is not set
+CONFIG_SND_OSSEMUL=y
+# CONFIG_SND_OXYGEN is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_PCM is not set
+# CONFIG_SND_PCMCIA is not set
+# CONFIG_SND_PCM_OSS is not set
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_PDAUDIOCF is not set
+# CONFIG_SND_PORTMAN2X4 is not set
+# CONFIG_SND_POWERPC_SOC is not set
+# CONFIG_SND_PPC is not set
+# CONFIG_SND_RAWMIDI is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_RTCTIMER is not set
+# CONFIG_SND_SB16 is not set
+# CONFIG_SND_SB8 is not set
+# CONFIG_SND_SBAWE is not set
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SND_SIS7019 is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SND_SOC_AU1XAUDIO is not set
+# CONFIG_SND_SOC_AU1XPSC is not set
+# CONFIG_SND_SOC_CACHE_LZO is not set
+# CONFIG_SND_SOC_MPC5200_AC97 is not set
+# CONFIG_SND_SOC_MPC5200_I2S is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_SPI is not set
+# CONFIG_SND_SSCAPE is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_TIMER is not set
+# CONFIG_SND_TRIDENT is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_US122L is not set
+# CONFIG_SND_USB_USX2Y is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_VXPOCKET is not set
+# CONFIG_SND_WAVEFRONT is not set
+# CONFIG_SND_YMFPCI is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_SOLO6X10 is not set
+# CONFIG_SONYPI is not set
+# CONFIG_SONY_LAPTOP is not set
+# CONFIG_SOUND is not set
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_SP5100_TCO is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+# CONFIG_SPARSE_IRQ is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_SPEAKUP is not set
+# CONFIG_SPI is not set
+# CONFIG_SPINLOCK_TEST is not set
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AU1550 is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_BUTTERFLY is not set
+# CONFIG_SPI_DEBUG is not set
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_FSL_ESPI is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_GPIO_OLD is not set
+# CONFIG_SPI_LM70_LLP is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_SPI_MPC52xx is not set
+# CONFIG_SPI_MPC52xx_PSC is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_ORION is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PPC4xx is not set
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_RAMIPS is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_XWAY is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_SQUASHFS_LZO is not set
+# CONFIG_SQUASHFS_XATTR is not set
+CONFIG_SQUASHFS_XZ=y
+# CONFIG_SQUASHFS_ZLIB is not set
+# CONFIG_SRAM is not set
+# CONFIG_SSB is not set
+# CONFIG_SSBI is not set
+# CONFIG_SSB_DEBUG is not set
+# CONFIG_SSB_DRIVER_GPIO is not set
+# CONFIG_SSB_PCMCIAHOST is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB_SDIOHOST is not set
+# CONFIG_SSB_SILENT is not set
+# CONFIG_SSFDC is not set
+CONFIG_STACKTRACE_SUPPORT=y
+# CONFIG_STACK_TRACER is not set
+CONFIG_STAGING=y
+# CONFIG_STAGING_MEDIA is not set
+CONFIG_STANDALONE=y
+CONFIG_STDBINUTILS=y
+# CONFIG_STE10XP is not set
+# CONFIG_STE_MODEM_RPROC is not set
+# CONFIG_STMMAC_ETH is not set
+CONFIG_STP=y
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_STUB_POULSBO is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_SUNRPC is not set
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_SUNRPC_GSS is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_SUSPEND is not set
+CONFIG_SWAP=y
+# CONFIG_SWCONFIG is not set
+# CONFIG_SWCONFIG_LEDS is not set
+# CONFIG_SYNCLINK_CS is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_SYSCTL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_SYSFS=y
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_TC35815 is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TCIC is not set
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_TEHUTI is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+CONFIG_TEXTSEARCH=y
+# CONFIG_TEXTSEARCH_BM is not set
+# CONFIG_TEXTSEARCH_FSM is not set
+# CONFIG_TEXTSEARCH_KMP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_TICK_CPU_ACCOUNTING is not set
+CONFIG_TICK_ONESHOT=y
+# CONFIG_TIFM_CORE is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_TIMB_DMA is not set
+CONFIG_TIMERFD=y
+# CONFIG_TIMER_STATS is not set
+CONFIG_TINY_RCU=y
+# CONFIG_TIPC is not set
+# CONFIG_TI_ADC081C is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_TI_ST is not set
+# CONFIG_TLAN is not set
+# CONFIG_TMD_HERMES is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+CONFIG_TMPFS_XATTR=y
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_S3C2410 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WM97XX is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_TR is not set
+# CONFIG_TRACER_SNAPSHOT is not set
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_TRACE_SINK is not set
+CONFIG_TRACING_SUPPORT=y
+CONFIG_TRAD_SIGNALS=y
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_TSL2583 is not set
+# CONFIG_TSL2x7x is not set
+CONFIG_TTY=y
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_TUN is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_TYPHOON is not set
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_UCB1400_CORE is not set
+# CONFIG_UDF_FS is not set
+CONFIG_UDF_NLS=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_UFS_FS is not set
+# CONFIG_UHID is not set
+CONFIG_UIDGID_STRICT_TYPE_CHECKS=y
+# CONFIG_UIO is not set
+# CONFIG_ULTRA is not set
+# CONFIG_ULTRIX_PARTITION is not set
+CONFIG_UNIX=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_USB is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USBPCWATCHDOG is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_ADUTUX is not set
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_ATM is not set
+CONFIG_USB_BELKIN=y
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_CXACRU is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_DEFAULT_PERSIST=y
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_DUMMY_HCD is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC_OTG_LPM is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_EHCI_HCD_PPC_OF is not set
+# CONFIG_USB_EHCI_MV is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_ET61X251 is not set
+CONFIG_USB_EZUSB=y
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_USB_GADGET_VBUS_DRAW=2
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_GSPCA is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_G_WEBCAM is not set
+# CONFIG_USB_HID is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_INPUT_IMS_PCU is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_IP_COMMON is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_KC2190 is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LIBUSUAL is not set
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET_AX88179_178A is not set
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_CDC_MBIM is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_QMI_WWAN is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_OHCI_HCD_PCI is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF_BE is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF_LE is not set
+# CONFIG_USB_OHCI_HCD_PPC_SOC is not set
+# CONFIG_USB_OHCI_HCD_SSB is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_PHY is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_PWC_INPUT_EVDEV is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_RCAR_PHY is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SERIAL is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7715_PARPORT is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QT2 is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+CONFIG_USB_SERIAL_SAFE_PADDED=y
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_WISHBONE is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_XSENS_MT is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_ZTE is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_SPEEDTOUCH is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_TMC is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_UEAGLEATM is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_USS720 is not set
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+# CONFIG_USB_VL600 is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_WPAN_HCD is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+# CONFIG_USB_XHCI_HCD is not set
+# CONFIG_USB_XUSBATM is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USE_GENERIC_SMP_HELPERS is not set
+# CONFIG_USE_OF is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_UWB is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+# CONFIG_VCNL4000 is not set
+# CONFIG_VETH is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VGA_ARB is not set
+# CONFIG_VGA_SWITCHEROO is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_ADV7183 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_ADV7393 is not set
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_AK881X is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT848 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_BWQCAM is not set
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_VIDEO_CAPTURE_DRIVERS is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CQCAM is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_CX2341X is not set
+# CONFIG_VIDEO_CX25840 is not set
+# CONFIG_VIDEO_CX88 is not set
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_VIDEO_DT3155 is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_GO7007 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+# CONFIG_VIDEO_HEXIUM_GEMINI is not set
+# CONFIG_VIDEO_HEXIUM_ORION is not set
+# CONFIG_VIDEO_IR_I2C is not set
+# CONFIG_VIDEO_IVTV is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_MEDIA is not set
+# CONFIG_VIDEO_MEM2MEM_TESTDEV is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_MXB is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_VIDEO_OV7640 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_PMS is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_SAA6588 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7134 is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_SH_MOBILE_CEU is not set
+# CONFIG_VIDEO_SONY_BTF_MPX is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_TIMBERDALE is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_TM6000 is not set
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_TW2804 is not set
+# CONFIG_VIDEO_TW9903 is not set
+# CONFIG_VIDEO_TW9906 is not set
+# CONFIG_VIDEO_UDA1342 is not set
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_VIDEO_V4L2 is not set
+# CONFIG_VIDEO_V4L2_COMMON is not set
+# CONFIG_VIDEO_V4L2_INT_DEVICE is not set
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+# CONFIG_VIDEO_VPX3220 is not set
+# CONFIG_VIDEO_VS6624 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIRQ_DEBUG is not set
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTUALIZATION is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_VITESSE_PHY is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_VMSPLIT_1G is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_2G_OPT is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_VORTEX is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_VT is not set
+# CONFIG_VT6655 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_VXGE is not set
+# CONFIG_VXLAN is not set
+# CONFIG_W1 is not set
+# CONFIG_W1_CON is not set
+# CONFIG_W1_MASTER_DS1WM is not set
+# CONFIG_W1_MASTER_DS2482 is not set
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_GPIO is not set
+# CONFIG_W1_MASTER_MATROX is not set
+# CONFIG_W1_SLAVE_BQ27000 is not set
+# CONFIG_W1_SLAVE_DS2408 is not set
+# CONFIG_W1_SLAVE_DS2413 is not set
+# CONFIG_W1_SLAVE_DS2423 is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+# CONFIG_W1_SLAVE_DS2760 is not set
+# CONFIG_W1_SLAVE_DS2780 is not set
+# CONFIG_W1_SLAVE_DS2781 is not set
+# CONFIG_W1_SLAVE_DS28E04 is not set
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_THERM is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83697HF_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_WAN is not set
+# CONFIG_WANXL is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_CORE is not set
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+# CONFIG_WD80x3 is not set
+# CONFIG_WDTPCI is not set
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PRIV=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+# CONFIG_WIMAX is not set
+# CONFIG_WIMAX_GDM72XX is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+# CONFIG_WIRELESS_EXT_SYSFS is not set
+# CONFIG_WLAGS49_H2 is not set
+# CONFIG_WLAGS49_H25 is not set
+CONFIG_WLAN=y
+# CONFIG_WL_TI is not set
+# CONFIG_WR_PPMC is not set
+# CONFIG_X25 is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_IPCOMP is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XILINX_AXI_EMAC is not set
+# CONFIG_XILINX_EMACLITE is not set
+# CONFIG_XILINX_LL_TEMAC is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_XMON is not set
+# CONFIG_XVMALLOC is not set
+CONFIG_XZ_DEC=y
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_BCJ is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_SPARC is not set
+# CONFIG_XZ_DEC_TEST is not set
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_YAFFS_FS is not set
+# CONFIG_YAM is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_YENTA is not set
+# CONFIG_YENTA_O2 is not set
+# CONFIG_YENTA_RICOH is not set
+# CONFIG_YENTA_TI is not set
+# CONFIG_YENTA_TOSHIBA is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_ZD1211RW_DEBUG is not set
+# CONFIG_ZEROPLUS_FF is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_ZLIB_DEFLATE is not set
+# CONFIG_ZLIB_INFLATE is not set
+# CONFIG_ZNET is not set
+CONFIG_ZONE_DMA=y
+CONFIG_ZONE_DMA_FLAG=1
+# CONFIG_ZRAM is not set
+# CONFIG_ZSMALLOC is not set
diff --git a/target/linux/generic/files/crypto/ocf/Kconfig b/target/linux/generic/files/crypto/ocf/Kconfig
--- a/target/linux/generic/files/crypto/ocf/Kconfig
+++ b/target/linux/generic/files/crypto/ocf/Kconfig
@@ -57,7 +57,7 @@ config OCF_IXP4XX_SHA1_MD5
 
 config OCF_HIFN
 	tristate "hifn (HW crypto engine)"
-	depends on OCF_OCF && PCI
+	depends on OCF_OCF
 	help
 	  OCF driver for various HIFN based crypto accelerators.
 	  (7951, 7955, 7956, 7751, 7811)
diff --git a/target/linux/generic/files/crypto/ocf/ocf-compat.h b/target/linux/generic/files/crypto/ocf/ocf-compat.h
--- a/target/linux/generic/files/crypto/ocf/ocf-compat.h
+++ b/target/linux/generic/files/crypto/ocf/ocf-compat.h
@@ -211,7 +211,6 @@ struct ocf_device {
 /* older kernels don't have these */
 
 #include <asm/irq.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
 #if !defined(IRQ_NONE) && !defined(IRQ_RETVAL)
 #define IRQ_NONE
 #define IRQ_HANDLED
@@ -223,7 +222,6 @@ typedef irqreturn_t (*irq_handler_t)(int
 #ifndef IRQF_SHARED
 #define IRQF_SHARED	SA_SHIRQ
 #endif
-#endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 # define strlcpy(dest,src,len) \
diff --git a/target/linux/generic/files/drivers/leds/ledtrig-netdev.c b/target/linux/generic/files/drivers/leds/ledtrig-netdev.c
--- a/target/linux/generic/files/drivers/leds/ledtrig-netdev.c
+++ b/target/linux/generic/files/drivers/leds/ledtrig-netdev.c
@@ -27,6 +27,11 @@
 #include <linux/timer.h>
 #include <linux/ctype.h>
 #include <linux/leds.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#include <net/net_namespace.h>
+#endif
 
 #include "leds.h"
 
@@ -98,7 +103,7 @@ static void set_baseline_state(struct le
 }
 
 static ssize_t led_device_name_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+				    struct device_attribute *attr, char *buf)
 {
 	struct led_classdev *led_cdev = dev_get_drvdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
@@ -110,8 +115,12 @@ static ssize_t led_device_name_show(stru
 	return strlen(buf) + 1;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21)
+extern struct net init_net;
+#endif
+
 static ssize_t led_device_name_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
+				     struct device_attribute *attr, const char *buf, size_t size)
 {
 	struct led_classdev *led_cdev = dev_get_drvdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
@@ -127,7 +136,11 @@ static ssize_t led_device_name_store(str
 
 	if (trigger_data->device_name[0] != 0) {
 		/* check for existing device to update from */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
 		trigger_data->net_dev = dev_get_by_name(&init_net, trigger_data->device_name);
+#else
+		trigger_data->net_dev = dev_get_by_name(trigger_data->device_name);
+#endif
 		if (trigger_data->net_dev != NULL)
 			trigger_data->link_up = (dev_get_flags(trigger_data->net_dev) & IFF_LOWER_UP) != 0;
 		set_baseline_state(trigger_data); /* updates LEDs, may start timers */
@@ -140,7 +153,7 @@ static ssize_t led_device_name_store(str
 static DEVICE_ATTR(device_name, 0644, led_device_name_show, led_device_name_store);
 
 static ssize_t led_mode_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			     struct device_attribute *attr, char *buf)
 {
 	struct led_classdev *led_cdev = dev_get_drvdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
@@ -165,7 +178,7 @@ static ssize_t led_mode_show(struct devi
 }
 
 static ssize_t led_mode_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
+			      struct device_attribute *attr, const char *buf, size_t size)
 {
 	struct led_classdev *led_cdev = dev_get_drvdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
@@ -211,7 +224,7 @@ static ssize_t led_mode_store(struct dev
 static DEVICE_ATTR(mode, 0644, led_mode_show, led_mode_store);
 
 static ssize_t led_interval_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+				 struct device_attribute *attr, char *buf)
 {
 	struct led_classdev *led_cdev = dev_get_drvdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
@@ -224,7 +237,7 @@ static ssize_t led_interval_show(struct 
 }
 
 static ssize_t led_interval_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
+				  struct device_attribute *attr, const char *buf, size_t size)
 {
 	struct led_classdev *led_cdev = dev_get_drvdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
@@ -233,14 +246,14 @@ static ssize_t led_interval_store(struct
 	unsigned long value = simple_strtoul(buf, &after, 10);
 	size_t count = after - buf;
 
-	if (isspace(*after))
+	if (*after && isspace(*after))
 		count++;
 
 	/* impose some basic bounds on the timer interval */
 	if (count == size && value >= 5 && value <= 10000) {
 		write_lock(&trigger_data->lock);
 		trigger_data->interval = msecs_to_jiffies(value);
-		set_baseline_state(trigger_data); /* resets timer */
+		set_baseline_state(trigger_data); // resets timer
 		write_unlock(&trigger_data->lock);
 		ret = count;
 	}
diff --git a/target/linux/generic/files/drivers/mtd/myloader.c b/target/linux/generic/files/drivers/mtd/myloader.c
--- a/target/linux/generic/files/drivers/mtd/myloader.c
+++ b/target/linux/generic/files/drivers/mtd/myloader.c
@@ -164,9 +164,7 @@ static struct mtd_part_parser myloader_m
 
 static int __init myloader_mtd_parser_init(void)
 {
-	register_mtd_parser(&myloader_mtd_parser);
-
-	return 0;
+	return register_mtd_parser(&myloader_mtd_parser);
 }
 
 static void __exit myloader_mtd_parser_exit(void)
diff --git a/target/linux/generic/files/drivers/net/phy/adm6996.c b/target/linux/generic/files/drivers/net/phy/adm6996.c
--- a/target/linux/generic/files/drivers/net/phy/adm6996.c
+++ b/target/linux/generic/files/drivers/net/phy/adm6996.c
@@ -5,16 +5,12 @@
  *
  * Copyright (c) 2008 Felix Fietkau <nbd@openwrt.org>
  * VLAN support Copyright (c) 2010, 2011 Peter Lebbing <peter@digitalbrains.com>
- * Copyright (c) 2013 Hauke Mehrtens <hauke@hauke-m.de>
- * Copyright (c) 2014 Matti Laakso <malaakso@elisanet.fi>
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of the GNU General Public License v2 as published by the
  * Free Software Foundation
  */
 
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
 /*#define DEBUG 1*/
 #include <linux/kernel.h>
 #include <linux/string.h>
@@ -24,7 +20,6 @@
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/delay.h>
-#include <linux/gpio.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
@@ -32,8 +27,6 @@
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/mii.h>
-#include <linux/platform_device.h>
-#include <linux/platform_data/adm6996-gpio.h>
 #include <linux/ethtool.h>
 #include <linux/phy.h>
 #include <linux/switch.h>
@@ -47,27 +40,20 @@ MODULE_DESCRIPTION("Infineon ADM6996 Swi
 MODULE_AUTHOR("Felix Fietkau, Peter Lebbing <peter@digitalbrains.com>");
 MODULE_LICENSE("GPL");
 
+enum adm6996_model {
+	ADM6996FC,
+	ADM6996M
+};
+
 static const char * const adm6996_model_name[] =
 {
-	NULL,
 	"ADM6996FC",
-	"ADM6996M",
-	"ADM6996L"
-};
-
-struct adm6996_mib_desc {
-	unsigned int offset;
-	const char *name;
+	"ADM6996M"
 };
 
 struct adm6996_priv {
 	struct switch_dev dev;
-	void *priv;
-
-	u8 eecs;
-	u8 eesk;
-	u8 eedi;
-	u8 eerc;
+	struct phy_device *phydev;
 
 	enum adm6996_model model;
 
@@ -79,226 +65,44 @@ struct adm6996_priv {
 #endif
 
 	u16 pvid[ADM_NUM_PORTS];	/* Primary VLAN ID */
-	u8 tagged_ports;
 
 	u16 vlan_id[ADM_NUM_VLANS];
 	u8 vlan_table[ADM_NUM_VLANS];	/* bitmap, 1 = port is member */
 	u8 vlan_tagged[ADM_NUM_VLANS];	/* bitmap, 1 = tagged member */
-	
-	struct mutex mib_lock;
-	char buf[2048];
 
 	struct mutex reg_mutex;
 
 	/* use abstraction for regops, we want to add gpio support in the future */
-	u16 (*read)(struct adm6996_priv *priv, enum admreg reg);
-	void (*write)(struct adm6996_priv *priv, enum admreg reg, u16 val);
+	u16 (*read)(struct phy_device *phydev, enum admreg reg);
+	void (*write)(struct phy_device *phydev, enum admreg reg, u16 val);
 };
 
 #define to_adm(_dev) container_of(_dev, struct adm6996_priv, dev)
 #define phy_to_adm(_phy) ((struct adm6996_priv *) (_phy)->priv)
 
-#define MIB_DESC(_o, _n)	\
-	{			\
-		.offset = (_o),	\
-		.name = (_n),	\
-	}
-
-static const struct adm6996_mib_desc adm6996_mibs[] = {
-	MIB_DESC(ADM_CL0, "RxPacket"),
-	MIB_DESC(ADM_CL6, "RxByte"),
-	MIB_DESC(ADM_CL12, "TxPacket"),
-	MIB_DESC(ADM_CL18, "TxByte"),
-	MIB_DESC(ADM_CL24, "Collision"),
-	MIB_DESC(ADM_CL30, "Error"),
-};
-
 static inline u16
-r16(struct adm6996_priv *priv, enum admreg reg)
+r16(struct phy_device *pdev, enum admreg reg)
 {
-	return priv->read(priv, reg);
+	return phy_to_adm(pdev)->read(pdev, reg);
 }
 
 static inline void
-w16(struct adm6996_priv *priv, enum admreg reg, u16 val)
+w16(struct phy_device *pdev, enum admreg reg, u16 val)
 {
-	priv->write(priv, reg, val);
+	phy_to_adm(pdev)->write(pdev, reg, val);
 }
 
-/* Minimum timing constants */
-#define EECK_EDGE_TIME  3   /* 3us - max(adm 2.5us, 93c 1us) */
-#define EEDI_SETUP_TIME 1   /* 1us - max(adm 10ns, 93c 400ns) */
-#define EECS_SETUP_TIME 1   /* 1us - max(adm no, 93c 200ns) */
-
-static void adm6996_gpio_write(struct adm6996_priv *priv, int cs, char *buf, unsigned int bits)
-{
-	int i, len = (bits + 7) / 8;
-	u8 mask;
-
-	gpio_set_value(priv->eecs, cs);
-	udelay(EECK_EDGE_TIME);
-
-	/* Byte assemble from MSB to LSB */
-	for (i = 0; i < len; i++) {
-		/* Bit bang from MSB to LSB */
-		for (mask = 0x80; mask && bits > 0; mask >>= 1, bits --) {
-			/* Clock low */
-			gpio_set_value(priv->eesk, 0);
-			udelay(EECK_EDGE_TIME);
-
-			/* Output on rising edge */
-			gpio_set_value(priv->eedi, (mask & buf[i]));
-			udelay(EEDI_SETUP_TIME);
-
-			/* Clock high */
-			gpio_set_value(priv->eesk, 1);
-			udelay(EECK_EDGE_TIME);
-		}
-	}
-
-	/* Clock low */
-	gpio_set_value(priv->eesk, 0);
-	udelay(EECK_EDGE_TIME);
-
-	if (cs)
-		gpio_set_value(priv->eecs, 0);
-}
-
-static void adm6996_gpio_read(struct adm6996_priv *priv, int cs, char *buf, unsigned int bits)
-{
-	int i, len = (bits + 7) / 8;
-	u8 mask;
-
-	gpio_set_value(priv->eecs, cs);
-	udelay(EECK_EDGE_TIME);
-
-	/* Byte assemble from MSB to LSB */
-	for (i = 0; i < len; i++) {
-		u8 byte;
-
-		/* Bit bang from MSB to LSB */
-		for (mask = 0x80, byte = 0; mask && bits > 0; mask >>= 1, bits --) {
-			u8 gp;
-
-			/* Clock low */
-			gpio_set_value(priv->eesk, 0);
-			udelay(EECK_EDGE_TIME);
-
-			/* Input on rising edge */
-			gp = gpio_get_value(priv->eedi);
-			if (gp)
-				byte |= mask;
-
-			/* Clock high */
-			gpio_set_value(priv->eesk, 1);
-			udelay(EECK_EDGE_TIME);
-		}
-
-		*buf++ = byte;
-	}
-
-	/* Clock low */
-	gpio_set_value(priv->eesk, 0);
-	udelay(EECK_EDGE_TIME);
-
-	if (cs)
-		gpio_set_value(priv->eecs, 0);
-}
-
-/* Advance clock(s) */
-static void adm6996_gpio_adclk(struct adm6996_priv *priv, int clocks)
-{
-	int i;
-	for (i = 0; i < clocks; i++) {
-		/* Clock high */
-		gpio_set_value(priv->eesk, 1);
-		udelay(EECK_EDGE_TIME);
-
-		/* Clock low */
-		gpio_set_value(priv->eesk, 0);
-		udelay(EECK_EDGE_TIME);
-	}
-}
 
 static u16
-adm6996_read_gpio_reg(struct adm6996_priv *priv, enum admreg reg)
+adm6996_read_mii_reg(struct phy_device *phydev, enum admreg reg)
 {
-	/* cmd: 01 10 T DD R RRRRRR */
-	u8 bits[6] = {
-		0xFF, 0xFF, 0xFF, 0xFF,
-		(0x06 << 4) | ((0 & 0x01) << 3 | (reg&64)>>6),
-		((reg&63)<<2)
-	};
-
-	u8 rbits[4];
-
-	/* Enable GPIO outputs with all pins to 0 */
-	gpio_direction_output(priv->eecs, 0);
-	gpio_direction_output(priv->eesk, 0);
-	gpio_direction_output(priv->eedi, 0);
-
-	adm6996_gpio_write(priv, 0, bits, 46);
-	gpio_direction_input(priv->eedi);
-	adm6996_gpio_adclk(priv, 2);
-	adm6996_gpio_read(priv, 0, rbits, 32);
-
-	/* Extra clock(s) required per datasheet */
-	adm6996_gpio_adclk(priv, 2);
-
-	/* Disable GPIO outputs */
-	gpio_direction_input(priv->eecs);
-	gpio_direction_input(priv->eesk);
-
-	 /* EEPROM has 16-bit registers, but pumps out two registers in one request */
-	return (reg & 0x01 ?  (rbits[0]<<8) | rbits[1] : (rbits[2]<<8) | (rbits[3]));
-}
-
-/* Write chip configuration register */
-/* Follow 93c66 timing and chip's min EEPROM timing requirement */
-static void
-adm6996_write_gpio_reg(struct adm6996_priv *priv, enum admreg reg, u16 val)
-{
-	/* cmd(27bits): sb(1) + opc(01) + addr(bbbbbbbb) + data(bbbbbbbbbbbbbbbb) */
-	u8 bits[4] = {
-		(0x05 << 5) | (reg >> 3),
-		(reg << 5) | (u8)(val >> 11),
-		(u8)(val >> 3),
-		(u8)(val << 5)
-	};
-
-	/* Enable GPIO outputs with all pins to 0 */
-	gpio_direction_output(priv->eecs, 0);
-	gpio_direction_output(priv->eesk, 0);
-	gpio_direction_output(priv->eedi, 0);
-
-	/* Write cmd. Total 27 bits */
-	adm6996_gpio_write(priv, 1, bits, 27);
-
-	/* Extra clock(s) required per datasheet */
-	adm6996_gpio_adclk(priv, 2);
-
-	/* Disable GPIO outputs */
-	gpio_direction_input(priv->eecs);
-	gpio_direction_input(priv->eesk);
-	gpio_direction_input(priv->eedi);
-}
-
-static u16
-adm6996_read_mii_reg(struct adm6996_priv *priv, enum admreg reg)
-{
-	struct phy_device *phydev = priv->priv;
-	struct mii_bus *bus = phydev->bus;
-
-	return bus->read(bus, PHYADDR(reg));
+	return phydev->bus->read(phydev->bus, PHYADDR(reg));
 }
 
 static void
-adm6996_write_mii_reg(struct adm6996_priv *priv, enum admreg reg, u16 val)
+adm6996_write_mii_reg(struct phy_device *phydev, enum admreg reg, u16 val)
 {
-	struct phy_device *phydev = priv->priv;
-	struct mii_bus *bus = phydev->bus;
-
-	bus->write(bus, PHYADDR(reg), val);
+	phydev->bus->write(phydev->bus, PHYADDR(reg), val);
 }
 
 static int
@@ -362,7 +166,7 @@ adm6996_set_data(struct switch_dev *dev,
 	if (val->value.i > 65535)
 		return -EINVAL;
 
-	w16(priv, priv->addr, val->value.i);
+	w16(priv->phydev, priv->addr, val->value.i);
 
 	return 0;
 };
@@ -373,7 +177,7 @@ adm6996_get_data(struct switch_dev *dev,
 {
 	struct adm6996_priv *priv = to_adm(dev);
 
-	val->value.i = r16(priv, priv->addr);
+	val->value.i = r16(priv->phydev, priv->addr);
 
 	return 0;
 };
@@ -385,7 +189,8 @@ adm6996_set_pvid(struct switch_dev *dev,
 {
 	struct adm6996_priv *priv = to_adm(dev);
 
-	pr_devel("set_pvid port %d vlan %d\n", port, vlan);
+	dev_dbg (&priv->phydev->dev, "set_pvid port %d vlan %d\n", port
+			, vlan);
 
 	if (vlan > ADM_VLAN_MAX_ID)
 		return -EINVAL;
@@ -400,7 +205,7 @@ adm6996_get_pvid(struct switch_dev *dev,
 {
 	struct adm6996_priv *priv = to_adm(dev);
 
-	pr_devel("get_pvid port %d\n", port);
+	dev_dbg (&priv->phydev->dev, "get_pvid port %d\n", port);
 	*vlan = priv->pvid[port];
 
 	return 0;
@@ -412,7 +217,8 @@ adm6996_set_vid(struct switch_dev *dev, 
 {
 	struct adm6996_priv *priv = to_adm(dev);
 
-	pr_devel("set_vid port %d vid %d\n", val->port_vlan, val->value.i);
+	dev_dbg (&priv->phydev->dev, "set_vid port %d vid %d\n", val->port_vlan,
+			val->value.i);
 
 	if (val->value.i > ADM_VLAN_MAX_ID)
 		return -EINVAL;
@@ -428,7 +234,7 @@ adm6996_get_vid(struct switch_dev *dev, 
 {
 	struct adm6996_priv *priv = to_adm(dev);
 
-	pr_devel("get_vid port %d\n", val->port_vlan);
+	dev_dbg (&priv->phydev->dev, "get_vid port %d\n", val->port_vlan);
 
 	val->value.i = priv->vlan_id[val->port_vlan];
 
@@ -443,7 +249,8 @@ adm6996_get_ports(struct switch_dev *dev
 	u8 tagged = priv->vlan_tagged[val->port_vlan];
 	int i;
 
-	pr_devel("get_ports port_vlan %d\n", val->port_vlan);
+	dev_dbg (&priv->phydev->dev, "get_ports port_vlan %d\n",
+			val->port_vlan);
 
 	val->len = 0;
 
@@ -472,7 +279,8 @@ adm6996_set_ports(struct switch_dev *dev
 	u8 *tagged = &priv->vlan_tagged[val->port_vlan];
 	int i;
 
-	pr_devel("set_ports port_vlan %d ports", val->port_vlan);
+	dev_dbg (&priv->phydev->dev, "set_ports port_vlan %d ports",
+			val->port_vlan);
 
 	*ports = 0;
 	*tagged = 0;
@@ -486,10 +294,8 @@ adm6996_set_ports(struct switch_dev *dev
 			""));
 #endif
 
-		if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) {
+		if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED))
 			*tagged |= (1 << p->id);
-			priv->tagged_ports |= (1 << p->id);
-		}
 
 		*ports |= (1 << p->id);
 	}
@@ -509,34 +315,24 @@ adm6996_enable_vlan(struct adm6996_priv 
 {
 	u16 reg;
 
-	reg = r16(priv, ADM_OTBE_P2_PVID);
+	reg = r16(priv->phydev, ADM_OTBE_P2_PVID);
 	reg &= ~(ADM_OTBE_MASK);
-	w16(priv, ADM_OTBE_P2_PVID, reg);
-	reg = r16(priv, ADM_IFNTE);
+	w16(priv->phydev, ADM_OTBE_P2_PVID, reg);
+	reg = r16(priv->phydev, ADM_IFNTE);
 	reg &= ~(ADM_IFNTE_MASK);
-	w16(priv, ADM_IFNTE, reg);
-	reg = r16(priv, ADM_VID_CHECK);
+	w16(priv->phydev, ADM_IFNTE, reg);
+	reg = r16(priv->phydev, ADM_VID_CHECK);
 	reg |= ADM_VID_CHECK_MASK;
-	w16(priv, ADM_VID_CHECK, reg);
-	reg = r16(priv, ADM_SYSC0);
+	w16(priv->phydev, ADM_VID_CHECK, reg);
+	reg = r16(priv->phydev, ADM_SYSC0);
 	reg |= ADM_NTTE;
 	reg &= ~(ADM_RVID1);
-	w16(priv, ADM_SYSC0, reg);
-	reg = r16(priv, ADM_SYSC3);
+	w16(priv->phydev, ADM_SYSC0, reg);
+	reg = r16(priv->phydev, ADM_SYSC3);
 	reg |= ADM_TBV;
-	w16(priv, ADM_SYSC3, reg);
-}
+	w16(priv->phydev, ADM_SYSC3, reg);
 
-static void
-adm6996_enable_vlan_6996l(struct adm6996_priv *priv)
-{
-	u16 reg;
-
-	reg = r16(priv, ADM_SYSC3);
-	reg |= ADM_TBV;
-	reg |= ADM_MAC_CLONE;
-	w16(priv, ADM_SYSC3, reg);
-}
+};
 
 /*
  * Disable VLANs
@@ -552,53 +348,29 @@ adm6996_disable_vlan(struct adm6996_priv
 	u16 reg;
 	int i;
 
-	for (i = 0; i < ADM_NUM_VLANS; i++) {
+	for (i = 0; i < ADM_NUM_PORTS; i++) {
 		reg = ADM_VLAN_FILT_MEMBER_MASK;
-		w16(priv, ADM_VLAN_FILT_L(i), reg);
+		w16(priv->phydev, ADM_VLAN_FILT_L(i), reg);
 		reg = ADM_VLAN_FILT_VALID | ADM_VLAN_FILT_VID(1);
-		w16(priv, ADM_VLAN_FILT_H(i), reg);
+		w16(priv->phydev, ADM_VLAN_FILT_H(i), reg);
 	}
 
-	reg = r16(priv, ADM_OTBE_P2_PVID);
+	reg = r16(priv->phydev, ADM_OTBE_P2_PVID);
 	reg |= ADM_OTBE_MASK;
-	w16(priv, ADM_OTBE_P2_PVID, reg);
-	reg = r16(priv, ADM_IFNTE);
+	w16(priv->phydev, ADM_OTBE_P2_PVID, reg);
+	reg = r16(priv->phydev, ADM_IFNTE);
 	reg |= ADM_IFNTE_MASK;
-	w16(priv, ADM_IFNTE, reg);
-	reg = r16(priv, ADM_VID_CHECK);
+	w16(priv->phydev, ADM_IFNTE, reg);
+	reg = r16(priv->phydev, ADM_VID_CHECK);
 	reg &= ~(ADM_VID_CHECK_MASK);
-	w16(priv, ADM_VID_CHECK, reg);
-	reg = r16(priv, ADM_SYSC0);
+	w16(priv->phydev, ADM_VID_CHECK, reg);
+	reg = r16(priv->phydev, ADM_SYSC0);
 	reg &= ~(ADM_NTTE);
 	reg |= ADM_RVID1;
-	w16(priv, ADM_SYSC0, reg);
-	reg = r16(priv, ADM_SYSC3);
+	w16(priv->phydev, ADM_SYSC0, reg);
+	reg = r16(priv->phydev, ADM_SYSC3);
 	reg &= ~(ADM_TBV);
-	w16(priv, ADM_SYSC3, reg);
-}
-
-/*
- * Disable VLANs
- *
- * Sets VLAN mapping for port-based VLAN with all ports connected to
- * eachother (this is also the power-on default).
- *
- * Precondition: reg_mutex must be held
- */
-static void
-adm6996_disable_vlan_6996l(struct adm6996_priv *priv)
-{
-	u16 reg;
-	int i;
-
-	for (i = 0; i < ADM_NUM_VLANS; i++) {
-		w16(priv, ADM_VLAN_MAP(i), 0);
-	}
-
-	reg = r16(priv, ADM_SYSC3);
-	reg &= ~(ADM_TBV);
-	reg &= ~(ADM_MAC_CLONE);
-	w16(priv, ADM_SYSC3, reg);
+	w16(priv->phydev, ADM_SYSC3, reg);
 }
 
 /*
@@ -611,31 +383,22 @@ adm6996_apply_port_pvids(struct adm6996_
 	int i;
 
 	for (i = 0; i < ADM_NUM_PORTS; i++) {
-		reg = r16(priv, adm_portcfg[i]);
+		reg = r16(priv->phydev, adm_portcfg[i]);
 		reg &= ~(ADM_PORTCFG_PVID_MASK);
 		reg |= ADM_PORTCFG_PVID(priv->pvid[i]);
-		if (priv->model == ADM6996L) {
-			if (priv->tagged_ports & (1 << i))
-				reg |= (1 << 4);
-			else
-				reg &= ~(1 << 4);
-		}
-		w16(priv, adm_portcfg[i], reg);
+		w16(priv->phydev, adm_portcfg[i], reg);
 	}
 
-	w16(priv, ADM_P0_PVID, ADM_P0_PVID_VAL(priv->pvid[0]));
-	w16(priv, ADM_P1_PVID, ADM_P1_PVID_VAL(priv->pvid[1]));
-	reg = r16(priv, ADM_OTBE_P2_PVID);
+	w16(priv->phydev, ADM_P0_PVID, ADM_P0_PVID_VAL(priv->pvid[0]));
+	w16(priv->phydev, ADM_P1_PVID, ADM_P1_PVID_VAL(priv->pvid[1]));
+	reg = r16(priv->phydev, ADM_OTBE_P2_PVID);
 	reg &= ~(ADM_P2_PVID_MASK);
 	reg |= ADM_P2_PVID_VAL(priv->pvid[2]);
-	w16(priv, ADM_OTBE_P2_PVID, reg);
+	w16(priv->phydev, ADM_OTBE_P2_PVID, reg);
 	reg = ADM_P3_PVID_VAL(priv->pvid[3]);
 	reg |= ADM_P4_PVID_VAL(priv->pvid[4]);
-	w16(priv, ADM_P3_P4_PVID, reg);
-	reg = r16(priv, ADM_P5_PVID);
-	reg &= ~(ADM_P2_PVID_MASK);
-	reg |= ADM_P5_PVID_VAL(priv->pvid[5]);
-	w16(priv, ADM_P5_PVID, reg);
+	w16(priv->phydev, ADM_P3_P4_PVID, reg);
+	w16(priv->phydev, ADM_P5_PVID, ADM_P5_PVID_VAL(priv->pvid[5]));
 }
 
 /*
@@ -655,37 +418,16 @@ adm6996_apply_vlan_filters(struct adm699
 
 		if (ports == 0) {
 			/* Disable VLAN entry */
-			w16(priv, ADM_VLAN_FILT_H(i), 0);
-			w16(priv, ADM_VLAN_FILT_L(i), 0);
+			w16(priv->phydev, ADM_VLAN_FILT_H(i), 0);
+			w16(priv->phydev, ADM_VLAN_FILT_L(i), 0);
 			continue;
 		}
 
 		reg = ADM_VLAN_FILT_MEMBER(ports);
 		reg |= ADM_VLAN_FILT_TAGGED(tagged);
-		w16(priv, ADM_VLAN_FILT_L(i), reg);
+		w16(priv->phydev, ADM_VLAN_FILT_L(i), reg);
 		reg = ADM_VLAN_FILT_VALID | ADM_VLAN_FILT_VID(vid);
-		w16(priv, ADM_VLAN_FILT_H(i), reg);
-	}
-}
-
-static void
-adm6996_apply_vlan_filters_6996l(struct adm6996_priv *priv)
-{
-	u8 ports;
-	u16 reg;
-	int i;
-
-	for (i = 0; i < ADM_NUM_VLANS; i++) {
-		ports = priv->vlan_table[i];
-
-		if (ports == 0) {
-			/* Disable VLAN entry */
-			w16(priv, ADM_VLAN_MAP(i), 0);
-			continue;
-		} else {
-			reg = ADM_VLAN_FILT(ports);
-			w16(priv, ADM_VLAN_MAP(i), reg);
-		}
+		w16(priv->phydev, ADM_VLAN_FILT_H(i), reg);
 	}
 }
 
@@ -694,34 +436,25 @@ adm6996_hw_apply(struct switch_dev *dev)
 {
 	struct adm6996_priv *priv = to_adm(dev);
 
-	pr_devel("hw_apply\n");
+	dev_dbg(&priv->phydev->dev, "hw_apply\n");
 
 	mutex_lock(&priv->reg_mutex);
 
 	if (!priv->enable_vlan) {
 		if (priv->vlan_enabled) {
-			if (priv->model == ADM6996L)
-				adm6996_disable_vlan_6996l(priv);
-			else
-				adm6996_disable_vlan(priv);
+			adm6996_disable_vlan(priv);
 			priv->vlan_enabled = 0;
 		}
 		goto out;
 	}
 
 	if (!priv->vlan_enabled) {
-		if (priv->model == ADM6996L)
-			adm6996_enable_vlan_6996l(priv);
-		else
-			adm6996_enable_vlan(priv);
+		adm6996_enable_vlan(priv);
 		priv->vlan_enabled = 1;
 	}
 
 	adm6996_apply_port_pvids(priv);
-	if (priv->model == ADM6996L)
-		adm6996_apply_vlan_filters_6996l(priv);
-	else
-		adm6996_apply_vlan_filters(priv);
+	adm6996_apply_vlan_filters(priv);
 
 out:
 	mutex_unlock(&priv->reg_mutex);
@@ -744,16 +477,14 @@ adm6996_perform_reset (struct adm6996_pr
 
 	/* initialize port and vlan settings */
 	for (i = 0; i < ADM_NUM_PORTS - 1; i++) {
-		w16(priv, adm_portcfg[i], ADM_PORTCFG_INIT |
+		w16(priv->phydev, adm_portcfg[i], ADM_PORTCFG_INIT |
 			ADM_PORTCFG_PVID(0));
 	}
-	w16(priv, adm_portcfg[5], ADM_PORTCFG_CPU);
+	w16(priv->phydev, adm_portcfg[5], ADM_PORTCFG_CPU);
 
-	if (priv->model == ADM6996M || priv->model == ADM6996FC) {
-		/* reset all PHY ports */
-		for (i = 0; i < ADM_PHY_PORTS; i++) {
-			w16(priv, ADM_PHY_PORT(i), ADM_PHYCFG_INIT);
-		}
+	/* reset all PHY ports */
+	for (i = 0; i < ADM_PHY_PORTS; i++) {
+		w16(priv->phydev, ADM_PHY_PORT(i), ADM_PHYCFG_INIT);
 	}
 
 	priv->enable_vlan = 0;
@@ -771,16 +502,10 @@ adm6996_perform_reset (struct adm6996_pr
 
 	if (priv->model == ADM6996M) {
 		/* Clear VLAN priority map so prio's are unused */
-		w16 (priv, ADM_VLAN_PRIOMAP, 0);
+		w16 (priv->phydev, ADM_VLAN_PRIOMAP, 0);
 
 		adm6996_disable_vlan(priv);
 		adm6996_apply_port_pvids(priv);
-	} else if (priv->model == ADM6996L) {
-		/* Clear VLAN priority map so prio's are unused */
-		w16 (priv, ADM_VLAN_PRIOMAP, 0);
-
-		adm6996_disable_vlan_6996l(priv);
-		adm6996_apply_port_pvids(priv);
 	}
 }
 
@@ -789,106 +514,13 @@ adm6996_reset_switch(struct switch_dev *
 {
 	struct adm6996_priv *priv = to_adm(dev);
 
-	pr_devel("reset\n");
-
+	dev_dbg (&priv->phydev->dev, "reset\n");
 	mutex_lock(&priv->reg_mutex);
 	adm6996_perform_reset (priv);
 	mutex_unlock(&priv->reg_mutex);
 	return 0;
 }
 
-static int
-adm6996_get_port_link(struct switch_dev *dev, int port,
-		struct switch_port_link *link)
-{
-	struct adm6996_priv *priv = to_adm(dev);
-	
-	u16 reg = 0;
-	
-	if (port >= ADM_NUM_PORTS)
-		return -EINVAL;
-	
-	switch (port) {
-	case 0:
-		reg = r16(priv, ADM_PS0);
-		break;
-	case 1:
-		reg = r16(priv, ADM_PS0);
-		reg = reg >> 8;
-		break;
-	case 2:
-		reg = r16(priv, ADM_PS1);
-		break;
-	case 3:
-		reg = r16(priv, ADM_PS1);
-		reg = reg >> 8;
-		break;
-	case 4:
-		reg = r16(priv, ADM_PS1);
-		reg = reg >> 12;
-		break;
-	case 5:
-		reg = r16(priv, ADM_PS2);
-		/* Bits 0, 1, 3 and 4. */
-		reg = (reg & 3) | ((reg & 24) >> 1);
-		break;
-	default:
-		return -EINVAL;
-	}
-	
-	link->link = reg & ADM_PS_LS;
-	if (!link->link)
-		return 0;
-	link->aneg = true;
-	link->duplex = reg & ADM_PS_DS;
-	link->tx_flow = reg & ADM_PS_FCS;
-	link->rx_flow = reg & ADM_PS_FCS;
-	if (reg & ADM_PS_SS)
-		link->speed = SWITCH_PORT_SPEED_100;
-	else
-		link->speed = SWITCH_PORT_SPEED_10;
-
-	return 0;
-}
-
-static int
-adm6996_sw_get_port_mib(struct switch_dev *dev,
-		       const struct switch_attr *attr,
-		       struct switch_val *val)
-{
-	struct adm6996_priv *priv = to_adm(dev);
-	int port;
-	char *buf = priv->buf;
-	int i, len = 0;
-	u32 reg = 0;
-
-	port = val->port_vlan;
-	if (port >= ADM_NUM_PORTS)
-		return -EINVAL;
-
-	mutex_lock(&priv->mib_lock);
-
-	len += snprintf(buf + len, sizeof(priv->buf) - len,
-			"Port %d MIB counters\n",
-			port);
-
-	for (i = 0; i < ARRAY_SIZE(adm6996_mibs); i++) {
-		reg = r16(priv, adm6996_mibs[i].offset + ADM_OFFSET_PORT(port));
-		reg += r16(priv, adm6996_mibs[i].offset + ADM_OFFSET_PORT(port) + 1) << 16;
-		len += snprintf(buf + len, sizeof(priv->buf) - len,
-				"%-12s: %u\n",
-				adm6996_mibs[i].name,
-				reg);
-	}
-
-	mutex_unlock(&priv->mib_lock);
-
-	val->value.s = buf;
-	val->len = len;
-
-	return 0;
-}
-
 static struct switch_attr adm6996_globals[] = {
 	{
 	 .type = SWITCH_TYPE_INT,
@@ -918,13 +550,6 @@ static struct switch_attr adm6996_global
 };
 
 static struct switch_attr adm6996_port[] = {
-	{
-	 .type = SWITCH_TYPE_STRING,
-	 .name = "mib",
-	 .description = "Get port's MIB counters",
-	 .set = NULL,
-	 .get = adm6996_sw_get_port_mib,
-	},
 };
 
 static struct switch_attr adm6996_vlan[] = {
@@ -937,7 +562,7 @@ static struct switch_attr adm6996_vlan[]
 	 },
 };
 
-static struct switch_dev_ops adm6996_ops = {
+static const struct switch_dev_ops adm6996_ops = {
 	.attr_global = {
 			.attr = adm6996_globals,
 			.n_attr = ARRAY_SIZE(adm6996_globals),
@@ -956,65 +581,15 @@ static struct switch_dev_ops adm6996_ops
 	.set_vlan_ports = adm6996_set_ports,
 	.apply_config = adm6996_hw_apply,
 	.reset_switch = adm6996_reset_switch,
-	.get_port_link = adm6996_get_port_link,
 };
 
-static int adm6996_switch_init(struct adm6996_priv *priv, const char *alias, struct net_device *netdev)
-{
-	struct switch_dev *swdev;
-	u16 test, old;
-
-	if (!priv->model) {
-		/* Detect type of chip */
-		old = r16(priv, ADM_VID_CHECK);
-		test = old ^ (1 << 12);
-		w16(priv, ADM_VID_CHECK, test);
-		test ^= r16(priv, ADM_VID_CHECK);
-		if (test & (1 << 12)) {
-			/* 
-			 * Bit 12 of this register is read-only. 
-			 * This is the FC model. 
-			 */
-			priv->model = ADM6996FC;
-		} else {
-			/* Bit 12 is read-write. This is the M model. */
-			priv->model = ADM6996M;
-			w16(priv, ADM_VID_CHECK, old);
-		}
-	}
-
-	swdev = &priv->dev;
-	swdev->name = (adm6996_model_name[priv->model]);
-	swdev->cpu_port = ADM_CPU_PORT;
-	swdev->ports = ADM_NUM_PORTS;
-	swdev->vlans = ADM_NUM_VLANS;
-	swdev->ops = &adm6996_ops;
-	swdev->alias = alias;
-
-	/* The ADM6996L connected through GPIOs does not support any switch
-	   status calls */
-	if (priv->model == ADM6996L) {
-		adm6996_ops.attr_port.n_attr = 0;
-		adm6996_ops.get_port_link = NULL;
-	}
-
-	pr_info ("%s: %s model PHY found.\n", alias, swdev->name);
-
-	mutex_lock(&priv->reg_mutex);
-	adm6996_perform_reset (priv);
-	mutex_unlock(&priv->reg_mutex);
-
-	if (priv->model == ADM6996M || priv->model == ADM6996L) {
-		return register_switch(swdev, netdev);
-	}
-
-	return -ENODEV;
-}
-
 static int adm6996_config_init(struct phy_device *pdev)
 {
 	struct adm6996_priv *priv;
+	struct switch_dev *swdev;
+
 	int ret;
+	u16 test, old;
 
 	pdev->supported = ADVERTISED_100baseT_Full;
 	pdev->advertising = ADVERTISED_100baseT_Full;
@@ -1025,21 +600,53 @@ static int adm6996_config_init(struct ph
 		return 0;
 	}
 
-	priv = devm_kzalloc(&pdev->dev, sizeof(struct adm6996_priv), GFP_KERNEL);
-	if (!priv)
+	priv = kzalloc(sizeof(struct adm6996_priv), GFP_KERNEL);
+	if (priv == NULL)
 		return -ENOMEM;
 
 	mutex_init(&priv->reg_mutex);
-	mutex_init(&priv->mib_lock);
-	priv->priv = pdev;
+	priv->phydev = pdev;
 	priv->read = adm6996_read_mii_reg;
 	priv->write = adm6996_write_mii_reg;
+	pdev->priv = priv;
 
-	ret = adm6996_switch_init(priv, pdev->attached_dev->name, pdev->attached_dev);
-	if (ret < 0)
-		return ret;
+	/* Detect type of chip */
+	old = r16(pdev, ADM_VID_CHECK);
+	test = old ^ (1 << 12);
+	w16(pdev, ADM_VID_CHECK, test);
+	test ^= r16(pdev, ADM_VID_CHECK);
+	if (test & (1 << 12)) {
+		/* 
+		 * Bit 12 of this register is read-only. 
+		 * This is the FC model. 
+		 */
+		priv->model = ADM6996FC;
+	} else {
+		/* Bit 12 is read-write. This is the M model. */
+		priv->model = ADM6996M;
+		w16(pdev, ADM_VID_CHECK, old);
+	}
 
-	pdev->priv = priv;
+	swdev = &priv->dev;
+	swdev->name = (adm6996_model_name[priv->model]);
+	swdev->cpu_port = ADM_CPU_PORT;
+	swdev->ports = ADM_NUM_PORTS;
+	swdev->vlans = ADM_NUM_VLANS;
+	swdev->ops = &adm6996_ops;
+
+	pr_info ("%s: %s model PHY found.\n", pdev->attached_dev->name,
+			swdev->name);
+
+	mutex_lock(&priv->reg_mutex);
+	adm6996_perform_reset (priv);
+	mutex_unlock(&priv->reg_mutex);
+
+	if (priv->model == ADM6996M) {
+		if ((ret = register_switch(swdev, pdev->attached_dev)) < 0) {
+			kfree(priv);
+			return ret;
+		}
+	}
 
 	return 0;
 }
@@ -1095,12 +702,14 @@ static void adm6996_remove(struct phy_de
 {
 	struct adm6996_priv *priv = phy_to_adm(pdev);
 
-	if (priv && (priv->model == ADM6996M || priv->model == ADM6996L))
+	if (priv != NULL && priv->model == ADM6996M)
 		unregister_switch(&priv->dev);
+
+	kfree(priv);
 }
 
 
-static struct phy_driver adm6996_phy_driver = {
+static struct phy_driver adm6996_driver = {
 	.name		= "Infineon ADM6996",
 	.phy_id		= (ADM_SIG0_VAL << 16) | ADM_SIG1_VAL,
 	.phy_id_mask	= 0xffffffff,
@@ -1113,91 +722,15 @@ static struct phy_driver adm6996_phy_dri
 	.driver		= { .owner = THIS_MODULE,},
 };
 
-static int adm6996_gpio_probe(struct platform_device *pdev)
-{
-	struct adm6996_gpio_platform_data *pdata = pdev->dev.platform_data;
-	struct adm6996_priv *priv;
-	int ret;
-
-	if (!pdata)
-		return -EINVAL;
-				  
-	priv = devm_kzalloc(&pdev->dev, sizeof(struct adm6996_priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	mutex_init(&priv->reg_mutex);
-	mutex_init(&priv->mib_lock);
-
-	priv->eecs = pdata->eecs;
-	priv->eedi = pdata->eedi;
-	priv->eerc = pdata->eerc;
-	priv->eesk = pdata->eesk;
-
-	priv->model = pdata->model;
-	priv->read = adm6996_read_gpio_reg;
-	priv->write = adm6996_write_gpio_reg;
-
-	ret = devm_gpio_request(&pdev->dev, priv->eecs, "adm_eecs");
-	if (ret)
-		return ret;
-	ret = devm_gpio_request(&pdev->dev, priv->eedi, "adm_eedi");
-	if (ret)
-		return ret;
-	ret = devm_gpio_request(&pdev->dev, priv->eerc, "adm_eerc");
-	if (ret)
-		return ret;
-	ret = devm_gpio_request(&pdev->dev, priv->eesk, "adm_eesk");
-	if (ret)
-		return ret;
-
-	ret = adm6996_switch_init(priv, dev_name(&pdev->dev), NULL);
-	if (ret < 0)
-		return ret;
-
-	platform_set_drvdata(pdev, priv);
-
-	return 0;
-}
-
-static int adm6996_gpio_remove(struct platform_device *pdev)
-{
-	struct adm6996_priv *priv = platform_get_drvdata(pdev);
-
-	if (priv && (priv->model == ADM6996M || priv->model == ADM6996L))
-		unregister_switch(&priv->dev);
-
-	return 0;
-}
-
-static struct platform_driver adm6996_gpio_driver = {
-	.probe = adm6996_gpio_probe,
-	.remove = adm6996_gpio_remove,
-	.driver = {
-		.name = "adm6996_gpio",
-	},
-};
-
 static int __init adm6996_init(void)
 {
-	int err;
-
 	phy_register_fixup_for_id(PHY_ANY_ID, adm6996_fixup);
-	err =  phy_driver_register(&adm6996_phy_driver);
-	if (err)
-		return err;
-
-	err = platform_driver_register(&adm6996_gpio_driver);
-	if (err)
-		phy_driver_unregister(&adm6996_phy_driver);
-
-	return err;
+	return phy_driver_register(&adm6996_driver);
 }
 
 static void __exit adm6996_exit(void)
 {
-	platform_driver_unregister(&adm6996_gpio_driver);
-	phy_driver_unregister(&adm6996_phy_driver);
+	phy_driver_unregister(&adm6996_driver);
 }
 
 module_init(adm6996_init);
diff --git a/target/linux/generic/files/drivers/net/phy/adm6996.h b/target/linux/generic/files/drivers/net/phy/adm6996.h
--- a/target/linux/generic/files/drivers/net/phy/adm6996.h
+++ b/target/linux/generic/files/drivers/net/phy/adm6996.h
@@ -46,20 +46,9 @@ enum admreg {
 	ADM_EEPROM_EXT_BASE	= 0x40,
 #define ADM_VLAN_FILT_L(n) (ADM_EEPROM_EXT_BASE + 2 * (n))
 #define ADM_VLAN_FILT_H(n) (ADM_EEPROM_EXT_BASE + 1 + 2 * (n))
-#define ADM_VLAN_MAP(n) (ADM_EEPROM_BASE + 0x13 + n)
 	ADM_COUNTER_BASE	= 0xa0,
 		ADM_SIG0		= ADM_COUNTER_BASE + 0,
 		ADM_SIG1		= ADM_COUNTER_BASE + 1,
-		ADM_PS0		= ADM_COUNTER_BASE + 2,
-		ADM_PS1		= ADM_COUNTER_BASE + 3,
-		ADM_PS2		= ADM_COUNTER_BASE + 4,
-		ADM_CL0		= ADM_COUNTER_BASE + 8, /* RxPacket */
-		ADM_CL6		= ADM_COUNTER_BASE + 0x1a, /* RxByte */
-		ADM_CL12		= ADM_COUNTER_BASE + 0x2c, /* TxPacket */
-		ADM_CL18		= ADM_COUNTER_BASE + 0x3e, /* TxByte */
-		ADM_CL24		= ADM_COUNTER_BASE + 0x50, /* Coll */
-		ADM_CL30		= ADM_COUNTER_BASE + 0x62, /* Err */
-#define ADM_OFFSET_PORT(n) ((n * 4) - (n / 4) * 2 - (n / 5) * 2)
 	ADM_PHY_BASE		= 0x200,
 #define ADM_PHY_PORT(n) (ADM_PHY_BASE + (0x20 * n))
 };
@@ -143,8 +132,7 @@ enum {
 };
 
 /* Tag Based VLAN in ADM_SYSC3 */
-#define ADM_MAC_CLONE	BIT(4)
-#define ADM_TBV		BIT(5)
+#define ADM_TBV (1 << 5)
 
 static const u8 adm_portcfg[] = {
 	[0] = ADM_P0_CFG,
@@ -164,18 +152,6 @@ static const u8 adm_portcfg[] = {
 #define ADM_VLAN_FILT_VALID (1 << 15)
 #define ADM_VLAN_FILT_VID(n) (((n) & 0xfff) << 0)
 
-/* Convert ports to a form for ADM6996L VLAN map */
-#define ADM_VLAN_FILT(ports) ((ports & 0x01) | ((ports & 0x02) << 1) | \
-			((ports & 0x04) << 2) | ((ports & 0x08) << 3) | \
-			((ports & 0x10) << 3) | ((ports & 0x20) << 3))
-
-/* Port status register */
-enum {
-	ADM_PS_LS = (1 << 0),	/* Link status */
-	ADM_PS_SS = (1 << 1),	/* Speed status */
-	ADM_PS_DS = (1 << 2),	/* Duplex status */
-	ADM_PS_FCS = (1 << 3)	/* Flow control status */
-};
 
 /*
  * Split the register address in phy id and register
diff --git a/target/linux/generic/files/drivers/net/phy/ar8216.c b/target/linux/generic/files/drivers/net/phy/ar8216.c
--- a/target/linux/generic/files/drivers/net/phy/ar8216.c
+++ b/target/linux/generic/files/drivers/net/phy/ar8216.c
@@ -33,15 +33,105 @@
 #include <linux/lockdep.h>
 #include <linux/ar8216_platform.h>
 #include <linux/workqueue.h>
-#include <linux/version.h>
+#include <linux/of_device.h>
 
 #include "ar8216.h"
 
-extern const struct ar8xxx_chip ar8327_chip;
-extern const struct ar8xxx_chip ar8337_chip;
+/* size of the vlan table */
+#define AR8X16_MAX_VLANS	128
+#define AR8X16_PROBE_RETRIES	10
+#define AR8X16_MAX_PORTS	8
 
 #define AR8XXX_MIB_WORK_DELAY	2000 /* msecs */
 
+struct ar8xxx_priv;
+
+#define AR8XXX_CAP_GIGE			BIT(0)
+#define AR8XXX_CAP_MIB_COUNTERS		BIT(1)
+
+enum {
+	AR8XXX_VER_AR8216 = 0x01,
+	AR8XXX_VER_AR8236 = 0x03,
+	AR8XXX_VER_AR8316 = 0x10,
+	AR8XXX_VER_AR8327 = 0x12,
+};
+
+struct ar8xxx_mib_desc {
+	unsigned int size;
+	unsigned int offset;
+	const char *name;
+};
+
+struct ar8xxx_chip {
+	unsigned long caps;
+
+	int (*hw_init)(struct ar8xxx_priv *priv);
+	void (*init_globals)(struct ar8xxx_priv *priv);
+	void (*init_port)(struct ar8xxx_priv *priv, int port);
+	void (*setup_port)(struct ar8xxx_priv *priv, int port, u32 egress,
+			   u32 ingress, u32 members, u32 pvid);
+	u32 (*read_port_status)(struct ar8xxx_priv *priv, int port);
+	int (*atu_flush)(struct ar8xxx_priv *priv);
+	void (*vtu_flush)(struct ar8xxx_priv *priv);
+	void (*vtu_load_vlan)(struct ar8xxx_priv *priv, u32 vid, u32 port_mask);
+
+	const struct ar8xxx_mib_desc *mib_decs;
+	unsigned num_mibs;
+};
+
+struct ar8327_data {
+	u32 port0_status;
+	u32 port6_status;
+};
+
+struct ar8xxx_priv {
+	struct switch_dev dev;
+	struct mii_bus *mii_bus;
+	struct phy_device *phy;
+
+	u32 (*read)(struct ar8xxx_priv *priv, int reg);
+	void (*write)(struct ar8xxx_priv *priv, int reg, u32 val);
+
+	int (*get_port_link)(unsigned port);
+
+	const struct net_device_ops *ndo_old;
+	struct net_device_ops ndo;
+	struct mutex reg_mutex;
+	u8 chip_ver;
+	u8 chip_rev;
+	const struct ar8xxx_chip *chip;
+	union {
+		struct ar8327_data ar8327;
+	} chip_data;
+	bool initialized;
+	bool port4_phy;
+	char buf[2048];
+
+	bool init;
+	bool mii_lo_first;
+
+	struct mutex mib_lock;
+	struct delayed_work mib_work;
+	int mib_next_port;
+	u64 *mib_stats;
+
+	struct list_head list;
+	unsigned int use_count;
+
+	/* all fields below are cleared on reset */
+	bool vlan;
+	u16 vlan_id[AR8X16_MAX_VLANS];
+	u8 vlan_table[AR8X16_MAX_VLANS];
+	u8 vlan_tagged;
+	u16 pvid[AR8X16_MAX_PORTS];
+
+	/* mirroring */
+	bool mirror_rx;
+	bool mirror_tx;
+	int source_port;
+	int monitor_port;
+};
+
 #define MIB_DESC(_s , _o, _n)	\
 	{			\
 		.size = (_s),	\
@@ -89,7 +179,7 @@ static const struct ar8xxx_mib_desc ar82
 	MIB_DESC(1, AR8216_STATS_TXLATECOL, "TxLateCol"),
 };
 
-const struct ar8xxx_mib_desc ar8236_mibs[39] = {
+static const struct ar8xxx_mib_desc ar8236_mibs[] = {
 	MIB_DESC(1, AR8236_STATS_RXBROAD, "RxBroad"),
 	MIB_DESC(1, AR8236_STATS_RXPAUSE, "RxPause"),
 	MIB_DESC(1, AR8236_STATS_RXMULTI, "RxMulti"),
@@ -134,169 +224,103 @@ const struct ar8xxx_mib_desc ar8236_mibs
 static DEFINE_MUTEX(ar8xxx_dev_list_lock);
 static LIST_HEAD(ar8xxx_dev_list);
 
-/* inspired by phy_poll_reset in drivers/net/phy/phy_device.c */
-static int
-ar8xxx_phy_poll_reset(struct mii_bus *bus)
+static inline struct ar8xxx_priv *
+swdev_to_ar8xxx(struct switch_dev *swdev)
 {
-        unsigned int sleep_msecs = 20;
-        int ret, elapsed, i;
-
-        for (elapsed = sleep_msecs; elapsed <= 600;
-	     elapsed += sleep_msecs) {
-                msleep(sleep_msecs);
-                for (i = 0; i < AR8XXX_NUM_PHYS; i++) {
-                        ret = mdiobus_read(bus, i, MII_BMCR);
-                        if (ret < 0)
-				return ret;
-                        if (ret & BMCR_RESET)
-				break;
-                        if (i == AR8XXX_NUM_PHYS - 1) {
-                                usleep_range(1000, 2000);
-                                return 0;
-                        }
-                }
-        }
-        return -ETIMEDOUT;
+	return container_of(swdev, struct ar8xxx_priv, dev);
 }
 
-static int
-ar8xxx_phy_check_aneg(struct phy_device *phydev)
+static inline bool ar8xxx_has_gige(struct ar8xxx_priv *priv)
 {
-	int ret;
-
-	if (phydev->autoneg != AUTONEG_ENABLE)
-		return 0;
-	/*
-	 * BMCR_ANENABLE might have been cleared
-	 * by phy_init_hw in certain kernel versions
-	 * therefore check for it
-	 */
-	ret = phy_read(phydev, MII_BMCR);
-	if (ret < 0)
-		return ret;
-	if (ret & BMCR_ANENABLE)
-		return 0;
-
-	dev_info(&phydev->dev, "ANEG disabled, re-enabling ...\n");
-	ret |= BMCR_ANENABLE | BMCR_ANRESTART;
-	return phy_write(phydev, MII_BMCR, ret);
+	return priv->chip->caps & AR8XXX_CAP_GIGE;
 }
 
-void
-ar8xxx_phy_init(struct ar8xxx_priv *priv)
+static inline bool ar8xxx_has_mib_counters(struct ar8xxx_priv *priv)
 {
-	int i;
-	struct mii_bus *bus;
-
-	bus = priv->mii_bus;
-	for (i = 0; i < AR8XXX_NUM_PHYS; i++) {
-		if (priv->chip->phy_fixup)
-			priv->chip->phy_fixup(priv, i);
-
-		/* initialize the port itself */
-		mdiobus_write(bus, i, MII_ADVERTISE,
-			ADVERTISE_ALL | ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
-		if (ar8xxx_has_gige(priv))
-			mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
-		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
-	}
-
-	ar8xxx_phy_poll_reset(bus);
+	return priv->chip->caps & AR8XXX_CAP_MIB_COUNTERS;
 }
 
-u32
-ar8xxx_mii_read32(struct ar8xxx_priv *priv, int phy_id, int regnum)
+static inline bool chip_is_ar8216(struct ar8xxx_priv *priv)
 {
-	struct mii_bus *bus = priv->mii_bus;
-	u16 lo, hi;
-
-	lo = bus->read(bus, phy_id, regnum);
-	hi = bus->read(bus, phy_id, regnum + 1);
-
-	return (hi << 16) | lo;
+	return priv->chip_ver == AR8XXX_VER_AR8216;
 }
 
-void
-ar8xxx_mii_write32(struct ar8xxx_priv *priv, int phy_id, int regnum, u32 val)
+static inline bool chip_is_ar8236(struct ar8xxx_priv *priv)
 {
-	struct mii_bus *bus = priv->mii_bus;
-	u16 lo, hi;
-
-	lo = val & 0xffff;
-	hi = (u16) (val >> 16);
-
-	if (priv->chip->mii_lo_first)
-	{
-		bus->write(bus, phy_id, regnum, lo);
-		bus->write(bus, phy_id, regnum + 1, hi);
-	} else {
-		bus->write(bus, phy_id, regnum + 1, hi);
-		bus->write(bus, phy_id, regnum, lo);
-	}
+	return priv->chip_ver == AR8XXX_VER_AR8236;
 }
 
-u32
-ar8xxx_read(struct ar8xxx_priv *priv, int reg)
+static inline bool chip_is_ar8316(struct ar8xxx_priv *priv)
+{
+	return priv->chip_ver == AR8XXX_VER_AR8316;
+}
+
+static inline bool chip_is_ar8327(struct ar8xxx_priv *priv)
+{
+	return priv->chip_ver == AR8XXX_VER_AR8327;
+}
+
+static inline void
+split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page)
+{
+	regaddr >>= 1;
+	*r1 = regaddr & 0x1e;
+
+	regaddr >>= 5;
+	*r2 = regaddr & 0x7;
+
+	regaddr >>= 3;
+	*page = regaddr & 0x1ff;
+}
+
+static u32
+ar8xxx_mii_read(struct ar8xxx_priv *priv, int reg)
 {
 	struct mii_bus *bus = priv->mii_bus;
 	u16 r1, r2, page;
-	u32 val;
+	u16 lo, hi;
 
 	split_addr((u32) reg, &r1, &r2, &page);
 
 	mutex_lock(&bus->mdio_lock);
 
 	bus->write(bus, 0x18, 0, page);
-	wait_for_page_switch();
-	val = ar8xxx_mii_read32(priv, 0x10 | r2, r1);
+	usleep_range(1000, 2000); /* wait for the page switch to propagate */
+	lo = bus->read(bus, 0x10 | r2, r1);
+	hi = bus->read(bus, 0x10 | r2, r1 + 1);
 
 	mutex_unlock(&bus->mdio_lock);
 
-	return val;
+	return (hi << 16) | lo;
 }
 
-void
-ar8xxx_write(struct ar8xxx_priv *priv, int reg, u32 val)
+static void
+ar8xxx_mii_write(struct ar8xxx_priv *priv, int reg, u32 val)
 {
 	struct mii_bus *bus = priv->mii_bus;
-	u16 r1, r2, page;
-
-	split_addr((u32) reg, &r1, &r2, &page);
+	u16 r1, r2, r3;
+	u16 lo, hi;
+
+	split_addr((u32) reg, &r1, &r2, &r3);
+	lo = val & 0xffff;
+	hi = (u16) (val >> 16);
 
 	mutex_lock(&bus->mdio_lock);
 
-	bus->write(bus, 0x18, 0, page);
-	wait_for_page_switch();
-	ar8xxx_mii_write32(priv, 0x10 | r2, r1, val);
+	bus->write(bus, 0x18, 0, r3);
+	usleep_range(1000, 2000); /* wait for the page switch to propagate */
+	if (priv->mii_lo_first) {
+		bus->write(bus, 0x10 | r2, r1, lo);
+		bus->write(bus, 0x10 | r2, r1 + 1, hi);
+	} else {
+		bus->write(bus, 0x10 | r2, r1 + 1, hi);
+		bus->write(bus, 0x10 | r2, r1, lo);
+	}
 
 	mutex_unlock(&bus->mdio_lock);
 }
 
-u32
-ar8xxx_rmw(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
-{
-	struct mii_bus *bus = priv->mii_bus;
-	u16 r1, r2, page;
-	u32 ret;
-
-	split_addr((u32) reg, &r1, &r2, &page);
-
-	mutex_lock(&bus->mdio_lock);
-
-	bus->write(bus, 0x18, 0, page);
-	wait_for_page_switch();
-
-	ret = ar8xxx_mii_read32(priv, 0x10 | r2, r1);
-	ret &= ~mask;
-	ret |= val;
-	ar8xxx_mii_write32(priv, 0x10 | r2, r1, ret);
-
-	mutex_unlock(&bus->mdio_lock);
-
-	return ret;
-}
-
-void
+static void
 ar8xxx_phy_dbg_write(struct ar8xxx_priv *priv, int phy_addr,
 		     u16 dbg_addr, u16 dbg_data)
 {
@@ -308,7 +332,7 @@ ar8xxx_phy_dbg_write(struct ar8xxx_priv 
 	mutex_unlock(&bus->mdio_lock);
 }
 
-void
+static void
 ar8xxx_phy_mmd_write(struct ar8xxx_priv *priv, int phy_addr, u16 addr, u16 data)
 {
 	struct mii_bus *bus = priv->mii_bus;
@@ -319,18 +343,31 @@ ar8xxx_phy_mmd_write(struct ar8xxx_priv 
 	mutex_unlock(&bus->mdio_lock);
 }
 
-u16
-ar8xxx_phy_mmd_read(struct ar8xxx_priv *priv, int phy_addr, u16 addr)
+static u32
+ar8xxx_rmw(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
 {
-	struct mii_bus *bus = priv->mii_bus;
-	u16 data;
-
-	mutex_lock(&bus->mdio_lock);
-	bus->write(bus, phy_addr, MII_ATH_MMD_ADDR, addr);
-	data = bus->read(bus, phy_addr, MII_ATH_MMD_DATA);
-	mutex_unlock(&bus->mdio_lock);
-
-	return data;
+	u32 v;
+
+	lockdep_assert_held(&priv->reg_mutex);
+
+	v = priv->read(priv, reg);
+	v &= ~mask;
+	v |= val;
+	priv->write(priv, reg, v);
+
+	return v;
+}
+
+static inline void
+ar8xxx_reg_set(struct ar8xxx_priv *priv, int reg, u32 val)
+{
+	u32 v;
+
+	lockdep_assert_held(&priv->reg_mutex);
+
+	v = priv->read(priv, reg);
+	v |= val;
+	priv->write(priv, reg, v);
 }
 
 static int
@@ -342,7 +379,7 @@ ar8xxx_reg_wait(struct ar8xxx_priv *priv
 	for (i = 0; i < timeout; i++) {
 		u32 t;
 
-		t = ar8xxx_read(priv, reg);
+		t = priv->read(priv, reg);
 		if ((t & mask) == val)
 			return 0;
 
@@ -355,13 +392,20 @@ ar8xxx_reg_wait(struct ar8xxx_priv *priv
 static int
 ar8xxx_mib_op(struct ar8xxx_priv *priv, u32 op)
 {
-	unsigned mib_func = priv->chip->mib_func;
+	unsigned mib_func;
 	int ret;
 
 	lockdep_assert_held(&priv->mib_lock);
 
+	if (chip_is_ar8327(priv))
+		mib_func = AR8327_REG_MIB_FUNC;
+	else
+		mib_func = AR8216_REG_MIB_FUNC;
+
+	mutex_lock(&priv->reg_mutex);
 	/* Capture the hardware statistics for all ports */
 	ar8xxx_rmw(priv, mib_func, AR8216_MIB_FUNC, (op << AR8216_MIB_FUNC_S));
+	mutex_unlock(&priv->reg_mutex);
 
 	/* Wait for the capturing to complete. */
 	ret = ar8xxx_reg_wait(priv, mib_func, AR8216_MIB_BUSY, 0, 10);
@@ -397,8 +441,13 @@ ar8xxx_mib_fetch_port_stat(struct ar8xxx
 
 	lockdep_assert_held(&priv->mib_lock);
 
-	base = priv->chip->reg_port_stats_start +
-	       priv->chip->reg_port_stats_length * port;
+	if (chip_is_ar8327(priv))
+		base = AR8327_REG_PORT_STATS_BASE(port);
+	else if (chip_is_ar8236(priv) ||
+		 chip_is_ar8316(priv))
+		base = AR8236_REG_PORT_STATS_BASE(port);
+	else
+		base = AR8216_REG_PORT_STATS_BASE(port);
 
 	mib_stats = &priv->mib_stats[port * priv->chip->num_mibs];
 	for (i = 0; i < priv->chip->num_mibs; i++) {
@@ -406,11 +455,11 @@ ar8xxx_mib_fetch_port_stat(struct ar8xxx
 		u64 t;
 
 		mib = &priv->chip->mib_decs[i];
-		t = ar8xxx_read(priv, base + mib->offset);
+		t = priv->read(priv, base + mib->offset);
 		if (mib->size == 2) {
 			u64 hi;
 
-			hi = ar8xxx_read(priv, base + mib->offset + 4);
+			hi = priv->read(priv, base + mib->offset + 4);
 			t |= hi << 32;
 		}
 
@@ -454,9 +503,6 @@ ar8216_read_port_link(struct ar8xxx_priv
 	link->tx_flow = !!(status & AR8216_PORT_STATUS_TXFLOW);
 	link->rx_flow = !!(status & AR8216_PORT_STATUS_RXFLOW);
 
-	if (link->aneg && link->duplex && priv->chip->read_port_eee_status)
-		link->eee = priv->chip->read_port_eee_status(priv, port);
-
 	speed = (status & AR8216_PORT_STATUS_SPEED) >>
 		 AR8216_PORT_STATUS_SPEED_S;
 
@@ -542,14 +588,14 @@ ar8216_mangle_rx(struct net_device *dev,
 	buf[15 + 2] = vlan & 0xff;
 }
 
-int
+static int
 ar8216_wait_bit(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
 {
 	int timeout = 20;
 	u32 t = 0;
 
 	while (1) {
-		t = ar8xxx_read(priv, reg);
+		t = priv->read(priv, reg);
 		if ((t & mask) == val)
 			return 0;
 
@@ -572,10 +618,10 @@ ar8216_vtu_op(struct ar8xxx_priv *priv, 
 	if ((op & AR8216_VTU_OP) == AR8216_VTU_OP_LOAD) {
 		val &= AR8216_VTUDATA_MEMBER;
 		val |= AR8216_VTUDATA_VALID;
-		ar8xxx_write(priv, AR8216_REG_VTU_DATA, val);
+		priv->write(priv, AR8216_REG_VTU_DATA, val);
 	}
 	op |= AR8216_VTU_ACTIVE;
-	ar8xxx_write(priv, AR8216_REG_VTU, op);
+	priv->write(priv, AR8216_REG_VTU, op);
 }
 
 static void
@@ -600,8 +646,7 @@ ar8216_atu_flush(struct ar8xxx_priv *pri
 
 	ret = ar8216_wait_bit(priv, AR8216_REG_ATU, AR8216_ATU_ACTIVE, 0);
 	if (!ret)
-		ar8xxx_write(priv, AR8216_REG_ATU, AR8216_ATU_OP_FLUSH |
-						   AR8216_ATU_ACTIVE);
+		priv->write(priv, AR8216_REG_ATU, AR8216_ATU_OP_FLUSH);
 
 	return ret;
 }
@@ -609,28 +654,14 @@ ar8216_atu_flush(struct ar8xxx_priv *pri
 static u32
 ar8216_read_port_status(struct ar8xxx_priv *priv, int port)
 {
-	return ar8xxx_read(priv, AR8216_REG_PORT_STATUS(port));
+	return priv->read(priv, AR8216_REG_PORT_STATUS(port));
 }
 
 static void
-ar8216_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
+ar8216_setup_port(struct ar8xxx_priv *priv, int port, u32 egress, u32 ingress,
+		  u32 members, u32 pvid)
 {
 	u32 header;
-	u32 egress, ingress;
-	u32 pvid;
-
-	if (priv->vlan) {
-		pvid = priv->vlan_id[priv->pvid[port]];
-		if (priv->vlan_tagged & (1 << port))
-			egress = AR8216_OUT_ADD_VLAN;
-		else
-			egress = AR8216_OUT_STRIP_VLAN;
-		ingress = AR8216_IN_SECURE;
-	} else {
-		pvid = port;
-		egress = AR8216_OUT_KEEP;
-		ingress = AR8216_IN_PORT_ONLY;
-	}
 
 	if (chip_is_ar8216(priv) && priv->vlan && port == AR8216_PORT_CPU)
 		header = AR8216_PORT_CTRL_HEADER;
@@ -656,12 +687,6 @@ ar8216_setup_port(struct ar8xxx_priv *pr
 static int
 ar8216_hw_init(struct ar8xxx_priv *priv)
 {
-	if (priv->initialized)
-		return 0;
-
-	ar8xxx_phy_init(priv);
-
-	priv->initialized = true;
 	return 0;
 }
 
@@ -669,7 +694,7 @@ static void
 ar8216_init_globals(struct ar8xxx_priv *priv)
 {
 	/* standard atheros magic */
-	ar8xxx_write(priv, 0x38, 0xc000050e);
+	priv->write(priv, 0x38, 0xc000050e);
 
 	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
 		   AR8216_GCTRL_MTU, 1518 + 8 + 2);
@@ -679,14 +704,14 @@ static void
 ar8216_init_port(struct ar8xxx_priv *priv, int port)
 {
 	/* Enable port learning and tx */
-	ar8xxx_write(priv, AR8216_REG_PORT_CTRL(port),
+	priv->write(priv, AR8216_REG_PORT_CTRL(port),
 		AR8216_PORT_CTRL_LEARN |
 		(4 << AR8216_PORT_CTRL_STATE_S));
 
-	ar8xxx_write(priv, AR8216_REG_PORT_VLAN(port), 0);
+	priv->write(priv, AR8216_REG_PORT_VLAN(port), 0);
 
 	if (port == AR8216_PORT_CPU) {
-		ar8xxx_write(priv, AR8216_REG_PORT_STATUS(port),
+		priv->write(priv, AR8216_REG_PORT_STATUS(port),
 			AR8216_PORT_STATUS_LINK_UP |
 			(ar8xxx_has_gige(priv) ?
                                 AR8216_PORT_SPEED_1000M : AR8216_PORT_SPEED_100M) |
@@ -696,30 +721,31 @@ ar8216_init_port(struct ar8xxx_priv *pri
 			(chip_is_ar8316(priv) ? AR8216_PORT_STATUS_TXFLOW : 0) |
 			AR8216_PORT_STATUS_DUPLEX);
 	} else {
-		ar8xxx_write(priv, AR8216_REG_PORT_STATUS(port),
+		priv->write(priv, AR8216_REG_PORT_STATUS(port),
 			AR8216_PORT_STATUS_LINK_AUTO);
 	}
 }
 
+static const struct ar8xxx_chip ar8216_chip = {
+	.caps = AR8XXX_CAP_MIB_COUNTERS,
+
+	.hw_init = ar8216_hw_init,
+	.init_globals = ar8216_init_globals,
+	.init_port = ar8216_init_port,
+	.setup_port = ar8216_setup_port,
+	.read_port_status = ar8216_read_port_status,
+	.atu_flush = ar8216_atu_flush,
+	.vtu_flush = ar8216_vtu_flush,
+	.vtu_load_vlan = ar8216_vtu_load_vlan,
+
+	.num_mibs = ARRAY_SIZE(ar8216_mibs),
+	.mib_decs = ar8216_mibs,
+};
+
 static void
-ar8236_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
+ar8236_setup_port(struct ar8xxx_priv *priv, int port, u32 egress, u32 ingress,
+		  u32 members, u32 pvid)
 {
-	u32 egress, ingress;
-	u32 pvid;
-
-	if (priv->vlan) {
-		pvid = priv->vlan_id[priv->pvid[port]];
-		if (priv->vlan_tagged & (1 << port))
-			egress = AR8216_OUT_ADD_VLAN;
-		else
-			egress = AR8216_OUT_STRIP_VLAN;
-		ingress = AR8216_IN_SECURE;
-	} else {
-		pvid = port;
-		egress = AR8216_OUT_KEEP;
-		ingress = AR8216_IN_PORT_ONLY;
-	}
-
 	ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
 		   AR8216_PORT_CTRL_LEARN | AR8216_PORT_CTRL_VLAN_MODE |
 		   AR8216_PORT_CTRL_SINGLE_VLAN | AR8216_PORT_CTRL_STATE |
@@ -739,6 +765,29 @@ ar8236_setup_port(struct ar8xxx_priv *pr
 		   (members << AR8236_PORT_VLAN2_MEMBER_S));
 }
 
+static int
+ar8236_hw_init(struct ar8xxx_priv *priv)
+{
+	int i;
+	struct mii_bus *bus;
+
+	if (priv->initialized)
+		return 0;
+
+	/* Initialize the PHYs */
+	bus = priv->mii_bus;
+	for (i = 0; i < 5; i++) {
+		mdiobus_write(bus, i, MII_ADVERTISE,
+			      ADVERTISE_ALL | ADVERTISE_PAUSE_CAP |
+			      ADVERTISE_PAUSE_ASYM);
+		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+	}
+	msleep(1000);
+
+	priv->initialized = true;
+	return 0;
+}
+
 static void
 ar8236_init_globals(struct ar8xxx_priv *priv)
 {
@@ -746,26 +795,35 @@ ar8236_init_globals(struct ar8xxx_priv *
 	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
 		   AR8316_GCTRL_MTU, 9018 + 8 + 2);
 
-	/* enable cpu port to receive arp frames */
-	ar8xxx_reg_set(priv, AR8216_REG_ATU_CTRL,
-		   AR8236_ATU_CTRL_RES);
-
-	/* enable cpu port to receive multicast and broadcast frames */
-	ar8xxx_reg_set(priv, AR8216_REG_FLOOD_MASK,
-		   AR8236_FM_CPU_BROADCAST_EN | AR8236_FM_CPU_BCAST_FWD_EN);
-
 	/* Enable MIB counters */
 	ar8xxx_rmw(priv, AR8216_REG_MIB_FUNC, AR8216_MIB_FUNC | AR8236_MIB_EN,
 		   (AR8216_MIB_FUNC_NO_OP << AR8216_MIB_FUNC_S) |
 		   AR8236_MIB_EN);
 }
 
+static const struct ar8xxx_chip ar8236_chip = {
+	.caps = AR8XXX_CAP_MIB_COUNTERS,
+	.hw_init = ar8236_hw_init,
+	.init_globals = ar8236_init_globals,
+	.init_port = ar8216_init_port,
+	.setup_port = ar8236_setup_port,
+	.read_port_status = ar8216_read_port_status,
+	.atu_flush = ar8216_atu_flush,
+	.vtu_flush = ar8216_vtu_flush,
+	.vtu_load_vlan = ar8216_vtu_load_vlan,
+
+	.num_mibs = ARRAY_SIZE(ar8236_mibs),
+	.mib_decs = ar8236_mibs,
+};
+
 static int
 ar8316_hw_init(struct ar8xxx_priv *priv)
 {
+	int i;
 	u32 val, newval;
-
-	val = ar8xxx_read(priv, AR8316_REG_POSTRIP);
+	struct mii_bus *bus;
+
+	val = priv->read(priv, AR8316_REG_POSTRIP);
 
 	if (priv->phy->interface == PHY_INTERFACE_MODE_RGMII) {
 		if (priv->port4_phy) {
@@ -789,7 +847,7 @@ ar8316_hw_init(struct ar8xxx_priv *priv)
 	if (val == newval)
 		goto out;
 
-	ar8xxx_write(priv, AR8316_REG_POSTRIP, newval);
+	priv->write(priv, AR8316_REG_POSTRIP, newval);
 
 	if (priv->port4_phy &&
 	    priv->phy->interface == PHY_INTERFACE_MODE_RGMII) {
@@ -802,7 +860,17 @@ ar8316_hw_init(struct ar8xxx_priv *priv)
 		msleep(1000);
 	}
 
-	ar8xxx_phy_init(priv);
+	/* Initialize the ports */
+	bus = priv->mii_bus;
+	for (i = 0; i < 5; i++) {
+		/* initialize the port itself */
+		mdiobus_write(bus, i, MII_ADVERTISE,
+			ADVERTISE_ALL | ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+		mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
+		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+	}
+
+	msleep(1000);
 
 out:
 	priv->initialized = true;
@@ -813,10 +881,10 @@ static void
 ar8316_init_globals(struct ar8xxx_priv *priv)
 {
 	/* standard atheros magic */
-	ar8xxx_write(priv, 0x38, 0xc000050e);
+	priv->write(priv, 0x38, 0xc000050e);
 
 	/* enable cpu port to receive multicast and broadcast frames */
-	ar8xxx_write(priv, AR8216_REG_FLOOD_MASK, 0x003f003f);
+	priv->write(priv, AR8216_REG_FLOOD_MASK, 0x003f003f);
 
 	/* enable jumbo frames */
 	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
@@ -828,7 +896,484 @@ ar8316_init_globals(struct ar8xxx_priv *
 		   AR8236_MIB_EN);
 }
 
-int
+static const struct ar8xxx_chip ar8316_chip = {
+	.caps = AR8XXX_CAP_GIGE | AR8XXX_CAP_MIB_COUNTERS,
+	.hw_init = ar8316_hw_init,
+	.init_globals = ar8316_init_globals,
+	.init_port = ar8216_init_port,
+	.setup_port = ar8216_setup_port,
+	.read_port_status = ar8216_read_port_status,
+	.atu_flush = ar8216_atu_flush,
+	.vtu_flush = ar8216_vtu_flush,
+	.vtu_load_vlan = ar8216_vtu_load_vlan,
+
+	.num_mibs = ARRAY_SIZE(ar8236_mibs),
+	.mib_decs = ar8236_mibs,
+};
+
+static u32
+ar8327_get_pad_cfg(struct ar8327_pad_cfg *cfg)
+{
+	u32 t;
+
+	if (!cfg)
+		return 0;
+
+	t = 0;
+	switch (cfg->mode) {
+	case AR8327_PAD_NC:
+		break;
+
+	case AR8327_PAD_MAC2MAC_MII:
+		t = AR8327_PAD_MAC_MII_EN;
+		if (cfg->rxclk_sel)
+			t |= AR8327_PAD_MAC_MII_RXCLK_SEL;
+		if (cfg->txclk_sel)
+			t |= AR8327_PAD_MAC_MII_TXCLK_SEL;
+		break;
+
+	case AR8327_PAD_MAC2MAC_GMII:
+		t = AR8327_PAD_MAC_GMII_EN;
+		if (cfg->rxclk_sel)
+			t |= AR8327_PAD_MAC_GMII_RXCLK_SEL;
+		if (cfg->txclk_sel)
+			t |= AR8327_PAD_MAC_GMII_TXCLK_SEL;
+		break;
+
+	case AR8327_PAD_MAC_SGMII:
+		t = AR8327_PAD_SGMII_EN;
+
+		/*
+		 * WAR for the QUalcomm Atheros AP136 board.
+		 * It seems that RGMII TX/RX delay settings needs to be
+		 * applied for SGMII mode as well, The ethernet is not
+		 * reliable without this.
+		 */
+		t |= cfg->txclk_delay_sel << AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S;
+		t |= cfg->rxclk_delay_sel << AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S;
+		if (cfg->rxclk_delay_en)
+			t |= AR8327_PAD_RGMII_RXCLK_DELAY_EN;
+		if (cfg->txclk_delay_en)
+			t |= AR8327_PAD_RGMII_TXCLK_DELAY_EN;
+
+		if (cfg->sgmii_delay_en)
+			t |= AR8327_PAD_SGMII_DELAY_EN;
+
+		break;
+
+	case AR8327_PAD_MAC2PHY_MII:
+		t = AR8327_PAD_PHY_MII_EN;
+		if (cfg->rxclk_sel)
+			t |= AR8327_PAD_PHY_MII_RXCLK_SEL;
+		if (cfg->txclk_sel)
+			t |= AR8327_PAD_PHY_MII_TXCLK_SEL;
+		break;
+
+	case AR8327_PAD_MAC2PHY_GMII:
+		t = AR8327_PAD_PHY_GMII_EN;
+		if (cfg->pipe_rxclk_sel)
+			t |= AR8327_PAD_PHY_GMII_PIPE_RXCLK_SEL;
+		if (cfg->rxclk_sel)
+			t |= AR8327_PAD_PHY_GMII_RXCLK_SEL;
+		if (cfg->txclk_sel)
+			t |= AR8327_PAD_PHY_GMII_TXCLK_SEL;
+		break;
+
+	case AR8327_PAD_MAC_RGMII:
+		t = AR8327_PAD_RGMII_EN;
+		t |= cfg->txclk_delay_sel << AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S;
+		t |= cfg->rxclk_delay_sel << AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S;
+		if (cfg->rxclk_delay_en)
+			t |= AR8327_PAD_RGMII_RXCLK_DELAY_EN;
+		if (cfg->txclk_delay_en)
+			t |= AR8327_PAD_RGMII_TXCLK_DELAY_EN;
+		break;
+
+	case AR8327_PAD_PHY_GMII:
+		t = AR8327_PAD_PHYX_GMII_EN;
+		break;
+
+	case AR8327_PAD_PHY_RGMII:
+		t = AR8327_PAD_PHYX_RGMII_EN;
+		break;
+
+	case AR8327_PAD_PHY_MII:
+		t = AR8327_PAD_PHYX_MII_EN;
+		break;
+	}
+
+	return t;
+}
+
+static void
+ar8327_phy_fixup(struct ar8xxx_priv *priv, int phy)
+{
+	switch (priv->chip_rev) {
+	case 1:
+		/* For 100M waveform */
+		ar8xxx_phy_dbg_write(priv, phy, 0, 0x02ea);
+		/* Turn on Gigabit clock */
+		ar8xxx_phy_dbg_write(priv, phy, 0x3d, 0x68a0);
+		break;
+
+	case 2:
+		ar8xxx_phy_mmd_write(priv, phy, 0x7, 0x3c);
+		ar8xxx_phy_mmd_write(priv, phy, 0x4007, 0x0);
+		/* fallthrough */
+	case 4:
+		ar8xxx_phy_mmd_write(priv, phy, 0x3, 0x800d);
+		ar8xxx_phy_mmd_write(priv, phy, 0x4003, 0x803f);
+
+		ar8xxx_phy_dbg_write(priv, phy, 0x3d, 0x6860);
+		ar8xxx_phy_dbg_write(priv, phy, 0x5, 0x2c46);
+		ar8xxx_phy_dbg_write(priv, phy, 0x3c, 0x6000);
+		break;
+	}
+}
+
+static u32
+ar8327_get_port_init_status(struct ar8327_port_cfg *cfg)
+{
+	u32 t;
+
+	if (!cfg->force_link)
+		return AR8216_PORT_STATUS_LINK_AUTO;
+
+	t = AR8216_PORT_STATUS_TXMAC | AR8216_PORT_STATUS_RXMAC;
+	t |= cfg->duplex ? AR8216_PORT_STATUS_DUPLEX : 0;
+	t |= cfg->rxpause ? AR8216_PORT_STATUS_RXFLOW : 0;
+	t |= cfg->txpause ? AR8216_PORT_STATUS_TXFLOW : 0;
+
+	switch (cfg->speed) {
+	case AR8327_PORT_SPEED_10:
+		t |= AR8216_PORT_SPEED_10M;
+		break;
+	case AR8327_PORT_SPEED_100:
+		t |= AR8216_PORT_SPEED_100M;
+		break;
+	case AR8327_PORT_SPEED_1000:
+		t |= AR8216_PORT_SPEED_1000M;
+		break;
+	}
+
+	return t;
+}
+
+static int
+ar8327_hw_config_pdata(struct ar8xxx_priv *priv,
+		       struct ar8327_platform_data *pdata)
+{
+	struct ar8327_led_cfg *led_cfg;
+	struct ar8327_data *data;
+	u32 pos, new_pos;
+	u32 t;
+
+	if (!pdata)
+		return -EINVAL;
+
+	priv->get_port_link = pdata->get_port_link;
+
+	data = &priv->chip_data.ar8327;
+
+	data->port0_status = ar8327_get_port_init_status(&pdata->port0_cfg);
+	data->port6_status = ar8327_get_port_init_status(&pdata->port6_cfg);
+
+	t = ar8327_get_pad_cfg(pdata->pad0_cfg);
+	priv->write(priv, AR8327_REG_PAD0_MODE, t);
+	t = ar8327_get_pad_cfg(pdata->pad5_cfg);
+	priv->write(priv, AR8327_REG_PAD5_MODE, t);
+	t = ar8327_get_pad_cfg(pdata->pad6_cfg);
+	priv->write(priv, AR8327_REG_PAD6_MODE, t);
+
+	pos = priv->read(priv, AR8327_REG_POWER_ON_STRIP);
+	new_pos = pos;
+
+	led_cfg = pdata->led_cfg;
+	if (led_cfg) {
+		if (led_cfg->open_drain)
+			new_pos |= AR8327_POWER_ON_STRIP_LED_OPEN_EN;
+		else
+			new_pos &= ~AR8327_POWER_ON_STRIP_LED_OPEN_EN;
+
+		priv->write(priv, AR8327_REG_LED_CTRL0, led_cfg->led_ctrl0);
+		priv->write(priv, AR8327_REG_LED_CTRL1, led_cfg->led_ctrl1);
+		priv->write(priv, AR8327_REG_LED_CTRL2, led_cfg->led_ctrl2);
+		priv->write(priv, AR8327_REG_LED_CTRL3, led_cfg->led_ctrl3);
+
+		if (new_pos != pos)
+			new_pos |= AR8327_POWER_ON_STRIP_POWER_ON_SEL;
+	}
+
+	if (pdata->sgmii_cfg) {
+		t = pdata->sgmii_cfg->sgmii_ctrl;
+		if (priv->chip_rev == 1)
+			t |= AR8327_SGMII_CTRL_EN_PLL |
+			     AR8327_SGMII_CTRL_EN_RX |
+			     AR8327_SGMII_CTRL_EN_TX;
+		else
+			t &= ~(AR8327_SGMII_CTRL_EN_PLL |
+			       AR8327_SGMII_CTRL_EN_RX |
+			       AR8327_SGMII_CTRL_EN_TX);
+
+		priv->write(priv, AR8327_REG_SGMII_CTRL, t);
+
+		if (pdata->sgmii_cfg->serdes_aen)
+			new_pos &= ~AR8327_POWER_ON_STRIP_SERDES_AEN;
+		else
+			new_pos |= AR8327_POWER_ON_STRIP_SERDES_AEN;
+	}
+
+	priv->write(priv, AR8327_REG_POWER_ON_STRIP, new_pos);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static int
+ar8327_hw_config_of(struct ar8xxx_priv *priv, struct device_node *np)
+{
+	const __be32 *paddr;
+	int len;
+	int i;
+
+	paddr = of_get_property(np, "qca,ar8327-initvals", &len);
+	if (!paddr || len < (2 * sizeof(*paddr)))
+		return -EINVAL;
+
+	len /= sizeof(*paddr);
+
+	for (i = 0; i < len - 1; i += 2) {
+		u32 reg;
+		u32 val;
+
+		reg = be32_to_cpup(paddr + i);
+		val = be32_to_cpup(paddr + i + 1);
+
+		switch (reg) {
+		case AR8327_REG_PORT_STATUS(0):
+			priv->chip_data.ar8327.port0_status = val;
+			break;
+		case AR8327_REG_PORT_STATUS(6):
+			priv->chip_data.ar8327.port6_status = val;
+			break;
+		default:
+			priv->write(priv, reg, val);
+			break;
+		}
+	}
+
+	return 0;
+}
+#else
+static inline int
+ar8327_hw_config_of(struct ar8xxx_priv *priv, struct device_node *np)
+{
+	return -EINVAL;
+}
+#endif
+
+static int
+ar8327_hw_init(struct ar8xxx_priv *priv)
+{
+	struct mii_bus *bus;
+	int ret;
+	int i;
+
+	if (priv->phy->dev.of_node)
+		ret = ar8327_hw_config_of(priv, priv->phy->dev.of_node);
+	else
+		ret = ar8327_hw_config_pdata(priv,
+					     priv->phy->dev.platform_data);
+
+	if (ret)
+		return ret;
+
+	bus = priv->mii_bus;
+	for (i = 0; i < AR8327_NUM_PHYS; i++) {
+		ar8327_phy_fixup(priv, i);
+
+		/* start aneg on the PHY */
+		mdiobus_write(bus, i, MII_ADVERTISE, ADVERTISE_ALL |
+						     ADVERTISE_PAUSE_CAP |
+						     ADVERTISE_PAUSE_ASYM);
+		mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
+		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+	}
+
+	msleep(1000);
+
+	return 0;
+}
+
+static void
+ar8327_init_globals(struct ar8xxx_priv *priv)
+{
+	u32 t;
+
+	/* enable CPU port and disable mirror port */
+	t = AR8327_FWD_CTRL0_CPU_PORT_EN |
+	    AR8327_FWD_CTRL0_MIRROR_PORT;
+	priv->write(priv, AR8327_REG_FWD_CTRL0, t);
+
+	/* forward multicast and broadcast frames to CPU */
+	t = (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_UC_FLOOD_S) |
+	    (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_MC_FLOOD_S) |
+	    (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_BC_FLOOD_S);
+	priv->write(priv, AR8327_REG_FWD_CTRL1, t);
+
+	/* setup MTU */
+	ar8xxx_rmw(priv, AR8327_REG_MAX_FRAME_SIZE,
+		   AR8327_MAX_FRAME_SIZE_MTU, 1518 + 8 + 2);
+
+	/* Enable MIB counters */
+	ar8xxx_reg_set(priv, AR8327_REG_MODULE_EN,
+		       AR8327_MODULE_EN_MIB);
+}
+
+static void
+ar8327_init_port(struct ar8xxx_priv *priv, int port)
+{
+	u32 t;
+
+	if (port == AR8216_PORT_CPU)
+		t = priv->chip_data.ar8327.port0_status;
+	else if (port == 6)
+		t = priv->chip_data.ar8327.port6_status;
+	else
+		t = AR8216_PORT_STATUS_LINK_AUTO;
+
+	priv->write(priv, AR8327_REG_PORT_STATUS(port), t);
+	priv->write(priv, AR8327_REG_PORT_HEADER(port), 0);
+
+	t = 1 << AR8327_PORT_VLAN0_DEF_SVID_S;
+	t |= 1 << AR8327_PORT_VLAN0_DEF_CVID_S;
+	priv->write(priv, AR8327_REG_PORT_VLAN0(port), t);
+
+	t = AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH << AR8327_PORT_VLAN1_OUT_MODE_S;
+	priv->write(priv, AR8327_REG_PORT_VLAN1(port), t);
+
+	t = AR8327_PORT_LOOKUP_LEARN;
+	t |= AR8216_PORT_STATE_FORWARD << AR8327_PORT_LOOKUP_STATE_S;
+	priv->write(priv, AR8327_REG_PORT_LOOKUP(port), t);
+}
+
+static u32
+ar8327_read_port_status(struct ar8xxx_priv *priv, int port)
+{
+	return priv->read(priv, AR8327_REG_PORT_STATUS(port));
+}
+
+static int
+ar8327_atu_flush(struct ar8xxx_priv *priv)
+{
+	int ret;
+
+	ret = ar8216_wait_bit(priv, AR8327_REG_ATU_FUNC,
+			      AR8327_ATU_FUNC_BUSY, 0);
+	if (!ret)
+		priv->write(priv, AR8327_REG_ATU_FUNC,
+			    AR8327_ATU_FUNC_OP_FLUSH);
+
+	return ret;
+}
+
+static void
+ar8327_vtu_op(struct ar8xxx_priv *priv, u32 op, u32 val)
+{
+	if (ar8216_wait_bit(priv, AR8327_REG_VTU_FUNC1,
+			    AR8327_VTU_FUNC1_BUSY, 0))
+		return;
+
+	if ((op & AR8327_VTU_FUNC1_OP) == AR8327_VTU_FUNC1_OP_LOAD)
+		priv->write(priv, AR8327_REG_VTU_FUNC0, val);
+
+	op |= AR8327_VTU_FUNC1_BUSY;
+	priv->write(priv, AR8327_REG_VTU_FUNC1, op);
+}
+
+static void
+ar8327_vtu_flush(struct ar8xxx_priv *priv)
+{
+	ar8327_vtu_op(priv, AR8327_VTU_FUNC1_OP_FLUSH, 0);
+}
+
+static void
+ar8327_vtu_load_vlan(struct ar8xxx_priv *priv, u32 vid, u32 port_mask)
+{
+	u32 op;
+	u32 val;
+	int i;
+
+	op = AR8327_VTU_FUNC1_OP_LOAD | (vid << AR8327_VTU_FUNC1_VID_S);
+	val = AR8327_VTU_FUNC0_VALID | AR8327_VTU_FUNC0_IVL;
+	for (i = 0; i < AR8327_NUM_PORTS; i++) {
+		u32 mode;
+
+		if ((port_mask & BIT(i)) == 0)
+			mode = AR8327_VTU_FUNC0_EG_MODE_NOT;
+		else if (priv->vlan == 0)
+			mode = AR8327_VTU_FUNC0_EG_MODE_KEEP;
+		else if (priv->vlan_tagged & BIT(i))
+			mode = AR8327_VTU_FUNC0_EG_MODE_TAG;
+		else
+			mode = AR8327_VTU_FUNC0_EG_MODE_UNTAG;
+
+		val |= mode << AR8327_VTU_FUNC0_EG_MODE_S(i);
+	}
+	ar8327_vtu_op(priv, op, val);
+}
+
+static void
+ar8327_setup_port(struct ar8xxx_priv *priv, int port, u32 egress, u32 ingress,
+		  u32 members, u32 pvid)
+{
+	u32 t;
+	u32 mode;
+
+	t = pvid << AR8327_PORT_VLAN0_DEF_SVID_S;
+	t |= pvid << AR8327_PORT_VLAN0_DEF_CVID_S;
+	priv->write(priv, AR8327_REG_PORT_VLAN0(port), t);
+
+	mode = AR8327_PORT_VLAN1_OUT_MODE_UNMOD;
+	switch (egress) {
+	case AR8216_OUT_KEEP:
+		mode = AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH;
+		break;
+	case AR8216_OUT_STRIP_VLAN:
+		mode = AR8327_PORT_VLAN1_OUT_MODE_UNTAG;
+		break;
+	case AR8216_OUT_ADD_VLAN:
+		mode = AR8327_PORT_VLAN1_OUT_MODE_TAG;
+		break;
+	}
+
+	t = AR8327_PORT_VLAN1_PORT_VLAN_PROP;
+	t |= mode << AR8327_PORT_VLAN1_OUT_MODE_S;
+	priv->write(priv, AR8327_REG_PORT_VLAN1(port), t);
+
+	t = members;
+	t |= AR8327_PORT_LOOKUP_LEARN;
+	t |= ingress << AR8327_PORT_LOOKUP_IN_MODE_S;
+	t |= AR8216_PORT_STATE_FORWARD << AR8327_PORT_LOOKUP_STATE_S;
+	priv->write(priv, AR8327_REG_PORT_LOOKUP(port), t);
+}
+
+static const struct ar8xxx_chip ar8327_chip = {
+	.caps = AR8XXX_CAP_GIGE | AR8XXX_CAP_MIB_COUNTERS,
+	.hw_init = ar8327_hw_init,
+	.init_globals = ar8327_init_globals,
+	.init_port = ar8327_init_port,
+	.setup_port = ar8327_setup_port,
+	.read_port_status = ar8327_read_port_status,
+	.atu_flush = ar8327_atu_flush,
+	.vtu_flush = ar8327_vtu_flush,
+	.vtu_load_vlan = ar8327_vtu_load_vlan,
+
+	.num_mibs = ARRAY_SIZE(ar8236_mibs),
+	.mib_decs = ar8236_mibs,
+};
+
+static int
 ar8xxx_sw_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
 		   struct switch_val *val)
 {
@@ -837,7 +1382,7 @@ ar8xxx_sw_set_vlan(struct switch_dev *de
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
 		   struct switch_val *val)
 {
@@ -847,7 +1392,7 @@ ar8xxx_sw_get_vlan(struct switch_dev *de
 }
 
 
-int
+static int
 ar8xxx_sw_set_pvid(struct switch_dev *dev, int port, int vlan)
 {
 	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
@@ -861,7 +1406,7 @@ ar8xxx_sw_set_pvid(struct switch_dev *de
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_get_pvid(struct switch_dev *dev, int port, int *vlan)
 {
 	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
@@ -887,7 +1432,7 @@ ar8xxx_sw_get_vid(struct switch_dev *dev
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_get_port_link(struct switch_dev *dev, int port,
 			struct switch_port_link *link)
 {
@@ -953,6 +1498,47 @@ ar8xxx_sw_set_ports(struct switch_dev *d
 }
 
 static void
+ar8327_set_mirror_regs(struct ar8xxx_priv *priv)
+{
+	int port;
+ 
+	/* reset all mirror registers */
+	ar8xxx_rmw(priv, AR8327_REG_FWD_CTRL0,
+		   AR8327_FWD_CTRL0_MIRROR_PORT,
+		   (0xF << AR8327_FWD_CTRL0_MIRROR_PORT_S));
+	for (port = 0; port < AR8327_NUM_PORTS; port++) {
+		ar8xxx_rmw(priv, AR8327_REG_PORT_LOOKUP(port),
+			   AR8327_PORT_LOOKUP_ING_MIRROR_EN,
+			   0);
+
+		ar8xxx_rmw(priv, AR8327_REG_PORT_HOL_CTRL1(port),
+			   AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN,
+			   0);
+	}
+
+	/* now enable mirroring if necessary */
+	if (priv->source_port >= AR8327_NUM_PORTS ||
+	    priv->monitor_port >= AR8327_NUM_PORTS ||
+	    priv->source_port == priv->monitor_port) {
+		return;
+	}
+
+	ar8xxx_rmw(priv, AR8327_REG_FWD_CTRL0,
+		   AR8327_FWD_CTRL0_MIRROR_PORT,
+		   (priv->monitor_port << AR8327_FWD_CTRL0_MIRROR_PORT_S));
+
+	if (priv->mirror_rx)
+		ar8xxx_rmw(priv, AR8327_REG_PORT_LOOKUP(priv->source_port),
+			   AR8327_PORT_LOOKUP_ING_MIRROR_EN,
+			   AR8327_PORT_LOOKUP_ING_MIRROR_EN);
+
+	if (priv->mirror_tx)
+		ar8xxx_rmw(priv, AR8327_REG_PORT_HOL_CTRL1(priv->source_port),
+			   AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN,
+			   AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN);
+}
+
+static void
 ar8216_set_mirror_regs(struct ar8xxx_priv *priv)
 {
 	int port;
@@ -962,11 +1548,13 @@ ar8216_set_mirror_regs(struct ar8xxx_pri
 		   AR8216_GLOBAL_CPUPORT_MIRROR_PORT,
 		   (0xF << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));
 	for (port = 0; port < AR8216_NUM_PORTS; port++) {
-		ar8xxx_reg_clear(priv, AR8216_REG_PORT_CTRL(port),
-			   AR8216_PORT_CTRL_MIRROR_RX);
-
-		ar8xxx_reg_clear(priv, AR8216_REG_PORT_CTRL(port),
-			   AR8216_PORT_CTRL_MIRROR_TX);
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
+			   AR8216_PORT_CTRL_MIRROR_RX,
+			   0);
+
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
+			   AR8216_PORT_CTRL_MIRROR_TX,
+			   0);
 	}
 
 	/* now enable mirroring if necessary */
@@ -981,15 +1569,27 @@ ar8216_set_mirror_regs(struct ar8xxx_pri
 		   (priv->monitor_port << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));
 
 	if (priv->mirror_rx)
-		ar8xxx_reg_set(priv, AR8216_REG_PORT_CTRL(priv->source_port),
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(priv->source_port),
+			   AR8216_PORT_CTRL_MIRROR_RX,
 			   AR8216_PORT_CTRL_MIRROR_RX);
 
 	if (priv->mirror_tx)
-		ar8xxx_reg_set(priv, AR8216_REG_PORT_CTRL(priv->source_port),
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(priv->source_port),
+			   AR8216_PORT_CTRL_MIRROR_TX,
 			   AR8216_PORT_CTRL_MIRROR_TX);
 }
 
-int
+static void
+ar8xxx_set_mirror_regs(struct ar8xxx_priv *priv)
+{
+	if (chip_is_ar8327(priv)) {
+		ar8327_set_mirror_regs(priv);
+	} else {
+		ar8216_set_mirror_regs(priv);
+	}
+}
+
+static int
 ar8xxx_sw_hw_apply(struct switch_dev *dev)
 {
 	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
@@ -1033,20 +1633,36 @@ ar8xxx_sw_hw_apply(struct switch_dev *de
 
 	/* update the port destination mask registers and tag settings */
 	for (i = 0; i < dev->ports; i++) {
-		priv->chip->setup_port(priv, i, portmask[i]);
+		int egress, ingress;
+		int pvid;
+
+		if (priv->vlan) {
+			pvid = priv->vlan_id[priv->pvid[i]];
+			if (priv->vlan_tagged & (1 << i))
+				egress = AR8216_OUT_ADD_VLAN;
+			else
+				egress = AR8216_OUT_STRIP_VLAN;
+			ingress = AR8216_IN_SECURE;
+		} else {
+			pvid = i;
+			egress = AR8216_OUT_KEEP;
+			ingress = AR8216_IN_PORT_ONLY;
+		}
+
+		priv->chip->setup_port(priv, i, egress, ingress, portmask[i],
+				       pvid);
 	}
-
-	priv->chip->set_mirror_regs(priv);
-
+	
+	ar8xxx_set_mirror_regs(priv);
+	
 	mutex_unlock(&priv->reg_mutex);
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_reset_switch(struct switch_dev *dev)
 {
 	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-	const struct ar8xxx_chip *chip = priv->chip;
 	int i;
 
 	mutex_lock(&priv->reg_mutex);
@@ -1058,21 +1674,21 @@ ar8xxx_sw_reset_switch(struct switch_dev
 
 	/* Configure all ports */
 	for (i = 0; i < dev->ports; i++)
-		chip->init_port(priv, i);
+		priv->chip->init_port(priv, i);
 
 	priv->mirror_rx = false;
 	priv->mirror_tx = false;
 	priv->source_port = 0;
 	priv->monitor_port = 0;
-
-	chip->init_globals(priv);
+	
+	priv->chip->init_globals(priv);
 
 	mutex_unlock(&priv->reg_mutex);
 
-	return chip->sw_hw_apply(dev);
+	return ar8xxx_sw_hw_apply(dev);
 }
 
-int
+static int
 ar8xxx_sw_set_reset_mibs(struct switch_dev *dev,
 			 const struct switch_attr *attr,
 			 struct switch_val *val)
@@ -1100,22 +1716,22 @@ unlock:
 	return ret;
 }
 
-int
+static int
 ar8xxx_sw_set_mirror_rx_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val)
 {
 	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-
+	
 	mutex_lock(&priv->reg_mutex);
 	priv->mirror_rx = !!val->value.i;
-	priv->chip->set_mirror_regs(priv);
+	ar8xxx_set_mirror_regs(priv);
 	mutex_unlock(&priv->reg_mutex);
 
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_get_mirror_rx_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val)
@@ -1125,7 +1741,7 @@ ar8xxx_sw_get_mirror_rx_enable(struct sw
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_set_mirror_tx_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val)
@@ -1134,13 +1750,13 @@ ar8xxx_sw_set_mirror_tx_enable(struct sw
 
 	mutex_lock(&priv->reg_mutex);
 	priv->mirror_tx = !!val->value.i;
-	priv->chip->set_mirror_regs(priv);
+	ar8xxx_set_mirror_regs(priv);
 	mutex_unlock(&priv->reg_mutex);
 
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_get_mirror_tx_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val)
@@ -1150,22 +1766,22 @@ ar8xxx_sw_get_mirror_tx_enable(struct sw
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_set_mirror_monitor_port(struct switch_dev *dev,
 				  const struct switch_attr *attr,
 				  struct switch_val *val)
 {
 	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-
+	
 	mutex_lock(&priv->reg_mutex);
 	priv->monitor_port = val->value.i;
-	priv->chip->set_mirror_regs(priv);
+	ar8xxx_set_mirror_regs(priv);
 	mutex_unlock(&priv->reg_mutex);
 
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_get_mirror_monitor_port(struct switch_dev *dev,
 				  const struct switch_attr *attr,
 				  struct switch_val *val)
@@ -1175,22 +1791,22 @@ ar8xxx_sw_get_mirror_monitor_port(struct
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_set_mirror_source_port(struct switch_dev *dev,
 				 const struct switch_attr *attr,
 				 struct switch_val *val)
 {
 	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-
+	
 	mutex_lock(&priv->reg_mutex);
 	priv->source_port = val->value.i;
-	priv->chip->set_mirror_regs(priv);
+	ar8xxx_set_mirror_regs(priv);
 	mutex_unlock(&priv->reg_mutex);
 
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_get_mirror_source_port(struct switch_dev *dev,
 				 const struct switch_attr *attr,
 				 struct switch_val *val)
@@ -1200,7 +1816,7 @@ ar8xxx_sw_get_mirror_source_port(struct 
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_set_port_reset_mib(struct switch_dev *dev,
 			     const struct switch_attr *attr,
 			     struct switch_val *val)
@@ -1230,7 +1846,7 @@ unlock:
 	return ret;
 }
 
-int
+static int
 ar8xxx_sw_get_port_mib(struct switch_dev *dev,
 		       const struct switch_attr *attr,
 		       struct switch_val *val)
@@ -1278,79 +1894,7 @@ unlock:
 	return ret;
 }
 
-int
-ar8xxx_sw_get_arl_table(struct switch_dev *dev,
-			const struct switch_attr *attr,
-			struct switch_val *val)
-{
-	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-	struct mii_bus *bus = priv->mii_bus;
-	const struct ar8xxx_chip *chip = priv->chip;
-	char *buf = priv->arl_buf;
-	int i, j, k, len = 0;
-	struct arl_entry *a, *a1;
-	u32 status;
-
-	if (!chip->get_arl_entry)
-		return -EOPNOTSUPP;
-
-	mutex_lock(&priv->reg_mutex);
-	mutex_lock(&bus->mdio_lock);
-
-	chip->get_arl_entry(priv, NULL, NULL, AR8XXX_ARL_INITIALIZE);
-
-	for(i = 0; i < AR8XXX_NUM_ARL_RECORDS; ++i) {
-		a = &priv->arl_table[i];
-		duplicate:
-		chip->get_arl_entry(priv, a, &status, AR8XXX_ARL_GET_NEXT);
-
-		if (!status)
-			break;
-
-		/* avoid duplicates
-		 * ARL table can include multiple valid entries
-		 * per MAC, just with differing status codes
-		 */
-		for (j = 0; j < i; ++j) {
-			a1 = &priv->arl_table[j];
-			if (a->port == a1->port && !memcmp(a->mac, a1->mac, sizeof(a->mac)))
-				goto duplicate;
-		}
-	}
-
-	mutex_unlock(&bus->mdio_lock);
-
-	len += snprintf(buf + len, sizeof(priv->arl_buf) - len,
-                        "address resolution table\n");
-
-	if (i == AR8XXX_NUM_ARL_RECORDS)
-		len += snprintf(buf + len, sizeof(priv->arl_buf) - len,
-				"Too many entries found, displaying the first %d only!\n",
-				AR8XXX_NUM_ARL_RECORDS);
-
-	for (j = 0; j < priv->dev.ports; ++j) {
-		for (k = 0; k < i; ++k) {
-			a = &priv->arl_table[k];
-			if (a->port != j)
-				continue;
-			len += snprintf(buf + len, sizeof(priv->arl_buf) - len,
-					"Port %d: MAC %02x:%02x:%02x:%02x:%02x:%02x\n",
-					j,
-					a->mac[5], a->mac[4], a->mac[3],
-					a->mac[2], a->mac[1], a->mac[0]);
-		}
-	}
-
-	val->value.s = buf;
-	val->len = len;
-
-	mutex_unlock(&priv->reg_mutex);
-
-	return 0;
-}
-
-
-static const struct switch_attr ar8xxx_sw_attr_globals[] = {
+static struct switch_attr ar8xxx_sw_attr_globals[] = {
 	{
 		.type = SWITCH_TYPE_INT,
 		.name = "enable_vlan",
@@ -1387,7 +1931,7 @@ static const struct switch_attr ar8xxx_s
 		.description = "Mirror monitor port",
 		.set = ar8xxx_sw_set_mirror_monitor_port,
 		.get = ar8xxx_sw_get_mirror_monitor_port,
-		.max = AR8216_NUM_PORTS - 1
+		.max = AR8216_NUM_PORTS - 1 
 	},
 	{
 		.type = SWITCH_TYPE_INT,
@@ -1397,16 +1941,58 @@ static const struct switch_attr ar8xxx_s
 		.get = ar8xxx_sw_get_mirror_source_port,
 		.max = AR8216_NUM_PORTS - 1
  	},
+};
+
+static struct switch_attr ar8327_sw_attr_globals[] = {
 	{
-		.type = SWITCH_TYPE_STRING,
-		.name = "arl_table",
-		.description = "Get ARL table",
-		.set = NULL,
-		.get = ar8xxx_sw_get_arl_table,
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "Enable VLAN mode",
+		.set = ar8xxx_sw_set_vlan,
+		.get = ar8xxx_sw_get_vlan,
+		.max = 1
 	},
+	{
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset_mibs",
+		.description = "Reset all MIB counters",
+		.set = ar8xxx_sw_set_reset_mibs,
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_rx",
+		.description = "Enable mirroring of RX packets",
+		.set = ar8xxx_sw_set_mirror_rx_enable,
+		.get = ar8xxx_sw_get_mirror_rx_enable,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_tx",
+		.description = "Enable mirroring of TX packets",
+		.set = ar8xxx_sw_set_mirror_tx_enable,
+		.get = ar8xxx_sw_get_mirror_tx_enable,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "mirror_monitor_port",
+		.description = "Mirror monitor port",
+		.set = ar8xxx_sw_set_mirror_monitor_port,
+		.get = ar8xxx_sw_get_mirror_monitor_port,
+		.max = AR8327_NUM_PORTS - 1 
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "mirror_source_port",
+		.description = "Mirror source port",
+		.set = ar8xxx_sw_set_mirror_source_port,
+		.get = ar8xxx_sw_get_mirror_source_port,
+		.max = AR8327_NUM_PORTS - 1
+ 	},
 };
 
-const struct switch_attr ar8xxx_sw_attr_port[2] = {
+static struct switch_attr ar8xxx_sw_attr_port[] = {
 	{
 		.type = SWITCH_TYPE_NOVAL,
 		.name = "reset_mib",
@@ -1422,7 +2008,7 @@ const struct switch_attr ar8xxx_sw_attr_
 	},
 };
 
-const struct switch_attr ar8xxx_sw_attr_vlan[1] = {
+static struct switch_attr ar8xxx_sw_attr_vlan[] = {
 	{
 		.type = SWITCH_TYPE_INT,
 		.name = "vid",
@@ -1455,85 +2041,26 @@ static const struct switch_dev_ops ar8xx
 	.get_port_link = ar8xxx_sw_get_port_link,
 };
 
-static const struct ar8xxx_chip ar8216_chip = {
-	.caps = AR8XXX_CAP_MIB_COUNTERS,
-
-	.reg_port_stats_start = 0x19000,
-	.reg_port_stats_length = 0xa0,
-
-	.name = "Atheros AR8216",
-	.ports = AR8216_NUM_PORTS,
-	.vlans = AR8216_NUM_VLANS,
-	.swops = &ar8xxx_sw_ops,
-
-	.hw_init = ar8216_hw_init,
-	.init_globals = ar8216_init_globals,
-	.init_port = ar8216_init_port,
-	.setup_port = ar8216_setup_port,
-	.read_port_status = ar8216_read_port_status,
-	.atu_flush = ar8216_atu_flush,
-	.vtu_flush = ar8216_vtu_flush,
-	.vtu_load_vlan = ar8216_vtu_load_vlan,
-	.set_mirror_regs = ar8216_set_mirror_regs,
-	.sw_hw_apply = ar8xxx_sw_hw_apply,
-
-	.num_mibs = ARRAY_SIZE(ar8216_mibs),
-	.mib_decs = ar8216_mibs,
-	.mib_func = AR8216_REG_MIB_FUNC
-};
-
-static const struct ar8xxx_chip ar8236_chip = {
-	.caps = AR8XXX_CAP_MIB_COUNTERS,
-
-	.reg_port_stats_start = 0x20000,
-	.reg_port_stats_length = 0x100,
-
-	.name = "Atheros AR8236",
-	.ports = AR8216_NUM_PORTS,
-	.vlans = AR8216_NUM_VLANS,
-	.swops = &ar8xxx_sw_ops,
-
-	.hw_init = ar8216_hw_init,
-	.init_globals = ar8236_init_globals,
-	.init_port = ar8216_init_port,
-	.setup_port = ar8236_setup_port,
-	.read_port_status = ar8216_read_port_status,
-	.atu_flush = ar8216_atu_flush,
-	.vtu_flush = ar8216_vtu_flush,
-	.vtu_load_vlan = ar8216_vtu_load_vlan,
-	.set_mirror_regs = ar8216_set_mirror_regs,
-	.sw_hw_apply = ar8xxx_sw_hw_apply,
-
-	.num_mibs = ARRAY_SIZE(ar8236_mibs),
-	.mib_decs = ar8236_mibs,
-	.mib_func = AR8216_REG_MIB_FUNC
-};
-
-static const struct ar8xxx_chip ar8316_chip = {
-	.caps = AR8XXX_CAP_GIGE | AR8XXX_CAP_MIB_COUNTERS,
-
-	.reg_port_stats_start = 0x20000,
-	.reg_port_stats_length = 0x100,
-
-	.name = "Atheros AR8316",
-	.ports = AR8216_NUM_PORTS,
-	.vlans = AR8X16_MAX_VLANS,
-	.swops = &ar8xxx_sw_ops,
-
-	.hw_init = ar8316_hw_init,
-	.init_globals = ar8316_init_globals,
-	.init_port = ar8216_init_port,
-	.setup_port = ar8216_setup_port,
-	.read_port_status = ar8216_read_port_status,
-	.atu_flush = ar8216_atu_flush,
-	.vtu_flush = ar8216_vtu_flush,
-	.vtu_load_vlan = ar8216_vtu_load_vlan,
-	.set_mirror_regs = ar8216_set_mirror_regs,
-	.sw_hw_apply = ar8xxx_sw_hw_apply,
-
-	.num_mibs = ARRAY_SIZE(ar8236_mibs),
-	.mib_decs = ar8236_mibs,
-	.mib_func = AR8216_REG_MIB_FUNC
+static const struct switch_dev_ops ar8327_sw_ops = {
+	.attr_global = {
+		.attr = ar8327_sw_attr_globals,
+		.n_attr = ARRAY_SIZE(ar8327_sw_attr_globals),
+	},
+	.attr_port = {
+		.attr = ar8xxx_sw_attr_port,
+		.n_attr = ARRAY_SIZE(ar8xxx_sw_attr_port),
+	},
+	.attr_vlan = {
+		.attr = ar8xxx_sw_attr_vlan,
+		.n_attr = ARRAY_SIZE(ar8xxx_sw_attr_vlan),
+	},
+	.get_port_pvid = ar8xxx_sw_get_pvid,
+	.set_port_pvid = ar8xxx_sw_set_pvid,
+	.get_vlan_ports = ar8xxx_sw_get_ports,
+	.set_vlan_ports = ar8xxx_sw_set_ports,
+	.apply_config = ar8xxx_sw_hw_apply,
+	.reset_switch = ar8xxx_sw_reset_switch,
+	.get_port_link = ar8xxx_sw_get_port_link,
 };
 
 static int
@@ -1543,7 +2070,7 @@ ar8xxx_id_chip(struct ar8xxx_priv *priv)
 	u16 id;
 	int i;
 
-	val = ar8xxx_read(priv, AR8216_REG_CTRL);
+	val = priv->read(priv, AR8216_REG_CTRL);
 	if (val == ~0)
 		return -ENODEV;
 
@@ -1551,7 +2078,7 @@ ar8xxx_id_chip(struct ar8xxx_priv *priv)
 	for (i = 0; i < AR8X16_PROBE_RETRIES; i++) {
 		u16 t;
 
-		val = ar8xxx_read(priv, AR8216_REG_CTRL);
+		val = priv->read(priv, AR8216_REG_CTRL);
 		if (val == ~0)
 			return -ENODEV;
 
@@ -1574,11 +2101,9 @@ ar8xxx_id_chip(struct ar8xxx_priv *priv)
 		priv->chip = &ar8316_chip;
 		break;
 	case AR8XXX_VER_AR8327:
+		priv->mii_lo_first = true;
 		priv->chip = &ar8327_chip;
 		break;
-	case AR8XXX_VER_AR8337:
-		priv->chip = &ar8337_chip;
-		break;
 	default:
 		pr_err("ar8216: Unknown Atheros device [ver=%d, rev=%d]\n",
 		       priv->chip_ver, priv->chip_rev);
@@ -1673,18 +2198,28 @@ ar8xxx_create(void)
 static void
 ar8xxx_free(struct ar8xxx_priv *priv)
 {
-	if (priv->chip && priv->chip->cleanup)
-		priv->chip->cleanup(priv);
-
-	kfree(priv->chip_data);
 	kfree(priv->mib_stats);
 	kfree(priv);
 }
 
+static struct ar8xxx_priv *
+ar8xxx_create_mii(struct mii_bus *bus)
+{
+	struct ar8xxx_priv *priv;
+
+	priv = ar8xxx_create();
+	if (priv) {
+		priv->mii_bus = bus;
+		priv->read = ar8xxx_mii_read;
+		priv->write = ar8xxx_mii_write;
+	}
+
+	return priv;
+}
+
 static int
 ar8xxx_probe_switch(struct ar8xxx_priv *priv)
 {
-	const struct ar8xxx_chip *chip;
 	struct switch_dev *swdev;
 	int ret;
 
@@ -1692,14 +2227,28 @@ ar8xxx_probe_switch(struct ar8xxx_priv *
 	if (ret)
 		return ret;
 
-	chip = priv->chip;
-
 	swdev = &priv->dev;
 	swdev->cpu_port = AR8216_PORT_CPU;
-	swdev->name = chip->name;
-	swdev->vlans = chip->vlans;
-	swdev->ports = chip->ports;
-	swdev->ops = chip->swops;
+	swdev->ops = &ar8xxx_sw_ops;
+
+	if (chip_is_ar8316(priv)) {
+		swdev->name = "Atheros AR8316";
+		swdev->vlans = AR8X16_MAX_VLANS;
+		swdev->ports = AR8216_NUM_PORTS;
+	} else if (chip_is_ar8236(priv)) {
+		swdev->name = "Atheros AR8236";
+		swdev->vlans = AR8216_NUM_VLANS;
+		swdev->ports = AR8216_NUM_PORTS;
+	} else if (chip_is_ar8327(priv)) {
+		swdev->name = "Atheros AR8327";
+		swdev->vlans = AR8X16_MAX_VLANS;
+		swdev->ports = AR8327_NUM_PORTS;
+		swdev->ops = &ar8327_sw_ops;
+	} else {
+		swdev->name = "Atheros AR8216";
+		swdev->vlans = AR8216_NUM_VLANS;
+		swdev->ports = AR8216_NUM_PORTS;
+	}
 
 	ret = ar8xxx_mib_init(priv);
 	if (ret)
@@ -1740,8 +2289,8 @@ ar8xxx_phy_config_init(struct phy_device
 	if (WARN_ON(!priv))
 		return -ENODEV;
 
-	if (priv->chip->config_at_probe)
-		return ar8xxx_phy_check_aneg(phydev);
+	if (chip_is_ar8327(priv))
+		return 0;
 
 	priv->phy = phydev;
 
@@ -1773,46 +2322,12 @@ ar8xxx_phy_config_init(struct phy_device
 	return 0;
 }
 
-static bool
-ar8xxx_check_link_states(struct ar8xxx_priv *priv)
-{
-	bool link_new, changed = false;
-	u32 status;
-	int i;
-
-	mutex_lock(&priv->reg_mutex);
-
-	for (i = 0; i < priv->dev.ports; i++) {
-		status = priv->chip->read_port_status(priv, i);
-		link_new = !!(status & AR8216_PORT_STATUS_LINK_UP);
-		if (link_new == priv->link_up[i])
-			continue;
-
-		priv->link_up[i] = link_new;
-		changed = true;
-		dev_info(&priv->phy->dev, "Port %d is %s\n",
-			 i, link_new ? "up" : "down");
-	}
-
-	if (changed)
-		priv->chip->atu_flush(priv);
-
-	mutex_unlock(&priv->reg_mutex);
-
-	return changed;
-}
-
 static int
 ar8xxx_phy_read_status(struct phy_device *phydev)
 {
 	struct ar8xxx_priv *priv = phydev->priv;
 	struct switch_port_link link;
-
-	/* check for link changes and flush ATU
-	 * if a change was detected
-	 */
-	if (phydev->state == PHY_CHANGELINK)
-		ar8xxx_check_link_states(priv);
+	int ret;
 
 	if (phydev->addr != 0)
 		return genphy_read_status(phydev);
@@ -1837,11 +2352,16 @@ ar8xxx_phy_read_status(struct phy_device
 	}
 	phydev->duplex = link.duplex ? DUPLEX_FULL : DUPLEX_HALF;
 
+	/* flush the address translation unit */
+	mutex_lock(&priv->reg_mutex);
+	ret = priv->chip->atu_flush(priv);
+	mutex_unlock(&priv->reg_mutex);
+
 	phydev->state = PHY_RUNNING;
 	netif_carrier_on(phydev->attached_dev);
 	phydev->adjust_link(phydev->attached_dev);
 
-	return 0;
+	return ret;
 }
 
 static int
@@ -1855,11 +2375,9 @@ ar8xxx_phy_config_aneg(struct phy_device
 
 static const u32 ar8xxx_phy_ids[] = {
 	0x004dd033,
-	0x004dd034, /* AR8327 */
-	0x004dd036, /* AR8337 */
+	0x004dd034,
 	0x004dd041,
 	0x004dd042,
-	0x004dd043, /* AR8236 */
 };
 
 static bool
@@ -1913,14 +2431,12 @@ ar8xxx_phy_probe(struct phy_device *phyd
 		if (priv->mii_bus == phydev->bus)
 			goto found;
 
-	priv = ar8xxx_create();
+	priv = ar8xxx_create_mii(phydev->bus);
 	if (priv == NULL) {
 		ret = -ENOMEM;
 		goto unlock;
 	}
 
-	priv->mii_bus = phydev->bus;
-
 	ret = ar8xxx_probe_switch(priv);
 	if (ret)
 		goto free_priv;
@@ -1947,7 +2463,7 @@ found:
 			phydev->advertising = ADVERTISED_100baseT_Full;
 		}
 
-		if (priv->chip->config_at_probe) {
+		if (chip_is_ar8327(priv)) {
 			priv->phy = phydev;
 
 			ret = ar8xxx_start(priv);
@@ -2017,15 +2533,6 @@ ar8xxx_phy_remove(struct phy_device *phy
 	ar8xxx_free(priv);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
-static int
-ar8xxx_phy_soft_reset(struct phy_device *phydev)
-{
-	/* we don't need an extra reset */
-	return 0;
-}
-#endif
-
 static struct phy_driver ar8xxx_phy_driver = {
 	.phy_id		= 0x004d0000,
 	.name		= "Atheros AR8216/AR8236/AR8316",
@@ -2037,9 +2544,6 @@ static struct phy_driver ar8xxx_phy_driv
 	.config_init	= ar8xxx_phy_config_init,
 	.config_aneg	= ar8xxx_phy_config_aneg,
 	.read_status	= ar8xxx_phy_read_status,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
-	.soft_reset	= ar8xxx_phy_soft_reset,
-#endif
 	.driver		= { .owner = THIS_MODULE },
 };
 
diff --git a/target/linux/generic/files/drivers/net/phy/ar8216.h b/target/linux/generic/files/drivers/net/phy/ar8216.h
--- a/target/linux/generic/files/drivers/net/phy/ar8216.h
+++ b/target/linux/generic/files/drivers/net/phy/ar8216.h
@@ -19,20 +19,11 @@
 
 #define BITS(_s, _n)	(((1UL << (_n)) - 1) << _s)
 
-#define AR8XXX_CAP_GIGE			BIT(0)
-#define AR8XXX_CAP_MIB_COUNTERS		BIT(1)
-
-#define AR8XXX_NUM_PHYS 	5
 #define AR8216_PORT_CPU	0
 #define AR8216_NUM_PORTS	6
 #define AR8216_NUM_VLANS	16
 #define AR8316_NUM_VLANS	4096
 
-/* size of the vlan table */
-#define AR8X16_MAX_VLANS	128
-#define AR8X16_PROBE_RETRIES	10
-#define AR8X16_MAX_PORTS	8
-
 /* Atheros specific MII registers */
 #define MII_ATH_MMD_ADDR		0x0d
 #define MII_ATH_MMD_DATA		0x0e
@@ -49,8 +40,6 @@
 #define AR8216_REG_FLOOD_MASK		0x002C
 #define   AR8216_FM_UNI_DEST_PORTS	BITS(0, 6)
 #define   AR8216_FM_MULTI_DEST_PORTS	BITS(16, 6)
-#define   AR8236_FM_CPU_BROADCAST_EN	BIT(26)
-#define   AR8236_FM_CPU_BCAST_FWD_EN	BIT(25)
 
 #define AR8216_REG_GLOBAL_CTRL		0x0030
 #define   AR8216_GCTRL_MTU		BITS(0, 11)
@@ -104,7 +93,6 @@
 #define   AR8216_ATU_CTRL_AGE_EN	BIT(17)
 #define   AR8216_ATU_CTRL_AGE_TIME	BITS(0, 16)
 #define   AR8216_ATU_CTRL_AGE_TIME_S	0
-#define   AR8236_ATU_CTRL_RES		BIT(20)
 
 #define AR8216_REG_MIB_FUNC		0x0080
 #define   AR8216_MIB_TIMER		BITS(0, 16)
@@ -176,6 +164,8 @@
 #define AR8216_REG_PORT_RATE(_i)	(AR8216_PORT_OFFSET(_i) + 0x000c)
 #define AR8216_REG_PORT_PRIO(_i)	(AR8216_PORT_OFFSET(_i) + 0x0010)
 
+#define AR8216_REG_PORT_STATS_BASE(_i)	(0x19000 + (_i) * 0xa0)
+
 #define AR8216_STATS_RXBROAD		0x00
 #define AR8216_STATS_RXPAUSE		0x04
 #define AR8216_STATS_RXMULTI		0x08
@@ -227,6 +217,8 @@
 #define   AR8236_PORT_VLAN2_VLAN_MODE	BITS(30, 2)
 #define   AR8236_PORT_VLAN2_VLAN_MODE_S	30
 
+#define AR8236_REG_PORT_STATS_BASE(_i)	(0x20000 + (_i) * 0x100)
+
 #define AR8236_STATS_RXBROAD		0x00
 #define AR8236_STATS_RXPAUSE		0x04
 #define AR8236_STATS_RXMULTI		0x08
@@ -297,6 +289,169 @@
 #define   AR8316_POSTRIP_RXDELAY_S1		BIT(26)
 #define   AR8316_POSTRIP_POWER_ON_SEL		BIT(31)
 
+#define AR8327_NUM_PORTS	7
+#define AR8327_NUM_PHYS		5
+#define AR8327_PORTS_ALL	0x7f
+
+#define AR8327_REG_MASK				0x000
+
+#define AR8327_REG_PAD0_MODE			0x004
+#define AR8327_REG_PAD5_MODE			0x008
+#define AR8327_REG_PAD6_MODE			0x00c
+#define   AR8327_PAD_MAC_MII_RXCLK_SEL		BIT(0)
+#define   AR8327_PAD_MAC_MII_TXCLK_SEL		BIT(1)
+#define   AR8327_PAD_MAC_MII_EN			BIT(2)
+#define   AR8327_PAD_MAC_GMII_RXCLK_SEL		BIT(4)
+#define   AR8327_PAD_MAC_GMII_TXCLK_SEL		BIT(5)
+#define   AR8327_PAD_MAC_GMII_EN		BIT(6)
+#define   AR8327_PAD_SGMII_EN			BIT(7)
+#define   AR8327_PAD_PHY_MII_RXCLK_SEL		BIT(8)
+#define   AR8327_PAD_PHY_MII_TXCLK_SEL		BIT(9)
+#define   AR8327_PAD_PHY_MII_EN			BIT(10)
+#define   AR8327_PAD_PHY_GMII_PIPE_RXCLK_SEL	BIT(11)
+#define   AR8327_PAD_PHY_GMII_RXCLK_SEL		BIT(12)
+#define   AR8327_PAD_PHY_GMII_TXCLK_SEL		BIT(13)
+#define   AR8327_PAD_PHY_GMII_EN		BIT(14)
+#define   AR8327_PAD_PHYX_GMII_EN		BIT(16)
+#define   AR8327_PAD_PHYX_RGMII_EN		BIT(17)
+#define   AR8327_PAD_PHYX_MII_EN		BIT(18)
+#define   AR8327_PAD_SGMII_DELAY_EN		BIT(19)
+#define   AR8327_PAD_RGMII_RXCLK_DELAY_SEL	BITS(20, 2)
+#define   AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S	20
+#define   AR8327_PAD_RGMII_TXCLK_DELAY_SEL	BITS(22, 2)
+#define   AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S	22
+#define   AR8327_PAD_RGMII_RXCLK_DELAY_EN	BIT(24)
+#define   AR8327_PAD_RGMII_TXCLK_DELAY_EN	BIT(25)
+#define   AR8327_PAD_RGMII_EN			BIT(26)
+
+#define AR8327_REG_POWER_ON_STRIP		0x010
+#define   AR8327_POWER_ON_STRIP_POWER_ON_SEL	BIT(31)
+#define   AR8327_POWER_ON_STRIP_LED_OPEN_EN	BIT(24)
+#define   AR8327_POWER_ON_STRIP_SERDES_AEN	BIT(7)
+
+#define AR8327_REG_INT_STATUS0			0x020
+#define   AR8327_INT0_VT_DONE			BIT(20)
+
+#define AR8327_REG_INT_STATUS1			0x024
+#define AR8327_REG_INT_MASK0			0x028
+#define AR8327_REG_INT_MASK1			0x02c
+
+#define AR8327_REG_MODULE_EN			0x030
+#define   AR8327_MODULE_EN_MIB			BIT(0)
+
+#define AR8327_REG_MIB_FUNC			0x034
+#define   AR8327_MIB_CPU_KEEP			BIT(20)
+
+#define AR8327_REG_SERVICE_TAG			0x048
+#define AR8327_REG_LED_CTRL0			0x050
+#define AR8327_REG_LED_CTRL1			0x054
+#define AR8327_REG_LED_CTRL2			0x058
+#define AR8327_REG_LED_CTRL3			0x05c
+#define AR8327_REG_MAC_ADDR0			0x060
+#define AR8327_REG_MAC_ADDR1			0x064
+
+#define AR8327_REG_MAX_FRAME_SIZE		0x078
+#define   AR8327_MAX_FRAME_SIZE_MTU		BITS(0, 14)
+
+#define AR8327_REG_PORT_STATUS(_i)		(0x07c + (_i) * 4)
+
+#define AR8327_REG_HEADER_CTRL			0x098
+#define AR8327_REG_PORT_HEADER(_i)		(0x09c + (_i) * 4)
+
+#define AR8327_REG_SGMII_CTRL			0x0e0
+#define   AR8327_SGMII_CTRL_EN_PLL		BIT(1)
+#define   AR8327_SGMII_CTRL_EN_RX		BIT(2)
+#define   AR8327_SGMII_CTRL_EN_TX		BIT(3)
+
+#define AR8327_REG_PORT_VLAN0(_i)		(0x420 + (_i) * 0x8)
+#define   AR8327_PORT_VLAN0_DEF_SVID		BITS(0, 12)
+#define   AR8327_PORT_VLAN0_DEF_SVID_S		0
+#define   AR8327_PORT_VLAN0_DEF_CVID		BITS(16, 12)
+#define   AR8327_PORT_VLAN0_DEF_CVID_S		16
+
+#define AR8327_REG_PORT_VLAN1(_i)		(0x424 + (_i) * 0x8)
+#define   AR8327_PORT_VLAN1_PORT_VLAN_PROP	BIT(6)
+#define   AR8327_PORT_VLAN1_OUT_MODE		BITS(12, 2)
+#define   AR8327_PORT_VLAN1_OUT_MODE_S		12
+#define   AR8327_PORT_VLAN1_OUT_MODE_UNMOD	0
+#define   AR8327_PORT_VLAN1_OUT_MODE_UNTAG	1
+#define   AR8327_PORT_VLAN1_OUT_MODE_TAG	2
+#define   AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH	3
+
+#define AR8327_REG_ATU_DATA0			0x600
+#define AR8327_REG_ATU_DATA1			0x604
+#define AR8327_REG_ATU_DATA2			0x608
+
+#define AR8327_REG_ATU_FUNC			0x60c
+#define   AR8327_ATU_FUNC_OP			BITS(0, 4)
+#define   AR8327_ATU_FUNC_OP_NOOP		0x0
+#define   AR8327_ATU_FUNC_OP_FLUSH		0x1
+#define   AR8327_ATU_FUNC_OP_LOAD		0x2
+#define   AR8327_ATU_FUNC_OP_PURGE		0x3
+#define   AR8327_ATU_FUNC_OP_FLUSH_LOCKED	0x4
+#define   AR8327_ATU_FUNC_OP_FLUSH_UNICAST	0x5
+#define   AR8327_ATU_FUNC_OP_GET_NEXT		0x6
+#define   AR8327_ATU_FUNC_OP_SEARCH_MAC		0x7
+#define   AR8327_ATU_FUNC_OP_CHANGE_TRUNK	0x8
+#define   AR8327_ATU_FUNC_BUSY			BIT(31)
+
+#define AR8327_REG_VTU_FUNC0			0x0610
+#define   AR8327_VTU_FUNC0_EG_MODE		BITS(4, 14)
+#define   AR8327_VTU_FUNC0_EG_MODE_S(_i)	(4 + (_i) * 2)
+#define   AR8327_VTU_FUNC0_EG_MODE_KEEP		0
+#define   AR8327_VTU_FUNC0_EG_MODE_UNTAG	1
+#define   AR8327_VTU_FUNC0_EG_MODE_TAG		2
+#define   AR8327_VTU_FUNC0_EG_MODE_NOT		3
+#define   AR8327_VTU_FUNC0_IVL			BIT(19)
+#define   AR8327_VTU_FUNC0_VALID		BIT(20)
+
+#define AR8327_REG_VTU_FUNC1			0x0614
+#define   AR8327_VTU_FUNC1_OP			BITS(0, 3)
+#define   AR8327_VTU_FUNC1_OP_NOOP		0
+#define   AR8327_VTU_FUNC1_OP_FLUSH		1
+#define   AR8327_VTU_FUNC1_OP_LOAD		2
+#define   AR8327_VTU_FUNC1_OP_PURGE		3
+#define   AR8327_VTU_FUNC1_OP_REMOVE_PORT	4
+#define   AR8327_VTU_FUNC1_OP_GET_NEXT		5
+#define   AR8327_VTU_FUNC1_OP_GET_ONE		6
+#define   AR8327_VTU_FUNC1_FULL			BIT(4)
+#define   AR8327_VTU_FUNC1_PORT			BIT(8, 4)
+#define   AR8327_VTU_FUNC1_PORT_S		8
+#define   AR8327_VTU_FUNC1_VID			BIT(16, 12)
+#define   AR8327_VTU_FUNC1_VID_S		16
+#define   AR8327_VTU_FUNC1_BUSY			BIT(31)
+
+#define AR8327_REG_FWD_CTRL0			0x620
+#define   AR8327_FWD_CTRL0_CPU_PORT_EN		BIT(10)
+#define   AR8327_FWD_CTRL0_MIRROR_PORT		BITS(4, 4)
+#define   AR8327_FWD_CTRL0_MIRROR_PORT_S	4
+
+#define AR8327_REG_FWD_CTRL1			0x624
+#define   AR8327_FWD_CTRL1_UC_FLOOD		BITS(0, 7)
+#define   AR8327_FWD_CTRL1_UC_FLOOD_S		0
+#define   AR8327_FWD_CTRL1_MC_FLOOD		BITS(8, 7)
+#define   AR8327_FWD_CTRL1_MC_FLOOD_S		8
+#define   AR8327_FWD_CTRL1_BC_FLOOD		BITS(16, 7)
+#define   AR8327_FWD_CTRL1_BC_FLOOD_S		16
+#define   AR8327_FWD_CTRL1_IGMP			BITS(24, 7)
+#define   AR8327_FWD_CTRL1_IGMP_S		24
+
+#define AR8327_REG_PORT_LOOKUP(_i)		(0x660 + (_i) * 0xc)
+#define   AR8327_PORT_LOOKUP_MEMBER		BITS(0, 7)
+#define   AR8327_PORT_LOOKUP_IN_MODE		BITS(8, 2)
+#define   AR8327_PORT_LOOKUP_IN_MODE_S		8
+#define   AR8327_PORT_LOOKUP_STATE		BITS(16, 3)
+#define   AR8327_PORT_LOOKUP_STATE_S		16
+#define   AR8327_PORT_LOOKUP_LEARN		BIT(20)
+#define   AR8327_PORT_LOOKUP_ING_MIRROR_EN	BIT(25)
+
+#define AR8327_REG_PORT_PRIO(_i)		(0x664 + (_i) * 0xc)
+
+#define AR8327_REG_PORT_HOL_CTRL1(_i)		(0x974 + (_i) * 0x8)
+#define   AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN	BIT(16)
+
+#define AR8327_REG_PORT_STATS_BASE(_i)		(0x1000 + (_i) * 0x100)
+
 /* port speed */
 enum {
         AR8216_PORT_SPEED_10M = 0,
@@ -329,273 +484,4 @@ enum {
 	AR8216_PORT_STATE_FORWARD = 4
 };
 
-enum {
-	AR8XXX_VER_AR8216 = 0x01,
-	AR8XXX_VER_AR8236 = 0x03,
-	AR8XXX_VER_AR8316 = 0x10,
-	AR8XXX_VER_AR8327 = 0x12,
-	AR8XXX_VER_AR8337 = 0x13,
-};
-
-#define AR8XXX_NUM_ARL_RECORDS	100
-
-enum arl_op {
-	AR8XXX_ARL_INITIALIZE,
-	AR8XXX_ARL_GET_NEXT
-};
-
-struct arl_entry {
-	u8 port;
-	u8 mac[6];
-};
-
-struct ar8xxx_priv;
-
-struct ar8xxx_mib_desc {
-	unsigned int size;
-	unsigned int offset;
-	const char *name;
-};
-
-struct ar8xxx_chip {
-	unsigned long caps;
-	bool config_at_probe;
-	bool mii_lo_first;
-
-	/* parameters to calculate REG_PORT_STATS_BASE */
-	unsigned reg_port_stats_start;
-	unsigned reg_port_stats_length;
-
-	int (*hw_init)(struct ar8xxx_priv *priv);
-	void (*cleanup)(struct ar8xxx_priv *priv);
-
-	const char *name;
-	int vlans;
-	int ports;
-	const struct switch_dev_ops *swops;
-
-	void (*init_globals)(struct ar8xxx_priv *priv);
-	void (*init_port)(struct ar8xxx_priv *priv, int port);
-	void (*setup_port)(struct ar8xxx_priv *priv, int port, u32 members);
-	u32 (*read_port_status)(struct ar8xxx_priv *priv, int port);
-	u32 (*read_port_eee_status)(struct ar8xxx_priv *priv, int port);
-	int (*atu_flush)(struct ar8xxx_priv *priv);
-	void (*vtu_flush)(struct ar8xxx_priv *priv);
-	void (*vtu_load_vlan)(struct ar8xxx_priv *priv, u32 vid, u32 port_mask);
-	void (*phy_fixup)(struct ar8xxx_priv *priv, int phy);
-	void (*set_mirror_regs)(struct ar8xxx_priv *priv);
-	void (*get_arl_entry)(struct ar8xxx_priv *priv, struct arl_entry *a,
-			      u32 *status, enum arl_op op);
-	int (*sw_hw_apply)(struct switch_dev *dev);
-
-	const struct ar8xxx_mib_desc *mib_decs;
-	unsigned num_mibs;
-	unsigned mib_func;
-};
-
-struct ar8xxx_priv {
-	struct switch_dev dev;
-	struct mii_bus *mii_bus;
-	struct phy_device *phy;
-
-	int (*get_port_link)(unsigned port);
-
-	const struct net_device_ops *ndo_old;
-	struct net_device_ops ndo;
-	struct mutex reg_mutex;
-	u8 chip_ver;
-	u8 chip_rev;
-	const struct ar8xxx_chip *chip;
-	void *chip_data;
-	bool initialized;
-	bool port4_phy;
-	char buf[2048];
-	struct arl_entry arl_table[AR8XXX_NUM_ARL_RECORDS];
-	char arl_buf[AR8XXX_NUM_ARL_RECORDS * 32 + 256];
-	bool link_up[AR8X16_MAX_PORTS];
-
-	bool init;
-
-	struct mutex mib_lock;
-	struct delayed_work mib_work;
-	int mib_next_port;
-	u64 *mib_stats;
-
-	struct list_head list;
-	unsigned int use_count;
-
-	/* all fields below are cleared on reset */
-	bool vlan;
-	u16 vlan_id[AR8X16_MAX_VLANS];
-	u8 vlan_table[AR8X16_MAX_VLANS];
-	u8 vlan_tagged;
-	u16 pvid[AR8X16_MAX_PORTS];
-
-	/* mirroring */
-	bool mirror_rx;
-	bool mirror_tx;
-	int source_port;
-	int monitor_port;
-};
-
-u32
-ar8xxx_mii_read32(struct ar8xxx_priv *priv, int phy_id, int regnum);
-void
-ar8xxx_mii_write32(struct ar8xxx_priv *priv, int phy_id, int regnum, u32 val);
-u32
-ar8xxx_read(struct ar8xxx_priv *priv, int reg);
-void
-ar8xxx_write(struct ar8xxx_priv *priv, int reg, u32 val);
-u32
-ar8xxx_rmw(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val);
-
-void
-ar8xxx_phy_dbg_write(struct ar8xxx_priv *priv, int phy_addr,
-		     u16 dbg_addr, u16 dbg_data);
-void
-ar8xxx_phy_mmd_write(struct ar8xxx_priv *priv, int phy_addr, u16 addr, u16 data);
-u16
-ar8xxx_phy_mmd_read(struct ar8xxx_priv *priv, int phy_addr, u16 addr);
-void
-ar8xxx_phy_init(struct ar8xxx_priv *priv);
-int
-ar8xxx_sw_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
-		   struct switch_val *val);
-int
-ar8xxx_sw_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
-		   struct switch_val *val);
-int
-ar8xxx_sw_set_reset_mibs(struct switch_dev *dev,
-			 const struct switch_attr *attr,
-			 struct switch_val *val);
-int
-ar8xxx_sw_set_mirror_rx_enable(struct switch_dev *dev,
-			       const struct switch_attr *attr,
-			       struct switch_val *val);
-int
-ar8xxx_sw_get_mirror_rx_enable(struct switch_dev *dev,
-			       const struct switch_attr *attr,
-			       struct switch_val *val);
-int
-ar8xxx_sw_set_mirror_tx_enable(struct switch_dev *dev,
-			       const struct switch_attr *attr,
-			       struct switch_val *val);
-int
-ar8xxx_sw_get_mirror_tx_enable(struct switch_dev *dev,
-			       const struct switch_attr *attr,
-			       struct switch_val *val);
-int
-ar8xxx_sw_set_mirror_monitor_port(struct switch_dev *dev,
-				  const struct switch_attr *attr,
-				  struct switch_val *val);
-int
-ar8xxx_sw_get_mirror_monitor_port(struct switch_dev *dev,
-				  const struct switch_attr *attr,
-				  struct switch_val *val);
-int
-ar8xxx_sw_set_mirror_source_port(struct switch_dev *dev,
-				 const struct switch_attr *attr,
-				 struct switch_val *val);
-int
-ar8xxx_sw_get_mirror_source_port(struct switch_dev *dev,
-				 const struct switch_attr *attr,
-				 struct switch_val *val);
-int
-ar8xxx_sw_set_pvid(struct switch_dev *dev, int port, int vlan);
-int
-ar8xxx_sw_get_pvid(struct switch_dev *dev, int port, int *vlan);
-int
-ar8xxx_sw_hw_apply(struct switch_dev *dev);
-int
-ar8xxx_sw_reset_switch(struct switch_dev *dev);
-int
-ar8xxx_sw_get_port_link(struct switch_dev *dev, int port,
-			struct switch_port_link *link);
-int
-ar8xxx_sw_set_port_reset_mib(struct switch_dev *dev,
-                             const struct switch_attr *attr,
-                             struct switch_val *val);
-int
-ar8xxx_sw_get_port_mib(struct switch_dev *dev,
-                       const struct switch_attr *attr,
-                       struct switch_val *val);
-int
-ar8xxx_sw_get_arl_table(struct switch_dev *dev,
-			const struct switch_attr *attr,
-			struct switch_val *val);
-int
-ar8216_wait_bit(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val);
-
-static inline struct ar8xxx_priv *
-swdev_to_ar8xxx(struct switch_dev *swdev)
-{
-	return container_of(swdev, struct ar8xxx_priv, dev);
-}
-
-static inline bool ar8xxx_has_gige(struct ar8xxx_priv *priv)
-{
-	return priv->chip->caps & AR8XXX_CAP_GIGE;
-}
-
-static inline bool ar8xxx_has_mib_counters(struct ar8xxx_priv *priv)
-{
-	return priv->chip->caps & AR8XXX_CAP_MIB_COUNTERS;
-}
-
-static inline bool chip_is_ar8216(struct ar8xxx_priv *priv)
-{
-	return priv->chip_ver == AR8XXX_VER_AR8216;
-}
-
-static inline bool chip_is_ar8236(struct ar8xxx_priv *priv)
-{
-	return priv->chip_ver == AR8XXX_VER_AR8236;
-}
-
-static inline bool chip_is_ar8316(struct ar8xxx_priv *priv)
-{
-	return priv->chip_ver == AR8XXX_VER_AR8316;
-}
-
-static inline bool chip_is_ar8327(struct ar8xxx_priv *priv)
-{
-	return priv->chip_ver == AR8XXX_VER_AR8327;
-}
-
-static inline bool chip_is_ar8337(struct ar8xxx_priv *priv)
-{
-	return priv->chip_ver == AR8XXX_VER_AR8337;
-}
-
-static inline void
-ar8xxx_reg_set(struct ar8xxx_priv *priv, int reg, u32 val)
-{
-	ar8xxx_rmw(priv, reg, 0, val);
-}
-
-static inline void
-ar8xxx_reg_clear(struct ar8xxx_priv *priv, int reg, u32 val)
-{
-	ar8xxx_rmw(priv, reg, val, 0);
-}
-
-static inline void
-split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page)
-{
-	regaddr >>= 1;
-	*r1 = regaddr & 0x1e;
-
-	regaddr >>= 5;
-	*r2 = regaddr & 0x7;
-
-	regaddr >>= 3;
-	*page = regaddr & 0x1ff;
-}
-
-static inline void
-wait_for_page_switch(void)
-{
-	udelay(5);
-}
-
 #endif
diff --git a/target/linux/generic/files/drivers/net/phy/b53/Kconfig b/target/linux/generic/files/drivers/net/phy/b53/Kconfig
--- a/target/linux/generic/files/drivers/net/phy/b53/Kconfig
+++ b/target/linux/generic/files/drivers/net/phy/b53/Kconfig
@@ -26,12 +26,5 @@ config B53_MMAP_DRIVER
 	  Select to enable support for memory-mapped switches like the BCM63XX
 	  integrated switches.
 
-config B53_SRAB_DRIVER
-	tristate "B53 SRAB connected switch driver"
-	depends on B53
-	help
-	  Select to enable support for memory-mapped Switch Register Access
-	  Bridge Registers (SRAB) like it is found on the BCM53010
-
 config B53_PHY_FIXUP
 	bool
diff --git a/target/linux/generic/files/drivers/net/phy/b53/Makefile b/target/linux/generic/files/drivers/net/phy/b53/Makefile
--- a/target/linux/generic/files/drivers/net/phy/b53/Makefile
+++ b/target/linux/generic/files/drivers/net/phy/b53/Makefile
@@ -3,7 +3,6 @@ obj-$(CONFIG_B53)		+= b53_common.o
 obj-$(CONFIG_B53_PHY_FIXUP)	+= b53_phy_fixup.o
 
 obj-$(CONFIG_B53_MMAP_DRIVER)	+= b53_mmap.o
-obj-$(CONFIG_B53_SRAB_DRIVER)	+= b53_srab.o
 obj-$(CONFIG_B53_PHY_DRIVER)	+= b53_mdio.o
 obj-$(CONFIG_B53_SPI_DRIVER)	+= b53_spi.o
 
diff --git a/target/linux/generic/files/drivers/net/phy/b53/b53_common.c b/target/linux/generic/files/drivers/net/phy/b53/b53_common.c
--- a/target/linux/generic/files/drivers/net/phy/b53/b53_common.c
+++ b/target/linux/generic/files/drivers/net/phy/b53/b53_common.c
@@ -189,8 +189,7 @@ static void b53_set_vlan_entry(struct b5
 		u32 entry = 0;
 
 		if (members) {
-			entry = ((untag & VA_UNTAG_MASK_25) << VA_UNTAG_S_25) |
-				members;
+			entry = (untag << VA_UNTAG_S) | members;
 			if (dev->core_rev >= 3)
 				entry |= VA_VALID_25_R4 | vid << VA_VID_HIGH_S;
 			else
@@ -204,8 +203,7 @@ static void b53_set_vlan_entry(struct b5
 		u16 entry = 0;
 
 		if (members)
-			entry = ((untag & VA_UNTAG_MASK_65) << VA_UNTAG_S_65) |
-				members | VA_VALID_65;
+			entry = (untag << VA_UNTAG_S) | members | VA_VALID_65;
 
 		b53_write16(dev, B53_VLAN_PAGE, B53_VLAN_WRITE_65, entry);
 		b53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_65, vid |
@@ -374,7 +372,7 @@ static void b53_enable_ports(struct b53_
 		 */
 		if (dev->enable_vlan || is_cpu_port(dev, i))
 			pvlan_mask = 0x1ff;
-		else if (is531x5(dev) || is5301x(dev))
+		else if (is531x5(dev))
 			/* BCM53115 may use a different port as cpu port */
 			pvlan_mask = BIT(dev->sw_dev.cpu_port);
 		else
@@ -398,7 +396,7 @@ static void b53_enable_ports(struct b53_
 			    pvlan_mask);
 
 		/* port state is handled by bcm63xx_enet driver */
-		if (!is63xx(dev) && !(is5301x(dev) && i == 6))
+		if (!is63xx(dev))
 			b53_write8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(i),
 				   port_ctrl);
 	}
@@ -408,11 +406,11 @@ static void b53_enable_mib(struct b53_de
 {
 	u8 gc;
 
-	b53_read8(dev, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, &gc);
+	b53_read8(dev, B53_CTRL_PAGE, B53_GLOBAL_CONFIG, &gc);
 
 	gc &= ~(GC_RESET_MIB | GC_MIB_AC_EN);
 
-	b53_write8(dev, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, gc);
+	b53_write8(dev, B53_CTRL_PAGE, B53_GLOBAL_CONFIG, gc);
 }
 
 static int b53_apply(struct b53_device *dev)
@@ -459,7 +457,7 @@ static int b53_apply(struct b53_device *
 	return 0;
 }
 
-static void b53_switch_reset_gpio(struct b53_device *dev)
+void b53_switch_reset_gpio(struct b53_device *dev)
 {
 	int gpio = dev->reset_gpio;
 
@@ -480,7 +478,6 @@ static void b53_switch_reset_gpio(struct
 
 static int b53_switch_reset(struct b53_device *dev)
 {
-	u8 cpu_port = dev->sw_dev.cpu_port;
 	u8 mgmt;
 
 	b53_switch_reset_gpio(dev);
@@ -526,7 +523,7 @@ static int b53_switch_reset(struct b53_d
 				return -EINVAL;
 			}
 		}
-	} else if (is531x5(dev) && cpu_port == B53_CPU_PORT) {
+	} else if (is531x5(dev) && dev->sw_dev.cpu_port == B53_CPU_PORT) {
 		u8 mii_port_override;
 
 		b53_read8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,
@@ -534,33 +531,6 @@ static int b53_switch_reset(struct b53_d
 		b53_write8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,
 			   mii_port_override | PORT_OVERRIDE_EN |
 			   PORT_OVERRIDE_LINK);
-	} else if (is5301x(dev)) {
-		if (cpu_port == 8) {
-			u8 mii_port_override;
-
-			b53_read8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,
-				  &mii_port_override);
-			mii_port_override |= PORT_OVERRIDE_LINK |
-					     PORT_OVERRIDE_RX_FLOW |
-					     PORT_OVERRIDE_TX_FLOW |
-					     PORT_OVERRIDE_SPEED_2000M |
-					     PORT_OVERRIDE_EN;
-			b53_write8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,
-				   mii_port_override);
-
-			/* TODO: Ports 5 & 7 require some extra handling */
-		} else {
-			u8 po_reg = B53_GMII_PORT_OVERRIDE_CTRL(cpu_port);
-			u8 gmii_po;
-
-			b53_read8(dev, B53_CTRL_PAGE, po_reg, &gmii_po);
-			gmii_po |= GMII_PO_LINK |
-				   GMII_PO_RX_FLOW |
-				   GMII_PO_TX_FLOW |
-				   GMII_PO_EN |
-				   GMII_PO_SPEED_2000M;
-			b53_write8(dev, B53_CTRL_PAGE, po_reg, gmii_po);
-		}
 	}
 
 	b53_enable_mib(dev);
@@ -803,8 +773,8 @@ static int b53_global_reset_switch(struc
 	priv->enable_jumbo = 0;
 	priv->allow_vid_4095 = 0;
 
-	memset(priv->vlans, 0, sizeof(*priv->vlans) * dev->vlans);
-	memset(priv->ports, 0, sizeof(*priv->ports) * dev->ports);
+	memset(priv->vlans, 0, sizeof(priv->vlans) * dev->vlans);
+	memset(priv->ports, 0, sizeof(priv->ports) * dev->ports);
 
 	return b53_switch_reset(priv);
 }
@@ -1158,19 +1128,6 @@ static const struct b53_chip_data b53_sw
 		.sw_ops = &b53_switch_ops,
 	},
 	{
-		.chip_id = BCM53128_DEVICE_ID,
-		.dev_name = "BCM53128",
-		.alias = "bcm53128",
-		.vlans = 4096,
-		.enabled_ports = 0x1ff,
-		.cpu_port = B53_CPU_PORT,
-		.vta_regs = B53_VTA_REGS,
-		.duplex_reg = B53_DUPLEX_STAT_GE,
-		.jumbo_pm_reg = B53_JUMBO_PORT_MASK,
-		.jumbo_size_reg = B53_JUMBO_MAX_SIZE,
-		.sw_ops = &b53_switch_ops,
-	},
-	{
 		.chip_id = BCM63XX_DEVICE_ID,
 		.dev_name = "BCM63xx",
 		.alias = "bcm63xx",
@@ -1183,74 +1140,9 @@ static const struct b53_chip_data b53_sw
 		.jumbo_size_reg = B53_JUMBO_MAX_SIZE_63XX,
 		.sw_ops = &b53_switch_ops,
 	},
-	{
-		.chip_id = BCM53010_DEVICE_ID,
-		.dev_name = "BCM53010",
-		.alias = "bcm53011",
-		.vlans = 4096,
-		.enabled_ports = 0x1f,
-		.cpu_port = B53_CPU_PORT_25, /* TODO: auto detect */
-		.vta_regs = B53_VTA_REGS,
-		.duplex_reg = B53_DUPLEX_STAT_GE,
-		.jumbo_pm_reg = B53_JUMBO_PORT_MASK,
-		.jumbo_size_reg = B53_JUMBO_MAX_SIZE,
-		.sw_ops = &b53_switch_ops,
-	},
-	{
-		.chip_id = BCM53011_DEVICE_ID,
-		.dev_name = "BCM53011",
-		.alias = "bcm53011",
-		.vlans = 4096,
-		.enabled_ports = 0x1bf,
-		.cpu_port = B53_CPU_PORT_25, /* TODO: auto detect */
-		.vta_regs = B53_VTA_REGS,
-		.duplex_reg = B53_DUPLEX_STAT_GE,
-		.jumbo_pm_reg = B53_JUMBO_PORT_MASK,
-		.jumbo_size_reg = B53_JUMBO_MAX_SIZE,
-		.sw_ops = &b53_switch_ops,
-	},
-	{
-		.chip_id = BCM53012_DEVICE_ID,
-		.dev_name = "BCM53012",
-		.alias = "bcm53011",
-		.vlans = 4096,
-		.enabled_ports = 0x1bf,
-		.cpu_port = B53_CPU_PORT_25, /* TODO: auto detect */
-		.vta_regs = B53_VTA_REGS,
-		.duplex_reg = B53_DUPLEX_STAT_GE,
-		.jumbo_pm_reg = B53_JUMBO_PORT_MASK,
-		.jumbo_size_reg = B53_JUMBO_MAX_SIZE,
-		.sw_ops = &b53_switch_ops,
-	},
-	{
-		.chip_id = BCM53018_DEVICE_ID,
-		.dev_name = "BCM53018",
-		.alias = "bcm53018",
-		.vlans = 4096,
-		.enabled_ports = 0x1f,
-		.cpu_port = B53_CPU_PORT_25, /* TODO: auto detect */
-		.vta_regs = B53_VTA_REGS,
-		.duplex_reg = B53_DUPLEX_STAT_GE,
-		.jumbo_pm_reg = B53_JUMBO_PORT_MASK,
-		.jumbo_size_reg = B53_JUMBO_MAX_SIZE,
-		.sw_ops = &b53_switch_ops,
-	},
-	{
-		.chip_id = BCM53019_DEVICE_ID,
-		.dev_name = "BCM53019",
-		.alias = "bcm53019",
-		.vlans = 4096,
-		.enabled_ports = 0x1f,
-		.cpu_port = B53_CPU_PORT_25, /* TODO: auto detect */
-		.vta_regs = B53_VTA_REGS,
-		.duplex_reg = B53_DUPLEX_STAT_GE,
-		.jumbo_pm_reg = B53_JUMBO_PORT_MASK,
-		.jumbo_size_reg = B53_JUMBO_MAX_SIZE,
-		.sw_ops = &b53_switch_ops,
-	},
 };
 
-static int b53_switch_init(struct b53_device *dev)
+int b53_switch_init(struct b53_device *dev)
 {
 	struct switch_dev *sw_dev = &dev->sw_dev;
 	unsigned i;
@@ -1335,8 +1227,7 @@ static int b53_switch_init(struct b53_de
 
 	dev->reset_gpio = b53_switch_get_reset_gpio(dev);
 	if (dev->reset_gpio >= 0) {
-		ret = devm_gpio_request_one(dev->dev, dev->reset_gpio,
-					    GPIOF_OUT_INIT_HIGH, "robo_reset");
+		ret = devm_gpio_request_one(dev->dev, dev->reset_gpio, GPIOF_OUT_INIT_HIGH, "robo_reset");
 		if (ret)
 			return ret;
 	}
@@ -1405,12 +1296,6 @@ int b53_switch_detect(struct b53_device 
 		switch (id32) {
 		case BCM53115_DEVICE_ID:
 		case BCM53125_DEVICE_ID:
-		case BCM53128_DEVICE_ID:
-		case BCM53010_DEVICE_ID:
-		case BCM53011_DEVICE_ID:
-		case BCM53012_DEVICE_ID:
-		case BCM53018_DEVICE_ID:
-		case BCM53019_DEVICE_ID:
 			dev->chip_id = id32;
 			break;
 		default:
diff --git a/target/linux/generic/files/drivers/net/phy/b53/b53_mdio.c b/target/linux/generic/files/drivers/net/phy/b53/b53_mdio.c
--- a/target/linux/generic/files/drivers/net/phy/b53/b53_mdio.c
+++ b/target/linux/generic/files/drivers/net/phy/b53/b53_mdio.c
@@ -296,7 +296,7 @@ static int b53_phy_config_init(struct ph
 
 	ret = b53_switch_register(dev);
 	if (ret) {
-		dev_err(dev->dev, "failed to register switch: %i\n", ret);
+		pr_info("failed to register switch: %i\n", ret);
 		return ret;
 	}
 
@@ -357,7 +357,7 @@ static struct phy_driver b53_phy_driver_
 	},
 };
 
-/* BCM53125, BCM53128 */
+/* BCM53125 */
 static struct phy_driver b53_phy_driver_id2 = {
 	.phy_id		= 0x03625c00,
 	.name		= "Broadcom B53 (2)",
diff --git a/target/linux/generic/files/drivers/net/phy/b53/b53_mmap.c b/target/linux/generic/files/drivers/net/phy/b53/b53_mmap.c
--- a/target/linux/generic/files/drivers/net/phy/b53/b53_mmap.c
+++ b/target/linux/generic/files/drivers/net/phy/b53/b53_mmap.c
@@ -64,25 +64,19 @@ static int b53_mmap_read32(struct b53_de
 
 static int b53_mmap_read48(struct b53_device *dev, u8 page, u8 reg, u64 *val)
 {
-	if (WARN_ON(reg % 2))
+	u8 __iomem *regs = dev->priv;
+
+	if (WARN_ON(reg % 4))
 		return -EINVAL;
 
-	if (reg % 4) {
-		u16 lo;
-		u32 hi;
-
-		b53_mmap_read16(dev, page, reg, &lo);
-		b53_mmap_read32(dev, page, reg + 2, &hi);
-
-		*val = ((u64)hi << 16) | lo;
+	if (dev->pdata && dev->pdata->big_endian) {
+		*val = readl_be(regs + (page << 8) + reg);
+		*val <<= 16;
+		*val |= readw_be(regs + (page << 8) + reg + 4);
 	} else {
-		u32 lo;
-		u16 hi;
-
-		b53_mmap_read32(dev, page, reg, &lo);
-		b53_mmap_read16(dev, page, reg + 4, &hi);
-
-		*val = ((u64)hi << 32) | lo;
+		*val |= readw(regs + (page << 8) + reg + 4);
+		*val <<= 32;
+		*val = readl(regs + (page << 8) + reg);
 	}
 
 	return 0;
@@ -90,13 +84,19 @@ static int b53_mmap_read48(struct b53_de
 
 static int b53_mmap_read64(struct b53_device *dev, u8 page, u8 reg, u64 *val)
 {
+	u8 __iomem *regs = dev->priv;
 	u32 hi, lo;
 
 	if (WARN_ON(reg % 4))
 		return -EINVAL;
 
-	b53_mmap_read32(dev, page, reg, &lo);
-	b53_mmap_read32(dev, page, reg + 4, &hi);
+	if (dev->pdata && dev->pdata->big_endian) {
+		lo = readl_be(regs + (page << 8) + reg);
+		hi = readl_be(regs + (page << 8) + reg + 4);
+	} else {
+		lo = readl(regs + (page << 8) + reg);
+		hi = readl(regs + (page << 8) + reg + 4);
+	}
 
 	*val = ((u64)hi << 32) | lo;
 
@@ -147,21 +147,17 @@ static int b53_mmap_write32(struct b53_d
 static int b53_mmap_write48(struct b53_device *dev, u8 page, u8 reg,
 				    u64 value)
 {
-	if (WARN_ON(reg % 2))
+	u8 __iomem *regs = dev->priv;
+
+	if (WARN_ON(reg % 4))
 		return -EINVAL;
 
-	if (reg % 4) {
-		u32 hi = (u32)(value >> 16);
-		u16 lo = (u16)value;
-
-		b53_mmap_write16(dev, page, reg, lo);
-		b53_mmap_write32(dev, page, reg + 2, hi);
+	if (dev->pdata && dev->pdata->big_endian) {
+		writel_be((u32)(value >> 16), regs + (page << 8) + reg);
+		writew_be((u16)value, regs + (page << 8) + reg + 4);
 	} else {
-		u16 hi = (u16)(value >> 32);
-		u32 lo = (u32)value;
-
-		b53_mmap_write32(dev, page, reg, lo);
-		b53_mmap_write16(dev, page, reg + 4, hi);
+		writel((u32)value, regs + (page << 8) + reg);
+		writew((u16)(value >> 32), regs + (page << 8) + reg + 4);
 	}
 
 	return 0;
@@ -170,16 +166,18 @@ static int b53_mmap_write48(struct b53_d
 static int b53_mmap_write64(struct b53_device *dev, u8 page, u8 reg,
 			     u64 value)
 {
-	u32 hi, lo;
-
-	hi = (u32)(value >> 32);
-	lo = (u32)value;
+	u8 __iomem *regs = dev->priv;
 
 	if (WARN_ON(reg % 4))
 		return -EINVAL;
 
-	b53_mmap_write32(dev, page, reg, lo);
-	b53_mmap_write32(dev, page, reg + 4, hi);
+	if (dev->pdata && dev->pdata->big_endian) {
+		writel_be((u32)(value >> 32), regs + (page << 8) + reg);
+		writel_be((u32)value, regs + (page << 8) + reg + 4);
+	} else {
+		writel((u32)value, regs + (page << 8) + reg);
+		writel((u32)(value >> 32), regs + (page << 8) + reg + 4);
+	}
 
 	return 0;
 }
@@ -212,17 +210,19 @@ static int b53_mmap_probe(struct platfor
 	if (pdata)
 		dev->pdata = pdata;
 
-	platform_set_drvdata(pdev, dev);
+	pdev->dev.platform_data = dev;
 
 	return b53_switch_register(dev);
 }
 
 static int b53_mmap_remove(struct platform_device *pdev)
 {
-	struct b53_device *dev = platform_get_drvdata(pdev);
+	struct b53_device *dev = pdev->dev.platform_data;
 
-	if (dev)
+	if (dev) {
+		pdev->dev.platform_data = dev->pdata;
 		b53_switch_remove(dev);
+	}
 
 	return 0;
 }
diff --git a/target/linux/generic/files/drivers/net/phy/b53/b53_priv.h b/target/linux/generic/files/drivers/net/phy/b53/b53_priv.h
--- a/target/linux/generic/files/drivers/net/phy/b53/b53_priv.h
+++ b/target/linux/generic/files/drivers/net/phy/b53/b53_priv.h
@@ -46,13 +46,7 @@ enum {
 	BCM5398_DEVICE_ID = 0x98,
 	BCM53115_DEVICE_ID = 0x53115,
 	BCM53125_DEVICE_ID = 0x53125,
-	BCM53128_DEVICE_ID = 0x53128,
 	BCM63XX_DEVICE_ID = 0x6300,
-	BCM53010_DEVICE_ID = 0x53010,
-	BCM53011_DEVICE_ID = 0x53011,
-	BCM53012_DEVICE_ID = 0x53012,
-	BCM53018_DEVICE_ID = 0x53018,
-	BCM53019_DEVICE_ID = 0x53019,
 };
 
 #define B53_N_PORTS	9
@@ -138,8 +132,7 @@ static inline int is539x(struct b53_devi
 static inline int is531x5(struct b53_device *dev)
 {
 	return dev->chip_id == BCM53115_DEVICE_ID ||
-		dev->chip_id == BCM53125_DEVICE_ID ||
-		dev->chip_id == BCM53128_DEVICE_ID;
+		dev->chip_id == BCM53125_DEVICE_ID;
 }
 
 static inline int is63xx(struct b53_device *dev)
@@ -151,15 +144,6 @@ static inline int is63xx(struct b53_devi
 #endif
 }
 
-static inline int is5301x(struct b53_device *dev)
-{
-	return dev->chip_id == BCM53010_DEVICE_ID ||
-		dev->chip_id == BCM53011_DEVICE_ID ||
-		dev->chip_id == BCM53012_DEVICE_ID ||
-		dev->chip_id == BCM53018_DEVICE_ID ||
-		dev->chip_id == BCM53019_DEVICE_ID;
-}
-
 #define B53_CPU_PORT_25	5
 #define B53_CPU_PORT	8
 
@@ -308,7 +292,6 @@ static inline int b53_switch_get_reset_g
 	enum bcm47xx_board board = bcm47xx_board_get();
 
 	switch (board) {
-	case BCM47XX_BOARD_LINKSYS_WRT300NV11:
 	case BCM47XX_BOARD_LINKSYS_WRT310NV1:
 		return 8;
 	default:
diff --git a/target/linux/generic/files/drivers/net/phy/b53/b53_regs.h b/target/linux/generic/files/drivers/net/phy/b53/b53_regs.h
--- a/target/linux/generic/files/drivers/net/phy/b53/b53_regs.h
+++ b/target/linux/generic/files/drivers/net/phy/b53/b53_regs.h
@@ -31,12 +31,12 @@
 #define B53_MEM_ACCESS_PAGE		0x08 /* Memory access */
 
 /* PHY Registers */
-#define B53_PORT_MII_PAGE(i)		(0x10 + (i)) /* Port i MII Registers */
+#define B53_PORT_MII_PAGE(i)		(0x10 + i) /* Port i MII Registers */
 #define B53_IM_PORT_PAGE		0x18 /* Inverse MII Port (to EMAC) */
 #define B53_ALL_PORT_PAGE		0x19 /* All ports MII (broadcast) */
 
 /* MIB registers */
-#define B53_MIB_PAGE(i)			(0x20 + (i))
+#define B53_MIB_PAGE(i)			(0x20 + i)
 
 /* Quality of Service (QoS) Registers */
 #define B53_QOS_PAGE			0x30
@@ -50,22 +50,19 @@
 /* Jumbo Frame Registers */
 #define B53_JUMBO_PAGE			0x40
 
-/* CFP Configuration Registers Page */
-#define B53_CFP_PAGE			0xa1
-
 /*************************************************************************
  * Control Page registers
  *************************************************************************/
 
 /* Port Control Register (8 bit) */
-#define B53_PORT_CTRL(i)		(0x00 + (i))
+#define B53_PORT_CTRL(i)		(0x00 + i)
 #define   PORT_CTRL_RX_DISABLE		BIT(0)
 #define   PORT_CTRL_TX_DISABLE		BIT(1)
 #define   PORT_CTRL_RX_BCST_EN		BIT(2) /* Broadcast RX (P8 only) */
 #define   PORT_CTRL_RX_MCST_EN		BIT(3) /* Multicast RX (P8 only) */
 #define   PORT_CTRL_RX_UCST_EN		BIT(4) /* Unicast RX (P8 only) */
 #define	  PORT_CTRL_STP_STATE_S		5
-#define   PORT_CTRL_STP_STATE_MASK	(0x7 << PORT_CTRL_STP_STATE_S)
+#define   PORT_CTRL_STP_STATE_MASK	(0x3 << PORT_CTRL_STP_STATE_S)
 
 /* SMP Control Register (8 bit) */
 #define B53_SMP_CTRL			0x0a
@@ -78,7 +75,7 @@
 /* IMP Port state override register (8 bit) */
 #define B53_PORT_OVERRIDE_CTRL		0x0e
 #define   PORT_OVERRIDE_LINK		BIT(0)
-#define   PORT_OVERRIDE_FULL_DUPLEX	BIT(1) /* 0 = Half Duplex */
+#define   PORT_OVERRIDE_HALF_DUPLEX	BIT(1) /* 0 = Full Duplex */
 #define   PORT_OVERRIDE_SPEED_S		2
 #define   PORT_OVERRIDE_SPEED_10M	(0 << PORT_OVERRIDE_SPEED_S)
 #define   PORT_OVERRIDE_SPEED_100M	(1 << PORT_OVERRIDE_SPEED_S)
@@ -86,7 +83,6 @@
 #define   PORT_OVERRIDE_RV_MII_25	BIT(4) /* BCM5325 only */
 #define   PORT_OVERRIDE_RX_FLOW		BIT(4)
 #define   PORT_OVERRIDE_TX_FLOW		BIT(5)
-#define   PORT_OVERRIDE_SPEED_2000M	BIT(6) /* BCM5301X only, requires setting 1000M */
 #define   PORT_OVERRIDE_EN		BIT(7) /* Use the register contents */
 
 /* Power-down mode control */
@@ -103,25 +99,6 @@
 #define B53_MC_FLOOD_MASK		0x34
 #define B53_IPMC_FLOOD_MASK		0x36
 
-/*
- * Override Ports 0-7 State on devices with xMII interfaces (8 bit)
- *
- * For port 8 still use B53_PORT_OVERRIDE_CTRL
- * Please note that not all ports are available on every hardware, e.g. BCM5301X
- * don't include overriding port 6, BCM63xx also have some limitations.
- */
-#define B53_GMII_PORT_OVERRIDE_CTRL(i)	(0x58 + (i))
-#define   GMII_PO_LINK			BIT(0)
-#define   GMII_PO_FULL_DUPLEX		BIT(1) /* 0 = Half Duplex */
-#define   GMII_PO_SPEED_S		2
-#define   GMII_PO_SPEED_10M		(0 << GMII_PO_SPEED_S)
-#define   GMII_PO_SPEED_100M		(1 << GMII_PO_SPEED_S)
-#define   GMII_PO_SPEED_1000M		(2 << GMII_PO_SPEED_S)
-#define   GMII_PO_RX_FLOW		BIT(4)
-#define   GMII_PO_TX_FLOW		BIT(5)
-#define   GMII_PO_EN			BIT(6) /* Use the register contents */
-#define   GMII_PO_SPEED_2000M		BIT(7) /* BCM5301X only, requires setting 1000M */
-
 /* Software reset register (8 bit) */
 #define B53_SOFTRESET			0x79
 
@@ -179,10 +156,6 @@
 #define   GC_FRM_MGMT_PORT_04		0x00
 #define   GC_FRM_MGMT_PORT_MII		0x80
 
-/* Broadcom Header control register (8 bit) */
-#define B53_BRCM_HDR			0x03
-#define   BRCM_HDR_EN			BIT(0) /* Enable tagging on IMP port */
-
 /* Device ID register (8 or 32 bit) */
 #define B53_DEVICE_ID			0x30
 
@@ -309,10 +282,8 @@
 #define B53_VLAN_WRITE_65		0x0a
 #define B53_VLAN_READ			0x0c
 #define   VA_MEMBER_MASK		0x3f
-#define   VA_UNTAG_S_25			6
-#define   VA_UNTAG_MASK_25		0x3f
-#define   VA_UNTAG_S_65			7
-#define   VA_UNTAG_MASK_65		0x1f
+#define   VA_UNTAG_S			6
+#define   VA_UNTAG_MASK			(0x3f << VA_UNTAG_S)
 #define   VA_VID_HIGH_S			12
 #define   VA_VID_HIGH_MASK		(0xffff << VA_VID_HIGH_S)
 #define   VA_VALID_25			BIT(20)
@@ -337,11 +308,4 @@
 #define   JMS_MIN_SIZE			1518
 #define   JMS_MAX_SIZE			9724
 
-/*************************************************************************
- * CFP Configuration Page Registers
- *************************************************************************/
-
-/* CFP Control Register with ports map (8 bit) */
-#define B53_CFP_CTRL			0x00
-
 #endif /* !__B53_REGS_H */
diff --git a/target/linux/generic/files/drivers/net/phy/b53/b53_spi.c b/target/linux/generic/files/drivers/net/phy/b53/b53_spi.c
--- a/target/linux/generic/files/drivers/net/phy/b53/b53_spi.c
+++ b/target/linux/generic/files/drivers/net/phy/b53/b53_spi.c
@@ -86,7 +86,6 @@ static inline int b53_spi_set_page(struc
 static inline int b53_prepare_reg_access(struct spi_device *spi, u8 page)
 {
 	int ret = b53_spi_clear_status(spi);
-
 	if (ret)
 		return ret;
 
@@ -145,7 +144,6 @@ static int b53_spi_read8(struct b53_devi
 static int b53_spi_read16(struct b53_device *dev, u8 page, u8 reg, u16 *val)
 {
 	int ret = b53_spi_read(dev, page, reg, (u8 *)val, 2);
-
 	if (!ret)
 		*val = le16_to_cpu(*val);
 
@@ -155,7 +153,6 @@ static int b53_spi_read16(struct b53_dev
 static int b53_spi_read32(struct b53_device *dev, u8 page, u8 reg, u32 *val)
 {
 	int ret = b53_spi_read(dev, page, reg, (u8 *)val, 4);
-
 	if (!ret)
 		*val = le32_to_cpu(*val);
 
@@ -177,7 +174,6 @@ static int b53_spi_read48(struct b53_dev
 static int b53_spi_read64(struct b53_device *dev, u8 page, u8 reg, u64 *val)
 {
 	int ret = b53_spi_read(dev, page, reg, (u8 *)val, 8);
-
 	if (!ret)
 		*val = le64_to_cpu(*val);
 
@@ -298,17 +294,20 @@ static int b53_spi_probe(struct spi_devi
 	if (ret)
 		return ret;
 
-	spi_set_drvdata(spi, dev);
+	spi->dev.platform_data = dev;
 
 	return 0;
 }
 
 static int b53_spi_remove(struct spi_device *spi)
 {
-	struct b53_device *dev = spi_get_drvdata(spi);
+	struct b53_device *dev = spi->dev.platform_data;
 
-	if (dev)
+	if (dev) {
+		struct b53_platform_data *pdata = dev->pdata;
 		b53_switch_remove(dev);
+		spi->dev.platform_data = pdata;
+	}
 
 	return 0;
 }
diff --git a/target/linux/generic/files/drivers/net/phy/micrel.c b/target/linux/generic/files/drivers/net/phy/micrel.c
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/drivers/net/phy/micrel.c
@@ -0,0 +1,83 @@
+/*
+ *  Driver for Micrel/Kendin PHYs
+ *
+ *  Copyright (c) 2008-2009 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
+#include <linux/phy.h>
+
+#define KSZ_REG_INT_CTRL	0x1b
+
+#define KSZ_INT_LU_EN	(1 << 8)	/* enable Link Up interrupt */
+#define KSZ_INT_RF_EN	(1 << 9)	/* enable Remote Fault interrupt */
+#define KSZ_INT_LD_EN	(1 << 10)	/* enable Link Down interrupt */
+
+#define KSZ_INT_INIT	(KSZ_INT_LU_EN | KSZ_INT_LD_EN)
+
+static int ksz8041_ack_interrupt(struct phy_device *phydev)
+{
+	int err;
+
+	err = phy_read(phydev, KSZ_REG_INT_CTRL);
+
+	return (err < 0) ? err : 0;
+}
+
+static int ksz8041_config_intr(struct phy_device *phydev)
+{
+	int err;
+
+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+		err = phy_write(phydev, KSZ_REG_INT_CTRL,
+				KSZ_INT_INIT);
+	else
+		err = phy_write(phydev, KSZ_REG_INT_CTRL, 0);
+
+	return err;
+}
+
+static struct phy_driver ksz8041_phy_driver = {
+	.phy_id		= 0x00221512,
+	.name		= "Micrel KSZ8041",
+	.phy_id_mask	= 0x001fffff,
+	.features	= PHY_BASIC_FEATURES,
+	.flags		= PHY_HAS_INTERRUPT,
+	.config_aneg	= genphy_config_aneg,
+	.read_status	= genphy_read_status,
+	.ack_interrupt	= ksz8041_ack_interrupt,
+	.config_intr	= ksz8041_config_intr,
+	.driver	= {
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init micrel_phy_init(void)
+{
+	return phy_driver_register(&ksz8041_phy_driver);
+}
+
+static void __exit micrel_phy_exit(void)
+{
+	phy_driver_unregister(&ksz8041_phy_driver);
+}
+
+#ifdef MODULE
+module_init(micrel_phy_init);
+module_exit(micrel_phy_exit);
+#else
+subsys_initcall(micrel_phy_init);
+#endif
+
+MODULE_DESCRIPTION("Micrel/Kendin PHY driver");
+MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
+MODULE_AUTHOR("Imre Kaloz <kaloz@openwrt.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/target/linux/generic/files/drivers/net/phy/rtl8306.c b/target/linux/generic/files/drivers/net/phy/rtl8306.c
--- a/target/linux/generic/files/drivers/net/phy/rtl8306.c
+++ b/target/linux/generic/files/drivers/net/phy/rtl8306.c
@@ -126,7 +126,6 @@ enum rtl_regidx {
 	RTL_REG_EN_TAG_CLR,
 	RTL_REG_EN_TAG_IN,
 	RTL_REG_TRAP_CPU,
-	RTL_REG_CPU_LINKUP,
 	RTL_REG_TRUNK_PORTSEL,
 	RTL_REG_EN_TRUNK,
 	RTL_REG_RESET,
@@ -195,7 +194,6 @@ static const struct rtl_reg rtl_regs[] =
 	[RTL_REG_RESET]          = { 0, 0, 16,  1, 12, 0 },
 
 	[RTL_REG_TRAP_CPU]       = { 3, 2, 22,  1,  6, 0 },
-	[RTL_REG_CPU_LINKUP]     = { 0, 6, 22,  1, 15, 0 },
 
 	[RTL_REG_VLAN_TAG_ONLY]  = { 0, 0, 16,  1,  8, 1 },
 	[RTL_REG_VLAN_FILTER]    = { 0, 0, 16,  1,  9, 1 },
@@ -435,8 +433,6 @@ rtl_hw_apply(struct switch_dev *dev)
 	rtl_set(dev, RTL_REG_TRUNK_PORTSEL, trunk_psel);
 	rtl_phy_restore(dev, 5, &port5);
 
-	rtl_set(dev, RTL_REG_CPU_LINKUP, 1);
-
 	return 0;
 }
 
@@ -523,7 +519,7 @@ rtl_get_cpuport(struct switch_dev *dev, 
 #endif
 
 static int
-rtl_reset(struct switch_dev *dev)
+rtl_reset(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
 {
 	rtl_hw_init(dev);
 	return 0;
@@ -586,27 +582,6 @@ rtl_attr_get_port_int(struct switch_dev 
 	return rtl_attr_get_int(dev, attr, val);
 }
 
-static int 
-rtl_get_port_link(struct switch_dev *dev, int port, struct switch_port_link *link)
-{
-	if (port >= RTL8306_NUM_PORTS)
-		return -EINVAL;
-
-	link->link = rtl_get(dev, RTL_PORT_REG(port, LINK));
-	if (!link->link)
-		return 0;
-
-	link->duplex = rtl_get(dev, RTL_PORT_REG(port, DUPLEX));
-	link->aneg = rtl_get(dev, RTL_PORT_REG(port, NWAY));
-
-	if (rtl_get(dev, RTL_PORT_REG(port, SPEED)))
-		link->speed = SWITCH_PORT_SPEED_100;
-	else
-		link->speed = SWITCH_PORT_SPEED_10;
-
-	return 0;
-}
-
 static int
 rtl_attr_set_vlan_int(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
 {
@@ -639,8 +614,7 @@ rtl_get_ports(struct switch_dev *dev, st
 
 		port = &val->value.ports[val->len];
 		port->id = i;
-		if (rtl_get(dev, RTL_PORT_REG(i, TAG_INSERT)) == 2 || i == dev->cpu_port)
-			port->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
+		port->flags = 0;
 		val->len++;
 	}
 
@@ -679,8 +653,7 @@ rtl_set_vlan(struct switch_dev *dev, con
 static int
 rtl_get_vlan(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
 {
-	val->value.i = rtl_get(dev, RTL_REG_VLAN_ENABLE);
-	return 0;
+	return rtl_get(dev, RTL_REG_VLAN_ENABLE);
 }
 
 static int
@@ -735,6 +708,12 @@ rtl_set_ports(struct switch_dev *dev, st
 static struct switch_attr rtl_globals[] = {
 	{
 		.type = SWITCH_TYPE_INT,
+		.name = "reset",
+		.description = "Reset the switch",
+		.set = rtl_reset,
+	},
+	{
+		.type = SWITCH_TYPE_INT,
 		.name = "enable_vlan",
 		.description = "Enable VLAN mode",
 		.max = 1,
@@ -803,6 +782,13 @@ static struct switch_attr rtl_port[] = {
 		.description = "Port VLAN ID",
 		.max = RTL8306_NUM_VLANS - 1,
 	},
+	{
+		RTL_PORT_REGATTR(LINK),
+		.name = "link",
+		.description = "get the current link state",
+		.max = 1,
+		.set = NULL,
+	},
 #ifdef DEBUG
 	{
 		RTL_PORT_REGATTR(NULL_VID_REPLACE),
@@ -829,6 +815,18 @@ static struct switch_attr rtl_port[] = {
 		.max = 3,
 	},
 #endif
+	{
+		RTL_PORT_REGATTR(SPEED),
+		.name = "speed",
+		.description = "current link speed",
+		.max = 1,
+	},
+	{
+		RTL_PORT_REGATTR(NWAY),
+		.name = "nway",
+		.description = "enable autonegotiation",
+		.max = 1,
+	},
 };
 
 static struct switch_attr rtl_vlan[] = {
@@ -857,8 +855,6 @@ static const struct switch_dev_ops rtl83
 	.get_vlan_ports = rtl_get_ports,
 	.set_vlan_ports = rtl_set_ports,
 	.apply_config = rtl_hw_apply,
-	.reset_switch = rtl_reset,
-	.get_port_link = rtl_get_port_link,
 };
 
 static int
diff --git a/target/linux/generic/files/drivers/net/phy/swconfig.c b/target/linux/generic/files/drivers/net/phy/swconfig.c
--- a/target/linux/generic/files/drivers/net/phy/swconfig.c
+++ b/target/linux/generic/files/drivers/net/phy/swconfig.c
@@ -24,7 +24,13 @@
 #include <linux/skbuff.h>
 #include <linux/switch.h>
 #include <linux/of.h>
-#include <linux/version.h>
+
+//#define DEBUG 1
+#ifdef DEBUG
+#define DPRINTF(format, ...) printk("%s: " format, __func__, ##__VA_ARGS__)
+#else
+#define DPRINTF(...) do {} while(0)
+#endif
 
 #define SWCONFIG_DEVNAME	"switch%d"
 
@@ -33,12 +39,13 @@
 MODULE_AUTHOR("Felix Fietkau <nbd@openwrt.org>");
 MODULE_LICENSE("GPL");
 
-static int swdev_id;
+static int swdev_id = 0;
 static struct list_head swdevs;
 static DEFINE_SPINLOCK(swdevs_lock);
 struct swconfig_callback;
 
-struct swconfig_callback {
+struct swconfig_callback
+{
 	struct sk_buff *msg;
 	struct genlmsghdr *hdr;
 	struct genl_info *info;
@@ -57,8 +64,7 @@ struct swconfig_callback {
 /* defaults */
 
 static int
-swconfig_get_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr,
-			struct switch_val *val)
+swconfig_get_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
 {
 	int ret;
 	if (val->port_vlan >= dev->vlans)
@@ -72,8 +78,7 @@ swconfig_get_vlan_ports(struct switch_de
 }
 
 static int
-swconfig_set_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr,
-			struct switch_val *val)
+swconfig_set_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
 {
 	struct switch_port *ports = val->value.ports;
 	const struct switch_dev_ops *ops = dev->ops;
@@ -102,8 +107,7 @@ swconfig_set_vlan_ports(struct switch_de
 }
 
 static int
-swconfig_set_pvid(struct switch_dev *dev, const struct switch_attr *attr,
-			struct switch_val *val)
+swconfig_set_pvid(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
 {
 	if (val->port_vlan >= dev->ports)
 		return -EINVAL;
@@ -115,8 +119,7 @@ swconfig_set_pvid(struct switch_dev *dev
 }
 
 static int
-swconfig_get_pvid(struct switch_dev *dev, const struct switch_attr *attr,
-			struct switch_val *val)
+swconfig_get_pvid(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
 {
 	if (val->port_vlan >= dev->ports)
 		return -EINVAL;
@@ -145,8 +148,7 @@ swconfig_speed_str(enum switch_port_spee
 }
 
 static int
-swconfig_get_link(struct switch_dev *dev, const struct switch_attr *attr,
-			struct switch_val *val)
+swconfig_get_link(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
 {
 	struct switch_port_link link;
 	int len;
@@ -167,14 +169,12 @@ swconfig_get_link(struct switch_dev *dev
 
 	if (link.link)
 		len = snprintf(dev->buf, sizeof(dev->buf),
-			       "port:%d link:up speed:%s %s-duplex %s%s%s%s%s",
+			       "port:%d link:up speed:%s %s-duplex %s%s%s",
 			       val->port_vlan,
 			       swconfig_speed_str(link.speed),
 			       link.duplex ? "full" : "half",
-			       link.tx_flow ? "txflow " : "",
+			       link.tx_flow ? "txflow ": "",
 			       link.rx_flow ?	"rxflow " : "",
-			       link.eee & ADVERTISED_100baseT_Full ? "eee100 " : "",
-			       link.eee & ADVERTISED_1000baseT_Full ? "eee1000 " : "",
 			       link.aneg ? "auto" : "");
 	else
 		len = snprintf(dev->buf, sizeof(dev->buf), "port:%d link:down",
@@ -187,8 +187,7 @@ swconfig_get_link(struct switch_dev *dev
 }
 
 static int
-swconfig_apply_config(struct switch_dev *dev, const struct switch_attr *attr,
-			struct switch_val *val)
+swconfig_apply_config(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
 {
 	/* don't complain if not supported by the switch driver */
 	if (!dev->ops->apply_config)
@@ -198,8 +197,7 @@ swconfig_apply_config(struct switch_dev 
 }
 
 static int
-swconfig_reset_switch(struct switch_dev *dev, const struct switch_attr *attr,
-			struct switch_val *val)
+swconfig_reset_switch(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
 {
 	/* don't complain if not supported by the switch driver */
 	if (!dev->ops->reset_switch)
@@ -265,8 +263,7 @@ static struct switch_attr default_vlan[]
 };
 
 static const struct switch_attr *
-swconfig_find_attr_by_name(const struct switch_attrlist *alist,
-				const char *name)
+swconfig_find_attr_by_name(const struct switch_attrlist *alist, const char *name)
 {
 	int i;
 
@@ -359,7 +356,7 @@ swconfig_get_dev(struct genl_info *info)
 	if (dev)
 		mutex_lock(&dev->sw_mutex);
 	else
-		pr_debug("device %d not found\n", id);
+		DPRINTF("device %d not found\n", id);
 	swconfig_unlock();
 done:
 	return dev;
@@ -396,8 +393,7 @@ swconfig_dump_attr(struct swconfig_callb
 			op->description))
 			goto nla_put_failure;
 
-	genlmsg_end(msg, hdr);
-	return msg->len;
+	return genlmsg_end(msg, hdr);
 nla_put_failure:
 	genlmsg_cancel(msg, hdr);
 	return -EMSGSIZE;
@@ -465,7 +461,7 @@ swconfig_list_attrs(struct sk_buff *skb,
 	if (!dev)
 		return -EINVAL;
 
-	switch (hdr->cmd) {
+	switch(hdr->cmd) {
 	case SWITCH_CMD_LIST_GLOBAL:
 		alist = &dev->ops->attr_global;
 		def_list = default_global;
@@ -542,7 +538,7 @@ swconfig_lookup_attr(struct switch_dev *
 	if (!info->attrs[SWITCH_ATTR_OP_ID])
 		goto done;
 
-	switch (hdr->cmd) {
+	switch(hdr->cmd) {
 	case SWITCH_CMD_SET_GLOBAL:
 	case SWITCH_CMD_GET_GLOBAL:
 		alist = &dev->ops->attr_global;
@@ -601,7 +597,7 @@ swconfig_lookup_attr(struct switch_dev *
 
 done:
 	if (!attr)
-		pr_debug("attribute lookup failed\n");
+		DPRINTF("attribute lookup failed\n");
 	val->attr = attr;
 	return attr;
 }
@@ -655,7 +651,7 @@ swconfig_set_attr(struct sk_buff *skb, s
 		goto error;
 
 	val.attr = attr;
-	switch (attr->type) {
+	switch(attr->type) {
 	case SWITCH_TYPE_NOVAL:
 		break;
 	case SWITCH_TYPE_INT:
@@ -678,8 +674,7 @@ swconfig_set_attr(struct sk_buff *skb, s
 		/* TODO: implement multipart? */
 		if (info->attrs[SWITCH_ATTR_OP_VALUE_PORTS]) {
 			err = swconfig_parse_ports(skb,
-				info->attrs[SWITCH_ATTR_OP_VALUE_PORTS],
-				&val, dev->ports);
+				info->attrs[SWITCH_ATTR_OP_VALUE_PORTS], &val, dev->ports);
 			if (err < 0)
 				goto error;
 		} else {
@@ -809,7 +804,7 @@ swconfig_get_attr(struct sk_buff *skb, s
 	if (IS_ERR(hdr))
 		goto nla_put_failure;
 
-	switch (attr->type) {
+	switch(attr->type) {
 	case SWITCH_TYPE_INT:
 		if (nla_put_u32(msg, SWITCH_ATTR_OP_VALUE_INT, val.value.i))
 			goto nla_put_failure;
@@ -825,12 +820,11 @@ swconfig_get_attr(struct sk_buff *skb, s
 			goto nla_put_failure;
 		break;
 	default:
-		pr_debug("invalid type in attribute\n");
+		DPRINTF("invalid type in attribute\n");
 		err = -EINVAL;
 		goto error;
 	}
-	genlmsg_end(msg, hdr);
-	err = msg->len;
+	err = genlmsg_end(msg, hdr);
 	if (err < 0)
 		goto nla_put_failure;
 
@@ -883,18 +877,15 @@ swconfig_send_switch(struct sk_buff *msg
 		if (!p)
 			continue;
 		if (dev->portmap[i].s) {
-			if (nla_put_string(msg, SWITCH_PORTMAP_SEGMENT,
-						dev->portmap[i].s))
+			if (nla_put_string(msg, SWITCH_PORTMAP_SEGMENT, dev->portmap[i].s))
 				goto nla_put_failure;
-			if (nla_put_u32(msg, SWITCH_PORTMAP_VIRT,
-						dev->portmap[i].virt))
+			if (nla_put_u32(msg, SWITCH_PORTMAP_VIRT, dev->portmap[i].virt))
 				goto nla_put_failure;
 		}
 		nla_nest_end(msg, p);
 	}
 	nla_nest_end(msg, m);
-	genlmsg_end(msg, hdr);
-	return msg->len;
+	return genlmsg_end(msg, hdr);
 nla_put_failure:
 	genlmsg_cancel(msg, hdr);
 	return -EMSGSIZE;
@@ -1007,15 +998,13 @@ of_switch_load_portmap(struct switch_dev
 			continue;
 
 		if (size != (2 * sizeof(*prop))) {
-			pr_err("%s: failed to parse port mapping\n",
-					port->name);
+			pr_err("%s: failed to parse port mapping\n", port->name);
 			continue;
 		}
 
 		phys = be32_to_cpup(prop++);
 		if ((phys < 0) | (phys >= dev->ports)) {
-			pr_err("%s: physical port index out of range\n",
-					port->name);
+			pr_err("%s: physical port index out of range\n", port->name);
 			continue;
 		}
 
@@ -1045,12 +1034,12 @@ register_switch(struct switch_dev *dev, 
 	BUG_ON(!dev->alias);
 
 	if (dev->ports > 0) {
-		dev->portbuf = kzalloc(sizeof(struct switch_port) *
-				dev->ports, GFP_KERNEL);
+		dev->portbuf = kzalloc(sizeof(struct switch_port) * dev->ports,
+				GFP_KERNEL);
 		if (!dev->portbuf)
 			return -ENOMEM;
-		dev->portmap = kzalloc(sizeof(struct switch_portmap) *
-				dev->ports, GFP_KERNEL);
+		dev->portmap = kzalloc(sizeof(struct switch_portmap) * dev->ports,
+				GFP_KERNEL);
 		if (!dev->portmap) {
 			kfree(dev->portbuf);
 			return -ENOMEM;
@@ -1084,7 +1073,7 @@ register_switch(struct switch_dev *dev, 
 	/* fill device name */
 	snprintf(dev->devname, IFNAMSIZ, SWCONFIG_DEVNAME, i);
 
-	list_add_tail(&dev->dev_list, &swdevs);
+	list_add(&dev->dev_list, &swdevs);
 	swconfig_unlock();
 
 	err = swconfig_create_led_trigger(dev);
@@ -1112,14 +1101,9 @@ EXPORT_SYMBOL_GPL(unregister_switch);
 static int __init
 swconfig_init(void)
 {
-	int err;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0))
-	int i;
-#endif
+	int i, err;
 
 	INIT_LIST_HEAD(&swdevs);
-	
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0))
 	err = genl_register_family(&switch_fam);
 	if (err)
 		return err;
@@ -1129,17 +1113,12 @@ swconfig_init(void)
 		if (err)
 			goto unregister;
 	}
+
 	return 0;
 
 unregister:
 	genl_unregister_family(&switch_fam);
 	return err;
-#else
-	err = genl_register_family_with_ops(&switch_fam, swconfig_ops);
-	if (err)
-		return err;
-	return 0;
-#endif
 }
 
 static void __exit
diff --git a/target/linux/generic/files/drivers/net/phy/swconfig_leds.c b/target/linux/generic/files/drivers/net/phy/swconfig_leds.c
--- a/target/linux/generic/files/drivers/net/phy/swconfig_leds.c
+++ b/target/linux/generic/files/drivers/net/phy/swconfig_leds.c
@@ -209,7 +209,7 @@ swconfig_trig_led_event(struct switch_le
 	link = !!(sw_trig->port_link & port_mask);
 	if (!link) {
 		if (link != trig_data->prev_link)
-			swconfig_trig_set_brightness(trig_data, LED_OFF);
+			led_set_brightness(trig_data->led_cdev, LED_OFF);
 	} else {
 		unsigned long traffic;
 		int i;
diff --git a/target/linux/generic/files/fs/yaffs2/Kconfig b/target/linux/generic/files/fs/yaffs2/Kconfig
--- a/target/linux/generic/files/fs/yaffs2/Kconfig
+++ b/target/linux/generic/files/fs/yaffs2/Kconfig
@@ -1,23 +1,23 @@
 #
-# yaffs file system configurations
+# YAFFS file system configurations
 #
 
 config YAFFS_FS
-	tristate "yaffs2 file system support"
+	tristate "YAFFS2 file system support"
 	default n
 	depends on MTD_BLOCK
 	select YAFFS_YAFFS1
 	select YAFFS_YAFFS2
 	help
-	  yaffs2, or Yet Another Flash File System, is a file system
+	  YAFFS2, or Yet Another Flash Filing System, is a filing system
 	  optimised for NAND Flash chips.
 
-	  To compile the yaffs2 file system support as a module, choose M
+	  To compile the YAFFS2 file system support as a module, choose M
 	  here: the module will be called yaffs2.
 
 	  If unsure, say N.
 
-	  Further information on yaffs2 is available at
+	  Further information on YAFFS2 is available at
 	  <http://www.aleph1.co.uk/yaffs/>.
 
 config YAFFS_YAFFS1
@@ -25,7 +25,7 @@ config YAFFS_YAFFS1
 	depends on YAFFS_FS
 	default y
 	help
-	  Enable yaffs1 support -- yaffs for 512 byte / page devices
+	  Enable YAFFS1 support -- yaffs for 512 byte / page devices
 
 	  Not needed for 2K-page devices.
 
@@ -49,11 +49,11 @@ config YAFFS_9BYTE_TAGS
 	  If unsure, say N.
 
 config YAFFS_DOES_ECC
-	bool "Lets yaffs do its own ECC"
+	bool "Lets Yaffs do its own ECC"
 	depends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS
 	default n
 	help
-	  This enables yaffs to use its own ECC functions instead of using
+	  This enables Yaffs to use its own ECC functions instead of using
 	  the ones from the generic MTD-NAND driver.
 
 	  If unsure, say N.
@@ -74,7 +74,7 @@ config YAFFS_YAFFS2
 	depends on YAFFS_FS
 	default y
 	help
-	  Enable yaffs2 support -- yaffs for >= 2K bytes per page devices
+	  Enable YAFFS2 support -- yaffs for >= 2K bytes per page devices
 
 	  If unsure, say Y.
 
@@ -91,23 +91,39 @@ config YAFFS_AUTO_YAFFS2
 	  If unsure, say Y.
 
 config YAFFS_DISABLE_TAGS_ECC
-	bool "Disable yaffs from doing ECC on tags by default"
+	bool "Disable YAFFS from doing ECC on tags by default"
 	depends on YAFFS_FS && YAFFS_YAFFS2
 	default n
 	help
-	  This defaults yaffs to using its own ECC calculations on tags instead of
+	  This defaults Yaffs to using its own ECC calculations on tags instead of
 	  just relying on the MTD.
 	  This behavior can also be overridden with tags_ecc_on and
 	  tags_ecc_off mount options.
 
 	  If unsure, say N.
 
+
+config YAFFS_DISABLE_WIDE_TNODES
+	bool "Turn off wide tnodes"
+	depends on YAFFS_FS
+	default n
+	help
+	  Wide tnodes are only used for NAND arrays >=32MB for 512-byte
+	  page devices and >=128MB for 2k page devices. They use slightly
+	  more RAM but are faster since they eliminate chunk group
+	  searching.
+
+	  Setting this to 'y' will force tnode width to 16 bits and save
+	  memory but make large arrays slower.
+
+	  If unsure, say N.
+
 config YAFFS_ALWAYS_CHECK_CHUNK_ERASED
 	bool "Force chunk erase check"
 	depends on YAFFS_FS
 	default n
 	help
-          Normally yaffs only checks chunks before writing until an erased
+          Normally YAFFS only checks chunks before writing until an erased
 	  chunk is found. This helps to detect any partially written
 	  chunks that might have happened due to power loss.
 
@@ -120,6 +136,17 @@ config YAFFS_ALWAYS_CHECK_CHUNK_ERASED
 
 	  If unsure, say Y.
 
+config YAFFS_SHORT_NAMES_IN_RAM
+	bool "Cache short names in RAM"
+	depends on YAFFS_FS
+	default y
+	help
+	  If this config is set, then short names are stored with the
+	  yaffs_Object.  This costs an extra 16 bytes of RAM per object,
+	  but makes look-ups faster.
+
+	  If unsure, say Y.
+
 config YAFFS_EMPTY_LOST_AND_FOUND
 	bool "Empty lost and found on boot"
 	depends on YAFFS_FS
@@ -150,17 +177,7 @@ config YAFFS_DISABLE_BACKGROUND
 	 If this is set, then background processing is disabled.
 	 Background processing makes many foreground activities faster.
 
-	 If unsure, say N.
-
-config YAFFS_DISABLE_BAD_BLOCK_MARKING
-	bool "Disable yaffs2 bad block marking"
-	depends on YAFFS_FS
-	default n
-	help
-	 Useful during early flash bring up to prevent problems causing
-	 lots of bad block marking.
-
-	 If unsure, say N.
+	  If unsure, say N.
 
 config YAFFS_XATTR
 	bool "Enable yaffs2 xattr support"
@@ -169,3 +186,5 @@ config YAFFS_XATTR
 	help
 	 If this is set then yaffs2 will provide xattr support.
 	 If unsure, say Y.
+
+
diff --git a/target/linux/generic/files/fs/yaffs2/Makefile b/target/linux/generic/files/fs/yaffs2/Makefile
--- a/target/linux/generic/files/fs/yaffs2/Makefile
+++ b/target/linux/generic/files/fs/yaffs2/Makefile
@@ -4,15 +4,14 @@
 
 obj-$(CONFIG_YAFFS_FS) += yaffs.o
 
-yaffs-y := yaffs_ecc.o yaffs_vfs.o yaffs_guts.o yaffs_checkptrw.o
+yaffs-y := yaffs_ecc.o yaffs_vfs_glue.o yaffs_guts.o yaffs_checkptrw.o
 yaffs-y += yaffs_packedtags1.o yaffs_packedtags2.o yaffs_nand.o
-yaffs-y += yaffs_tagscompat.o yaffs_tagsmarshall.o
-yaffs-y += yaffs_mtdif.o
-yaffs-y += yaffs_nameval.o yaffs_attribs.o
+yaffs-y += yaffs_tagscompat.o yaffs_tagsvalidity.o
+yaffs-y += yaffs_mtdif.o yaffs_mtdif1.o yaffs_mtdif2.o
+yaffs-y += yaffs_nameval.o
 yaffs-y += yaffs_allocator.o
 yaffs-y += yaffs_yaffs1.o
 yaffs-y += yaffs_yaffs2.o
 yaffs-y += yaffs_bitmap.o
-yaffs-y += yaffs_summary.o
 yaffs-y += yaffs_verify.o
 
diff --git a/target/linux/generic/files/fs/yaffs2/NOTE.openwrt b/target/linux/generic/files/fs/yaffs2/NOTE.openwrt
--- a/target/linux/generic/files/fs/yaffs2/NOTE.openwrt
+++ b/target/linux/generic/files/fs/yaffs2/NOTE.openwrt
@@ -1,4 +1,4 @@
 The yaffs2 source has been fetched from the yaffs2 GIT tree.
 
 URL: git://www.aleph1.co.uk/yaffs2
-Version: 7e5cf0fa1b694f835cdc184a8395b229fa29f9ae (2014-08-07)
+Version: 7396445d7d0d13469b9505791114b9dc6b76ffe4 (2010-10-20)
diff --git a/target/linux/generic/files/fs/yaffs2/devextras.h b/target/linux/generic/files/fs/yaffs2/devextras.h
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/devextras.h
@@ -0,0 +1,101 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * This file is just holds extra declarations of macros that would normally
+ * be providesd in the Linux kernel. These macros have been written from
+ * scratch but are functionally equivalent to the Linux ones.
+ *
+ */
+
+#ifndef __EXTRAS_H__
+#define __EXTRAS_H__
+
+
+#include "yportenv.h"
+
+#if !(defined __KERNEL__)
+
+/* Definition of types */
+typedef unsigned char __u8;
+typedef unsigned short __u16;
+typedef unsigned __u32;
+
+#endif
+
+
+#if !(defined __KERNEL__)
+
+
+#ifndef WIN32
+#include <sys/stat.h>
+#endif
+
+
+#ifdef CONFIG_YAFFS_PROVIDE_DEFS
+/* File types */
+
+
+#define DT_UNKNOWN	0
+#define DT_FIFO		1
+#define DT_CHR		2
+#define DT_DIR		4
+#define DT_BLK		6
+#define DT_REG		8
+#define DT_LNK		10
+#define DT_SOCK		12
+#define DT_WHT		14
+
+
+#ifndef WIN32
+#include <sys/stat.h>
+#endif
+
+/*
+ * Attribute flags.  These should be or-ed together to figure out what
+ * has been changed!
+ */
+#define ATTR_MODE	1
+#define ATTR_UID	2
+#define ATTR_GID	4
+#define ATTR_SIZE	8
+#define ATTR_ATIME	16
+#define ATTR_MTIME	32
+#define ATTR_CTIME	64
+
+struct iattr {
+	unsigned int ia_valid;
+	unsigned ia_mode;
+	unsigned ia_uid;
+	unsigned ia_gid;
+	unsigned ia_size;
+	unsigned ia_atime;
+	unsigned ia_mtime;
+	unsigned ia_ctime;
+	unsigned int ia_attr_flags;
+};
+
+#endif
+
+#else
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+
+#endif
+
+
+#endif
diff --git a/target/linux/generic/files/fs/yaffs2/moduleconfig.h b/target/linux/generic/files/fs/yaffs2/moduleconfig.h
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/moduleconfig.h
@@ -0,0 +1,86 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Martin Fouts <Martin.Fouts@palmsource.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_CONFIG_H__
+#define __YAFFS_CONFIG_H__
+
+#ifdef YAFFS_OUT_OF_TREE
+
+/* DO NOT UNSET THESE THREE. YAFFS2 will not compile if you do. */
+#define CONFIG_YAFFS_FS
+#define CONFIG_YAFFS_YAFFS1
+#define CONFIG_YAFFS_YAFFS2
+
+/* These options are independent of each other.  Select those that matter. */
+
+/* Default: Not selected */
+/* Meaning: Yaffs does its own ECC, rather than using MTD ECC */
+/* #define CONFIG_YAFFS_DOES_ECC */
+
+/* Default: Selected */
+/* Meaning: Yaffs does its own ECC on tags for packed tags rather than use mtd */
+#define CONFIG_YAFFS_DOES_TAGS_ECC
+
+/* Default: Not selected */
+/* Meaning: ECC byte order is 'wrong'.  Only meaningful if */
+/*          CONFIG_YAFFS_DOES_ECC is set */
+/* #define CONFIG_YAFFS_ECC_WRONG_ORDER */
+
+/* Default: Not selected */
+/* Meaning: Always test whether chunks are erased before writing to them.
+	    Use during mtd debugging and init. */
+/* #define CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED */
+
+/* Default: Not Selected */
+/* Meaning: At mount automatically empty all files from lost and found. */
+/* This is done to fix an old problem where rmdir was not checking for an */
+/* empty directory. This can also be achieved with a mount option. */
+#define CONFIG_YAFFS_EMPTY_LOST_AND_FOUND
+
+/* Default: Selected */
+/* Meaning: Cache short names, taking more RAM, but faster look-ups */
+#define CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+
+/* Default: Unselected */
+/* Meaning: Select to disable block refreshing. */
+/* Block Refreshing periodically rewrites the oldest block. */
+/* #define CONFIG_DISABLE_BLOCK_REFRESHING */
+
+/* Default: Unselected */
+/* Meaning: Select to disable background processing */
+/* #define CONFIG_DISABLE_BACKGROUND */
+
+
+/* Default: Selected */
+/* Meaning: Enable XATTR support */
+#define CONFIG_YAFFS_XATTR
+
+/*
+Older-style on-NAND data format has a "page_status" byte to record
+chunk/page state.  This byte is zeroed when the page is discarded.
+Choose this option if you have existing on-NAND data in this format
+that you need to continue to support.  New data written also uses the
+older-style format.
+Note: Use of this option generally requires that MTD's oob layout be
+adjusted to use the older-style format.  See notes on tags formats and
+MTD versions in yaffs_mtdif1.c.
+*/
+/* Default: Not selected */
+/* Meaning: Use older-style on-NAND data format with page_status byte */
+/* #define CONFIG_YAFFS_9BYTE_TAGS */
+
+#endif /* YAFFS_OUT_OF_TREE */
+
+#endif /* __YAFFS_CONFIG_H__ */
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_allocator.c b/target/linux/generic/files/fs/yaffs2/yaffs_allocator.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_allocator.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_allocator.c
@@ -1,253 +1,299 @@
 /*
- * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
  *
  * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
  * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
  */
 
+
 #include "yaffs_allocator.h"
 #include "yaffs_guts.h"
 #include "yaffs_trace.h"
 #include "yportenv.h"
 
-/*
- * Each entry in yaffs_tnode_list and yaffs_obj_list hold blocks
- * of approx 100 objects that are themn allocated singly.
- * This is basically a simplified slab allocator.
- *
- * We don't use the Linux slab allocator because slab does not allow
- * us to dump all the objects in one hit when we do a umount and tear
- * down  all the tnodes and objects. slab requires that we first free
- * the individual objects.
- *
- * Once yaffs has been mainlined I shall try to motivate for a change
- * to slab to provide the extra features we need here.
- */
+#ifdef CONFIG_YAFFS_YMALLOC_ALLOCATOR
+
+void yaffs_deinit_raw_tnodes_and_objs(yaffs_dev_t *dev)
+{
+	dev = dev;
+}
+
+void yaffs_init_raw_tnodes_and_objs(yaffs_dev_t *dev)
+{
+	dev = dev;
+}
+
+yaffs_tnode_t *yaffs_alloc_raw_tnode(yaffs_dev_t *dev)
+{
+	return (yaffs_tnode_t *)YMALLOC(dev->tnode_size);
+}
+
+void yaffs_free_raw_tnode(yaffs_dev_t *dev, yaffs_tnode_t *tn)
+{
+	dev = dev;
+	YFREE(tn);
+}
+
+void yaffs_init_raw_objs(yaffs_dev_t *dev)
+{
+	dev = dev;
+}
+
+void yaffs_deinit_raw_objs(yaffs_dev_t *dev)
+{
+	dev = dev;
+}
+
+yaffs_obj_t *yaffs_alloc_raw_obj(yaffs_dev_t *dev)
+{
+	dev = dev;
+	return (yaffs_obj_t *) YMALLOC(sizeof(yaffs_obj_t));
+}
+
+
+void yaffs_free_raw_obj(yaffs_dev_t *dev, yaffs_obj_t *obj)
+{
+
+	dev = dev;
+	YFREE(obj);
+}
+
+#else
 
 struct yaffs_tnode_list {
 	struct yaffs_tnode_list *next;
-	struct yaffs_tnode *tnodes;
+	yaffs_tnode_t *tnodes;
 };
 
-struct yaffs_obj_list {
-	struct yaffs_obj_list *next;
-	struct yaffs_obj *objects;
+typedef struct yaffs_tnode_list yaffs_tnodelist_t;
+
+struct yaffs_obj_tList_struct {
+	yaffs_obj_t *objects;
+	struct yaffs_obj_tList_struct *next;
 };
 
-struct yaffs_allocator {
-	int n_tnodes_created;
-	struct yaffs_tnode *free_tnodes;
-	int n_free_tnodes;
-	struct yaffs_tnode_list *alloc_tnode_list;
+typedef struct yaffs_obj_tList_struct yaffs_obj_tList;
 
-	int n_obj_created;
-	struct list_head free_objs;
-	int n_free_objects;
 
-	struct yaffs_obj_list *allocated_obj_list;
+struct yaffs_AllocatorStruct {
+	int n_tnodesCreated;
+	yaffs_tnode_t *freeTnodes;
+	int nFreeTnodes;
+	yaffs_tnodelist_t *allocatedTnodeList;
+
+	int n_objCreated;
+	yaffs_obj_t *freeObjects;
+	int nFreeObjects;
+
+	yaffs_obj_tList *allocatedObjectList;
 };
 
-static void yaffs_deinit_raw_tnodes(struct yaffs_dev *dev)
+typedef struct yaffs_AllocatorStruct yaffs_Allocator;
+
+
+static void yaffs_deinit_raw_tnodes(yaffs_dev_t *dev)
 {
-	struct yaffs_allocator *allocator =
-	    (struct yaffs_allocator *)dev->allocator;
-	struct yaffs_tnode_list *tmp;
 
-	if (!allocator) {
-		BUG();
+	yaffs_Allocator *allocator = (yaffs_Allocator *)dev->allocator;
+
+	yaffs_tnodelist_t *tmp;
+
+	if(!allocator){
+		YBUG();
 		return;
 	}
 
-	while (allocator->alloc_tnode_list) {
-		tmp = allocator->alloc_tnode_list->next;
+	while (allocator->allocatedTnodeList) {
+		tmp = allocator->allocatedTnodeList->next;
 
-		kfree(allocator->alloc_tnode_list->tnodes);
-		kfree(allocator->alloc_tnode_list);
-		allocator->alloc_tnode_list = tmp;
+		YFREE(allocator->allocatedTnodeList->tnodes);
+		YFREE(allocator->allocatedTnodeList);
+		allocator->allocatedTnodeList = tmp;
+
 	}
 
-	allocator->free_tnodes = NULL;
-	allocator->n_free_tnodes = 0;
-	allocator->n_tnodes_created = 0;
+	allocator->freeTnodes = NULL;
+	allocator->nFreeTnodes = 0;
+	allocator->n_tnodesCreated = 0;
 }
 
-static void yaffs_init_raw_tnodes(struct yaffs_dev *dev)
+static void yaffs_init_raw_tnodes(yaffs_dev_t *dev)
 {
-	struct yaffs_allocator *allocator = dev->allocator;
+	yaffs_Allocator *allocator = dev->allocator;
 
-	if (!allocator) {
-		BUG();
-		return;
-	}
-
-	allocator->alloc_tnode_list = NULL;
-	allocator->free_tnodes = NULL;
-	allocator->n_free_tnodes = 0;
-	allocator->n_tnodes_created = 0;
+	if(allocator){
+		allocator->allocatedTnodeList = NULL;
+		allocator->freeTnodes = NULL;
+		allocator->nFreeTnodes = 0;
+		allocator->n_tnodesCreated = 0;
+	} else
+		YBUG();
 }
 
-static int yaffs_create_tnodes(struct yaffs_dev *dev, int n_tnodes)
+static int yaffs_create_tnodes(yaffs_dev_t *dev, int n_tnodes)
 {
-	struct yaffs_allocator *allocator =
-	    (struct yaffs_allocator *)dev->allocator;
+	yaffs_Allocator *allocator = (yaffs_Allocator *)dev->allocator;
 	int i;
-	struct yaffs_tnode *new_tnodes;
-	u8 *mem;
-	struct yaffs_tnode *curr;
-	struct yaffs_tnode *next;
-	struct yaffs_tnode_list *tnl;
+	yaffs_tnode_t *newTnodes;
+	__u8 *mem;
+	yaffs_tnode_t *curr;
+	yaffs_tnode_t *next;
+	yaffs_tnodelist_t *tnl;
 
-	if (!allocator) {
-		BUG();
+	if(!allocator){
+		YBUG();
 		return YAFFS_FAIL;
 	}
 
 	if (n_tnodes < 1)
 		return YAFFS_OK;
 
+
 	/* make these things */
-	new_tnodes = kmalloc(n_tnodes * dev->tnode_size, GFP_NOFS);
-	mem = (u8 *) new_tnodes;
 
-	if (!new_tnodes) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"yaffs: Could not allocate Tnodes");
+	newTnodes = YMALLOC(n_tnodes * dev->tnode_size);
+	mem = (__u8 *)newTnodes;
+
+	if (!newTnodes) {
+		T(YAFFS_TRACE_ERROR,
+			(TSTR("yaffs: Could not allocate Tnodes" TENDSTR)));
 		return YAFFS_FAIL;
 	}
 
 	/* New hookup for wide tnodes */
 	for (i = 0; i < n_tnodes - 1; i++) {
-		curr = (struct yaffs_tnode *)&mem[i * dev->tnode_size];
-		next = (struct yaffs_tnode *)&mem[(i + 1) * dev->tnode_size];
+		curr = (yaffs_tnode_t *) &mem[i * dev->tnode_size];
+		next = (yaffs_tnode_t *) &mem[(i+1) * dev->tnode_size];
 		curr->internal[0] = next;
 	}
 
-	curr = (struct yaffs_tnode *)&mem[(n_tnodes - 1) * dev->tnode_size];
-	curr->internal[0] = allocator->free_tnodes;
-	allocator->free_tnodes = (struct yaffs_tnode *)mem;
+	curr = (yaffs_tnode_t *) &mem[(n_tnodes - 1) * dev->tnode_size];
+	curr->internal[0] = allocator->freeTnodes;
+	allocator->freeTnodes = (yaffs_tnode_t *)mem;
 
-	allocator->n_free_tnodes += n_tnodes;
-	allocator->n_tnodes_created += n_tnodes;
+	allocator->nFreeTnodes += n_tnodes;
+	allocator->n_tnodesCreated += n_tnodes;
 
 	/* Now add this bunch of tnodes to a list for freeing up.
 	 * NB If we can't add this to the management list it isn't fatal
 	 * but it just means we can't free this bunch of tnodes later.
 	 */
-	tnl = kmalloc(sizeof(struct yaffs_tnode_list), GFP_NOFS);
+
+	tnl = YMALLOC(sizeof(yaffs_tnodelist_t));
 	if (!tnl) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"Could not add tnodes to management list");
-		return YAFFS_FAIL;
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR
+		   ("yaffs: Could not add tnodes to management list" TENDSTR)));
+		   return YAFFS_FAIL;
 	} else {
-		tnl->tnodes = new_tnodes;
-		tnl->next = allocator->alloc_tnode_list;
-		allocator->alloc_tnode_list = tnl;
+		tnl->tnodes = newTnodes;
+		tnl->next = allocator->allocatedTnodeList;
+		allocator->allocatedTnodeList = tnl;
 	}
 
-	yaffs_trace(YAFFS_TRACE_ALLOCATE, "Tnodes added");
+	T(YAFFS_TRACE_ALLOCATE, (TSTR("yaffs: Tnodes added" TENDSTR)));
 
 	return YAFFS_OK;
 }
 
-struct yaffs_tnode *yaffs_alloc_raw_tnode(struct yaffs_dev *dev)
+
+yaffs_tnode_t *yaffs_alloc_raw_tnode(yaffs_dev_t *dev)
 {
-	struct yaffs_allocator *allocator =
-	    (struct yaffs_allocator *)dev->allocator;
-	struct yaffs_tnode *tn = NULL;
+	yaffs_Allocator *allocator = (yaffs_Allocator *)dev->allocator;
+	yaffs_tnode_t *tn = NULL;
 
-	if (!allocator) {
-		BUG();
+	if(!allocator){
+		YBUG();
 		return NULL;
 	}
 
 	/* If there are none left make more */
-	if (!allocator->free_tnodes)
+	if (!allocator->freeTnodes)
 		yaffs_create_tnodes(dev, YAFFS_ALLOCATION_NTNODES);
 
-	if (allocator->free_tnodes) {
-		tn = allocator->free_tnodes;
-		allocator->free_tnodes = allocator->free_tnodes->internal[0];
-		allocator->n_free_tnodes--;
+	if (allocator->freeTnodes) {
+		tn = allocator->freeTnodes;
+		allocator->freeTnodes = allocator->freeTnodes->internal[0];
+		allocator->nFreeTnodes--;
 	}
 
 	return tn;
 }
 
 /* FreeTnode frees up a tnode and puts it back on the free list */
-void yaffs_free_raw_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
+void yaffs_free_raw_tnode(yaffs_dev_t *dev, yaffs_tnode_t *tn)
 {
-	struct yaffs_allocator *allocator = dev->allocator;
+	yaffs_Allocator *allocator = dev->allocator;
 
-	if (!allocator) {
-		BUG();
+	if(!allocator){
+		YBUG();
 		return;
 	}
 
 	if (tn) {
-		tn->internal[0] = allocator->free_tnodes;
-		allocator->free_tnodes = tn;
-		allocator->n_free_tnodes++;
+		tn->internal[0] = allocator->freeTnodes;
+		allocator->freeTnodes = tn;
+		allocator->nFreeTnodes++;
 	}
-	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+	dev->checkpoint_blocks_required = 0; /* force recalculation*/
 }
 
-/*--------------- yaffs_obj alloaction ------------------------
- *
- * Free yaffs_objs are stored in a list using obj->siblings.
- * The blocks of allocated objects are stored in a linked list.
- */
 
-static void yaffs_init_raw_objs(struct yaffs_dev *dev)
+
+static void yaffs_init_raw_objs(yaffs_dev_t *dev)
 {
-	struct yaffs_allocator *allocator = dev->allocator;
+	yaffs_Allocator *allocator = dev->allocator;
 
-	if (!allocator) {
-		BUG();
+	if(allocator) {
+		allocator->allocatedObjectList = NULL;
+		allocator->freeObjects = NULL;
+		allocator->nFreeObjects = 0;
+	} else
+		YBUG();
+}
+
+static void yaffs_deinit_raw_objs(yaffs_dev_t *dev)
+{
+	yaffs_Allocator *allocator = dev->allocator;
+	yaffs_obj_tList *tmp;
+
+	if(!allocator){
+		YBUG();
 		return;
 	}
 
-	allocator->allocated_obj_list = NULL;
-	INIT_LIST_HEAD(&allocator->free_objs);
-	allocator->n_free_objects = 0;
+	while (allocator->allocatedObjectList) {
+		tmp = allocator->allocatedObjectList->next;
+		YFREE(allocator->allocatedObjectList->objects);
+		YFREE(allocator->allocatedObjectList);
+
+		allocator->allocatedObjectList = tmp;
+	}
+
+	allocator->freeObjects = NULL;
+	allocator->nFreeObjects = 0;
+	allocator->n_objCreated = 0;
 }
 
-static void yaffs_deinit_raw_objs(struct yaffs_dev *dev)
+
+static int yaffs_create_free_objs(yaffs_dev_t *dev, int n_obj)
 {
-	struct yaffs_allocator *allocator = dev->allocator;
-	struct yaffs_obj_list *tmp;
+	yaffs_Allocator *allocator = dev->allocator;
 
-	if (!allocator) {
-		BUG();
-		return;
-	}
+	int i;
+	yaffs_obj_t *newObjects;
+	yaffs_obj_tList *list;
 
-	while (allocator->allocated_obj_list) {
-		tmp = allocator->allocated_obj_list->next;
-		kfree(allocator->allocated_obj_list->objects);
-		kfree(allocator->allocated_obj_list);
-		allocator->allocated_obj_list = tmp;
-	}
-
-	INIT_LIST_HEAD(&allocator->free_objs);
-	allocator->n_free_objects = 0;
-	allocator->n_obj_created = 0;
-}
-
-static int yaffs_create_free_objs(struct yaffs_dev *dev, int n_obj)
-{
-	struct yaffs_allocator *allocator = dev->allocator;
-	int i;
-	struct yaffs_obj *new_objs;
-	struct yaffs_obj_list *list;
-
-	if (!allocator) {
-		BUG();
+	if(!allocator){
+		YBUG();
 		return YAFFS_FAIL;
 	}
 
@@ -255,103 +301,109 @@ static int yaffs_create_free_objs(struct
 		return YAFFS_OK;
 
 	/* make these things */
-	new_objs = kmalloc(n_obj * sizeof(struct yaffs_obj), GFP_NOFS);
-	list = kmalloc(sizeof(struct yaffs_obj_list), GFP_NOFS);
+	newObjects = YMALLOC(n_obj * sizeof(yaffs_obj_t));
+	list = YMALLOC(sizeof(yaffs_obj_tList));
 
-	if (!new_objs || !list) {
-		kfree(new_objs);
-		new_objs = NULL;
-		kfree(list);
-		list = NULL;
-		yaffs_trace(YAFFS_TRACE_ALLOCATE,
-			"Could not allocate more objects");
+	if (!newObjects || !list) {
+		if (newObjects){
+			YFREE(newObjects);
+			newObjects = NULL;
+		}
+		if (list){
+			YFREE(list);
+			list = NULL;
+		}
+		T(YAFFS_TRACE_ALLOCATE,
+		  (TSTR("yaffs: Could not allocate more objects" TENDSTR)));
 		return YAFFS_FAIL;
 	}
 
 	/* Hook them into the free list */
-	for (i = 0; i < n_obj; i++)
-		list_add(&new_objs[i].siblings, &allocator->free_objs);
+	for (i = 0; i < n_obj - 1; i++) {
+		newObjects[i].siblings.next =
+				(struct ylist_head *)(&newObjects[i + 1]);
+	}
 
-	allocator->n_free_objects += n_obj;
-	allocator->n_obj_created += n_obj;
+	newObjects[n_obj - 1].siblings.next = (void *)allocator->freeObjects;
+	allocator->freeObjects = newObjects;
+	allocator->nFreeObjects += n_obj;
+	allocator->n_objCreated += n_obj;
 
 	/* Now add this bunch of Objects to a list for freeing up. */
 
-	list->objects = new_objs;
-	list->next = allocator->allocated_obj_list;
-	allocator->allocated_obj_list = list;
+	list->objects = newObjects;
+	list->next = allocator->allocatedObjectList;
+	allocator->allocatedObjectList = list;
 
 	return YAFFS_OK;
 }
 
-struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev)
+yaffs_obj_t *yaffs_alloc_raw_obj(yaffs_dev_t *dev)
 {
-	struct yaffs_obj *obj = NULL;
-	struct list_head *lh;
-	struct yaffs_allocator *allocator = dev->allocator;
+	yaffs_obj_t *obj = NULL;
+	yaffs_Allocator *allocator = dev->allocator;
 
-	if (!allocator) {
-		BUG();
+	if(!allocator) {
+		YBUG();
 		return obj;
 	}
 
 	/* If there are none left make more */
-	if (list_empty(&allocator->free_objs))
+	if (!allocator->freeObjects)
 		yaffs_create_free_objs(dev, YAFFS_ALLOCATION_NOBJECTS);
 
-	if (!list_empty(&allocator->free_objs)) {
-		lh = allocator->free_objs.next;
-		obj = list_entry(lh, struct yaffs_obj, siblings);
-		list_del_init(lh);
-		allocator->n_free_objects--;
+	if (allocator->freeObjects) {
+		obj = allocator->freeObjects;
+		allocator->freeObjects =
+			(yaffs_obj_t *) (allocator->freeObjects->siblings.next);
+		allocator->nFreeObjects--;
 	}
 
 	return obj;
 }
 
-void yaffs_free_raw_obj(struct yaffs_dev *dev, struct yaffs_obj *obj)
+
+void yaffs_free_raw_obj(yaffs_dev_t *dev, yaffs_obj_t *obj)
 {
 
-	struct yaffs_allocator *allocator = dev->allocator;
+	yaffs_Allocator *allocator = dev->allocator;
 
-	if (!allocator) {
-		BUG();
-		return;
-	}
-
-	/* Link into the free list. */
-	list_add(&obj->siblings, &allocator->free_objs);
-	allocator->n_free_objects++;
-}
-
-void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev)
-{
-
-	if (!dev->allocator) {
-		BUG();
-		return;
-	}
-
-	yaffs_deinit_raw_tnodes(dev);
-	yaffs_deinit_raw_objs(dev);
-	kfree(dev->allocator);
-	dev->allocator = NULL;
-}
-
-void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev)
-{
-	struct yaffs_allocator *allocator;
-
-	if (dev->allocator) {
-		BUG();
-		return;
-	}
-
-	allocator = kmalloc(sizeof(struct yaffs_allocator), GFP_NOFS);
-	if (allocator) {
-		dev->allocator = allocator;
-		yaffs_init_raw_tnodes(dev);
-		yaffs_init_raw_objs(dev);
+	if(!allocator)
+		YBUG();
+	else {
+		/* Link into the free list. */
+		obj->siblings.next = (struct ylist_head *)(allocator->freeObjects);
+		allocator->freeObjects = obj;
+		allocator->nFreeObjects++;
 	}
 }
 
+void yaffs_deinit_raw_tnodes_and_objs(yaffs_dev_t *dev)
+{
+	if(dev->allocator){
+		yaffs_deinit_raw_tnodes(dev);
+		yaffs_deinit_raw_objs(dev);
+
+		YFREE(dev->allocator);
+		dev->allocator=NULL;
+	} else
+		YBUG();
+}
+
+void yaffs_init_raw_tnodes_and_objs(yaffs_dev_t *dev)
+{
+	yaffs_Allocator *allocator;
+
+	if(!dev->allocator){
+		allocator = YMALLOC(sizeof(yaffs_Allocator));
+		if(allocator){
+			dev->allocator = allocator;
+			yaffs_init_raw_tnodes(dev);
+			yaffs_init_raw_objs(dev);
+		}
+	} else
+		YBUG();
+}
+
+
+#endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_allocator.h b/target/linux/generic/files/fs/yaffs2/yaffs_allocator.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_allocator.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_allocator.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -18,13 +18,13 @@
 
 #include "yaffs_guts.h"
 
-void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev);
-void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev);
+void yaffs_init_raw_tnodes_and_objs(yaffs_dev_t *dev);
+void yaffs_deinit_raw_tnodes_and_objs(yaffs_dev_t *dev);
 
-struct yaffs_tnode *yaffs_alloc_raw_tnode(struct yaffs_dev *dev);
-void yaffs_free_raw_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn);
+yaffs_tnode_t *yaffs_alloc_raw_tnode(yaffs_dev_t *dev);
+void yaffs_free_raw_tnode(yaffs_dev_t *dev, yaffs_tnode_t *tn);
 
-struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev);
-void yaffs_free_raw_obj(struct yaffs_dev *dev, struct yaffs_obj *obj);
+yaffs_obj_t *yaffs_alloc_raw_obj(yaffs_dev_t *dev);
+void yaffs_free_raw_obj(yaffs_dev_t *dev, yaffs_obj_t *obj);
 
 #endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_bitmap.c b/target/linux/generic/files/fs/yaffs2/yaffs_bitmap.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_bitmap.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_bitmap.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -17,81 +17,89 @@
  * Chunk bitmap manipulations
  */
 
-static inline u8 *yaffs_block_bits(struct yaffs_dev *dev, int blk)
+static Y_INLINE __u8 *yaffs_BlockBits(yaffs_dev_t *dev, int blk)
 {
 	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"BlockBits block %d is not valid",
-			blk);
-		BUG();
+		T(YAFFS_TRACE_ERROR,
+			(TSTR("**>> yaffs: BlockBits block %d is not valid" TENDSTR),
+			blk));
+		YBUG();
 	}
 	return dev->chunk_bits +
-	    (dev->chunk_bit_stride * (blk - dev->internal_start_block));
+		(dev->chunk_bit_stride * (blk - dev->internal_start_block));
 }
 
-void yaffs_verify_chunk_bit_id(struct yaffs_dev *dev, int blk, int chunk)
+void yaffs_verify_chunk_bit_id(yaffs_dev_t *dev, int blk, int chunk)
 {
 	if (blk < dev->internal_start_block || blk > dev->internal_end_block ||
-	    chunk < 0 || chunk >= dev->param.chunks_per_block) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"Chunk Id (%d:%d) invalid",
-			blk, chunk);
-		BUG();
+			chunk < 0 || chunk >= dev->param.chunks_per_block) {
+		T(YAFFS_TRACE_ERROR,
+		(TSTR("**>> yaffs: Chunk Id (%d:%d) invalid"TENDSTR),
+			blk, chunk));
+		YBUG();
 	}
 }
 
-void yaffs_clear_chunk_bits(struct yaffs_dev *dev, int blk)
+void yaffs_clear_chunk_bits(yaffs_dev_t *dev, int blk)
 {
-	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
 
-	memset(blk_bits, 0, dev->chunk_bit_stride);
+	memset(blkBits, 0, dev->chunk_bit_stride);
 }
 
-void yaffs_clear_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+void yaffs_clear_chunk_bit(yaffs_dev_t *dev, int blk, int chunk)
 {
-	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
 
 	yaffs_verify_chunk_bit_id(dev, blk, chunk);
-	blk_bits[chunk / 8] &= ~(1 << (chunk & 7));
+
+	blkBits[chunk / 8] &= ~(1 << (chunk & 7));
 }
 
-void yaffs_set_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+void yaffs_set_chunk_bit(yaffs_dev_t *dev, int blk, int chunk)
 {
-	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
 
 	yaffs_verify_chunk_bit_id(dev, blk, chunk);
-	blk_bits[chunk / 8] |= (1 << (chunk & 7));
+
+	blkBits[chunk / 8] |= (1 << (chunk & 7));
 }
 
-int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+int yaffs_check_chunk_bit(yaffs_dev_t *dev, int blk, int chunk)
 {
-	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
 
-	yaffs_verify_chunk_bit_id(dev, blk, chunk);
-	return (blk_bits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
+	return (blkBits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
 }
 
-int yaffs_still_some_chunks(struct yaffs_dev *dev, int blk)
+int yaffs_still_some_chunks(yaffs_dev_t *dev, int blk)
 {
-	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
 	int i;
-
 	for (i = 0; i < dev->chunk_bit_stride; i++) {
-		if (*blk_bits)
+		if (*blkBits)
 			return 1;
-		blk_bits++;
+		blkBits++;
 	}
 	return 0;
 }
 
-int yaffs_count_chunk_bits(struct yaffs_dev *dev, int blk)
+int yaffs_count_chunk_bits(yaffs_dev_t *dev, int blk)
 {
-	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
 	int i;
 	int n = 0;
+	for (i = 0; i < dev->chunk_bit_stride; i++) {
+		__u8 x = *blkBits;
+		while (x) {
+			if (x & 1)
+				n++;
+			x >>= 1;
+		}
 
-	for (i = 0; i < dev->chunk_bit_stride; i++, blk_bits++)
-		n += hweight8(*blk_bits);
-
+		blkBits++;
+	}
 	return n;
 }
+
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_bitmap.h b/target/linux/generic/files/fs/yaffs2/yaffs_bitmap.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_bitmap.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_bitmap.h
@@ -1,16 +1,14 @@
 /*
- * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
  *
  * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
- *
- * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
  */
 
 /*
@@ -22,12 +20,12 @@
 
 #include "yaffs_guts.h"
 
-void yaffs_verify_chunk_bit_id(struct yaffs_dev *dev, int blk, int chunk);
-void yaffs_clear_chunk_bits(struct yaffs_dev *dev, int blk);
-void yaffs_clear_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
-void yaffs_set_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
-int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
-int yaffs_still_some_chunks(struct yaffs_dev *dev, int blk);
-int yaffs_count_chunk_bits(struct yaffs_dev *dev, int blk);
+void yaffs_verify_chunk_bit_id(yaffs_dev_t *dev, int blk, int chunk);
+void yaffs_clear_chunk_bits(yaffs_dev_t *dev, int blk);
+void yaffs_clear_chunk_bit(yaffs_dev_t *dev, int blk, int chunk);
+void yaffs_set_chunk_bit(yaffs_dev_t *dev, int blk, int chunk);
+int yaffs_check_chunk_bit(yaffs_dev_t *dev, int blk, int chunk);
+int yaffs_still_some_chunks(yaffs_dev_t *dev, int blk);
+int yaffs_count_chunk_bits(yaffs_dev_t *dev, int blk);
 
 #endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_checkptrw.c b/target/linux/generic/files/fs/yaffs2/yaffs_checkptrw.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_checkptrw.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_checkptrw.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -14,91 +14,40 @@
 #include "yaffs_checkptrw.h"
 #include "yaffs_getblockinfo.h"
 
-struct yaffs_checkpt_chunk_hdr {
-	int version;
-	int seq;
-	u32 sum;
-	u32 xor;
-} ;
+static int yaffs2_checkpt_space_ok(yaffs_dev_t *dev)
+{
+	int blocksAvailable = dev->n_erased_blocks - dev->param.n_reserved_blocks;
 
+	T(YAFFS_TRACE_CHECKPOINT,
+		(TSTR("checkpt blocks available = %d" TENDSTR),
+		blocksAvailable));
 
-static int apply_chunk_offset(struct yaffs_dev *dev, int chunk)
-{
-	return chunk - dev->chunk_offset;
+	return (blocksAvailable <= 0) ? 0 : 1;
 }
 
-static int apply_block_offset(struct yaffs_dev *dev, int block)
-{
-	return block - dev->block_offset;
-}
 
-static void yaffs2_checkpt_init_chunk_hdr(struct yaffs_dev *dev)
-{
-	struct yaffs_checkpt_chunk_hdr hdr;
-
-	hdr.version = YAFFS_CHECKPOINT_VERSION;
-	hdr.seq = dev->checkpt_page_seq;
-	hdr.sum = dev->checkpt_sum;
-	hdr.xor = dev->checkpt_xor;
-
-	dev->checkpt_byte_offs = sizeof(hdr);
-
-	memcpy(dev->checkpt_buffer, &hdr, sizeof(hdr));
-}
-
-static int yaffs2_checkpt_check_chunk_hdr(struct yaffs_dev *dev)
-{
-	struct yaffs_checkpt_chunk_hdr hdr;
-
-	memcpy(&hdr, dev->checkpt_buffer, sizeof(hdr));
-
-	dev->checkpt_byte_offs = sizeof(hdr);
-
-	return hdr.version == YAFFS_CHECKPOINT_VERSION &&
-		hdr.seq == dev->checkpt_page_seq &&
-		hdr.sum == dev->checkpt_sum &&
-		hdr.xor == dev->checkpt_xor;
-}
-
-static int yaffs2_checkpt_space_ok(struct yaffs_dev *dev)
-{
-	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
-
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-		"checkpt blocks_avail = %d", blocks_avail);
-
-	return (blocks_avail <= 0) ? 0 : 1;
-}
-
-static int yaffs_checkpt_erase(struct yaffs_dev *dev)
+static int yaffs_checkpt_erase(yaffs_dev_t *dev)
 {
 	int i;
 
-	if (!dev->drv.drv_erase_fn)
+	if (!dev->param.erase_fn)
 		return 0;
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-		"checking blocks %d to %d",
-		dev->internal_start_block, dev->internal_end_block);
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checking blocks %d to %d"TENDSTR),
+		dev->internal_start_block, dev->internal_end_block));
 
 	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
-		struct yaffs_block_info *bi = yaffs_get_block_info(dev, i);
-		int offset_i = apply_block_offset(dev, i);
-		int result;
-
+		yaffs_block_info_t *bi = yaffs_get_block_info(dev, i);
 		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
-			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"erasing checkpt block %d", i);
+			T(YAFFS_TRACE_CHECKPOINT, (TSTR("erasing checkpt block %d"TENDSTR), i));
 
 			dev->n_erasures++;
 
-			result = dev->drv.drv_erase_fn(dev, offset_i);
-			if(result) {
+			if (dev->param.erase_fn(dev, i - dev->block_offset /* realign */)) {
 				bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
 				dev->n_erased_blocks++;
-				dev->n_free_chunks +=
-				    dev->param.chunks_per_block;
+				dev->n_free_chunks += dev->param.chunks_per_block;
 			} else {
-				dev->drv.drv_mark_bad_fn(dev, offset_i);
+				dev->param.bad_block_fn(dev, i);
 				bi->block_state = YAFFS_BLOCK_STATE_DEAD;
 			}
 		}
@@ -109,112 +58,93 @@ static int yaffs_checkpt_erase(struct ya
 	return 1;
 }
 
-static void yaffs2_checkpt_find_erased_block(struct yaffs_dev *dev)
+
+static void yaffs2_checkpt_find_erased_block(yaffs_dev_t *dev)
 {
-	int i;
-	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
-
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-		"allocating checkpt block: erased %d reserved %d avail %d next %d ",
-		dev->n_erased_blocks, dev->param.n_reserved_blocks,
-		blocks_avail, dev->checkpt_next_block);
+	int  i;
+	int blocksAvailable = dev->n_erased_blocks - dev->param.n_reserved_blocks;
+	T(YAFFS_TRACE_CHECKPOINT,
+		(TSTR("allocating checkpt block: erased %d reserved %d avail %d next %d "TENDSTR),
+		dev->n_erased_blocks, dev->param.n_reserved_blocks, blocksAvailable, dev->checkpt_next_block));
 
 	if (dev->checkpt_next_block >= 0 &&
-	    dev->checkpt_next_block <= dev->internal_end_block &&
-	    blocks_avail > 0) {
+			dev->checkpt_next_block <= dev->internal_end_block &&
+			blocksAvailable > 0) {
 
-		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
-		     i++) {
-			struct yaffs_block_info *bi;
-
-			bi = yaffs_get_block_info(dev, i);
+		for (i = dev->checkpt_next_block; i <= dev->internal_end_block; i++) {
+			yaffs_block_info_t *bi = yaffs_get_block_info(dev, i);
 			if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
 				dev->checkpt_next_block = i + 1;
 				dev->checkpt_cur_block = i;
-				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-					"allocating checkpt block %d", i);
+				T(YAFFS_TRACE_CHECKPOINT, (TSTR("allocating checkpt block %d"TENDSTR), i));
 				return;
 			}
 		}
 	}
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "out of checkpt blocks");
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("out of checkpt blocks"TENDSTR)));
 
 	dev->checkpt_next_block = -1;
 	dev->checkpt_cur_block = -1;
 }
 
-static void yaffs2_checkpt_find_block(struct yaffs_dev *dev)
+static void yaffs2_checkpt_find_block(yaffs_dev_t *dev)
 {
-	int i;
-	struct yaffs_ext_tags tags;
+	int  i;
+	yaffs_ext_tags tags;
 
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-		"find next checkpt block: start:  blocks %d next %d",
-		dev->blocks_in_checkpt, dev->checkpt_next_block);
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("find next checkpt block: start:  blocks %d next %d" TENDSTR),
+		dev->blocks_in_checkpt, dev->checkpt_next_block));
 
 	if (dev->blocks_in_checkpt < dev->checkpt_max_blocks)
-		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
-		     i++) {
+		for (i = dev->checkpt_next_block; i <= dev->internal_end_block; i++) {
 			int chunk = i * dev->param.chunks_per_block;
-			enum yaffs_block_state state;
-			u32 seq;
+			int realignedChunk = chunk - dev->chunk_offset;
 
-			dev->tagger.read_chunk_tags_fn(dev,
-					apply_chunk_offset(dev, chunk),
+			dev->param.read_chunk_tags_fn(dev, realignedChunk,
 					NULL, &tags);
-			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-				"find next checkpt block: search: block %d state %d oid %d seq %d eccr %d",
-				i, (int) state,
-				tags.obj_id, tags.seq_number,
-				tags.ecc_result);
+			T(YAFFS_TRACE_CHECKPOINT, (TSTR("find next checkpt block: search: block %d oid %d seq %d eccr %d" TENDSTR),
+				i, tags.obj_id, tags.seq_number, tags.ecc_result));
 
-			if (tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA)
-				continue;
-
-			dev->tagger.query_block_fn(dev,
-						apply_block_offset(dev, i),
-						&state, &seq);
-			if (state == YAFFS_BLOCK_STATE_DEAD)
-				continue;
-
-			/* Right kind of block */
-			dev->checkpt_next_block = tags.obj_id;
-			dev->checkpt_cur_block = i;
-			dev->checkpt_block_list[dev->blocks_in_checkpt] = i;
-			dev->blocks_in_checkpt++;
-			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-				"found checkpt block %d", i);
-			return;
+			if (tags.seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA) {
+				/* Right kind of block */
+				dev->checkpt_next_block = tags.obj_id;
+				dev->checkpt_cur_block = i;
+				dev->checkpt_block_list[dev->blocks_in_checkpt] = i;
+				dev->blocks_in_checkpt++;
+				T(YAFFS_TRACE_CHECKPOINT, (TSTR("found checkpt block %d"TENDSTR), i));
+				return;
+			}
 		}
 
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "found no more checkpt blocks");
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("found no more checkpt blocks"TENDSTR)));
 
 	dev->checkpt_next_block = -1;
 	dev->checkpt_cur_block = -1;
 }
 
-int yaffs2_checkpt_open(struct yaffs_dev *dev, int writing)
+
+int yaffs2_checkpt_open(yaffs_dev_t *dev, int forWriting)
 {
-	int i;
 
-	dev->checkpt_open_write = writing;
+
+	dev->checkpt_open_write = forWriting;
 
 	/* Got the functions we need? */
-	if (!dev->tagger.write_chunk_tags_fn ||
-	    !dev->tagger.read_chunk_tags_fn ||
-	    !dev->drv.drv_erase_fn ||
-	    !dev->drv.drv_mark_bad_fn)
+	if (!dev->param.write_chunk_tags_fn ||
+		!dev->param.read_chunk_tags_fn ||
+		!dev->param.erase_fn ||
+		!dev->param.bad_block_fn)
 		return 0;
 
-	if (writing && !yaffs2_checkpt_space_ok(dev))
+	if (forWriting && !yaffs2_checkpt_space_ok(dev))
 		return 0;
 
 	if (!dev->checkpt_buffer)
-		dev->checkpt_buffer =
-		    kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+		dev->checkpt_buffer = YMALLOC_DMA(dev->param.total_bytes_per_chunk);
 	if (!dev->checkpt_buffer)
 		return 0;
 
+
 	dev->checkpt_page_seq = 0;
 	dev->checkpt_byte_count = 0;
 	dev->checkpt_sum = 0;
@@ -223,46 +153,44 @@ int yaffs2_checkpt_open(struct yaffs_dev
 	dev->checkpt_cur_chunk = -1;
 	dev->checkpt_next_block = dev->internal_start_block;
 
-	if (writing) {
+	/* Erase all the blocks in the checkpoint area */
+	if (forWriting) {
 		memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
-		yaffs2_checkpt_init_chunk_hdr(dev);
+		dev->checkpt_byte_offs = 0;
 		return yaffs_checkpt_erase(dev);
+	} else {
+		int i;
+		/* Set to a value that will kick off a read */
+		dev->checkpt_byte_offs = dev->data_bytes_per_chunk;
+		/* A checkpoint block list of 1 checkpoint block per 16 block is (hopefully)
+		 * going to be way more than we need */
+		dev->blocks_in_checkpt = 0;
+		dev->checkpt_max_blocks = (dev->internal_end_block - dev->internal_start_block)/16 + 2;
+		dev->checkpt_block_list = YMALLOC(sizeof(int) * dev->checkpt_max_blocks);
+		if(!dev->checkpt_block_list)
+			return 0;
+
+		for (i = 0; i < dev->checkpt_max_blocks; i++)
+			dev->checkpt_block_list[i] = -1;
 	}
 
-	/* Opening for a read */
-	/* Set to a value that will kick off a read */
-	dev->checkpt_byte_offs = dev->data_bytes_per_chunk;
-	/* A checkpoint block list of 1 checkpoint block per 16 block is
-	 * (hopefully) going to be way more than we need */
-	dev->blocks_in_checkpt = 0;
-	dev->checkpt_max_blocks =
-	    (dev->internal_end_block - dev->internal_start_block) / 16 + 2;
-	dev->checkpt_block_list =
-	    kmalloc(sizeof(int) * dev->checkpt_max_blocks, GFP_NOFS);
-
-	if (!dev->checkpt_block_list)
-		return 0;
-
-	for (i = 0; i < dev->checkpt_max_blocks; i++)
-		dev->checkpt_block_list[i] = -1;
-
 	return 1;
 }
 
-int yaffs2_get_checkpt_sum(struct yaffs_dev *dev, u32 * sum)
+int yaffs2_get_checkpt_sum(yaffs_dev_t *dev, __u32 *sum)
 {
-	u32 composite_sum;
-
-	composite_sum = (dev->checkpt_sum << 8) | (dev->checkpt_xor & 0xff);
-	*sum = composite_sum;
+	__u32 compositeSum;
+	compositeSum =  (dev->checkpt_sum << 8) | (dev->checkpt_xor & 0xFF);
+	*sum = compositeSum;
 	return 1;
 }
 
-static int yaffs2_checkpt_flush_buffer(struct yaffs_dev *dev)
+static int yaffs2_checkpt_flush_buffer(yaffs_dev_t *dev)
 {
 	int chunk;
-	int offset_chunk;
-	struct yaffs_ext_tags tags;
+	int realignedChunk;
+
+	yaffs_ext_tags tags;
 
 	if (dev->checkpt_cur_block < 0) {
 		yaffs2_checkpt_find_erased_block(dev);
@@ -273,34 +201,31 @@ static int yaffs2_checkpt_flush_buffer(s
 		return 0;
 
 	tags.is_deleted = 0;
-	tags.obj_id = dev->checkpt_next_block;	/* Hint to next place to look */
+	tags.obj_id = dev->checkpt_next_block; /* Hint to next place to look */
 	tags.chunk_id = dev->checkpt_page_seq + 1;
-	tags.seq_number = YAFFS_SEQUENCE_CHECKPOINT_DATA;
+	tags.seq_number =  YAFFS_SEQUENCE_CHECKPOINT_DATA;
 	tags.n_bytes = dev->data_bytes_per_chunk;
 	if (dev->checkpt_cur_chunk == 0) {
 		/* First chunk we write for the block? Set block state to
 		   checkpoint */
-		struct yaffs_block_info *bi =
-		    yaffs_get_block_info(dev, dev->checkpt_cur_block);
+		yaffs_block_info_t *bi = yaffs_get_block_info(dev, dev->checkpt_cur_block);
 		bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
 		dev->blocks_in_checkpt++;
 	}
 
-	chunk =
-	    dev->checkpt_cur_block * dev->param.chunks_per_block +
-	    dev->checkpt_cur_chunk;
+	chunk = dev->checkpt_cur_block * dev->param.chunks_per_block + dev->checkpt_cur_chunk;
 
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-		"checkpoint wite buffer nand %d(%d:%d) objid %d chId %d",
-		chunk, dev->checkpt_cur_block, dev->checkpt_cur_chunk,
-		tags.obj_id, tags.chunk_id);
 
-	offset_chunk = apply_chunk_offset(dev, chunk);
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint wite buffer nand %d(%d:%d) objid %d chId %d" TENDSTR),
+		chunk, dev->checkpt_cur_block, dev->checkpt_cur_chunk, tags.obj_id, tags.chunk_id));
+
+	realignedChunk = chunk - dev->chunk_offset;
 
 	dev->n_page_writes++;
 
-	dev->tagger.write_chunk_tags_fn(dev, offset_chunk,
-				       dev->checkpt_buffer, &tags);
+	dev->param.write_chunk_tags_fn(dev, realignedChunk,
+			dev->checkpt_buffer, &tags);
+	dev->checkpt_byte_offs = 0;
 	dev->checkpt_page_seq++;
 	dev->checkpt_cur_chunk++;
 	if (dev->checkpt_cur_chunk >= dev->param.chunks_per_block) {
@@ -309,17 +234,19 @@ static int yaffs2_checkpt_flush_buffer(s
 	}
 	memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
 
-	yaffs2_checkpt_init_chunk_hdr(dev);
-
-
 	return 1;
 }
 
-int yaffs2_checkpt_wr(struct yaffs_dev *dev, const void *data, int n_bytes)
+
+int yaffs2_checkpt_wr(yaffs_dev_t *dev, const void *data, int n_bytes)
 {
 	int i = 0;
 	int ok = 1;
-	u8 *data_bytes = (u8 *) data;
+
+
+	__u8 * dataBytes = (__u8 *)data;
+
+
 
 	if (!dev->checkpt_buffer)
 		return 0;
@@ -328,31 +255,35 @@ int yaffs2_checkpt_wr(struct yaffs_dev *
 		return -1;
 
 	while (i < n_bytes && ok) {
-		dev->checkpt_buffer[dev->checkpt_byte_offs] = *data_bytes;
-		dev->checkpt_sum += *data_bytes;
-		dev->checkpt_xor ^= *data_bytes;
+		dev->checkpt_buffer[dev->checkpt_byte_offs] = *dataBytes;
+		dev->checkpt_sum += *dataBytes;
+		dev->checkpt_xor ^= *dataBytes;
 
 		dev->checkpt_byte_offs++;
 		i++;
-		data_bytes++;
+		dataBytes++;
 		dev->checkpt_byte_count++;
 
+
 		if (dev->checkpt_byte_offs < 0 ||
-		    dev->checkpt_byte_offs >= dev->data_bytes_per_chunk)
+		   dev->checkpt_byte_offs >= dev->data_bytes_per_chunk)
 			ok = yaffs2_checkpt_flush_buffer(dev);
 	}
 
 	return i;
 }
 
-int yaffs2_checkpt_rd(struct yaffs_dev *dev, void *data, int n_bytes)
+int yaffs2_checkpt_rd(yaffs_dev_t *dev, void *data, int n_bytes)
 {
 	int i = 0;
 	int ok = 1;
-	struct yaffs_ext_tags tags;
+	yaffs_ext_tags tags;
+
+
 	int chunk;
-	int offset_chunk;
-	u8 *data_bytes = (u8 *) data;
+	int realignedChunk;
+
+	__u8 *dataBytes = (__u8 *)data;
 
 	if (!dev->checkpt_buffer)
 		return 0;
@@ -362,113 +293,109 @@ int yaffs2_checkpt_rd(struct yaffs_dev *
 
 	while (i < n_bytes && ok) {
 
+
 		if (dev->checkpt_byte_offs < 0 ||
-		    dev->checkpt_byte_offs >= dev->data_bytes_per_chunk) {
+			dev->checkpt_byte_offs >= dev->data_bytes_per_chunk) {
 
 			if (dev->checkpt_cur_block < 0) {
 				yaffs2_checkpt_find_block(dev);
 				dev->checkpt_cur_chunk = 0;
 			}
 
-			if (dev->checkpt_cur_block < 0) {
+			if (dev->checkpt_cur_block < 0)
 				ok = 0;
-				break;
-			}
+			else {
+				chunk = dev->checkpt_cur_block *
+					dev->param.chunks_per_block +
+					dev->checkpt_cur_chunk;
 
-			chunk = dev->checkpt_cur_block *
-			    dev->param.chunks_per_block +
-			    dev->checkpt_cur_chunk;
+				realignedChunk = chunk - dev->chunk_offset;
+				
+				dev->n_page_reads++;
 
-			offset_chunk = apply_chunk_offset(dev, chunk);
-			dev->n_page_reads++;
-
-			/* read in the next chunk */
-			dev->tagger.read_chunk_tags_fn(dev,
-						offset_chunk,
+				/* read in the next chunk */
+				/* printf("read checkpoint page %d\n",dev->checkpointPage); */
+				dev->param.read_chunk_tags_fn(dev,
+						realignedChunk,
 						dev->checkpt_buffer,
 						&tags);
 
-			if (tags.chunk_id != (dev->checkpt_page_seq + 1) ||
-			    tags.ecc_result > YAFFS_ECC_RESULT_FIXED ||
-			    tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA) {
-				ok = 0;
-				break;
+				if (tags.chunk_id != (dev->checkpt_page_seq + 1) ||
+					tags.ecc_result > YAFFS_ECC_RESULT_FIXED ||
+					tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA)
+					ok = 0;
+
+				dev->checkpt_byte_offs = 0;
+				dev->checkpt_page_seq++;
+				dev->checkpt_cur_chunk++;
+
+				if (dev->checkpt_cur_chunk >= dev->param.chunks_per_block)
+					dev->checkpt_cur_block = -1;
 			}
-			if(!yaffs2_checkpt_check_chunk_hdr(dev)) {
-				ok = 0;
-				break;
-			}
-
-			dev->checkpt_page_seq++;
-			dev->checkpt_cur_chunk++;
-
-			if (dev->checkpt_cur_chunk >=
-					dev->param.chunks_per_block)
-				dev->checkpt_cur_block = -1;
-
 		}
 
-		*data_bytes = dev->checkpt_buffer[dev->checkpt_byte_offs];
-		dev->checkpt_sum += *data_bytes;
-		dev->checkpt_xor ^= *data_bytes;
-		dev->checkpt_byte_offs++;
-		i++;
-		data_bytes++;
-		dev->checkpt_byte_count++;
+		if (ok) {
+			*dataBytes = dev->checkpt_buffer[dev->checkpt_byte_offs];
+			dev->checkpt_sum += *dataBytes;
+			dev->checkpt_xor ^= *dataBytes;
+			dev->checkpt_byte_offs++;
+			i++;
+			dataBytes++;
+			dev->checkpt_byte_count++;
+		}
 	}
 
-	return i;
+	return 	i;
 }
 
-int yaffs_checkpt_close(struct yaffs_dev *dev)
+int yaffs_checkpt_close(yaffs_dev_t *dev)
 {
-	int i;
 
 	if (dev->checkpt_open_write) {
-		if (dev->checkpt_byte_offs !=
-			sizeof(sizeof(struct yaffs_checkpt_chunk_hdr)))
+		if (dev->checkpt_byte_offs != 0)
 			yaffs2_checkpt_flush_buffer(dev);
-	} else if (dev->checkpt_block_list) {
-		for (i = 0;
-		     i < dev->blocks_in_checkpt &&
-		     dev->checkpt_block_list[i] >= 0; i++) {
+	} else if(dev->checkpt_block_list){
+		int i;
+		for (i = 0; i < dev->blocks_in_checkpt && dev->checkpt_block_list[i] >= 0; i++) {
 			int blk = dev->checkpt_block_list[i];
-			struct yaffs_block_info *bi = NULL;
-
-			if (dev->internal_start_block <= blk &&
-			    blk <= dev->internal_end_block)
+			yaffs_block_info_t *bi = NULL;
+			if( dev->internal_start_block <= blk && blk <= dev->internal_end_block)
 				bi = yaffs_get_block_info(dev, blk);
 			if (bi && bi->block_state == YAFFS_BLOCK_STATE_EMPTY)
 				bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+			else {
+				/* Todo this looks odd... */
+			}
 		}
-		kfree(dev->checkpt_block_list);
+		YFREE(dev->checkpt_block_list);
 		dev->checkpt_block_list = NULL;
 	}
 
-	dev->n_free_chunks -=
-		dev->blocks_in_checkpt * dev->param.chunks_per_block;
+	dev->n_free_chunks -= dev->blocks_in_checkpt * dev->param.chunks_per_block;
 	dev->n_erased_blocks -= dev->blocks_in_checkpt;
 
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "checkpoint byte count %d",
-		dev->checkpt_byte_count);
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint byte count %d" TENDSTR),
+			dev->checkpt_byte_count));
 
 	if (dev->checkpt_buffer) {
 		/* free the buffer */
-		kfree(dev->checkpt_buffer);
+		YFREE(dev->checkpt_buffer);
 		dev->checkpt_buffer = NULL;
 		return 1;
-	} else {
+	} else
 		return 0;
-	}
 }
 
-int yaffs2_checkpt_invalidate_stream(struct yaffs_dev *dev)
+int yaffs2_checkpt_invalidate_stream(yaffs_dev_t *dev)
 {
 	/* Erase the checkpoint data */
 
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-		"checkpoint invalidate of %d blocks",
-		dev->blocks_in_checkpt);
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint invalidate of %d blocks"TENDSTR),
+		dev->blocks_in_checkpt));
 
 	return yaffs_checkpt_erase(dev);
 }
+
+
+
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_checkptrw.h b/target/linux/generic/files/fs/yaffs2/yaffs_checkptrw.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_checkptrw.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_checkptrw.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -18,16 +18,17 @@
 
 #include "yaffs_guts.h"
 
-int yaffs2_checkpt_open(struct yaffs_dev *dev, int writing);
+int yaffs2_checkpt_open(yaffs_dev_t *dev, int forWriting);
 
-int yaffs2_checkpt_wr(struct yaffs_dev *dev, const void *data, int n_bytes);
+int yaffs2_checkpt_wr(yaffs_dev_t *dev, const void *data, int n_bytes);
 
-int yaffs2_checkpt_rd(struct yaffs_dev *dev, void *data, int n_bytes);
+int yaffs2_checkpt_rd(yaffs_dev_t *dev, void *data, int n_bytes);
 
-int yaffs2_get_checkpt_sum(struct yaffs_dev *dev, u32 * sum);
+int yaffs2_get_checkpt_sum(yaffs_dev_t *dev, __u32 *sum);
 
-int yaffs_checkpt_close(struct yaffs_dev *dev);
+int yaffs_checkpt_close(yaffs_dev_t *dev);
 
-int yaffs2_checkpt_invalidate_stream(struct yaffs_dev *dev);
+int yaffs2_checkpt_invalidate_stream(yaffs_dev_t *dev);
+
 
 #endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_ecc.c b/target/linux/generic/files/fs/yaffs2/yaffs_ecc.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_ecc.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_ecc.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -16,22 +16,22 @@
  *
  * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
  * The two unused bit are set to 1.
- * The ECC can correct single bit errors in a 256-byte page of data. Thus, two
- * such ECC blocks are used on a 512-byte NAND page.
+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
+ * blocks are used on a 512-byte NAND page.
  *
  */
 
+/* Table generated by gen-ecc.c
+ * Using a table means we do not have to calculate p1..p4 and p1'..p4'
+ * for each byte of data. These are instead provided in a table in bits7..2.
+ * Bit 0 of each entry indicates whether the entry has an odd or even parity, and therefore
+ * this bytes influence on the line parity.
+ */
+
 #include "yportenv.h"
 
 #include "yaffs_ecc.h"
 
-/* Table generated by gen-ecc.c
- * Using a table means we do not have to calculate p1..p4 and p1'..p4'
- * for each byte of data. These are instead provided in a table in bits7..2.
- * Bit 0 of each entry indicates whether the entry has an odd or even parity,
- * and therefore this bytes influence on the line parity.
- */
-
 static const unsigned char column_parity_table[] = {
 	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
 	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
@@ -67,11 +67,35 @@ static const unsigned char column_parity
 	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
 };
 
+/* Count the bits in an unsigned char or a U32 */
+
+static int yaffs_count_bits(unsigned char x)
+{
+	int r = 0;
+	while (x) {
+		if (x & 1)
+			r++;
+		x >>= 1;
+	}
+	return r;
+}
+
+static int yaffs_count_bits32(unsigned x)
+{
+	int r = 0;
+	while (x) {
+		if (x & 1)
+			r++;
+		x >>= 1;
+	}
+	return r;
+}
 
 /* Calculate the ECC for a 256-byte block of data */
-void yaffs_ecc_calc(const unsigned char *data, unsigned char *ecc)
+void yaffs_ecc_cacl(const unsigned char *data, unsigned char *ecc)
 {
 	unsigned int i;
+
 	unsigned char col_parity = 0;
 	unsigned char line_parity = 0;
 	unsigned char line_parity_prime = 0;
@@ -82,7 +106,7 @@ void yaffs_ecc_calc(const unsigned char 
 		b = column_parity_table[*data++];
 		col_parity ^= b;
 
-		if (b & 0x01) {	/* odd number of bits in the byte */
+		if (b & 0x01) {		/* odd number of bits in the byte */
 			line_parity ^= i;
 			line_parity_prime ^= ~i;
 		}
@@ -128,12 +152,19 @@ void yaffs_ecc_calc(const unsigned char 
 		t |= 0x01;
 	ecc[0] = ~t;
 
+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
+	/* Swap the bytes into the wrong order */
+	t = ecc[0];
+	ecc[0] = ecc[1];
+	ecc[1] = t;
+#endif
 }
 
+
 /* Correct the ECC on a 256 byte block of data */
 
 int yaffs_ecc_correct(unsigned char *data, unsigned char *read_ecc,
-		      const unsigned char *test_ecc)
+		     const unsigned char *test_ecc)
 {
 	unsigned char d0, d1, d2;	/* deltas */
 
@@ -142,7 +173,7 @@ int yaffs_ecc_correct(unsigned char *dat
 	d2 = read_ecc[2] ^ test_ecc[2];
 
 	if ((d0 | d1 | d2) == 0)
-		return 0;	/* no error */
+		return 0; /* no error */
 
 	if (((d0 ^ (d0 >> 1)) & 0x55) == 0x55 &&
 	    ((d1 ^ (d1 >> 1)) & 0x55) == 0x55 &&
@@ -152,6 +183,15 @@ int yaffs_ecc_correct(unsigned char *dat
 		unsigned byte;
 		unsigned bit;
 
+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
+		/* swap the bytes to correct for the wrong order */
+		unsigned char t;
+
+		t = d0;
+		d0 = d1;
+		d1 = t;
+#endif
+
 		bit = byte = 0;
 
 		if (d1 & 0x80)
@@ -180,17 +220,19 @@ int yaffs_ecc_correct(unsigned char *dat
 
 		data[byte] ^= (1 << bit);
 
-		return 1;	/* Corrected the error */
+		return 1; /* Corrected the error */
 	}
 
-	if ((hweight8(d0) + hweight8(d1) + hweight8(d2)) == 1) {
+	if ((yaffs_count_bits(d0) +
+	     yaffs_count_bits(d1) +
+	     yaffs_count_bits(d2)) ==  1) {
 		/* Reccoverable error in ecc */
 
 		read_ecc[0] = test_ecc[0];
 		read_ecc[1] = test_ecc[1];
 		read_ecc[2] = test_ecc[2];
 
-		return 1;	/* Corrected the error */
+		return 1; /* Corrected the error */
 	}
 
 	/* Unrecoverable error */
@@ -199,13 +241,15 @@ int yaffs_ecc_correct(unsigned char *dat
 
 }
 
+
 /*
  * ECCxxxOther does ECC calcs on arbitrary n bytes of data
  */
 void yaffs_ecc_calc_other(const unsigned char *data, unsigned n_bytes,
-			  struct yaffs_ecc_other *ecc_other)
+				yaffs_ECCOther *eccOther)
 {
 	unsigned int i;
+
 	unsigned char col_parity = 0;
 	unsigned line_parity = 0;
 	unsigned line_parity_prime = 0;
@@ -215,7 +259,7 @@ void yaffs_ecc_calc_other(const unsigned
 		b = column_parity_table[*data++];
 		col_parity ^= b;
 
-		if (b & 0x01) {
+		if (b & 0x01)	 {
 			/* odd number of bits in the byte */
 			line_parity ^= i;
 			line_parity_prime ^= ~i;
@@ -223,56 +267,54 @@ void yaffs_ecc_calc_other(const unsigned
 
 	}
 
-	ecc_other->col_parity = (col_parity >> 2) & 0x3f;
-	ecc_other->line_parity = line_parity;
-	ecc_other->line_parity_prime = line_parity_prime;
+	eccOther->colParity = (col_parity >> 2) & 0x3f;
+	eccOther->lineParity = line_parity;
+	eccOther->lineParityPrime = line_parity_prime;
 }
 
 int yaffs_ecc_correct_other(unsigned char *data, unsigned n_bytes,
-			    struct yaffs_ecc_other *read_ecc,
-			    const struct yaffs_ecc_other *test_ecc)
+			yaffs_ECCOther *read_ecc,
+			const yaffs_ECCOther *test_ecc)
 {
-	unsigned char delta_col;	/* column parity delta */
-	unsigned delta_line;	/* line parity delta */
-	unsigned delta_line_prime;	/* line parity delta */
+	unsigned char cDelta;	/* column parity delta */
+	unsigned lDelta;	/* line parity delta */
+	unsigned lDeltaPrime;	/* line parity delta */
 	unsigned bit;
 
-	delta_col = read_ecc->col_parity ^ test_ecc->col_parity;
-	delta_line = read_ecc->line_parity ^ test_ecc->line_parity;
-	delta_line_prime =
-	    read_ecc->line_parity_prime ^ test_ecc->line_parity_prime;
+	cDelta = read_ecc->colParity ^ test_ecc->colParity;
+	lDelta = read_ecc->lineParity ^ test_ecc->lineParity;
+	lDeltaPrime = read_ecc->lineParityPrime ^ test_ecc->lineParityPrime;
 
-	if ((delta_col | delta_line | delta_line_prime) == 0)
-		return 0;	/* no error */
+	if ((cDelta | lDelta | lDeltaPrime) == 0)
+		return 0; /* no error */
 
-	if (delta_line == ~delta_line_prime &&
-	    (((delta_col ^ (delta_col >> 1)) & 0x15) == 0x15)) {
+	if (lDelta == ~lDeltaPrime &&
+	    (((cDelta ^ (cDelta >> 1)) & 0x15) == 0x15)) {
 		/* Single bit (recoverable) error in data */
 
 		bit = 0;
 
-		if (delta_col & 0x20)
+		if (cDelta & 0x20)
 			bit |= 0x04;
-		if (delta_col & 0x08)
+		if (cDelta & 0x08)
 			bit |= 0x02;
-		if (delta_col & 0x02)
+		if (cDelta & 0x02)
 			bit |= 0x01;
 
-		if (delta_line >= n_bytes)
+		if (lDelta >= n_bytes)
 			return -1;
 
-		data[delta_line] ^= (1 << bit);
+		data[lDelta] ^= (1 << bit);
 
-		return 1;	/* corrected */
+		return 1; /* corrected */
 	}
 
-	if ((hweight32(delta_line) +
-	     hweight32(delta_line_prime) +
-	     hweight8(delta_col)) == 1) {
+	if ((yaffs_count_bits32(lDelta) + yaffs_count_bits32(lDeltaPrime) +
+			yaffs_count_bits(cDelta)) == 1) {
 		/* Reccoverable error in ecc */
 
 		*read_ecc = *test_ecc;
-		return 1;	/* corrected */
+		return 1; /* corrected */
 	}
 
 	/* Unrecoverable error */
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_ecc.h b/target/linux/generic/files/fs/yaffs2/yaffs_ecc.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_ecc.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_ecc.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -18,27 +18,27 @@
  *
  * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
  * The two unused bit are set to 1.
- * The ECC can correct single bit errors in a 256-byte page of data.
- * Thus, two such ECC blocks are used on a 512-byte NAND page.
+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
+ * blocks are used on a 512-byte NAND page.
  *
  */
 
 #ifndef __YAFFS_ECC_H__
 #define __YAFFS_ECC_H__
 
-struct yaffs_ecc_other {
-	unsigned char col_parity;
-	unsigned line_parity;
-	unsigned line_parity_prime;
-};
+typedef struct {
+	unsigned char colParity;
+	unsigned lineParity;
+	unsigned lineParityPrime;
+} yaffs_ECCOther;
 
-void yaffs_ecc_calc(const unsigned char *data, unsigned char *ecc);
+void yaffs_ecc_cacl(const unsigned char *data, unsigned char *ecc);
 int yaffs_ecc_correct(unsigned char *data, unsigned char *read_ecc,
-		      const unsigned char *test_ecc);
+		const unsigned char *test_ecc);
 
 void yaffs_ecc_calc_other(const unsigned char *data, unsigned n_bytes,
-			  struct yaffs_ecc_other *ecc);
+			yaffs_ECCOther *ecc);
 int yaffs_ecc_correct_other(unsigned char *data, unsigned n_bytes,
-			    struct yaffs_ecc_other *read_ecc,
-			    const struct yaffs_ecc_other *test_ecc);
+			yaffs_ECCOther *read_ecc,
+			const yaffs_ECCOther *test_ecc);
 #endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_getblockinfo.h b/target/linux/generic/files/fs/yaffs2/yaffs_getblockinfo.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_getblockinfo.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_getblockinfo.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -20,14 +20,14 @@
 #include "yaffs_trace.h"
 
 /* Function to manipulate block info */
-static inline struct yaffs_block_info *yaffs_get_block_info(struct yaffs_dev
-							      *dev, int blk)
+static Y_INLINE yaffs_block_info_t *yaffs_get_block_info(yaffs_dev_t * dev, int blk)
 {
 	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"**>> yaffs: get_block_info block %d is not valid",
-			blk);
-		BUG();
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR
+		   ("**>> yaffs: getBlockInfo block %d is not valid" TENDSTR),
+		   blk));
+		YBUG();
 	}
 	return &dev->block_info[blk - dev->internal_start_block];
 }
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_guts.c b/target/linux/generic/files/fs/yaffs2/yaffs_guts.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_guts.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_guts.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -10,25 +10,28 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-
 #include "yportenv.h"
 #include "yaffs_trace.h"
 
+#include "yaffsinterface.h"
 #include "yaffs_guts.h"
+#include "yaffs_tagsvalidity.h"
 #include "yaffs_getblockinfo.h"
+
 #include "yaffs_tagscompat.h"
-#include "yaffs_tagsmarshall.h"
+
 #include "yaffs_nand.h"
+
 #include "yaffs_yaffs1.h"
 #include "yaffs_yaffs2.h"
 #include "yaffs_bitmap.h"
 #include "yaffs_verify.h"
+
 #include "yaffs_nand.h"
 #include "yaffs_packedtags2.h"
+
 #include "yaffs_nameval.h"
 #include "yaffs_allocator.h"
-#include "yaffs_attribs.h"
-#include "yaffs_summary.h"
 
 /* Note YAFFS_GC_GOOD_ENOUGH must be <= YAFFS_GC_PASSIVE_THRESHOLD */
 #define YAFFS_GC_GOOD_ENOUGH 2
@@ -36,40 +39,94 @@
 
 #include "yaffs_ecc.h"
 
-/* Forward declarations */
-
-static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
-			     const u8 *buffer, int n_bytes, int use_reserve);
-
-static void yaffs_fix_null_name(struct yaffs_obj *obj, YCHAR *name,
-				int buffer_size);
+
+
+/* Robustification (if it ever comes about...) */
+static void yaffs_retire_block(yaffs_dev_t *dev, int flash_block);
+static void yaffs_handle_chunk_wr_error(yaffs_dev_t *dev, int nand_chunk,
+		int erasedOk);
+static void yaffs_handle_chunk_wr_ok(yaffs_dev_t *dev, int nand_chunk,
+				const __u8 *data,
+				const yaffs_ext_tags *tags);
+static void yaffs_handle_chunk_update(yaffs_dev_t *dev, int nand_chunk,
+				const yaffs_ext_tags *tags);
+
+/* Other local prototypes */
+static void yaffs_update_parent(yaffs_obj_t *obj);
+static int yaffs_unlink_obj(yaffs_obj_t *obj);
+static int yaffs_obj_cache_dirty(yaffs_obj_t *obj);
+
+static int yaffs_write_new_chunk(yaffs_dev_t *dev,
+					const __u8 *buffer,
+					yaffs_ext_tags *tags,
+					int useReserve);
+
+
+static yaffs_obj_t *yaffs_new_obj(yaffs_dev_t *dev, int number,
+					yaffs_obj_type type);
+
+
+static int yaffs_apply_xattrib_mod(yaffs_obj_t *obj, char *buffer, yaffs_xattr_mod *xmod);
+
+static void yaffs_remove_obj_from_dir(yaffs_obj_t *obj);
+static int yaffs_check_structures(void);
+static int yaffs_generic_obj_del(yaffs_obj_t *in);
+
+static int yaffs_check_chunk_erased(struct yaffs_dev_s *dev,
+				int nand_chunk);
+
+static int yaffs_unlink_worker(yaffs_obj_t *obj);
+
+static int yaffs_tags_match(const yaffs_ext_tags *tags, int obj_id,
+			int chunkInObject);
+
+static int yaffs_alloc_chunk(yaffs_dev_t *dev, int useReserve,
+				yaffs_block_info_t **blockUsedPtr);
+
+static void yaffs_check_obj_details_loaded(yaffs_obj_t *in);
+
+static void yaffs_invalidate_whole_cache(yaffs_obj_t *in);
+static void yaffs_invalidate_chunk_cache(yaffs_obj_t *object, int chunk_id);
+
+static int yaffs_find_chunk_in_file(yaffs_obj_t *in, int inode_chunk,
+				yaffs_ext_tags *tags);
+
+static int yaffs_verify_chunk_written(yaffs_dev_t *dev,
+					int nand_chunk,
+					const __u8 *data,
+					yaffs_ext_tags *tags);
+
+
+static void yaffs_load_name_from_oh(yaffs_dev_t *dev,YCHAR *name, const YCHAR *ohName, int bufferSize);
+static void yaffs_load_oh_from_name(yaffs_dev_t *dev,YCHAR *ohName, const YCHAR *name);
+
 
 /* Function to calculate chunk and offset */
 
-void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
-				int *chunk_out, u32 *offset_out)
+static void yaffs_addr_to_chunk(yaffs_dev_t *dev, loff_t addr, int *chunkOut,
+		__u32 *offsetOut)
 {
 	int chunk;
-	u32 offset;
-
-	chunk = (u32) (addr >> dev->chunk_shift);
+	__u32 offset;
+
+	chunk  = (__u32)(addr >> dev->chunk_shift);
 
 	if (dev->chunk_div == 1) {
 		/* easy power of 2 case */
-		offset = (u32) (addr & dev->chunk_mask);
+		offset = (__u32)(addr & dev->chunk_mask);
 	} else {
 		/* Non power-of-2 case */
 
-		loff_t chunk_base;
+		loff_t chunkBase;
 
 		chunk /= dev->chunk_div;
 
-		chunk_base = ((loff_t) chunk) * dev->data_bytes_per_chunk;
-		offset = (u32) (addr - chunk_base);
+		chunkBase = ((loff_t)chunk) * dev->data_bytes_per_chunk;
+		offset = (__u32)(addr - chunkBase);
 	}
 
-	*chunk_out = chunk;
-	*offset_out = offset;
+	*chunkOut = chunk;
+	*offsetOut = offset;
 }
 
 /* Function to return the number of shifts for a power of 2 greater than or
@@ -78,93 +135,110 @@ void yaffs_addr_to_chunk(struct yaffs_de
  * be hellishly efficient.
  */
 
-static inline u32 calc_shifts_ceiling(u32 x)
+static __u32 ShiftsGE(__u32 x)
 {
-	int extra_bits;
-	int shifts;
-
-	shifts = extra_bits = 0;
+	int extraBits;
+	int nShifts;
+
+	nShifts = extraBits = 0;
 
 	while (x > 1) {
 		if (x & 1)
-			extra_bits++;
+			extraBits++;
 		x >>= 1;
-		shifts++;
+		nShifts++;
 	}
 
-	if (extra_bits)
-		shifts++;
-
-	return shifts;
+	if (extraBits)
+		nShifts++;
+
+	return nShifts;
 }
 
 /* Function to return the number of shifts to get a 1 in bit 0
  */
 
-static inline u32 calc_shifts(u32 x)
+static __u32 Shifts(__u32 x)
 {
-	u32 shifts;
-
-	shifts = 0;
+	__u32 nShifts;
+
+	nShifts =  0;
 
 	if (!x)
 		return 0;
 
-	while (!(x & 1)) {
+	while (!(x&1)) {
 		x >>= 1;
-		shifts++;
+		nShifts++;
 	}
 
-	return shifts;
+	return nShifts;
 }
 
+
+
 /*
  * Temporary buffer manipulations.
  */
 
-static int yaffs_init_tmp_buffers(struct yaffs_dev *dev)
+static int yaffs_init_tmp_buffers(yaffs_dev_t *dev)
 {
 	int i;
-	u8 *buf = (u8 *) 1;
+	__u8 *buf = (__u8 *)1;
 
 	memset(dev->temp_buffer, 0, sizeof(dev->temp_buffer));
 
 	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
-		dev->temp_buffer[i].in_use = 0;
-		buf = kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
-		dev->temp_buffer[i].buffer = buf;
+		dev->temp_buffer[i].line = 0;	/* not in use */
+		dev->temp_buffer[i].buffer = buf =
+		    YMALLOC_DMA(dev->param.total_bytes_per_chunk);
 	}
 
 	return buf ? YAFFS_OK : YAFFS_FAIL;
 }
 
-u8 *yaffs_get_temp_buffer(struct yaffs_dev * dev)
+__u8 *yaffs_get_temp_buffer(yaffs_dev_t *dev, int line_no)
 {
-	int i;
+	int i, j;
 
 	dev->temp_in_use++;
 	if (dev->temp_in_use > dev->max_temp)
 		dev->max_temp = dev->temp_in_use;
 
 	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
-		if (dev->temp_buffer[i].in_use == 0) {
-			dev->temp_buffer[i].in_use = 1;
+		if (dev->temp_buffer[i].line == 0) {
+			dev->temp_buffer[i].line = line_no;
+			if ((i + 1) > dev->max_temp) {
+				dev->max_temp = i + 1;
+				for (j = 0; j <= i; j++)
+					dev->temp_buffer[j].max_line =
+					    dev->temp_buffer[j].line;
+			}
+
 			return dev->temp_buffer[i].buffer;
 		}
 	}
 
-	yaffs_trace(YAFFS_TRACE_BUFFERS, "Out of temp buffers");
+	T(YAFFS_TRACE_BUFFERS,
+	  (TSTR("Out of temp buffers at line %d, other held by lines:"),
+	   line_no));
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
+		T(YAFFS_TRACE_BUFFERS, (TSTR(" %d "), dev->temp_buffer[i].line));
+
+	T(YAFFS_TRACE_BUFFERS, (TSTR(" " TENDSTR)));
+
 	/*
 	 * If we got here then we have to allocate an unmanaged one
 	 * This is not good.
 	 */
 
 	dev->unmanaged_buffer_allocs++;
-	return kmalloc(dev->data_bytes_per_chunk, GFP_NOFS);
+	return YMALLOC(dev->data_bytes_per_chunk);
 
 }
 
-void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer)
+void yaffs_release_temp_buffer(yaffs_dev_t *dev, __u8 *buffer,
+				    int line_no)
 {
 	int i;
 
@@ -172,94 +246,61 @@ void yaffs_release_temp_buffer(struct ya
 
 	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
 		if (dev->temp_buffer[i].buffer == buffer) {
-			dev->temp_buffer[i].in_use = 0;
+			dev->temp_buffer[i].line = 0;
 			return;
 		}
 	}
 
 	if (buffer) {
 		/* assume it is an unmanaged one. */
-		yaffs_trace(YAFFS_TRACE_BUFFERS,
-			"Releasing unmanaged temp buffer");
-		kfree(buffer);
+		T(YAFFS_TRACE_BUFFERS,
+		  (TSTR("Releasing unmanaged temp buffer in line %d" TENDSTR),
+		   line_no));
+		YFREE(buffer);
 		dev->unmanaged_buffer_deallocs++;
 	}
 
 }
 
 /*
- * Functions for robustisizing TODO
- *
+ * Determine if we have a managed buffer.
  */
-
-static void yaffs_handle_chunk_wr_ok(struct yaffs_dev *dev, int nand_chunk,
-				     const u8 *data,
-				     const struct yaffs_ext_tags *tags)
+int yaffs_is_managed_tmp_buffer(yaffs_dev_t *dev, const __u8 *buffer)
 {
-	(void) dev;
-	(void) nand_chunk;
-	(void) data;
-	(void) tags;
-}
-
-static void yaffs_handle_chunk_update(struct yaffs_dev *dev, int nand_chunk,
-				      const struct yaffs_ext_tags *tags)
-{
-	(void) dev;
-	(void) nand_chunk;
-	(void) tags;
-}
-
-void yaffs_handle_chunk_error(struct yaffs_dev *dev,
-			      struct yaffs_block_info *bi)
-{
-	if (!bi->gc_prioritise) {
-		bi->gc_prioritise = 1;
-		dev->has_pending_prioritised_gc = 1;
-		bi->chunk_error_strikes++;
-
-		if (bi->chunk_error_strikes > 3) {
-			bi->needs_retiring = 1;	/* Too many stikes, so retire */
-			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"yaffs: Block struck out");
-
-		}
+	int i;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->temp_buffer[i].buffer == buffer)
+			return 1;
 	}
-}
-
-static void yaffs_handle_chunk_wr_error(struct yaffs_dev *dev, int nand_chunk,
-					int erased_ok)
-{
-	int flash_block = nand_chunk / dev->param.chunks_per_block;
-	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
-
-	yaffs_handle_chunk_error(dev, bi);
-
-	if (erased_ok) {
-		/* Was an actual write failure,
-		 * so mark the block for retirement.*/
-		bi->needs_retiring = 1;
-		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
-		  "**>> Block %d needs retiring", flash_block);
+
+	for (i = 0; i < dev->param.n_caches; i++) {
+		if (dev->cache[i].data == buffer)
+			return 1;
 	}
 
-	/* Delete the chunk */
-	yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
-	yaffs_skip_rest_of_block(dev);
+	if (buffer == dev->checkpt_buffer)
+		return 1;
+
+	T(YAFFS_TRACE_ALWAYS,
+		(TSTR("yaffs: unmaged buffer detected.\n" TENDSTR)));
+	return 0;
 }
 
 /*
  * Verification code
  */
 
+
+
+
 /*
  *  Simple hash function. Needs to have a reasonable spread
  */
 
-static inline int yaffs_hash_fn(int n)
+static Y_INLINE int yaffs_hash_fn(int n)
 {
-	if (n < 0)
-		n = -n;
+	n = abs(n);
 	return n % YAFFS_NOBJECT_BUCKETS;
 }
 
@@ -268,36 +309,38 @@ static inline int yaffs_hash_fn(int n)
  * Note that root might have a presence in NAND if permissions are set.
  */
 
-struct yaffs_obj *yaffs_root(struct yaffs_dev *dev)
+yaffs_obj_t *yaffs_root(yaffs_dev_t *dev)
 {
 	return dev->root_dir;
 }
 
-struct yaffs_obj *yaffs_lost_n_found(struct yaffs_dev *dev)
+yaffs_obj_t *yaffs_lost_n_found(yaffs_dev_t *dev)
 {
 	return dev->lost_n_found;
 }
 
+
 /*
  *  Erased NAND checking functions
  */
 
-int yaffs_check_ff(u8 *buffer, int n_bytes)
+int yaffs_check_ff(__u8 *buffer, int n_bytes)
 {
 	/* Horrible, slow implementation */
 	while (n_bytes--) {
-		if (*buffer != 0xff)
+		if (*buffer != 0xFF)
 			return 0;
 		buffer++;
 	}
 	return 1;
 }
 
-static int yaffs_check_chunk_erased(struct yaffs_dev *dev, int nand_chunk)
+static int yaffs_check_chunk_erased(struct yaffs_dev_s *dev,
+				int nand_chunk)
 {
 	int retval = YAFFS_OK;
-	u8 *data = yaffs_get_temp_buffer(dev);
-	struct yaffs_ext_tags tags;
+	__u8 *data = yaffs_get_temp_buffer(dev, __LINE__);
+	yaffs_ext_tags tags;
 	int result;
 
 	result = yaffs_rd_chunk_tags_nand(dev, nand_chunk, data, &tags);
@@ -305,199 +348,57 @@ static int yaffs_check_chunk_erased(stru
 	if (tags.ecc_result > YAFFS_ECC_RESULT_NO_ERROR)
 		retval = YAFFS_FAIL;
 
-	if (!yaffs_check_ff(data, dev->data_bytes_per_chunk) ||
-		tags.chunk_used) {
-		yaffs_trace(YAFFS_TRACE_NANDACCESS,
-			"Chunk %d not erased", nand_chunk);
+	if (!yaffs_check_ff(data, dev->data_bytes_per_chunk) || tags.chunk_used) {
+		T(YAFFS_TRACE_NANDACCESS,
+		  (TSTR("Chunk %d not erased" TENDSTR), nand_chunk));
 		retval = YAFFS_FAIL;
 	}
 
-	yaffs_release_temp_buffer(dev, data);
+	yaffs_release_temp_buffer(dev, data, __LINE__);
 
 	return retval;
 
 }
 
-static int yaffs_verify_chunk_written(struct yaffs_dev *dev,
-				      int nand_chunk,
-				      const u8 *data,
-				      struct yaffs_ext_tags *tags)
+
+static int yaffs_verify_chunk_written(yaffs_dev_t *dev,
+					int nand_chunk,
+					const __u8 *data,
+					yaffs_ext_tags *tags)
 {
 	int retval = YAFFS_OK;
-	struct yaffs_ext_tags temp_tags;
-	u8 *buffer = yaffs_get_temp_buffer(dev);
+	yaffs_ext_tags tempTags;
+	__u8 *buffer = yaffs_get_temp_buffer(dev,__LINE__);
 	int result;
-
-	result = yaffs_rd_chunk_tags_nand(dev, nand_chunk, buffer, &temp_tags);
-	if (memcmp(buffer, data, dev->data_bytes_per_chunk) ||
-	    temp_tags.obj_id != tags->obj_id ||
-	    temp_tags.chunk_id != tags->chunk_id ||
-	    temp_tags.n_bytes != tags->n_bytes)
+	
+	result = yaffs_rd_chunk_tags_nand(dev,nand_chunk,buffer,&tempTags);
+	if(memcmp(buffer,data,dev->data_bytes_per_chunk) ||
+		tempTags.obj_id != tags->obj_id ||
+		tempTags.chunk_id  != tags->chunk_id ||
+		tempTags.n_bytes != tags->n_bytes)
 		retval = YAFFS_FAIL;
 
-	yaffs_release_temp_buffer(dev, buffer);
+	yaffs_release_temp_buffer(dev, buffer, __LINE__);
 
 	return retval;
 }
 
-
-int yaffs_check_alloc_available(struct yaffs_dev *dev, int n_chunks)
-{
-	int reserved_chunks;
-	int reserved_blocks = dev->param.n_reserved_blocks;
-	int checkpt_blocks;
-
-	checkpt_blocks = yaffs_calc_checkpt_blocks_required(dev);
-
-	reserved_chunks =
-	    (reserved_blocks + checkpt_blocks) * dev->param.chunks_per_block;
-
-	return (dev->n_free_chunks > (reserved_chunks + n_chunks));
-}
-
-static int yaffs_find_alloc_block(struct yaffs_dev *dev)
-{
-	int i;
-	struct yaffs_block_info *bi;
-
-	if (dev->n_erased_blocks < 1) {
-		/* Hoosterman we've got a problem.
-		 * Can't get space to gc
-		 */
-		yaffs_trace(YAFFS_TRACE_ERROR,
-		  "yaffs tragedy: no more erased blocks");
-
-		return -1;
-	}
-
-	/* Find an empty block. */
-
-	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
-		dev->alloc_block_finder++;
-		if (dev->alloc_block_finder < dev->internal_start_block
-		    || dev->alloc_block_finder > dev->internal_end_block) {
-			dev->alloc_block_finder = dev->internal_start_block;
-		}
-
-		bi = yaffs_get_block_info(dev, dev->alloc_block_finder);
-
-		if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
-			bi->block_state = YAFFS_BLOCK_STATE_ALLOCATING;
-			dev->seq_number++;
-			bi->seq_number = dev->seq_number;
-			dev->n_erased_blocks--;
-			yaffs_trace(YAFFS_TRACE_ALLOCATE,
-			  "Allocated block %d, seq  %d, %d left" ,
-			   dev->alloc_block_finder, dev->seq_number,
-			   dev->n_erased_blocks);
-			return dev->alloc_block_finder;
-		}
-	}
-
-	yaffs_trace(YAFFS_TRACE_ALWAYS,
-		"yaffs tragedy: no more erased blocks, but there should have been %d",
-		dev->n_erased_blocks);
-
-	return -1;
-}
-
-static int yaffs_alloc_chunk(struct yaffs_dev *dev, int use_reserver,
-			     struct yaffs_block_info **block_ptr)
-{
-	int ret_val;
-	struct yaffs_block_info *bi;
-
-	if (dev->alloc_block < 0) {
-		/* Get next block to allocate off */
-		dev->alloc_block = yaffs_find_alloc_block(dev);
-		dev->alloc_page = 0;
-	}
-
-	if (!use_reserver && !yaffs_check_alloc_available(dev, 1)) {
-		/* No space unless we're allowed to use the reserve. */
-		return -1;
-	}
-
-	if (dev->n_erased_blocks < dev->param.n_reserved_blocks
-	    && dev->alloc_page == 0)
-		yaffs_trace(YAFFS_TRACE_ALLOCATE, "Allocating reserve");
-
-	/* Next page please.... */
-	if (dev->alloc_block >= 0) {
-		bi = yaffs_get_block_info(dev, dev->alloc_block);
-
-		ret_val = (dev->alloc_block * dev->param.chunks_per_block) +
-		    dev->alloc_page;
-		bi->pages_in_use++;
-		yaffs_set_chunk_bit(dev, dev->alloc_block, dev->alloc_page);
-
-		dev->alloc_page++;
-
-		dev->n_free_chunks--;
-
-		/* If the block is full set the state to full */
-		if (dev->alloc_page >= dev->param.chunks_per_block) {
-			bi->block_state = YAFFS_BLOCK_STATE_FULL;
-			dev->alloc_block = -1;
-		}
-
-		if (block_ptr)
-			*block_ptr = bi;
-
-		return ret_val;
-	}
-
-	yaffs_trace(YAFFS_TRACE_ERROR,
-		"!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!");
-
-	return -1;
-}
-
-static int yaffs_get_erased_chunks(struct yaffs_dev *dev)
-{
-	int n;
-
-	n = dev->n_erased_blocks * dev->param.chunks_per_block;
-
-	if (dev->alloc_block > 0)
-		n += (dev->param.chunks_per_block - dev->alloc_page);
-
-	return n;
-
-}
-
-/*
- * yaffs_skip_rest_of_block() skips over the rest of the allocation block
- * if we don't want to write to it.
- */
-void yaffs_skip_rest_of_block(struct yaffs_dev *dev)
-{
-	struct yaffs_block_info *bi;
-
-	if (dev->alloc_block > 0) {
-		bi = yaffs_get_block_info(dev, dev->alloc_block);
-		if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
-			bi->block_state = YAFFS_BLOCK_STATE_FULL;
-			dev->alloc_block = -1;
-		}
-	}
-}
-
-static int yaffs_write_new_chunk(struct yaffs_dev *dev,
-				 const u8 *data,
-				 struct yaffs_ext_tags *tags, int use_reserver)
+static int yaffs_write_new_chunk(struct yaffs_dev_s *dev,
+					const __u8 *data,
+					yaffs_ext_tags *tags,
+					int useReserve)
 {
 	int attempts = 0;
-	int write_ok = 0;
+	int writeOk = 0;
 	int chunk;
 
 	yaffs2_checkpt_invalidate(dev);
 
 	do {
-		struct yaffs_block_info *bi = 0;
-		int erased_ok = 0;
-
-		chunk = yaffs_alloc_chunk(dev, use_reserver, &bi);
+		yaffs_block_info_t *bi = 0;
+		int erasedOk = 0;
+
+		chunk = yaffs_alloc_chunk(dev, useReserve, &bi);
 		if (chunk < 0) {
 			/* no space */
 			break;
@@ -509,7 +410,7 @@ static int yaffs_write_new_chunk(struct 
 		 *
 		 * Check the first page we try to write in a block.
 		 * If the check passes then we don't need to check any
-		 * more.        If the check fails, we check again...
+		 * more.	If the check fails, we check again...
 		 * If the block has been erased, we don't need to check.
 		 *
 		 * However, if the block has been prioritised for gc,
@@ -523,42 +424,42 @@ static int yaffs_write_new_chunk(struct 
 		 * lot of checks that are most likely not needed.
 		 *
 		 * Mods to the above
-		 * If an erase check fails or the write fails we skip the
+		 * If an erase check fails or the write fails we skip the 
 		 * rest of the block.
 		 */
 
 		/* let's give it a try */
 		attempts++;
 
-		if (dev->param.always_check_erased)
+		if(dev->param.always_check_erased)
 			bi->skip_erased_check = 0;
 
 		if (!bi->skip_erased_check) {
-			erased_ok = yaffs_check_chunk_erased(dev, chunk);
-			if (erased_ok != YAFFS_OK) {
-				yaffs_trace(YAFFS_TRACE_ERROR,
-				  "**>> yaffs chunk %d was not erased",
-				  chunk);
+			erasedOk = yaffs_check_chunk_erased(dev, chunk);
+			if (erasedOk != YAFFS_OK) {
+				T(YAFFS_TRACE_ERROR,
+				(TSTR("**>> yaffs chunk %d was not erased"
+				TENDSTR), chunk));
 
 				/* If not erased, delete this one,
 				 * skip rest of block and
 				 * try another chunk */
-				yaffs_chunk_del(dev, chunk, 1, __LINE__);
-				yaffs_skip_rest_of_block(dev);
+				 yaffs_chunk_del(dev,chunk,1,__LINE__);
+				 yaffs_skip_rest_of_block(dev);
 				continue;
 			}
 		}
 
-		write_ok = yaffs_wr_chunk_tags_nand(dev, chunk, data, tags);
-
-		if (!bi->skip_erased_check)
-			write_ok =
-			    yaffs_verify_chunk_written(dev, chunk, data, tags);
-
-		if (write_ok != YAFFS_OK) {
+		writeOk = yaffs_wr_chunk_tags_nand(dev, chunk,
+				data, tags);
+
+		if(!bi->skip_erased_check)
+			writeOk = yaffs_verify_chunk_written(dev, chunk, data, tags);
+
+		if (writeOk != YAFFS_OK) {
 			/* Clean up aborted write, skip to next block and
 			 * try another chunk */
-			yaffs_handle_chunk_wr_error(dev, chunk, erased_ok);
+			yaffs_handle_chunk_wr_error(dev, chunk, erasedOk);
 			continue;
 		}
 
@@ -567,58 +468,58 @@ static int yaffs_write_new_chunk(struct 
 		/* Copy the data into the robustification buffer */
 		yaffs_handle_chunk_wr_ok(dev, chunk, data, tags);
 
-	} while (write_ok != YAFFS_OK &&
-		 (yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
-
-	if (!write_ok)
+	} while (writeOk != YAFFS_OK &&
+		(yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
+
+	if (!writeOk)
 		chunk = -1;
 
 	if (attempts > 1) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"**>> yaffs write required %d attempts",
-			attempts);
-		dev->n_retried_writes += (attempts - 1);
+		T(YAFFS_TRACE_ERROR,
+			(TSTR("**>> yaffs write required %d attempts" TENDSTR),
+			attempts));
+
+		dev->n_retired_writes += (attempts - 1);
 	}
 
 	return chunk;
 }
 
+
+ 
 /*
  * Block retiring for handling a broken block.
  */
 
-static void yaffs_retire_block(struct yaffs_dev *dev, int flash_block)
+static void yaffs_retire_block(yaffs_dev_t *dev, int flash_block)
 {
-	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
+	yaffs_block_info_t *bi = yaffs_get_block_info(dev, flash_block);
 
 	yaffs2_checkpt_invalidate(dev);
-
-	yaffs2_clear_oldest_dirty_seq(dev, bi);
+	
+	yaffs2_clear_oldest_dirty_seq(dev,bi);
 
 	if (yaffs_mark_bad(dev, flash_block) != YAFFS_OK) {
 		if (yaffs_erase_block(dev, flash_block) != YAFFS_OK) {
-			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"yaffs: Failed to mark bad and erase block %d",
-				flash_block);
+			T(YAFFS_TRACE_ALWAYS, (TSTR(
+				"yaffs: Failed to mark bad and erase block %d"
+				TENDSTR), flash_block));
 		} else {
-			struct yaffs_ext_tags tags;
-			int chunk_id =
-			    flash_block * dev->param.chunks_per_block;
-
-			u8 *buffer = yaffs_get_temp_buffer(dev);
+			yaffs_ext_tags tags;
+			int chunk_id = flash_block * dev->param.chunks_per_block;
+
+			__u8 *buffer = yaffs_get_temp_buffer(dev, __LINE__);
 
 			memset(buffer, 0xff, dev->data_bytes_per_chunk);
-			memset(&tags, 0, sizeof(tags));
+			yaffs_init_tags(&tags);
 			tags.seq_number = YAFFS_SEQUENCE_BAD_BLOCK;
-			if (dev->tagger.write_chunk_tags_fn(dev, chunk_id -
-							dev->chunk_offset,
-							buffer,
-							&tags) != YAFFS_OK)
-				yaffs_trace(YAFFS_TRACE_ALWAYS,
-					"yaffs: Failed to write bad block marker to block %d",
-					flash_block);
-
-			yaffs_release_temp_buffer(dev, buffer);
+			if (dev->param.write_chunk_tags_fn(dev, chunk_id -
+				dev->chunk_offset, buffer, &tags) != YAFFS_OK)
+				T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Failed to "
+					TCONT("write bad block marker to block %d")
+					TENDSTR), flash_block));
+
+			yaffs_release_temp_buffer(dev, buffer, __LINE__);
 		}
 	}
 
@@ -629,138 +530,112 @@ static void yaffs_retire_block(struct ya
 	dev->n_retired_blocks++;
 }
 
-/*---------------- Name handling functions ------------*/
-
-static void yaffs_load_name_from_oh(struct yaffs_dev *dev, YCHAR *name,
-				    const YCHAR *oh_name, int buff_size)
+/*
+ * Functions for robustisizing TODO
+ *
+ */
+
+static void yaffs_handle_chunk_wr_ok(yaffs_dev_t *dev, int nand_chunk,
+				const __u8 *data,
+				const yaffs_ext_tags *tags)
 {
-#ifdef CONFIG_YAFFS_AUTO_UNICODE
-	if (dev->param.auto_unicode) {
-		if (*oh_name) {
-			/* It is an ASCII name, do an ASCII to
-			 * unicode conversion */
-			const char *ascii_oh_name = (const char *)oh_name;
-			int n = buff_size - 1;
-			while (n > 0 && *ascii_oh_name) {
-				*name = *ascii_oh_name;
-				name++;
-				ascii_oh_name++;
-				n--;
-			}
-		} else {
-			strncpy(name, oh_name + 1, buff_size - 1);
+	dev=dev;
+	nand_chunk=nand_chunk;
+	data=data;
+	tags=tags;
+}
+
+static void yaffs_handle_chunk_update(yaffs_dev_t *dev, int nand_chunk,
+				const yaffs_ext_tags *tags)
+{
+	dev=dev;
+	nand_chunk=nand_chunk;
+	tags=tags;
+}
+
+void yaffs_handle_chunk_error(yaffs_dev_t *dev, yaffs_block_info_t *bi)
+{
+	if (!bi->gc_prioritise) {
+		bi->gc_prioritise = 1;
+		dev->has_pending_prioritised_gc = 1;
+		bi->chunk_error_strikes++;
+
+		if (bi->chunk_error_strikes > 3) {
+			bi->needs_retiring = 1; /* Too many stikes, so retire this */
+			T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Block struck out" TENDSTR)));
+
 		}
-	} else {
-#else
-	(void) dev;
-	{
-#endif
-		strncpy(name, oh_name, buff_size - 1);
 	}
 }
 
-static void yaffs_load_oh_from_name(struct yaffs_dev *dev, YCHAR *oh_name,
-				    const YCHAR *name)
+static void yaffs_handle_chunk_wr_error(yaffs_dev_t *dev, int nand_chunk,
+		int erasedOk)
 {
-#ifdef CONFIG_YAFFS_AUTO_UNICODE
-
-	int is_ascii;
-	const YCHAR *w;
-
-	if (dev->param.auto_unicode) {
-
-		is_ascii = 1;
-		w = name;
-
-		/* Figure out if the name will fit in ascii character set */
-		while (is_ascii && *w) {
-			if ((*w) & 0xff00)
-				is_ascii = 0;
-			w++;
+	int flash_block = nand_chunk / dev->param.chunks_per_block;
+	yaffs_block_info_t *bi = yaffs_get_block_info(dev, flash_block);
+
+	yaffs_handle_chunk_error(dev, bi);
+
+	if (erasedOk) {
+		/* Was an actual write failure, so mark the block for retirement  */
+		bi->needs_retiring = 1;
+		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		  (TSTR("**>> Block %d needs retiring" TENDSTR), flash_block));
+	}
+
+	/* Delete the chunk */
+	yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+	yaffs_skip_rest_of_block(dev);
+}
+
+
+/*---------------- Name handling functions ------------*/
+
+static __u16 yaffs_calc_name_sum(const YCHAR *name)
+{
+	__u16 sum = 0;
+	__u16 i = 1;
+
+	const YUCHAR *bname = (const YUCHAR *) name;
+	if (bname) {
+		while ((*bname) && (i < (YAFFS_MAX_NAME_LENGTH/2))) {
+
+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+			sum += yaffs_toupper(*bname) * i;
+#else
+			sum += (*bname) * i;
+#endif
+			i++;
+			bname++;
 		}
-
-		if (is_ascii) {
-			/* It is an ASCII name, so convert unicode to ascii */
-			char *ascii_oh_name = (char *)oh_name;
-			int n = YAFFS_MAX_NAME_LENGTH - 1;
-			while (n > 0 && *name) {
-				*ascii_oh_name = *name;
-				name++;
-				ascii_oh_name++;
-				n--;
-			}
-		} else {
-			/* Unicode name, so save starting at the second YCHAR */
-			*oh_name = 0;
-			strncpy(oh_name + 1, name, YAFFS_MAX_NAME_LENGTH - 2);
-		}
-	} else {
-#else
-	dev = dev;
-	{
-#endif
-		strncpy(oh_name, name, YAFFS_MAX_NAME_LENGTH - 1);
-	}
-}
-
-static u16 yaffs_calc_name_sum(const YCHAR *name)
-{
-	u16 sum = 0;
-	u16 i = 1;
-
-	if (!name)
-		return 0;
-
-	while ((*name) && i < (YAFFS_MAX_NAME_LENGTH / 2)) {
-
-		/* 0x1f mask is case insensitive */
-		sum += ((*name) & 0x1f) * i;
-		i++;
-		name++;
 	}
 	return sum;
 }
 
-
-void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR * name)
+void yaffs_set_obj_name(yaffs_obj_t *obj, const YCHAR *name)
 {
-	memset(obj->short_name, 0, sizeof(obj->short_name));
-
-	if (name && !name[0]) {
-		yaffs_fix_null_name(obj, obj->short_name,
-				YAFFS_SHORT_NAME_LENGTH);
-		name = obj->short_name;
-	} else if (name &&
-		strnlen(name, YAFFS_SHORT_NAME_LENGTH + 1) <=
-		YAFFS_SHORT_NAME_LENGTH)  {
-		strcpy(obj->short_name, name);
-	}
-
+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+	memset(obj->short_name, 0, sizeof(YCHAR) * (YAFFS_SHORT_NAME_LENGTH+1));
+	if (name && yaffs_strnlen(name,YAFFS_SHORT_NAME_LENGTH+1) <= YAFFS_SHORT_NAME_LENGTH)
+		yaffs_strcpy(obj->short_name, name);
+	else
+		obj->short_name[0] = _Y('\0');
+#endif
 	obj->sum = yaffs_calc_name_sum(name);
 }
 
-void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
-				const struct yaffs_obj_hdr *oh)
+void yaffs_set_obj_name_from_oh(yaffs_obj_t *obj, const yaffs_obj_header *oh)
 {
 #ifdef CONFIG_YAFFS_AUTO_UNICODE
-	YCHAR tmp_name[YAFFS_MAX_NAME_LENGTH + 1];
-	memset(tmp_name, 0, sizeof(tmp_name));
-	yaffs_load_name_from_oh(obj->my_dev, tmp_name, oh->name,
-				YAFFS_MAX_NAME_LENGTH + 1);
-	yaffs_set_obj_name(obj, tmp_name);
+	YCHAR tmpName[YAFFS_MAX_NAME_LENGTH+1];
+	memset(tmpName,0,sizeof(tmpName));
+	yaffs_load_name_from_oh(obj->my_dev,tmpName,oh->name,YAFFS_MAX_NAME_LENGTH+1);
+	yaffs_set_obj_name(obj,tmpName);
 #else
-	yaffs_set_obj_name(obj, oh->name);
+	yaffs_set_obj_name(obj,oh->name);
 #endif
 }
 
-loff_t yaffs_max_file_size(struct yaffs_dev *dev)
-{
-	if(sizeof(loff_t) < 8)
-		return YAFFS_MAX_FILE_SIZE_32;
-	else
-		return ((loff_t) YAFFS_MAX_CHUNK_ID) * dev->data_bytes_per_chunk;
-}
-
 /*-------------------- TNODES -------------------
 
  * List of spare tnodes
@@ -768,87 +643,87 @@ loff_t yaffs_max_file_size(struct yaffs_
  * in the tnode.
  */
 
-struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev)
+
+yaffs_tnode_t *yaffs_get_tnode(yaffs_dev_t *dev)
 {
-	struct yaffs_tnode *tn = yaffs_alloc_raw_tnode(dev);
-
-	if (tn) {
+	yaffs_tnode_t *tn = yaffs_alloc_raw_tnode(dev);
+	if (tn){
 		memset(tn, 0, dev->tnode_size);
 		dev->n_tnodes++;
 	}
 
-	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+	dev->checkpoint_blocks_required = 0; /* force recalculation*/
 
 	return tn;
 }
 
 /* FreeTnode frees up a tnode and puts it back on the free list */
-static void yaffs_free_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
+static void yaffs_free_tnode(yaffs_dev_t *dev, yaffs_tnode_t *tn)
 {
-	yaffs_free_raw_tnode(dev, tn);
+	yaffs_free_raw_tnode(dev,tn);
 	dev->n_tnodes--;
-	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+	dev->checkpoint_blocks_required = 0; /* force recalculation*/
 }
 
-static void yaffs_deinit_tnodes_and_objs(struct yaffs_dev *dev)
+static void yaffs_deinit_tnodes_and_objs(yaffs_dev_t *dev)
 {
 	yaffs_deinit_raw_tnodes_and_objs(dev);
 	dev->n_obj = 0;
 	dev->n_tnodes = 0;
 }
 
-static void yaffs_load_tnode_0(struct yaffs_dev *dev, struct yaffs_tnode *tn,
-			unsigned pos, unsigned val)
+
+void yaffs_load_tnode_0(yaffs_dev_t *dev, yaffs_tnode_t *tn, unsigned pos,
+		unsigned val)
 {
-	u32 *map = (u32 *) tn;
-	u32 bit_in_map;
-	u32 bit_in_word;
-	u32 word_in_map;
-	u32 mask;
+	__u32 *map = (__u32 *)tn;
+	__u32 bitInMap;
+	__u32 bitInWord;
+	__u32 wordInMap;
+	__u32 mask;
 
 	pos &= YAFFS_TNODES_LEVEL0_MASK;
 	val >>= dev->chunk_grp_bits;
 
-	bit_in_map = pos * dev->tnode_width;
-	word_in_map = bit_in_map / 32;
-	bit_in_word = bit_in_map & (32 - 1);
-
-	mask = dev->tnode_mask << bit_in_word;
-
-	map[word_in_map] &= ~mask;
-	map[word_in_map] |= (mask & (val << bit_in_word));
-
-	if (dev->tnode_width > (32 - bit_in_word)) {
-		bit_in_word = (32 - bit_in_word);
-		word_in_map++;
-		mask =
-		    dev->tnode_mask >> bit_in_word;
-		map[word_in_map] &= ~mask;
-		map[word_in_map] |= (mask & (val >> bit_in_word));
+	bitInMap = pos * dev->tnode_width;
+	wordInMap = bitInMap / 32;
+	bitInWord = bitInMap & (32 - 1);
+
+	mask = dev->tnode_mask << bitInWord;
+
+	map[wordInMap] &= ~mask;
+	map[wordInMap] |= (mask & (val << bitInWord));
+
+	if (dev->tnode_width > (32 - bitInWord)) {
+		bitInWord = (32 - bitInWord);
+		wordInMap++;;
+		mask = dev->tnode_mask >> (/*dev->tnode_width -*/ bitInWord);
+		map[wordInMap] &= ~mask;
+		map[wordInMap] |= (mask & (val >> bitInWord));
 	}
 }
 
-u32 yaffs_get_group_base(struct yaffs_dev *dev, struct yaffs_tnode *tn,
-			 unsigned pos)
+__u32 yaffs_get_group_base(yaffs_dev_t *dev, yaffs_tnode_t *tn,
+		unsigned pos)
 {
-	u32 *map = (u32 *) tn;
-	u32 bit_in_map;
-	u32 bit_in_word;
-	u32 word_in_map;
-	u32 val;
+	__u32 *map = (__u32 *)tn;
+	__u32 bitInMap;
+	__u32 bitInWord;
+	__u32 wordInMap;
+	__u32 val;
 
 	pos &= YAFFS_TNODES_LEVEL0_MASK;
 
-	bit_in_map = pos * dev->tnode_width;
-	word_in_map = bit_in_map / 32;
-	bit_in_word = bit_in_map & (32 - 1);
-
-	val = map[word_in_map] >> bit_in_word;
-
-	if (dev->tnode_width > (32 - bit_in_word)) {
-		bit_in_word = (32 - bit_in_word);
-		word_in_map++;
-		val |= (map[word_in_map] << bit_in_word);
+	bitInMap = pos * dev->tnode_width;
+	wordInMap = bitInMap / 32;
+	bitInWord = bitInMap & (32 - 1);
+
+	val = map[wordInMap] >> bitInWord;
+
+	if	(dev->tnode_width > (32 - bitInWord)) {
+		bitInWord = (32 - bitInWord);
+		wordInMap++;;
+		val |= (map[wordInMap] << bitInWord);
 	}
 
 	val &= dev->tnode_mask;
@@ -865,16 +740,16 @@ u32 yaffs_get_group_base(struct yaffs_de
  */
 
 /* FindLevel0Tnode finds the level 0 tnode, if one exists. */
-struct yaffs_tnode *yaffs_find_tnode_0(struct yaffs_dev *dev,
-				       struct yaffs_file_var *file_struct,
-				       u32 chunk_id)
+yaffs_tnode_t *yaffs_find_tnode_0(yaffs_dev_t *dev,
+					yaffs_file_s *file_struct,
+					__u32 chunk_id)
 {
-	struct yaffs_tnode *tn = file_struct->top;
-	u32 i;
-	int required_depth;
+	yaffs_tnode_t *tn = file_struct->top;
+	__u32 i;
+	int requiredTallness;
 	int level = file_struct->top_level;
 
-	(void) dev;
+	dev=dev;
 
 	/* Check sane level and chunk Id */
 	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL)
@@ -886,54 +761,54 @@ struct yaffs_tnode *yaffs_find_tnode_0(s
 	/* First check we're tall enough (ie enough top_level) */
 
 	i = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
-	required_depth = 0;
+	requiredTallness = 0;
 	while (i) {
 		i >>= YAFFS_TNODES_INTERNAL_BITS;
-		required_depth++;
+		requiredTallness++;
 	}
 
-	if (required_depth > file_struct->top_level)
-		return NULL;	/* Not tall enough, so we can't find it */
+	if (requiredTallness > file_struct->top_level)
+		return NULL; /* Not tall enough, so we can't find it */
 
 	/* Traverse down to level 0 */
 	while (level > 0 && tn) {
 		tn = tn->internal[(chunk_id >>
-				   (YAFFS_TNODES_LEVEL0_BITS +
-				    (level - 1) *
-				    YAFFS_TNODES_INTERNAL_BITS)) &
-				  YAFFS_TNODES_INTERNAL_MASK];
+			(YAFFS_TNODES_LEVEL0_BITS +
+				(level - 1) *
+				YAFFS_TNODES_INTERNAL_BITS)) &
+			YAFFS_TNODES_INTERNAL_MASK];
 		level--;
 	}
 
 	return tn;
 }
 
-/* add_find_tnode_0 finds the level 0 tnode if it exists,
- * otherwise first expands the tree.
+/* AddOrFindLevel0Tnode finds the level 0 tnode if it exists, otherwise first expands the tree.
  * This happens in two steps:
  *  1. If the tree isn't tall enough, then make it taller.
  *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.
  *
  * Used when modifying the tree.
  *
- *  If the tn argument is NULL, then a fresh tnode will be added otherwise the
- *  specified tn will be plugged into the ttree.
+ *  If the tn argument is NULL, then a fresh tnode will be added otherwise the specified tn will
+ *  be plugged into the ttree.
  */
 
-struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
-					   struct yaffs_file_var *file_struct,
-					   u32 chunk_id,
-					   struct yaffs_tnode *passed_tn)
+yaffs_tnode_t *yaffs_add_find_tnode_0(yaffs_dev_t *dev,
+					yaffs_file_s *file_struct,
+					__u32 chunk_id,
+					yaffs_tnode_t *passed_tn)
 {
-	int required_depth;
+	int requiredTallness;
 	int i;
 	int l;
-	struct yaffs_tnode *tn;
-	u32 x;
+	yaffs_tnode_t *tn;
+
+	__u32 x;
+
 
 	/* Check sane level and page Id */
-	if (file_struct->top_level < 0 ||
-	    file_struct->top_level > YAFFS_TNODES_MAX_LEVEL)
+	if (file_struct->top_level < 0 || file_struct->top_level > YAFFS_TNODES_MAX_LEVEL)
 		return NULL;
 
 	if (chunk_id > YAFFS_MAX_CHUNK_ID)
@@ -942,15 +817,16 @@ struct yaffs_tnode *yaffs_add_find_tnode
 	/* First check we're tall enough (ie enough top_level) */
 
 	x = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
-	required_depth = 0;
+	requiredTallness = 0;
 	while (x) {
 		x >>= YAFFS_TNODES_INTERNAL_BITS;
-		required_depth++;
+		requiredTallness++;
 	}
 
-	if (required_depth > file_struct->top_level) {
+
+	if (requiredTallness > file_struct->top_level) {
 		/* Not tall enough, gotta make the tree taller */
-		for (i = file_struct->top_level; i < required_depth; i++) {
+		for (i = file_struct->top_level; i < requiredTallness; i++) {
 
 			tn = yaffs_get_tnode(dev);
 
@@ -959,8 +835,8 @@ struct yaffs_tnode *yaffs_add_find_tnode
 				file_struct->top = tn;
 				file_struct->top_level++;
 			} else {
-				yaffs_trace(YAFFS_TRACE_ERROR,
-					"yaffs: no more tnodes");
+				T(YAFFS_TRACE_ERROR,
+					(TSTR("yaffs: no more tnodes" TENDSTR)));
 				return NULL;
 			}
 		}
@@ -978,24 +854,24 @@ struct yaffs_tnode *yaffs_add_find_tnode
 			      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &
 			    YAFFS_TNODES_INTERNAL_MASK;
 
+
 			if ((l > 1) && !tn->internal[x]) {
 				/* Add missing non-level-zero tnode */
 				tn->internal[x] = yaffs_get_tnode(dev);
-				if (!tn->internal[x])
+				if(!tn->internal[x])
 					return NULL;
 			} else if (l == 1) {
 				/* Looking from level 1 at level 0 */
 				if (passed_tn) {
-					/* If we already have one, release it */
+					/* If we already have one, then release it.*/
 					if (tn->internal[x])
-						yaffs_free_tnode(dev,
-							tn->internal[x]);
+						yaffs_free_tnode(dev, tn->internal[x]);
 					tn->internal[x] = passed_tn;
 
 				} else if (!tn->internal[x]) {
 					/* Don't have one, none passed in */
 					tn->internal[x] = yaffs_get_tnode(dev);
-					if (!tn->internal[x])
+					if(!tn->internal[x])
 						return NULL;
 				}
 			}
@@ -1006,8 +882,7 @@ struct yaffs_tnode *yaffs_add_find_tnode
 	} else {
 		/* top is level 0 */
 		if (passed_tn) {
-			memcpy(tn, passed_tn,
-			       (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8);
+			memcpy(tn, passed_tn, (dev->tnode_width * YAFFS_NTNODES_LEVEL0)/8);
 			yaffs_free_tnode(dev, passed_tn);
 		}
 	}
@@ -1015,737 +890,230 @@ struct yaffs_tnode *yaffs_add_find_tnode
 	return tn;
 }
 
-static int yaffs_tags_match(const struct yaffs_ext_tags *tags, int obj_id,
-			    int chunk_obj)
-{
-	return (tags->chunk_id == chunk_obj &&
-		tags->obj_id == obj_id &&
-		!tags->is_deleted) ? 1 : 0;
-
-}
-
-static int yaffs_find_chunk_in_group(struct yaffs_dev *dev, int the_chunk,
-					struct yaffs_ext_tags *tags, int obj_id,
-					int inode_chunk)
+static int yaffs_find_chunk_in_group(yaffs_dev_t *dev, int theChunk,
+				yaffs_ext_tags *tags, int obj_id,
+				int inode_chunk)
 {
 	int j;
 
-	for (j = 0; the_chunk && j < dev->chunk_grp_size; j++) {
-		if (yaffs_check_chunk_bit
-		    (dev, the_chunk / dev->param.chunks_per_block,
-		     the_chunk % dev->param.chunks_per_block)) {
-
-			if (dev->chunk_grp_size == 1)
-				return the_chunk;
+	for (j = 0; theChunk && j < dev->chunk_grp_size; j++) {
+		if (yaffs_check_chunk_bit(dev, theChunk / dev->param.chunks_per_block,
+				theChunk % dev->param.chunks_per_block)) {
+			
+			if(dev->chunk_grp_size == 1)
+				return theChunk;
 			else {
-				yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
-							 tags);
-				if (yaffs_tags_match(tags,
-							obj_id, inode_chunk)) {
+				yaffs_rd_chunk_tags_nand(dev, theChunk, NULL,
+								tags);
+				if (yaffs_tags_match(tags, obj_id, inode_chunk)) {
 					/* found it; */
-					return the_chunk;
+					return theChunk;
 				}
 			}
 		}
-		the_chunk++;
+		theChunk++;
 	}
 	return -1;
 }
 
-int yaffs_find_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
-				    struct yaffs_ext_tags *tags)
+#if 0
+/* Experimental code not being used yet. Might speed up file deletion */
+/* DeleteWorker scans backwards through the tnode tree and deletes all the
+ * chunks and tnodes in the file.
+ * Returns 1 if the tree was deleted.
+ * Returns 0 if it stopped early due to hitting the limit and the delete is incomplete.
+ */
+
+static int yaffs_del_worker(yaffs_obj_t *in, yaffs_tnode_t *tn, __u32 level,
+			      int chunk_offset, int *limit)
 {
-	/*Get the Tnode, then get the level 0 offset chunk offset */
-	struct yaffs_tnode *tn;
-	int the_chunk = -1;
-	struct yaffs_ext_tags local_tags;
-	int ret_val = -1;
-	struct yaffs_dev *dev = in->my_dev;
-
-	if (!tags) {
-		/* Passed a NULL, so use our own tags space */
-		tags = &local_tags;
+	int i;
+	int inode_chunk;
+	int theChunk;
+	yaffs_ext_tags tags;
+	int foundChunk;
+	yaffs_dev_t *dev = in->my_dev;
+
+	int allDone = 1;
+
+	if (tn) {
+		if (level > 0) {
+			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
+			     i--) {
+				if (tn->internal[i]) {
+					if (limit && (*limit) < 0) {
+						allDone = 0;
+					} else {
+						allDone =
+							yaffs_del_worker(in,
+								tn->
+								internal
+								[i],
+								level -
+								1,
+								(chunk_offset
+									<<
+									YAFFS_TNODES_INTERNAL_BITS)
+								+ i,
+								limit);
+					}
+					if (allDone) {
+						yaffs_free_tnode(dev,
+								tn->
+								internal[i]);
+						tn->internal[i] = NULL;
+					}
+				}
+			}
+			return (allDone) ? 1 : 0;
+		} else if (level == 0) {
+			int hitLimit = 0;
+
+			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0 && !hitLimit;
+					i--) {
+				theChunk = yaffs_get_group_base(dev, tn, i);
+				if (theChunk) {
+
+					inode_chunk = (chunk_offset <<
+						YAFFS_TNODES_LEVEL0_BITS) + i;
+
+					foundChunk =
+						yaffs_find_chunk_in_group(dev,
+								theChunk,
+								&tags,
+								in->obj_id,
+								inode_chunk);
+
+					if (foundChunk > 0) {
+						yaffs_chunk_del(dev,
+								  foundChunk, 1,
+								  __LINE__);
+						in->n_data_chunks--;
+						if (limit) {
+							*limit = *limit - 1;
+							if (*limit <= 0)
+								hitLimit = 1;
+						}
+
+					}
+
+					yaffs_load_tnode_0(dev, tn, i, 0);
+				}
+
+			}
+			return (i < 0) ? 1 : 0;
+
+		}
+
 	}
 
-	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
-
-	if (!tn)
-		return ret_val;
-
-	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
-
-	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
-					      inode_chunk);
-	return ret_val;
+	return 1;
+
 }
 
-static int yaffs_find_del_file_chunk(struct yaffs_obj *in, int inode_chunk,
-				     struct yaffs_ext_tags *tags)
+#endif
+
+static void yaffs_soft_del_chunk(yaffs_dev_t *dev, int chunk)
 {
-	/* Get the Tnode, then get the level 0 offset chunk offset */
-	struct yaffs_tnode *tn;
-	int the_chunk = -1;
-	struct yaffs_ext_tags local_tags;
-	struct yaffs_dev *dev = in->my_dev;
-	int ret_val = -1;
-
-	if (!tags) {
-		/* Passed a NULL, so use our own tags space */
-		tags = &local_tags;
-	}
-
-	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
-
-	if (!tn)
-		return ret_val;
-
-	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
-
-	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
-					      inode_chunk);
-
-	/* Delete the entry in the filestructure (if found) */
-	if (ret_val != -1)
-		yaffs_load_tnode_0(dev, tn, inode_chunk, 0);
-
-	return ret_val;
-}
-
-int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
-			    int nand_chunk, int in_scan)
-{
-	/* NB in_scan is zero unless scanning.
-	 * For forward scanning, in_scan is > 0;
-	 * for backward scanning in_scan is < 0
-	 *
-	 * nand_chunk = 0 is a dummy insert to make sure the tnodes are there.
-	 */
-
-	struct yaffs_tnode *tn;
-	struct yaffs_dev *dev = in->my_dev;
-	int existing_cunk;
-	struct yaffs_ext_tags existing_tags;
-	struct yaffs_ext_tags new_tags;
-	unsigned existing_serial, new_serial;
-
-	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE) {
-		/* Just ignore an attempt at putting a chunk into a non-file
-		 * during scanning.
-		 * If it is not during Scanning then something went wrong!
-		 */
-		if (!in_scan) {
-			yaffs_trace(YAFFS_TRACE_ERROR,
-				"yaffs tragedy:attempt to put data chunk into a non-file"
-				);
-			BUG();
-		}
-
-		yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
-		return YAFFS_OK;
-	}
-
-	tn = yaffs_add_find_tnode_0(dev,
-				    &in->variant.file_variant,
-				    inode_chunk, NULL);
-	if (!tn)
-		return YAFFS_FAIL;
-
-	if (!nand_chunk)
-		/* Dummy insert, bail now */
-		return YAFFS_OK;
-
-	existing_cunk = yaffs_get_group_base(dev, tn, inode_chunk);
-
-	if (in_scan != 0) {
-		/* If we're scanning then we need to test for duplicates
-		 * NB This does not need to be efficient since it should only
-		 * happen when the power fails during a write, then only one
-		 * chunk should ever be affected.
-		 *
-		 * Correction for YAFFS2: This could happen quite a lot and we
-		 * need to think about efficiency! TODO
-		 * Update: For backward scanning we don't need to re-read tags
-		 * so this is quite cheap.
-		 */
-
-		if (existing_cunk > 0) {
-			/* NB Right now existing chunk will not be real
-			 * chunk_id if the chunk group size > 1
-			 * thus we have to do a FindChunkInFile to get the
-			 * real chunk id.
-			 *
-			 * We have a duplicate now we need to decide which
-			 * one to use:
-			 *
-			 * Backwards scanning YAFFS2: The old one is what
-			 * we use, dump the new one.
-			 * YAFFS1: Get both sets of tags and compare serial
-			 * numbers.
-			 */
-
-			if (in_scan > 0) {
-				/* Only do this for forward scanning */
-				yaffs_rd_chunk_tags_nand(dev,
-							 nand_chunk,
-							 NULL, &new_tags);
-
-				/* Do a proper find */
-				existing_cunk =
-				    yaffs_find_chunk_in_file(in, inode_chunk,
-							     &existing_tags);
-			}
-
-			if (existing_cunk <= 0) {
-				/*Hoosterman - how did this happen? */
-
-				yaffs_trace(YAFFS_TRACE_ERROR,
-					"yaffs tragedy: existing chunk < 0 in scan"
-					);
-
-			}
-
-			/* NB The deleted flags should be false, otherwise
-			 * the chunks will not be loaded during a scan
-			 */
-
-			if (in_scan > 0) {
-				new_serial = new_tags.serial_number;
-				existing_serial = existing_tags.serial_number;
-			}
-
-			if ((in_scan > 0) &&
-			    (existing_cunk <= 0 ||
-			     ((existing_serial + 1) & 3) == new_serial)) {
-				/* Forward scanning.
-				 * Use new
-				 * Delete the old one and drop through to
-				 * update the tnode
-				 */
-				yaffs_chunk_del(dev, existing_cunk, 1,
-						__LINE__);
-			} else {
-				/* Backward scanning or we want to use the
-				 * existing one
-				 * Delete the new one and return early so that
-				 * the tnode isn't changed
-				 */
-				yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
-				return YAFFS_OK;
-			}
-		}
-
-	}
-
-	if (existing_cunk == 0)
-		in->n_data_chunks++;
-
-	yaffs_load_tnode_0(dev, tn, inode_chunk, nand_chunk);
-
-	return YAFFS_OK;
-}
-
-static void yaffs_soft_del_chunk(struct yaffs_dev *dev, int chunk)
-{
-	struct yaffs_block_info *the_block;
+	yaffs_block_info_t *theBlock;
 	unsigned block_no;
 
-	yaffs_trace(YAFFS_TRACE_DELETION, "soft delete chunk %d", chunk);
-
-	block_no = chunk / dev->param.chunks_per_block;
-	the_block = yaffs_get_block_info(dev, block_no);
-	if (the_block) {
-		the_block->soft_del_pages++;
+	T(YAFFS_TRACE_DELETION, (TSTR("soft delete chunk %d" TENDSTR), chunk));
+
+	block_no =  chunk / dev->param.chunks_per_block;
+	theBlock = yaffs_get_block_info(dev, block_no);
+	if (theBlock) {
+		theBlock->soft_del_pages++;
 		dev->n_free_chunks++;
-		yaffs2_update_oldest_dirty_seq(dev, block_no, the_block);
+		yaffs2_update_oldest_dirty_seq(dev, block_no, theBlock);
 	}
 }
 
-/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all
- * the chunks in the file.
- * All soft deleting does is increment the block's softdelete count and pulls
- * the chunk out of the tnode.
- * Thus, essentially this is the same as DeleteWorker except that the chunks
- * are soft deleted.
+/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all the chunks in the file.
+ * All soft deleting does is increment the block's softdelete count and pulls the chunk out
+ * of the tnode.
+ * Thus, essentially this is the same as DeleteWorker except that the chunks are soft deleted.
  */
 
-static int yaffs_soft_del_worker(struct yaffs_obj *in, struct yaffs_tnode *tn,
-				 u32 level, int chunk_offset)
+static int yaffs_soft_del_worker(yaffs_obj_t *in, yaffs_tnode_t *tn,
+				  __u32 level, int chunk_offset)
 {
 	int i;
-	int the_chunk;
-	int all_done = 1;
-	struct yaffs_dev *dev = in->my_dev;
-
-	if (!tn)
-		return 1;
-
-	if (level > 0) {
-		for (i = YAFFS_NTNODES_INTERNAL - 1;
-			all_done && i >= 0;
-			i--) {
-			if (tn->internal[i]) {
-				all_done =
-				    yaffs_soft_del_worker(in,
-					tn->internal[i],
-					level - 1,
-					(chunk_offset <<
-					YAFFS_TNODES_INTERNAL_BITS)
-					+ i);
-				if (all_done) {
-					yaffs_free_tnode(dev,
-						tn->internal[i]);
-					tn->internal[i] = NULL;
-				} else {
-					/* Can this happen? */
+	int theChunk;
+	int allDone = 1;
+	yaffs_dev_t *dev = in->my_dev;
+
+	if (tn) {
+		if (level > 0) {
+
+			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
+			     i--) {
+				if (tn->internal[i]) {
+					allDone =
+					    yaffs_soft_del_worker(in,
+								   tn->
+								   internal[i],
+								   level - 1,
+								   (chunk_offset
+								    <<
+								    YAFFS_TNODES_INTERNAL_BITS)
+								   + i);
+					if (allDone) {
+						yaffs_free_tnode(dev,
+								tn->
+								internal[i]);
+						tn->internal[i] = NULL;
+					} else {
+						/* Hoosterman... how could this happen? */
+					}
 				}
 			}
+			return (allDone) ? 1 : 0;
+		} else if (level == 0) {
+
+			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
+				theChunk = yaffs_get_group_base(dev, tn, i);
+				if (theChunk) {
+					/* Note this does not find the real chunk, only the chunk group.
+					 * We make an assumption that a chunk group is not larger than
+					 * a block.
+					 */
+					yaffs_soft_del_chunk(dev, theChunk);
+					yaffs_load_tnode_0(dev, tn, i, 0);
+				}
+
+			}
+			return 1;
+
 		}
-		return (all_done) ? 1 : 0;
+
 	}
 
-	/* level 0 */
-	 for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
-		the_chunk = yaffs_get_group_base(dev, tn, i);
-		if (the_chunk) {
-			yaffs_soft_del_chunk(dev, the_chunk);
-			yaffs_load_tnode_0(dev, tn, i, 0);
+	return 1;
+
+}
+
+static void yaffs_soft_del_file(yaffs_obj_t *obj)
+{
+	if (obj->deleted &&
+	    obj->variant_type == YAFFS_OBJECT_TYPE_FILE && !obj->soft_del) {
+		if (obj->n_data_chunks <= 0) {
+			/* Empty file with no duplicate object headers, just delete it immediately */
+			yaffs_free_tnode(obj->my_dev,
+					obj->variant.file_variant.top);
+			obj->variant.file_variant.top = NULL;
+			T(YAFFS_TRACE_TRACING,
+			  (TSTR("yaffs: Deleting empty file %d" TENDSTR),
+			   obj->obj_id));
+			yaffs_generic_obj_del(obj);
+		} else {
+			yaffs_soft_del_worker(obj,
+					       obj->variant.file_variant.top,
+					       obj->variant.file_variant.
+					       top_level, 0);
+			obj->soft_del = 1;
 		}
 	}
-	return 1;
-}
-
-static void yaffs_remove_obj_from_dir(struct yaffs_obj *obj)
-{
-	struct yaffs_dev *dev = obj->my_dev;
-	struct yaffs_obj *parent;
-
-	yaffs_verify_obj_in_dir(obj);
-	parent = obj->parent;
-
-	yaffs_verify_dir(parent);
-
-	if (dev && dev->param.remove_obj_fn)
-		dev->param.remove_obj_fn(obj);
-
-	list_del_init(&obj->siblings);
-	obj->parent = NULL;
-
-	yaffs_verify_dir(parent);
-}
-
-void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj)
-{
-	if (!directory) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"tragedy: Trying to add an object to a null pointer directory"
-			);
-		BUG();
-		return;
-	}
-	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"tragedy: Trying to add an object to a non-directory"
-			);
-		BUG();
-	}
-
-	if (obj->siblings.prev == NULL) {
-		/* Not initialised */
-		BUG();
-	}
-
-	yaffs_verify_dir(directory);
-
-	yaffs_remove_obj_from_dir(obj);
-
-	/* Now add it */
-	list_add(&obj->siblings, &directory->variant.dir_variant.children);
-	obj->parent = directory;
-
-	if (directory == obj->my_dev->unlinked_dir
-	    || directory == obj->my_dev->del_dir) {
-		obj->unlinked = 1;
-		obj->my_dev->n_unlinked_files++;
-		obj->rename_allowed = 0;
-	}
-
-	yaffs_verify_dir(directory);
-	yaffs_verify_obj_in_dir(obj);
-}
-
-static int yaffs_change_obj_name(struct yaffs_obj *obj,
-				 struct yaffs_obj *new_dir,
-				 const YCHAR *new_name, int force, int shadows)
-{
-	int unlink_op;
-	int del_op;
-	struct yaffs_obj *existing_target;
-
-	if (new_dir == NULL)
-		new_dir = obj->parent;	/* use the old directory */
-
-	if (new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"tragedy: yaffs_change_obj_name: new_dir is not a directory"
-			);
-		BUG();
-	}
-
-	unlink_op = (new_dir == obj->my_dev->unlinked_dir);
-	del_op = (new_dir == obj->my_dev->del_dir);
-
-	existing_target = yaffs_find_by_name(new_dir, new_name);
-
-	/* If the object is a file going into the unlinked directory,
-	 *   then it is OK to just stuff it in since duplicate names are OK.
-	 *   else only proceed if the new name does not exist and we're putting
-	 *   it into a directory.
-	 */
-	if (!(unlink_op || del_op || force ||
-	      shadows > 0 || !existing_target) ||
-	      new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
-		return YAFFS_FAIL;
-
-	yaffs_set_obj_name(obj, new_name);
-	obj->dirty = 1;
-	yaffs_add_obj_to_dir(new_dir, obj);
-
-	if (unlink_op)
-		obj->unlinked = 1;
-
-	/* If it is a deletion then we mark it as a shrink for gc  */
-	if (yaffs_update_oh(obj, new_name, 0, del_op, shadows, NULL) >= 0)
-		return YAFFS_OK;
-
-	return YAFFS_FAIL;
-}
-
-/*------------------------ Short Operations Cache ------------------------------
- *   In many situations where there is no high level buffering  a lot of
- *   reads might be short sequential reads, and a lot of writes may be short
- *   sequential writes. eg. scanning/writing a jpeg file.
- *   In these cases, a short read/write cache can provide a huge perfomance
- *   benefit with dumb-as-a-rock code.
- *   In Linux, the page cache provides read buffering and the short op cache
- *   provides write buffering.
- *
- *   There are a small number (~10) of cache chunks per device so that we don't
- *   need a very intelligent search.
- */
-
-static int yaffs_obj_cache_dirty(struct yaffs_obj *obj)
-{
-	struct yaffs_dev *dev = obj->my_dev;
-	int i;
-	struct yaffs_cache *cache;
-	int n_caches = obj->my_dev->param.n_caches;
-
-	for (i = 0; i < n_caches; i++) {
-		cache = &dev->cache[i];
-		if (cache->object == obj && cache->dirty)
-			return 1;
-	}
-
-	return 0;
-}
-
-static void yaffs_flush_single_cache(struct yaffs_cache *cache, int discard)
-{
-
-	if (!cache || cache->locked)
-		return;
-
-	/* Write it out and free it up  if need be.*/
-	if (cache->dirty) {
-		yaffs_wr_data_obj(cache->object,
-				  cache->chunk_id,
-				  cache->data,
-				  cache->n_bytes,
-				  1);
-
-		cache->dirty = 0;
-	}
-
-	if (discard)
-		cache->object = NULL;
-}
-
-static void yaffs_flush_file_cache(struct yaffs_obj *obj, int discard)
-{
-	struct yaffs_dev *dev = obj->my_dev;
-	int i;
-	struct yaffs_cache *cache;
-	int n_caches = obj->my_dev->param.n_caches;
-
-	if (n_caches < 1)
-		return;
-
-
-	/* Find the chunks for this object and flush them. */
-	for (i = 0; i < n_caches; i++) {
-		cache = &dev->cache[i];
-		if (cache->object == obj)
-			yaffs_flush_single_cache(cache, discard);
-	}
-
-}
-
-
-void yaffs_flush_whole_cache(struct yaffs_dev *dev, int discard)
-{
-	struct yaffs_obj *obj;
-	int n_caches = dev->param.n_caches;
-	int i;
-
-	/* Find a dirty object in the cache and flush it...
-	 * until there are no further dirty objects.
-	 */
-	do {
-		obj = NULL;
-		for (i = 0; i < n_caches && !obj; i++) {
-			if (dev->cache[i].object && dev->cache[i].dirty)
-				obj = dev->cache[i].object;
-		}
-		if (obj)
-			yaffs_flush_file_cache(obj, discard);
-	} while (obj);
-
-}
-
-/* Grab us an unused cache chunk for use.
- * First look for an empty one.
- * Then look for the least recently used non-dirty one.
- * Then look for the least recently used dirty one...., flush and look again.
- */
-static struct yaffs_cache *yaffs_grab_chunk_worker(struct yaffs_dev *dev)
-{
-	int i;
-
-	if (dev->param.n_caches > 0) {
-		for (i = 0; i < dev->param.n_caches; i++) {
-			if (!dev->cache[i].object)
-				return &dev->cache[i];
-		}
-	}
-
-	return NULL;
-}
-
-static struct yaffs_cache *yaffs_grab_chunk_cache(struct yaffs_dev *dev)
-{
-	struct yaffs_cache *cache;
-	int usage;
-	int i;
-
-	if (dev->param.n_caches < 1)
-		return NULL;
-
-	/* First look for an unused cache */
-
-	cache = yaffs_grab_chunk_worker(dev);
-
-	if (cache)
-		return cache;
-
-	/*
-	 * Thery were all in use.
-	 * Find the LRU cache and flush it if it is dirty.
-	 */
-
-	usage = -1;
-	cache = NULL;
-
-	for (i = 0; i < dev->param.n_caches; i++) {
-		if (dev->cache[i].object &&
-		    !dev->cache[i].locked &&
-		    (dev->cache[i].last_use < usage || !cache)) {
-				usage = dev->cache[i].last_use;
-				cache = &dev->cache[i];
-		}
-	}
-
-#if 1
-	yaffs_flush_single_cache(cache, 1);
-#else
-	yaffs_flush_file_cache(cache->object, 1);
-	cache = yaffs_grab_chunk_worker(dev);
-#endif
-
-	return cache;
-}
-
-/* Find a cached chunk */
-static struct yaffs_cache *yaffs_find_chunk_cache(const struct yaffs_obj *obj,
-						  int chunk_id)
-{
-	struct yaffs_dev *dev = obj->my_dev;
-	int i;
-
-	if (dev->param.n_caches < 1)
-		return NULL;
-
-	for (i = 0; i < dev->param.n_caches; i++) {
-		if (dev->cache[i].object == obj &&
-		    dev->cache[i].chunk_id == chunk_id) {
-			dev->cache_hits++;
-
-			return &dev->cache[i];
-		}
-	}
-	return NULL;
-}
-
-/* Mark the chunk for the least recently used algorithym */
-static void yaffs_use_cache(struct yaffs_dev *dev, struct yaffs_cache *cache,
-			    int is_write)
-{
-	int i;
-
-	if (dev->param.n_caches < 1)
-		return;
-
-	if (dev->cache_last_use < 0 ||
-		dev->cache_last_use > 100000000) {
-		/* Reset the cache usages */
-		for (i = 1; i < dev->param.n_caches; i++)
-			dev->cache[i].last_use = 0;
-
-		dev->cache_last_use = 0;
-	}
-	dev->cache_last_use++;
-	cache->last_use = dev->cache_last_use;
-
-	if (is_write)
-		cache->dirty = 1;
-}
-
-/* Invalidate a single cache page.
- * Do this when a whole page gets written,
- * ie the short cache for this page is no longer valid.
- */
-static void yaffs_invalidate_chunk_cache(struct yaffs_obj *object, int chunk_id)
-{
-	struct yaffs_cache *cache;
-
-	if (object->my_dev->param.n_caches > 0) {
-		cache = yaffs_find_chunk_cache(object, chunk_id);
-
-		if (cache)
-			cache->object = NULL;
-	}
-}
-
-/* Invalidate all the cache pages associated with this object
- * Do this whenever ther file is deleted or resized.
- */
-static void yaffs_invalidate_whole_cache(struct yaffs_obj *in)
-{
-	int i;
-	struct yaffs_dev *dev = in->my_dev;
-
-	if (dev->param.n_caches > 0) {
-		/* Invalidate it. */
-		for (i = 0; i < dev->param.n_caches; i++) {
-			if (dev->cache[i].object == in)
-				dev->cache[i].object = NULL;
-		}
-	}
-}
-
-static void yaffs_unhash_obj(struct yaffs_obj *obj)
-{
-	int bucket;
-	struct yaffs_dev *dev = obj->my_dev;
-
-	/* If it is still linked into the bucket list, free from the list */
-	if (!list_empty(&obj->hash_link)) {
-		list_del_init(&obj->hash_link);
-		bucket = yaffs_hash_fn(obj->obj_id);
-		dev->obj_bucket[bucket].count--;
-	}
-}
-
-/*  FreeObject frees up a Object and puts it back on the free list */
-static void yaffs_free_obj(struct yaffs_obj *obj)
-{
-	struct yaffs_dev *dev;
-
-	if (!obj) {
-		BUG();
-		return;
-	}
-	dev = obj->my_dev;
-	yaffs_trace(YAFFS_TRACE_OS, "FreeObject %p inode %p",
-		obj, obj->my_inode);
-	if (obj->parent)
-		BUG();
-	if (!list_empty(&obj->siblings))
-		BUG();
-
-	if (obj->my_inode) {
-		/* We're still hooked up to a cached inode.
-		 * Don't delete now, but mark for later deletion
-		 */
-		obj->defered_free = 1;
-		return;
-	}
-
-	yaffs_unhash_obj(obj);
-
-	yaffs_free_raw_obj(dev, obj);
-	dev->n_obj--;
-	dev->checkpoint_blocks_required = 0;	/* force recalculation */
-}
-
-void yaffs_handle_defered_free(struct yaffs_obj *obj)
-{
-	if (obj->defered_free)
-		yaffs_free_obj(obj);
-}
-
-static int yaffs_generic_obj_del(struct yaffs_obj *in)
-{
-	/* Iinvalidate the file's data in the cache, without flushing. */
-	yaffs_invalidate_whole_cache(in);
-
-	if (in->my_dev->param.is_yaffs2 && in->parent != in->my_dev->del_dir) {
-		/* Move to unlinked directory so we have a deletion record */
-		yaffs_change_obj_name(in, in->my_dev->del_dir, _Y("deleted"), 0,
-				      0);
-	}
-
-	yaffs_remove_obj_from_dir(in);
-	yaffs_chunk_del(in->my_dev, in->hdr_chunk, 1, __LINE__);
-	in->hdr_chunk = 0;
-
-	yaffs_free_obj(in);
-	return YAFFS_OK;
-
-}
-
-static void yaffs_soft_del_file(struct yaffs_obj *obj)
-{
-	if (!obj->deleted ||
-	    obj->variant_type != YAFFS_OBJECT_TYPE_FILE ||
-	    obj->soft_del)
-		return;
-
-	if (obj->n_data_chunks <= 0) {
-		/* Empty file with no duplicate object headers,
-		 * just delete it immediately */
-		yaffs_free_tnode(obj->my_dev, obj->variant.file_variant.top);
-		obj->variant.file_variant.top = NULL;
-		yaffs_trace(YAFFS_TRACE_TRACING,
-			"yaffs: Deleting empty file %d",
-			obj->obj_id);
-		yaffs_generic_obj_del(obj);
-	} else {
-		yaffs_soft_del_worker(obj,
-				      obj->variant.file_variant.top,
-				      obj->variant.
-				      file_variant.top_level, 0);
-		obj->soft_del = 1;
-	}
 }
 
 /* Pruning removes any part of the file structure tree that is beyond the
@@ -1763,142 +1131,229 @@ static void yaffs_soft_del_file(struct y
  * If there is no data in a subtree then it is pruned.
  */
 
-static struct yaffs_tnode *yaffs_prune_worker(struct yaffs_dev *dev,
-					      struct yaffs_tnode *tn, u32 level,
-					      int del0)
+static yaffs_tnode_t *yaffs_prune_worker(yaffs_dev_t *dev, yaffs_tnode_t *tn,
+				__u32 level, int del0)
 {
 	int i;
-	int has_data;
-
-	if (!tn)
-		return tn;
-
-	has_data = 0;
-
-	if (level > 0) {
-		for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
-			if (tn->internal[i]) {
-				tn->internal[i] =
-				    yaffs_prune_worker(dev,
-						tn->internal[i],
-						level - 1,
-						(i == 0) ? del0 : 1);
+	int hasData;
+
+	if (tn) {
+		hasData = 0;
+
+		if(level > 0){
+			for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
+				if (tn->internal[i]) {
+					tn->internal[i] =
+						yaffs_prune_worker(dev, tn->internal[i],
+							level - 1,
+							(i == 0) ? del0 : 1);
+				}
+
+				if (tn->internal[i])
+					hasData++;
 			}
-
-			if (tn->internal[i])
-				has_data++;
+		} else {
+			int tnode_size_u32 = dev->tnode_size/sizeof(__u32);
+			__u32 *map = (__u32 *)tn;
+
+                        for(i = 0; !hasData && i < tnode_size_u32; i++){
+                                if(map[i])
+                                        hasData++;
+                        }
+                }
+
+		if (hasData == 0 && del0) {
+			/* Free and return NULL */
+
+			yaffs_free_tnode(dev, tn);
+			tn = NULL;
 		}
-	} else {
-		int tnode_size_u32 = dev->tnode_size / sizeof(u32);
-		u32 *map = (u32 *) tn;
-
-		for (i = 0; !has_data && i < tnode_size_u32; i++) {
-			if (map[i])
-				has_data++;
+
+	}
+
+	return tn;
+
+}
+
+static int yaffs_prune_tree(yaffs_dev_t *dev,
+				yaffs_file_s *file_struct)
+{
+	int i;
+	int hasData;
+	int done = 0;
+	yaffs_tnode_t *tn;
+
+	if (file_struct->top_level > 0) {
+		file_struct->top =
+		    yaffs_prune_worker(dev, file_struct->top, file_struct->top_level, 0);
+
+		/* Now we have a tree with all the non-zero branches NULL but the height
+		 * is the same as it was.
+		 * Let's see if we can trim internal tnodes to shorten the tree.
+		 * We can do this if only the 0th element in the tnode is in use
+		 * (ie all the non-zero are NULL)
+		 */
+
+		while (file_struct->top_level && !done) {
+			tn = file_struct->top;
+
+			hasData = 0;
+			for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
+				if (tn->internal[i])
+					hasData++;
+			}
+
+			if (!hasData) {
+				file_struct->top = tn->internal[0];
+				file_struct->top_level--;
+				yaffs_free_tnode(dev, tn);
+			} else {
+				done = 1;
+			}
 		}
 	}
 
-	if (has_data == 0 && del0) {
-		/* Free and return NULL */
-		yaffs_free_tnode(dev, tn);
-		tn = NULL;
+	return YAFFS_OK;
+}
+
+/*-------------------- End of File Structure functions.-------------------*/
+
+
+/* AllocateEmptyObject gets us a clean Object. Tries to make allocate more if we run out */
+static yaffs_obj_t *yaffs_alloc_empty_obj(yaffs_dev_t *dev)
+{
+	yaffs_obj_t *obj = yaffs_alloc_raw_obj(dev);
+
+	if (obj) {
+		dev->n_obj++;
+
+		/* Now sweeten it up... */
+
+		memset(obj, 0, sizeof(yaffs_obj_t));
+		obj->being_created = 1;
+
+		obj->my_dev = dev;
+		obj->hdr_chunk = 0;
+		obj->variant_type = YAFFS_OBJECT_TYPE_UNKNOWN;
+		YINIT_LIST_HEAD(&(obj->hard_links));
+		YINIT_LIST_HEAD(&(obj->hash_link));
+		YINIT_LIST_HEAD(&obj->siblings);
+
+
+		/* Now make the directory sane */
+		if (dev->root_dir) {
+			obj->parent = dev->root_dir;
+			ylist_add(&(obj->siblings), &dev->root_dir->variant.dir_variant.children);
+		}
+
+		/* Add it to the lost and found directory.
+		 * NB Can't put root or lostNFound in lostNFound so
+		 * check if lostNFound exists first
+		 */
+		if (dev->lost_n_found)
+			yaffs_add_obj_to_dir(dev->lost_n_found, obj);
+
+		obj->being_created = 0;
 	}
-	return tn;
+
+	dev->checkpoint_blocks_required = 0; /* force recalculation*/
+
+	return obj;
 }
 
-static int yaffs_prune_tree(struct yaffs_dev *dev,
-			    struct yaffs_file_var *file_struct)
+static yaffs_obj_t *yaffs_create_fake_dir(yaffs_dev_t *dev, int number,
+					       __u32 mode)
+{
+
+	yaffs_obj_t *obj =
+	    yaffs_new_obj(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
+	if (obj) {
+		obj->fake = 1;		/* it is fake so it might have no NAND presence... */
+		obj->rename_allowed = 0;	/* ... and we're not allowed to rename it... */
+		obj->unlink_allowed = 0;	/* ... or unlink it */
+		obj->deleted = 0;
+		obj->unlinked = 0;
+		obj->yst_mode = mode;
+		obj->my_dev = dev;
+		obj->hdr_chunk = 0;	/* Not a valid chunk. */
+	}
+
+	return obj;
+
+}
+
+static void yaffs_unhash_obj(yaffs_obj_t *obj)
+{
+	int bucket;
+	yaffs_dev_t *dev = obj->my_dev;
+
+	/* If it is still linked into the bucket list, free from the list */
+	if (!ylist_empty(&obj->hash_link)) {
+		ylist_del_init(&obj->hash_link);
+		bucket = yaffs_hash_fn(obj->obj_id);
+		dev->obj_bucket[bucket].count--;
+	}
+}
+
+/*  FreeObject frees up a Object and puts it back on the free list */
+static void yaffs_free_obj(yaffs_obj_t *obj)
+{
+	yaffs_dev_t *dev = obj->my_dev;
+
+	T(YAFFS_TRACE_OS, (TSTR("FreeObject %p inode %p"TENDSTR), obj, obj->my_inode));
+
+	if (!obj)
+		YBUG();
+	if (obj->parent)
+		YBUG();
+	if (!ylist_empty(&obj->siblings))
+		YBUG();
+
+
+	if (obj->my_inode) {
+		/* We're still hooked up to a cached inode.
+		 * Don't delete now, but mark for later deletion
+		 */
+		obj->defered_free = 1;
+		return;
+	}
+
+	yaffs_unhash_obj(obj);
+
+	yaffs_free_raw_obj(dev,obj);
+	dev->n_obj--;
+	dev->checkpoint_blocks_required = 0; /* force recalculation*/
+}
+
+
+void yaffs_handle_defered_free(yaffs_obj_t *obj)
+{
+	if (obj->defered_free)
+		yaffs_free_obj(obj);
+}
+
+static void yaffs_init_tnodes_and_objs(yaffs_dev_t *dev)
 {
 	int i;
-	int has_data;
-	int done = 0;
-	struct yaffs_tnode *tn;
-
-	if (file_struct->top_level < 1)
-		return YAFFS_OK;
-
-	file_struct->top =
-	   yaffs_prune_worker(dev, file_struct->top, file_struct->top_level, 0);
-
-	/* Now we have a tree with all the non-zero branches NULL but
-	 * the height is the same as it was.
-	 * Let's see if we can trim internal tnodes to shorten the tree.
-	 * We can do this if only the 0th element in the tnode is in use
-	 * (ie all the non-zero are NULL)
-	 */
-
-	while (file_struct->top_level && !done) {
-		tn = file_struct->top;
-
-		has_data = 0;
-		for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
-			if (tn->internal[i])
-				has_data++;
-		}
-
-		if (!has_data) {
-			file_struct->top = tn->internal[0];
-			file_struct->top_level--;
-			yaffs_free_tnode(dev, tn);
-		} else {
-			done = 1;
-		}
+
+	dev->n_obj = 0;
+	dev->n_tnodes = 0;
+
+	yaffs_init_raw_tnodes_and_objs(dev);
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		YINIT_LIST_HEAD(&dev->obj_bucket[i].list);
+		dev->obj_bucket[i].count = 0;
 	}
-
-	return YAFFS_OK;
 }
 
-/*-------------------- End of File Structure functions.-------------------*/
-
-/* alloc_empty_obj gets us a clean Object.*/
-static struct yaffs_obj *yaffs_alloc_empty_obj(struct yaffs_dev *dev)
-{
-	struct yaffs_obj *obj = yaffs_alloc_raw_obj(dev);
-
-	if (!obj)
-		return obj;
-
-	dev->n_obj++;
-
-	/* Now sweeten it up... */
-
-	memset(obj, 0, sizeof(struct yaffs_obj));
-	obj->being_created = 1;
-
-	obj->my_dev = dev;
-	obj->hdr_chunk = 0;
-	obj->variant_type = YAFFS_OBJECT_TYPE_UNKNOWN;
-	INIT_LIST_HEAD(&(obj->hard_links));
-	INIT_LIST_HEAD(&(obj->hash_link));
-	INIT_LIST_HEAD(&obj->siblings);
-
-	/* Now make the directory sane */
-	if (dev->root_dir) {
-		obj->parent = dev->root_dir;
-		list_add(&(obj->siblings),
-			 &dev->root_dir->variant.dir_variant.children);
-	}
-
-	/* Add it to the lost and found directory.
-	 * NB Can't put root or lost-n-found in lost-n-found so
-	 * check if lost-n-found exists first
-	 */
-	if (dev->lost_n_found)
-		yaffs_add_obj_to_dir(dev->lost_n_found, obj);
-
-	obj->being_created = 0;
-
-	dev->checkpoint_blocks_required = 0;	/* force recalculation */
-
-	return obj;
-}
-
-static int yaffs_find_nice_bucket(struct yaffs_dev *dev)
+static int yaffs_find_nice_bucket(yaffs_dev_t *dev)
 {
 	int i;
 	int l = 999;
 	int lowest = 999999;
 
+
 	/* Search for the shortest list or one that
 	 * isn't too long.
 	 */
@@ -1910,72 +1365,82 @@ static int yaffs_find_nice_bucket(struct
 			lowest = dev->obj_bucket[dev->bucket_finder].count;
 			l = dev->bucket_finder;
 		}
+
 	}
 
 	return l;
 }
 
-static int yaffs_new_obj_id(struct yaffs_dev *dev)
+static int yaffs_new_obj_id(yaffs_dev_t *dev)
 {
 	int bucket = yaffs_find_nice_bucket(dev);
-	int found = 0;
-	struct list_head *i;
-	u32 n = (u32) bucket;
 
 	/* Now find an object value that has not already been taken
 	 * by scanning the list.
 	 */
 
+	int found = 0;
+	struct ylist_head *i;
+
+	__u32 n = (__u32) bucket;
+
+	/* yaffs_check_obj_hash_sane();  */
+
 	while (!found) {
 		found = 1;
 		n += YAFFS_NOBJECT_BUCKETS;
 		if (1 || dev->obj_bucket[bucket].count > 0) {
-			list_for_each(i, &dev->obj_bucket[bucket].list) {
+			ylist_for_each(i, &dev->obj_bucket[bucket].list) {
 				/* If there is already one in the list */
-				if (i && list_entry(i, struct yaffs_obj,
-						    hash_link)->obj_id == n) {
+				if (i && ylist_entry(i, yaffs_obj_t,
+						hash_link)->obj_id == n) {
 					found = 0;
 				}
 			}
 		}
 	}
+
 	return n;
 }
 
-static void yaffs_hash_obj(struct yaffs_obj *in)
+static void yaffs_hash_obj(yaffs_obj_t *in)
 {
 	int bucket = yaffs_hash_fn(in->obj_id);
-	struct yaffs_dev *dev = in->my_dev;
-
-	list_add(&in->hash_link, &dev->obj_bucket[bucket].list);
+	yaffs_dev_t *dev = in->my_dev;
+
+	ylist_add(&in->hash_link, &dev->obj_bucket[bucket].list);
 	dev->obj_bucket[bucket].count++;
 }
 
-struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number)
+yaffs_obj_t *yaffs_find_by_number(yaffs_dev_t *dev, __u32 number)
 {
 	int bucket = yaffs_hash_fn(number);
-	struct list_head *i;
-	struct yaffs_obj *in;
-
-	list_for_each(i, &dev->obj_bucket[bucket].list) {
+	struct ylist_head *i;
+	yaffs_obj_t *in;
+
+	ylist_for_each(i, &dev->obj_bucket[bucket].list) {
 		/* Look if it is in the list */
-		in = list_entry(i, struct yaffs_obj, hash_link);
-		if (in->obj_id == number) {
-			/* Don't show if it is defered free */
-			if (in->defered_free)
-				return NULL;
-			return in;
+		if (i) {
+			in = ylist_entry(i, yaffs_obj_t, hash_link);
+			if (in->obj_id == number) {
+
+				/* Don't tell the VFS about this one if it is defered free */
+				if (in->defered_free)
+					return NULL;
+
+				return in;
+			}
 		}
 	}
 
 	return NULL;
 }
 
-static struct yaffs_obj *yaffs_new_obj(struct yaffs_dev *dev, int number,
-				enum yaffs_obj_type type)
+yaffs_obj_t *yaffs_new_obj(yaffs_dev_t *dev, int number,
+				    yaffs_obj_type type)
 {
-	struct yaffs_obj *the_obj = NULL;
-	struct yaffs_tnode *tn = NULL;
+	yaffs_obj_t *theObject=NULL;
+	yaffs_tnode_t *tn = NULL;
 
 	if (number < 0)
 		number = yaffs_new_obj_id(dev);
@@ -1986,116 +1451,2956 @@ static struct yaffs_obj *yaffs_new_obj(s
 			return NULL;
 	}
 
-	the_obj = yaffs_alloc_empty_obj(dev);
-	if (!the_obj) {
-		if (tn)
-			yaffs_free_tnode(dev, tn);
+	theObject = yaffs_alloc_empty_obj(dev);
+	if (!theObject){
+		if(tn)
+			yaffs_free_tnode(dev,tn);
 		return NULL;
 	}
 
-	the_obj->fake = 0;
-	the_obj->rename_allowed = 1;
-	the_obj->unlink_allowed = 1;
-	the_obj->obj_id = number;
-	yaffs_hash_obj(the_obj);
-	the_obj->variant_type = type;
-	yaffs_load_current_time(the_obj, 1, 1);
-
-	switch (type) {
+
+	if (theObject) {
+		theObject->fake = 0;
+		theObject->rename_allowed = 1;
+		theObject->unlink_allowed = 1;
+		theObject->obj_id = number;
+		yaffs_hash_obj(theObject);
+		theObject->variant_type = type;
+#ifdef CONFIG_YAFFS_WINCE
+		yfsd_win_file_time_now(theObject->win_atime);
+		theObject->win_ctime[0] = theObject->win_mtime[0] =
+		    theObject->win_atime[0];
+		theObject->win_ctime[1] = theObject->win_mtime[1] =
+		    theObject->win_atime[1];
+
+#else
+
+		theObject->yst_atime = theObject->yst_mtime =
+		    theObject->yst_ctime = Y_CURRENT_TIME;
+#endif
+		switch (type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			theObject->variant.file_variant.file_size = 0;
+			theObject->variant.file_variant.scanned_size = 0;
+			theObject->variant.file_variant.shrink_size = 0xFFFFFFFF;	/* max __u32 */
+			theObject->variant.file_variant.top_level = 0;
+			theObject->variant.file_variant.top = tn;
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			YINIT_LIST_HEAD(&theObject->variant.dir_variant.
+					children);
+			YINIT_LIST_HEAD(&theObject->variant.dir_variant.
+					dirty);
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			/* No action required */
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+			/* todo this should not happen */
+			break;
+		}
+	}
+
+	return theObject;
+}
+
+yaffs_obj_t *yaffs_find_or_create_by_number(yaffs_dev_t *dev,
+						int number,
+						yaffs_obj_type type)
+{
+	yaffs_obj_t *theObject = NULL;
+
+	if (number > 0)
+		theObject = yaffs_find_by_number(dev, number);
+
+	if (!theObject)
+		theObject = yaffs_new_obj(dev, number, type);
+
+	return theObject;
+
+}
+
+
+YCHAR *yaffs_clone_str(const YCHAR *str)
+{
+	YCHAR *newStr = NULL;
+	int len;
+
+	if (!str)
+		str = _Y("");
+
+	len = yaffs_strnlen(str,YAFFS_MAX_ALIAS_LENGTH);
+	newStr = YMALLOC((len + 1) * sizeof(YCHAR));
+	if (newStr){
+		yaffs_strncpy(newStr, str,len);
+		newStr[len] = 0;
+	}
+	return newStr;
+
+}
+
+/*
+ * Mknod (create) a new object.
+ * equiv_obj only has meaning for a hard link;
+ * aliasString only has meaning for a symlink.
+ * rdev only has meaning for devices (a subset of special objects)
+ */
+
+static yaffs_obj_t *yaffs_create_obj(yaffs_obj_type type,
+				       yaffs_obj_t *parent,
+				       const YCHAR *name,
+				       __u32 mode,
+				       __u32 uid,
+				       __u32 gid,
+				       yaffs_obj_t *equiv_obj,
+				       const YCHAR *aliasString, __u32 rdev)
+{
+	yaffs_obj_t *in;
+	YCHAR *str = NULL;
+
+	yaffs_dev_t *dev = parent->my_dev;
+
+	/* Check if the entry exists. If it does then fail the call since we don't want a dup.*/
+	if (yaffs_find_by_name(parent, name))
+		return NULL;
+
+	if (type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		str = yaffs_clone_str(aliasString);
+		if (!str)
+			return NULL;
+	}
+
+	in = yaffs_new_obj(dev, -1, type);
+
+	if (!in){
+		if(str)
+			YFREE(str);
+		return NULL;
+	}
+
+
+
+
+
+	if (in) {
+		in->hdr_chunk = 0;
+		in->valid = 1;
+		in->variant_type = type;
+
+		in->yst_mode = mode;
+
+#ifdef CONFIG_YAFFS_WINCE
+		yfsd_win_file_time_now(in->win_atime);
+		in->win_ctime[0] = in->win_mtime[0] = in->win_atime[0];
+		in->win_ctime[1] = in->win_mtime[1] = in->win_atime[1];
+
+#else
+		in->yst_atime = in->yst_mtime = in->yst_ctime = Y_CURRENT_TIME;
+
+		in->yst_rdev = rdev;
+		in->yst_uid = uid;
+		in->yst_gid = gid;
+#endif
+		in->n_data_chunks = 0;
+
+		yaffs_set_obj_name(in, name);
+		in->dirty = 1;
+
+		yaffs_add_obj_to_dir(parent, in);
+
+		in->my_dev = parent->my_dev;
+
+		switch (type) {
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			in->variant.symlink_variant.alias = str;
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+			in->variant.hardlink_variant.equiv_obj =
+				equiv_obj;
+			in->variant.hardlink_variant.equiv_id =
+				equiv_obj->obj_id;
+			ylist_add(&in->hard_links, &equiv_obj->hard_links);
+			break;
+		case YAFFS_OBJECT_TYPE_FILE:
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+			/* do nothing */
+			break;
+		}
+
+		if (yaffs_update_oh(in, name, 0, 0, 0, NULL) < 0) {
+			/* Could not create the object header, fail the creation */
+			yaffs_del_obj(in);
+			in = NULL;
+		}
+
+		yaffs_update_parent(parent);
+	}
+
+	return in;
+}
+
+yaffs_obj_t *yaffs_create_file(yaffs_obj_t *parent, const YCHAR *name,
+			__u32 mode, __u32 uid, __u32 gid)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
+				uid, gid, NULL, NULL, 0);
+}
+
+yaffs_obj_t *yaffs_create_dir(yaffs_obj_t *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
+				 mode, uid, gid, NULL, NULL, 0);
+}
+
+yaffs_obj_t *yaffs_create_special(yaffs_obj_t *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid, __u32 rdev)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
+				 uid, gid, NULL, NULL, rdev);
+}
+
+yaffs_obj_t *yaffs_create_symlink(yaffs_obj_t *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid,
+				const YCHAR *alias)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
+				uid, gid, NULL, alias, 0);
+}
+
+/* yaffs_link_obj returns the object id of the equivalent object.*/
+yaffs_obj_t *yaffs_link_obj(yaffs_obj_t *parent, const YCHAR *name,
+			yaffs_obj_t *equiv_obj)
+{
+	/* Get the real object in case we were fed a hard link as an equivalent object */
+	equiv_obj = yaffs_get_equivalent_obj(equiv_obj);
+
+	if (yaffs_create_obj
+	    (YAFFS_OBJECT_TYPE_HARDLINK, parent, name, 0, 0, 0,
+	     equiv_obj, NULL, 0)) {
+		return equiv_obj;
+	} else {
+		return NULL;
+	}
+
+}
+
+static int yaffs_change_obj_name(yaffs_obj_t *obj, yaffs_obj_t *new_dir,
+				const YCHAR *new_name, int force, int shadows)
+{
+	int unlinkOp;
+	int deleteOp;
+
+	yaffs_obj_t *existingTarget;
+
+	if (new_dir == NULL)
+		new_dir = obj->parent;	/* use the old directory */
+
+	if (new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_change_obj_name: new_dir is not a directory"
+		    TENDSTR)));
+		YBUG();
+	}
+
+	/* TODO: Do we need this different handling for YAFFS2 and YAFFS1?? */
+	if (obj->my_dev->param.is_yaffs2)
+		unlinkOp = (new_dir == obj->my_dev->unlinked_dir);
+	else
+		unlinkOp = (new_dir == obj->my_dev->unlinked_dir
+			    && obj->variant_type == YAFFS_OBJECT_TYPE_FILE);
+
+	deleteOp = (new_dir == obj->my_dev->del_dir);
+
+	existingTarget = yaffs_find_by_name(new_dir, new_name);
+
+	/* If the object is a file going into the unlinked directory,
+	 *   then it is OK to just stuff it in since duplicate names are allowed.
+	 *   else only proceed if the new name does not exist and if we're putting
+	 *   it into a directory.
+	 */
+	if ((unlinkOp ||
+	     deleteOp ||
+	     force ||
+	     (shadows > 0) ||
+	     !existingTarget) &&
+	    new_dir->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_set_obj_name(obj, new_name);
+		obj->dirty = 1;
+
+		yaffs_add_obj_to_dir(new_dir, obj);
+
+		if (unlinkOp)
+			obj->unlinked = 1;
+
+		/* If it is a deletion then we mark it as a shrink for gc purposes. */
+		if (yaffs_update_oh(obj, new_name, 0, deleteOp, shadows, NULL) >= 0)
+			return YAFFS_OK;
+	}
+
+	return YAFFS_FAIL;
+}
+
+int yaffs_rename_obj(yaffs_obj_t *old_dir, const YCHAR *old_name,
+		yaffs_obj_t *new_dir, const YCHAR *new_name)
+{
+	yaffs_obj_t *obj = NULL;
+	yaffs_obj_t *existingTarget = NULL;
+	int force = 0;
+	int result;
+	yaffs_dev_t *dev;
+
+
+	if (!old_dir || old_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		YBUG();
+	if (!new_dir || new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		YBUG();
+
+	dev = old_dir->my_dev;
+
+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+	/* Special case for case insemsitive systems (eg. WinCE).
+	 * While look-up is case insensitive, the name isn't.
+	 * Therefore we might want to change x.txt to X.txt
+	*/
+	if (old_dir == new_dir && yaffs_strcmp(old_name, new_name) == 0)
+		force = 1;
+#endif
+
+	if(yaffs_strnlen(new_name,YAFFS_MAX_NAME_LENGTH+1) > YAFFS_MAX_NAME_LENGTH)
+		/* ENAMETOOLONG */
+		return YAFFS_FAIL;
+
+	obj = yaffs_find_by_name(old_dir, old_name);
+
+	if (obj && obj->rename_allowed) {
+
+		/* Now do the handling for an existing target, if there is one */
+
+		existingTarget = yaffs_find_by_name(new_dir, new_name);
+		if (existingTarget &&
+			existingTarget->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+			!ylist_empty(&existingTarget->variant.dir_variant.children)) {
+			/* There is a target that is a non-empty directory, so we fail */
+			return YAFFS_FAIL;	/* EEXIST or ENOTEMPTY */
+		} else if (existingTarget && existingTarget != obj) {
+			/* Nuke the target first, using shadowing,
+			 * but only if it isn't the same object.
+			 *
+			 * Note we must disable gc otherwise it can mess up the shadowing.
+			 *
+			 */
+			dev->gc_disable=1;
+			yaffs_change_obj_name(obj, new_dir, new_name, force,
+						existingTarget->obj_id);
+			existingTarget->is_shadowed = 1;
+			yaffs_unlink_obj(existingTarget);
+			dev->gc_disable=0;
+		}
+
+		result = yaffs_change_obj_name(obj, new_dir, new_name, 1, 0);
+
+		yaffs_update_parent(old_dir);
+		if(new_dir != old_dir)
+			yaffs_update_parent(new_dir);
+		
+		return result;
+	}
+	return YAFFS_FAIL;
+}
+
+/*------------------------- Block Management and Page Allocation ----------------*/
+
+static int yaffs_init_blocks(yaffs_dev_t *dev)
+{
+	int nBlocks = dev->internal_end_block - dev->internal_start_block + 1;
+
+	dev->block_info = NULL;
+	dev->chunk_bits = NULL;
+
+	dev->alloc_block = -1;	/* force it to get a new one */
+
+	/* If the first allocation strategy fails, thry the alternate one */
+	dev->block_info = YMALLOC(nBlocks * sizeof(yaffs_block_info_t));
+	if (!dev->block_info) {
+		dev->block_info = YMALLOC_ALT(nBlocks * sizeof(yaffs_block_info_t));
+		dev->block_info_alt = 1;
+	} else
+		dev->block_info_alt = 0;
+
+	if (dev->block_info) {
+		/* Set up dynamic blockinfo stuff. */
+		dev->chunk_bit_stride = (dev->param.chunks_per_block + 7) / 8; /* round up bytes */
+		dev->chunk_bits = YMALLOC(dev->chunk_bit_stride * nBlocks);
+		if (!dev->chunk_bits) {
+			dev->chunk_bits = YMALLOC_ALT(dev->chunk_bit_stride * nBlocks);
+			dev->chunk_bits_alt = 1;
+		} else
+			dev->chunk_bits_alt = 0;
+	}
+
+	if (dev->block_info && dev->chunk_bits) {
+		memset(dev->block_info, 0, nBlocks * sizeof(yaffs_block_info_t));
+		memset(dev->chunk_bits, 0, dev->chunk_bit_stride * nBlocks);
+		return YAFFS_OK;
+	}
+
+	return YAFFS_FAIL;
+}
+
+static void yaffs_deinit_blocks(yaffs_dev_t *dev)
+{
+	if (dev->block_info_alt && dev->block_info)
+		YFREE_ALT(dev->block_info);
+	else if (dev->block_info)
+		YFREE(dev->block_info);
+
+	dev->block_info_alt = 0;
+
+	dev->block_info = NULL;
+
+	if (dev->chunk_bits_alt && dev->chunk_bits)
+		YFREE_ALT(dev->chunk_bits);
+	else if (dev->chunk_bits)
+		YFREE(dev->chunk_bits);
+	dev->chunk_bits_alt = 0;
+	dev->chunk_bits = NULL;
+}
+
+void yaffs_block_became_dirty(yaffs_dev_t *dev, int block_no)
+{
+	yaffs_block_info_t *bi = yaffs_get_block_info(dev, block_no);
+
+	int erasedOk = 0;
+
+	/* If the block is still healthy erase it and mark as clean.
+	 * If the block has had a data failure, then retire it.
+	 */
+
+	T(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
+		(TSTR("yaffs_block_became_dirty block %d state %d %s"TENDSTR),
+		block_no, bi->block_state, (bi->needs_retiring) ? "needs retiring" : ""));
+
+	yaffs2_clear_oldest_dirty_seq(dev,bi);
+
+	bi->block_state = YAFFS_BLOCK_STATE_DIRTY;
+
+	/* If this is the block being garbage collected then stop gc'ing this block */
+	if(block_no == dev->gc_block)
+		dev->gc_block = 0;
+
+	/* If this block is currently the best candidate for gc then drop as a candidate */
+	if(block_no == dev->gc_dirtiest){
+		dev->gc_dirtiest = 0;
+		dev->gc_pages_in_use = 0;
+	}
+
+	if (!bi->needs_retiring) {
+		yaffs2_checkpt_invalidate(dev);
+		erasedOk = yaffs_erase_block(dev, block_no);
+		if (!erasedOk) {
+			dev->n_erase_failures++;
+			T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+			  (TSTR("**>> Erasure failed %d" TENDSTR), block_no));
+		}
+	}
+
+	if (erasedOk &&
+	    ((yaffs_trace_mask & YAFFS_TRACE_ERASE) || !yaffs_skip_verification(dev))) {
+		int i;
+		for (i = 0; i < dev->param.chunks_per_block; i++) {
+			if (!yaffs_check_chunk_erased
+			    (dev, block_no * dev->param.chunks_per_block + i)) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   (">>Block %d erasure supposedly OK, but chunk %d not erased"
+				    TENDSTR), block_no, i));
+			}
+		}
+	}
+
+	if (erasedOk) {
+		/* Clean it up... */
+		bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+		bi->seq_number = 0;
+		dev->n_erased_blocks++;
+		bi->pages_in_use = 0;
+		bi->soft_del_pages = 0;
+		bi->has_shrink_hdr = 0;
+		bi->skip_erased_check = 1;  /* This is clean, so no need to check */
+		bi->gc_prioritise = 0;
+		yaffs_clear_chunk_bits(dev, block_no);
+
+		T(YAFFS_TRACE_ERASE,
+		  (TSTR("Erased block %d" TENDSTR), block_no));
+	} else {
+		dev->n_free_chunks -= dev->param.chunks_per_block;	/* We lost a block of free space */
+
+		yaffs_retire_block(dev, block_no);
+		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		  (TSTR("**>> Block %d retired" TENDSTR), block_no));
+	}
+}
+
+static int yaffs_find_alloc_block(yaffs_dev_t *dev)
+{
+	int i;
+
+	yaffs_block_info_t *bi;
+
+	if (dev->n_erased_blocks < 1) {
+		/* Hoosterman we've got a problem.
+		 * Can't get space to gc
+		 */
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR("yaffs tragedy: no more erased blocks" TENDSTR)));
+
+		return -1;
+	}
+
+	/* Find an empty block. */
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		dev->alloc_block_finder++;
+		if (dev->alloc_block_finder < dev->internal_start_block
+		    || dev->alloc_block_finder > dev->internal_end_block) {
+			dev->alloc_block_finder = dev->internal_start_block;
+		}
+
+		bi = yaffs_get_block_info(dev, dev->alloc_block_finder);
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+			bi->block_state = YAFFS_BLOCK_STATE_ALLOCATING;
+			dev->seq_number++;
+			bi->seq_number = dev->seq_number;
+			dev->n_erased_blocks--;
+			T(YAFFS_TRACE_ALLOCATE,
+			  (TSTR("Allocated block %d, seq  %d, %d left" TENDSTR),
+			   dev->alloc_block_finder, dev->seq_number,
+			   dev->n_erased_blocks));
+			return dev->alloc_block_finder;
+		}
+	}
+
+	T(YAFFS_TRACE_ALWAYS,
+	  (TSTR
+	   ("yaffs tragedy: no more erased blocks, but there should have been %d"
+	    TENDSTR), dev->n_erased_blocks));
+
+	return -1;
+}
+
+
+/*
+ * Check if there's space to allocate...
+ * Thinks.... do we need top make this ths same as yaffs_get_free_chunks()?
+ */
+int yaffs_check_alloc_available(yaffs_dev_t *dev, int n_chunks)
+{
+	int reservedChunks;
+	int reservedBlocks = dev->param.n_reserved_blocks;
+	int checkpointBlocks;
+
+	checkpointBlocks = yaffs_calc_checkpt_blocks_required(dev);
+
+	reservedChunks = ((reservedBlocks + checkpointBlocks) * dev->param.chunks_per_block);
+
+	return (dev->n_free_chunks > (reservedChunks + n_chunks));
+}
+
+static int yaffs_alloc_chunk(yaffs_dev_t *dev, int useReserve,
+		yaffs_block_info_t **blockUsedPtr)
+{
+	int retVal;
+	yaffs_block_info_t *bi;
+
+	if (dev->alloc_block < 0) {
+		/* Get next block to allocate off */
+		dev->alloc_block = yaffs_find_alloc_block(dev);
+		dev->alloc_page = 0;
+	}
+
+	if (!useReserve && !yaffs_check_alloc_available(dev, 1)) {
+		/* Not enough space to allocate unless we're allowed to use the reserve. */
+		return -1;
+	}
+
+	if (dev->n_erased_blocks < dev->param.n_reserved_blocks
+			&& dev->alloc_page == 0) {
+		T(YAFFS_TRACE_ALLOCATE, (TSTR("Allocating reserve" TENDSTR)));
+	}
+
+	/* Next page please.... */
+	if (dev->alloc_block >= 0) {
+		bi = yaffs_get_block_info(dev, dev->alloc_block);
+
+		retVal = (dev->alloc_block * dev->param.chunks_per_block) +
+			dev->alloc_page;
+		bi->pages_in_use++;
+		yaffs_set_chunk_bit(dev, dev->alloc_block,
+				dev->alloc_page);
+
+		dev->alloc_page++;
+
+		dev->n_free_chunks--;
+
+		/* If the block is full set the state to full */
+		if (dev->alloc_page >= dev->param.chunks_per_block) {
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+
+		if (blockUsedPtr)
+			*blockUsedPtr = bi;
+
+		return retVal;
+	}
+
+	T(YAFFS_TRACE_ERROR,
+			(TSTR("!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!" TENDSTR)));
+
+	return -1;
+}
+
+static int yaffs_get_erased_chunks(yaffs_dev_t *dev)
+{
+	int n;
+
+	n = dev->n_erased_blocks * dev->param.chunks_per_block;
+
+	if (dev->alloc_block > 0)
+		n += (dev->param.chunks_per_block - dev->alloc_page);
+
+	return n;
+
+}
+
+/*
+ * yaffs_skip_rest_of_block() skips over the rest of the allocation block
+ * if we don't want to write to it.
+ */
+void yaffs_skip_rest_of_block(yaffs_dev_t *dev)
+{
+	if(dev->alloc_block > 0){
+		yaffs_block_info_t *bi = yaffs_get_block_info(dev, dev->alloc_block);
+		if(bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING){
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+	}
+}
+
+
+static int yaffs_gc_block(yaffs_dev_t *dev, int block,
+		int wholeBlock)
+{
+	int oldChunk;
+	int newChunk;
+	int mark_flash;
+	int retVal = YAFFS_OK;
+	int i;
+	int isCheckpointBlock;
+	int matchingChunk;
+	int maxCopies;
+
+	int chunksBefore = yaffs_get_erased_chunks(dev);
+	int chunksAfter;
+
+	yaffs_ext_tags tags;
+
+	yaffs_block_info_t *bi = yaffs_get_block_info(dev, block);
+
+	yaffs_obj_t *object;
+
+	isCheckpointBlock = (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT);
+
+
+	T(YAFFS_TRACE_TRACING,
+			(TSTR("Collecting block %d, in use %d, shrink %d, wholeBlock %d" TENDSTR),
+			 block,
+			 bi->pages_in_use,
+			 bi->has_shrink_hdr,
+			 wholeBlock));
+
+	/*yaffs_verify_free_chunks(dev); */
+
+	if(bi->block_state == YAFFS_BLOCK_STATE_FULL)
+		bi->block_state = YAFFS_BLOCK_STATE_COLLECTING;
+	
+	bi->has_shrink_hdr = 0;	/* clear the flag so that the block can erase */
+
+	dev->gc_disable = 1;
+
+	if (isCheckpointBlock ||
+			!yaffs_still_some_chunks(dev, block)) {
+		T(YAFFS_TRACE_TRACING,
+				(TSTR
+				 ("Collecting block %d that has no chunks in use" TENDSTR),
+				 block));
+		yaffs_block_became_dirty(dev, block);
+	} else {
+
+		__u8 *buffer = yaffs_get_temp_buffer(dev, __LINE__);
+
+		yaffs_verify_blk(dev, bi, block);
+
+		maxCopies = (wholeBlock) ? dev->param.chunks_per_block : 5;
+		oldChunk = block * dev->param.chunks_per_block + dev->gc_chunk;
+
+		for (/* init already done */;
+		     retVal == YAFFS_OK &&
+		     dev->gc_chunk < dev->param.chunks_per_block &&
+		     (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) &&
+		     maxCopies > 0;
+		     dev->gc_chunk++, oldChunk++) {
+			if (yaffs_check_chunk_bit(dev, block, dev->gc_chunk)) {
+
+				/* This page is in use and might need to be copied off */
+
+				maxCopies--;
+
+				mark_flash = 1;
+
+				yaffs_init_tags(&tags);
+
+				yaffs_rd_chunk_tags_nand(dev, oldChunk,
+								buffer, &tags);
+
+				object =
+				    yaffs_find_by_number(dev,
+							     tags.obj_id);
+
+				T(YAFFS_TRACE_GC_DETAIL,
+				  (TSTR
+				   ("Collecting chunk in block %d, %d %d %d " TENDSTR),
+				   dev->gc_chunk, tags.obj_id, tags.chunk_id,
+				   tags.n_bytes));
+
+				if (object && !yaffs_skip_verification(dev)) {
+					if (tags.chunk_id == 0)
+						matchingChunk = object->hdr_chunk;
+					else if (object->soft_del)
+						matchingChunk = oldChunk; /* Defeat the test */
+					else
+						matchingChunk = yaffs_find_chunk_in_file(object, tags.chunk_id, NULL);
+
+					if (oldChunk != matchingChunk)
+						T(YAFFS_TRACE_ERROR,
+						  (TSTR("gc: page in gc mismatch: %d %d %d %d"TENDSTR),
+						  oldChunk, matchingChunk, tags.obj_id, tags.chunk_id));
+
+				}
+
+				if (!object) {
+					T(YAFFS_TRACE_ERROR,
+					  (TSTR
+					   ("page %d in gc has no object: %d %d %d "
+					    TENDSTR), oldChunk,
+					    tags.obj_id, tags.chunk_id, tags.n_bytes));
+				}
+
+				if (object &&
+				    object->deleted &&
+				    object->soft_del &&
+				    tags.chunk_id != 0) {
+					/* Data chunk in a soft deleted file, throw it away
+					 * It's a soft deleted data chunk,
+					 * No need to copy this, just forget about it and
+					 * fix up the object.
+					 */
+					 
+					/* Free chunks already includes softdeleted chunks.
+					 * How ever this chunk is going to soon be really deleted
+					 * which will increment free chunks.
+					 * We have to decrement free chunks so this works out properly.
+					 */
+					dev->n_free_chunks--;
+					bi->soft_del_pages--;
+
+					object->n_data_chunks--;
+
+					if (object->n_data_chunks <= 0) {
+						/* remeber to clean up the object */
+						dev->gc_cleanup_list[dev->n_clean_ups] =
+						    tags.obj_id;
+						dev->n_clean_ups++;
+					}
+					mark_flash = 0;
+				} else if (0) {
+					/* Todo object && object->deleted && object->n_data_chunks == 0 */
+					/* Deleted object header with no data chunks.
+					 * Can be discarded and the file deleted.
+					 */
+					object->hdr_chunk = 0;
+					yaffs_free_tnode(object->my_dev,
+							object->variant.
+							file_variant.top);
+					object->variant.file_variant.top = NULL;
+					yaffs_generic_obj_del(object);
+
+				} else if (object) {
+					/* It's either a data chunk in a live file or
+					 * an ObjectHeader, so we're interested in it.
+					 * NB Need to keep the ObjectHeaders of deleted files
+					 * until the whole file has been deleted off
+					 */
+					tags.serial_number++;
+
+					dev->n_gc_copies++;
+
+					if (tags.chunk_id == 0) {
+						/* It is an object Id,
+						 * We need to nuke the shrinkheader flags first
+						 * Also need to clean up shadowing.
+						 * We no longer want the shrinkHeader flag since its work is done
+						 * and if it is left in place it will mess up scanning.
+						 */
+
+						yaffs_obj_header *oh;
+						oh = (yaffs_obj_header *)buffer;
+
+						oh->is_shrink = 0;
+						tags.extra_is_shrink = 0;
+
+						oh->shadows_obj = 0;
+						oh->inband_shadowed_obj_id = 0;
+						tags.extra_shadows = 0;
+
+						/* Update file size */
+						if(object->variant_type == YAFFS_OBJECT_TYPE_FILE){
+							oh->file_size = object->variant.file_variant.file_size;
+							tags.extra_length = oh->file_size;
+						}
+
+						yaffs_verify_oh(object, oh, &tags, 1);
+						newChunk =
+						    yaffs_write_new_chunk(dev,(__u8 *) oh, &tags, 1);
+					} else
+						newChunk =
+						    yaffs_write_new_chunk(dev, buffer, &tags, 1);
+
+					if (newChunk < 0) {
+						retVal = YAFFS_FAIL;
+					} else {
+
+						/* Ok, now fix up the Tnodes etc. */
+
+						if (tags.chunk_id == 0) {
+							/* It's a header */
+							object->hdr_chunk =  newChunk;
+							object->serial =   tags.serial_number;
+						} else {
+							/* It's a data chunk */
+							int ok;
+							ok = yaffs_put_chunk_in_file
+							    (object,
+							     tags.chunk_id,
+							     newChunk, 0);
+						}
+					}
+				}
+
+				if (retVal == YAFFS_OK)
+					yaffs_chunk_del(dev, oldChunk, mark_flash, __LINE__);
+
+			}
+		}
+
+		yaffs_release_temp_buffer(dev, buffer, __LINE__);
+
+
+
+	}
+
+	yaffs_verify_collected_blk(dev, bi, block);
+
+
+
+	if (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
+		/*
+		 * The gc did not complete. Set block state back to FULL
+		 * because checkpointing does not restore gc.
+		 */
+		bi->block_state = YAFFS_BLOCK_STATE_FULL;
+	} else {
+		/* The gc completed. */
+		/* Do any required cleanups */
+		for (i = 0; i < dev->n_clean_ups; i++) {
+			/* Time to delete the file too */
+			object =
+			    yaffs_find_by_number(dev,
+						     dev->gc_cleanup_list[i]);
+			if (object) {
+				yaffs_free_tnode(dev,
+						object->variant.file_variant.
+						top);
+				object->variant.file_variant.top = NULL;
+				T(YAFFS_TRACE_GC,
+				  (TSTR
+				   ("yaffs: About to finally delete object %d"
+				    TENDSTR), object->obj_id));
+				yaffs_generic_obj_del(object);
+				object->my_dev->n_deleted_files--;
+			}
+
+		}
+
+
+		chunksAfter = yaffs_get_erased_chunks(dev);
+		if (chunksBefore >= chunksAfter) {
+			T(YAFFS_TRACE_GC,
+			  (TSTR
+			   ("gc did not increase free chunks before %d after %d"
+			    TENDSTR), chunksBefore, chunksAfter));
+		}
+		dev->gc_block = 0;
+		dev->gc_chunk = 0;
+		dev->n_clean_ups = 0;
+	}
+
+	dev->gc_disable = 0;
+
+	return retVal;
+}
+
+/*
+ * FindBlockForgarbageCollection is used to select the dirtiest block (or close enough)
+ * for garbage collection.
+ */
+
+static unsigned yaffs_find_gc_block(yaffs_dev_t *dev,
+					int aggressive,
+					int background)
+{
+	int i;
+	int iterations;
+	unsigned selected = 0;
+	int prioritised = 0;
+	int prioritisedExists = 0;
+	yaffs_block_info_t *bi;
+	int threshold;
+
+	/* First let's see if we need to grab a prioritised block */
+	if (dev->has_pending_prioritised_gc && !aggressive) {
+		dev->gc_dirtiest = 0;
+		bi = dev->block_info;
+		for (i = dev->internal_start_block;
+			i <= dev->internal_end_block && !selected;
+			i++) {
+
+			if (bi->gc_prioritise) {
+				prioritisedExists = 1;
+				if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
+				   yaffs_block_ok_for_gc(dev, bi)) {
+					selected = i;
+					prioritised = 1;
+				}
+			}
+			bi++;
+		}
+
+		/*
+		 * If there is a prioritised block and none was selected then
+		 * this happened because there is at least one old dirty block gumming
+		 * up the works. Let's gc the oldest dirty block.
+		 */
+
+		if(prioritisedExists &&
+			!selected &&
+			dev->oldest_dirty_block > 0)
+			selected = dev->oldest_dirty_block;
+
+		if (!prioritisedExists) /* None found, so we can clear this */
+			dev->has_pending_prioritised_gc = 0;
+	}
+
+	/* If we're doing aggressive GC then we are happy to take a less-dirty block, and
+	 * search harder.
+	 * else (we're doing a leasurely gc), then we only bother to do this if the
+	 * block has only a few pages in use.
+	 */
+
+	if (!selected){
+		int pagesUsed;
+		int nBlocks = dev->internal_end_block - dev->internal_start_block + 1;
+		if (aggressive){
+			threshold = dev->param.chunks_per_block;
+			iterations = nBlocks;
+		} else {
+			int maxThreshold;
+
+			if(background)
+				maxThreshold = dev->param.chunks_per_block/2;
+			else
+				maxThreshold = dev->param.chunks_per_block/8;
+
+			if(maxThreshold <  YAFFS_GC_PASSIVE_THRESHOLD)
+				maxThreshold = YAFFS_GC_PASSIVE_THRESHOLD;
+
+			threshold = background ?
+				(dev->gc_not_done + 2) * 2 : 0;
+			if(threshold <YAFFS_GC_PASSIVE_THRESHOLD)
+				threshold = YAFFS_GC_PASSIVE_THRESHOLD;
+			if(threshold > maxThreshold)
+				threshold = maxThreshold;
+
+			iterations = nBlocks / 16 + 1;
+			if (iterations > 100)
+				iterations = 100;
+		}
+
+		for (i = 0;
+			i < iterations &&
+			(dev->gc_dirtiest < 1 ||
+				dev->gc_pages_in_use > YAFFS_GC_GOOD_ENOUGH);
+			i++) {
+			dev->gc_block_finder++;
+			if (dev->gc_block_finder < dev->internal_start_block ||
+				dev->gc_block_finder > dev->internal_end_block)
+				dev->gc_block_finder = dev->internal_start_block;
+
+			bi = yaffs_get_block_info(dev, dev->gc_block_finder);
+
+			pagesUsed = bi->pages_in_use - bi->soft_del_pages;
+
+			if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
+				pagesUsed < dev->param.chunks_per_block &&
+				(dev->gc_dirtiest < 1 || pagesUsed < dev->gc_pages_in_use) &&
+				yaffs_block_ok_for_gc(dev, bi)) {
+				dev->gc_dirtiest = dev->gc_block_finder;
+				dev->gc_pages_in_use = pagesUsed;
+			}
+		}
+
+		if(dev->gc_dirtiest > 0 && dev->gc_pages_in_use <= threshold)
+			selected = dev->gc_dirtiest;
+	}
+
+	/*
+	 * If nothing has been selected for a while, try selecting the oldest dirty
+	 * because that's gumming up the works.
+	 */
+
+	if(!selected && dev->param.is_yaffs2 &&
+		dev->gc_not_done >= ( background ? 10 : 20)){
+		yaffs2_find_oldest_dirty_seq(dev);
+		if(dev->oldest_dirty_block > 0) {
+			selected = dev->oldest_dirty_block;
+			dev->gc_dirtiest = selected;
+			dev->oldest_dirty_gc_count++;
+			bi = yaffs_get_block_info(dev, selected);
+			dev->gc_pages_in_use =  bi->pages_in_use - bi->soft_del_pages;
+		} else
+			dev->gc_not_done = 0;
+	}
+
+	if(selected){
+		T(YAFFS_TRACE_GC,
+		  (TSTR("GC Selected block %d with %d free, prioritised:%d" TENDSTR),
+		  selected,
+		  dev->param.chunks_per_block - dev->gc_pages_in_use,
+		  prioritised));
+
+		dev->n_gc_blocks++;
+		if(background)
+			dev->bg_gcs++;
+
+		dev->gc_dirtiest = 0;
+		dev->gc_pages_in_use = 0;
+		dev->gc_not_done = 0;
+		if(dev->refresh_skip > 0)
+			dev->refresh_skip--;
+	} else{
+		dev->gc_not_done++;
+		T(YAFFS_TRACE_GC,
+		  (TSTR("GC none: finder %d skip %d threshold %d dirtiest %d using %d oldest %d%s" TENDSTR),
+		  dev->gc_block_finder, dev->gc_not_done,
+		  threshold,
+		  dev->gc_dirtiest, dev->gc_pages_in_use,
+		  dev->oldest_dirty_block,
+		  background ? " bg" : ""));
+	}
+
+	return selected;
+}
+
+/* New garbage collector
+ * If we're very low on erased blocks then we do aggressive garbage collection
+ * otherwise we do "leasurely" garbage collection.
+ * Aggressive gc looks further (whole array) and will accept less dirty blocks.
+ * Passive gc only inspects smaller areas and will only accept more dirty blocks.
+ *
+ * The idea is to help clear out space in a more spread-out manner.
+ * Dunno if it really does anything useful.
+ */
+static int yaffs_check_gc(yaffs_dev_t *dev, int background)
+{
+	int aggressive = 0;
+	int gcOk = YAFFS_OK;
+	int maxTries = 0;
+	int minErased;
+	int erasedChunks;
+	int checkpointBlockAdjust;
+
+	if(dev->param.gc_control &&
+		(dev->param.gc_control(dev) & 1) == 0)
+		return YAFFS_OK;
+
+	if (dev->gc_disable) {
+		/* Bail out so we don't get recursive gc */
+		return YAFFS_OK;
+	}
+
+	/* This loop should pass the first time.
+	 * We'll only see looping here if the collection does not increase space.
+	 */
+
+	do {
+		maxTries++;
+
+		checkpointBlockAdjust = yaffs_calc_checkpt_blocks_required(dev);
+
+		minErased  = dev->param.n_reserved_blocks + checkpointBlockAdjust + 1;
+		erasedChunks = dev->n_erased_blocks * dev->param.chunks_per_block;
+
+		/* If we need a block soon then do aggressive gc.*/
+		if (dev->n_erased_blocks < minErased)
+			aggressive = 1;
+		else {
+			if(!background && erasedChunks > (dev->n_free_chunks / 4))
+				break;
+
+			if(dev->gc_skip > 20)
+				dev->gc_skip = 20;
+			if(erasedChunks < dev->n_free_chunks/2 ||
+				dev->gc_skip < 1 ||
+				background)
+				aggressive = 0;
+			else {
+				dev->gc_skip--;
+				break;
+			}
+		}
+
+		dev->gc_skip = 5;
+
+                /* If we don't already have a block being gc'd then see if we should start another */
+
+		if (dev->gc_block < 1 && !aggressive) {
+			dev->gc_block = yaffs2_find_refresh_block(dev);
+			dev->gc_chunk = 0;
+			dev->n_clean_ups=0;
+		}
+		if (dev->gc_block < 1) {
+			dev->gc_block = yaffs_find_gc_block(dev, aggressive, background);
+			dev->gc_chunk = 0;
+			dev->n_clean_ups=0;
+		}
+
+		if (dev->gc_block > 0) {
+			dev->all_gcs++;
+			if (!aggressive)
+				dev->passive_gc_count++;
+
+			T(YAFFS_TRACE_GC,
+			  (TSTR
+			   ("yaffs: GC erasedBlocks %d aggressive %d" TENDSTR),
+			   dev->n_erased_blocks, aggressive));
+
+			gcOk = yaffs_gc_block(dev, dev->gc_block, aggressive);
+		}
+
+		if (dev->n_erased_blocks < (dev->param.n_reserved_blocks) && dev->gc_block > 0) {
+			T(YAFFS_TRACE_GC,
+			  (TSTR
+			   ("yaffs: GC !!!no reclaim!!! erasedBlocks %d after try %d block %d"
+			    TENDSTR), dev->n_erased_blocks, maxTries, dev->gc_block));
+		}
+	} while ((dev->n_erased_blocks < dev->param.n_reserved_blocks) &&
+		 (dev->gc_block > 0) &&
+		 (maxTries < 2));
+
+	return aggressive ? gcOk : YAFFS_OK;
+}
+
+/*
+ * yaffs_bg_gc()
+ * Garbage collects. Intended to be called from a background thread.
+ * Returns non-zero if at least half the free chunks are erased.
+ */
+int yaffs_bg_gc(yaffs_dev_t *dev, unsigned urgency)
+{
+	int erasedChunks = dev->n_erased_blocks * dev->param.chunks_per_block;
+
+	T(YAFFS_TRACE_BACKGROUND, (TSTR("Background gc %u" TENDSTR),urgency));
+
+	yaffs_check_gc(dev, 1);
+	return erasedChunks > dev->n_free_chunks/2;
+}
+
+/*-------------------------  TAGS --------------------------------*/
+
+static int yaffs_tags_match(const yaffs_ext_tags *tags, int obj_id,
+			   int chunkInObject)
+{
+	return (tags->chunk_id == chunkInObject &&
+		tags->obj_id == obj_id && !tags->is_deleted) ? 1 : 0;
+
+}
+
+
+/*-------------------- Data file manipulation -----------------*/
+
+static int yaffs_find_chunk_in_file(yaffs_obj_t *in, int inode_chunk,
+				 yaffs_ext_tags *tags)
+{
+	/*Get the Tnode, then get the level 0 offset chunk offset */
+	yaffs_tnode_t *tn;
+	int theChunk = -1;
+	yaffs_ext_tags localTags;
+	int retVal = -1;
+
+	yaffs_dev_t *dev = in->my_dev;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &localTags;
+	}
+
+	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
+
+	if (tn) {
+		theChunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+		retVal =
+		    yaffs_find_chunk_in_group(dev, theChunk, tags, in->obj_id,
+					   inode_chunk);
+	}
+	return retVal;
+}
+
+static int yaffs_find_del_file_chunk(yaffs_obj_t *in, int inode_chunk,
+					  yaffs_ext_tags *tags)
+{
+	/* Get the Tnode, then get the level 0 offset chunk offset */
+	yaffs_tnode_t *tn;
+	int theChunk = -1;
+	yaffs_ext_tags localTags;
+
+	yaffs_dev_t *dev = in->my_dev;
+	int retVal = -1;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &localTags;
+	}
+
+	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
+
+	if (tn) {
+
+		theChunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+		retVal =
+		    yaffs_find_chunk_in_group(dev, theChunk, tags, in->obj_id,
+					   inode_chunk);
+
+		/* Delete the entry in the filestructure (if found) */
+		if (retVal != -1)
+			yaffs_load_tnode_0(dev, tn, inode_chunk, 0);
+	}
+
+	return retVal;
+}
+
+
+int yaffs_put_chunk_in_file(yaffs_obj_t *in, int inode_chunk,
+			        int nand_chunk, int in_scan)
+{
+	/* NB in_scan is zero unless scanning.
+	 * For forward scanning, in_scan is > 0;
+	 * for backward scanning in_scan is < 0
+	 *
+	 * nand_chunk = 0 is a dummy insert to make sure the tnodes are there.
+	 */
+
+	yaffs_tnode_t *tn;
+	yaffs_dev_t *dev = in->my_dev;
+	int existingChunk;
+	yaffs_ext_tags existingTags;
+	yaffs_ext_tags newTags;
+	unsigned existingSerial, newSerial;
+
+	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE) {
+		/* Just ignore an attempt at putting a chunk into a non-file during scanning
+		 * If it is not during Scanning then something went wrong!
+		 */
+		if (!in_scan) {
+			T(YAFFS_TRACE_ERROR,
+			  (TSTR
+			   ("yaffs tragedy:attempt to put data chunk into a non-file"
+			    TENDSTR)));
+			YBUG();
+		}
+
+		yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+		return YAFFS_OK;
+	}
+
+	tn = yaffs_add_find_tnode_0(dev,
+					&in->variant.file_variant,
+					inode_chunk,
+					NULL);
+	if (!tn)
+		return YAFFS_FAIL;
+	
+	if(!nand_chunk)
+		/* Dummy insert, bail now */
+		return YAFFS_OK;
+
+	existingChunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	if (in_scan != 0) {
+		/* If we're scanning then we need to test for duplicates
+		 * NB This does not need to be efficient since it should only ever
+		 * happen when the power fails during a write, then only one
+		 * chunk should ever be affected.
+		 *
+		 * Correction for YAFFS2: This could happen quite a lot and we need to think about efficiency! TODO
+		 * Update: For backward scanning we don't need to re-read tags so this is quite cheap.
+		 */
+
+		if (existingChunk > 0) {
+			/* NB Right now existing chunk will not be real chunk_id if the chunk group size > 1
+			 *    thus we have to do a FindChunkInFile to get the real chunk id.
+			 *
+			 * We have a duplicate now we need to decide which one to use:
+			 *
+			 * Backwards scanning YAFFS2: The old one is what we use, dump the new one.
+			 * Forward scanning YAFFS2: The new one is what we use, dump the old one.
+			 * YAFFS1: Get both sets of tags and compare serial numbers.
+			 */
+
+			if (in_scan > 0) {
+				/* Only do this for forward scanning */
+				yaffs_rd_chunk_tags_nand(dev,
+								nand_chunk,
+								NULL, &newTags);
+
+				/* Do a proper find */
+				existingChunk =
+				    yaffs_find_chunk_in_file(in, inode_chunk,
+							  &existingTags);
+			}
+
+			if (existingChunk <= 0) {
+				/*Hoosterman - how did this happen? */
+
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("yaffs tragedy: existing chunk < 0 in scan"
+				    TENDSTR)));
+
+			}
+
+			/* NB The deleted flags should be false, otherwise the chunks will
+			 * not be loaded during a scan
+			 */
+
+			if (in_scan > 0) {
+				newSerial = newTags.serial_number;
+				existingSerial = existingTags.serial_number;
+			}
+
+			if ((in_scan > 0) &&
+			    (existingChunk <= 0 ||
+			     ((existingSerial + 1) & 3) == newSerial)) {
+				/* Forward scanning.
+				 * Use new
+				 * Delete the old one and drop through to update the tnode
+				 */
+				yaffs_chunk_del(dev, existingChunk, 1,
+						  __LINE__);
+			} else {
+				/* Backward scanning or we want to use the existing one
+				 * Use existing.
+				 * Delete the new one and return early so that the tnode isn't changed
+				 */
+				yaffs_chunk_del(dev, nand_chunk, 1,
+						  __LINE__);
+				return YAFFS_OK;
+			}
+		}
+
+	}
+
+	if (existingChunk == 0)
+		in->n_data_chunks++;
+
+	yaffs_load_tnode_0(dev, tn, inode_chunk, nand_chunk);
+
+	return YAFFS_OK;
+}
+
+static int yaffs_rd_data_obj(yaffs_obj_t *in, int inode_chunk,
+					__u8 *buffer)
+{
+	int nand_chunk = yaffs_find_chunk_in_file(in, inode_chunk, NULL);
+
+	if (nand_chunk >= 0)
+		return yaffs_rd_chunk_tags_nand(in->my_dev, nand_chunk,
+						buffer, NULL);
+	else {
+		T(YAFFS_TRACE_NANDACCESS,
+		  (TSTR("Chunk %d not found zero instead" TENDSTR),
+		   nand_chunk));
+		/* get sane (zero) data if you read a hole */
+		memset(buffer, 0, in->my_dev->data_bytes_per_chunk);
+		return 0;
+	}
+
+}
+
+void yaffs_chunk_del(yaffs_dev_t *dev, int chunk_id, int mark_flash, int lyn)
+{
+	int block;
+	int page;
+	yaffs_ext_tags tags;
+	yaffs_block_info_t *bi;
+
+	if (chunk_id <= 0)
+		return;
+
+	dev->n_deletions++;
+	block = chunk_id / dev->param.chunks_per_block;
+	page = chunk_id % dev->param.chunks_per_block;
+
+
+	if (!yaffs_check_chunk_bit(dev, block, page))
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Deleting invalid chunk %d"TENDSTR),
+			 chunk_id));
+
+	bi = yaffs_get_block_info(dev, block);
+	
+	yaffs2_update_oldest_dirty_seq(dev, block, bi);
+
+	T(YAFFS_TRACE_DELETION,
+	  (TSTR("line %d delete of chunk %d" TENDSTR), lyn, chunk_id));
+
+	if (!dev->param.is_yaffs2 && mark_flash &&
+	    bi->block_state != YAFFS_BLOCK_STATE_COLLECTING) {
+
+		yaffs_init_tags(&tags);
+
+		tags.is_deleted = 1;
+
+		yaffs_wr_chunk_tags_nand(dev, chunk_id, NULL, &tags);
+		yaffs_handle_chunk_update(dev, chunk_id, &tags);
+	} else {
+		dev->n_unmarked_deletions++;
+	}
+
+	/* Pull out of the management area.
+	 * If the whole block became dirty, this will kick off an erasure.
+	 */
+	if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING ||
+	    bi->block_state == YAFFS_BLOCK_STATE_FULL ||
+	    bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+	    bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
+		dev->n_free_chunks++;
+
+		yaffs_clear_chunk_bit(dev, block, page);
+
+		bi->pages_in_use--;
+
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state != YAFFS_BLOCK_STATE_ALLOCATING &&
+		    bi->block_state != YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+			yaffs_block_became_dirty(dev, block);
+		}
+
+	}
+
+}
+
+static int yaffs_wr_data_obj(yaffs_obj_t *in, int inode_chunk,
+					const __u8 *buffer, int n_bytes,
+					int useReserve)
+{
+	/* Find old chunk Need to do this to get serial number
+	 * Write new one and patch into tree.
+	 * Invalidate old tags.
+	 */
+
+	int prevChunkId;
+	yaffs_ext_tags prevTags;
+
+	int newChunkId;
+	yaffs_ext_tags newTags;
+
+	yaffs_dev_t *dev = in->my_dev;
+
+	yaffs_check_gc(dev,0);
+
+	/* Get the previous chunk at this location in the file if it exists.
+	 * If it does not exist then put a zero into the tree. This creates
+	 * the tnode now, rather than later when it is harder to clean up.
+	 */
+	prevChunkId = yaffs_find_chunk_in_file(in, inode_chunk, &prevTags);
+	if(prevChunkId < 1 &&
+		!yaffs_put_chunk_in_file(in, inode_chunk, 0, 0))
+		return 0;
+
+	/* Set up new tags */
+	yaffs_init_tags(&newTags);
+
+	newTags.chunk_id = inode_chunk;
+	newTags.obj_id = in->obj_id;
+	newTags.serial_number =
+	    (prevChunkId > 0) ? prevTags.serial_number + 1 : 1;
+	newTags.n_bytes = n_bytes;
+
+	if (n_bytes < 1 || n_bytes > dev->param.total_bytes_per_chunk) {
+		T(YAFFS_TRACE_ERROR,
+		(TSTR("Writing %d bytes to chunk!!!!!!!!!" TENDSTR), n_bytes));
+		YBUG();
+	}
+	
+		
+	newChunkId =
+	    yaffs_write_new_chunk(dev, buffer, &newTags,
+					      useReserve);
+
+	if (newChunkId > 0) {
+		yaffs_put_chunk_in_file(in, inode_chunk, newChunkId, 0);
+
+		if (prevChunkId > 0)
+			yaffs_chunk_del(dev, prevChunkId, 1, __LINE__);
+
+		yaffs_verify_file_sane(in);
+	}
+	return newChunkId;
+
+}
+
+/* UpdateObjectHeader updates the header on NAND for an object.
+ * If name is not NULL, then that new name is used.
+ */
+int yaffs_update_oh(yaffs_obj_t *in, const YCHAR *name, int force,
+			     int is_shrink, int shadows, yaffs_xattr_mod *xmod)
+{
+
+	yaffs_block_info_t *bi;
+
+	yaffs_dev_t *dev = in->my_dev;
+
+	int prevChunkId;
+	int retVal = 0;
+	int result = 0;
+
+	int newChunkId;
+	yaffs_ext_tags newTags;
+	yaffs_ext_tags oldTags;
+	const YCHAR *alias = NULL;
+
+	__u8 *buffer = NULL;
+	YCHAR old_name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	yaffs_obj_header *oh = NULL;
+
+	yaffs_strcpy(old_name, _Y("silly old name"));
+
+
+	if (!in->fake ||
+		in == dev->root_dir || /* The root_dir should also be saved */
+		force  || xmod) {
+
+		yaffs_check_gc(dev,0);
+		yaffs_check_obj_details_loaded(in);
+
+		buffer = yaffs_get_temp_buffer(in->my_dev, __LINE__);
+		oh = (yaffs_obj_header *) buffer;
+
+		prevChunkId = in->hdr_chunk;
+
+		if (prevChunkId > 0) {
+			result = yaffs_rd_chunk_tags_nand(dev, prevChunkId,
+							buffer, &oldTags);
+
+			yaffs_verify_oh(in, oh, &oldTags, 0);
+
+			memcpy(old_name, oh->name, sizeof(oh->name));
+			memset(buffer, 0xFF, sizeof(yaffs_obj_header));
+		} else
+			memset(buffer, 0xFF, dev->data_bytes_per_chunk);
+
+		oh->type = in->variant_type;
+		oh->yst_mode = in->yst_mode;
+		oh->shadows_obj = oh->inband_shadowed_obj_id = shadows;
+
+#ifdef CONFIG_YAFFS_WINCE
+		oh->win_atime[0] = in->win_atime[0];
+		oh->win_ctime[0] = in->win_ctime[0];
+		oh->win_mtime[0] = in->win_mtime[0];
+		oh->win_atime[1] = in->win_atime[1];
+		oh->win_ctime[1] = in->win_ctime[1];
+		oh->win_mtime[1] = in->win_mtime[1];
+#else
+		oh->yst_uid = in->yst_uid;
+		oh->yst_gid = in->yst_gid;
+		oh->yst_atime = in->yst_atime;
+		oh->yst_mtime = in->yst_mtime;
+		oh->yst_ctime = in->yst_ctime;
+		oh->yst_rdev = in->yst_rdev;
+#endif
+		if (in->parent)
+			oh->parent_obj_id = in->parent->obj_id;
+		else
+			oh->parent_obj_id = 0;
+
+		if (name && *name) {
+			memset(oh->name, 0, sizeof(oh->name));
+			yaffs_load_oh_from_name(dev,oh->name,name);
+		} else if (prevChunkId > 0)
+			memcpy(oh->name, old_name, sizeof(oh->name));
+		else
+			memset(oh->name, 0, sizeof(oh->name));
+
+		oh->is_shrink = is_shrink;
+
+		switch (in->variant_type) {
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+			/* Should not happen */
+			break;
+		case YAFFS_OBJECT_TYPE_FILE:
+			oh->file_size =
+			    (oh->parent_obj_id == YAFFS_OBJECTID_DELETED
+			     || oh->parent_obj_id ==
+			     YAFFS_OBJECTID_UNLINKED) ? 0 : in->variant.
+			    file_variant.file_size;
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+			oh->equiv_id =
+			    in->variant.hardlink_variant.equiv_id;
+			break;
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			/* Do nothing */
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			/* Do nothing */
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			alias = in->variant.symlink_variant.alias;
+			if(!alias)
+				alias = _Y("no alias");
+			yaffs_strncpy(oh->alias,
+					alias,
+				      YAFFS_MAX_ALIAS_LENGTH);
+			oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
+			break;
+		}
+
+		/* process any xattrib modifications */
+		if(xmod)
+			yaffs_apply_xattrib_mod(in, (char *)buffer, xmod);
+
+
+		/* Tags */
+		yaffs_init_tags(&newTags);
+		in->serial++;
+		newTags.chunk_id = 0;
+		newTags.obj_id = in->obj_id;
+		newTags.serial_number = in->serial;
+
+		/* Add extra info for file header */
+
+		newTags.extra_available = 1;
+		newTags.extra_parent_id = oh->parent_obj_id;
+		newTags.extra_length = oh->file_size;
+		newTags.extra_is_shrink = oh->is_shrink;
+		newTags.extra_equiv_id = oh->equiv_id;
+		newTags.extra_shadows = (oh->shadows_obj > 0) ? 1 : 0;
+		newTags.extra_obj_type = in->variant_type;
+
+		yaffs_verify_oh(in, oh, &newTags, 1);
+
+		/* Create new chunk in NAND */
+		newChunkId =
+		    yaffs_write_new_chunk(dev, buffer, &newTags,
+						      (prevChunkId > 0) ? 1 : 0);
+
+		if (newChunkId >= 0) {
+
+			in->hdr_chunk = newChunkId;
+
+			if (prevChunkId > 0) {
+				yaffs_chunk_del(dev, prevChunkId, 1,
+						  __LINE__);
+			}
+
+			if (!yaffs_obj_cache_dirty(in))
+				in->dirty = 0;
+
+			/* If this was a shrink, then mark the block that the chunk lives on */
+			if (is_shrink) {
+				bi = yaffs_get_block_info(in->my_dev,
+					newChunkId / in->my_dev->param.chunks_per_block);
+				bi->has_shrink_hdr = 1;
+			}
+
+		}
+
+		retVal = newChunkId;
+
+	}
+
+	if (buffer)
+		yaffs_release_temp_buffer(dev, buffer, __LINE__);
+
+	return retVal;
+}
+
+/*------------------------ Short Operations Cache ----------------------------------------
+ *   In many situations where there is no high level buffering (eg WinCE) a lot of
+ *   reads might be short sequential reads, and a lot of writes may be short
+ *   sequential writes. eg. scanning/writing a jpeg file.
+ *   In these cases, a short read/write cache can provide a huge perfomance benefit
+ *   with dumb-as-a-rock code.
+ *   In Linux, the page cache provides read buffering aand the short op cache provides write
+ *   buffering.
+ *
+ *   There are a limited number (~10) of cache chunks per device so that we don't
+ *   need a very intelligent search.
+ */
+
+static int yaffs_obj_cache_dirty(yaffs_obj_t *obj)
+{
+	yaffs_dev_t *dev = obj->my_dev;
+	int i;
+	yaffs_cache_t *cache;
+	int nCaches = obj->my_dev->param.n_caches;
+
+	for (i = 0; i < nCaches; i++) {
+		cache = &dev->cache[i];
+		if (cache->object == obj &&
+		    cache->dirty)
+			return 1;
+	}
+
+	return 0;
+}
+
+
+static void yaffs_flush_file_cache(yaffs_obj_t *obj)
+{
+	yaffs_dev_t *dev = obj->my_dev;
+	int lowest = -99;	/* Stop compiler whining. */
+	int i;
+	yaffs_cache_t *cache;
+	int chunkWritten = 0;
+	int nCaches = obj->my_dev->param.n_caches;
+
+	if (nCaches > 0) {
+		do {
+			cache = NULL;
+
+			/* Find the dirty cache for this object with the lowest chunk id. */
+			for (i = 0; i < nCaches; i++) {
+				if (dev->cache[i].object == obj &&
+				    dev->cache[i].dirty) {
+					if (!cache
+					    || dev->cache[i].chunk_id <
+					    lowest) {
+						cache = &dev->cache[i];
+						lowest = cache->chunk_id;
+					}
+				}
+			}
+
+			if (cache && !cache->locked) {
+				/* Write it out and free it up */
+
+				chunkWritten =
+				    yaffs_wr_data_obj(cache->object,
+								 cache->chunk_id,
+								 cache->data,
+								 cache->n_bytes,
+								 1);
+				cache->dirty = 0;
+				cache->object = NULL;
+			}
+
+		} while (cache && chunkWritten > 0);
+
+		if (cache) {
+			/* Hoosterman, disk full while writing cache out. */
+			T(YAFFS_TRACE_ERROR,
+			  (TSTR("yaffs tragedy: no space during cache write" TENDSTR)));
+
+		}
+	}
+
+}
+
+/*yaffs_flush_whole_cache(dev)
+ *
+ *
+ */
+
+void yaffs_flush_whole_cache(yaffs_dev_t *dev)
+{
+	yaffs_obj_t *obj;
+	int nCaches = dev->param.n_caches;
+	int i;
+
+	/* Find a dirty object in the cache and flush it...
+	 * until there are no further dirty objects.
+	 */
+	do {
+		obj = NULL;
+		for (i = 0; i < nCaches && !obj; i++) {
+			if (dev->cache[i].object &&
+			    dev->cache[i].dirty)
+				obj = dev->cache[i].object;
+
+		}
+		if (obj)
+			yaffs_flush_file_cache(obj);
+
+	} while (obj);
+
+}
+
+
+/* Grab us a cache chunk for use.
+ * First look for an empty one.
+ * Then look for the least recently used non-dirty one.
+ * Then look for the least recently used dirty one...., flush and look again.
+ */
+static yaffs_cache_t *yaffs_grab_chunk_worker(yaffs_dev_t *dev)
+{
+	int i;
+
+	if (dev->param.n_caches > 0) {
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (!dev->cache[i].object)
+				return &dev->cache[i];
+		}
+	}
+
+	return NULL;
+}
+
+static yaffs_cache_t *yaffs_grab_chunk_cache(yaffs_dev_t *dev)
+{
+	yaffs_cache_t *cache;
+	yaffs_obj_t *theObj;
+	int usage;
+	int i;
+	int pushout;
+
+	if (dev->param.n_caches > 0) {
+		/* Try find a non-dirty one... */
+
+		cache = yaffs_grab_chunk_worker(dev);
+
+		if (!cache) {
+			/* They were all dirty, find the last recently used object and flush
+			 * its cache, then  find again.
+			 * NB what's here is not very accurate, we actually flush the object
+			 * the last recently used page.
+			 */
+
+			/* With locking we can't assume we can use entry zero */
+
+			theObj = NULL;
+			usage = -1;
+			cache = NULL;
+			pushout = -1;
+
+			for (i = 0; i < dev->param.n_caches; i++) {
+				if (dev->cache[i].object &&
+				    !dev->cache[i].locked &&
+				    (dev->cache[i].last_use < usage || !cache)) {
+					usage = dev->cache[i].last_use;
+					theObj = dev->cache[i].object;
+					cache = &dev->cache[i];
+					pushout = i;
+				}
+			}
+
+			if (!cache || cache->dirty) {
+				/* Flush and try again */
+				yaffs_flush_file_cache(theObj);
+				cache = yaffs_grab_chunk_worker(dev);
+			}
+
+		}
+		return cache;
+	} else
+		return NULL;
+
+}
+
+/* Find a cached chunk */
+static yaffs_cache_t *yaffs_find_chunk_cache(const yaffs_obj_t *obj,
+					      int chunk_id)
+{
+	yaffs_dev_t *dev = obj->my_dev;
+	int i;
+	if (dev->param.n_caches > 0) {
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (dev->cache[i].object == obj &&
+			    dev->cache[i].chunk_id == chunk_id) {
+				dev->cache_hits++;
+
+				return &dev->cache[i];
+			}
+		}
+	}
+	return NULL;
+}
+
+/* Mark the chunk for the least recently used algorithym */
+static void yaffs_use_cache(yaffs_dev_t *dev, yaffs_cache_t *cache,
+				int isAWrite)
+{
+
+	if (dev->param.n_caches > 0) {
+		if (dev->cache_last_use < 0 || dev->cache_last_use > 100000000) {
+			/* Reset the cache usages */
+			int i;
+			for (i = 1; i < dev->param.n_caches; i++)
+				dev->cache[i].last_use = 0;
+
+			dev->cache_last_use = 0;
+		}
+
+		dev->cache_last_use++;
+
+		cache->last_use = dev->cache_last_use;
+
+		if (isAWrite)
+			cache->dirty = 1;
+	}
+}
+
+/* Invalidate a single cache page.
+ * Do this when a whole page gets written,
+ * ie the short cache for this page is no longer valid.
+ */
+static void yaffs_invalidate_chunk_cache(yaffs_obj_t *object, int chunk_id)
+{
+	if (object->my_dev->param.n_caches > 0) {
+		yaffs_cache_t *cache = yaffs_find_chunk_cache(object, chunk_id);
+
+		if (cache)
+			cache->object = NULL;
+	}
+}
+
+/* Invalidate all the cache pages associated with this object
+ * Do this whenever ther file is deleted or resized.
+ */
+static void yaffs_invalidate_whole_cache(yaffs_obj_t *in)
+{
+	int i;
+	yaffs_dev_t *dev = in->my_dev;
+
+	if (dev->param.n_caches > 0) {
+		/* Invalidate it. */
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (dev->cache[i].object == in)
+				dev->cache[i].object = NULL;
+		}
+	}
+}
+
+
+/*--------------------- File read/write ------------------------
+ * Read and write have very similar structures.
+ * In general the read/write has three parts to it
+ * An incomplete chunk to start with (if the read/write is not chunk-aligned)
+ * Some complete chunks
+ * An incomplete chunk to end off with
+ *
+ * Curve-balls: the first chunk might also be the last chunk.
+ */
+
+int yaffs_file_rd(yaffs_obj_t *in, __u8 *buffer, loff_t offset,
+			int n_bytes)
+{
+
+	int chunk;
+	__u32 start;
+	int nToCopy;
+	int n = n_bytes;
+	int nDone = 0;
+	yaffs_cache_t *cache;
+
+	yaffs_dev_t *dev;
+
+	dev = in->my_dev;
+
+	while (n > 0) {
+		/* chunk = offset / dev->data_bytes_per_chunk + 1; */
+		/* start = offset % dev->data_bytes_per_chunk; */
+		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
+		chunk++;
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+		if ((start + n) < dev->data_bytes_per_chunk)
+			nToCopy = n;
+		else
+			nToCopy = dev->data_bytes_per_chunk - start;
+
+		cache = yaffs_find_chunk_cache(in, chunk);
+
+		/* If the chunk is already in the cache or it is less than a whole chunk
+		 * or we're using inband tags then use the cache (if there is caching)
+		 * else bypass the cache.
+		 */
+		if (cache || nToCopy != dev->data_bytes_per_chunk || dev->param.inband_tags) {
+			if (dev->param.n_caches > 0) {
+
+				/* If we can't find the data in the cache, then load it up. */
+
+				if (!cache) {
+					cache = yaffs_grab_chunk_cache(in->my_dev);
+					cache->object = in;
+					cache->chunk_id = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_rd_data_obj(in, chunk,
+								      cache->
+								      data);
+					cache->n_bytes = 0;
+				}
+
+				yaffs_use_cache(dev, cache, 0);
+
+				cache->locked = 1;
+
+
+				memcpy(buffer, &cache->data[start], nToCopy);
+
+				cache->locked = 0;
+			} else {
+				/* Read into the local buffer then copy..*/
+
+				__u8 *localBuffer =
+				    yaffs_get_temp_buffer(dev, __LINE__);
+				yaffs_rd_data_obj(in, chunk,
+							      localBuffer);
+
+				memcpy(buffer, &localBuffer[start], nToCopy);
+
+
+				yaffs_release_temp_buffer(dev, localBuffer,
+							__LINE__);
+			}
+
+		} else {
+
+			/* A full chunk. Read directly into the supplied buffer. */
+			yaffs_rd_data_obj(in, chunk, buffer);
+
+		}
+
+		n -= nToCopy;
+		offset += nToCopy;
+		buffer += nToCopy;
+		nDone += nToCopy;
+
+	}
+
+	return nDone;
+}
+
+int yaffs_do_file_wr(yaffs_obj_t *in, const __u8 *buffer, loff_t offset,
+			int n_bytes, int write_trhrough)
+{
+
+	int chunk;
+	__u32 start;
+	int nToCopy;
+	int n = n_bytes;
+	int nDone = 0;
+	int nToWriteBack;
+	int startOfWrite = offset;
+	int chunkWritten = 0;
+	__u32 n_bytesRead;
+	__u32 chunkStart;
+
+	yaffs_dev_t *dev;
+
+	dev = in->my_dev;
+
+	while (n > 0 && chunkWritten >= 0) {
+		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
+
+		if (chunk * dev->data_bytes_per_chunk + start != offset ||
+				start >= dev->data_bytes_per_chunk) {
+			T(YAFFS_TRACE_ERROR, (
+			   TSTR("AddrToChunk of offset %d gives chunk %d start %d"
+			   TENDSTR),
+			   (int)offset, chunk, start));
+		}
+		chunk++; /* File pos to chunk in file offset */
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+
+		if ((start + n) < dev->data_bytes_per_chunk) {
+			nToCopy = n;
+
+			/* Now folks, to calculate how many bytes to write back....
+			 * If we're overwriting and not writing to then end of file then
+			 * we need to write back as much as was there before.
+			 */
+
+			chunkStart = ((chunk - 1) * dev->data_bytes_per_chunk);
+
+			if (chunkStart > in->variant.file_variant.file_size)
+				n_bytesRead = 0; /* Past end of file */
+			else
+				n_bytesRead = in->variant.file_variant.file_size - chunkStart;
+
+			if (n_bytesRead > dev->data_bytes_per_chunk)
+				n_bytesRead = dev->data_bytes_per_chunk;
+
+			nToWriteBack =
+			    (n_bytesRead >
+			     (start + n)) ? n_bytesRead : (start + n);
+
+			if (nToWriteBack < 0 || nToWriteBack > dev->data_bytes_per_chunk)
+				YBUG();
+
+		} else {
+			nToCopy = dev->data_bytes_per_chunk - start;
+			nToWriteBack = dev->data_bytes_per_chunk;
+		}
+
+		if (nToCopy != dev->data_bytes_per_chunk || dev->param.inband_tags) {
+			/* An incomplete start or end chunk (or maybe both start and end chunk),
+			 * or we're using inband tags, so we want to use the cache buffers.
+			 */
+			if (dev->param.n_caches > 0) {
+				yaffs_cache_t *cache;
+				/* If we can't find the data in the cache, then load the cache */
+				cache = yaffs_find_chunk_cache(in, chunk);
+
+				if (!cache
+				    && yaffs_check_alloc_available(dev, 1)) {
+					cache = yaffs_grab_chunk_cache(dev);
+					cache->object = in;
+					cache->chunk_id = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_rd_data_obj(in, chunk,
+								      cache->data);
+				} else if (cache &&
+					!cache->dirty &&
+					!yaffs_check_alloc_available(dev, 1)) {
+					/* Drop the cache if it was a read cache item and
+					 * no space check has been made for it.
+					 */
+					 cache = NULL;
+				}
+
+				if (cache) {
+					yaffs_use_cache(dev, cache, 1);
+					cache->locked = 1;
+
+
+					memcpy(&cache->data[start], buffer,
+					       nToCopy);
+
+
+					cache->locked = 0;
+					cache->n_bytes = nToWriteBack;
+
+					if (write_trhrough) {
+						chunkWritten =
+						    yaffs_wr_data_obj
+						    (cache->object,
+						     cache->chunk_id,
+						     cache->data, cache->n_bytes,
+						     1);
+						cache->dirty = 0;
+					}
+
+				} else {
+					chunkWritten = -1;	/* fail the write */
+				}
+			} else {
+				/* An incomplete start or end chunk (or maybe both start and end chunk)
+				 * Read into the local buffer then copy, then copy over and write back.
+				 */
+
+				__u8 *localBuffer =
+				    yaffs_get_temp_buffer(dev, __LINE__);
+
+				yaffs_rd_data_obj(in, chunk,
+							      localBuffer);
+
+
+
+				memcpy(&localBuffer[start], buffer, nToCopy);
+
+				chunkWritten =
+				    yaffs_wr_data_obj(in, chunk,
+								 localBuffer,
+								 nToWriteBack,
+								 0);
+
+				yaffs_release_temp_buffer(dev, localBuffer,
+							__LINE__);
+
+			}
+
+		} else {
+			/* A full chunk. Write directly from the supplied buffer. */
+
+
+
+			chunkWritten =
+			    yaffs_wr_data_obj(in, chunk, buffer,
+							 dev->data_bytes_per_chunk,
+							 0);
+
+			/* Since we've overwritten the cached data, we better invalidate it. */
+			yaffs_invalidate_chunk_cache(in, chunk);
+		}
+
+		if (chunkWritten >= 0) {
+			n -= nToCopy;
+			offset += nToCopy;
+			buffer += nToCopy;
+			nDone += nToCopy;
+		}
+
+	}
+
+	/* Update file object */
+
+	if ((startOfWrite + nDone) > in->variant.file_variant.file_size)
+		in->variant.file_variant.file_size = (startOfWrite + nDone);
+
+	in->dirty = 1;
+
+	return nDone;
+}
+
+int yaffs_wr_file(yaffs_obj_t *in, const __u8 *buffer, loff_t offset,
+			int n_bytes, int write_trhrough)
+{
+	yaffs2_handle_hole(in,offset);
+	return yaffs_do_file_wr(in,buffer,offset,n_bytes,write_trhrough);
+}
+
+
+
+/* ---------------------- File resizing stuff ------------------ */
+
+static void yaffs_prune_chunks(yaffs_obj_t *in, int new_size)
+{
+
+	yaffs_dev_t *dev = in->my_dev;
+	int oldFileSize = in->variant.file_variant.file_size;
+
+	int lastDel = 1 + (oldFileSize - 1) / dev->data_bytes_per_chunk;
+
+	int startDel = 1 + (new_size + dev->data_bytes_per_chunk - 1) /
+	    dev->data_bytes_per_chunk;
+	int i;
+	int chunk_id;
+
+	/* Delete backwards so that we don't end up with holes if
+	 * power is lost part-way through the operation.
+	 */
+	for (i = lastDel; i >= startDel; i--) {
+		/* NB this could be optimised somewhat,
+		 * eg. could retrieve the tags and write them without
+		 * using yaffs_chunk_del
+		 */
+
+		chunk_id = yaffs_find_del_file_chunk(in, i, NULL);
+		if (chunk_id > 0) {
+			if (chunk_id <
+			    (dev->internal_start_block * dev->param.chunks_per_block)
+			    || chunk_id >=
+			    ((dev->internal_end_block +
+			      1) * dev->param.chunks_per_block)) {
+				T(YAFFS_TRACE_ALWAYS,
+				  (TSTR("Found daft chunk_id %d for %d" TENDSTR),
+				   chunk_id, i));
+			} else {
+				in->n_data_chunks--;
+				yaffs_chunk_del(dev, chunk_id, 1, __LINE__);
+			}
+		}
+	}
+
+}
+
+
+void yaffs_resize_file_down( yaffs_obj_t *obj, loff_t new_size)
+{
+	int newFullChunks;
+	__u32 new_sizeOfPartialChunk;
+	yaffs_dev_t *dev = obj->my_dev;
+
+	yaffs_addr_to_chunk(dev, new_size, &newFullChunks, &new_sizeOfPartialChunk);
+
+	yaffs_prune_chunks(obj, new_size);
+
+	if (new_sizeOfPartialChunk != 0) {
+		int lastChunk = 1 + newFullChunks;
+		__u8 *localBuffer = yaffs_get_temp_buffer(dev, __LINE__);
+
+		/* Got to read and rewrite the last chunk with its new size and zero pad */
+		yaffs_rd_data_obj(obj, lastChunk, localBuffer);
+		memset(localBuffer + new_sizeOfPartialChunk, 0,
+			dev->data_bytes_per_chunk - new_sizeOfPartialChunk);
+
+		yaffs_wr_data_obj(obj, lastChunk, localBuffer,
+					     new_sizeOfPartialChunk, 1);
+
+		yaffs_release_temp_buffer(dev, localBuffer, __LINE__);
+	}
+
+	obj->variant.file_variant.file_size = new_size;
+
+	yaffs_prune_tree(dev, &obj->variant.file_variant);
+}
+
+
+int yaffs_resize_file(yaffs_obj_t *in, loff_t new_size)
+{
+	yaffs_dev_t *dev = in->my_dev;
+	int oldFileSize = in->variant.file_variant.file_size;
+
+	yaffs_flush_file_cache(in);
+	yaffs_invalidate_whole_cache(in);
+
+	yaffs_check_gc(dev,0);
+
+	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	if (new_size == oldFileSize)
+		return YAFFS_OK;
+		
+	if(new_size > oldFileSize){
+		yaffs2_handle_hole(in,new_size);
+		in->variant.file_variant.file_size = new_size;
+	} else {
+		/* new_size < oldFileSize */ 
+		yaffs_resize_file_down(in, new_size);
+	} 
+
+	/* Write a new object header to reflect the resize.
+	 * show we've shrunk the file, if need be
+	 * Do this only if the file is not in the deleted directories
+	 * and is not shadowed.
+	 */
+	if (in->parent &&
+	    !in->is_shadowed &&
+	    in->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
+	    in->parent->obj_id != YAFFS_OBJECTID_DELETED)
+		yaffs_update_oh(in, NULL, 0, 0, 0, NULL);
+
+
+	return YAFFS_OK;
+}
+
+loff_t yaffs_get_file_size(yaffs_obj_t *obj)
+{
+	YCHAR *alias = NULL;
+	obj = yaffs_get_equivalent_obj(obj);
+
+	switch (obj->variant_type) {
 	case YAFFS_OBJECT_TYPE_FILE:
-		the_obj->variant.file_variant.file_size = 0;
-		the_obj->variant.file_variant.scanned_size = 0;
-		the_obj->variant.file_variant.shrink_size =
-						yaffs_max_file_size(dev);
-		the_obj->variant.file_variant.top_level = 0;
-		the_obj->variant.file_variant.top = tn;
+		return obj->variant.file_variant.file_size;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		alias = obj->variant.symlink_variant.alias;
+		if(!alias)
+			return 0;
+		return yaffs_strnlen(alias,YAFFS_MAX_ALIAS_LENGTH);
+	default:
+		return 0;
+	}
+}
+
+
+
+int yaffs_flush_file(yaffs_obj_t *in, int update_time, int data_sync)
+{
+	int retVal;
+	if (in->dirty) {
+		yaffs_flush_file_cache(in);
+		if(data_sync) /* Only sync data */
+			retVal=YAFFS_OK;
+		else {
+			if (update_time) {
+#ifdef CONFIG_YAFFS_WINCE
+				yfsd_win_file_time_now(in->win_mtime);
+#else
+
+				in->yst_mtime = Y_CURRENT_TIME;
+
+#endif
+			}
+
+			retVal = (yaffs_update_oh(in, NULL, 0, 0, 0, NULL) >=
+				0) ? YAFFS_OK : YAFFS_FAIL;
+		}
+	} else {
+		retVal = YAFFS_OK;
+	}
+
+	return retVal;
+
+}
+
+static int yaffs_generic_obj_del(yaffs_obj_t *in)
+{
+
+	/* First off, invalidate the file's data in the cache, without flushing. */
+	yaffs_invalidate_whole_cache(in);
+
+	if (in->my_dev->param.is_yaffs2 && (in->parent != in->my_dev->del_dir)) {
+		/* Move to the unlinked directory so we have a record that it was deleted. */
+		yaffs_change_obj_name(in, in->my_dev->del_dir, _Y("deleted"), 0, 0);
+
+	}
+
+	yaffs_remove_obj_from_dir(in);
+	yaffs_chunk_del(in->my_dev, in->hdr_chunk, 1, __LINE__);
+	in->hdr_chunk = 0;
+
+	yaffs_free_obj(in);
+	return YAFFS_OK;
+
+}
+
+/* yaffs_del_file deletes the whole file data
+ * and the inode associated with the file.
+ * It does not delete the links associated with the file.
+ */
+static int yaffs_unlink_file_if_needed(yaffs_obj_t *in)
+{
+
+	int retVal;
+	int immediateDeletion = 0;
+	yaffs_dev_t *dev = in->my_dev;
+
+	if (!in->my_inode)
+		immediateDeletion = 1;
+
+	if (immediateDeletion) {
+		retVal =
+		    yaffs_change_obj_name(in, in->my_dev->del_dir,
+					   _Y("deleted"), 0, 0);
+		T(YAFFS_TRACE_TRACING,
+		  (TSTR("yaffs: immediate deletion of file %d" TENDSTR),
+		   in->obj_id));
+		in->deleted = 1;
+		in->my_dev->n_deleted_files++;
+		if (dev->param.disable_soft_del || dev->param.is_yaffs2)
+			yaffs_resize_file(in, 0);
+		yaffs_soft_del_file(in);
+	} else {
+		retVal =
+		    yaffs_change_obj_name(in, in->my_dev->unlinked_dir,
+					   _Y("unlinked"), 0, 0);
+	}
+
+
+	return retVal;
+}
+
+int yaffs_del_file(yaffs_obj_t *in)
+{
+	int retVal = YAFFS_OK;
+	int deleted; /* Need to cache value on stack if in is freed */
+	yaffs_dev_t *dev = in->my_dev;
+
+	if (dev->param.disable_soft_del || dev->param.is_yaffs2)
+		yaffs_resize_file(in, 0);
+
+	if (in->n_data_chunks > 0) {
+		/* Use soft deletion if there is data in the file.
+		 * That won't be the case if it has been resized to zero.
+		 */
+		if (!in->unlinked)
+			retVal = yaffs_unlink_file_if_needed(in);
+
+		deleted = in->deleted;
+
+		if (retVal == YAFFS_OK && in->unlinked && !in->deleted) {
+			in->deleted = 1;
+			deleted = 1;
+			in->my_dev->n_deleted_files++;
+			yaffs_soft_del_file(in);
+		}
+		return deleted ? YAFFS_OK : YAFFS_FAIL;
+	} else {
+		/* The file has no data chunks so we toss it immediately */
+		yaffs_free_tnode(in->my_dev, in->variant.file_variant.top);
+		in->variant.file_variant.top = NULL;
+		yaffs_generic_obj_del(in);
+
+		return YAFFS_OK;
+	}
+}
+
+static int yaffs_is_non_empty_dir(yaffs_obj_t *obj)
+{
+	return (obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY) &&
+		!(ylist_empty(&obj->variant.dir_variant.children));
+}
+
+static int yaffs_del_dir(yaffs_obj_t *obj)
+{
+	/* First check that the directory is empty. */
+	if (yaffs_is_non_empty_dir(obj))
+		return YAFFS_FAIL;
+
+	return yaffs_generic_obj_del(obj);
+}
+
+static int yaffs_del_symlink(yaffs_obj_t *in)
+{
+	if(in->variant.symlink_variant.alias)
+		YFREE(in->variant.symlink_variant.alias);
+	in->variant.symlink_variant.alias=NULL;
+
+	return yaffs_generic_obj_del(in);
+}
+
+static int yaffs_del_link(yaffs_obj_t *in)
+{
+	/* remove this hardlink from the list assocaited with the equivalent
+	 * object
+	 */
+	ylist_del_init(&in->hard_links);
+	return yaffs_generic_obj_del(in);
+}
+
+int yaffs_del_obj(yaffs_obj_t *obj)
+{
+int retVal = -1;
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		retVal = yaffs_del_file(obj);
 		break;
 	case YAFFS_OBJECT_TYPE_DIRECTORY:
-		INIT_LIST_HEAD(&the_obj->variant.dir_variant.children);
-		INIT_LIST_HEAD(&the_obj->variant.dir_variant.dirty);
+		if(!ylist_empty(&obj->variant.dir_variant.dirty)){
+			T(YAFFS_TRACE_BACKGROUND, (TSTR("Remove object %d from dirty directories" TENDSTR),obj->obj_id));
+			ylist_del_init(&obj->variant.dir_variant.dirty);
+		}
+		return yaffs_del_dir(obj);
 		break;
 	case YAFFS_OBJECT_TYPE_SYMLINK:
+		retVal = yaffs_del_symlink(obj);
+		break;
 	case YAFFS_OBJECT_TYPE_HARDLINK:
+		retVal = yaffs_del_link(obj);
+		break;
 	case YAFFS_OBJECT_TYPE_SPECIAL:
-		/* No action required */
+		retVal = yaffs_generic_obj_del(obj);
 		break;
 	case YAFFS_OBJECT_TYPE_UNKNOWN:
-		/* todo this should not happen */
-		break;
+		retVal = 0;
+		break;		/* should not happen. */
 	}
-	return the_obj;
+
+	return retVal;
 }
 
-static struct yaffs_obj *yaffs_create_fake_dir(struct yaffs_dev *dev,
-					       int number, u32 mode)
+static int yaffs_unlink_worker(yaffs_obj_t *obj)
 {
 
-	struct yaffs_obj *obj =
-	    yaffs_new_obj(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
-
+	int immediateDeletion = 0;
+
+	if (!obj->my_inode)
+		immediateDeletion = 1;
+
+	if(obj)
+		yaffs_update_parent(obj->parent);
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+		return yaffs_del_link(obj);
+	} else if (!ylist_empty(&obj->hard_links)) {
+		/* Curve ball: We're unlinking an object that has a hardlink.
+		 *
+		 * This problem arises because we are not strictly following
+		 * The Linux link/inode model.
+		 *
+		 * We can't really delete the object.
+		 * Instead, we do the following:
+		 * - Select a hardlink.
+		 * - Unhook it from the hard links
+		 * - Move it from its parent directory (so that the rename can work)
+		 * - Rename the object to the hardlink's name.
+		 * - Delete the hardlink
+		 */
+
+		yaffs_obj_t *hl;
+		yaffs_obj_t *parent;
+		int retVal;
+		YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+		hl = ylist_entry(obj->hard_links.next, yaffs_obj_t, hard_links);
+
+		yaffs_get_obj_name(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
+		parent = hl->parent;
+
+		ylist_del_init(&hl->hard_links);
+
+ 		yaffs_add_obj_to_dir(obj->my_dev->unlinked_dir, hl);
+
+		retVal = yaffs_change_obj_name(obj,parent, name, 0, 0);
+
+		if (retVal == YAFFS_OK)
+			retVal = yaffs_generic_obj_del(hl);
+
+		return retVal;
+
+	} else if (immediateDeletion) {
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			return yaffs_del_file(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			ylist_del_init(&obj->variant.dir_variant.dirty);
+			return yaffs_del_dir(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			return yaffs_del_symlink(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			return yaffs_generic_obj_del(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		default:
+			return YAFFS_FAIL;
+		}
+	} else if(yaffs_is_non_empty_dir(obj))
+		return YAFFS_FAIL;
+	else
+		return yaffs_change_obj_name(obj, obj->my_dev->unlinked_dir,
+					   _Y("unlinked"), 0, 0);
+}
+
+
+static int yaffs_unlink_obj(yaffs_obj_t *obj)
+{
+
+	if (obj && obj->unlink_allowed)
+		return yaffs_unlink_worker(obj);
+
+	return YAFFS_FAIL;
+
+}
+int yaffs_unlinker(yaffs_obj_t *dir, const YCHAR *name)
+{
+	yaffs_obj_t *obj;
+
+	obj = yaffs_find_by_name(dir, name);
+	return yaffs_unlink_obj(obj);
+}
+
+/*----------------------- Initialisation Scanning ---------------------- */
+
+void yaffs_handle_shadowed_obj(yaffs_dev_t *dev, int obj_id,
+				int backward_scanning)
+{
+	yaffs_obj_t *obj;
+
+	if (!backward_scanning) {
+		/* Handle YAFFS1 forward scanning case
+		 * For YAFFS1 we always do the deletion
+		 */
+
+	} else {
+		/* Handle YAFFS2 case (backward scanning)
+		 * If the shadowed object exists then ignore.
+		 */
+		obj = yaffs_find_by_number(dev, obj_id);
+		if(obj)
+			return;
+	}
+
+	/* Let's create it (if it does not exist) assuming it is a file so that it can do shrinking etc.
+	 * We put it in unlinked dir to be cleaned up after the scanning
+	 */
+	obj =
+	    yaffs_find_or_create_by_number(dev, obj_id,
+					     YAFFS_OBJECT_TYPE_FILE);
 	if (!obj)
-		return NULL;
-
-	obj->fake = 1;	/* it is fake so it might not use NAND */
-	obj->rename_allowed = 0;
-	obj->unlink_allowed = 0;
-	obj->deleted = 0;
-	obj->unlinked = 0;
-	obj->yst_mode = mode;
-	obj->my_dev = dev;
-	obj->hdr_chunk = 0;	/* Not a valid chunk. */
-	return obj;
+		return;
+	obj->is_shadowed = 1;
+	yaffs_add_obj_to_dir(dev->unlinked_dir, obj);
+	obj->variant.file_variant.shrink_size = 0;
+	obj->valid = 1;		/* So that we don't read any other info for this file */
 
 }
 
 
-static void yaffs_init_tnodes_and_objs(struct yaffs_dev *dev)
+void yaffs_link_fixup(yaffs_dev_t *dev, yaffs_obj_t *hard_list)
 {
-	int i;
-
-	dev->n_obj = 0;
-	dev->n_tnodes = 0;
-	yaffs_init_raw_tnodes_and_objs(dev);
-
-	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
-		INIT_LIST_HEAD(&dev->obj_bucket[i].list);
-		dev->obj_bucket[i].count = 0;
+	yaffs_obj_t *hl;
+	yaffs_obj_t *in;
+
+	while (hard_list) {
+		hl = hard_list;
+		hard_list = (yaffs_obj_t *) (hard_list->hard_links.next);
+
+		in = yaffs_find_by_number(dev,
+					      hl->variant.hardlink_variant.
+					      equiv_id);
+
+		if (in) {
+			/* Add the hardlink pointers */
+			hl->variant.hardlink_variant.equiv_obj = in;
+			ylist_add(&hl->hard_links, &in->hard_links);
+		} else {
+			/* Todo Need to report/handle this better.
+			 * Got a problem... hardlink to a non-existant object
+			 */
+			hl->variant.hardlink_variant.equiv_obj = NULL;
+			YINIT_LIST_HEAD(&hl->hard_links);
+
+		}
 	}
 }
 
-struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
-						 int number,
-						 enum yaffs_obj_type type)
+
+static void yaffs_strip_deleted_objs(yaffs_dev_t *dev)
 {
-	struct yaffs_obj *the_obj = NULL;
-
-	if (number > 0)
-		the_obj = yaffs_find_by_number(dev, number);
-
-	if (!the_obj)
-		the_obj = yaffs_new_obj(dev, number, type);
-
-	return the_obj;
+	/*
+	*  Sort out state of unlinked and deleted objects after scanning.
+	*/
+	struct ylist_head *i;
+	struct ylist_head *n;
+	yaffs_obj_t *l;
+
+	if (dev->read_only)
+		return;
+
+	/* Soft delete all the unlinked files */
+	ylist_for_each_safe(i, n,
+		&dev->unlinked_dir->variant.dir_variant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_obj_t, siblings);
+			yaffs_del_obj(l);
+		}
+	}
+
+	ylist_for_each_safe(i, n,
+		&dev->del_dir->variant.dir_variant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_obj_t, siblings);
+			yaffs_del_obj(l);
+		}
+	}
 
 }
 
-YCHAR *yaffs_clone_str(const YCHAR *str)
+/*
+ * This code iterates through all the objects making sure that they are rooted.
+ * Any unrooted objects are re-rooted in lost+found.
+ * An object needs to be in one of:
+ * - Directly under deleted, unlinked
+ * - Directly or indirectly under root.
+ *
+ * Note:
+ *  This code assumes that we don't ever change the current relationships between
+ *  directories:
+ *   root_dir->parent == unlinked_dir->parent == del_dir->parent == NULL
+ *   lostNfound->parent == root_dir
+ *
+ * This fixes the problem where directories might have inadvertently been deleted
+ * leaving the object "hanging" without being rooted in the directory tree.
+ */
+ 
+static int yaffs_has_null_parent(yaffs_dev_t *dev, yaffs_obj_t *obj)
 {
-	YCHAR *new_str = NULL;
-	int len;
-
-	if (!str)
-		str = _Y("");
-
-	len = strnlen(str, YAFFS_MAX_ALIAS_LENGTH);
-	new_str = kmalloc((len + 1) * sizeof(YCHAR), GFP_NOFS);
-	if (new_str) {
-		strncpy(new_str, str, len);
-		new_str[len] = 0;
+	return (obj == dev->del_dir ||
+		obj == dev->unlinked_dir||
+		obj == dev->root_dir);
+}
+
+static void yaffs_fix_hanging_objs(yaffs_dev_t *dev)
+{
+	yaffs_obj_t *obj;
+	yaffs_obj_t *parent;
+	int i;
+	struct ylist_head *lh;
+	struct ylist_head *n;
+	int depthLimit;
+	int hanging;
+
+	if (dev->read_only)
+		return;
+
+	/* Iterate through the objects in each hash entry,
+	 * looking at each object.
+	 * Make sure it is rooted.
+	 */
+
+	for (i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++) {
+		ylist_for_each_safe(lh, n, &dev->obj_bucket[i].list) {
+			if (lh) {
+				obj = ylist_entry(lh, yaffs_obj_t, hash_link);
+				parent= obj->parent;
+				
+				if(yaffs_has_null_parent(dev,obj)){
+					/* These directories are not hanging */
+					hanging = 0;
+				}
+				else if(!parent || parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+					hanging = 1;
+				else if(yaffs_has_null_parent(dev,parent))
+					hanging = 0;
+				else {
+					/*
+					 * Need to follow the parent chain to see if it is hanging.
+					 */
+					hanging = 0;
+					depthLimit=100;
+
+					while(parent != dev->root_dir &&
+						parent->parent &&
+						parent->parent->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+						depthLimit > 0){
+						parent = parent->parent;
+						depthLimit--;
+					}
+					if(parent != dev->root_dir)
+						hanging = 1;
+				}
+				if(hanging){
+					T(YAFFS_TRACE_SCAN,
+					  (TSTR("Hanging object %d moved to lost and found" TENDSTR),
+					  	obj->obj_id));
+					yaffs_add_obj_to_dir(dev->lost_n_found,obj);
+				}
+			}
+		}
 	}
-	return new_str;
-
 }
+
+
+/*
+ * Delete directory contents for cleaning up lost and found.
+ */
+static void yaffs_del_dir_contents(yaffs_obj_t *dir)
+{
+	yaffs_obj_t *obj;
+	struct ylist_head *lh;
+	struct ylist_head *n;
+
+	if(dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		YBUG();
+	
+	ylist_for_each_safe(lh, n, &dir->variant.dir_variant.children) {
+		if (lh) {
+			obj = ylist_entry(lh, yaffs_obj_t, siblings);
+			if(obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY)
+				yaffs_del_dir_contents(obj);
+
+			T(YAFFS_TRACE_SCAN,
+				(TSTR("Deleting lost_found object %d" TENDSTR),
+				obj->obj_id));
+
+			/* Need to use UnlinkObject since Delete would not handle
+			 * hardlinked objects correctly.
+			 */
+			yaffs_unlink_obj(obj); 
+		}
+	}
+			
+}
+
+static void yaffs_empty_l_n_f(yaffs_dev_t *dev)
+{
+	yaffs_del_dir_contents(dev->lost_n_found);
+}
+
+static void yaffs_check_obj_details_loaded(yaffs_obj_t *in)
+{
+	__u8 *chunkData;
+	yaffs_obj_header *oh;
+	yaffs_dev_t *dev;
+	yaffs_ext_tags tags;
+	int result;
+	int alloc_failed = 0;
+
+	if (!in)
+		return;
+
+	dev = in->my_dev;
+
+#if 0
+	T(YAFFS_TRACE_SCAN, (TSTR("details for object %d %s loaded" TENDSTR),
+		in->obj_id,
+		in->lazy_loaded ? "not yet" : "already"));
+#endif
+
+	if (in->lazy_loaded && in->hdr_chunk > 0) {
+		in->lazy_loaded = 0;
+		chunkData = yaffs_get_temp_buffer(dev, __LINE__);
+
+		result = yaffs_rd_chunk_tags_nand(dev, in->hdr_chunk, chunkData, &tags);
+		oh = (yaffs_obj_header *) chunkData;
+
+		in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+		in->win_atime[0] = oh->win_atime[0];
+		in->win_ctime[0] = oh->win_ctime[0];
+		in->win_mtime[0] = oh->win_mtime[0];
+		in->win_atime[1] = oh->win_atime[1];
+		in->win_ctime[1] = oh->win_ctime[1];
+		in->win_mtime[1] = oh->win_mtime[1];
+#else
+		in->yst_uid = oh->yst_uid;
+		in->yst_gid = oh->yst_gid;
+		in->yst_atime = oh->yst_atime;
+		in->yst_mtime = oh->yst_mtime;
+		in->yst_ctime = oh->yst_ctime;
+		in->yst_rdev = oh->yst_rdev;
+
+#endif
+		yaffs_set_obj_name_from_oh(in, oh);
+
+		if (in->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
+			in->variant.symlink_variant.alias =
+						    yaffs_clone_str(oh->alias);
+			if (!in->variant.symlink_variant.alias)
+				alloc_failed = 1; /* Not returned to caller */
+		}
+
+		yaffs_release_temp_buffer(dev, chunkData, __LINE__);
+	}
+}
+
+/*------------------------------  Directory Functions ----------------------------- */
+
 /*
  *yaffs_update_parent() handles fixing a directories mtime and ctime when a new
  * link (ie. name) is created or deleted in the directory.
@@ -2111,2326 +4416,222 @@ YCHAR *yaffs_clone_str(const YCHAR *str)
  * If the directory updating is defered then yaffs_update_dirty_dirs must be
  * called periodically.
  */
-
-static void yaffs_update_parent(struct yaffs_obj *obj)
+ 
+static void yaffs_update_parent(yaffs_obj_t *obj)
 {
-	struct yaffs_dev *dev;
-
-	if (!obj)
+	yaffs_dev_t *dev;
+	if(!obj)
 		return;
+#ifndef CONFIG_YAFFS_WINCE
+
 	dev = obj->my_dev;
 	obj->dirty = 1;
-	yaffs_load_current_time(obj, 0, 1);
-	if (dev->param.defered_dir_update) {
-		struct list_head *link = &obj->variant.dir_variant.dirty;
-
-		if (list_empty(link)) {
-			list_add(link, &dev->dirty_dirs);
-			yaffs_trace(YAFFS_TRACE_BACKGROUND,
-			  "Added object %d to dirty directories",
-			   obj->obj_id);
+	obj->yst_mtime = obj->yst_ctime = Y_CURRENT_TIME;
+	if(dev->param.defered_dir_update){
+		struct ylist_head *link = &obj->variant.dir_variant.dirty; 
+	
+		if(ylist_empty(link)){
+			ylist_add(link,&dev->dirty_dirs);
+			T(YAFFS_TRACE_BACKGROUND, (TSTR("Added object %d to dirty directories" TENDSTR),obj->obj_id));
 		}
 
-	} else {
+	} else
 		yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
-	}
+#endif
 }
 
-void yaffs_update_dirty_dirs(struct yaffs_dev *dev)
+void yaffs_update_dirty_dirs(yaffs_dev_t *dev)
 {
-	struct list_head *link;
-	struct yaffs_obj *obj;
-	struct yaffs_dir_var *d_s;
-	union yaffs_obj_var *o_v;
-
-	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update dirty directories");
-
-	while (!list_empty(&dev->dirty_dirs)) {
+	struct ylist_head *link;
+	yaffs_obj_t *obj;
+	yaffs_dir_s *dS;
+	yaffs_obj_variant *oV;
+
+	T(YAFFS_TRACE_BACKGROUND, (TSTR("Update dirty directories" TENDSTR)));
+
+	while(!ylist_empty(&dev->dirty_dirs)){
 		link = dev->dirty_dirs.next;
-		list_del_init(link);
-
-		d_s = list_entry(link, struct yaffs_dir_var, dirty);
-		o_v = list_entry(d_s, union yaffs_obj_var, dir_variant);
-		obj = list_entry(o_v, struct yaffs_obj, variant);
-
-		yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update directory %d",
-			obj->obj_id);
-
-		if (obj->dirty)
+		ylist_del_init(link);
+		
+		dS=ylist_entry(link,yaffs_dir_s,dirty);
+		oV = ylist_entry(dS,yaffs_obj_variant,dir_variant);
+		obj = ylist_entry(oV,yaffs_obj_t,variant);
+
+		T(YAFFS_TRACE_BACKGROUND, (TSTR("Update directory %d" TENDSTR), obj->obj_id));
+
+		if(obj->dirty)
 			yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
 	}
 }
 
-/*
- * Mknod (create) a new object.
- * equiv_obj only has meaning for a hard link;
- * alias_str only has meaning for a symlink.
- * rdev only has meaning for devices (a subset of special objects)
- */
-
-static struct yaffs_obj *yaffs_create_obj(enum yaffs_obj_type type,
-					  struct yaffs_obj *parent,
-					  const YCHAR *name,
-					  u32 mode,
-					  u32 uid,
-					  u32 gid,
-					  struct yaffs_obj *equiv_obj,
-					  const YCHAR *alias_str, u32 rdev)
+static void yaffs_remove_obj_from_dir(yaffs_obj_t *obj)
 {
-	struct yaffs_obj *in;
-	YCHAR *str = NULL;
-	struct yaffs_dev *dev = parent->my_dev;
-
-	/* Check if the entry exists.
-	 * If it does then fail the call since we don't want a dup. */
-	if (yaffs_find_by_name(parent, name))
+	yaffs_dev_t *dev = obj->my_dev;
+	yaffs_obj_t *parent;
+
+	yaffs_verify_obj_in_dir(obj);
+	parent = obj->parent;
+
+	yaffs_verify_dir(parent);
+
+	if (dev && dev->param.remove_obj_fn)
+		dev->param.remove_obj_fn(obj);
+
+
+	ylist_del_init(&obj->siblings);
+	obj->parent = NULL;
+	
+	yaffs_verify_dir(parent);
+}
+
+void yaffs_add_obj_to_dir(yaffs_obj_t *directory,
+					yaffs_obj_t *obj)
+{
+	if (!directory) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: Trying to add an object to a null pointer directory"
+		    TENDSTR)));
+		YBUG();
+		return;
+	}
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: Trying to add an object to a non-directory"
+		    TENDSTR)));
+		YBUG();
+	}
+
+	if (obj->siblings.prev == NULL) {
+		/* Not initialised */
+		YBUG();
+	}
+
+
+	yaffs_verify_dir(directory);
+
+	yaffs_remove_obj_from_dir(obj);
+
+
+	/* Now add it */
+	ylist_add(&obj->siblings, &directory->variant.dir_variant.children);
+	obj->parent = directory;
+
+	if (directory == obj->my_dev->unlinked_dir
+			|| directory == obj->my_dev->del_dir) {
+		obj->unlinked = 1;
+		obj->my_dev->n_unlinked_files++;
+		obj->rename_allowed = 0;
+	}
+
+	yaffs_verify_dir(directory);
+	yaffs_verify_obj_in_dir(obj);
+}
+
+yaffs_obj_t *yaffs_find_by_name(yaffs_obj_t *directory,
+				     const YCHAR *name)
+{
+	int sum;
+
+	struct ylist_head *i;
+	YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
+
+	yaffs_obj_t *l;
+
+	if (!name)
 		return NULL;
 
-	if (type == YAFFS_OBJECT_TYPE_SYMLINK) {
-		str = yaffs_clone_str(alias_str);
-		if (!str)
-			return NULL;
-	}
-
-	in = yaffs_new_obj(dev, -1, type);
-
-	if (!in) {
-		kfree(str);
+	if (!directory) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_find_by_name: null pointer directory"
+		    TENDSTR)));
+		YBUG();
 		return NULL;
 	}
-
-	in->hdr_chunk = 0;
-	in->valid = 1;
-	in->variant_type = type;
-
-	in->yst_mode = mode;
-
-	yaffs_attribs_init(in, gid, uid, rdev);
-
-	in->n_data_chunks = 0;
-
-	yaffs_set_obj_name(in, name);
-	in->dirty = 1;
-
-	yaffs_add_obj_to_dir(parent, in);
-
-	in->my_dev = parent->my_dev;
-
-	switch (type) {
-	case YAFFS_OBJECT_TYPE_SYMLINK:
-		in->variant.symlink_variant.alias = str;
-		break;
-	case YAFFS_OBJECT_TYPE_HARDLINK:
-		in->variant.hardlink_variant.equiv_obj = equiv_obj;
-		in->variant.hardlink_variant.equiv_id = equiv_obj->obj_id;
-		list_add(&in->hard_links, &equiv_obj->hard_links);
-		break;
-	case YAFFS_OBJECT_TYPE_FILE:
-	case YAFFS_OBJECT_TYPE_DIRECTORY:
-	case YAFFS_OBJECT_TYPE_SPECIAL:
-	case YAFFS_OBJECT_TYPE_UNKNOWN:
-		/* do nothing */
-		break;
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_find_by_name: non-directory" TENDSTR)));
+		YBUG();
 	}
 
-	if (yaffs_update_oh(in, name, 0, 0, 0, NULL) < 0) {
-		/* Could not create the object header, fail */
-		yaffs_del_obj(in);
-		in = NULL;
-	}
-
-	if (in)
-		yaffs_update_parent(parent);
-
-	return in;
-}
-
-struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
-				    const YCHAR *name, u32 mode, u32 uid,
-				    u32 gid)
-{
-	return yaffs_create_obj(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
-				uid, gid, NULL, NULL, 0);
-}
-
-struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
-				   u32 mode, u32 uid, u32 gid)
-{
-	return yaffs_create_obj(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
-				mode, uid, gid, NULL, NULL, 0);
-}
-
-struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
-				       const YCHAR *name, u32 mode, u32 uid,
-				       u32 gid, u32 rdev)
-{
-	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
-				uid, gid, NULL, NULL, rdev);
-}
-
-struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
-				       const YCHAR *name, u32 mode, u32 uid,
-				       u32 gid, const YCHAR *alias)
-{
-	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
-				uid, gid, NULL, alias, 0);
-}
-
-/* yaffs_link_obj returns the object id of the equivalent object.*/
-struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR * name,
-				 struct yaffs_obj *equiv_obj)
-{
-	/* Get the real object in case we were fed a hard link obj */
-	equiv_obj = yaffs_get_equivalent_obj(equiv_obj);
-
-	if (yaffs_create_obj(YAFFS_OBJECT_TYPE_HARDLINK,
-			parent, name, 0, 0, 0,
-			equiv_obj, NULL, 0))
-		return equiv_obj;
-
-	return NULL;
-
-}
-
-
-
-/*---------------------- Block Management and Page Allocation -------------*/
-
-static void yaffs_deinit_blocks(struct yaffs_dev *dev)
-{
-	if (dev->block_info_alt && dev->block_info)
-		vfree(dev->block_info);
-	else
-		kfree(dev->block_info);
-
-	dev->block_info_alt = 0;
-
-	dev->block_info = NULL;
-
-	if (dev->chunk_bits_alt && dev->chunk_bits)
-		vfree(dev->chunk_bits);
-	else
-		kfree(dev->chunk_bits);
-	dev->chunk_bits_alt = 0;
-	dev->chunk_bits = NULL;
-}
-
-static int yaffs_init_blocks(struct yaffs_dev *dev)
-{
-	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
-
-	dev->block_info = NULL;
-	dev->chunk_bits = NULL;
-	dev->alloc_block = -1;	/* force it to get a new one */
-
-	/* If the first allocation strategy fails, thry the alternate one */
-	dev->block_info =
-		kmalloc(n_blocks * sizeof(struct yaffs_block_info), GFP_NOFS);
-	if (!dev->block_info) {
-		dev->block_info =
-		    vmalloc(n_blocks * sizeof(struct yaffs_block_info));
-		dev->block_info_alt = 1;
-	} else {
-		dev->block_info_alt = 0;
-	}
-
-	if (!dev->block_info)
-		goto alloc_error;
-
-	/* Set up dynamic blockinfo stuff. Round up bytes. */
-	dev->chunk_bit_stride = (dev->param.chunks_per_block + 7) / 8;
-	dev->chunk_bits =
-		kmalloc(dev->chunk_bit_stride * n_blocks, GFP_NOFS);
-	if (!dev->chunk_bits) {
-		dev->chunk_bits =
-		    vmalloc(dev->chunk_bit_stride * n_blocks);
-		dev->chunk_bits_alt = 1;
-	} else {
-		dev->chunk_bits_alt = 0;
-	}
-	if (!dev->chunk_bits)
-		goto alloc_error;
-
-
-	memset(dev->block_info, 0, n_blocks * sizeof(struct yaffs_block_info));
-	memset(dev->chunk_bits, 0, dev->chunk_bit_stride * n_blocks);
-	return YAFFS_OK;
-
-alloc_error:
-	yaffs_deinit_blocks(dev);
-	return YAFFS_FAIL;
-}
-
-
-void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no)
-{
-	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block_no);
-	int erased_ok = 0;
-	int i;
-
-	/* If the block is still healthy erase it and mark as clean.
-	 * If the block has had a data failure, then retire it.
-	 */
-
-	yaffs_trace(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
-		"yaffs_block_became_dirty block %d state %d %s",
-		block_no, bi->block_state,
-		(bi->needs_retiring) ? "needs retiring" : "");
-
-	yaffs2_clear_oldest_dirty_seq(dev, bi);
-
-	bi->block_state = YAFFS_BLOCK_STATE_DIRTY;
-
-	/* If this is the block being garbage collected then stop gc'ing */
-	if (block_no == dev->gc_block)
-		dev->gc_block = 0;
-
-	/* If this block is currently the best candidate for gc
-	 * then drop as a candidate */
-	if (block_no == dev->gc_dirtiest) {
-		dev->gc_dirtiest = 0;
-		dev->gc_pages_in_use = 0;
-	}
-
-	if (!bi->needs_retiring) {
-		yaffs2_checkpt_invalidate(dev);
-		erased_ok = yaffs_erase_block(dev, block_no);
-		if (!erased_ok) {
-			dev->n_erase_failures++;
-			yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
-			  "**>> Erasure failed %d", block_no);
-		}
-	}
-
-	/* Verify erasure if needed */
-	if (erased_ok &&
-	    ((yaffs_trace_mask & YAFFS_TRACE_ERASE) ||
-	     !yaffs_skip_verification(dev))) {
-		for (i = 0; i < dev->param.chunks_per_block; i++) {
-			if (!yaffs_check_chunk_erased(dev,
-				block_no * dev->param.chunks_per_block + i)) {
-				yaffs_trace(YAFFS_TRACE_ERROR,
-					">>Block %d erasure supposedly OK, but chunk %d not erased",
-					block_no, i);
+	sum = yaffs_calc_name_sum(name);
+
+	ylist_for_each(i, &directory->variant.dir_variant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_obj_t, siblings);
+
+			if (l->parent != directory)
+				YBUG();
+
+			yaffs_check_obj_details_loaded(l);
+
+			/* Special case for lost-n-found */
+			if (l->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
+				if (yaffs_strcmp(name, YAFFS_LOSTNFOUND_NAME) == 0)
+					return l;
+			} else if (yaffs_sum_cmp(l->sum, sum) || l->hdr_chunk <= 0) {
+				/* LostnFound chunk called Objxxx
+				 * Do a real check
+				 */
+				yaffs_get_obj_name(l, buffer,
+						    YAFFS_MAX_NAME_LENGTH + 1);
+				if (yaffs_strncmp(name, buffer, YAFFS_MAX_NAME_LENGTH) == 0)
+					return l;
 			}
 		}
 	}
 
-	if (!erased_ok) {
-		/* We lost a block of free space */
-		dev->n_free_chunks -= dev->param.chunks_per_block;
-		yaffs_retire_block(dev, block_no);
-		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
-			"**>> Block %d retired", block_no);
-		return;
+	return NULL;
+}
+
+
+#if 0
+int yaffs_ApplyToDirectoryChildren(yaffs_obj_t *the_dir,
+					int (*fn) (yaffs_obj_t *))
+{
+	struct ylist_head *i;
+	yaffs_obj_t *l;
+
+	if (!the_dir) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_find_by_name: null pointer directory"
+		    TENDSTR)));
+		YBUG();
+		return YAFFS_FAIL;
 	}
-
-	/* Clean it up... */
-	bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
-	bi->seq_number = 0;
-	dev->n_erased_blocks++;
-	bi->pages_in_use = 0;
-	bi->soft_del_pages = 0;
-	bi->has_shrink_hdr = 0;
-	bi->skip_erased_check = 1;	/* Clean, so no need to check */
-	bi->gc_prioritise = 0;
-	bi->has_summary = 0;
-
-	yaffs_clear_chunk_bits(dev, block_no);
-
-	yaffs_trace(YAFFS_TRACE_ERASE, "Erased block %d", block_no);
-}
-
-static inline int yaffs_gc_process_chunk(struct yaffs_dev *dev,
-					struct yaffs_block_info *bi,
-					int old_chunk, u8 *buffer)
-{
-	int new_chunk;
-	int mark_flash = 1;
-	struct yaffs_ext_tags tags;
-	struct yaffs_obj *object;
-	int matching_chunk;
-	int ret_val = YAFFS_OK;
-
-	memset(&tags, 0, sizeof(tags));
-	yaffs_rd_chunk_tags_nand(dev, old_chunk,
-				 buffer, &tags);
-	object = yaffs_find_by_number(dev, tags.obj_id);
-
-	yaffs_trace(YAFFS_TRACE_GC_DETAIL,
-		"Collecting chunk in block %d, %d %d %d ",
-		dev->gc_chunk, tags.obj_id,
-		tags.chunk_id, tags.n_bytes);
-
-	if (object && !yaffs_skip_verification(dev)) {
-		if (tags.chunk_id == 0)
-			matching_chunk =
-			    object->hdr_chunk;
-		else if (object->soft_del)
-			/* Defeat the test */
-			matching_chunk = old_chunk;
-		else
-			matching_chunk =
-			    yaffs_find_chunk_in_file
-			    (object, tags.chunk_id,
-			     NULL);
-
-		if (old_chunk != matching_chunk)
-			yaffs_trace(YAFFS_TRACE_ERROR,
-				"gc: page in gc mismatch: %d %d %d %d",
-				old_chunk,
-				matching_chunk,
-				tags.obj_id,
-				tags.chunk_id);
+	if (the_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_find_by_name: non-directory" TENDSTR)));
+		YBUG();
+		return YAFFS_FAIL;
 	}
 
-	if (!object) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"page %d in gc has no object: %d %d %d ",
-			old_chunk,
-			tags.obj_id, tags.chunk_id,
-			tags.n_bytes);
-	}
-
-	if (object &&
-	    object->deleted &&
-	    object->soft_del && tags.chunk_id != 0) {
-		/* Data chunk in a soft deleted file,
-		 * throw it away.
-		 * It's a soft deleted data chunk,
-		 * No need to copy this, just forget
-		 * about it and fix up the object.
-		 */
-
-		/* Free chunks already includes
-		 * softdeleted chunks, how ever this
-		 * chunk is going to soon be really
-		 * deleted which will increment free
-		 * chunks. We have to decrement free
-		 * chunks so this works out properly.
-		 */
-		dev->n_free_chunks--;
-		bi->soft_del_pages--;
-
-		object->n_data_chunks--;
-		if (object->n_data_chunks <= 0) {
-			/* remeber to clean up obj */
-			dev->gc_cleanup_list[dev->n_clean_ups] = tags.obj_id;
-			dev->n_clean_ups++;
-		}
-		mark_flash = 0;
-	} else if (object) {
-		/* It's either a data chunk in a live
-		 * file or an ObjectHeader, so we're
-		 * interested in it.
-		 * NB Need to keep the ObjectHeaders of
-		 * deleted files until the whole file
-		 * has been deleted off
-		 */
-		tags.serial_number++;
-		dev->n_gc_copies++;
-
-		if (tags.chunk_id == 0) {
-			/* It is an object Id,
-			 * We need to nuke the
-			 * shrinkheader flags since its
-			 * work is done.
-			 * Also need to clean up
-			 * shadowing.
-			 */
-			struct yaffs_obj_hdr *oh;
-			oh = (struct yaffs_obj_hdr *) buffer;
-
-			oh->is_shrink = 0;
-			tags.extra_is_shrink = 0;
-			oh->shadows_obj = 0;
-			oh->inband_shadowed_obj_id = 0;
-			tags.extra_shadows = 0;
-
-			/* Update file size */
-			if (object->variant_type == YAFFS_OBJECT_TYPE_FILE) {
-				yaffs_oh_size_load(oh,
-				    object->variant.file_variant.file_size);
-				tags.extra_file_size =
-				    object->variant.file_variant.file_size;
-			}
-
-			yaffs_verify_oh(object, oh, &tags, 1);
-			new_chunk =
-			    yaffs_write_new_chunk(dev, (u8 *) oh, &tags, 1);
-		} else {
-			new_chunk =
-			    yaffs_write_new_chunk(dev, buffer, &tags, 1);
-		}
-
-		if (new_chunk < 0) {
-			ret_val = YAFFS_FAIL;
-		} else {
-
-			/* Now fix up the Tnodes etc. */
-
-			if (tags.chunk_id == 0) {
-				/* It's a header */
-				object->hdr_chunk = new_chunk;
-				object->serial = tags.serial_number;
-			} else {
-				/* It's a data chunk */
-				yaffs_put_chunk_in_file(object, tags.chunk_id,
-							new_chunk, 0);
-			}
+	ylist_for_each(i, &the_dir->variant.dir_variant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_obj_t, siblings);
+			if (l && !fn(l))
+				return YAFFS_FAIL;
 		}
 	}
-	if (ret_val == YAFFS_OK)
-		yaffs_chunk_del(dev, old_chunk, mark_flash, __LINE__);
-	return ret_val;
+
+	return YAFFS_OK;
+
 }
-
-static int yaffs_gc_block(struct yaffs_dev *dev, int block, int whole_block)
-{
-	int old_chunk;
-	int ret_val = YAFFS_OK;
-	int i;
-	int is_checkpt_block;
-	int max_copies;
-	int chunks_before = yaffs_get_erased_chunks(dev);
-	int chunks_after;
-	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block);
-
-	is_checkpt_block = (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT);
-
-	yaffs_trace(YAFFS_TRACE_TRACING,
-		"Collecting block %d, in use %d, shrink %d, whole_block %d",
-		block, bi->pages_in_use, bi->has_shrink_hdr,
-		whole_block);
-
-	/*yaffs_verify_free_chunks(dev); */
-
-	if (bi->block_state == YAFFS_BLOCK_STATE_FULL)
-		bi->block_state = YAFFS_BLOCK_STATE_COLLECTING;
-
-	bi->has_shrink_hdr = 0;	/* clear the flag so that the block can erase */
-
-	dev->gc_disable = 1;
-
-	yaffs_summary_gc(dev, block);
-
-	if (is_checkpt_block || !yaffs_still_some_chunks(dev, block)) {
-		yaffs_trace(YAFFS_TRACE_TRACING,
-			"Collecting block %d that has no chunks in use",
-			block);
-		yaffs_block_became_dirty(dev, block);
-	} else {
-
-		u8 *buffer = yaffs_get_temp_buffer(dev);
-
-		yaffs_verify_blk(dev, bi, block);
-
-		max_copies = (whole_block) ? dev->param.chunks_per_block : 5;
-		old_chunk = block * dev->param.chunks_per_block + dev->gc_chunk;
-
-		for (/* init already done */ ;
-		     ret_val == YAFFS_OK &&
-		     dev->gc_chunk < dev->param.chunks_per_block &&
-		     (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) &&
-		     max_copies > 0;
-		     dev->gc_chunk++, old_chunk++) {
-			if (yaffs_check_chunk_bit(dev, block, dev->gc_chunk)) {
-				/* Page is in use and might need to be copied */
-				max_copies--;
-				ret_val = yaffs_gc_process_chunk(dev, bi,
-							old_chunk, buffer);
-			}
-		}
-		yaffs_release_temp_buffer(dev, buffer);
-	}
-
-	yaffs_verify_collected_blk(dev, bi, block);
-
-	if (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
-		/*
-		 * The gc did not complete. Set block state back to FULL
-		 * because checkpointing does not restore gc.
-		 */
-		bi->block_state = YAFFS_BLOCK_STATE_FULL;
-	} else {
-		/* The gc completed. */
-		/* Do any required cleanups */
-		for (i = 0; i < dev->n_clean_ups; i++) {
-			/* Time to delete the file too */
-			struct yaffs_obj *object =
-			    yaffs_find_by_number(dev, dev->gc_cleanup_list[i]);
-			if (object) {
-				yaffs_free_tnode(dev,
-					  object->variant.file_variant.top);
-				object->variant.file_variant.top = NULL;
-				yaffs_trace(YAFFS_TRACE_GC,
-					"yaffs: About to finally delete object %d",
-					object->obj_id);
-				yaffs_generic_obj_del(object);
-				object->my_dev->n_deleted_files--;
-			}
-
-		}
-		chunks_after = yaffs_get_erased_chunks(dev);
-		if (chunks_before >= chunks_after)
-			yaffs_trace(YAFFS_TRACE_GC,
-				"gc did not increase free chunks before %d after %d",
-				chunks_before, chunks_after);
-		dev->gc_block = 0;
-		dev->gc_chunk = 0;
-		dev->n_clean_ups = 0;
-	}
-
-	dev->gc_disable = 0;
-
-	return ret_val;
-}
-
-/*
- * find_gc_block() selects the dirtiest block (or close enough)
- * for garbage collection.
- */
-
-static unsigned yaffs_find_gc_block(struct yaffs_dev *dev,
-				    int aggressive, int background)
-{
-	int i;
-	int iterations;
-	unsigned selected = 0;
-	int prioritised = 0;
-	int prioritised_exist = 0;
-	struct yaffs_block_info *bi;
-	int threshold;
-
-	/* First let's see if we need to grab a prioritised block */
-	if (dev->has_pending_prioritised_gc && !aggressive) {
-		dev->gc_dirtiest = 0;
-		bi = dev->block_info;
-		for (i = dev->internal_start_block;
-		     i <= dev->internal_end_block && !selected; i++) {
-
-			if (bi->gc_prioritise) {
-				prioritised_exist = 1;
-				if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
-				    yaffs_block_ok_for_gc(dev, bi)) {
-					selected = i;
-					prioritised = 1;
-				}
-			}
-			bi++;
-		}
-
-		/*
-		 * If there is a prioritised block and none was selected then
-		 * this happened because there is at least one old dirty block
-		 * gumming up the works. Let's gc the oldest dirty block.
-		 */
-
-		if (prioritised_exist &&
-		    !selected && dev->oldest_dirty_block > 0)
-			selected = dev->oldest_dirty_block;
-
-		if (!prioritised_exist)	/* None found, so we can clear this */
-			dev->has_pending_prioritised_gc = 0;
-	}
-
-	/* If we're doing aggressive GC then we are happy to take a less-dirty
-	 * block, and search harder.
-	 * else (leasurely gc), then we only bother to do this if the
-	 * block has only a few pages in use.
-	 */
-
-	if (!selected) {
-		int pages_used;
-		int n_blocks =
-		    dev->internal_end_block - dev->internal_start_block + 1;
-		if (aggressive) {
-			threshold = dev->param.chunks_per_block;
-			iterations = n_blocks;
-		} else {
-			int max_threshold;
-
-			if (background)
-				max_threshold = dev->param.chunks_per_block / 2;
-			else
-				max_threshold = dev->param.chunks_per_block / 8;
-
-			if (max_threshold < YAFFS_GC_PASSIVE_THRESHOLD)
-				max_threshold = YAFFS_GC_PASSIVE_THRESHOLD;
-
-			threshold = background ? (dev->gc_not_done + 2) * 2 : 0;
-			if (threshold < YAFFS_GC_PASSIVE_THRESHOLD)
-				threshold = YAFFS_GC_PASSIVE_THRESHOLD;
-			if (threshold > max_threshold)
-				threshold = max_threshold;
-
-			iterations = n_blocks / 16 + 1;
-			if (iterations > 100)
-				iterations = 100;
-		}
-
-		for (i = 0;
-		     i < iterations &&
-		     (dev->gc_dirtiest < 1 ||
-		      dev->gc_pages_in_use > YAFFS_GC_GOOD_ENOUGH);
-		     i++) {
-			dev->gc_block_finder++;
-			if (dev->gc_block_finder < dev->internal_start_block ||
-			    dev->gc_block_finder > dev->internal_end_block)
-				dev->gc_block_finder =
-				    dev->internal_start_block;
-
-			bi = yaffs_get_block_info(dev, dev->gc_block_finder);
-
-			pages_used = bi->pages_in_use - bi->soft_del_pages;
-
-			if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
-			    pages_used < dev->param.chunks_per_block &&
-			    (dev->gc_dirtiest < 1 ||
-			     pages_used < dev->gc_pages_in_use) &&
-			    yaffs_block_ok_for_gc(dev, bi)) {
-				dev->gc_dirtiest = dev->gc_block_finder;
-				dev->gc_pages_in_use = pages_used;
-			}
-		}
-
-		if (dev->gc_dirtiest > 0 && dev->gc_pages_in_use <= threshold)
-			selected = dev->gc_dirtiest;
-	}
-
-	/*
-	 * If nothing has been selected for a while, try the oldest dirty
-	 * because that's gumming up the works.
-	 */
-
-	if (!selected && dev->param.is_yaffs2 &&
-	    dev->gc_not_done >= (background ? 10 : 20)) {
-		yaffs2_find_oldest_dirty_seq(dev);
-		if (dev->oldest_dirty_block > 0) {
-			selected = dev->oldest_dirty_block;
-			dev->gc_dirtiest = selected;
-			dev->oldest_dirty_gc_count++;
-			bi = yaffs_get_block_info(dev, selected);
-			dev->gc_pages_in_use =
-			    bi->pages_in_use - bi->soft_del_pages;
-		} else {
-			dev->gc_not_done = 0;
-		}
-	}
-
-	if (selected) {
-		yaffs_trace(YAFFS_TRACE_GC,
-			"GC Selected block %d with %d free, prioritised:%d",
-			selected,
-			dev->param.chunks_per_block - dev->gc_pages_in_use,
-			prioritised);
-
-		dev->n_gc_blocks++;
-		if (background)
-			dev->bg_gcs++;
-
-		dev->gc_dirtiest = 0;
-		dev->gc_pages_in_use = 0;
-		dev->gc_not_done = 0;
-		if (dev->refresh_skip > 0)
-			dev->refresh_skip--;
-	} else {
-		dev->gc_not_done++;
-		yaffs_trace(YAFFS_TRACE_GC,
-			"GC none: finder %d skip %d threshold %d dirtiest %d using %d oldest %d%s",
-			dev->gc_block_finder, dev->gc_not_done, threshold,
-			dev->gc_dirtiest, dev->gc_pages_in_use,
-			dev->oldest_dirty_block, background ? " bg" : "");
-	}
-
-	return selected;
-}
-
-/* New garbage collector
- * If we're very low on erased blocks then we do aggressive garbage collection
- * otherwise we do "leasurely" garbage collection.
- * Aggressive gc looks further (whole array) and will accept less dirty blocks.
- * Passive gc only inspects smaller areas and only accepts more dirty blocks.
- *
- * The idea is to help clear out space in a more spread-out manner.
- * Dunno if it really does anything useful.
- */
-static int yaffs_check_gc(struct yaffs_dev *dev, int background)
-{
-	int aggressive = 0;
-	int gc_ok = YAFFS_OK;
-	int max_tries = 0;
-	int min_erased;
-	int erased_chunks;
-	int checkpt_block_adjust;
-
-	if (dev->param.gc_control_fn &&
-		(dev->param.gc_control_fn(dev) & 1) == 0)
-		return YAFFS_OK;
-
-	if (dev->gc_disable)
-		/* Bail out so we don't get recursive gc */
-		return YAFFS_OK;
-
-	/* This loop should pass the first time.
-	 * Only loops here if the collection does not increase space.
-	 */
-
-	do {
-		max_tries++;
-
-		checkpt_block_adjust = yaffs_calc_checkpt_blocks_required(dev);
-
-		min_erased =
-		    dev->param.n_reserved_blocks + checkpt_block_adjust + 1;
-		erased_chunks =
-		    dev->n_erased_blocks * dev->param.chunks_per_block;
-
-		/* If we need a block soon then do aggressive gc. */
-		if (dev->n_erased_blocks < min_erased)
-			aggressive = 1;
-		else {
-			if (!background
-			    && erased_chunks > (dev->n_free_chunks / 4))
-				break;
-
-			if (dev->gc_skip > 20)
-				dev->gc_skip = 20;
-			if (erased_chunks < dev->n_free_chunks / 2 ||
-			    dev->gc_skip < 1 || background)
-				aggressive = 0;
-			else {
-				dev->gc_skip--;
-				break;
-			}
-		}
-
-		dev->gc_skip = 5;
-
-		/* If we don't already have a block being gc'd then see if we
-		 * should start another */
-
-		if (dev->gc_block < 1 && !aggressive) {
-			dev->gc_block = yaffs2_find_refresh_block(dev);
-			dev->gc_chunk = 0;
-			dev->n_clean_ups = 0;
-		}
-		if (dev->gc_block < 1) {
-			dev->gc_block =
-			    yaffs_find_gc_block(dev, aggressive, background);
-			dev->gc_chunk = 0;
-			dev->n_clean_ups = 0;
-		}
-
-		if (dev->gc_block > 0) {
-			dev->all_gcs++;
-			if (!aggressive)
-				dev->passive_gc_count++;
-
-			yaffs_trace(YAFFS_TRACE_GC,
-				"yaffs: GC n_erased_blocks %d aggressive %d",
-				dev->n_erased_blocks, aggressive);
-
-			gc_ok = yaffs_gc_block(dev, dev->gc_block, aggressive);
-		}
-
-		if (dev->n_erased_blocks < (dev->param.n_reserved_blocks) &&
-		    dev->gc_block > 0) {
-			yaffs_trace(YAFFS_TRACE_GC,
-				"yaffs: GC !!!no reclaim!!! n_erased_blocks %d after try %d block %d",
-				dev->n_erased_blocks, max_tries,
-				dev->gc_block);
-		}
-	} while ((dev->n_erased_blocks < dev->param.n_reserved_blocks) &&
-		 (dev->gc_block > 0) && (max_tries < 2));
-
-	return aggressive ? gc_ok : YAFFS_OK;
-}
-
-/*
- * yaffs_bg_gc()
- * Garbage collects. Intended to be called from a background thread.
- * Returns non-zero if at least half the free chunks are erased.
- */
-int yaffs_bg_gc(struct yaffs_dev *dev, unsigned urgency)
-{
-	int erased_chunks = dev->n_erased_blocks * dev->param.chunks_per_block;
-
-	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Background gc %u", urgency);
-
-	yaffs_check_gc(dev, 1);
-	return erased_chunks > dev->n_free_chunks / 2;
-}
-
-/*-------------------- Data file manipulation -----------------*/
-
-static int yaffs_rd_data_obj(struct yaffs_obj *in, int inode_chunk, u8 * buffer)
-{
-	int nand_chunk = yaffs_find_chunk_in_file(in, inode_chunk, NULL);
-
-	if (nand_chunk >= 0)
-		return yaffs_rd_chunk_tags_nand(in->my_dev, nand_chunk,
-						buffer, NULL);
-	else {
-		yaffs_trace(YAFFS_TRACE_NANDACCESS,
-			"Chunk %d not found zero instead",
-			nand_chunk);
-		/* get sane (zero) data if you read a hole */
-		memset(buffer, 0, in->my_dev->data_bytes_per_chunk);
-		return 0;
-	}
-
-}
-
-void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
-		     int lyn)
-{
-	int block;
-	int page;
-	struct yaffs_ext_tags tags;
-	struct yaffs_block_info *bi;
-
-	if (chunk_id <= 0)
-		return;
-
-	dev->n_deletions++;
-	block = chunk_id / dev->param.chunks_per_block;
-	page = chunk_id % dev->param.chunks_per_block;
-
-	if (!yaffs_check_chunk_bit(dev, block, page))
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Deleting invalid chunk %d", chunk_id);
-
-	bi = yaffs_get_block_info(dev, block);
-
-	yaffs2_update_oldest_dirty_seq(dev, block, bi);
-
-	yaffs_trace(YAFFS_TRACE_DELETION,
-		"line %d delete of chunk %d",
-		lyn, chunk_id);
-
-	if (!dev->param.is_yaffs2 && mark_flash &&
-	    bi->block_state != YAFFS_BLOCK_STATE_COLLECTING) {
-
-		memset(&tags, 0, sizeof(tags));
-		tags.is_deleted = 1;
-		yaffs_wr_chunk_tags_nand(dev, chunk_id, NULL, &tags);
-		yaffs_handle_chunk_update(dev, chunk_id, &tags);
-	} else {
-		dev->n_unmarked_deletions++;
-	}
-
-	/* Pull out of the management area.
-	 * If the whole block became dirty, this will kick off an erasure.
-	 */
-	if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING ||
-	    bi->block_state == YAFFS_BLOCK_STATE_FULL ||
-	    bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
-	    bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
-		dev->n_free_chunks++;
-		yaffs_clear_chunk_bit(dev, block, page);
-		bi->pages_in_use--;
-
-		if (bi->pages_in_use == 0 &&
-		    !bi->has_shrink_hdr &&
-		    bi->block_state != YAFFS_BLOCK_STATE_ALLOCATING &&
-		    bi->block_state != YAFFS_BLOCK_STATE_NEEDS_SCAN) {
-			yaffs_block_became_dirty(dev, block);
-		}
-	}
-}
-
-static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
-			     const u8 *buffer, int n_bytes, int use_reserve)
-{
-	/* Find old chunk Need to do this to get serial number
-	 * Write new one and patch into tree.
-	 * Invalidate old tags.
-	 */
-
-	int prev_chunk_id;
-	struct yaffs_ext_tags prev_tags;
-	int new_chunk_id;
-	struct yaffs_ext_tags new_tags;
-	struct yaffs_dev *dev = in->my_dev;
-
-	yaffs_check_gc(dev, 0);
-
-	/* Get the previous chunk at this location in the file if it exists.
-	 * If it does not exist then put a zero into the tree. This creates
-	 * the tnode now, rather than later when it is harder to clean up.
-	 */
-	prev_chunk_id = yaffs_find_chunk_in_file(in, inode_chunk, &prev_tags);
-	if (prev_chunk_id < 1 &&
-	    !yaffs_put_chunk_in_file(in, inode_chunk, 0, 0))
-		return 0;
-
-	/* Set up new tags */
-	memset(&new_tags, 0, sizeof(new_tags));
-
-	new_tags.chunk_id = inode_chunk;
-	new_tags.obj_id = in->obj_id;
-	new_tags.serial_number =
-	    (prev_chunk_id > 0) ? prev_tags.serial_number + 1 : 1;
-	new_tags.n_bytes = n_bytes;
-
-	if (n_bytes < 1 || n_bytes > dev->param.total_bytes_per_chunk) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-		  "Writing %d bytes to chunk!!!!!!!!!",
-		   n_bytes);
-		BUG();
-	}
-
-	new_chunk_id =
-	    yaffs_write_new_chunk(dev, buffer, &new_tags, use_reserve);
-
-	if (new_chunk_id > 0) {
-		yaffs_put_chunk_in_file(in, inode_chunk, new_chunk_id, 0);
-
-		if (prev_chunk_id > 0)
-			yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
-
-		yaffs_verify_file_sane(in);
-	}
-	return new_chunk_id;
-
-}
-
-
-
-static int yaffs_do_xattrib_mod(struct yaffs_obj *obj, int set,
-				const YCHAR *name, const void *value, int size,
-				int flags)
-{
-	struct yaffs_xattr_mod xmod;
-	int result;
-
-	xmod.set = set;
-	xmod.name = name;
-	xmod.data = value;
-	xmod.size = size;
-	xmod.flags = flags;
-	xmod.result = -ENOSPC;
-
-	result = yaffs_update_oh(obj, NULL, 0, 0, 0, &xmod);
-
-	if (result > 0)
-		return xmod.result;
-	else
-		return -ENOSPC;
-}
-
-static int yaffs_apply_xattrib_mod(struct yaffs_obj *obj, char *buffer,
-				   struct yaffs_xattr_mod *xmod)
-{
-	int retval = 0;
-	int x_offs = sizeof(struct yaffs_obj_hdr);
-	struct yaffs_dev *dev = obj->my_dev;
-	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
-	char *x_buffer = buffer + x_offs;
-
-	if (xmod->set)
-		retval =
-		    nval_set(x_buffer, x_size, xmod->name, xmod->data,
-			     xmod->size, xmod->flags);
-	else
-		retval = nval_del(x_buffer, x_size, xmod->name);
-
-	obj->has_xattr = nval_hasvalues(x_buffer, x_size);
-	obj->xattr_known = 1;
-	xmod->result = retval;
-
-	return retval;
-}
-
-static int yaffs_do_xattrib_fetch(struct yaffs_obj *obj, const YCHAR *name,
-				  void *value, int size)
-{
-	char *buffer = NULL;
-	int result;
-	struct yaffs_ext_tags tags;
-	struct yaffs_dev *dev = obj->my_dev;
-	int x_offs = sizeof(struct yaffs_obj_hdr);
-	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
-	char *x_buffer;
-	int retval = 0;
-
-	if (obj->hdr_chunk < 1)
-		return -ENODATA;
-
-	/* If we know that the object has no xattribs then don't do all the
-	 * reading and parsing.
-	 */
-	if (obj->xattr_known && !obj->has_xattr) {
-		if (name)
-			return -ENODATA;
-		else
-			return 0;
-	}
-
-	buffer = (char *)yaffs_get_temp_buffer(dev);
-	if (!buffer)
-		return -ENOMEM;
-
-	result =
-	    yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, (u8 *) buffer, &tags);
-
-	if (result != YAFFS_OK)
-		retval = -ENOENT;
-	else {
-		x_buffer = buffer + x_offs;
-
-		if (!obj->xattr_known) {
-			obj->has_xattr = nval_hasvalues(x_buffer, x_size);
-			obj->xattr_known = 1;
-		}
-
-		if (name)
-			retval = nval_get(x_buffer, x_size, name, value, size);
-		else
-			retval = nval_list(x_buffer, x_size, value, size);
-	}
-	yaffs_release_temp_buffer(dev, (u8 *) buffer);
-	return retval;
-}
-
-int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR * name,
-		      const void *value, int size, int flags)
-{
-	return yaffs_do_xattrib_mod(obj, 1, name, value, size, flags);
-}
-
-int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR * name)
-{
-	return yaffs_do_xattrib_mod(obj, 0, name, NULL, 0, 0);
-}
-
-int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR * name, void *value,
-		      int size)
-{
-	return yaffs_do_xattrib_fetch(obj, name, value, size);
-}
-
-int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size)
-{
-	return yaffs_do_xattrib_fetch(obj, NULL, buffer, size);
-}
-
-static void yaffs_check_obj_details_loaded(struct yaffs_obj *in)
-{
-	u8 *buf;
-	struct yaffs_obj_hdr *oh;
-	struct yaffs_dev *dev;
-	struct yaffs_ext_tags tags;
-	int result;
-	int alloc_failed = 0;
-
-	if (!in || !in->lazy_loaded || in->hdr_chunk < 1)
-		return;
-
-	dev = in->my_dev;
-	in->lazy_loaded = 0;
-	buf = yaffs_get_temp_buffer(dev);
-
-	result = yaffs_rd_chunk_tags_nand(dev, in->hdr_chunk, buf, &tags);
-	oh = (struct yaffs_obj_hdr *)buf;
-
-	in->yst_mode = oh->yst_mode;
-	yaffs_load_attribs(in, oh);
-	yaffs_set_obj_name_from_oh(in, oh);
-
-	if (in->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
-		in->variant.symlink_variant.alias =
-		    yaffs_clone_str(oh->alias);
-		if (!in->variant.symlink_variant.alias)
-			alloc_failed = 1;	/* Not returned */
-	}
-	yaffs_release_temp_buffer(dev, buf);
-}
-
-/* UpdateObjectHeader updates the header on NAND for an object.
- * If name is not NULL, then that new name is used.
- */
-int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name, int force,
-		    int is_shrink, int shadows, struct yaffs_xattr_mod *xmod)
-{
-
-	struct yaffs_block_info *bi;
-	struct yaffs_dev *dev = in->my_dev;
-	int prev_chunk_id;
-	int ret_val = 0;
-	int result = 0;
-	int new_chunk_id;
-	struct yaffs_ext_tags new_tags;
-	struct yaffs_ext_tags old_tags;
-	const YCHAR *alias = NULL;
-	u8 *buffer = NULL;
-	YCHAR old_name[YAFFS_MAX_NAME_LENGTH + 1];
-	struct yaffs_obj_hdr *oh = NULL;
-	loff_t file_size = 0;
-
-	strcpy(old_name, _Y("silly old name"));
-
-	if (in->fake && in != dev->root_dir && !force && !xmod)
-		return ret_val;
-
-	yaffs_check_gc(dev, 0);
-	yaffs_check_obj_details_loaded(in);
-
-	buffer = yaffs_get_temp_buffer(in->my_dev);
-	oh = (struct yaffs_obj_hdr *)buffer;
-
-	prev_chunk_id = in->hdr_chunk;
-
-	if (prev_chunk_id > 0) {
-		result = yaffs_rd_chunk_tags_nand(dev, prev_chunk_id,
-						  buffer, &old_tags);
-
-		yaffs_verify_oh(in, oh, &old_tags, 0);
-		memcpy(old_name, oh->name, sizeof(oh->name));
-		memset(buffer, 0xff, sizeof(struct yaffs_obj_hdr));
-	} else {
-		memset(buffer, 0xff, dev->data_bytes_per_chunk);
-	}
-
-	oh->type = in->variant_type;
-	oh->yst_mode = in->yst_mode;
-	oh->shadows_obj = oh->inband_shadowed_obj_id = shadows;
-
-	yaffs_load_attribs_oh(oh, in);
-
-	if (in->parent)
-		oh->parent_obj_id = in->parent->obj_id;
-	else
-		oh->parent_obj_id = 0;
-
-	if (name && *name) {
-		memset(oh->name, 0, sizeof(oh->name));
-		yaffs_load_oh_from_name(dev, oh->name, name);
-	} else if (prev_chunk_id > 0) {
-		memcpy(oh->name, old_name, sizeof(oh->name));
-	} else {
-		memset(oh->name, 0, sizeof(oh->name));
-	}
-
-	oh->is_shrink = is_shrink;
-
-	switch (in->variant_type) {
-	case YAFFS_OBJECT_TYPE_UNKNOWN:
-		/* Should not happen */
-		break;
-	case YAFFS_OBJECT_TYPE_FILE:
-		if (oh->parent_obj_id != YAFFS_OBJECTID_DELETED &&
-		    oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED)
-			file_size = in->variant.file_variant.file_size;
-		yaffs_oh_size_load(oh, file_size);
-		break;
-	case YAFFS_OBJECT_TYPE_HARDLINK:
-		oh->equiv_id = in->variant.hardlink_variant.equiv_id;
-		break;
-	case YAFFS_OBJECT_TYPE_SPECIAL:
-		/* Do nothing */
-		break;
-	case YAFFS_OBJECT_TYPE_DIRECTORY:
-		/* Do nothing */
-		break;
-	case YAFFS_OBJECT_TYPE_SYMLINK:
-		alias = in->variant.symlink_variant.alias;
-		if (!alias)
-			alias = _Y("no alias");
-		strncpy(oh->alias, alias, YAFFS_MAX_ALIAS_LENGTH);
-		oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
-		break;
-	}
-
-	/* process any xattrib modifications */
-	if (xmod)
-		yaffs_apply_xattrib_mod(in, (char *)buffer, xmod);
-
-	/* Tags */
-	memset(&new_tags, 0, sizeof(new_tags));
-	in->serial++;
-	new_tags.chunk_id = 0;
-	new_tags.obj_id = in->obj_id;
-	new_tags.serial_number = in->serial;
-
-	/* Add extra info for file header */
-	new_tags.extra_available = 1;
-	new_tags.extra_parent_id = oh->parent_obj_id;
-	new_tags.extra_file_size = file_size;
-	new_tags.extra_is_shrink = oh->is_shrink;
-	new_tags.extra_equiv_id = oh->equiv_id;
-	new_tags.extra_shadows = (oh->shadows_obj > 0) ? 1 : 0;
-	new_tags.extra_obj_type = in->variant_type;
-	yaffs_verify_oh(in, oh, &new_tags, 1);
-
-	/* Create new chunk in NAND */
-	new_chunk_id =
-	    yaffs_write_new_chunk(dev, buffer, &new_tags,
-				  (prev_chunk_id > 0) ? 1 : 0);
-
-	if (buffer)
-		yaffs_release_temp_buffer(dev, buffer);
-
-	if (new_chunk_id < 0)
-		return new_chunk_id;
-
-	in->hdr_chunk = new_chunk_id;
-
-	if (prev_chunk_id > 0)
-		yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
-
-	if (!yaffs_obj_cache_dirty(in))
-		in->dirty = 0;
-
-	/* If this was a shrink, then mark the block
-	 * that the chunk lives on */
-	if (is_shrink) {
-		bi = yaffs_get_block_info(in->my_dev,
-					  new_chunk_id /
-					  in->my_dev->param.chunks_per_block);
-		bi->has_shrink_hdr = 1;
-	}
-
-
-	return new_chunk_id;
-}
-
-/*--------------------- File read/write ------------------------
- * Read and write have very similar structures.
- * In general the read/write has three parts to it
- * An incomplete chunk to start with (if the read/write is not chunk-aligned)
- * Some complete chunks
- * An incomplete chunk to end off with
- *
- * Curve-balls: the first chunk might also be the last chunk.
- */
-
-int yaffs_file_rd(struct yaffs_obj *in, u8 * buffer, loff_t offset, int n_bytes)
-{
-	int chunk;
-	u32 start;
-	int n_copy;
-	int n = n_bytes;
-	int n_done = 0;
-	struct yaffs_cache *cache;
-	struct yaffs_dev *dev;
-
-	dev = in->my_dev;
-
-	while (n > 0) {
-		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
-		chunk++;
-
-		/* OK now check for the curveball where the start and end are in
-		 * the same chunk.
-		 */
-		if ((start + n) < dev->data_bytes_per_chunk)
-			n_copy = n;
-		else
-			n_copy = dev->data_bytes_per_chunk - start;
-
-		cache = yaffs_find_chunk_cache(in, chunk);
-
-		/* If the chunk is already in the cache or it is less than
-		 * a whole chunk or we're using inband tags then use the cache
-		 * (if there is caching) else bypass the cache.
-		 */
-		if (cache || n_copy != dev->data_bytes_per_chunk ||
-		    dev->param.inband_tags) {
-			if (dev->param.n_caches > 0) {
-
-				/* If we can't find the data in the cache,
-				 * then load it up. */
-
-				if (!cache) {
-					cache =
-					    yaffs_grab_chunk_cache(in->my_dev);
-					cache->object = in;
-					cache->chunk_id = chunk;
-					cache->dirty = 0;
-					cache->locked = 0;
-					yaffs_rd_data_obj(in, chunk,
-							  cache->data);
-					cache->n_bytes = 0;
-				}
-
-				yaffs_use_cache(dev, cache, 0);
-
-				cache->locked = 1;
-
-				memcpy(buffer, &cache->data[start], n_copy);
-
-				cache->locked = 0;
-			} else {
-				/* Read into the local buffer then copy.. */
-
-				u8 *local_buffer =
-				    yaffs_get_temp_buffer(dev);
-				yaffs_rd_data_obj(in, chunk, local_buffer);
-
-				memcpy(buffer, &local_buffer[start], n_copy);
-
-				yaffs_release_temp_buffer(dev, local_buffer);
-			}
-		} else {
-			/* A full chunk. Read directly into the buffer. */
-			yaffs_rd_data_obj(in, chunk, buffer);
-		}
-		n -= n_copy;
-		offset += n_copy;
-		buffer += n_copy;
-		n_done += n_copy;
-	}
-	return n_done;
-}
-
-int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
-		     int n_bytes, int write_through)
-{
-
-	int chunk;
-	u32 start;
-	int n_copy;
-	int n = n_bytes;
-	int n_done = 0;
-	int n_writeback;
-	loff_t start_write = offset;
-	int chunk_written = 0;
-	u32 n_bytes_read;
-	loff_t chunk_start;
-	struct yaffs_dev *dev;
-
-	dev = in->my_dev;
-
-	while (n > 0 && chunk_written >= 0) {
-		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
-
-		if (((loff_t)chunk) *
-		    dev->data_bytes_per_chunk + start != offset ||
-		    start >= dev->data_bytes_per_chunk) {
-			yaffs_trace(YAFFS_TRACE_ERROR,
-				"AddrToChunk of offset %lld gives chunk %d start %d",
-				offset, chunk, start);
-		}
-		chunk++;	/* File pos to chunk in file offset */
-
-		/* OK now check for the curveball where the start and end are in
-		 * the same chunk.
-		 */
-
-		if ((start + n) < dev->data_bytes_per_chunk) {
-			n_copy = n;
-
-			/* Now calculate how many bytes to write back....
-			 * If we're overwriting and not writing to then end of
-			 * file then we need to write back as much as was there
-			 * before.
-			 */
-
-			chunk_start = (((loff_t)(chunk - 1)) *
-					dev->data_bytes_per_chunk);
-
-			if (chunk_start > in->variant.file_variant.file_size)
-				n_bytes_read = 0;	/* Past end of file */
-			else
-				n_bytes_read =
-				    in->variant.file_variant.file_size -
-				    chunk_start;
-
-			if (n_bytes_read > dev->data_bytes_per_chunk)
-				n_bytes_read = dev->data_bytes_per_chunk;
-
-			n_writeback =
-			    (n_bytes_read >
-			     (start + n)) ? n_bytes_read : (start + n);
-
-			if (n_writeback < 0 ||
-			    n_writeback > dev->data_bytes_per_chunk)
-				BUG();
-
-		} else {
-			n_copy = dev->data_bytes_per_chunk - start;
-			n_writeback = dev->data_bytes_per_chunk;
-		}
-
-		if (n_copy != dev->data_bytes_per_chunk ||
-		    !dev->param.cache_bypass_aligned ||
-		    dev->param.inband_tags) {
-			/* An incomplete start or end chunk (or maybe both
-			 * start and end chunk), or we're using inband tags,
-			 * or we're forcing writes through the cache,
-			 * so we want to use the cache buffers.
-			 */
-			if (dev->param.n_caches > 0) {
-				struct yaffs_cache *cache;
-
-				/* If we can't find the data in the cache, then
-				 * load the cache */
-				cache = yaffs_find_chunk_cache(in, chunk);
-
-				if (!cache &&
-				    yaffs_check_alloc_available(dev, 1)) {
-					cache = yaffs_grab_chunk_cache(dev);
-					cache->object = in;
-					cache->chunk_id = chunk;
-					cache->dirty = 0;
-					cache->locked = 0;
-					yaffs_rd_data_obj(in, chunk,
-							  cache->data);
-				} else if (cache &&
-					   !cache->dirty &&
-					   !yaffs_check_alloc_available(dev,
-									1)) {
-					/* Drop the cache if it was a read cache
-					 * item and no space check has been made
-					 * for it.
-					 */
-					cache = NULL;
-				}
-
-				if (cache) {
-					yaffs_use_cache(dev, cache, 1);
-					cache->locked = 1;
-
-					memcpy(&cache->data[start], buffer,
-					       n_copy);
-
-					cache->locked = 0;
-					cache->n_bytes = n_writeback;
-
-					if (write_through) {
-						chunk_written =
-						    yaffs_wr_data_obj
-						    (cache->object,
-						     cache->chunk_id,
-						     cache->data,
-						     cache->n_bytes, 1);
-						cache->dirty = 0;
-					}
-				} else {
-					chunk_written = -1;	/* fail write */
-				}
-			} else {
-				/* An incomplete start or end chunk (or maybe
-				 * both start and end chunk). Read into the
-				 * local buffer then copy over and write back.
-				 */
-
-				u8 *local_buffer = yaffs_get_temp_buffer(dev);
-
-				yaffs_rd_data_obj(in, chunk, local_buffer);
-				memcpy(&local_buffer[start], buffer, n_copy);
-
-				chunk_written =
-				    yaffs_wr_data_obj(in, chunk,
-						      local_buffer,
-						      n_writeback, 0);
-
-				yaffs_release_temp_buffer(dev, local_buffer);
-			}
-		} else {
-			/* A full chunk. Write directly from the buffer. */
-
-			chunk_written =
-			    yaffs_wr_data_obj(in, chunk, buffer,
-					      dev->data_bytes_per_chunk, 0);
-
-			/* Since we've overwritten the cached data,
-			 * we better invalidate it. */
-			yaffs_invalidate_chunk_cache(in, chunk);
-		}
-
-		if (chunk_written >= 0) {
-			n -= n_copy;
-			offset += n_copy;
-			buffer += n_copy;
-			n_done += n_copy;
-		}
-	}
-
-	/* Update file object */
-
-	if ((start_write + n_done) > in->variant.file_variant.file_size)
-		in->variant.file_variant.file_size = (start_write + n_done);
-
-	in->dirty = 1;
-	return n_done;
-}
-
-int yaffs_wr_file(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
-		  int n_bytes, int write_through)
-{
-	yaffs2_handle_hole(in, offset);
-	return yaffs_do_file_wr(in, buffer, offset, n_bytes, write_through);
-}
-
-/* ---------------------- File resizing stuff ------------------ */
-
-static void yaffs_prune_chunks(struct yaffs_obj *in, loff_t new_size)
-{
-
-	struct yaffs_dev *dev = in->my_dev;
-	loff_t old_size = in->variant.file_variant.file_size;
-	int i;
-	int chunk_id;
-	u32 dummy;
-	int last_del;
-	int start_del;
-
-	if (old_size > 0)
-		yaffs_addr_to_chunk(dev, old_size - 1, &last_del, &dummy);
-	else
-		last_del = 0;
-
-	yaffs_addr_to_chunk(dev, new_size + dev->data_bytes_per_chunk - 1,
-				&start_del, &dummy);
-	last_del++;
-	start_del++;
-
-	/* Delete backwards so that we don't end up with holes if
-	 * power is lost part-way through the operation.
-	 */
-	for (i = last_del; i >= start_del; i--) {
-		/* NB this could be optimised somewhat,
-		 * eg. could retrieve the tags and write them without
-		 * using yaffs_chunk_del
-		 */
-
-		chunk_id = yaffs_find_del_file_chunk(in, i, NULL);
-
-		if (chunk_id < 1)
-			continue;
-
-		if (chunk_id <
-		    (dev->internal_start_block * dev->param.chunks_per_block) ||
-		    chunk_id >=
-		    ((dev->internal_end_block + 1) *
-		      dev->param.chunks_per_block)) {
-			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"Found daft chunk_id %d for %d",
-				chunk_id, i);
-		} else {
-			in->n_data_chunks--;
-			yaffs_chunk_del(dev, chunk_id, 1, __LINE__);
-		}
-	}
-}
-
-void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size)
-{
-	int new_full;
-	u32 new_partial;
-	struct yaffs_dev *dev = obj->my_dev;
-
-	yaffs_addr_to_chunk(dev, new_size, &new_full, &new_partial);
-
-	yaffs_prune_chunks(obj, new_size);
-
-	if (new_partial != 0) {
-		int last_chunk = 1 + new_full;
-		u8 *local_buffer = yaffs_get_temp_buffer(dev);
-
-		/* Rewrite the last chunk with its new size and zero pad */
-		yaffs_rd_data_obj(obj, last_chunk, local_buffer);
-		memset(local_buffer + new_partial, 0,
-		       dev->data_bytes_per_chunk - new_partial);
-
-		yaffs_wr_data_obj(obj, last_chunk, local_buffer,
-				  new_partial, 1);
-
-		yaffs_release_temp_buffer(dev, local_buffer);
-	}
-
-	obj->variant.file_variant.file_size = new_size;
-
-	yaffs_prune_tree(dev, &obj->variant.file_variant);
-}
-
-int yaffs_resize_file(struct yaffs_obj *in, loff_t new_size)
-{
-	struct yaffs_dev *dev = in->my_dev;
-	loff_t old_size = in->variant.file_variant.file_size;
-
-	yaffs_flush_file_cache(in, 1);
-	yaffs_invalidate_whole_cache(in);
-
-	yaffs_check_gc(dev, 0);
-
-	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE)
-		return YAFFS_FAIL;
-
-	if (new_size == old_size)
-		return YAFFS_OK;
-
-	if (new_size > old_size) {
-		yaffs2_handle_hole(in, new_size);
-		in->variant.file_variant.file_size = new_size;
-	} else {
-		/* new_size < old_size */
-		yaffs_resize_file_down(in, new_size);
-	}
-
-	/* Write a new object header to reflect the resize.
-	 * show we've shrunk the file, if need be
-	 * Do this only if the file is not in the deleted directories
-	 * and is not shadowed.
-	 */
-	if (in->parent &&
-	    !in->is_shadowed &&
-	    in->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
-	    in->parent->obj_id != YAFFS_OBJECTID_DELETED)
-		yaffs_update_oh(in, NULL, 0, 0, 0, NULL);
-
-	return YAFFS_OK;
-}
-
-int yaffs_flush_file(struct yaffs_obj *in,
-		     int update_time,
-		     int data_sync,
-		     int discard_cache)
-{
-	if (!in->dirty)
-		return YAFFS_OK;
-
-	yaffs_flush_file_cache(in, discard_cache);
-
-	if (data_sync)
-		return YAFFS_OK;
-
-	if (update_time)
-		yaffs_load_current_time(in, 0, 0);
-
-	return (yaffs_update_oh(in, NULL, 0, 0, 0, NULL) >= 0) ?
-				YAFFS_OK : YAFFS_FAIL;
-}
-
-
-/* yaffs_del_file deletes the whole file data
- * and the inode associated with the file.
- * It does not delete the links associated with the file.
- */
-static int yaffs_unlink_file_if_needed(struct yaffs_obj *in)
-{
-	int ret_val;
-	int del_now = 0;
-	struct yaffs_dev *dev = in->my_dev;
-
-	if (!in->my_inode)
-		del_now = 1;
-
-	if (del_now) {
-		ret_val =
-		    yaffs_change_obj_name(in, in->my_dev->del_dir,
-					  _Y("deleted"), 0, 0);
-		yaffs_trace(YAFFS_TRACE_TRACING,
-			"yaffs: immediate deletion of file %d",
-			in->obj_id);
-		in->deleted = 1;
-		in->my_dev->n_deleted_files++;
-		if (dev->param.disable_soft_del || dev->param.is_yaffs2)
-			yaffs_resize_file(in, 0);
-		yaffs_soft_del_file(in);
-	} else {
-		ret_val =
-		    yaffs_change_obj_name(in, in->my_dev->unlinked_dir,
-					  _Y("unlinked"), 0, 0);
-	}
-	return ret_val;
-}
-
-static int yaffs_del_file(struct yaffs_obj *in)
-{
-	int ret_val = YAFFS_OK;
-	int deleted;	/* Need to cache value on stack if in is freed */
-	struct yaffs_dev *dev = in->my_dev;
-
-	if (dev->param.disable_soft_del || dev->param.is_yaffs2)
-		yaffs_resize_file(in, 0);
-
-	if (in->n_data_chunks > 0) {
-		/* Use soft deletion if there is data in the file.
-		 * That won't be the case if it has been resized to zero.
-		 */
-		if (!in->unlinked)
-			ret_val = yaffs_unlink_file_if_needed(in);
-
-		deleted = in->deleted;
-
-		if (ret_val == YAFFS_OK && in->unlinked && !in->deleted) {
-			in->deleted = 1;
-			deleted = 1;
-			in->my_dev->n_deleted_files++;
-			yaffs_soft_del_file(in);
-		}
-		return deleted ? YAFFS_OK : YAFFS_FAIL;
-	} else {
-		/* The file has no data chunks so we toss it immediately */
-		yaffs_free_tnode(in->my_dev, in->variant.file_variant.top);
-		in->variant.file_variant.top = NULL;
-		yaffs_generic_obj_del(in);
-
-		return YAFFS_OK;
-	}
-}
-
-int yaffs_is_non_empty_dir(struct yaffs_obj *obj)
-{
-	return (obj &&
-		obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY) &&
-		!(list_empty(&obj->variant.dir_variant.children));
-}
-
-static int yaffs_del_dir(struct yaffs_obj *obj)
-{
-	/* First check that the directory is empty. */
-	if (yaffs_is_non_empty_dir(obj))
-		return YAFFS_FAIL;
-
-	return yaffs_generic_obj_del(obj);
-}
-
-static int yaffs_del_symlink(struct yaffs_obj *in)
-{
-	kfree(in->variant.symlink_variant.alias);
-	in->variant.symlink_variant.alias = NULL;
-
-	return yaffs_generic_obj_del(in);
-}
-
-static int yaffs_del_link(struct yaffs_obj *in)
-{
-	/* remove this hardlink from the list associated with the equivalent
-	 * object
-	 */
-	list_del_init(&in->hard_links);
-	return yaffs_generic_obj_del(in);
-}
-
-int yaffs_del_obj(struct yaffs_obj *obj)
-{
-	int ret_val = -1;
-
-	switch (obj->variant_type) {
-	case YAFFS_OBJECT_TYPE_FILE:
-		ret_val = yaffs_del_file(obj);
-		break;
-	case YAFFS_OBJECT_TYPE_DIRECTORY:
-		if (!list_empty(&obj->variant.dir_variant.dirty)) {
-			yaffs_trace(YAFFS_TRACE_BACKGROUND,
-				"Remove object %d from dirty directories",
-				obj->obj_id);
-			list_del_init(&obj->variant.dir_variant.dirty);
-		}
-		return yaffs_del_dir(obj);
-		break;
-	case YAFFS_OBJECT_TYPE_SYMLINK:
-		ret_val = yaffs_del_symlink(obj);
-		break;
-	case YAFFS_OBJECT_TYPE_HARDLINK:
-		ret_val = yaffs_del_link(obj);
-		break;
-	case YAFFS_OBJECT_TYPE_SPECIAL:
-		ret_val = yaffs_generic_obj_del(obj);
-		break;
-	case YAFFS_OBJECT_TYPE_UNKNOWN:
-		ret_val = 0;
-		break;		/* should not happen. */
-	}
-	return ret_val;
-}
-
-
-static void yaffs_empty_dir_to_dir(struct yaffs_obj *from_dir,
-				   struct yaffs_obj *to_dir)
-{
-	struct yaffs_obj *obj;
-	struct list_head *lh;
-	struct list_head *n;
-
-	list_for_each_safe(lh, n, &from_dir->variant.dir_variant.children) {
-		obj = list_entry(lh, struct yaffs_obj, siblings);
-		yaffs_add_obj_to_dir(to_dir, obj);
-	}
-}
-
-struct yaffs_obj *yaffs_retype_obj(struct yaffs_obj *obj,
-				   enum yaffs_obj_type type)
-{
-	/* Tear down the old variant */
-	switch (obj->variant_type) {
-	case YAFFS_OBJECT_TYPE_FILE:
-		/* Nuke file data */
-		yaffs_resize_file(obj, 0);
-		yaffs_free_tnode(obj->my_dev, obj->variant.file_variant.top);
-		obj->variant.file_variant.top = NULL;
-		break;
-	case YAFFS_OBJECT_TYPE_DIRECTORY:
-		/* Put the children in lost and found. */
-		yaffs_empty_dir_to_dir(obj, obj->my_dev->lost_n_found);
-		if (!list_empty(&obj->variant.dir_variant.dirty))
-			list_del_init(&obj->variant.dir_variant.dirty);
-		break;
-	case YAFFS_OBJECT_TYPE_SYMLINK:
-		/* Nuke symplink data */
-		kfree(obj->variant.symlink_variant.alias);
-		obj->variant.symlink_variant.alias = NULL;
-		break;
-	case YAFFS_OBJECT_TYPE_HARDLINK:
-		list_del_init(&obj->hard_links);
-		break;
-	default:
-		break;
-	}
-
-	memset(&obj->variant, 0, sizeof(obj->variant));
-
-	/*Set up new variant if the memset is not enough. */
-	switch (type) {
-	case YAFFS_OBJECT_TYPE_DIRECTORY:
-		INIT_LIST_HEAD(&obj->variant.dir_variant.children);
-		INIT_LIST_HEAD(&obj->variant.dir_variant.dirty);
-		break;
-	case YAFFS_OBJECT_TYPE_FILE:
-	case YAFFS_OBJECT_TYPE_SYMLINK:
-	case YAFFS_OBJECT_TYPE_HARDLINK:
-	default:
-		break;
-	}
-
-	obj->variant_type = type;
-
-	return obj;
-
-}
-
-static int yaffs_unlink_worker(struct yaffs_obj *obj)
-{
-	int del_now = 0;
-
-	if (!obj)
-		return YAFFS_FAIL;
-
-	if (!obj->my_inode)
-		del_now = 1;
-
-	yaffs_update_parent(obj->parent);
-
-	if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
-		return yaffs_del_link(obj);
-	} else if (!list_empty(&obj->hard_links)) {
-		/* Curve ball: We're unlinking an object that has a hardlink.
-		 *
-		 * This problem arises because we are not strictly following
-		 * The Linux link/inode model.
-		 *
-		 * We can't really delete the object.
-		 * Instead, we do the following:
-		 * - Select a hardlink.
-		 * - Unhook it from the hard links
-		 * - Move it from its parent directory so that the rename works.
-		 * - Rename the object to the hardlink's name.
-		 * - Delete the hardlink
-		 */
-
-		struct yaffs_obj *hl;
-		struct yaffs_obj *parent;
-		int ret_val;
-		YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
-
-		hl = list_entry(obj->hard_links.next, struct yaffs_obj,
-				hard_links);
-
-		yaffs_get_obj_name(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
-		parent = hl->parent;
-
-		list_del_init(&hl->hard_links);
-
-		yaffs_add_obj_to_dir(obj->my_dev->unlinked_dir, hl);
-
-		ret_val = yaffs_change_obj_name(obj, parent, name, 0, 0);
-
-		if (ret_val == YAFFS_OK)
-			ret_val = yaffs_generic_obj_del(hl);
-
-		return ret_val;
-
-	} else if (del_now) {
-		switch (obj->variant_type) {
-		case YAFFS_OBJECT_TYPE_FILE:
-			return yaffs_del_file(obj);
-			break;
-		case YAFFS_OBJECT_TYPE_DIRECTORY:
-			list_del_init(&obj->variant.dir_variant.dirty);
-			return yaffs_del_dir(obj);
-			break;
-		case YAFFS_OBJECT_TYPE_SYMLINK:
-			return yaffs_del_symlink(obj);
-			break;
-		case YAFFS_OBJECT_TYPE_SPECIAL:
-			return yaffs_generic_obj_del(obj);
-			break;
-		case YAFFS_OBJECT_TYPE_HARDLINK:
-		case YAFFS_OBJECT_TYPE_UNKNOWN:
-		default:
-			return YAFFS_FAIL;
-		}
-	} else if (yaffs_is_non_empty_dir(obj)) {
-		return YAFFS_FAIL;
-	} else {
-		return yaffs_change_obj_name(obj, obj->my_dev->unlinked_dir,
-						_Y("unlinked"), 0, 0);
-	}
-}
-
-static int yaffs_unlink_obj(struct yaffs_obj *obj)
-{
-	if (obj && obj->unlink_allowed)
-		return yaffs_unlink_worker(obj);
-
-	return YAFFS_FAIL;
-}
-
-int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR *name)
-{
-	struct yaffs_obj *obj;
-
-	obj = yaffs_find_by_name(dir, name);
-	return yaffs_unlink_obj(obj);
-}
-
-/* Note:
- * If old_name is NULL then we take old_dir as the object to be renamed.
- */
-int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR *old_name,
-		     struct yaffs_obj *new_dir, const YCHAR *new_name)
-{
-	struct yaffs_obj *obj = NULL;
-	struct yaffs_obj *existing_target = NULL;
-	int force = 0;
-	int result;
-	struct yaffs_dev *dev;
-
-	if (!old_dir || old_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
-		BUG();
-		return YAFFS_FAIL;
-	}
-	if (!new_dir || new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
-		BUG();
-		return YAFFS_FAIL;
-	}
-
-	dev = old_dir->my_dev;
-
-#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
-	/* Special case for case insemsitive systems.
-	 * While look-up is case insensitive, the name isn't.
-	 * Therefore we might want to change x.txt to X.txt
-	 */
-	if (old_dir == new_dir &&
-		old_name && new_name &&
-		strcmp(old_name, new_name) == 0)
-		force = 1;
 #endif
 
-	if (strnlen(new_name, YAFFS_MAX_NAME_LENGTH + 1) >
-	    YAFFS_MAX_NAME_LENGTH)
-		/* ENAMETOOLONG */
-		return YAFFS_FAIL;
-
-	if (old_name)
-		obj = yaffs_find_by_name(old_dir, old_name);
-	else{
-		obj = old_dir;
-		old_dir = obj->parent;
-	}
-
-	if (obj && obj->rename_allowed) {
-		/* Now handle an existing target, if there is one */
-		existing_target = yaffs_find_by_name(new_dir, new_name);
-		if (yaffs_is_non_empty_dir(existing_target)) {
-			return YAFFS_FAIL;	/* ENOTEMPTY */
-		} else if (existing_target && existing_target != obj) {
-			/* Nuke the target first, using shadowing,
-			 * but only if it isn't the same object.
-			 *
-			 * Note we must disable gc here otherwise it can mess
-			 * up the shadowing.
-			 *
-			 */
-			dev->gc_disable = 1;
-			yaffs_change_obj_name(obj, new_dir, new_name, force,
-					      existing_target->obj_id);
-			existing_target->is_shadowed = 1;
-			yaffs_unlink_obj(existing_target);
-			dev->gc_disable = 0;
-		}
-
-		result = yaffs_change_obj_name(obj, new_dir, new_name, 1, 0);
-
-		yaffs_update_parent(old_dir);
-		if (new_dir != old_dir)
-			yaffs_update_parent(new_dir);
-
-		return result;
-	}
-	return YAFFS_FAIL;
-}
-
-/*----------------------- Initialisation Scanning ---------------------- */
-
-void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
-			       int backward_scanning)
-{
-	struct yaffs_obj *obj;
-
-	if (backward_scanning) {
-		/* Handle YAFFS2 case (backward scanning)
-		 * If the shadowed object exists then ignore.
-		 */
-		obj = yaffs_find_by_number(dev, obj_id);
-		if (obj)
-			return;
-	}
-
-	/* Let's create it (if it does not exist) assuming it is a file so that
-	 * it can do shrinking etc.
-	 * We put it in unlinked dir to be cleaned up after the scanning
-	 */
-	obj =
-	    yaffs_find_or_create_by_number(dev, obj_id, YAFFS_OBJECT_TYPE_FILE);
-	if (!obj)
-		return;
-	obj->is_shadowed = 1;
-	yaffs_add_obj_to_dir(dev->unlinked_dir, obj);
-	obj->variant.file_variant.shrink_size = 0;
-	obj->valid = 1;		/* So that we don't read any other info. */
-}
-
-void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list)
-{
-	struct list_head *lh;
-	struct list_head *save;
-	struct yaffs_obj *hl;
-	struct yaffs_obj *in;
-
-	list_for_each_safe(lh, save, hard_list) {
-		hl = list_entry(lh, struct yaffs_obj, hard_links);
-		in = yaffs_find_by_number(dev,
-					hl->variant.hardlink_variant.equiv_id);
-
-		if (in) {
-			/* Add the hardlink pointers */
-			hl->variant.hardlink_variant.equiv_obj = in;
-			list_add(&hl->hard_links, &in->hard_links);
-		} else {
-			/* Todo Need to report/handle this better.
-			 * Got a problem... hardlink to a non-existant object
-			 */
-			hl->variant.hardlink_variant.equiv_obj = NULL;
-			INIT_LIST_HEAD(&hl->hard_links);
-		}
-	}
-}
-
-static void yaffs_strip_deleted_objs(struct yaffs_dev *dev)
-{
-	/*
-	 *  Sort out state of unlinked and deleted objects after scanning.
-	 */
-	struct list_head *i;
-	struct list_head *n;
-	struct yaffs_obj *l;
-
-	if (dev->read_only)
-		return;
-
-	/* Soft delete all the unlinked files */
-	list_for_each_safe(i, n,
-			   &dev->unlinked_dir->variant.dir_variant.children) {
-		l = list_entry(i, struct yaffs_obj, siblings);
-		yaffs_del_obj(l);
-	}
-
-	list_for_each_safe(i, n, &dev->del_dir->variant.dir_variant.children) {
-		l = list_entry(i, struct yaffs_obj, siblings);
-		yaffs_del_obj(l);
-	}
-}
-
-/*
- * This code iterates through all the objects making sure that they are rooted.
- * Any unrooted objects are re-rooted in lost+found.
- * An object needs to be in one of:
- * - Directly under deleted, unlinked
- * - Directly or indirectly under root.
- *
- * Note:
- *  This code assumes that we don't ever change the current relationships
- *  between directories:
- *   root_dir->parent == unlinked_dir->parent == del_dir->parent == NULL
- *   lost-n-found->parent == root_dir
- *
- * This fixes the problem where directories might have inadvertently been
- * deleted leaving the object "hanging" without being rooted in the
- * directory tree.
- */
-
-static int yaffs_has_null_parent(struct yaffs_dev *dev, struct yaffs_obj *obj)
-{
-	return (obj == dev->del_dir ||
-		obj == dev->unlinked_dir || obj == dev->root_dir);
-}
-
-static void yaffs_fix_hanging_objs(struct yaffs_dev *dev)
-{
-	struct yaffs_obj *obj;
-	struct yaffs_obj *parent;
-	int i;
-	struct list_head *lh;
-	struct list_head *n;
-	int depth_limit;
-	int hanging;
-
-	if (dev->read_only)
-		return;
-
-	/* Iterate through the objects in each hash entry,
-	 * looking at each object.
-	 * Make sure it is rooted.
-	 */
-
-	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
-		list_for_each_safe(lh, n, &dev->obj_bucket[i].list) {
-			obj = list_entry(lh, struct yaffs_obj, hash_link);
-			parent = obj->parent;
-
-			if (yaffs_has_null_parent(dev, obj)) {
-				/* These directories are not hanging */
-				hanging = 0;
-			} else if (!parent ||
-				   parent->variant_type !=
-				   YAFFS_OBJECT_TYPE_DIRECTORY) {
-				hanging = 1;
-			} else if (yaffs_has_null_parent(dev, parent)) {
-				hanging = 0;
-			} else {
-				/*
-				 * Need to follow the parent chain to
-				 * see if it is hanging.
-				 */
-				hanging = 0;
-				depth_limit = 100;
-
-				while (parent != dev->root_dir &&
-				       parent->parent &&
-				       parent->parent->variant_type ==
-				       YAFFS_OBJECT_TYPE_DIRECTORY &&
-				       depth_limit > 0) {
-					parent = parent->parent;
-					depth_limit--;
-				}
-				if (parent != dev->root_dir)
-					hanging = 1;
-			}
-			if (hanging) {
-				yaffs_trace(YAFFS_TRACE_SCAN,
-					"Hanging object %d moved to lost and found",
-					obj->obj_id);
-				yaffs_add_obj_to_dir(dev->lost_n_found, obj);
-			}
-		}
-	}
-}
-
-/*
- * Delete directory contents for cleaning up lost and found.
- */
-static void yaffs_del_dir_contents(struct yaffs_obj *dir)
-{
-	struct yaffs_obj *obj;
-	struct list_head *lh;
-	struct list_head *n;
-
-	if (dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
-		BUG();
-
-	list_for_each_safe(lh, n, &dir->variant.dir_variant.children) {
-		obj = list_entry(lh, struct yaffs_obj, siblings);
-		if (obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY)
-			yaffs_del_dir_contents(obj);
-		yaffs_trace(YAFFS_TRACE_SCAN,
-			"Deleting lost_found object %d",
-			obj->obj_id);
-		yaffs_unlink_obj(obj);
-	}
-}
-
-static void yaffs_empty_l_n_f(struct yaffs_dev *dev)
-{
-	yaffs_del_dir_contents(dev->lost_n_found);
-}
-
-
-struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *directory,
-				     const YCHAR *name)
-{
-	int sum;
-	struct list_head *i;
-	YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
-	struct yaffs_obj *l;
-
-	if (!name)
-		return NULL;
-
-	if (!directory) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"tragedy: yaffs_find_by_name: null pointer directory"
-			);
-		BUG();
-		return NULL;
-	}
-	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"tragedy: yaffs_find_by_name: non-directory"
-			);
-		BUG();
-	}
-
-	sum = yaffs_calc_name_sum(name);
-
-	list_for_each(i, &directory->variant.dir_variant.children) {
-		l = list_entry(i, struct yaffs_obj, siblings);
-
-		if (l->parent != directory)
-			BUG();
-
-		yaffs_check_obj_details_loaded(l);
-
-		/* Special case for lost-n-found */
-		if (l->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
-			if (!strcmp(name, YAFFS_LOSTNFOUND_NAME))
-				return l;
-		} else if (l->sum == sum || l->hdr_chunk <= 0) {
-			/* LostnFound chunk called Objxxx
-			 * Do a real check
-			 */
-			yaffs_get_obj_name(l, buffer,
-				YAFFS_MAX_NAME_LENGTH + 1);
-			if (!strncmp(name, buffer, YAFFS_MAX_NAME_LENGTH))
-				return l;
-		}
-	}
-	return NULL;
-}
-
 /* GetEquivalentObject dereferences any hard links to get to the
  * actual object.
  */
 
-struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj)
+yaffs_obj_t *yaffs_get_equivalent_obj(yaffs_obj_t *obj)
 {
 	if (obj && obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+		/* We want the object id of the equivalent object, not this one */
 		obj = obj->variant.hardlink_variant.equiv_obj;
 		yaffs_check_obj_details_loaded(obj);
 	}
@@ -4450,106 +4651,173 @@ struct yaffs_obj *yaffs_get_equivalent_o
  * system to share files.
  *
  * These automatic unicode are stored slightly differently...
- *  - If the name can fit in the ASCII character space then they are saved as
+ *  - If the name can fit in the ASCII character space then they are saved as 
  *    ascii names as per above.
  *  - If the name needs Unicode then the name is saved in Unicode
  *    starting at oh->name[1].
 
  */
-static void yaffs_fix_null_name(struct yaffs_obj *obj, YCHAR *name,
-				int buffer_size)
+static void yaffs_fix_null_name(yaffs_obj_t * obj,YCHAR * name, int buffer_size)
 {
 	/* Create an object name if we could not find one. */
-	if (strnlen(name, YAFFS_MAX_NAME_LENGTH) == 0) {
-		YCHAR local_name[20];
-		YCHAR num_string[20];
-		YCHAR *x = &num_string[19];
+	if(yaffs_strnlen(name,YAFFS_MAX_NAME_LENGTH) == 0){
+		YCHAR locName[20];
+		YCHAR numString[20];
+		YCHAR *x = &numString[19];
 		unsigned v = obj->obj_id;
-		num_string[19] = 0;
-		while (v > 0) {
+		numString[19] = 0;
+		while(v>0){
 			x--;
 			*x = '0' + (v % 10);
 			v /= 10;
 		}
 		/* make up a name */
-		strcpy(local_name, YAFFS_LOSTNFOUND_PREFIX);
-		strcat(local_name, x);
-		strncpy(name, local_name, buffer_size - 1);
+		yaffs_strcpy(locName, YAFFS_LOSTNFOUND_PREFIX);
+		yaffs_strcat(locName,x);
+		yaffs_strncpy(name, locName, buffer_size - 1);
 	}
 }
 
-int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR *name, int buffer_size)
+static void yaffs_load_name_from_oh(yaffs_dev_t *dev,YCHAR *name, const YCHAR *ohName, int bufferSize)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	if(dev->param.auto_unicode){
+		if(*ohName){
+			/* It is an ASCII name, so do an ASCII to unicode conversion */
+			const char *asciiOhName = (const char *)ohName;
+			int n = bufferSize - 1;
+			while(n > 0 && *asciiOhName){
+				*name = *asciiOhName;
+				name++;
+				asciiOhName++;
+				n--;
+			}
+		} else 
+			yaffs_strncpy(name,ohName+1, bufferSize -1);
+	} else
+#endif
+		yaffs_strncpy(name, ohName, bufferSize - 1);
+}
+
+
+static void yaffs_load_oh_from_name(yaffs_dev_t *dev, YCHAR *ohName, const YCHAR *name)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+
+	int isAscii;
+	YCHAR *w;
+
+	if(dev->param.auto_unicode){
+
+		isAscii = 1;
+		w = name;
+	
+		/* Figure out if the name will fit in ascii character set */
+		while(isAscii && *w){
+			if((*w) & 0xff00)
+				isAscii = 0;
+			w++;
+		}
+
+		if(isAscii){
+			/* It is an ASCII name, so do a unicode to ascii conversion */
+			char *asciiOhName = (char *)ohName;
+			int n = YAFFS_MAX_NAME_LENGTH  - 1;
+			while(n > 0 && *name){
+				*asciiOhName= *name;
+				name++;
+				asciiOhName++;
+				n--;
+			}
+		} else{
+			/* It is a unicode name, so save starting at the second YCHAR */
+			*ohName = 0;
+			yaffs_strncpy(ohName+1,name, YAFFS_MAX_NAME_LENGTH -2);
+		}
+	}
+	else 
+#endif
+		yaffs_strncpy(ohName,name, YAFFS_MAX_NAME_LENGTH - 1);
+
+}
+
+int yaffs_get_obj_name(yaffs_obj_t * obj, YCHAR * name, int buffer_size)
 {
 	memset(name, 0, buffer_size * sizeof(YCHAR));
+	
 	yaffs_check_obj_details_loaded(obj);
+
 	if (obj->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
-		strncpy(name, YAFFS_LOSTNFOUND_NAME, buffer_size - 1);
-	} else if (obj->short_name[0]) {
-		strcpy(name, obj->short_name);
-	} else if (obj->hdr_chunk > 0) {
+		yaffs_strncpy(name, YAFFS_LOSTNFOUND_NAME, buffer_size - 1);
+	} 
+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+	else if (obj->short_name[0]) {
+		yaffs_strcpy(name, obj->short_name);
+	}
+#endif
+	else if(obj->hdr_chunk > 0) {
 		int result;
-		u8 *buffer = yaffs_get_temp_buffer(obj->my_dev);
-
-		struct yaffs_obj_hdr *oh = (struct yaffs_obj_hdr *)buffer;
+		__u8 *buffer = yaffs_get_temp_buffer(obj->my_dev, __LINE__);
+
+		yaffs_obj_header *oh = (yaffs_obj_header *) buffer;
 
 		memset(buffer, 0, obj->my_dev->data_bytes_per_chunk);
 
 		if (obj->hdr_chunk > 0) {
 			result = yaffs_rd_chunk_tags_nand(obj->my_dev,
-							  obj->hdr_chunk,
-							  buffer, NULL);
+							obj->hdr_chunk, buffer,
+							NULL);
 		}
-		yaffs_load_name_from_oh(obj->my_dev, name, oh->name,
-					buffer_size);
-
-		yaffs_release_temp_buffer(obj->my_dev, buffer);
+		yaffs_load_name_from_oh(obj->my_dev,name,oh->name,buffer_size);
+
+		yaffs_release_temp_buffer(obj->my_dev, buffer, __LINE__);
 	}
 
-	yaffs_fix_null_name(obj, name, buffer_size);
-
-	return strnlen(name, YAFFS_MAX_NAME_LENGTH);
+	yaffs_fix_null_name(obj,name,buffer_size);
+
+	return yaffs_strnlen(name,YAFFS_MAX_NAME_LENGTH);
 }
 
-loff_t yaffs_get_obj_length(struct yaffs_obj *obj)
+
+int yaffs_get_obj_length(yaffs_obj_t *obj)
 {
 	/* Dereference any hard linking */
 	obj = yaffs_get_equivalent_obj(obj);
 
 	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
 		return obj->variant.file_variant.file_size;
-	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
-		if (!obj->variant.symlink_variant.alias)
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK){
+		if(!obj->variant.symlink_variant.alias)
 			return 0;
-		return strnlen(obj->variant.symlink_variant.alias,
-				     YAFFS_MAX_ALIAS_LENGTH);
+		return yaffs_strnlen(obj->variant.symlink_variant.alias,YAFFS_MAX_ALIAS_LENGTH);
 	} else {
 		/* Only a directory should drop through to here */
 		return obj->my_dev->data_bytes_per_chunk;
 	}
 }
 
-int yaffs_get_obj_link_count(struct yaffs_obj *obj)
+int yaffs_get_obj_link_count(yaffs_obj_t *obj)
 {
 	int count = 0;
-	struct list_head *i;
+	struct ylist_head *i;
 
 	if (!obj->unlinked)
-		count++;	/* the object itself */
-
-	list_for_each(i, &obj->hard_links)
-	    count++;		/* add the hard links; */
+		count++;		/* the object itself */
+
+	ylist_for_each(i, &obj->hard_links)
+		count++;		/* add the hard links; */
 
 	return count;
 }
 
-int yaffs_get_obj_inode(struct yaffs_obj *obj)
+int yaffs_get_obj_inode(yaffs_obj_t *obj)
 {
 	obj = yaffs_get_equivalent_obj(obj);
 
 	return obj->obj_id;
 }
 
-unsigned yaffs_get_obj_type(struct yaffs_obj *obj)
+unsigned yaffs_get_obj_type(yaffs_obj_t *obj)
 {
 	obj = yaffs_get_equivalent_obj(obj);
 
@@ -4575,15 +4843,13 @@ unsigned yaffs_get_obj_type(struct yaffs
 			return DT_BLK;
 		if (S_ISSOCK(obj->yst_mode))
 			return DT_SOCK;
-		return DT_REG;
-		break;
 	default:
 		return DT_REG;
 		break;
 	}
 }
 
-YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj)
+YCHAR *yaffs_get_symlink_alias(yaffs_obj_t *obj)
 {
 	obj = yaffs_get_equivalent_obj(obj);
 	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK)
@@ -4592,82 +4858,276 @@ YCHAR *yaffs_get_symlink_alias(struct ya
 		return yaffs_clone_str(_Y(""));
 }
 
-/*--------------------------- Initialisation code -------------------------- */
-
-static int yaffs_check_dev_fns(struct yaffs_dev *dev)
+#ifndef CONFIG_YAFFS_WINCE
+
+int yaffs_set_attribs(yaffs_obj_t *obj, struct iattr *attr)
 {
-	struct yaffs_driver *drv = &dev->drv;
-	struct yaffs_tags_handler *tagger = &dev->tagger;
+	unsigned int valid = attr->ia_valid;
+
+	if (valid & ATTR_MODE)
+		obj->yst_mode = attr->ia_mode;
+	if (valid & ATTR_UID)
+		obj->yst_uid = attr->ia_uid;
+	if (valid & ATTR_GID)
+		obj->yst_gid = attr->ia_gid;
+
+	if (valid & ATTR_ATIME)
+		obj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);
+	if (valid & ATTR_CTIME)
+		obj->yst_ctime = Y_TIME_CONVERT(attr->ia_ctime);
+	if (valid & ATTR_MTIME)
+		obj->yst_mtime = Y_TIME_CONVERT(attr->ia_mtime);
+
+	if (valid & ATTR_SIZE)
+		yaffs_resize_file(obj, attr->ia_size);
+
+	yaffs_update_oh(obj, NULL, 1, 0, 0, NULL);
+
+	return YAFFS_OK;
+
+}
+int yaffs_get_attribs(yaffs_obj_t *obj, struct iattr *attr)
+{
+	unsigned int valid = 0;
+
+	attr->ia_mode = obj->yst_mode;
+	valid |= ATTR_MODE;
+	attr->ia_uid = obj->yst_uid;
+	valid |= ATTR_UID;
+	attr->ia_gid = obj->yst_gid;
+	valid |= ATTR_GID;
+
+	Y_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;
+	valid |= ATTR_ATIME;
+	Y_TIME_CONVERT(attr->ia_ctime) = obj->yst_ctime;
+	valid |= ATTR_CTIME;
+	Y_TIME_CONVERT(attr->ia_mtime) = obj->yst_mtime;
+	valid |= ATTR_MTIME;
+
+	attr->ia_size = yaffs_get_file_size(obj);
+	valid |= ATTR_SIZE;
+
+	attr->ia_valid = valid;
+
+	return YAFFS_OK;
+}
+
+#endif
+
+
+static int yaffs_do_xattrib_mod(yaffs_obj_t *obj, int set, const YCHAR *name, const void *value, int size, int flags)
+{
+	yaffs_xattr_mod xmod;
+
+	int result;
+
+	xmod.set = set;
+	xmod.name = name;
+	xmod.data = value;
+	xmod.size =  size;
+	xmod.flags = flags;
+	xmod.result = -ENOSPC;
+
+	result = yaffs_update_oh(obj, NULL, 0, 0, 0, &xmod);
+
+	if(result > 0)
+		return xmod.result;
+	else
+		return -ENOSPC;
+}
+
+static int yaffs_apply_xattrib_mod(yaffs_obj_t *obj, char *buffer, yaffs_xattr_mod *xmod)
+{
+	int retval = 0;
+	int x_offs = sizeof(yaffs_obj_header);
+	yaffs_dev_t *dev = obj->my_dev;
+	int x_size = dev->data_bytes_per_chunk - sizeof(yaffs_obj_header);
+
+	char * x_buffer = buffer + x_offs;
+
+	if(xmod->set)
+		retval = nval_set(x_buffer, x_size, xmod->name, xmod->data, xmod->size, xmod->flags);
+	else
+		retval = nval_del(x_buffer, x_size, xmod->name);
+
+	obj->has_xattr = nval_hasvalues(x_buffer, x_size);
+	obj->xattr_known = 1;
+
+	xmod->result = retval;
+
+	return retval;
+}
+
+static int yaffs_do_xattrib_fetch(yaffs_obj_t *obj, const YCHAR *name, void *value, int size)
+{
+	char *buffer = NULL;
+	int result;
+	yaffs_ext_tags tags;
+	yaffs_dev_t *dev = obj->my_dev;
+	int x_offs = sizeof(yaffs_obj_header);
+	int x_size = dev->data_bytes_per_chunk - sizeof(yaffs_obj_header);
+
+	char * x_buffer;
+
+	int retval = 0;
+
+	if(obj->hdr_chunk < 1)
+		return -ENODATA;
+
+	/* If we know that the object has no xattribs then don't do all the
+	 * reading and parsing.
+	 */
+	if(obj->xattr_known && !obj->has_xattr){
+		if(name)
+			return -ENODATA;
+		else
+			return 0;
+	}
+
+	buffer = (char *) yaffs_get_temp_buffer(dev, __LINE__);
+	if(!buffer)
+		return -ENOMEM;
+
+	result = yaffs_rd_chunk_tags_nand(dev,obj->hdr_chunk, (__u8 *)buffer, &tags);
+
+	if(result != YAFFS_OK)
+		retval = -ENOENT;
+	else{
+		x_buffer =  buffer + x_offs;
+
+		if (!obj->xattr_known){
+			obj->has_xattr = nval_hasvalues(x_buffer, x_size);
+			obj->xattr_known = 1;
+		}
+
+		if(name)
+			retval = nval_get(x_buffer, x_size, name, value, size);
+		else
+			retval = nval_list(x_buffer, x_size, value,size);
+	}
+	yaffs_release_temp_buffer(dev,(__u8 *)buffer,__LINE__);
+	return retval;
+}
+
+int yaffs_set_xattrib(yaffs_obj_t *obj, const YCHAR *name, const void * value, int size, int flags)
+{
+	return yaffs_do_xattrib_mod(obj, 1, name, value, size, flags);
+}
+
+int yaffs_remove_xattrib(yaffs_obj_t *obj, const YCHAR *name)
+{
+	return yaffs_do_xattrib_mod(obj, 0, name, NULL, 0, 0);
+}
+
+int yaffs_get_xattrib(yaffs_obj_t *obj, const YCHAR *name, void *value, int size)
+{
+	return yaffs_do_xattrib_fetch(obj, name, value, size);
+}
+
+int yaffs_list_xattrib(yaffs_obj_t *obj, char *buffer, int size)
+{
+	return yaffs_do_xattrib_fetch(obj, NULL, buffer,size);
+}
+
+
+
+#if 0
+int yaffs_dump_obj(yaffs_obj_t *obj)
+{
+	YCHAR name[257];
+
+	yaffs_get_obj_name(obj, name, YAFFS_MAX_NAME_LENGTH + 1);
+
+	T(YAFFS_TRACE_ALWAYS,
+	  (TSTR
+	   ("Object %d, inode %d \"%s\"\n dirty %d valid %d serial %d sum %d"
+	    " chunk %d type %d size %d\n"
+	    TENDSTR), obj->obj_id, yaffs_get_obj_inode(obj), name,
+	   obj->dirty, obj->valid, obj->serial, obj->sum, obj->hdr_chunk,
+	   yaffs_get_obj_type(obj), yaffs_get_obj_length(obj)));
+
+	return YAFFS_OK;
+}
+#endif
+
+/*---------------------------- Initialisation code -------------------------------------- */
+
+static int yaffs_cehck_dev_fns(const yaffs_dev_t *dev)
+{
 
 	/* Common functions, gotta have */
-	if (!drv->drv_read_chunk_fn ||
-	    !drv->drv_write_chunk_fn ||
-	    !drv->drv_erase_fn)
+	if (!dev->param.erase_fn || !dev->param.initialise_flash_fn)
 		return 0;
 
-	if (dev->param.is_yaffs2 &&
-	     (!drv->drv_mark_bad_fn  || !drv->drv_check_bad_fn))
-		return 0;
-
-	/* Install the default tags marshalling functions if needed. */
-	yaffs_tags_compat_install(dev);
-	yaffs_tags_marshall_install(dev);
-
-	/* Check we now have the marshalling functions required. */
-	if (!tagger->write_chunk_tags_fn ||
-	    !tagger->read_chunk_tags_fn ||
-	    !tagger->query_block_fn ||
-	    !tagger->mark_bad_fn)
-		return 0;
-
-	return 1;
+#ifdef CONFIG_YAFFS_YAFFS2
+
+	/* Can use the "with tags" style interface for yaffs1 or yaffs2 */
+	if (dev->param.write_chunk_tags_fn &&
+	    dev->param.read_chunk_tags_fn &&
+	    !dev->param.write_chunk_fn &&
+	    !dev->param.read_chunk_fn &&
+	    dev->param.bad_block_fn &&
+	    dev->param.query_block_fn)
+		return 1;
+#endif
+
+	/* Can use the "spare" style interface for yaffs1 */
+	if (!dev->param.is_yaffs2 &&
+	    !dev->param.write_chunk_tags_fn &&
+	    !dev->param.read_chunk_tags_fn &&
+	    dev->param.write_chunk_fn &&
+	    dev->param.read_chunk_fn &&
+	    !dev->param.bad_block_fn &&
+	    !dev->param.query_block_fn)
+		return 1;
+
+	return 0;	/* bad */
 }
 
-static int yaffs_create_initial_dir(struct yaffs_dev *dev)
+
+static int yaffs_create_initial_dir(yaffs_dev_t *dev)
 {
-	/* Initialise the unlinked, deleted, root and lost+found directories */
-	dev->lost_n_found = dev->root_dir = NULL;
+	/* Initialise the unlinked, deleted, root and lost and found directories */
+
+	dev->lost_n_found = dev->root_dir =  NULL;
 	dev->unlinked_dir = dev->del_dir = NULL;
+
 	dev->unlinked_dir =
 	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
+
 	dev->del_dir =
 	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
+
 	dev->root_dir =
 	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_ROOT,
-				  YAFFS_ROOT_MODE | S_IFDIR);
+				      YAFFS_ROOT_MODE | S_IFDIR);
 	dev->lost_n_found =
 	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_LOSTNFOUND,
-				  YAFFS_LOSTNFOUND_MODE | S_IFDIR);
-
-	if (dev->lost_n_found && dev->root_dir && dev->unlinked_dir
-	    && dev->del_dir) {
+				      YAFFS_LOSTNFOUND_MODE | S_IFDIR);
+
+	if (dev->lost_n_found && dev->root_dir && dev->unlinked_dir && dev->del_dir) {
 		yaffs_add_obj_to_dir(dev->root_dir, dev->lost_n_found);
 		return YAFFS_OK;
 	}
+
 	return YAFFS_FAIL;
 }
 
-/* Low level init.
- * Typically only used by yaffs_guts_initialise, but also used by the
- * Low level yaffs driver tests.
- */
-
-int yaffs_guts_ll_init(struct yaffs_dev *dev)
+int yaffs_guts_initialise(yaffs_dev_t *dev)
 {
-
-
-	yaffs_trace(YAFFS_TRACE_TRACING, "yaffs: yaffs_ll_init()");
+	int init_failed = 0;
+	unsigned x;
+	int bits;
+
+	T(YAFFS_TRACE_TRACING, (TSTR("yaffs: yaffs_guts_initialise()" TENDSTR)));
+
+	/* Check stuff that must be set */
 
 	if (!dev) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"yaffs: Need a device"
-			);
+		T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Need a device" TENDSTR)));
 		return YAFFS_FAIL;
 	}
 
-	if (dev->ll_init)
-		return YAFFS_OK;
-
 	dev->internal_start_block = dev->param.start_block;
 	dev->internal_end_block = dev->param.end_block;
 	dev->block_offset = 0;
@@ -4685,89 +5145,58 @@ int yaffs_guts_ll_init(struct yaffs_dev 
 
 	/* Check geometry parameters. */
 
-	if ((!dev->param.inband_tags && dev->param.is_yaffs2 &&
-		dev->param.total_bytes_per_chunk < 1024) ||
-		(!dev->param.is_yaffs2 &&
-			dev->param.total_bytes_per_chunk < 512) ||
-		(dev->param.inband_tags && !dev->param.is_yaffs2) ||
-		 dev->param.chunks_per_block < 2 ||
-		 dev->param.n_reserved_blocks < 2 ||
-		dev->internal_start_block <= 0 ||
-		dev->internal_end_block <= 0 ||
-		dev->internal_end_block <=
-		(dev->internal_start_block + dev->param.n_reserved_blocks + 2)
-		) {
-		/* otherwise it is too small */
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"NAND geometry problems: chunk size %d, type is yaffs%s, inband_tags %d ",
-			dev->param.total_bytes_per_chunk,
-			dev->param.is_yaffs2 ? "2" : "",
-			dev->param.inband_tags);
+	if ((!dev->param.inband_tags && dev->param.is_yaffs2 && dev->param.total_bytes_per_chunk < 1024) ||
+	    (!dev->param.is_yaffs2 && dev->param.total_bytes_per_chunk < 512) ||
+	    (dev->param.inband_tags && !dev->param.is_yaffs2) ||
+	     dev->param.chunks_per_block < 2 ||
+	     dev->param.n_reserved_blocks < 2 ||
+	     dev->internal_start_block <= 0 ||
+	     dev->internal_end_block <= 0 ||
+	     dev->internal_end_block <= (dev->internal_start_block + dev->param.n_reserved_blocks + 2)) {	/* otherwise it is too small */
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("yaffs: NAND geometry problems: chunk size %d, type is yaffs%s, inband_tags %d "
+		    TENDSTR), dev->param.total_bytes_per_chunk, dev->param.is_yaffs2 ? "2" : "", dev->param.inband_tags));
 		return YAFFS_FAIL;
 	}
 
+	if (yaffs_init_nand(dev) != YAFFS_OK) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs: InitialiseNAND failed" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
 	/* Sort out space for inband tags, if required */
 	if (dev->param.inband_tags)
-		dev->data_bytes_per_chunk =
-		    dev->param.total_bytes_per_chunk -
-		    sizeof(struct yaffs_packed_tags2_tags_only);
+		dev->data_bytes_per_chunk = dev->param.total_bytes_per_chunk - sizeof(yaffs_PackedTags2TagsPart);
 	else
 		dev->data_bytes_per_chunk = dev->param.total_bytes_per_chunk;
 
 	/* Got the right mix of functions? */
-	if (!yaffs_check_dev_fns(dev)) {
+	if (!yaffs_cehck_dev_fns(dev)) {
 		/* Function missing */
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"device function(s) missing or wrong");
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("yaffs: device function(s) missing or wrong\n" TENDSTR)));
 
 		return YAFFS_FAIL;
 	}
 
-	if (yaffs_init_nand(dev) != YAFFS_OK) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS, "InitialiseNAND failed");
+	/* This is really a compilation check. */
+	if (!yaffs_check_structures()) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs_check_structures failed\n" TENDSTR)));
 		return YAFFS_FAIL;
 	}
 
-	return YAFFS_OK;
-}
-
-
-int yaffs_guts_format_dev(struct yaffs_dev *dev)
-{
-	int i;
-	enum yaffs_block_state state;
-	u32 dummy;
-
-	if(yaffs_guts_ll_init(dev) != YAFFS_OK)
-		return YAFFS_FAIL;
-
-	if(dev->is_mounted)
-		return YAFFS_FAIL;
-
-	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
-		yaffs_query_init_block_state(dev, i, &state, &dummy);
-		if (state != YAFFS_BLOCK_STATE_DEAD)
-			yaffs_erase_block(dev, i);
-	}
-
-	return YAFFS_OK;
-}
-
-
-int yaffs_guts_initialise(struct yaffs_dev *dev)
-{
-	int init_failed = 0;
-	unsigned x;
-	int bits;
-
-	if(yaffs_guts_ll_init(dev) != YAFFS_OK)
-		return YAFFS_FAIL;
-
 	if (dev->is_mounted) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS, "device already mounted");
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs: device already mounted\n" TENDSTR)));
 		return YAFFS_FAIL;
 	}
 
+	/* Finished with most checks. One or two more checks happen later on too. */
+
 	dev->is_mounted = 1;
 
 	/* OK now calculate a few things for the device */
@@ -4777,11 +5206,11 @@ int yaffs_guts_initialise(struct yaffs_d
 	 */
 	x = dev->data_bytes_per_chunk;
 	/* We always use dev->chunk_shift and dev->chunk_div */
-	dev->chunk_shift = calc_shifts(x);
+	dev->chunk_shift = Shifts(x);
 	x >>= dev->chunk_shift;
 	dev->chunk_div = x;
 	/* We only use chunk mask if chunk_div is 1 */
-	dev->chunk_mask = (1 << dev->chunk_shift) - 1;
+	dev->chunk_mask = (1<<dev->chunk_shift) - 1;
 
 	/*
 	 * Calculate chunk_grp_bits.
@@ -4790,7 +5219,7 @@ int yaffs_guts_initialise(struct yaffs_d
 
 	x = dev->param.chunks_per_block * (dev->internal_end_block + 1);
 
-	bits = calc_shifts_ceiling(x);
+	bits = ShiftsGE(x);
 
 	/* Set up tnode width if wide tnodes are enabled. */
 	if (!dev->param.wide_tnodes_disabled) {
@@ -4801,11 +5230,10 @@ int yaffs_guts_initialise(struct yaffs_d
 			dev->tnode_width = 16;
 		else
 			dev->tnode_width = bits;
-	} else {
+	} else
 		dev->tnode_width = 16;
-	}
-
-	dev->tnode_mask = (1 << dev->tnode_width) - 1;
+
+	dev->tnode_mask = (1<<dev->tnode_width)-1;
 
 	/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),
 	 * so if the bitwidth of the
@@ -4818,9 +5246,9 @@ int yaffs_guts_initialise(struct yaffs_d
 	else
 		dev->chunk_grp_bits = bits - dev->tnode_width;
 
-	dev->tnode_size = (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8;
-	if (dev->tnode_size < sizeof(struct yaffs_tnode))
-		dev->tnode_size = sizeof(struct yaffs_tnode);
+	dev->tnode_size = (dev->tnode_width * YAFFS_NTNODES_LEVEL0)/8;
+	if(dev->tnode_size < sizeof(yaffs_tnode_t))
+		dev->tnode_size = sizeof(yaffs_tnode_t);
 
 	dev->chunk_grp_size = 1 << dev->chunk_grp_bits;
 
@@ -4829,12 +5257,13 @@ int yaffs_guts_initialise(struct yaffs_d
 		 * the chunk group size > chunks per block.
 		 * This can be remedied by using larger "virtual blocks".
 		 */
-		yaffs_trace(YAFFS_TRACE_ALWAYS, "chunk group too large");
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs: chunk group too large\n" TENDSTR)));
 
 		return YAFFS_FAIL;
 	}
 
-	/* Finished verifying the device, continue with initialisation */
+	/* OK, we've finished verifying the device, lets continue with initialisation */
 
 	/* More device initialisation */
 	dev->all_gcs = 0;
@@ -4853,10 +5282,9 @@ int yaffs_guts_initialise(struct yaffs_d
 	dev->n_tags_ecc_unfixed = 0;
 	dev->n_erase_failures = 0;
 	dev->n_erased_blocks = 0;
-	dev->gc_disable = 0;
-	dev->has_pending_prioritised_gc = 1;
-		/* Assume the worst for now, will get fixed on first GC */
-	INIT_LIST_HEAD(&dev->dirty_dirs);
+	dev->gc_disable= 0;
+	dev->has_pending_prioritised_gc = 1; /* Assume the worst for now, will get fixed on first GC */
+	YINIT_LIST_HEAD(&dev->dirty_dirs);
 	dev->oldest_dirty_seq = 0;
 	dev->oldest_dirty_block = 0;
 
@@ -4867,28 +5295,28 @@ int yaffs_guts_initialise(struct yaffs_d
 	dev->cache = NULL;
 	dev->gc_cleanup_list = NULL;
 
-	if (!init_failed && dev->param.n_caches > 0) {
+
+	if (!init_failed &&
+	    dev->param.n_caches > 0) {
 		int i;
 		void *buf;
-		int cache_bytes =
-		    dev->param.n_caches * sizeof(struct yaffs_cache);
+		int cacheBytes = dev->param.n_caches * sizeof(yaffs_cache_t);
 
 		if (dev->param.n_caches > YAFFS_MAX_SHORT_OP_CACHES)
 			dev->param.n_caches = YAFFS_MAX_SHORT_OP_CACHES;
 
-		dev->cache = kmalloc(cache_bytes, GFP_NOFS);
-
-		buf = (u8 *) dev->cache;
+		dev->cache =  YMALLOC(cacheBytes);
+
+		buf = (__u8 *) dev->cache;
 
 		if (dev->cache)
-			memset(dev->cache, 0, cache_bytes);
+			memset(dev->cache, 0, cacheBytes);
 
 		for (i = 0; i < dev->param.n_caches && buf; i++) {
 			dev->cache[i].object = NULL;
 			dev->cache[i].last_use = 0;
 			dev->cache[i].dirty = 0;
-			dev->cache[i].data = buf =
-			    kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+			dev->cache[i].data = buf = YMALLOC_DMA(dev->param.total_bytes_per_chunk);
 		}
 		if (!buf)
 			init_failed = 1;
@@ -4899,9 +5327,7 @@ int yaffs_guts_initialise(struct yaffs_d
 	dev->cache_hits = 0;
 
 	if (!init_failed) {
-		dev->gc_cleanup_list =
-		    kmalloc(dev->param.chunks_per_block * sizeof(u32),
-					GFP_NOFS);
+		dev->gc_cleanup_list = YMALLOC(dev->param.chunks_per_block * sizeof(__u32));
 		if (!dev->gc_cleanup_list)
 			init_failed = 1;
 	}
@@ -4917,24 +5343,18 @@ int yaffs_guts_initialise(struct yaffs_d
 	if (!init_failed && !yaffs_create_initial_dir(dev))
 		init_failed = 1;
 
-	if (!init_failed && dev->param.is_yaffs2 &&
-		!dev->param.disable_summary &&
-		!yaffs_summary_init(dev))
-		init_failed = 1;
 
 	if (!init_failed) {
 		/* Now scan the flash. */
 		if (dev->param.is_yaffs2) {
 			if (yaffs2_checkpt_restore(dev)) {
 				yaffs_check_obj_details_loaded(dev->root_dir);
-				yaffs_trace(YAFFS_TRACE_CHECKPOINT |
-					YAFFS_TRACE_MOUNT,
-					"yaffs: restored from checkpoint"
-					);
+				T(YAFFS_TRACE_ALWAYS,
+				  (TSTR("yaffs: restored from checkpoint" TENDSTR)));
 			} else {
 
-				/* Clean up the mess caused by an aborted
-				 * checkpoint load then scan backwards.
+				/* Clean up the mess caused by an aborted checkpoint load
+				 * and scan backwards.
 				 */
 				yaffs_deinit_blocks(dev);
 
@@ -4953,27 +5373,25 @@ int yaffs_guts_initialise(struct yaffs_d
 
 				yaffs_init_tnodes_and_objs(dev);
 
-				if (!init_failed
-				    && !yaffs_create_initial_dir(dev))
+				if (!init_failed && !yaffs_create_initial_dir(dev))
 					init_failed = 1;
 
 				if (!init_failed && !yaffs2_scan_backwards(dev))
 					init_failed = 1;
 			}
-		} else if (!yaffs1_scan(dev)) {
-			init_failed = 1;
-		}
+		} else if (!yaffs1_scan(dev))
+				init_failed = 1;
 
 		yaffs_strip_deleted_objs(dev);
 		yaffs_fix_hanging_objs(dev);
-		if (dev->param.empty_lost_n_found)
+		if(dev->param.empty_lost_n_found)
 			yaffs_empty_l_n_f(dev);
 	}
 
 	if (init_failed) {
 		/* Clean up the mess */
-		yaffs_trace(YAFFS_TRACE_TRACING,
-		  "yaffs: yaffs_guts_initialise() aborted.");
+		T(YAFFS_TRACE_TRACING,
+		  (TSTR("yaffs: yaffs_guts_initialise() aborted.\n" TENDSTR)));
 
 		yaffs_deinitialise(dev);
 		return YAFFS_FAIL;
@@ -4984,7 +5402,7 @@ int yaffs_guts_initialise(struct yaffs_d
 	dev->n_page_writes = 0;
 	dev->n_erasures = 0;
 	dev->n_gc_copies = 0;
-	dev->n_retried_writes = 0;
+	dev->n_retired_writes = 0;
 
 	dev->n_retired_blocks = 0;
 
@@ -4992,50 +5410,53 @@ int yaffs_guts_initialise(struct yaffs_d
 	yaffs_verify_blocks(dev);
 
 	/* Clean up any aborted checkpoint data */
-	if (!dev->is_checkpointed && dev->blocks_in_checkpt > 0)
+	if(!dev->is_checkpointed && dev->blocks_in_checkpt > 0)
 		yaffs2_checkpt_invalidate(dev);
 
-	yaffs_trace(YAFFS_TRACE_TRACING,
-	  "yaffs: yaffs_guts_initialise() done.");
+	T(YAFFS_TRACE_TRACING,
+	  (TSTR("yaffs: yaffs_guts_initialise() done.\n" TENDSTR)));
 	return YAFFS_OK;
+
 }
 
-void yaffs_deinitialise(struct yaffs_dev *dev)
+void yaffs_deinitialise(yaffs_dev_t *dev)
 {
 	if (dev->is_mounted) {
 		int i;
 
 		yaffs_deinit_blocks(dev);
 		yaffs_deinit_tnodes_and_objs(dev);
-		yaffs_summary_deinit(dev);
-
-		if (dev->param.n_caches > 0 && dev->cache) {
+		if (dev->param.n_caches > 0 &&
+		    dev->cache) {
 
 			for (i = 0; i < dev->param.n_caches; i++) {
-				kfree(dev->cache[i].data);
+				if (dev->cache[i].data)
+					YFREE(dev->cache[i].data);
 				dev->cache[i].data = NULL;
 			}
 
-			kfree(dev->cache);
+			YFREE(dev->cache);
 			dev->cache = NULL;
 		}
 
-		kfree(dev->gc_cleanup_list);
+		YFREE(dev->gc_cleanup_list);
 
 		for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
-			kfree(dev->temp_buffer[i].buffer);
+			YFREE(dev->temp_buffer[i].buffer);
 
 		dev->is_mounted = 0;
 
-		yaffs_deinit_nand(dev);
+		if (dev->param.deinitialise_flash_fn)
+			dev->param.deinitialise_flash_fn(dev);
 	}
 }
 
-int yaffs_count_free_chunks(struct yaffs_dev *dev)
+int yaffs_count_free_chunks(yaffs_dev_t *dev)
 {
-	int n_free = 0;
+	int nFree=0;
 	int b;
-	struct yaffs_block_info *blk;
+
+	yaffs_block_info_t *blk;
 
 	blk = dev->block_info;
 	for (b = dev->internal_start_block; b <= dev->internal_end_block; b++) {
@@ -5044,7 +5465,7 @@ int yaffs_count_free_chunks(struct yaffs
 		case YAFFS_BLOCK_STATE_ALLOCATING:
 		case YAFFS_BLOCK_STATE_COLLECTING:
 		case YAFFS_BLOCK_STATE_FULL:
-			n_free +=
+			nFree +=
 			    (dev->param.chunks_per_block - blk->pages_in_use +
 			     blk->soft_del_pages);
 			break;
@@ -5053,84 +5474,71 @@ int yaffs_count_free_chunks(struct yaffs
 		}
 		blk++;
 	}
-	return n_free;
+
+	return nFree;
 }
 
-int yaffs_get_n_free_chunks(struct yaffs_dev *dev)
+int yaffs_get_n_free_chunks(yaffs_dev_t *dev)
 {
 	/* This is what we report to the outside world */
-	int n_free;
-	int n_dirty_caches;
-	int blocks_for_checkpt;
+
+	int nFree;
+	int nDirtyCacheChunks;
+	int blocksForCheckpoint;
 	int i;
 
-	n_free = dev->n_free_chunks;
-	n_free += dev->n_deleted_files;
-
-	/* Now count and subtract the number of dirty chunks in the cache. */
-
-	for (n_dirty_caches = 0, i = 0; i < dev->param.n_caches; i++) {
+#if 1
+	nFree = dev->n_free_chunks;
+#else
+	nFree = yaffs_count_free_chunks(dev);
+#endif
+
+	nFree += dev->n_deleted_files;
+
+	/* Now count the number of dirty chunks in the cache and subtract those */
+
+	for (nDirtyCacheChunks = 0, i = 0; i < dev->param.n_caches; i++) {
 		if (dev->cache[i].dirty)
-			n_dirty_caches++;
+			nDirtyCacheChunks++;
 	}
 
-	n_free -= n_dirty_caches;
-
-	n_free -=
-	    ((dev->param.n_reserved_blocks + 1) * dev->param.chunks_per_block);
-
-	/* Now figure checkpoint space and report that... */
-	blocks_for_checkpt = yaffs_calc_checkpt_blocks_required(dev);
-
-	n_free -= (blocks_for_checkpt * dev->param.chunks_per_block);
-
-	if (n_free < 0)
-		n_free = 0;
-
-	return n_free;
+	nFree -= nDirtyCacheChunks;
+
+	nFree -= ((dev->param.n_reserved_blocks + 1) * dev->param.chunks_per_block);
+
+	/* Now we figure out how much to reserve for the checkpoint and report that... */
+	blocksForCheckpoint = yaffs_calc_checkpt_blocks_required(dev);
+
+	nFree -= (blocksForCheckpoint * dev->param.chunks_per_block);
+
+	if (nFree < 0)
+		nFree = 0;
+
+	return nFree;
+
 }
 
 
-
-/*
- * Marshalling functions to get loff_t file sizes into and out of
- * object headers.
- */
-void yaffs_oh_size_load(struct yaffs_obj_hdr *oh, loff_t fsize)
+/*---------------------------------------- YAFFS test code ----------------------*/
+
+#define yaffs_check_struct(structure, syze, name) \
+	do { \
+		if (sizeof(structure) != syze) { \
+			T(YAFFS_TRACE_ALWAYS, (TSTR("%s should be %d but is %d\n" TENDSTR),\
+				name, syze, (int) sizeof(structure))); \
+			return YAFFS_FAIL; \
+		} \
+	} while (0)
+
+static int yaffs_check_structures(void)
 {
-	oh->file_size_low = (fsize & 0xFFFFFFFF);
-	oh->file_size_high = ((fsize >> 32) & 0xFFFFFFFF);
+/*      yaffs_check_struct(yaffs_tags_t,8,"yaffs_tags_t"); */
+/*      yaffs_check_struct(yaffs_tags_union_t,8,"yaffs_tags_union_t"); */
+/*      yaffs_check_struct(yaffs_spare,16,"yaffs_spare"); */
+/*	yaffs_check_struct(yaffs_tnode_t, 2 * YAFFS_NTNODES_LEVEL0, "yaffs_tnode_t"); */
+
+#ifndef CONFIG_YAFFS_WINCE
+	yaffs_check_struct(yaffs_obj_header, 512, "yaffs_obj_header");
+#endif
+	return YAFFS_OK;
 }
-
-loff_t yaffs_oh_to_size(struct yaffs_obj_hdr *oh)
-{
-	loff_t retval;
-
-	if (sizeof(loff_t) >= 8 && ~(oh->file_size_high))
-		retval = (((loff_t) oh->file_size_high) << 32) |
-			(((loff_t) oh->file_size_low) & 0xFFFFFFFF);
-	else
-		retval = (loff_t) oh->file_size_low;
-
-	return retval;
-}
-
-
-void yaffs_count_blocks_by_state(struct yaffs_dev *dev, int bs[10])
-{
-	int i;
-	struct yaffs_block_info *bi;
-	int s;
-
-	for(i = 0; i < 10; i++)
-		bs[i] = 0;
-
-	for(i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
-		bi = yaffs_get_block_info(dev, i);
-		s = bi->block_state;
-		if(s > YAFFS_BLOCK_STATE_DEAD || s < YAFFS_BLOCK_STATE_UNKNOWN)
-			bs[0]++;
-		else
-			bs[s]++;
-	}
-}
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_guts.h b/target/linux/generic/files/fs/yaffs2/yaffs_guts.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_guts.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_guts.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -17,55 +17,41 @@
 #define __YAFFS_GUTS_H__
 
 #include "yportenv.h"
+#include "devextras.h"
+#include "yaffs_list.h"
 
 #define YAFFS_OK	1
 #define YAFFS_FAIL  0
 
 /* Give us a  Y=0x59,
  * Give us an A=0x41,
- * Give us an FF=0xff
+ * Give us an FF=0xFF
  * Give us an S=0x53
  * And what have we got...
  */
-#define YAFFS_MAGIC			0x5941ff53
+#define YAFFS_MAGIC			0x5941FF53
 
-/*
- * Tnodes form a tree with the tnodes in "levels"
- * Levels greater than 0 hold 8 slots which point to other tnodes.
- * Those at level 0 hold 16 slots which point to chunks in NAND.
- *
- * A maximum level of 8 thust supports files of size up to:
- *
- * 2^(3*MAX_LEVEL+4)
- *
- * Thus a max level of 8 supports files with up to 2^^28 chunks which gives
- * a maximum file size of around 512Gbytees with 2k chunks.
- */
-#define YAFFS_NTNODES_LEVEL0		16
+#define YAFFS_NTNODES_LEVEL0	  	16
 #define YAFFS_TNODES_LEVEL0_BITS	4
 #define YAFFS_TNODES_LEVEL0_MASK	0xf
 
-#define YAFFS_NTNODES_INTERNAL		(YAFFS_NTNODES_LEVEL0 / 2)
-#define YAFFS_TNODES_INTERNAL_BITS	(YAFFS_TNODES_LEVEL0_BITS - 1)
+#define YAFFS_NTNODES_INTERNAL 		(YAFFS_NTNODES_LEVEL0 / 2)
+#define YAFFS_TNODES_INTERNAL_BITS 	(YAFFS_TNODES_LEVEL0_BITS - 1)
 #define YAFFS_TNODES_INTERNAL_MASK	0x7
-#define YAFFS_TNODES_MAX_LEVEL		8
-#define YAFFS_TNODES_MAX_BITS		(YAFFS_TNODES_LEVEL0_BITS + \
-					YAFFS_TNODES_INTERNAL_BITS * \
-					YAFFS_TNODES_MAX_LEVEL)
-#define YAFFS_MAX_CHUNK_ID		((1 << YAFFS_TNODES_MAX_BITS) - 1)
+#define YAFFS_TNODES_MAX_LEVEL		6
 
-#define YAFFS_MAX_FILE_SIZE_32		0x7fffffff
-
-/* Constants for YAFFS1 mode */
+#ifndef CONFIG_YAFFS_NO_YAFFS1
 #define YAFFS_BYTES_PER_SPARE		16
 #define YAFFS_BYTES_PER_CHUNK		512
 #define YAFFS_CHUNK_SIZE_SHIFT		9
 #define YAFFS_CHUNKS_PER_BLOCK		32
-#define YAFFS_BYTES_PER_BLOCK	(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
+#define YAFFS_BYTES_PER_BLOCK		(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
+#endif
 
-#define YAFFS_MIN_YAFFS2_CHUNK_SIZE	1024
+#define YAFFS_MIN_YAFFS2_CHUNK_SIZE 	1024
 #define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
 
+#define YAFFS_MAX_CHUNK_ID		0x000FFFFF
 
 
 #define YAFFS_ALLOCATION_NOBJECTS	100
@@ -74,12 +60,11 @@
 
 #define YAFFS_NOBJECT_BUCKETS		256
 
+
 #define YAFFS_OBJECT_SPACE		0x40000
-#define YAFFS_MAX_OBJECT_ID		(YAFFS_OBJECT_SPACE - 1)
+#define YAFFS_MAX_OBJECT_ID		(YAFFS_OBJECT_SPACE -1)
 
-/* Binary data version stamps */
-#define YAFFS_SUMMARY_VERSION		1
-#define YAFFS_CHECKPOINT_VERSION	7
+#define YAFFS_CHECKPOINT_VERSION 	4
 
 #ifdef CONFIG_YAFFS_UNICODE
 #define YAFFS_MAX_NAME_LENGTH		127
@@ -97,12 +82,11 @@
 #define YAFFS_OBJECTID_UNLINKED		3
 #define YAFFS_OBJECTID_DELETED		4
 
-/* Fake object Id for summary data */
-#define YAFFS_OBJECTID_SUMMARY		0x10
+/* Pseudo object ids for checkpointing */
+#define YAFFS_OBJECTID_SB_HEADER	0x10
+#define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
+#define YAFFS_SEQUENCE_CHECKPOINT_DATA  0x21
 
-/* Pseudo object ids for checkpointing */
-#define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
-#define YAFFS_SEQUENCE_CHECKPOINT_DATA	0x21
 
 #define YAFFS_MAX_SHORT_OP_CACHES	20
 
@@ -118,74 +102,80 @@
  * The range is limited slightly to help distinguish bad numbers from good.
  * This also allows us to perhaps in the future use special numbers for
  * special purposes.
- * EFFFFF00 allows the allocation of 8 blocks/second (~1Mbytes) for 15 years,
+ * EFFFFF00 allows the allocation of 8 blocks per second (~1Mbytes) for 15 years,
  * and is a larger number than the lifetime of a 2GB device.
  */
 #define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
-#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xefffff00
+#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xEFFFFF00
 
 /* Special sequence number for bad block that failed to be marked bad */
-#define YAFFS_SEQUENCE_BAD_BLOCK	0xffff0000
+#define YAFFS_SEQUENCE_BAD_BLOCK	0xFFFF0000
 
 /* ChunkCache is used for short read/write operations.*/
-struct yaffs_cache {
-	struct yaffs_obj *object;
+typedef struct {
+	struct yaffs_obj_s *object;
 	int chunk_id;
 	int last_use;
 	int dirty;
 	int n_bytes;		/* Only valid if the cache is dirty */
 	int locked;		/* Can't push out or flush while locked. */
-	u8 *data;
-};
+	__u8 *data;
+} yaffs_cache_t;
 
-/* yaffs1 tags structures in RAM
- * NB This uses bitfield. Bitfields should not straddle a u32 boundary
- * otherwise the structure size will get blown out.
+
+
+/* Tags structures in RAM
+ * NB This uses bitfield. Bitfields should not straddle a u32 boundary otherwise
+ * the structure size will get blown out.
  */
 
-struct yaffs_tags {
-	u32 chunk_id:20;
-	u32 serial_number:2;
-	u32 n_bytes_lsb:10;
-	u32 obj_id:18;
-	u32 ecc:12;
-	u32 n_bytes_msb:2;
-};
+#ifndef CONFIG_YAFFS_NO_YAFFS1
+typedef struct {
+	unsigned chunk_id:20;
+	unsigned serial_number:2;
+	unsigned n_bytes_lsb:10;
+	unsigned obj_id:18;
+	unsigned ecc:12;
+	unsigned n_bytes_msb:2;
+} yaffs_tags_t;
 
-union yaffs_tags_union {
-	struct yaffs_tags as_tags;
-	u8 as_bytes[8];
-};
+typedef union {
+	yaffs_tags_t as_tags;
+	__u8 as_bytes[8];
+} yaffs_tags_union_t;
 
+#endif
 
 /* Stuff used for extended tags in YAFFS2 */
 
-enum yaffs_ecc_result {
+typedef enum {
 	YAFFS_ECC_RESULT_UNKNOWN,
 	YAFFS_ECC_RESULT_NO_ERROR,
 	YAFFS_ECC_RESULT_FIXED,
 	YAFFS_ECC_RESULT_UNFIXED
-};
+} yaffs_ecc_result;
 
-enum yaffs_obj_type {
+typedef enum {
 	YAFFS_OBJECT_TYPE_UNKNOWN,
 	YAFFS_OBJECT_TYPE_FILE,
 	YAFFS_OBJECT_TYPE_SYMLINK,
 	YAFFS_OBJECT_TYPE_DIRECTORY,
 	YAFFS_OBJECT_TYPE_HARDLINK,
 	YAFFS_OBJECT_TYPE_SPECIAL
-};
+} yaffs_obj_type;
 
 #define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
 
-struct yaffs_ext_tags {
+typedef struct {
+
+	unsigned validity1;
 	unsigned chunk_used;	/*  Status of the chunk: used or unused */
-	unsigned obj_id;	/* If 0 this is not used */
-	unsigned chunk_id;	/* If 0 this is a header, else a data chunk */
+	unsigned obj_id;	/* If 0 then this is not part of an object (unused) */
+	unsigned chunk_id;	/* If 0 then this is a header, else a data chunk */
 	unsigned n_bytes;	/* Only valid for data chunks */
 
 	/* The following stuff only has meaning when we read */
-	enum yaffs_ecc_result ecc_result;
+	yaffs_ecc_result ecc_result;
 	unsigned block_bad;
 
 	/* YAFFS 1 stuff */
@@ -197,57 +187,57 @@ struct yaffs_ext_tags {
 
 	/* Extra info if this is an object header (YAFFS2 only) */
 
-	unsigned extra_available;	/* Extra info available if not zero */
+	unsigned extra_available;	/* There is extra info available if this is not zero */
 	unsigned extra_parent_id;	/* The parent object */
 	unsigned extra_is_shrink;	/* Is it a shrink header? */
-	unsigned extra_shadows;	/* Does this shadow another object? */
+	unsigned extra_shadows;		/* Does this shadow another object? */
 
-	enum yaffs_obj_type extra_obj_type;	/* What object type? */
+	yaffs_obj_type extra_obj_type;	/* What object type? */
 
-	loff_t extra_file_size;		/* Length if it is a file */
-	unsigned extra_equiv_id;	/* Equivalent object for a hard link */
-};
+	unsigned extra_length;		/* Length if it is a file */
+	unsigned extra_equiv_id;	/* Equivalent object Id if it is a hard link */
+
+	unsigned validty1;
+
+} yaffs_ext_tags;
 
 /* Spare structure for YAFFS1 */
-struct yaffs_spare {
-	u8 tb0;
-	u8 tb1;
-	u8 tb2;
-	u8 tb3;
-	u8 page_status;		/* set to 0 to delete the chunk */
-	u8 block_status;
-	u8 tb4;
-	u8 tb5;
-	u8 ecc1[3];
-	u8 tb6;
-	u8 tb7;
-	u8 ecc2[3];
-};
+typedef struct {
+	__u8 tb0;
+	__u8 tb1;
+	__u8 tb2;
+	__u8 tb3;
+	__u8 page_status;	/* set to 0 to delete the chunk */
+	__u8 block_status;
+	__u8 tb4;
+	__u8 tb5;
+	__u8 ecc1[3];
+	__u8 tb6;
+	__u8 tb7;
+	__u8 ecc2[3];
+} yaffs_spare;
 
 /*Special structure for passing through to mtd */
 struct yaffs_nand_spare {
-	struct yaffs_spare spare;
+	yaffs_spare spare;
 	int eccres1;
 	int eccres2;
 };
 
 /* Block data in RAM */
 
-enum yaffs_block_state {
+typedef enum {
 	YAFFS_BLOCK_STATE_UNKNOWN = 0,
 
 	YAFFS_BLOCK_STATE_SCANNING,
-	/* Being scanned */
+        /* Being scanned */
 
-	YAFFS_BLOCK_STATE_NEEDS_SCAN,
-	/* The block might have something on it (ie it is allocating or full,
-	 * perhaps empty) but it needs to be scanned to determine its true
-	 * state.
-	 * This state is only valid during scanning.
-	 * NB We tolerate empty because the pre-scanner might be incapable of
-	 * deciding
-	 * However, if this state is returned on a YAFFS2 device,
-	 * then we expect a sequence number
+	YAFFS_BLOCK_STATE_NEEDS_SCANNING,
+	/* The block might have something on it (ie it is allocating or full, perhaps empty)
+	 * but it needs to be scanned to determine its true state.
+	 * This state is only valid during yaffs_Scan.
+	 * NB We tolerate empty because the pre-scanner might be incapable of deciding
+	 * However, if this state is returned on a YAFFS2 device, then we expect a sequence number
 	 */
 
 	YAFFS_BLOCK_STATE_EMPTY,
@@ -258,14 +248,13 @@ enum yaffs_block_state {
 	 * At least one page holds valid data.
 	 * This is the one currently being used for page
 	 * allocation. Should never be more than one of these.
-	 * If a block is only partially allocated at mount it is treated as
-	 * full.
+         * If a block is only partially allocated at mount it is treated as full.
 	 */
 
 	YAFFS_BLOCK_STATE_FULL,
 	/* All the pages in this block have been allocated.
-	 * If a block was only partially allocated when mounted we treat
-	 * it as fully allocated.
+         * If a block was only partially allocated when mounted we treat
+         * it as fully allocated.
 	 */
 
 	YAFFS_BLOCK_STATE_DIRTY,
@@ -280,54 +269,57 @@ enum yaffs_block_state {
 	/* This block is being garbage collected */
 
 	YAFFS_BLOCK_STATE_DEAD
-	    /* This block has failed and is not in use */
-};
+	/* This block has failed and is not in use */
+} yaffs_block_state_t;
 
 #define	YAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)
 
-struct yaffs_block_info {
 
-	s32 soft_del_pages:10;	/* number of soft deleted pages */
-	s32 pages_in_use:10;	/* number of pages in use */
-	u32 block_state:4;	/* One of the above block states. */
-				/* NB use unsigned because enum is sometimes
-				 * an int */
-	u32 needs_retiring:1;	/* Data has failed on this block, */
-				/*need to get valid data off and retire*/
-	u32 skip_erased_check:1;/* Skip the erased check on this block */
-	u32 gc_prioritise:1;	/* An ECC check or blank check has failed.
-				   Block should be prioritised for GC */
-	u32 chunk_error_strikes:3;	/* How many times we've had ecc etc
-				failures on this block and tried to reuse it */
-	u32 has_summary:1;	/* The block has a summary */
+typedef struct {
 
-	u32 has_shrink_hdr:1;	/* This block has at least one shrink header */
-	u32 seq_number;		/* block sequence number for yaffs2 */
+	int soft_del_pages:10;	/* number of soft deleted pages */
+	int pages_in_use:10;	/* number of pages in use */
+	unsigned block_state:4;	/* One of the above block states. NB use unsigned because enum is sometimes an int */
+	__u32 needs_retiring:1;	/* Data has failed on this block, need to get valid data off */
+				/* and retire the block. */
+	__u32 skip_erased_check:1; /* If this is set we can skip the erased check on this block */
+	__u32 gc_prioritise:1; 	/* An ECC check or blank check has failed on this block.
+				   It should be prioritised for GC */
+	__u32 chunk_error_strikes:3; /* How many times we've had ecc etc failures on this block and tried to reuse it */
 
-};
+#ifdef CONFIG_YAFFS_YAFFS2
+	__u32 has_shrink_hdr:1; /* This block has at least one shrink object header */
+	__u32 seq_number;	 /* block sequence number for yaffs2 */
+#endif
+
+} yaffs_block_info_t;
 
 /* -------------------------- Object structure -------------------------------*/
 /* This is the object structure as stored on NAND */
 
-struct yaffs_obj_hdr {
-	enum yaffs_obj_type type;
+typedef struct {
+	yaffs_obj_type type;
 
 	/* Apply to everything  */
 	int parent_obj_id;
-	u16 sum_no_longer_used;	/* checksum of name. No longer used */
+	__u16 sum_no_longer_used;        /* checksum of name. No longer used */
 	YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
 
-	/* The following apply to all object types except for hard links */
-	u32 yst_mode;		/* protection */
+	/* The following apply to directories, files, symlinks - not hard links */
+	__u32 yst_mode;         /* protection */
 
-	u32 yst_uid;
-	u32 yst_gid;
-	u32 yst_atime;
-	u32 yst_mtime;
-	u32 yst_ctime;
+#ifdef CONFIG_YAFFS_WINCE
+	__u32 not_for_wince[5];
+#else
+	__u32 yst_uid;
+	__u32 yst_gid;
+	__u32 yst_atime;
+	__u32 yst_mtime;
+	__u32 yst_ctime;
+#endif
 
 	/* File size  applies to files only */
-	u32 file_size_low;
+	int file_size;
 
 	/* Equivalent object id applies to hard links only. */
 	int equiv_id;
@@ -335,30 +327,36 @@ struct yaffs_obj_hdr {
 	/* Alias is for symlinks only. */
 	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
 
-	u32 yst_rdev;	/* stuff for block and char devices (major/min) */
+	__u32 yst_rdev;		/* device stuff for block and char devices (major/min) */
 
-	u32 win_ctime[2];
-	u32 win_atime[2];
-	u32 win_mtime[2];
+#ifdef CONFIG_YAFFS_WINCE
+	__u32 win_ctime[2];
+	__u32 win_atime[2];
+	__u32 win_mtime[2];
+#else
+	__u32 room_to_grow[6];
 
-	u32 inband_shadowed_obj_id;
-	u32 inband_is_shrink;
+#endif
+	__u32 inband_shadowed_obj_id;
+	__u32 inband_is_shrink;
 
-	u32 file_size_high;
-	u32 reserved[1];
-	int shadows_obj;	/* This object header shadows the
-				specified object if > 0 */
+	__u32 reserved[2];
+	int shadows_obj;	/* This object header shadows the specified object if > 0 */
 
-	/* is_shrink applies to object headers written when wemake a hole. */
-	u32 is_shrink;
+	/* is_shrink applies to object headers written when we shrink the file (ie resize) */
+	__u32 is_shrink;
+
+} yaffs_obj_header;
+
+/*--------------------------- Tnode -------------------------- */
+
+union yaffs_tnode_union {
+	union yaffs_tnode_union *internal[YAFFS_NTNODES_INTERNAL];
 
 };
 
-/*--------------------------- Tnode -------------------------- */
+typedef union yaffs_tnode_union yaffs_tnode_t;
 
-struct yaffs_tnode {
-	struct yaffs_tnode *internal[YAFFS_NTNODES_INTERNAL];
-};
 
 /*------------------------  Object -----------------------------*/
 /* An object can be one of:
@@ -368,310 +366,294 @@ struct yaffs_tnode {
  * - a hard link
  */
 
-struct yaffs_file_var {
-	loff_t file_size;
-	loff_t scanned_size;
-	loff_t shrink_size;
+typedef struct {
+	__u32 file_size;
+	__u32 scanned_size;
+	__u32 shrink_size;
 	int top_level;
-	struct yaffs_tnode *top;
-};
+	yaffs_tnode_t *top;
+} yaffs_file_s;
 
-struct yaffs_dir_var {
-	struct list_head children;	/* list of child links */
-	struct list_head dirty;	/* Entry for list of dirty directories */
-};
+typedef struct {
+	struct ylist_head children;     /* list of child links */
+	struct ylist_head dirty;	/* Entry for list of dirty directories */
+} yaffs_dir_s;
 
-struct yaffs_symlink_var {
+typedef struct {
 	YCHAR *alias;
-};
+} yaffs_symlink_t;
 
-struct yaffs_hardlink_var {
-	struct yaffs_obj *equiv_obj;
-	u32 equiv_id;
-};
+typedef struct {
+	struct yaffs_obj_s *equiv_obj;
+	__u32 equiv_id;
+} yaffs_hard_link_s;
 
-union yaffs_obj_var {
-	struct yaffs_file_var file_variant;
-	struct yaffs_dir_var dir_variant;
-	struct yaffs_symlink_var symlink_variant;
-	struct yaffs_hardlink_var hardlink_variant;
-};
+typedef union {
+	yaffs_file_s file_variant;
+	yaffs_dir_s dir_variant;
+	yaffs_symlink_t symlink_variant;
+	yaffs_hard_link_s hardlink_variant;
+} yaffs_obj_variant;
 
-struct yaffs_obj {
-	u8 deleted:1;		/* This should only apply to unlinked files. */
-	u8 soft_del:1;		/* it has also been soft deleted */
-	u8 unlinked:1;		/* An unlinked file.*/
-	u8 fake:1;		/* A fake object has no presence on NAND. */
-	u8 rename_allowed:1;	/* Some objects cannot be renamed. */
-	u8 unlink_allowed:1;
-	u8 dirty:1;		/* the object needs to be written to flash */
-	u8 valid:1;		/* When the file system is being loaded up, this
+
+
+struct yaffs_obj_s {
+	__u8 deleted:1;		/* This should only apply to unlinked files. */
+	__u8 soft_del:1;	/* it has also been soft deleted */
+	__u8 unlinked:1;	/* An unlinked file. The file should be in the unlinked directory.*/
+	__u8 fake:1;		/* A fake object has no presence on NAND. */
+	__u8 rename_allowed:1;	/* Some objects are not allowed to be renamed. */
+	__u8 unlink_allowed:1;
+	__u8 dirty:1;		/* the object needs to be written to flash */
+	__u8 valid:1;		/* When the file system is being loaded up, this
 				 * object might be created before the data
-				 * is available
-				 * ie. file data chunks encountered before
-				* the header.
+				 * is available (ie. file data records appear before the header).
 				 */
-	u8 lazy_loaded:1;	/* This object has been lazy loaded and
-				 * is missing some detail */
+	__u8 lazy_loaded:1;	/* This object has been lazy loaded and is missing some detail */
 
-	u8 defered_free:1;	/* Object is removed from NAND, but is
-				 * still in the inode cache.
-				 * Free of object is defered.
+	__u8 defered_free:1;	/* For Linux kernel. Object is removed from NAND, but is
+				 * still in the inode cache. Free of object is defered.
 				 * until the inode is released.
 				 */
-	u8 being_created:1;	/* This object is still being created
-				 * so skip some verification checks. */
-	u8 is_shadowed:1;	/* This object is shadowed on the way
-				 * to being renamed. */
+	__u8 being_created:1;	/* This object is still being created so skip some checks. */
+	__u8 is_shadowed:1;	/* This object is shadowed on the way to being renamed. */
 
-	u8 xattr_known:1;	/* We know if this has object has xattribs
-				 * or not. */
-	u8 has_xattr:1;		/* This object has xattribs.
-				 * Only valid if xattr_known. */
+	__u8 xattr_known:1;	/* We know if this has object has xattribs or not. */
+	__u8 has_xattr:1;	/* This object has xattribs. Valid if xattr_known. */
 
-	u8 serial;		/* serial number of chunk in NAND.*/
-	u16 sum;		/* sum of the name to speed searching */
+	__u8 serial;		/* serial number of chunk in NAND. Cached here */
+	__u16 sum;		/* sum of the name to speed searching */
 
-	struct yaffs_dev *my_dev;	/* The device I'm on */
+	struct yaffs_dev_s *my_dev;       /* The device I'm on */
 
-	struct list_head hash_link;	/* list of objects in hash bucket */
+	struct ylist_head hash_link;     /* list of objects in this hash bucket */
 
-	struct list_head hard_links;	/* hard linked object chain*/
+	struct ylist_head hard_links;    /* all the equivalent hard linked objects */
 
 	/* directory structure stuff */
 	/* also used for linking up the free list */
-	struct yaffs_obj *parent;
-	struct list_head siblings;
+	struct yaffs_obj_s *parent;
+	struct ylist_head siblings;
 
 	/* Where's my object header in NAND? */
 	int hdr_chunk;
 
-	int n_data_chunks;	/* Number of data chunks for this file. */
+	int n_data_chunks;	/* Number of data chunks attached to the file. */
 
-	u32 obj_id;		/* the object id value */
+	__u32 obj_id;		/* the object id value */
 
-	u32 yst_mode;
+	__u32 yst_mode;
 
+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
 	YCHAR short_name[YAFFS_SHORT_NAME_LENGTH + 1];
+#endif
 
 #ifdef CONFIG_YAFFS_WINCE
-	u32 win_ctime[2];
-	u32 win_mtime[2];
-	u32 win_atime[2];
+	__u32 win_ctime[2];
+	__u32 win_mtime[2];
+	__u32 win_atime[2];
 #else
-	u32 yst_uid;
-	u32 yst_gid;
-	u32 yst_atime;
-	u32 yst_mtime;
-	u32 yst_ctime;
+	__u32 yst_uid;
+	__u32 yst_gid;
+	__u32 yst_atime;
+	__u32 yst_mtime;
+	__u32 yst_ctime;
 #endif
 
-	u32 yst_rdev;
+	__u32 yst_rdev;
 
 	void *my_inode;
 
-	enum yaffs_obj_type variant_type;
+	yaffs_obj_type variant_type;
 
-	union yaffs_obj_var variant;
+	yaffs_obj_variant variant;
 
 };
 
-struct yaffs_obj_bucket {
-	struct list_head list;
+typedef struct yaffs_obj_s yaffs_obj_t;
+
+typedef struct {
+	struct ylist_head list;
 	int count;
-};
+} yaffs_obj_bucket;
 
-/* yaffs_checkpt_obj holds the definition of an object as dumped
+
+/* yaffs_checkpt_obj_t holds the definition of an object as dumped
  * by checkpointing.
  */
 
-struct yaffs_checkpt_obj {
+typedef struct {
 	int struct_type;
-	u32 obj_id;
-	u32 parent_id;
+	__u32 obj_id;
+	__u32 parent_id;
 	int hdr_chunk;
-	enum yaffs_obj_type variant_type:3;
-	u8 deleted:1;
-	u8 soft_del:1;
-	u8 unlinked:1;
-	u8 fake:1;
-	u8 rename_allowed:1;
-	u8 unlink_allowed:1;
-	u8 serial;
+	yaffs_obj_type variant_type:3;
+	__u8 deleted:1;
+	__u8 soft_del:1;
+	__u8 unlinked:1;
+	__u8 fake:1;
+	__u8 rename_allowed:1;
+	__u8 unlink_allowed:1;
+	__u8 serial;
+
 	int n_data_chunks;
-	loff_t size_or_equiv_obj;
-};
+	__u32 size_or_equiv_obj;
+} yaffs_checkpt_obj_t;
 
 /*--------------------- Temporary buffers ----------------
  *
- * These are chunk-sized working buffers. Each device has a few.
+ * These are chunk-sized working buffers. Each device has a few
  */
 
-struct yaffs_buffer {
-	u8 *buffer;
-	int in_use;
-};
+typedef struct {
+	__u8 *buffer;
+	int line;	/* track from whence this buffer was allocated */
+	int max_line;
+} yaffs_buffer_t;
 
 /*----------------- Device ---------------------------------*/
 
-struct yaffs_param {
+
+struct yaffs_param_s {
 	const YCHAR *name;
 
 	/*
-	 * Entry parameters set up way early. Yaffs sets up the rest.
-	 * The structure should be zeroed out before use so that unused
-	 * and default values are zero.
-	 */
+         * Entry parameters set up way early. Yaffs sets up the rest.
+         * The structure should be zeroed out before use so that unused
+         * and defualt values are zero.
+         */
 
-	int inband_tags;	/* Use unband tags */
-	u32 total_bytes_per_chunk;	/* Should be >= 512, does not need to
-					 be a power of 2 */
+	int inband_tags;          /* Use unband tags */
+	__u32 total_bytes_per_chunk; /* Should be >= 512, does not need to be a power of 2 */
 	int chunks_per_block;	/* does not need to be a power of 2 */
 	int spare_bytes_per_chunk;	/* spare area size */
-	int start_block;	/* Start block we're allowed to use */
+	int start_block;		/* Start block we're allowed to use */
 	int end_block;		/* End block we're allowed to use */
-	int n_reserved_blocks;	/* Tuneable so that we can reduce
-				 * reserved blocks on NOR and RAM. */
+	int n_reserved_blocks;	/* We want this tuneable so that we can reduce */
+				/* reserved blocks on NOR and RAM. */
 
-	int n_caches;		/* If <= 0, then short op caching is disabled,
-				 * else the number of short op caches.
+
+	int n_caches;	/* If <= 0, then short op caching is disabled, else
+				 * the number of short op caches (don't use too many).
+                                 * 10 to 20 is a good bet.
 				 */
-	int cache_bypass_aligned; /* If non-zero then bypass the cache for
-				   * aligned writes.
-				   */
+	int use_nand_ecc;		/* Flag to decide whether or not to use NANDECC on data (yaffs1) */
+	int no_tags_ecc;		/* Flag to decide whether or not to do ECC on packed tags (yaffs2) */ 
 
-	int use_nand_ecc;	/* Flag to decide whether or not to use
-				 * NAND driver ECC on data (yaffs1) */
-	int tags_9bytes;	/* Use 9 byte tags */
-	int no_tags_ecc;	/* Flag to decide whether or not to do ECC
-				 * on packed tags (yaffs2) */
+	int is_yaffs2;           /* Use yaffs2 mode on this device */
 
-	int is_yaffs2;		/* Use yaffs2 mode on this device */
+	int empty_lost_n_found;  /* Auto-empty lost+found directory on mount */
 
-	int empty_lost_n_found;	/* Auto-empty lost+found directory on mount */
-
-	int refresh_period;	/* How often to check for a block refresh */
+	int refresh_period;	/* How often we should check to do a block refresh */
 
 	/* Checkpoint control. Can be set before or after initialisation */
-	u8 skip_checkpt_rd;
-	u8 skip_checkpt_wr;
+	__u8 skip_checkpt_rd;
+	__u8 skip_checkpt_wr;
 
 	int enable_xattr;	/* Enable xattribs */
 
-	int max_objects;	/*
-				 * Set to limit the number of objects created.
-				 * 0 = no limit.
-				*/
+	/* NAND access functions (Must be set before calling YAFFS)*/
+
+	int (*write_chunk_fn) (struct yaffs_dev_s *dev,
+					int nand_chunk, const __u8 *data,
+					const yaffs_spare *spare);
+	int (*read_chunk_fn) (struct yaffs_dev_s *dev,
+					int nand_chunk, __u8 *data,
+					yaffs_spare *spare);
+	int (*erase_fn) (struct yaffs_dev_s *dev,
+					int flash_block);
+	int (*initialise_flash_fn) (struct yaffs_dev_s *dev);
+	int (*deinitialise_flash_fn) (struct yaffs_dev_s *dev);
+
+#ifdef CONFIG_YAFFS_YAFFS2
+	int (*write_chunk_tags_fn) (struct yaffs_dev_s *dev,
+					 int nand_chunk, const __u8 *data,
+					 const yaffs_ext_tags *tags);
+	int (*read_chunk_tags_fn) (struct yaffs_dev_s *dev,
+					  int nand_chunk, __u8 *data,
+					  yaffs_ext_tags *tags);
+	int (*bad_block_fn) (struct yaffs_dev_s *dev, int block_no);
+	int (*query_block_fn) (struct yaffs_dev_s *dev, int block_no,
+			       yaffs_block_state_t *state, __u32 *seq_number);
+#endif
 
 	/* The remove_obj_fn function must be supplied by OS flavours that
 	 * need it.
-	 * yaffs direct uses it to implement the faster readdir.
-	 * Linux uses it to protect the directory during unlocking.
+         * yaffs direct uses it to implement the faster readdir.
+         * Linux uses it to protect the directory during unlocking.
 	 */
-	void (*remove_obj_fn) (struct yaffs_obj *obj);
+	void (*remove_obj_fn)(struct yaffs_obj_s *obj);
 
 	/* Callback to mark the superblock dirty */
-	void (*sb_dirty_fn) (struct yaffs_dev *dev);
+	void (*sb_dirty_fn)(struct yaffs_dev_s *dev);
+	
+	/*  Callback to control garbage collection. */
+	unsigned (*gc_control)(struct yaffs_dev_s *dev);
 
-	/*  Callback to control garbage collection. */
-	unsigned (*gc_control_fn) (struct yaffs_dev *dev);
-
-	/* Debug control flags. Don't use unless you know what you're doing */
-	int use_header_file_size;	/* Flag to determine if we should use
-					 * file sizes from the header */
+        /* Debug control flags. Don't use unless you know what you're doing */
+	int use_header_file_size;	/* Flag to determine if we should use file sizes from the header */
 	int disable_lazy_load;	/* Disable lazy loading on this device */
-	int wide_tnodes_disabled;	/* Set to disable wide tnodes */
-	int disable_soft_del;	/* yaffs 1 only: Set to disable the use of
-				 * softdeletion. */
-
-	int defered_dir_update;	/* Set to defer directory updates */
+	int wide_tnodes_disabled; /* Set to disable wide tnodes */
+	int disable_soft_del;  /* yaffs 1 only: Set to disable the use of softdeletion. */
+	
+	int defered_dir_update; /* Set to defer directory updates */
 
 #ifdef CONFIG_YAFFS_AUTO_UNICODE
 	int auto_unicode;
 #endif
-	int always_check_erased;	/* Force chunk erased check always on */
-
-	int disable_summary;
-	int disable_bad_block_marking;
-
+	int always_check_erased; /* Force chunk erased check always on */
 };
 
-struct yaffs_driver {
-	int (*drv_write_chunk_fn) (struct yaffs_dev *dev, int nand_chunk,
-				   const u8 *data, int data_len,
-				   const u8 *oob, int oob_len);
-	int (*drv_read_chunk_fn) (struct yaffs_dev *dev, int nand_chunk,
-				   u8 *data, int data_len,
-				   u8 *oob, int oob_len,
-				   enum yaffs_ecc_result *ecc_result);
-	int (*drv_erase_fn) (struct yaffs_dev *dev, int block_no);
-	int (*drv_mark_bad_fn) (struct yaffs_dev *dev, int block_no);
-	int (*drv_check_bad_fn) (struct yaffs_dev *dev, int block_no);
-	int (*drv_initialise_fn) (struct yaffs_dev *dev);
-	int (*drv_deinitialise_fn) (struct yaffs_dev *dev);
-};
+typedef struct yaffs_param_s yaffs_param_t;
 
-struct yaffs_tags_handler {
-	int (*write_chunk_tags_fn) (struct yaffs_dev *dev,
-				    int nand_chunk, const u8 *data,
-				    const struct yaffs_ext_tags *tags);
-	int (*read_chunk_tags_fn) (struct yaffs_dev *dev,
-				   int nand_chunk, u8 *data,
-				   struct yaffs_ext_tags *tags);
+struct yaffs_dev_s {
+	struct yaffs_param_s param;
 
-	int (*query_block_fn) (struct yaffs_dev *dev, int block_no,
-			       enum yaffs_block_state *state,
-			       u32 *seq_number);
-	int (*mark_bad_fn) (struct yaffs_dev *dev, int block_no);
-};
-
-struct yaffs_dev {
-	struct yaffs_param param;
-	struct yaffs_driver drv;
-	struct yaffs_tags_handler tagger;
-
-	/* Context storage. Holds extra OS specific data for this device */
+        /* Context storage. Holds extra OS specific data for this device */
 
 	void *os_context;
 	void *driver_context;
 
-	struct list_head dev_list;
+	struct ylist_head dev_list;
 
-	int ll_init;
 	/* Runtime parameters. Set up by YAFFS. */
-	int data_bytes_per_chunk;
+	int data_bytes_per_chunk;	
 
-	/* Non-wide tnode stuff */
-	u16 chunk_grp_bits;	/* Number of bits that need to be resolved if
-				 * the tnodes are not wide enough.
-				 */
-	u16 chunk_grp_size;	/* == 2^^chunk_grp_bits */
+        /* Non-wide tnode stuff */
+	__u16 chunk_grp_bits;	/* Number of bits that need to be resolved if
+                                 * the tnodes are not wide enough.
+                                 */
+	__u16 chunk_grp_size;	/* == 2^^chunk_grp_bits */
 
 	/* Stuff to support wide tnodes */
-	u32 tnode_width;
-	u32 tnode_mask;
-	u32 tnode_size;
+	__u32 tnode_width;
+	__u32 tnode_mask;
+	__u32 tnode_size;
 
 	/* Stuff for figuring out file offset to chunk conversions */
-	u32 chunk_shift;	/* Shift value */
-	u32 chunk_div;		/* Divisor after shifting: 1 for 2^n sizes */
-	u32 chunk_mask;		/* Mask to use for power-of-2 case */
+	__u32 chunk_shift; /* Shift value */
+	__u32 chunk_div;   /* Divisor after shifting: 1 for power-of-2 sizes */
+	__u32 chunk_mask;  /* Mask to use for power-of-2 case */
+
+
 
 	int is_mounted;
 	int read_only;
 	int is_checkpointed;
 
+
 	/* Stuff to support block offsetting to support start block zero */
 	int internal_start_block;
 	int internal_end_block;
 	int block_offset;
 	int chunk_offset;
 
+
 	/* Runtime checkpointing stuff */
-	int checkpt_page_seq;	/* running sequence number of checkpt pages */
+	int checkpt_page_seq;   /* running sequence number of checkpoint pages */
 	int checkpt_byte_count;
 	int checkpt_byte_offs;
-	u8 *checkpt_buffer;
+	__u8 *checkpt_buffer;
 	int checkpt_open_write;
 	int blocks_in_checkpt;
 	int checkpt_cur_chunk;
@@ -679,24 +661,23 @@ struct yaffs_dev {
 	int checkpt_next_block;
 	int *checkpt_block_list;
 	int checkpt_max_blocks;
-	u32 checkpt_sum;
-	u32 checkpt_xor;
+	__u32 checkpt_sum;
+	__u32 checkpt_xor;
 
-	int checkpoint_blocks_required;	/* Number of blocks needed to store
-					 * current checkpoint set */
+	int checkpoint_blocks_required; /* Number of blocks needed to store current checkpoint set */
 
 	/* Block Info */
-	struct yaffs_block_info *block_info;
-	u8 *chunk_bits;		/* bitmap of chunks in use */
-	u8 block_info_alt:1;	/* allocated using alternative alloc */
-	u8 chunk_bits_alt:1;	/* allocated using alternative alloc */
+	yaffs_block_info_t *block_info;
+	__u8 *chunk_bits;	/* bitmap of chunks in use */
+	unsigned block_info_alt:1;	/* was allocated using alternative strategy */
+	unsigned chunk_bits_alt:1;	/* was allocated using alternative strategy */
 	int chunk_bit_stride;	/* Number of bytes of chunk_bits per block.
 				 * Must be consistent with chunks_per_block.
 				 */
 
 	int n_erased_blocks;
 	int alloc_block;	/* Current block being allocated off */
-	u32 alloc_page;
+	__u32 alloc_page;
 	int alloc_block_finder;	/* Used to search for next allocation block */
 
 	/* Object and Tnode memory management */
@@ -706,17 +687,16 @@ struct yaffs_dev {
 
 	int n_hardlinks;
 
-	struct yaffs_obj_bucket obj_bucket[YAFFS_NOBJECT_BUCKETS];
-	u32 bucket_finder;
+	yaffs_obj_bucket obj_bucket[YAFFS_NOBJECT_BUCKETS];
+	__u32 bucket_finder;
 
 	int n_free_chunks;
 
 	/* Garbage collection control */
-	u32 *gc_cleanup_list;	/* objects to delete at the end of a GC. */
-	u32 n_clean_ups;
+	__u32 *gc_cleanup_list;	/* objects to delete at the end of a GC. */
+	__u32 n_clean_ups;
 
-	unsigned has_pending_prioritised_gc;	/* We think this device might
-						have pending prioritised gcs */
+	unsigned has_pending_prioritised_gc; /* We think this device might have pending prioritised gcs */
 	unsigned gc_disable;
 	unsigned gc_block_finder;
 	unsigned gc_dirtiest;
@@ -725,286 +705,265 @@ struct yaffs_dev {
 	unsigned gc_block;
 	unsigned gc_chunk;
 	unsigned gc_skip;
-	struct yaffs_summary_tags *gc_sum_tags;
 
 	/* Special directories */
-	struct yaffs_obj *root_dir;
-	struct yaffs_obj *lost_n_found;
+	yaffs_obj_t *root_dir;
+	yaffs_obj_t *lost_n_found;
+
+	/* Buffer areas for storing data to recover from write failures TODO
+	 *      __u8            buffered_data[YAFFS_CHUNKS_PER_BLOCK][YAFFS_BYTES_PER_CHUNK];
+	 *      yaffs_spare buffered_spare[YAFFS_CHUNKS_PER_BLOCK];
+	 */
 
 	int buffered_block;	/* Which block is buffered here? */
 	int doing_buffered_block_rewrite;
 
-	struct yaffs_cache *cache;
+	yaffs_cache_t *cache;
 	int cache_last_use;
 
-	/* Stuff for background deletion and unlinked files. */
-	struct yaffs_obj *unlinked_dir;	/* Directory where unlinked and deleted
-					 files live. */
-	struct yaffs_obj *del_dir;	/* Directory where deleted objects are
-					sent to disappear. */
-	struct yaffs_obj *unlinked_deletion;	/* Current file being
-							background deleted. */
-	int n_deleted_files;	/* Count of files awaiting deletion; */
-	int n_unlinked_files;	/* Count of unlinked files. */
+	/* Stuff for background deletion and unlinked files.*/
+	yaffs_obj_t *unlinked_dir;	/* Directory where unlinked and deleted files live. */
+	yaffs_obj_t *del_dir;	/* Directory where deleted objects are sent to disappear. */
+	yaffs_obj_t *unlinked_deletion;	/* Current file being background deleted.*/
+	int n_deleted_files;		/* Count of files awaiting deletion;*/
+	int n_unlinked_files;		/* Count of unlinked files. */
 	int n_bg_deletions;	/* Count of background deletions. */
 
 	/* Temporary buffer management */
-	struct yaffs_buffer temp_buffer[YAFFS_N_TEMP_BUFFERS];
+	yaffs_buffer_t temp_buffer[YAFFS_N_TEMP_BUFFERS];
 	int max_temp;
 	int temp_in_use;
 	int unmanaged_buffer_allocs;
 	int unmanaged_buffer_deallocs;
 
 	/* yaffs2 runtime stuff */
-	unsigned seq_number;	/* Sequence number of currently
-					allocating block */
+	unsigned seq_number;	/* Sequence number of currently allocating block */
 	unsigned oldest_dirty_seq;
 	unsigned oldest_dirty_block;
 
 	/* Block refreshing */
-	int refresh_skip;	/* A skip down counter.
-				 * Refresh happens when this gets to zero. */
+	int refresh_skip;	/* A skip down counter. Refresh happens when this gets to zero. */
 
 	/* Dirty directory handling */
-	struct list_head dirty_dirs;	/* List of dirty directories */
+	struct ylist_head dirty_dirs; /* List of dirty directories */
 
-	/* Summary */
-	int chunks_per_summary;
-	struct yaffs_summary_tags *sum_tags;
 
-	/* Statistics */
-	u32 n_page_writes;
-	u32 n_page_reads;
-	u32 n_erasures;
-	u32 n_bad_queries;
-	u32 n_bad_markings;
-	u32 n_erase_failures;
-	u32 n_gc_copies;
-	u32 all_gcs;
-	u32 passive_gc_count;
-	u32 oldest_dirty_gc_count;
-	u32 n_gc_blocks;
-	u32 bg_gcs;
-	u32 n_retried_writes;
-	u32 n_retired_blocks;
-	u32 n_ecc_fixed;
-	u32 n_ecc_unfixed;
-	u32 n_tags_ecc_fixed;
-	u32 n_tags_ecc_unfixed;
-	u32 n_deletions;
-	u32 n_unmarked_deletions;
-	u32 refresh_count;
-	u32 cache_hits;
-	u32 tags_used;
-	u32 summary_used;
+	/* Statistcs */
+	__u32 n_page_writes;
+	__u32 n_page_reads;
+	__u32 n_erasures;
+	__u32 n_erase_failures;
+	__u32 n_gc_copies;
+	__u32 all_gcs;
+	__u32 passive_gc_count;
+	__u32 oldest_dirty_gc_count;
+	__u32 n_gc_blocks;
+	__u32 bg_gcs;
+	__u32 n_retired_writes;
+	__u32 n_retired_blocks;
+	__u32 n_ecc_fixed;
+	__u32 n_ecc_unfixed;
+	__u32 n_tags_ecc_fixed;
+	__u32 n_tags_ecc_unfixed;
+	__u32 n_deletions;
+	__u32 n_unmarked_deletions;
+	__u32 refresh_count;
+	__u32 cache_hits;
 
 };
 
-/* The CheckpointDevice structure holds the device information that changes
- *at runtime and must be preserved over unmount/mount cycles.
+typedef struct yaffs_dev_s yaffs_dev_t;
+
+/* The static layout of block usage etc is stored in the super block header */
+typedef struct {
+	int StructType;
+	int version;
+	int checkpt_start_block;
+	int checkpt_end_block;
+	int start_block;
+	int end_block;
+	int rfu[100];
+} yaffs_sb_header;
+
+/* The CheckpointDevice structure holds the device information that changes at runtime and
+ * must be preserved over unmount/mount cycles.
  */
-struct yaffs_checkpt_dev {
+typedef struct {
 	int struct_type;
 	int n_erased_blocks;
 	int alloc_block;	/* Current block being allocated off */
-	u32 alloc_page;
+	__u32 alloc_page;
 	int n_free_chunks;
 
-	int n_deleted_files;	/* Count of files awaiting deletion; */
-	int n_unlinked_files;	/* Count of unlinked files. */
+	int n_deleted_files;		/* Count of files awaiting deletion;*/
+	int n_unlinked_files;		/* Count of unlinked files. */
 	int n_bg_deletions;	/* Count of background deletions. */
 
 	/* yaffs2 runtime stuff */
-	unsigned seq_number;	/* Sequence number of currently
-				 * allocating block */
+	unsigned seq_number;	/* Sequence number of currently allocating block */
 
-};
+} yaffs_checkpt_dev_t;
 
-struct yaffs_checkpt_validity {
+
+typedef struct {
 	int struct_type;
-	u32 magic;
-	u32 version;
-	u32 head;
-};
+	__u32 magic;
+	__u32 version;
+	__u32 head;
+} yaffs_checkpt_validty_t;
 
-struct yaffs_shadow_fixer {
+
+struct yaffs_shadow_fixer_s {
 	int obj_id;
 	int shadowed_id;
-	struct yaffs_shadow_fixer *next;
+	struct yaffs_shadow_fixer_s *next;
 };
 
 /* Structure for doing xattr modifications */
-struct yaffs_xattr_mod {
-	int set;		/* If 0 then this is a deletion */
+typedef struct {
+	int set; /* If 0 then this is a deletion */
 	const YCHAR *name;
 	const void *data;
 	int size;
 	int flags;
 	int result;
-};
+}yaffs_xattr_mod;
+
 
 /*----------------------- YAFFS Functions -----------------------*/
 
-int yaffs_guts_initialise(struct yaffs_dev *dev);
-void yaffs_deinitialise(struct yaffs_dev *dev);
+int yaffs_guts_initialise(yaffs_dev_t *dev);
+void yaffs_deinitialise(yaffs_dev_t *dev);
 
-int yaffs_get_n_free_chunks(struct yaffs_dev *dev);
+int yaffs_get_n_free_chunks(yaffs_dev_t *dev);
 
-int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR * old_name,
-		     struct yaffs_obj *new_dir, const YCHAR * new_name);
+int yaffs_rename_obj(yaffs_obj_t *old_dir, const YCHAR *old_name,
+		       yaffs_obj_t *new_dir, const YCHAR *new_name);
 
-int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR * name);
-int yaffs_del_obj(struct yaffs_obj *obj);
-struct yaffs_obj *yaffs_retype_obj(struct yaffs_obj *obj,
-				   enum yaffs_obj_type type);
+int yaffs_unlinker(yaffs_obj_t *dir, const YCHAR *name);
+int yaffs_del_obj(yaffs_obj_t *obj);
 
+int yaffs_get_obj_name(yaffs_obj_t *obj, YCHAR *name, int buffer_size);
+int yaffs_get_obj_length(yaffs_obj_t *obj);
+int yaffs_get_obj_inode(yaffs_obj_t *obj);
+unsigned yaffs_get_obj_type(yaffs_obj_t *obj);
+int yaffs_get_obj_link_count(yaffs_obj_t *obj);
 
-int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR * name, int buffer_size);
-loff_t yaffs_get_obj_length(struct yaffs_obj *obj);
-int yaffs_get_obj_inode(struct yaffs_obj *obj);
-unsigned yaffs_get_obj_type(struct yaffs_obj *obj);
-int yaffs_get_obj_link_count(struct yaffs_obj *obj);
+int yaffs_set_attribs(yaffs_obj_t *obj, struct iattr *attr);
+int yaffs_get_attribs(yaffs_obj_t *obj, struct iattr *attr);
 
 /* File operations */
-int yaffs_file_rd(struct yaffs_obj *obj, u8 * buffer, loff_t offset,
-		  int n_bytes);
-int yaffs_wr_file(struct yaffs_obj *obj, const u8 * buffer, loff_t offset,
-		  int n_bytes, int write_trhrough);
-int yaffs_resize_file(struct yaffs_obj *obj, loff_t new_size);
+int yaffs_file_rd(yaffs_obj_t *obj, __u8 *buffer, loff_t offset,
+				int n_bytes);
+int yaffs_wr_file(yaffs_obj_t *obj, const __u8 *buffer, loff_t offset,
+				int n_bytes, int write_trhrough);
+int yaffs_resize_file(yaffs_obj_t *obj, loff_t new_size);
 
-struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
-				    const YCHAR *name, u32 mode, u32 uid,
-				    u32 gid);
+yaffs_obj_t *yaffs_create_file(yaffs_obj_t *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid);
 
-int yaffs_flush_file(struct yaffs_obj *in,
-		     int update_time,
-		     int data_sync,
-		     int discard_cache);
+int yaffs_flush_file(yaffs_obj_t *obj, int update_time, int data_sync);
 
 /* Flushing and checkpointing */
-void yaffs_flush_whole_cache(struct yaffs_dev *dev, int discard);
+void yaffs_flush_whole_cache(yaffs_dev_t *dev);
 
-int yaffs_checkpoint_save(struct yaffs_dev *dev);
-int yaffs_checkpoint_restore(struct yaffs_dev *dev);
+int yaffs_checkpoint_save(yaffs_dev_t *dev);
+int yaffs_checkpoint_restore(yaffs_dev_t *dev);
 
 /* Directory operations */
-struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
-				   u32 mode, u32 uid, u32 gid);
-struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *the_dir,
-				     const YCHAR *name);
-struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number);
+yaffs_obj_t *yaffs_create_dir(yaffs_obj_t *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid);
+yaffs_obj_t *yaffs_find_by_name(yaffs_obj_t *the_dir, const YCHAR *name);
+int yaffs_ApplyToDirectoryChildren(yaffs_obj_t *the_dir,
+				   int (*fn) (yaffs_obj_t *));
+
+yaffs_obj_t *yaffs_find_by_number(yaffs_dev_t *dev, __u32 number);
 
 /* Link operations */
-struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR *name,
-				 struct yaffs_obj *equiv_obj);
+yaffs_obj_t *yaffs_link_obj(yaffs_obj_t *parent, const YCHAR *name,
+			 yaffs_obj_t *equiv_obj);
 
-struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj);
+yaffs_obj_t *yaffs_get_equivalent_obj(yaffs_obj_t *obj);
 
 /* Symlink operations */
-struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
-				       const YCHAR *name, u32 mode, u32 uid,
-				       u32 gid, const YCHAR *alias);
-YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj);
+yaffs_obj_t *yaffs_create_symlink(yaffs_obj_t *parent, const YCHAR *name,
+				 __u32 mode, __u32 uid, __u32 gid,
+				 const YCHAR *alias);
+YCHAR *yaffs_get_symlink_alias(yaffs_obj_t *obj);
 
 /* Special inodes (fifos, sockets and devices) */
-struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
-				       const YCHAR *name, u32 mode, u32 uid,
-				       u32 gid, u32 rdev);
+yaffs_obj_t *yaffs_create_special(yaffs_obj_t *parent, const YCHAR *name,
+				 __u32 mode, __u32 uid, __u32 gid, __u32 rdev);
 
-int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR *name,
-		      const void *value, int size, int flags);
-int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR *name, void *value,
-		      int size);
-int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size);
-int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR *name);
+
+int yaffs_set_xattrib(yaffs_obj_t *obj, const YCHAR *name, const void * value, int size, int flags);
+int yaffs_get_xattrib(yaffs_obj_t *obj, const YCHAR *name, void *value, int size);
+int yaffs_list_xattrib(yaffs_obj_t *obj, char *buffer, int size);
+int yaffs_remove_xattrib(yaffs_obj_t *obj, const YCHAR *name);
 
 /* Special directories */
-struct yaffs_obj *yaffs_root(struct yaffs_dev *dev);
-struct yaffs_obj *yaffs_lost_n_found(struct yaffs_dev *dev);
+yaffs_obj_t *yaffs_root(yaffs_dev_t *dev);
+yaffs_obj_t *yaffs_lost_n_found(yaffs_dev_t *dev);
 
-void yaffs_handle_defered_free(struct yaffs_obj *obj);
+#ifdef CONFIG_YAFFS_WINCE
+/* CONFIG_YAFFS_WINCE special stuff */
+void yfsd_win_file_time_now(__u32 target[2]);
+#endif
 
-void yaffs_update_dirty_dirs(struct yaffs_dev *dev);
+void yaffs_handle_defered_free(yaffs_obj_t *obj);
 
-int yaffs_bg_gc(struct yaffs_dev *dev, unsigned urgency);
+void yaffs_update_dirty_dirs(yaffs_dev_t *dev);
+
+int yaffs_bg_gc(yaffs_dev_t *dev, unsigned urgency);
 
 /* Debug dump  */
-int yaffs_dump_obj(struct yaffs_obj *obj);
+int yaffs_dump_obj(yaffs_obj_t *obj);
 
-void yaffs_guts_test(struct yaffs_dev *dev);
-int yaffs_guts_ll_init(struct yaffs_dev *dev);
-
+void yaffs_guts_test(yaffs_dev_t *dev);
 
 /* A few useful functions to be used within the core files*/
-void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
-		     int lyn);
-int yaffs_check_ff(u8 *buffer, int n_bytes);
-void yaffs_handle_chunk_error(struct yaffs_dev *dev,
-			      struct yaffs_block_info *bi);
+void yaffs_chunk_del(yaffs_dev_t *dev, int chunk_id, int mark_flash, int lyn);
+int yaffs_check_ff(__u8 *buffer, int n_bytes);
+void yaffs_handle_chunk_error(yaffs_dev_t *dev, yaffs_block_info_t *bi);
 
-u8 *yaffs_get_temp_buffer(struct yaffs_dev *dev);
-void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer);
+__u8 *yaffs_get_temp_buffer(yaffs_dev_t *dev, int line_no);
+void yaffs_release_temp_buffer(yaffs_dev_t *dev, __u8 *buffer, int line_no);
 
-struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
-						 int number,
-						 enum yaffs_obj_type type);
-int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
-			    int nand_chunk, int in_scan);
-void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR *name);
-void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
-				const struct yaffs_obj_hdr *oh);
-void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj);
+yaffs_obj_t *yaffs_find_or_create_by_number(yaffs_dev_t *dev,
+					        int number,
+					        yaffs_obj_type type);
+int yaffs_put_chunk_in_file(yaffs_obj_t *in, int inode_chunk,
+			        int nand_chunk, int in_scan);
+void yaffs_set_obj_name(yaffs_obj_t *obj, const YCHAR *name);
+void yaffs_set_obj_name_from_oh(yaffs_obj_t *obj, const yaffs_obj_header *oh);
+void yaffs_add_obj_to_dir(yaffs_obj_t *directory,
+					yaffs_obj_t *obj);
 YCHAR *yaffs_clone_str(const YCHAR *str);
-void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list);
-void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no);
-int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name,
-		    int force, int is_shrink, int shadows,
-		    struct yaffs_xattr_mod *xop);
-void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
-			       int backward_scanning);
-int yaffs_check_alloc_available(struct yaffs_dev *dev, int n_chunks);
-struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev);
-struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
-					   struct yaffs_file_var *file_struct,
-					   u32 chunk_id,
-					   struct yaffs_tnode *passed_tn);
+void yaffs_link_fixup(yaffs_dev_t *dev, yaffs_obj_t *hard_list);
+void yaffs_block_became_dirty(yaffs_dev_t *dev, int block_no);
+int yaffs_update_oh(yaffs_obj_t *in, const YCHAR *name,
+				int force, int is_shrink, int shadows,
+                                yaffs_xattr_mod *xop);
+void yaffs_handle_shadowed_obj(yaffs_dev_t *dev, int obj_id,
+				int backward_scanning);
+int yaffs_check_alloc_available(yaffs_dev_t *dev, int n_chunks);
+yaffs_tnode_t *yaffs_get_tnode(yaffs_dev_t *dev);
+yaffs_tnode_t *yaffs_add_find_tnode_0(yaffs_dev_t *dev,
+					yaffs_file_s *file_struct,
+					__u32 chunk_id,
+					yaffs_tnode_t *passed_tn);
 
-int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
-		     int n_bytes, int write_trhrough);
-void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size);
-void yaffs_skip_rest_of_block(struct yaffs_dev *dev);
+int yaffs_do_file_wr(yaffs_obj_t *in, const __u8 *buffer, loff_t offset,
+			int n_bytes, int write_trhrough);
+void yaffs_resize_file_down( yaffs_obj_t *obj, loff_t new_size);
+void yaffs_skip_rest_of_block(yaffs_dev_t *dev);
 
-int yaffs_count_free_chunks(struct yaffs_dev *dev);
+int yaffs_count_free_chunks(yaffs_dev_t *dev);
 
-struct yaffs_tnode *yaffs_find_tnode_0(struct yaffs_dev *dev,
-				       struct yaffs_file_var *file_struct,
-				       u32 chunk_id);
+yaffs_tnode_t *yaffs_find_tnode_0(yaffs_dev_t *dev,
+				yaffs_file_s *file_struct,
+				__u32 chunk_id);
 
-u32 yaffs_get_group_base(struct yaffs_dev *dev, struct yaffs_tnode *tn,
-			 unsigned pos);
-
-int yaffs_is_non_empty_dir(struct yaffs_obj *obj);
-
-int yaffs_guts_format_dev(struct yaffs_dev *dev);
-
-void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
-				int *chunk_out, u32 *offset_out);
-/*
- * Marshalling functions to get loff_t file sizes into aand out of
- * object headers.
- */
-void yaffs_oh_size_load(struct yaffs_obj_hdr *oh, loff_t fsize);
-loff_t yaffs_oh_to_size(struct yaffs_obj_hdr *oh);
-loff_t yaffs_max_file_size(struct yaffs_dev *dev);
-
-/*
- * Debug function to count number of blocks in each state
- * NB Needs to be called with correct number of integers
- */
-
-void yaffs_count_blocks_by_state(struct yaffs_dev *dev, int bs[10]);
-
-int yaffs_find_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
-				    struct yaffs_ext_tags *tags);
+__u32 yaffs_get_group_base(yaffs_dev_t *dev, yaffs_tnode_t *tn, unsigned pos);
 
 #endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_linux.h b/target/linux/generic/files/fs/yaffs2/yaffs_linux.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_linux.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_linux.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -16,33 +16,28 @@
 #ifndef __YAFFS_LINUX_H__
 #define __YAFFS_LINUX_H__
 
+#include "devextras.h"
 #include "yportenv.h"
 
-struct yaffs_linux_context {
-	struct list_head context_list;	/* List of these we have mounted */
-	struct yaffs_dev *dev;
-	struct super_block *super;
-	struct task_struct *bg_thread;	/* Background thread for this device */
-	int bg_running;
-	struct mutex gross_lock;	/* Gross locking mutex*/
-	u8 *spare_buffer;	/* For mtdif2 use. Don't know the buffer size
+struct yaffs_LinuxContext {
+	struct ylist_head	contextList; /* List of these we have mounted */
+	struct yaffs_dev_s *dev;
+	struct super_block * superBlock;
+	struct task_struct *bgThread; /* Background thread for this device */
+	int bgRunning;
+        struct semaphore grossLock;     /* Gross locking semaphore */
+	__u8 *spareBuffer;      /* For mtdif2 use. Don't know the size of the buffer
 				 * at compile time so we have to allocate it.
 				 */
-	struct list_head search_contexts;
-	struct task_struct *readdir_process;
+	struct ylist_head searchContexts;
+	void (*putSuperFunc)(struct super_block *sb);
+
+	struct task_struct *readdirProcess;
 	unsigned mount_id;
-	int dirty;
 };
 
-#define yaffs_dev_to_lc(dev) ((struct yaffs_linux_context *)((dev)->os_context))
+#define yaffs_dev_to_lc(dev) ((struct yaffs_LinuxContext *)((dev)->os_context))
 #define yaffs_dev_to_mtd(dev) ((struct mtd_info *)((dev)->driver_context))
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
-#define WRITE_SIZE_STR "writesize"
-#define WRITE_SIZE(mtd) ((mtd)->writesize)
-#else
-#define WRITE_SIZE_STR "oobblock"
-#define WRITE_SIZE(mtd) ((mtd)->oobblock)
 #endif
 
-#endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_linux_allocator.c b/target/linux/generic/files/fs/yaffs2/yaffs_linux_allocator.c
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_linux_allocator.c
@@ -0,0 +1,200 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ *
+ * Note: Tis code is currently unused. Being checked in in case it becomes useful.
+ */
+
+
+#include "yaffs_allocator.h"
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+#include "yportenv.h"
+#include "yaffs_linux.h"
+/*
+ * Start out with the same allocator as yaffs direct.
+ * Todo: Change to Linux slab allocator.
+ */
+
+
+
+#define NAMELEN  20
+struct yaffs_AllocatorStruct {
+	char tnode_name[NAMELEN+1];
+	char object_name[NAMELEN+1];
+	struct kmem_cache *tnode_cache;
+	struct kmem_cache *object_cache;
+};
+
+typedef struct yaffs_AllocatorStruct yaffs_Allocator;
+
+int mount_id;
+
+void yaffs_deinit_raw_tnodes_and_objs(yaffs_dev_t *dev)
+{
+	yaffs_Allocator *allocator = (yaffs_Allocator *)dev->allocator;
+
+	T(YAFFS_TRACE_ALLOCATE,(TSTR("Deinitialising yaffs allocator\n")));
+
+	if(allocator){
+		if(allocator->tnode_cache){
+			kmem_cache_destroy(allocator->tnode_cache);
+			allocator->tnode_cache = NULL;
+		} else {
+			T(YAFFS_TRACE_ALWAYS,
+				(TSTR("NULL tnode cache\n")));
+			YBUG();
+		}
+
+		if(allocator->object_cache){
+			kmem_cache_destroy(allocator->object_cache);
+			allocator->object_cache = NULL;
+		} else {
+			T(YAFFS_TRACE_ALWAYS,
+				(TSTR("NULL object cache\n")));
+			YBUG();
+		}
+
+		YFREE(allocator);
+
+	} else {
+		T(YAFFS_TRACE_ALWAYS,
+			(TSTR("Deinitialising NULL allocator\n")));
+		YBUG();
+	}
+	dev->allocator = NULL;
+}
+
+
+static void fake_ctor0(void *data){data = data;}
+static void fake_ctor1(void *data){data = data;}
+static void fake_ctor2(void *data){data = data;}
+static void fake_ctor3(void *data){data = data;}
+static void fake_ctor4(void *data){data = data;}
+static void fake_ctor5(void *data){data = data;}
+static void fake_ctor6(void *data){data = data;}
+static void fake_ctor7(void *data){data = data;}
+static void fake_ctor8(void *data){data = data;}
+static void fake_ctor9(void *data){data = data;}
+
+static void (*fake_ctor_list[10]) (void *) = {
+	fake_ctor0,
+	fake_ctor1,
+	fake_ctor2,
+	fake_ctor3,
+	fake_ctor4,
+	fake_ctor5,
+	fake_ctor6,
+	fake_ctor7,
+	fake_ctor8,
+	fake_ctor9,
+};
+
+void yaffs_init_raw_tnodes_and_objs(yaffs_dev_t *dev)
+{
+	yaffs_Allocator *allocator;
+	unsigned mount_id = yaffs_dev_to_lc(dev)->mount_id;
+
+	T(YAFFS_TRACE_ALLOCATE,(TSTR("Initialising yaffs allocator\n")));
+
+	if(dev->allocator)
+		YBUG();
+	else if(mount_id >= 10){
+		T(YAFFS_TRACE_ALWAYS,(TSTR("Bad mount_id %u\n"),mount_id));
+	} else {
+		 allocator = YMALLOC(sizeof(yaffs_Allocator));
+		 memset(allocator,0,sizeof(yaffs_Allocator));
+		 dev->allocator = allocator;
+
+		if(!dev->allocator){
+			T(YAFFS_TRACE_ALWAYS,
+				(TSTR("yaffs allocator creation failed\n")));
+			YBUG();
+			return;
+
+		}
+
+		sprintf(allocator->tnode_name,"yaffs_t_%u",mount_id);
+		sprintf(allocator->object_name,"yaffs_o_%u",mount_id);
+
+		allocator->tnode_cache =
+			kmem_cache_create(allocator->tnode_name,
+				dev->tnode_size,
+				0, 0,
+				fake_ctor_list[mount_id]);
+		if(allocator->tnode_cache)
+			T(YAFFS_TRACE_ALLOCATE,
+				(TSTR("tnode cache \"%s\" %p\n"),
+				allocator->tnode_name,allocator->tnode_cache));
+		else {
+			T(YAFFS_TRACE_ALWAYS,
+				(TSTR("yaffs cache creation failed\n")));
+			YBUG();
+		}
+
+
+		allocator->object_cache = 
+			kmem_cache_create(allocator->object_name,
+				sizeof(yaffs_obj_t),
+				0, 0,
+				fake_ctor_list[mount_id]);
+
+		if(allocator->object_cache)
+			T(YAFFS_TRACE_ALLOCATE,
+				(TSTR("object cache \"%s\" %p\n"),
+				allocator->object_name,allocator->object_cache));
+
+		else {
+			T(YAFFS_TRACE_ALWAYS,
+				(TSTR("yaffs cache creation failed\n")));
+			YBUG();
+		}
+	} 
+}
+
+
+yaffs_tnode_t *yaffs_alloc_raw_tnode(yaffs_dev_t *dev)
+{
+	yaffs_Allocator *allocator = dev->allocator;
+	if(!allocator || !allocator->tnode_cache){
+		YBUG();
+		return NULL;
+	}
+	return kmem_cache_alloc(allocator->tnode_cache, GFP_NOFS);
+}
+
+void yaffs_free_raw_tnode(yaffs_dev_t *dev, yaffs_tnode_t *tn)
+{
+	yaffs_Allocator *allocator = dev->allocator;
+	kmem_cache_free(allocator->tnode_cache,tn);
+}
+
+yaffs_obj_t *yaffs_alloc_raw_obj(yaffs_dev_t *dev)
+{
+	yaffs_Allocator *allocator = dev->allocator;
+	if(!allocator){
+		YBUG();
+		return NULL;
+	}
+	if(!allocator->object_cache){
+		YBUG();
+		return NULL;
+	}
+	return kmem_cache_alloc(allocator->object_cache, GFP_NOFS);
+}
+
+void yaffs_free_raw_obj(yaffs_dev_t *dev, yaffs_obj_t *obj)
+{
+	yaffs_Allocator *allocator = dev->allocator;
+	kmem_cache_free(allocator->object_cache,obj);
+}
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_list.h b/target/linux/generic/files/fs/yaffs2/yaffs_list.h
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_list.h
@@ -0,0 +1,127 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * This file is just holds extra declarations of macros that would normally
+ * be providesd in the Linux kernel. These macros have been written from
+ * scratch but are functionally equivalent to the Linux ones.
+ *
+ */
+
+#ifndef __YAFFS_LIST_H__
+#define __YAFFS_LIST_H__
+
+
+#include "yportenv.h"
+
+/*
+ * This is a simple doubly linked list implementation that matches the
+ * way the Linux kernel doubly linked list implementation works.
+ */
+
+struct ylist_head {
+	struct ylist_head *next; /* next in chain */
+	struct ylist_head *prev; /* previous in chain */
+};
+
+
+/* Initialise a static list */
+#define YLIST_HEAD(name) \
+struct ylist_head name = { &(name), &(name)}
+
+
+
+/* Initialise a list head to an empty list */
+#define YINIT_LIST_HEAD(p) \
+do { \
+	(p)->next = (p);\
+	(p)->prev = (p); \
+} while (0)
+
+
+/* Add an element to a list */
+static Y_INLINE void ylist_add(struct ylist_head *newEntry,
+				struct ylist_head *list)
+{
+	struct ylist_head *listNext = list->next;
+
+	list->next = newEntry;
+	newEntry->prev = list;
+	newEntry->next = listNext;
+	listNext->prev = newEntry;
+
+}
+
+static Y_INLINE void ylist_add_tail(struct ylist_head *newEntry,
+				 struct ylist_head *list)
+{
+	struct ylist_head *listPrev = list->prev;
+
+	list->prev = newEntry;
+	newEntry->next = list;
+	newEntry->prev = listPrev;
+	listPrev->next = newEntry;
+
+}
+
+
+/* Take an element out of its current list, with or without
+ * reinitialising the links.of the entry*/
+static Y_INLINE void ylist_del(struct ylist_head *entry)
+{
+	struct ylist_head *listNext = entry->next;
+	struct ylist_head *listPrev = entry->prev;
+
+	listNext->prev = listPrev;
+	listPrev->next = listNext;
+
+}
+
+static Y_INLINE void ylist_del_init(struct ylist_head *entry)
+{
+	ylist_del(entry);
+	entry->next = entry->prev = entry;
+}
+
+
+/* Test if the list is empty */
+static Y_INLINE int ylist_empty(struct ylist_head *entry)
+{
+	return (entry->next == entry);
+}
+
+
+/* ylist_entry takes a pointer to a list entry and offsets it to that
+ * we can find a pointer to the object it is embedded in.
+ */
+
+
+#define ylist_entry(entry, type, member) \
+	((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))
+
+
+/* ylist_for_each and list_for_each_safe  iterate over lists.
+ * ylist_for_each_safe uses temporary storage to make the list delete safe
+ */
+
+#define ylist_for_each(itervar, list) \
+	for (itervar = (list)->next; itervar != (list); itervar = itervar->next)
+
+#define ylist_for_each_safe(itervar, saveVar, list) \
+	for (itervar = (list)->next, saveVar = (list)->next->next; \
+		itervar != (list); itervar = saveVar, saveVar = saveVar->next)
+
+
+#endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_mtdif.c b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_mtdif.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -13,45 +13,24 @@
 
 #include "yportenv.h"
 
+
 #include "yaffs_mtdif.h"
 
 #include "linux/mtd/mtd.h"
 #include "linux/types.h"
 #include "linux/time.h"
 #include "linux/mtd/nand.h"
-#include "linux/kernel.h"
-#include "linux/version.h"
-#include "linux/types.h"
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
-#include "uapi/linux/major.h"
-#endif
 
-#include "yaffs_trace.h"
-#include "yaffs_guts.h"
 #include "yaffs_linux.h"
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
-#define MTD_OPS_AUTO_OOB MTD_OOB_AUTO
-#endif
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
-#define mtd_erase(m, ei) (m)->erase(m, ei)
-#define mtd_write_oob(m, addr, pops) (m)->write_oob(m, addr, pops)
-#define mtd_read_oob(m, addr, pops) (m)->read_oob(m, addr, pops)
-#define mtd_block_isbad(m, offs) (m)->block_isbad(m, offs)
-#define mtd_block_markbad(m, offs) (m)->block_markbad(m, offs)
-#endif
-
-
-
-int nandmtd_erase_block(struct yaffs_dev *dev, int block_no)
+int nandmtd_EraseBlockInNAND(yaffs_dev_t *dev, int blockNumber)
 {
 	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
-	u32 addr =
-	    ((loff_t) block_no) * dev->param.total_bytes_per_chunk *
-	    dev->param.chunks_per_block;
+	__u32 addr =
+	    ((loff_t) blockNumber) * dev->param.total_bytes_per_chunk
+		* dev->param.chunks_per_block;
 	struct erase_info ei;
+	
 	int retval = 0;
 
 	ei.mtd = mtd;
@@ -62,249 +41,16 @@ int nandmtd_erase_block(struct yaffs_dev
 	ei.callback = NULL;
 	ei.priv = (u_long) dev;
 
-	retval = mtd_erase(mtd, &ei);
+	retval = mtd->erase(mtd, &ei);
 
 	if (retval == 0)
 		return YAFFS_OK;
-
-	return YAFFS_FAIL;
+	else
+		return YAFFS_FAIL;
 }
 
-
-static 	int yaffs_mtd_write(struct yaffs_dev *dev, int nand_chunk,
-				   const u8 *data, int data_len,
-				   const u8 *oob, int oob_len)
-{
-	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
-	loff_t addr;
-	struct mtd_oob_ops ops;
-	int retval;
-
-	yaffs_trace(YAFFS_TRACE_MTD,
-			"yaffs_mtd_write(%p, %d, %p, %d, %p, %d)\n",
-			dev, nand_chunk, data, data_len, oob, oob_len);
-
-	if (!data || !data_len) {
-		data = NULL;
-		data_len = 0;
-	}
-
-	if (!oob || !oob_len) {
-		oob = NULL;
-		oob_len = 0;
-	}
-
-	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
-	memset(&ops, 0, sizeof(ops));
-	ops.mode = MTD_OPS_AUTO_OOB;
-	ops.len = (data) ? data_len : 0;
-	ops.ooblen = oob_len;
-	ops.datbuf = (u8 *)data;
-	ops.oobbuf = (u8 *)oob;
-
-	retval = mtd_write_oob(mtd, addr, &ops);
-	if (retval) {
-		yaffs_trace(YAFFS_TRACE_MTD,
-			"write_oob failed, chunk %d, mtd error %d",
-			nand_chunk, retval);
-	}
-	return retval ? YAFFS_FAIL : YAFFS_OK;
-}
-
-static int yaffs_mtd_read(struct yaffs_dev *dev, int nand_chunk,
-				   u8 *data, int data_len,
-				   u8 *oob, int oob_len,
-				   enum yaffs_ecc_result *ecc_result)
-{
-	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
-	loff_t addr;
-	struct mtd_oob_ops ops;
-	int retval;
-
-	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
-	memset(&ops, 0, sizeof(ops));
-	ops.mode = MTD_OPS_AUTO_OOB;
-	ops.len = (data) ? data_len : 0;
-	ops.ooblen = oob_len;
-	ops.datbuf = data;
-	ops.oobbuf = oob;
-
-#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
-	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
-	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
-	 */
-	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
-#endif
-	/* Read page and oob using MTD.
-	 * Check status and determine ECC result.
-	 */
-	retval = mtd_read_oob(mtd, addr, &ops);
-	if (retval)
-		yaffs_trace(YAFFS_TRACE_MTD,
-			"read_oob failed, chunk %d, mtd error %d",
-			nand_chunk, retval);
-
-	switch (retval) {
-	case 0:
-		/* no error */
-		if(ecc_result)
-			*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
-		break;
-
-	case -EUCLEAN:
-		/* MTD's ECC fixed the data */
-		if(ecc_result)
-			*ecc_result = YAFFS_ECC_RESULT_FIXED;
-		dev->n_ecc_fixed++;
-		break;
-
-	case -EBADMSG:
-	default:
-		/* MTD's ECC could not fix the data */
-		dev->n_ecc_unfixed++;
-		if(ecc_result)
-			*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
-		return YAFFS_FAIL;
-	}
-
-	return YAFFS_OK;
-}
-
-static 	int yaffs_mtd_erase(struct yaffs_dev *dev, int block_no)
-{
-	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
-
-	loff_t addr;
-	struct erase_info ei;
-	int retval = 0;
-	u32 block_size;
-
-	block_size = dev->param.total_bytes_per_chunk *
-		     dev->param.chunks_per_block;
-	addr = ((loff_t) block_no) * block_size;
-
-	ei.mtd = mtd;
-	ei.addr = addr;
-	ei.len = block_size;
-	ei.time = 1000;
-	ei.retries = 2;
-	ei.callback = NULL;
-	ei.priv = (u_long) dev;
-
-	retval = mtd_erase(mtd, &ei);
-
-	if (retval == 0)
-		return YAFFS_OK;
-
-	return YAFFS_FAIL;
-}
-
-static int yaffs_mtd_mark_bad(struct yaffs_dev *dev, int block_no)
-{
-	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
-	int blocksize = dev->param.chunks_per_block * dev->param.total_bytes_per_chunk;
-	int retval;
-
-	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad", block_no);
-
-	retval = mtd_block_markbad(mtd, (loff_t) blocksize * block_no);
-	return (retval) ? YAFFS_FAIL : YAFFS_OK;
-}
-
-static int yaffs_mtd_check_bad(struct yaffs_dev *dev, int block_no)
-{
-	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
-	int blocksize = dev->param.chunks_per_block * dev->param.total_bytes_per_chunk;
-	int retval;
-
-	yaffs_trace(YAFFS_TRACE_MTD, "checking block %d bad", block_no);
-
-	retval = mtd_block_isbad(mtd, (loff_t) blocksize * block_no);
-	return (retval) ? YAFFS_FAIL : YAFFS_OK;
-}
-
-static int yaffs_mtd_initialise(struct yaffs_dev *dev)
+int nandmtd_InitialiseNAND(yaffs_dev_t *dev)
 {
 	return YAFFS_OK;
 }
 
-static int yaffs_mtd_deinitialise(struct yaffs_dev *dev)
-{
-	return YAFFS_OK;
-}
-
-
-void yaffs_mtd_drv_install(struct yaffs_dev *dev)
-{
-	struct yaffs_driver *drv = &dev->drv;
-
-	drv->drv_write_chunk_fn = yaffs_mtd_write;
-	drv->drv_read_chunk_fn = yaffs_mtd_read;
-	drv->drv_erase_fn = yaffs_mtd_erase;
-	drv->drv_mark_bad_fn = yaffs_mtd_mark_bad;
-	drv->drv_check_bad_fn = yaffs_mtd_check_bad;
-	drv->drv_initialise_fn = yaffs_mtd_initialise;
-	drv->drv_deinitialise_fn = yaffs_mtd_deinitialise;
-}
-
-
-struct mtd_info * yaffs_get_mtd_device(dev_t sdev)
-{
-	struct mtd_info *mtd;
-
-	mtd = yaffs_get_mtd_device(sdev);
-
-	/* Check it's an mtd device..... */
-	if (MAJOR(sdev) != MTD_BLOCK_MAJOR)
-		return NULL;	/* This isn't an mtd device */
-
-	/* Check it's NAND */
-	if (mtd->type != MTD_NANDFLASH) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"yaffs: MTD device is not NAND it's type %d",
-			mtd->type);
-		return NULL;
-	}
-
-	yaffs_trace(YAFFS_TRACE_OS, " %s %d", WRITE_SIZE_STR, WRITE_SIZE(mtd));
-	yaffs_trace(YAFFS_TRACE_OS, " oobsize %d", mtd->oobsize);
-	yaffs_trace(YAFFS_TRACE_OS, " erasesize %d", mtd->erasesize);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
-	yaffs_trace(YAFFS_TRACE_OS, " size %u", mtd->size);
-#else
-	yaffs_trace(YAFFS_TRACE_OS, " size %lld", mtd->size);
-#endif
-
-	return mtd;
-}
-
-int yaffs_verify_mtd(struct mtd_info *mtd, int yaffs_version, int inband_tags)
-{
-	if (yaffs_version == 2) {
-		if ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
-		     mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
-		    !inband_tags) {
-			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"MTD device does not have the right page sizes"
-			);
-			return -1;
-		}
-	} else {
-		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
-		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
-			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"MTD device does not support have the right page sizes"
-			);
-			return -1;
-		}
-	}
-
-	return 0;
-}
-
-
-void yaffs_put_mtd_device(struct mtd_info *mtd)
-{
-	if(mtd)
-		put_mtd_device(mtd);
-}
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_mtdif.h b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_mtdif.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -18,8 +18,10 @@
 
 #include "yaffs_guts.h"
 
-void yaffs_mtd_drv_install(struct yaffs_dev *dev);
-struct mtd_info * yaffs_get_mtd_device(dev_t sdev);
-void yaffs_put_mtd_device(struct mtd_info *mtd);
-int yaffs_verify_mtd(struct mtd_info *mtd, int yaffs_version, int inband_tags);
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 18))
+extern struct nand_oobinfo yaffs_oobinfo;
+extern struct nand_oobinfo yaffs_noeccinfo;
 #endif
+int nandmtd_EraseBlockInNAND(yaffs_dev_t *dev, int blockNumber);
+int nandmtd_InitialiseNAND(yaffs_dev_t *dev);
+#endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_mtdif1.c b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif1.c
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif1.c
@@ -0,0 +1,361 @@
+/*
+ * YAFFS: Yet another FFS. A NAND-flash specific file system.
+ * yaffs_mtdif1.c  NAND mtd interface functions for small-page NAND.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This module provides the interface between yaffs_nand.c and the
+ * MTD API.  This version is used when the MTD interface supports the
+ * 'mtd_oob_ops' style calls to read_oob and write_oob, circa 2.6.17,
+ * and we have small-page NAND device.
+ *
+ * These functions are invoked via function pointers in yaffs_nand.c.
+ * This replaces functionality provided by functions in yaffs_mtdif.c
+ * and the yaffs_tags_tCompatability functions in yaffs_tagscompat.c that are
+ * called in yaffs_mtdif.c when the function pointers are NULL.
+ * We assume the MTD layer is performing ECC (use_nand_ecc is true).
+ */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_packedtags1.h"
+#include "yaffs_tagscompat.h"	/* for yaffs_calc_tags_ecc */
+#include "yaffs_linux.h"
+
+#include "linux/kernel.h"
+#include "linux/version.h"
+#include "linux/types.h"
+#include "linux/mtd/mtd.h"
+
+/* Don't compile this module if we don't have MTD's mtd_oob_ops interface */
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+# define YTAG1_SIZE 8
+#else
+# define YTAG1_SIZE 9
+#endif
+
+#if 0
+/* Use the following nand_ecclayout with MTD when using
+ * CONFIG_YAFFS_9BYTE_TAGS and the older on-NAND tags layout.
+ * If you have existing Yaffs images and the byte order differs from this,
+ * adjust 'oobfree' to match your existing Yaffs data.
+ *
+ * This nand_ecclayout scatters/gathers to/from the old-yaffs layout with the
+ * page_status byte (at NAND spare offset 4) scattered/gathered from/to
+ * the 9th byte.
+ *
+ * Old-style on-NAND format: T0,T1,T2,T3,P,B,T4,T5,E0,E1,E2,T6,T7,E3,E4,E5
+ * We have/need PackedTags1 plus page_status: T0,T1,T2,T3,T4,T5,T6,T7,P
+ * where Tn are the tag bytes, En are MTD's ECC bytes, P is the page_status
+ * byte and B is the small-page bad-block indicator byte.
+ */
+static struct nand_ecclayout nand_oob_16 = {
+	.eccbytes = 6,
+	.eccpos = { 8, 9, 10, 13, 14, 15 },
+	.oobavail = 9,
+	.oobfree = { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+#endif
+
+/* Write a chunk (page) of data to NAND.
+ *
+ * Caller always provides ExtendedTags data which are converted to a more
+ * compact (packed) form for storage in NAND.  A mini-ECC runs over the
+ * contents of the tags meta-data; used to valid the tags when read.
+ *
+ *  - Pack ExtendedTags to PackedTags1 form
+ *  - Compute mini-ECC for PackedTags1
+ *  - Write data and packed tags to NAND.
+ *
+ * Note: Due to the use of the PackedTags1 meta-data which does not include
+ * a full sequence number (as found in the larger PackedTags2 form) it is
+ * necessary for Yaffs to re-write a chunk/page (just once) to mark it as
+ * discarded and dirty.  This is not ideal: newer NAND parts are supposed
+ * to be written just once.  When Yaffs performs this operation, this
+ * function is called with a NULL data pointer -- calling MTD write_oob
+ * without data is valid usage (2.6.17).
+ *
+ * Any underlying MTD error results in YAFFS_FAIL.
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_WriteChunkWithTagsToNAND(yaffs_dev_t *dev,
+	int nand_chunk, const __u8 *data, const yaffs_ext_tags *etags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunkBytes = dev->data_bytes_per_chunk;
+	loff_t addr = ((loff_t)nand_chunk) * chunkBytes;
+	struct mtd_oob_ops ops;
+	yaffs_PackedTags1 pt1;
+	int retval;
+
+	/* we assume that PackedTags1 and yaffs_tags_t are compatible */
+	compile_time_assertion(sizeof(yaffs_PackedTags1) == 12);
+	compile_time_assertion(sizeof(yaffs_tags_t) == 8);
+
+	yaffs_PackTags1(&pt1, etags);
+	yaffs_calc_tags_ecc((yaffs_tags_t *)&pt1);
+
+	/* When deleting a chunk, the upper layer provides only skeletal
+	 * etags, one with is_deleted set.  However, we need to update the
+	 * tags, not erase them completely.  So we use the NAND write property
+	 * that only zeroed-bits stick and set tag bytes to all-ones and
+	 * zero just the (not) deleted bit.
+	 */
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+	if (etags->is_deleted) {
+		memset(&pt1, 0xff, 8);
+		/* clear delete status bit to indicate deleted */
+		pt1.deleted = 0;
+	}
+#else
+	((__u8 *)&pt1)[8] = 0xff;
+	if (etags->is_deleted) {
+		memset(&pt1, 0xff, 8);
+		/* zero page_status byte to indicate deleted */
+		((__u8 *)&pt1)[8] = 0;
+	}
+#endif
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OOB_AUTO;
+	ops.len = (data) ? chunkBytes : 0;
+	ops.ooblen = YTAG1_SIZE;
+	ops.datbuf = (__u8 *)data;
+	ops.oobbuf = (__u8 *)&pt1;
+
+	retval = mtd->write_oob(mtd, addr, &ops);
+	if (retval) {
+		T(YAFFS_TRACE_MTD,
+			(TSTR("write_oob failed, chunk %d, mtd error %d"TENDSTR),
+			nand_chunk, retval));
+	}
+	return retval ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Return with empty ExtendedTags but add ecc_result.
+ */
+static int rettags(yaffs_ext_tags *etags, int ecc_result, int retval)
+{
+	if (etags) {
+		memset(etags, 0, sizeof(*etags));
+		etags->ecc_result = ecc_result;
+	}
+	return retval;
+}
+
+/* Read a chunk (page) from NAND.
+ *
+ * Caller expects ExtendedTags data to be usable even on error; that is,
+ * all members except ecc_result and block_bad are zeroed.
+ *
+ *  - Check ECC results for data (if applicable)
+ *  - Check for blank/erased block (return empty ExtendedTags if blank)
+ *  - Check the PackedTags1 mini-ECC (correct if necessary/possible)
+ *  - Convert PackedTags1 to ExtendedTags
+ *  - Update ecc_result and block_bad members to refect state.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_dev_t *dev,
+	int nand_chunk, __u8 *data, yaffs_ext_tags *etags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunkBytes = dev->data_bytes_per_chunk;
+	loff_t addr = ((loff_t)nand_chunk) * chunkBytes;
+	int eccres = YAFFS_ECC_RESULT_NO_ERROR;
+	struct mtd_oob_ops ops;
+	yaffs_PackedTags1 pt1;
+	int retval;
+	int deleted;
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OOB_AUTO;
+	ops.len = (data) ? chunkBytes : 0;
+	ops.ooblen = YTAG1_SIZE;
+	ops.datbuf = data;
+	ops.oobbuf = (__u8 *)&pt1;
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
+	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
+	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
+	 */
+	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
+#endif
+	/* Read page and oob using MTD.
+	 * Check status and determine ECC result.
+	 */
+	retval = mtd->read_oob(mtd, addr, &ops);
+	if (retval) {
+		T(YAFFS_TRACE_MTD,
+			(TSTR("read_oob failed, chunk %d, mtd error %d"TENDSTR),
+			nand_chunk, retval));
+	}
+
+	switch (retval) {
+	case 0:
+		/* no error */
+		break;
+
+	case -EUCLEAN:
+		/* MTD's ECC fixed the data */
+		eccres = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+		break;
+
+	case -EBADMSG:
+		/* MTD's ECC could not fix the data */
+		dev->n_ecc_unfixed++;
+		/* fall into... */
+	default:
+		rettags(etags, YAFFS_ECC_RESULT_UNFIXED, 0);
+		etags->block_bad = (mtd->block_isbad)(mtd, addr);
+		return YAFFS_FAIL;
+	}
+
+	/* Check for a blank/erased chunk.
+	 */
+	if (yaffs_check_ff((__u8 *)&pt1, 8)) {
+		/* when blank, upper layers want ecc_result to be <= NO_ERROR */
+		return rettags(etags, YAFFS_ECC_RESULT_NO_ERROR, YAFFS_OK);
+	}
+
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+	/* Read deleted status (bit) then return it to it's non-deleted
+	 * state before performing tags mini-ECC check. pt1.deleted is
+	 * inverted.
+	 */
+	deleted = !pt1.deleted;
+	pt1.deleted = 1;
+#else
+	deleted = (yaffs_count_bits(((__u8 *)&pt1)[8]) < 7);
+#endif
+
+	/* Check the packed tags mini-ECC and correct if necessary/possible.
+	 */
+	retval = yaffs_check_tags_ecc((yaffs_tags_t *)&pt1);
+	switch (retval) {
+	case 0:
+		/* no tags error, use MTD result */
+		break;
+	case 1:
+		/* recovered tags-ECC error */
+		dev->n_tags_ecc_fixed++;
+		if (eccres == YAFFS_ECC_RESULT_NO_ERROR)
+			eccres = YAFFS_ECC_RESULT_FIXED;
+		break;
+	default:
+		/* unrecovered tags-ECC error */
+		dev->n_tags_ecc_unfixed++;
+		return rettags(etags, YAFFS_ECC_RESULT_UNFIXED, YAFFS_FAIL);
+	}
+
+	/* Unpack the tags to extended form and set ECC result.
+	 * [set shouldBeFF just to keep yaffs_unpack_tags1 happy]
+	 */
+	pt1.shouldBeFF = 0xFFFFFFFF;
+	yaffs_unpack_tags1(etags, &pt1);
+	etags->ecc_result = eccres;
+
+	/* Set deleted state */
+	etags->is_deleted = deleted;
+	return YAFFS_OK;
+}
+
+/* Mark a block bad.
+ *
+ * This is a persistant state.
+ * Use of this function should be rare.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_MarkNANDBlockBad(struct yaffs_dev_s *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
+	int retval;
+
+	T(YAFFS_TRACE_BAD_BLOCKS,(TSTR("marking block %d bad"TENDSTR), block_no));
+
+	retval = mtd->block_markbad(mtd, (loff_t)blocksize * block_no);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Check any MTD prerequists.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+static int nandmtd1_TestPrerequists(struct mtd_info *mtd)
+{
+	/* 2.6.18 has mtd->ecclayout->oobavail */
+	/* 2.6.21 has mtd->ecclayout->oobavail and mtd->oobavail */
+	int oobavail = mtd->ecclayout->oobavail;
+
+	if (oobavail < YTAG1_SIZE) {
+		T(YAFFS_TRACE_ERROR,
+			(TSTR("mtd device has only %d bytes for tags, need %d"TENDSTR),
+			oobavail, YTAG1_SIZE));
+		return YAFFS_FAIL;
+	}
+	return YAFFS_OK;
+}
+
+/* Query for the current state of a specific block.
+ *
+ * Examine the tags of the first chunk of the block and return the state:
+ *  - YAFFS_BLOCK_STATE_DEAD, the block is marked bad
+ *  - YAFFS_BLOCK_STATE_NEEDS_SCANNING, the block is in use
+ *  - YAFFS_BLOCK_STATE_EMPTY, the block is clean
+ *
+ * Always returns YAFFS_OK.
+ */
+int nandmtd1_QueryNANDBlock(struct yaffs_dev_s *dev, int block_no,
+	yaffs_block_state_t *pState, __u32 *pSequenceNumber)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunkNo = block_no * dev->param.chunks_per_block;
+	loff_t addr = (loff_t)chunkNo * dev->data_bytes_per_chunk;
+	yaffs_ext_tags etags;
+	int state = YAFFS_BLOCK_STATE_DEAD;
+	int seqnum = 0;
+	int retval;
+
+	/* We don't yet have a good place to test for MTD config prerequists.
+	 * Do it here as we are called during the initial scan.
+	 */
+	if (nandmtd1_TestPrerequists(mtd) != YAFFS_OK)
+		return YAFFS_FAIL;
+
+	retval = nandmtd1_ReadChunkWithTagsFromNAND(dev, chunkNo, NULL, &etags);
+	etags.block_bad = (mtd->block_isbad)(mtd, addr);
+	if (etags.block_bad) {
+		T(YAFFS_TRACE_BAD_BLOCKS,
+			(TSTR("block %d is marked bad"TENDSTR), block_no));
+		state = YAFFS_BLOCK_STATE_DEAD;
+	} else if (etags.ecc_result != YAFFS_ECC_RESULT_NO_ERROR) {
+		/* bad tags, need to look more closely */
+		state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+	} else if (etags.chunk_used) {
+		state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+		seqnum = etags.seq_number;
+	} else {
+		state = YAFFS_BLOCK_STATE_EMPTY;
+	}
+
+	*pState = state;
+	*pSequenceNumber = seqnum;
+
+	/* query always succeeds */
+	return YAFFS_OK;
+}
+
+#endif /*MTD_VERSION*/
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_mtdif1.h b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif1.h
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif1.h
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF1_H__
+#define __YAFFS_MTDIF1_H__
+
+int nandmtd1_WriteChunkWithTagsToNAND(yaffs_dev_t *dev, int nand_chunk,
+	const __u8 *data, const yaffs_ext_tags *tags);
+
+int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_dev_t *dev, int nand_chunk,
+	__u8 *data, yaffs_ext_tags *tags);
+
+int nandmtd1_MarkNANDBlockBad(struct yaffs_dev_s *dev, int block_no);
+
+int nandmtd1_QueryNANDBlock(struct yaffs_dev_s *dev, int block_no,
+	yaffs_block_state_t *state, __u32 *seq_number);
+
+#endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_mtdif2.c b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif2.c
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif2.c
@@ -0,0 +1,257 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* mtd interface for YAFFS2 */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+#include "yaffs_mtdif2.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+
+#include "yaffs_packedtags2.h"
+
+#include "yaffs_linux.h"
+
+/* NB For use with inband tags....
+ * We assume that the data buffer is of size totalBytersPerChunk so that we can also
+ * use it to load the tags.
+ */
+int nandmtd2_WriteChunkWithTagsToNAND(yaffs_dev_t *dev, int nand_chunk,
+				      const __u8 *data,
+				      const yaffs_ext_tags *tags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#else
+	size_t dummy;
+#endif
+	int retval = 0;
+
+	loff_t addr;
+
+	yaffs_PackedTags2 pt;
+
+	int packed_tags_size = dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void * packed_tags_ptr = dev->param.no_tags_ecc ? (void *) &pt.t : (void *)&pt;
+
+	T(YAFFS_TRACE_MTD,
+	  (TSTR
+	   ("nandmtd2_WriteChunkWithTagsToNAND chunk %d data %p tags %p"
+	    TENDSTR), nand_chunk, data, tags));
+
+
+	addr  = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+
+	/* For yaffs2 writing there must be both data and tags.
+	 * If we're using inband tags, then the tags are stuffed into
+	 * the end of the data buffer.
+	 */
+	if (!data || !tags)
+		BUG();
+	else if (dev->param.inband_tags) {
+		yaffs_PackedTags2TagsPart *pt2tp;
+		pt2tp = (yaffs_PackedTags2TagsPart *)(data + dev->data_bytes_per_chunk);
+		yaffs_PackTags2TagsPart(pt2tp, tags);
+	} else
+		yaffs_PackTags2(&pt, tags, !dev->param.no_tags_ecc);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	ops.mode = MTD_OOB_AUTO;
+	ops.ooblen = (dev->param.inband_tags) ? 0 : packed_tags_size;
+	ops.len = dev->param.total_bytes_per_chunk;
+	ops.ooboffs = 0;
+	ops.datbuf = (__u8 *)data;
+	ops.oobbuf = (dev->param.inband_tags) ? NULL : packed_tags_ptr;
+	retval = mtd->write_oob(mtd, addr, &ops);
+
+#else
+	if (!dev->param.inband_tags) {
+		retval =
+		    mtd->write_ecc(mtd, addr, dev->data_bytes_per_chunk,
+				   &dummy, data, (__u8 *) packed_tags_ptr, NULL);
+	} else {
+		retval =
+		    mtd->write(mtd, addr, dev->param.total_bytes_per_chunk, &dummy,
+			       data);
+	}
+#endif
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_dev_t *dev, int nand_chunk,
+				       __u8 *data, yaffs_ext_tags *tags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#endif
+	size_t dummy;
+	int retval = 0;
+	int localData = 0;
+
+	loff_t addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+
+	yaffs_PackedTags2 pt;
+
+	int packed_tags_size = dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void * packed_tags_ptr = dev->param.no_tags_ecc ? (void *) &pt.t: (void *)&pt;
+
+	T(YAFFS_TRACE_MTD,
+	  (TSTR
+	   ("nandmtd2_ReadChunkWithTagsFromNAND chunk %d data %p tags %p"
+	    TENDSTR), nand_chunk, data, tags));
+
+	if (dev->param.inband_tags) {
+
+		if (!data) {
+			localData = 1;
+			data = yaffs_get_temp_buffer(dev, __LINE__);
+		}
+
+
+	}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	if (dev->param.inband_tags || (data && !tags))
+		retval = mtd->read(mtd, addr, dev->param.total_bytes_per_chunk,
+				&dummy, data);
+	else if (tags) {
+		ops.mode = MTD_OOB_AUTO;
+		ops.ooblen = packed_tags_size;
+		ops.len = data ? dev->data_bytes_per_chunk : packed_tags_size;
+		ops.ooboffs = 0;
+		ops.datbuf = data;
+		ops.oobbuf = yaffs_dev_to_lc(dev)->spareBuffer;
+		retval = mtd->read_oob(mtd, addr, &ops);
+	}
+#else
+	if (!dev->param.inband_tags && data && tags) {
+
+		retval = mtd->read_ecc(mtd, addr, dev->data_bytes_per_chunk,
+					  &dummy, data, dev->spareBuffer,
+					  NULL);
+	} else {
+		if (data)
+			retval =
+			    mtd->read(mtd, addr, dev->data_bytes_per_chunk, &dummy,
+				      data);
+		if (!dev->param.inband_tags && tags)
+			retval =
+			    mtd->read_oob(mtd, addr, mtd->oobsize, &dummy,
+					  dev->spareBuffer);
+	}
+#endif
+
+
+	if (dev->param.inband_tags) {
+		if (tags) {
+			yaffs_PackedTags2TagsPart *pt2tp;
+			pt2tp = (yaffs_PackedTags2TagsPart *)&data[dev->data_bytes_per_chunk];
+			yaffs_unpack_tags2tags_part(tags, pt2tp);
+		}
+	} else {
+		if (tags) {
+			memcpy(packed_tags_ptr, yaffs_dev_to_lc(dev)->spareBuffer, packed_tags_size);
+			yaffs_unpack_tags2(tags, &pt, !dev->param.no_tags_ecc);
+		}
+	}
+
+	if (localData)
+		yaffs_release_temp_buffer(dev, data, __LINE__);
+
+	if (tags && retval == -EBADMSG && tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+		dev->n_ecc_unfixed++;
+	}
+	if(tags && retval == -EUCLEAN && tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->ecc_result = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+	}
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_MarkNANDBlockBad(struct yaffs_dev_s *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int retval;
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("nandmtd2_MarkNANDBlockBad %d" TENDSTR), block_no));
+
+	retval =
+	    mtd->block_markbad(mtd,
+			       block_no * dev->param.chunks_per_block *
+			       dev->param.total_bytes_per_chunk);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+
+}
+
+int nandmtd2_QueryNANDBlock(struct yaffs_dev_s *dev, int block_no,
+			    yaffs_block_state_t *state, __u32 *seq_number)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int retval;
+
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("nandmtd2_QueryNANDBlock %d" TENDSTR), block_no));
+	retval =
+	    mtd->block_isbad(mtd,
+			     block_no * dev->param.chunks_per_block *
+			     dev->param.total_bytes_per_chunk);
+
+	if (retval) {
+		T(YAFFS_TRACE_MTD, (TSTR("block is bad" TENDSTR)));
+
+		*state = YAFFS_BLOCK_STATE_DEAD;
+		*seq_number = 0;
+	} else {
+		yaffs_ext_tags t;
+		nandmtd2_ReadChunkWithTagsFromNAND(dev,
+						   block_no *
+						   dev->param.chunks_per_block, NULL,
+						   &t);
+
+		if (t.chunk_used) {
+			*seq_number = t.seq_number;
+			*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+		} else {
+			*seq_number = 0;
+			*state = YAFFS_BLOCK_STATE_EMPTY;
+		}
+	}
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("block is bad seq %d state %d" TENDSTR), *seq_number,
+	   *state));
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_mtdif2.h b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif2.h
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_mtdif2.h
@@ -0,0 +1,29 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF2_H__
+#define __YAFFS_MTDIF2_H__
+
+#include "yaffs_guts.h"
+int nandmtd2_WriteChunkWithTagsToNAND(yaffs_dev_t *dev, int nand_chunk,
+				const __u8 *data,
+				const yaffs_ext_tags *tags);
+int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_dev_t *dev, int nand_chunk,
+				__u8 *data, yaffs_ext_tags *tags);
+int nandmtd2_MarkNANDBlockBad(struct yaffs_dev_s *dev, int block_no);
+int nandmtd2_QueryNANDBlock(struct yaffs_dev_s *dev, int block_no,
+			yaffs_block_state_t *state, __u32 *seq_number);
+
+#endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_nameval.c b/target/linux/generic/files/fs/yaffs2/yaffs_nameval.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_nameval.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_nameval.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -12,58 +12,58 @@
  */
 
 /*
- * This simple implementation of a name-value store assumes a small number of
-* values and fits into a small finite buffer.
+ * This simple implementation of a name-value store assumes a small number of values and fits
+ * into a small finite buffer.
  *
  * Each attribute is stored as a record:
  *  sizeof(int) bytes   record size.
  *  strnlen+1 bytes name null terminated.
  *  nbytes    value.
  *  ----------
- *  total size  stored in record size
+ *  total size  stored in record size 
  *
  * This code has not been tested with unicode yet.
  */
 
+
 #include "yaffs_nameval.h"
 
 #include "yportenv.h"
-
+ 
 static int nval_find(const char *xb, int xb_size, const YCHAR *name,
-		     int *exist_size)
+		int *exist_size)
 {
-	int pos = 0;
+	int pos=0;
 	int size;
 
-	memcpy(&size, xb, sizeof(int));
-	while (size > 0 && (size < xb_size) && (pos + size < xb_size)) {
-		if (!strncmp((YCHAR *) (xb + pos + sizeof(int)),
-				name, size)) {
-			if (exist_size)
+	memcpy(&size,xb,sizeof(int));
+	while(size > 0 && (size < xb_size) && (pos + size < xb_size)){
+		if(yaffs_strncmp((YCHAR *)(xb+pos+sizeof(int)),name,size) == 0){
+			if(exist_size)
 				*exist_size = size;
 			return pos;
 		}
 		pos += size;
-		if (pos < xb_size - sizeof(int))
-			memcpy(&size, xb + pos, sizeof(int));
+		if(pos < xb_size -sizeof(int))
+			memcpy(&size,xb + pos,sizeof(int));
 		else
 			size = 0;
 	}
-	if (exist_size)
+	if(exist_size)
 		*exist_size = 0;
-	return -ENODATA;
+	return -1;
 }
 
 static int nval_used(const char *xb, int xb_size)
 {
-	int pos = 0;
+	int pos=0;
 	int size;
 
-	memcpy(&size, xb + pos, sizeof(int));
-	while (size > 0 && (size < xb_size) && (pos + size < xb_size)) {
+	memcpy(&size,xb + pos,sizeof(int));
+	while(size > 0 && (size < xb_size) && (pos + size < xb_size)){
 		pos += size;
-		if (pos < xb_size - sizeof(int))
-			memcpy(&size, xb + pos, sizeof(int));
+		if(pos < xb_size -sizeof(int))
+			memcpy(&size,xb + pos,sizeof(int));
 		else
 			size = 0;
 	}
@@ -72,74 +72,71 @@ static int nval_used(const char *xb, int
 
 int nval_del(char *xb, int xb_size, const YCHAR *name)
 {
-	int pos = nval_find(xb, xb_size, name, NULL);
+	int pos  = nval_find(xb, xb_size, name, NULL);
 	int size;
-
-	if (pos < 0 || pos >= xb_size)
+	
+	if(pos >= 0 && pos < xb_size){
+		/* Find size, shift rest over this record, then zero out the rest of buffer */
+		memcpy(&size,xb+pos,sizeof(int));
+		memcpy(xb + pos, xb + pos + size, xb_size - (pos + size));
+		memset(xb + (xb_size - size),0,size);
+		return 0;
+	} else
 		return -ENODATA;
-
-	/* Find size, shift rest over this record,
-	 * then zero out the rest of buffer */
-	memcpy(&size, xb + pos, sizeof(int));
-	memcpy(xb + pos, xb + pos + size, xb_size - (pos + size));
-	memset(xb + (xb_size - size), 0, size);
-	return 0;
 }
 
-int nval_set(char *xb, int xb_size, const YCHAR *name, const char *buf,
-		int bsize, int flags)
+int nval_set(char *xb, int xb_size, const YCHAR *name, const char *buf, int bsize, int flags)
 {
 	int pos;
-	int namelen = strnlen(name, xb_size);
+	int namelen = yaffs_strnlen(name,xb_size);
 	int reclen;
 	int size_exist = 0;
 	int space;
 	int start;
 
-	pos = nval_find(xb, xb_size, name, &size_exist);
+	pos = nval_find(xb,xb_size,name, &size_exist);
 
-	if (flags & XATTR_CREATE && pos >= 0)
+	if(flags & XATTR_CREATE && pos >= 0)
 		return -EEXIST;
-	if (flags & XATTR_REPLACE && pos < 0)
+	if(flags & XATTR_REPLACE && pos < 0)
 		return -ENODATA;
 
-	start = nval_used(xb, xb_size);
+	start = nval_used(xb,xb_size);
 	space = xb_size - start + size_exist;
 
 	reclen = (sizeof(int) + namelen + 1 + bsize);
 
-	if (reclen > space)
+	if(reclen > space)
 		return -ENOSPC;
 
-	if (pos >= 0) {
-		nval_del(xb, xb_size, name);
+	if(pos >= 0){
+		nval_del(xb,xb_size,name);
 		start = nval_used(xb, xb_size);
 	}
 
 	pos = start;
 
-	memcpy(xb + pos, &reclen, sizeof(int));
-	pos += sizeof(int);
-	strncpy((YCHAR *) (xb + pos), name, reclen);
-	pos += (namelen + 1);
-	memcpy(xb + pos, buf, bsize);
+	memcpy(xb + pos,&reclen,sizeof(int));
+	pos +=sizeof(int);
+	yaffs_strncpy((YCHAR *)(xb + pos), name, reclen);
+	pos+= (namelen+1);
+	memcpy(xb + pos,buf,bsize);
 	return 0;
 }
 
-int nval_get(const char *xb, int xb_size, const YCHAR * name, char *buf,
-	     int bsize)
+int nval_get(const char *xb, int xb_size, const YCHAR *name, char *buf, int bsize)
 {
-	int pos = nval_find(xb, xb_size, name, NULL);
+	int pos = nval_find(xb,xb_size,name,NULL);
 	int size;
-
-	if (pos >= 0 && pos < xb_size) {
-
-		memcpy(&size, xb + pos, sizeof(int));
-		pos += sizeof(int);	/* advance past record length */
+	
+	if(pos >= 0 && pos< xb_size){
+		
+		memcpy(&size,xb +pos,sizeof(int));
+		pos+=sizeof(int); /* advance past record length */
 		size -= sizeof(int);
 
 		/* Advance over name string */
-		while (xb[pos] && size > 0 && pos < xb_size) {
+		while(xb[pos] && size > 0 && pos < xb_size){
 			pos++;
 			size--;
 		}
@@ -147,21 +144,16 @@ int nval_get(const char *xb, int xb_size
 		pos++;
 		size--;
 
-		/* If bsize is zero then this is a size query.
-		 * Return the size, but don't copy.
-		 */
-		if (!bsize)
-			return size;
-
-		if (size <= bsize) {
-			memcpy(buf, xb + pos, size);
+		if(size <= bsize){
+			memcpy(buf,xb + pos,size);
 			return size;
 		}
+		
 	}
-	if (pos >= 0)
+	if(pos >= 0)
 		return -ERANGE;
-
-	return -ENODATA;
+	else
+		return -ENODATA;
 }
 
 int nval_list(const char *xb, int xb_size, char *buf, int bsize)
@@ -172,36 +164,33 @@ int nval_list(const char *xb, int xb_siz
 	int ncopied = 0;
 	int filled = 0;
 
-	memcpy(&size, xb + pos, sizeof(int));
-	while (size > sizeof(int) &&
-		size <= xb_size &&
-		(pos + size) < xb_size &&
-		!filled) {
-		pos += sizeof(int);
-		size -= sizeof(int);
-		name_len = strnlen((YCHAR *) (xb + pos), size);
-		if (ncopied + name_len + 1 < bsize) {
-			memcpy(buf, xb + pos, name_len * sizeof(YCHAR));
-			buf += name_len;
+	memcpy(&size,xb + pos,sizeof(int));
+	while(size > sizeof(int) && size <= xb_size && (pos + size) < xb_size && !filled){
+		pos+= sizeof(int);
+		size-=sizeof(int);
+		name_len = yaffs_strnlen((YCHAR *)(xb + pos), size);
+		if(ncopied + name_len + 1 < bsize){
+			memcpy(buf,xb+pos,name_len * sizeof(YCHAR));
+			buf+= name_len;
 			*buf = '\0';
 			buf++;
-			if (sizeof(YCHAR) > 1) {
+			if(sizeof(YCHAR) > 1){
 				*buf = '\0';
 				buf++;
 			}
-			ncopied += (name_len + 1);
-		} else {
+			ncopied += (name_len+1);
+		} else
 			filled = 1;
-		}
-		pos += size;
-		if (pos < xb_size - sizeof(int))
-			memcpy(&size, xb + pos, sizeof(int));
+		pos+=size;
+		if(pos < xb_size -sizeof(int))
+			memcpy(&size,xb + pos,sizeof(int));
 		else
 			size = 0;
 	}
 	return ncopied;
 }
 
+
 int nval_hasvalues(const char *xb, int xb_size)
 {
 	return nval_used(xb, xb_size) > 0;
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_nameval.h b/target/linux/generic/files/fs/yaffs2/yaffs_nameval.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_nameval.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_nameval.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -12,17 +12,14 @@
  *
  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
  */
-
 #ifndef __NAMEVAL_H__
 #define __NAMEVAL_H__
 
 #include "yportenv.h"
 
-int nval_del(char *xb, int xb_size, const YCHAR * name);
-int nval_set(char *xb, int xb_size, const YCHAR * name, const char *buf,
-	     int bsize, int flags);
-int nval_get(const char *xb, int xb_size, const YCHAR * name, char *buf,
-	     int bsize);
+int nval_del(char *xb, int xb_size, const YCHAR *name);
+int nval_set(char *xb, int xb_size, const YCHAR *name, const char *buf, int bsize, int flags);
+int nval_get(const char *xb, int xb_size, const YCHAR *name, char *buf, int bsize);
 int nval_list(const char *xb, int xb_size, char *buf, int bsize);
 int nval_hasvalues(const char *xb, int xb_size);
 #endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_nand.c b/target/linux/generic/files/fs/yaffs2/yaffs_nand.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_nand.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_nand.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -13,110 +13,128 @@
 
 #include "yaffs_nand.h"
 #include "yaffs_tagscompat.h"
+#include "yaffs_tagsvalidity.h"
 
 #include "yaffs_getblockinfo.h"
-#include "yaffs_summary.h"
 
-static int apply_chunk_offset(struct yaffs_dev *dev, int chunk)
-{
-	return chunk - dev->chunk_offset;
-}
-
-int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
-			     u8 *buffer, struct yaffs_ext_tags *tags)
+int yaffs_rd_chunk_tags_nand(yaffs_dev_t *dev, int nand_chunk,
+					   __u8 *buffer,
+					   yaffs_ext_tags *tags)
 {
 	int result;
-	struct yaffs_ext_tags local_tags;
-	int flash_chunk = apply_chunk_offset(dev, nand_chunk);
+	yaffs_ext_tags localTags;
+
+	int realignedChunkInNAND = nand_chunk - dev->chunk_offset;
 
 	dev->n_page_reads++;
 
-	/* If there are no tags provided use local tags. */
+	/* If there are no tags provided, use local tags to get prioritised gc working */
 	if (!tags)
-		tags = &local_tags;
+		tags = &localTags;
 
-	result = dev->tagger.read_chunk_tags_fn(dev, flash_chunk, buffer, tags);
-	if (tags && tags->ecc_result > YAFFS_ECC_RESULT_NO_ERROR) {
+	if (dev->param.read_chunk_tags_fn)
+		result = dev->param.read_chunk_tags_fn(dev, realignedChunkInNAND, buffer,
+						      tags);
+	else
+		result = yaffs_tags_compat_rd(dev,
+									realignedChunkInNAND,
+									buffer,
+									tags);
+	if (tags &&
+	   tags->ecc_result > YAFFS_ECC_RESULT_NO_ERROR) {
 
-		struct yaffs_block_info *bi;
-		bi = yaffs_get_block_info(dev,
-					  nand_chunk /
-					  dev->param.chunks_per_block);
+		yaffs_block_info_t *bi;
+		bi = yaffs_get_block_info(dev, nand_chunk/dev->param.chunks_per_block);
 		yaffs_handle_chunk_error(dev, bi);
 	}
-	return result;
-}
-
-int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
-				int nand_chunk,
-				const u8 *buffer, struct yaffs_ext_tags *tags)
-{
-	int result;
-	int flash_chunk = apply_chunk_offset(dev, nand_chunk);
-
-	dev->n_page_writes++;
-
-	if (!tags) {
-		yaffs_trace(YAFFS_TRACE_ERROR, "Writing with no tags");
-		BUG();
-		return YAFFS_FAIL;
-	}
-
-	tags->seq_number = dev->seq_number;
-	tags->chunk_used = 1;
-	yaffs_trace(YAFFS_TRACE_WRITE,
-		"Writing chunk %d tags %d %d",
-		nand_chunk, tags->obj_id, tags->chunk_id);
-
-	result = dev->tagger.write_chunk_tags_fn(dev, flash_chunk,
-							buffer, tags);
-
-	yaffs_summary_add(dev, tags, nand_chunk);
 
 	return result;
 }
 
-int yaffs_mark_bad(struct yaffs_dev *dev, int block_no)
+int yaffs_wr_chunk_tags_nand(yaffs_dev_t *dev,
+						   int nand_chunk,
+						   const __u8 *buffer,
+						   yaffs_ext_tags *tags)
+{
+
+	dev->n_page_writes++;
+
+	nand_chunk -= dev->chunk_offset;
+
+
+	if (tags) {
+		tags->seq_number = dev->seq_number;
+		tags->chunk_used = 1;
+		if (!yaffs_validate_tags(tags)) {
+			T(YAFFS_TRACE_ERROR,
+			  (TSTR("Writing uninitialised tags" TENDSTR)));
+			YBUG();
+		}
+		T(YAFFS_TRACE_WRITE,
+		  (TSTR("Writing chunk %d tags %d %d" TENDSTR), nand_chunk,
+		   tags->obj_id, tags->chunk_id));
+	} else {
+		T(YAFFS_TRACE_ERROR, (TSTR("Writing with no tags" TENDSTR)));
+		YBUG();
+	}
+
+	if (dev->param.write_chunk_tags_fn)
+		return dev->param.write_chunk_tags_fn(dev, nand_chunk, buffer,
+						     tags);
+	else
+		return yaffs_tags_compat_wr(dev,
+								       nand_chunk,
+								       buffer,
+								       tags);
+}
+
+int yaffs_mark_bad(yaffs_dev_t *dev, int block_no)
 {
 	block_no -= dev->block_offset;
-	dev->n_bad_markings++;
 
-	if (dev->param.disable_bad_block_marking)
-		return YAFFS_OK;
 
-	return dev->tagger.mark_bad_fn(dev, block_no);
+	if (dev->param.bad_block_fn)
+		return dev->param.bad_block_fn(dev, block_no);
+	else
+		return yaffs_tags_compat_mark_bad(dev, block_no);
 }
 
-
-int yaffs_query_init_block_state(struct yaffs_dev *dev,
-				 int block_no,
-				 enum yaffs_block_state *state,
-				 u32 *seq_number)
+int yaffs_query_init_block_state(yaffs_dev_t *dev,
+						 int block_no,
+						 yaffs_block_state_t *state,
+						 __u32 *seq_number)
 {
 	block_no -= dev->block_offset;
-	return dev->tagger.query_block_fn(dev, block_no, state, seq_number);
+
+	if (dev->param.query_block_fn)
+		return dev->param.query_block_fn(dev, block_no, state, seq_number);
+	else
+		return yaffs_tags_compat_query_block(dev, block_no,
+							     state,
+							     seq_number);
 }
 
-int yaffs_erase_block(struct yaffs_dev *dev, int block_no)
+
+int yaffs_erase_block(struct yaffs_dev_s *dev,
+				  int flash_block)
 {
 	int result;
 
-	block_no -= dev->block_offset;
+	flash_block -= dev->block_offset;
+
 	dev->n_erasures++;
-	result = dev->drv.drv_erase_fn(dev, block_no);
+
+	result = dev->param.erase_fn(dev, flash_block);
+
 	return result;
 }
 
-int yaffs_init_nand(struct yaffs_dev *dev)
+int yaffs_init_nand(struct yaffs_dev_s *dev)
 {
-	if (dev->drv.drv_initialise_fn)
-		return dev->drv.drv_initialise_fn(dev);
+	if(dev->param.initialise_flash_fn)
+		return dev->param.initialise_flash_fn(dev);
 	return YAFFS_OK;
 }
 
-int yaffs_deinit_nand(struct yaffs_dev *dev)
-{
-	if (dev->drv.drv_deinitialise_fn)
-		return dev->drv.drv_deinitialise_fn(dev);
-	return YAFFS_OK;
-}
+
+
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_nand.h b/target/linux/generic/files/fs/yaffs2/yaffs_nand.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_nand.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_nand.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -17,23 +17,28 @@
 #define __YAFFS_NAND_H__
 #include "yaffs_guts.h"
 
-int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
-			     u8 *buffer, struct yaffs_ext_tags *tags);
 
-int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
-			     int nand_chunk,
-			     const u8 *buffer, struct yaffs_ext_tags *tags);
 
-int yaffs_mark_bad(struct yaffs_dev *dev, int block_no);
+int yaffs_rd_chunk_tags_nand(yaffs_dev_t *dev, int nand_chunk,
+					__u8 *buffer,
+					yaffs_ext_tags *tags);
 
-int yaffs_query_init_block_state(struct yaffs_dev *dev,
-				 int block_no,
-				 enum yaffs_block_state *state,
-				 unsigned *seq_number);
+int yaffs_wr_chunk_tags_nand(yaffs_dev_t *dev,
+						int nand_chunk,
+						const __u8 *buffer,
+						yaffs_ext_tags *tags);
 
-int yaffs_erase_block(struct yaffs_dev *dev, int flash_block);
+int yaffs_mark_bad(yaffs_dev_t *dev, int block_no);
 
-int yaffs_init_nand(struct yaffs_dev *dev);
-int yaffs_deinit_nand(struct yaffs_dev *dev);
+int yaffs_query_init_block_state(yaffs_dev_t *dev,
+						int block_no,
+						yaffs_block_state_t *state,
+						unsigned *seq_number);
+
+int yaffs_erase_block(struct yaffs_dev_s *dev,
+				  int flash_block);
+
+int yaffs_init_nand(struct yaffs_dev_s *dev);
 
 #endif
+
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_nandemul2k.h b/target/linux/generic/files/fs/yaffs2/yaffs_nandemul2k.h
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_nandemul2k.h
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* Interface to emulated NAND functions (2k page size) */
+
+#ifndef __YAFFS_NANDEMUL2K_H__
+#define __YAFFS_NANDEMUL2K_H__
+
+#include "yaffs_guts.h"
+
+int nandemul2k_WriteChunkWithTagsToNAND(struct yaffs_dev_s *dev,
+					int nand_chunk, const __u8 *data,
+					const yaffs_ext_tags *tags);
+int nandemul2k_ReadChunkWithTagsFromNAND(struct yaffs_dev_s *dev,
+					 int nand_chunk, __u8 *data,
+					 yaffs_ext_tags *tags);
+int nandemul2k_MarkNANDBlockBad(struct yaffs_dev_s *dev, int block_no);
+int nandemul2k_QueryNANDBlock(struct yaffs_dev_s *dev, int block_no,
+			      yaffs_block_state_t *state, __u32 *seq_number);
+int nandemul2k_EraseBlockInNAND(struct yaffs_dev_s *dev,
+				int flash_block);
+int nandemul2k_InitialiseNAND(struct yaffs_dev_s *dev);
+int nandemul2k_GetBytesPerChunk(void);
+int nandemul2k_GetChunksPerBlock(void);
+int nandemul2k_GetNumberOfBlocks(void);
+
+#endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_packedtags1.c b/target/linux/generic/files/fs/yaffs2/yaffs_packedtags1.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_packedtags1.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_packedtags1.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -14,16 +14,7 @@
 #include "yaffs_packedtags1.h"
 #include "yportenv.h"
 
-static const u8 all_ff[20] = {
-	0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff
-};
-
-void yaffs_pack_tags1(struct yaffs_packed_tags1 *pt,
-		      const struct yaffs_ext_tags *t)
+void yaffs_PackTags1(yaffs_PackedTags1 *pt, const yaffs_ext_tags *t)
 {
 	pt->chunk_id = t->chunk_id;
 	pt->serial_number = t->serial_number;
@@ -31,17 +22,20 @@ void yaffs_pack_tags1(struct yaffs_packe
 	pt->obj_id = t->obj_id;
 	pt->ecc = 0;
 	pt->deleted = (t->is_deleted) ? 0 : 1;
-	pt->unused_stuff = 0;
-	pt->should_be_ff = 0xffffffff;
+	pt->unusedStuff = 0;
+	pt->shouldBeFF = 0xFFFFFFFF;
+
 }
 
-void yaffs_unpack_tags1(struct yaffs_ext_tags *t,
-			const struct yaffs_packed_tags1 *pt)
+void yaffs_unpack_tags1(yaffs_ext_tags *t, const yaffs_PackedTags1 *pt)
 {
+	static const __u8 allFF[] =
+	    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff };
 
-	if (memcmp(all_ff, pt, sizeof(struct yaffs_packed_tags1))) {
+	if (memcmp(allFF, pt, sizeof(yaffs_PackedTags1))) {
 		t->block_bad = 0;
-		if (pt->should_be_ff != 0xffffffff)
+		if (pt->shouldBeFF != 0xFFFFFFFF)
 			t->block_bad = 1;
 		t->chunk_used = 1;
 		t->obj_id = pt->obj_id;
@@ -51,6 +45,6 @@ void yaffs_unpack_tags1(struct yaffs_ext
 		t->is_deleted = (pt->deleted) ? 0 : 1;
 		t->serial_number = pt->serial_number;
 	} else {
-		memset(t, 0, sizeof(struct yaffs_ext_tags));
+		memset(t, 0, sizeof(yaffs_ext_tags));
 	}
 }
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_packedtags1.h b/target/linux/generic/files/fs/yaffs2/yaffs_packedtags1.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_packedtags1.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_packedtags1.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -20,20 +20,18 @@
 
 #include "yaffs_guts.h"
 
-struct yaffs_packed_tags1 {
-	u32 chunk_id:20;
-	u32 serial_number:2;
-	u32 n_bytes:10;
-	u32 obj_id:18;
-	u32 ecc:12;
-	u32 deleted:1;
-	u32 unused_stuff:1;
-	unsigned should_be_ff;
+typedef struct {
+	unsigned chunk_id:20;
+	unsigned serial_number:2;
+	unsigned n_bytes:10;
+	unsigned obj_id:18;
+	unsigned ecc:12;
+	unsigned deleted:1;
+	unsigned unusedStuff:1;
+	unsigned shouldBeFF;
 
-};
+} yaffs_PackedTags1;
 
-void yaffs_pack_tags1(struct yaffs_packed_tags1 *pt,
-		      const struct yaffs_ext_tags *t);
-void yaffs_unpack_tags1(struct yaffs_ext_tags *t,
-			const struct yaffs_packed_tags1 *pt);
+void yaffs_PackTags1(yaffs_PackedTags1 *pt, const yaffs_ext_tags *t);
+void yaffs_unpack_tags1(yaffs_ext_tags *t, const yaffs_PackedTags1 *pt);
 #endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_packedtags2.c b/target/linux/generic/files/fs/yaffs2/yaffs_packedtags2.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_packedtags2.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_packedtags2.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -14,6 +14,7 @@
 #include "yaffs_packedtags2.h"
 #include "yportenv.h"
 #include "yaffs_trace.h"
+#include "yaffs_tagsvalidity.h"
 
 /* This code packs a set of extended tags into a binary structure for
  * NAND storage
@@ -31,167 +32,167 @@
 #define EXTRA_SHADOWS_FLAG	0x20000000
 #define EXTRA_SPARE_FLAGS	0x10000000
 
-#define ALL_EXTRA_FLAGS		0xf0000000
+#define ALL_EXTRA_FLAGS		0xF0000000
 
 /* Also, the top 4 bits of the object Id are set to the object type. */
 #define EXTRA_OBJECT_TYPE_SHIFT (28)
-#define EXTRA_OBJECT_TYPE_MASK  ((0x0f) << EXTRA_OBJECT_TYPE_SHIFT)
+#define EXTRA_OBJECT_TYPE_MASK  ((0x0F) << EXTRA_OBJECT_TYPE_SHIFT)
 
-static void yaffs_dump_packed_tags2_tags_only(
-				const struct yaffs_packed_tags2_tags_only *ptt)
+
+static void yaffs_DumpPackedTags2TagsPart(const yaffs_PackedTags2TagsPart *ptt)
 {
-	yaffs_trace(YAFFS_TRACE_MTD,
-		"packed tags obj %d chunk %d byte %d seq %d",
-		ptt->obj_id, ptt->chunk_id, ptt->n_bytes, ptt->seq_number);
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("packed tags obj %d chunk %d byte %d seq %d" TENDSTR),
+	   ptt->obj_id, ptt->chunk_id, ptt->n_bytes,
+	   ptt->seq_number));
+}
+static void yaffs_DumpPackedTags2(const yaffs_PackedTags2 *pt)
+{
+	yaffs_DumpPackedTags2TagsPart(&pt->t);
 }
 
-static void yaffs_dump_packed_tags2(const struct yaffs_packed_tags2 *pt)
+static void yaffs_DumpTags2(const yaffs_ext_tags *t)
 {
-	yaffs_dump_packed_tags2_tags_only(&pt->t);
-}
-
-static void yaffs_dump_tags2(const struct yaffs_ext_tags *t)
-{
-	yaffs_trace(YAFFS_TRACE_MTD,
-		"ext.tags eccres %d blkbad %d chused %d obj %d chunk%d byte %d del %d ser %d seq %d",
-		t->ecc_result, t->block_bad, t->chunk_used, t->obj_id,
-		t->chunk_id, t->n_bytes, t->is_deleted, t->serial_number,
-		t->seq_number);
+	T(YAFFS_TRACE_MTD,
+	  (TSTR
+	   ("ext.tags eccres %d blkbad %d chused %d obj %d chunk%d byte %d del %d ser %d seq %d"
+	    TENDSTR), t->ecc_result, t->block_bad, t->chunk_used, t->obj_id,
+	   t->chunk_id, t->n_bytes, t->is_deleted, t->serial_number,
+	   t->seq_number));
 
 }
 
-static int yaffs_check_tags_extra_packable(const struct yaffs_ext_tags *t)
-{
-	if (t->chunk_id != 0 || !t->extra_available)
-		return 0;
-
-	/* Check if the file size is too long to store */
-	if (t->extra_obj_type == YAFFS_OBJECT_TYPE_FILE &&
-	    (t->extra_file_size >> 31) != 0)
-		return 0;
-	return 1;
-}
-
-void yaffs_pack_tags2_tags_only(struct yaffs_packed_tags2_tags_only *ptt,
-				const struct yaffs_ext_tags *t)
+void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart *ptt,
+		const yaffs_ext_tags *t)
 {
 	ptt->chunk_id = t->chunk_id;
 	ptt->seq_number = t->seq_number;
 	ptt->n_bytes = t->n_bytes;
 	ptt->obj_id = t->obj_id;
 
-	/* Only store extra tags for object headers.
-	 * If it is a file then only store  if the file size is short\
-	 * enough to fit.
-	 */
-	if (yaffs_check_tags_extra_packable(t)) {
+	if (t->chunk_id == 0 && t->extra_available) {
 		/* Store the extra header info instead */
 		/* We save the parent object in the chunk_id */
-		ptt->chunk_id = EXTRA_HEADER_INFO_FLAG | t->extra_parent_id;
+		ptt->chunk_id = EXTRA_HEADER_INFO_FLAG
+			| t->extra_parent_id;
 		if (t->extra_is_shrink)
 			ptt->chunk_id |= EXTRA_SHRINK_FLAG;
 		if (t->extra_shadows)
 			ptt->chunk_id |= EXTRA_SHADOWS_FLAG;
 
 		ptt->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
-		ptt->obj_id |= (t->extra_obj_type << EXTRA_OBJECT_TYPE_SHIFT);
+		ptt->obj_id |=
+		    (t->extra_obj_type << EXTRA_OBJECT_TYPE_SHIFT);
 
 		if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
 			ptt->n_bytes = t->extra_equiv_id;
 		else if (t->extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
-			ptt->n_bytes = (unsigned) t->extra_file_size;
+			ptt->n_bytes = t->extra_length;
 		else
 			ptt->n_bytes = 0;
 	}
 
-	yaffs_dump_packed_tags2_tags_only(ptt);
-	yaffs_dump_tags2(t);
+	yaffs_DumpPackedTags2TagsPart(ptt);
+	yaffs_DumpTags2(t);
 }
 
-void yaffs_pack_tags2(struct yaffs_packed_tags2 *pt,
-		      const struct yaffs_ext_tags *t, int tags_ecc)
+
+void yaffs_PackTags2(yaffs_PackedTags2 *pt, const yaffs_ext_tags *t, int tagsECC)
 {
-	yaffs_pack_tags2_tags_only(&pt->t, t);
+	yaffs_PackTags2TagsPart(&pt->t, t);
 
-	if (tags_ecc)
+	if(tagsECC)
 		yaffs_ecc_calc_other((unsigned char *)&pt->t,
-				    sizeof(struct yaffs_packed_tags2_tags_only),
-				    &pt->ecc);
+					sizeof(yaffs_PackedTags2TagsPart),
+					&pt->ecc);
 }
 
-void yaffs_unpack_tags2_tags_only(struct yaffs_ext_tags *t,
-				  struct yaffs_packed_tags2_tags_only *ptt)
+
+void yaffs_unpack_tags2tags_part(yaffs_ext_tags *t,
+		yaffs_PackedTags2TagsPart *ptt)
 {
-	memset(t, 0, sizeof(struct yaffs_ext_tags));
 
-	if (ptt->seq_number == 0xffffffff)
-		return;
+	memset(t, 0, sizeof(yaffs_ext_tags));
 
-	t->block_bad = 0;
-	t->chunk_used = 1;
-	t->obj_id = ptt->obj_id;
-	t->chunk_id = ptt->chunk_id;
-	t->n_bytes = ptt->n_bytes;
-	t->is_deleted = 0;
-	t->serial_number = 0;
-	t->seq_number = ptt->seq_number;
+	yaffs_init_tags(t);
 
-	/* Do extra header info stuff */
-	if (ptt->chunk_id & EXTRA_HEADER_INFO_FLAG) {
-		t->chunk_id = 0;
-		t->n_bytes = 0;
+	if (ptt->seq_number != 0xFFFFFFFF) {
+		t->block_bad = 0;
+		t->chunk_used = 1;
+		t->obj_id = ptt->obj_id;
+		t->chunk_id = ptt->chunk_id;
+		t->n_bytes = ptt->n_bytes;
+		t->is_deleted = 0;
+		t->serial_number = 0;
+		t->seq_number = ptt->seq_number;
 
-		t->extra_available = 1;
-		t->extra_parent_id = ptt->chunk_id & (~(ALL_EXTRA_FLAGS));
-		t->extra_is_shrink = ptt->chunk_id & EXTRA_SHRINK_FLAG ? 1 : 0;
-		t->extra_shadows = ptt->chunk_id & EXTRA_SHADOWS_FLAG ? 1 : 0;
-		t->extra_obj_type = ptt->obj_id >> EXTRA_OBJECT_TYPE_SHIFT;
-		t->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
+		/* Do extra header info stuff */
 
-		if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
-			t->extra_equiv_id = ptt->n_bytes;
-		else
-			t->extra_file_size = ptt->n_bytes;
+		if (ptt->chunk_id & EXTRA_HEADER_INFO_FLAG) {
+			t->chunk_id = 0;
+			t->n_bytes = 0;
+
+			t->extra_available = 1;
+			t->extra_parent_id =
+			    ptt->chunk_id & (~(ALL_EXTRA_FLAGS));
+			t->extra_is_shrink =
+			    (ptt->chunk_id & EXTRA_SHRINK_FLAG) ? 1 : 0;
+			t->extra_shadows =
+			    (ptt->chunk_id & EXTRA_SHADOWS_FLAG) ? 1 : 0;
+			t->extra_obj_type =
+			    ptt->obj_id >> EXTRA_OBJECT_TYPE_SHIFT;
+			t->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
+
+			if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
+				t->extra_equiv_id = ptt->n_bytes;
+			else
+				t->extra_length = ptt->n_bytes;
+		}
 	}
-	yaffs_dump_packed_tags2_tags_only(ptt);
-	yaffs_dump_tags2(t);
+
+	yaffs_DumpPackedTags2TagsPart(ptt);
+	yaffs_DumpTags2(t);
+
 }
 
-void yaffs_unpack_tags2(struct yaffs_ext_tags *t, struct yaffs_packed_tags2 *pt,
-			int tags_ecc)
+
+void yaffs_unpack_tags2(yaffs_ext_tags *t, yaffs_PackedTags2 *pt, int tagsECC)
 {
-	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
 
-	if (pt->t.seq_number != 0xffffffff && tags_ecc) {
+	yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+
+	if (pt->t.seq_number != 0xFFFFFFFF &&
+	    tagsECC){
 		/* Chunk is in use and we need to do ECC */
-
-		struct yaffs_ecc_other ecc;
+		
+		yaffs_ECCOther ecc;
 		int result;
 		yaffs_ecc_calc_other((unsigned char *)&pt->t,
-				sizeof(struct yaffs_packed_tags2_tags_only),
-				&ecc);
-		result =
-		    yaffs_ecc_correct_other((unsigned char *)&pt->t,
-				sizeof(struct yaffs_packed_tags2_tags_only),
-				&pt->ecc, &ecc);
+					sizeof(yaffs_PackedTags2TagsPart),
+					&ecc);
+		result = yaffs_ecc_correct_other((unsigned char *)&pt->t,
+						sizeof(yaffs_PackedTags2TagsPart),
+						&pt->ecc, &ecc);
 		switch (result) {
-		case 0:
-			ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
-			break;
-		case 1:
-			ecc_result = YAFFS_ECC_RESULT_FIXED;
-			break;
-		case -1:
-			ecc_result = YAFFS_ECC_RESULT_UNFIXED;
-			break;
-		default:
-			ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
+			case 0:
+				ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+				break;
+			case 1:
+				ecc_result = YAFFS_ECC_RESULT_FIXED;
+				break;
+			case -1:
+				ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+				break;
+			default:
+				ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
 		}
 	}
-	yaffs_unpack_tags2_tags_only(t, &pt->t);
+
+	yaffs_unpack_tags2tags_part(t, &pt->t);
 
 	t->ecc_result = ecc_result;
 
-	yaffs_dump_packed_tags2(pt);
-	yaffs_dump_tags2(t);
+	yaffs_DumpPackedTags2(pt);
+	yaffs_DumpTags2(t);
 }
+
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_packedtags2.h b/target/linux/generic/files/fs/yaffs2/yaffs_packedtags2.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_packedtags2.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_packedtags2.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -21,27 +21,23 @@
 #include "yaffs_guts.h"
 #include "yaffs_ecc.h"
 
-struct yaffs_packed_tags2_tags_only {
+typedef struct {
 	unsigned seq_number;
 	unsigned obj_id;
 	unsigned chunk_id;
 	unsigned n_bytes;
-};
+} yaffs_PackedTags2TagsPart;
 
-struct yaffs_packed_tags2 {
-	struct yaffs_packed_tags2_tags_only t;
-	struct yaffs_ecc_other ecc;
-};
+typedef struct {
+	yaffs_PackedTags2TagsPart t;
+	yaffs_ECCOther ecc;
+} yaffs_PackedTags2;
 
 /* Full packed tags with ECC, used for oob tags */
-void yaffs_pack_tags2(struct yaffs_packed_tags2 *pt,
-		      const struct yaffs_ext_tags *t, int tags_ecc);
-void yaffs_unpack_tags2(struct yaffs_ext_tags *t, struct yaffs_packed_tags2 *pt,
-			int tags_ecc);
+void yaffs_PackTags2(yaffs_PackedTags2 *pt, const yaffs_ext_tags *t, int tagsECC);
+void yaffs_unpack_tags2(yaffs_ext_tags *t, yaffs_PackedTags2 *pt, int tagsECC);
 
 /* Only the tags part (no ECC for use with inband tags */
-void yaffs_pack_tags2_tags_only(struct yaffs_packed_tags2_tags_only *pt,
-				const struct yaffs_ext_tags *t);
-void yaffs_unpack_tags2_tags_only(struct yaffs_ext_tags *t,
-				  struct yaffs_packed_tags2_tags_only *pt);
+void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart *pt, const yaffs_ext_tags *t);
+void yaffs_unpack_tags2tags_part(yaffs_ext_tags *t, yaffs_PackedTags2TagsPart *pt);
 #endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_qsort.c b/target/linux/generic/files/fs/yaffs2/yaffs_qsort.c
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_qsort.c
@@ -0,0 +1,163 @@
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "yportenv.h"
+/* #include <linux/string.h> */
+
+/*
+ * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
+ */
+#define swapcode(TYPE, parmi, parmj, n) do { 		\
+	long i = (n) / sizeof (TYPE); 			\
+	register TYPE *pi = (TYPE *) (parmi); 		\
+	register TYPE *pj = (TYPE *) (parmj); 		\
+	do { 						\
+		register TYPE	t = *pi;		\
+		*pi++ = *pj;				\
+		*pj++ = t;				\
+	} while (--i > 0);				\
+} while (0)
+
+#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
+	es % sizeof(long) ? 2 : es == sizeof(long) ? 0 : 1;
+
+static __inline void
+swapfunc(char *a, char *b, int n, int swaptype)
+{
+	if (swaptype <= 1)
+		swapcode(long, a, b, n);
+	else
+		swapcode(char, a, b, n);
+}
+
+#define yswap(a, b) do {					\
+	if (swaptype == 0) {				\
+		long t = *(long *)(a);			\
+		*(long *)(a) = *(long *)(b);		\
+		*(long *)(b) = t;			\
+	} else						\
+		swapfunc(a, b, es, swaptype);		\
+} while (0)
+
+#define vecswap(a, b, n) 	if ((n) > 0) swapfunc(a, b, n, swaptype)
+
+static __inline char *
+med3(char *a, char *b, char *c, int (*cmp)(const void *, const void *))
+{
+	return cmp(a, b) < 0 ?
+		(cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a))
+		: (cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c));
+}
+
+#ifndef min
+#define min(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+void
+yaffs_qsort(void *aa, size_t n, size_t es,
+	int (*cmp)(const void *, const void *))
+{
+	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
+	int d, r, swaptype, swap_cnt;
+	register char *a = aa;
+
+loop:	SWAPINIT(a, es);
+	swap_cnt = 0;
+	if (n < 7) {
+		for (pm = (char *)a + es; pm < (char *) a + n * es; pm += es)
+			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
+			     pl -= es)
+				yswap(pl, pl - es);
+		return;
+	}
+	pm = (char *)a + (n / 2) * es;
+	if (n > 7) {
+		pl = (char *)a;
+		pn = (char *)a + (n - 1) * es;
+		if (n > 40) {
+			d = (n / 8) * es;
+			pl = med3(pl, pl + d, pl + 2 * d, cmp);
+			pm = med3(pm - d, pm, pm + d, cmp);
+			pn = med3(pn - 2 * d, pn - d, pn, cmp);
+		}
+		pm = med3(pl, pm, pn, cmp);
+	}
+	yswap(a, pm);
+	pa = pb = (char *)a + es;
+
+	pc = pd = (char *)a + (n - 1) * es;
+	for (;;) {
+		while (pb <= pc && (r = cmp(pb, a)) <= 0) {
+			if (r == 0) {
+				swap_cnt = 1;
+				yswap(pa, pb);
+				pa += es;
+			}
+			pb += es;
+		}
+		while (pb <= pc && (r = cmp(pc, a)) >= 0) {
+			if (r == 0) {
+				swap_cnt = 1;
+				yswap(pc, pd);
+				pd -= es;
+			}
+			pc -= es;
+		}
+		if (pb > pc)
+			break;
+		yswap(pb, pc);
+		swap_cnt = 1;
+		pb += es;
+		pc -= es;
+	}
+	if (swap_cnt == 0) {  /* Switch to insertion sort */
+		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
+			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
+			     pl -= es)
+				yswap(pl, pl - es);
+		return;
+	}
+
+	pn = (char *)a + n * es;
+	r = min(pa - (char *)a, pb - pa);
+	vecswap(a, pb - r, r);
+	r = min((long)(pd - pc), (long)(pn - pd - es));
+	vecswap(pb, pn - r, r);
+	r = pb - pa;
+	if (r > es)
+		yaffs_qsort(a, r / es, es, cmp);
+	r = pd - pc;
+	if (r > es) {
+		/* Iterate rather than recurse to save stack space */
+		a = pn - r;
+		n = r / es;
+		goto loop;
+	}
+/*		yaffs_qsort(pn - r, r / es, es, cmp);*/
+}
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_qsort.h b/target/linux/generic/files/fs/yaffs2/yaffs_qsort.h
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_qsort.h
@@ -0,0 +1,34 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+
+#ifndef __YAFFS_QSORT_H__
+#define __YAFFS_QSORT_H__
+
+#ifdef __KERNEL__
+#include <linux/sort.h>
+
+extern void yaffs_qsort(void *const base, size_t total_elems, size_t size,
+			int (*cmp)(const void *, const void *)){
+	sort(base, total_elems, size, cmp, NULL);
+}
+
+#else
+
+extern void yaffs_qsort(void *const base, size_t total_elems, size_t size,
+			int (*cmp)(const void *, const void *));
+
+#endif
+#endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_tagscompat.c b/target/linux/generic/files/fs/yaffs2/yaffs_tagscompat.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_tagscompat.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_tagscompat.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -17,16 +17,56 @@
 #include "yaffs_getblockinfo.h"
 #include "yaffs_trace.h"
 
-static void yaffs_handle_rd_data_error(struct yaffs_dev *dev, int nand_chunk);
+static void yaffs_handle_rd_data_error(yaffs_dev_t *dev, int nand_chunk);
+#ifdef NOTYET
+static void yaffs_check_written_block(yaffs_dev_t *dev, int nand_chunk);
+static void yaffs_handle_chunk_wr_ok(yaffs_dev_t *dev, int nand_chunk,
+				     const __u8 *data,
+				     const yaffs_spare *spare);
+static void yaffs_handle_chunk_update(yaffs_dev_t *dev, int nand_chunk,
+				    const yaffs_spare *spare);
+static void yaffs_handle_chunk_wr_error(yaffs_dev_t *dev, int nand_chunk);
+#endif
 
+static const char yaffs_count_bits_table[256] = {
+	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+};
+
+int yaffs_count_bits(__u8 x)
+{
+	int retVal;
+	retVal = yaffs_count_bits_table[x];
+	return retVal;
+}
 
 /********** Tags ECC calculations  *********/
 
+void yaffs_calc_ecc(const __u8 *data, yaffs_spare *spare)
+{
+	yaffs_ecc_cacl(data, spare->ecc1);
+	yaffs_ecc_cacl(&data[256], spare->ecc2);
+}
 
-void yaffs_calc_tags_ecc(struct yaffs_tags *tags)
+void yaffs_calc_tags_ecc(yaffs_tags_t *tags)
 {
 	/* Calculate an ecc */
-	unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
+
+	unsigned char *b = ((yaffs_tags_union_t *) tags)->as_bytes;
 	unsigned i, j;
 	unsigned ecc = 0;
 	unsigned bit = 0;
@@ -40,10 +80,12 @@ void yaffs_calc_tags_ecc(struct yaffs_ta
 				ecc ^= bit;
 		}
 	}
+
 	tags->ecc = ecc;
+
 }
 
-int yaffs_check_tags_ecc(struct yaffs_tags *tags)
+int yaffs_check_tags_ecc(yaffs_tags_t *tags)
 {
 	unsigned ecc = tags->ecc;
 
@@ -53,7 +95,7 @@ int yaffs_check_tags_ecc(struct yaffs_ta
 
 	if (ecc && ecc <= 64) {
 		/* TODO: Handle the failure better. Retire? */
-		unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
+		unsigned char *b = ((yaffs_tags_union_t *) tags)->as_bytes;
 
 		ecc--;
 
@@ -68,164 +110,233 @@ int yaffs_check_tags_ecc(struct yaffs_ta
 		/* TODO Need to do somethiong here */
 		return -1;	/* unrecovered error */
 	}
+
 	return 0;
 }
 
 /********** Tags **********/
 
-static void yaffs_load_tags_to_spare(struct yaffs_spare *spare_ptr,
-				     struct yaffs_tags *tags_ptr)
+static void yaffs_load_tags_to_spare(yaffs_spare *sparePtr,
+				yaffs_tags_t *tagsPtr)
 {
-	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
+	yaffs_tags_union_t *tu = (yaffs_tags_union_t *) tagsPtr;
 
-	yaffs_calc_tags_ecc(tags_ptr);
+	yaffs_calc_tags_ecc(tagsPtr);
 
-	spare_ptr->tb0 = tu->as_bytes[0];
-	spare_ptr->tb1 = tu->as_bytes[1];
-	spare_ptr->tb2 = tu->as_bytes[2];
-	spare_ptr->tb3 = tu->as_bytes[3];
-	spare_ptr->tb4 = tu->as_bytes[4];
-	spare_ptr->tb5 = tu->as_bytes[5];
-	spare_ptr->tb6 = tu->as_bytes[6];
-	spare_ptr->tb7 = tu->as_bytes[7];
+	sparePtr->tb0 = tu->as_bytes[0];
+	sparePtr->tb1 = tu->as_bytes[1];
+	sparePtr->tb2 = tu->as_bytes[2];
+	sparePtr->tb3 = tu->as_bytes[3];
+	sparePtr->tb4 = tu->as_bytes[4];
+	sparePtr->tb5 = tu->as_bytes[5];
+	sparePtr->tb6 = tu->as_bytes[6];
+	sparePtr->tb7 = tu->as_bytes[7];
 }
 
-static void yaffs_get_tags_from_spare(struct yaffs_dev *dev,
-				      struct yaffs_spare *spare_ptr,
-				      struct yaffs_tags *tags_ptr)
+static void yaffs_get_tags_from_spare(yaffs_dev_t *dev, yaffs_spare *sparePtr,
+				yaffs_tags_t *tagsPtr)
 {
-	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
+	yaffs_tags_union_t *tu = (yaffs_tags_union_t *) tagsPtr;
 	int result;
 
-	tu->as_bytes[0] = spare_ptr->tb0;
-	tu->as_bytes[1] = spare_ptr->tb1;
-	tu->as_bytes[2] = spare_ptr->tb2;
-	tu->as_bytes[3] = spare_ptr->tb3;
-	tu->as_bytes[4] = spare_ptr->tb4;
-	tu->as_bytes[5] = spare_ptr->tb5;
-	tu->as_bytes[6] = spare_ptr->tb6;
-	tu->as_bytes[7] = spare_ptr->tb7;
+	tu->as_bytes[0] = sparePtr->tb0;
+	tu->as_bytes[1] = sparePtr->tb1;
+	tu->as_bytes[2] = sparePtr->tb2;
+	tu->as_bytes[3] = sparePtr->tb3;
+	tu->as_bytes[4] = sparePtr->tb4;
+	tu->as_bytes[5] = sparePtr->tb5;
+	tu->as_bytes[6] = sparePtr->tb6;
+	tu->as_bytes[7] = sparePtr->tb7;
 
-	result = yaffs_check_tags_ecc(tags_ptr);
+	result = yaffs_check_tags_ecc(tagsPtr);
 	if (result > 0)
 		dev->n_tags_ecc_fixed++;
 	else if (result < 0)
 		dev->n_tags_ecc_unfixed++;
 }
 
-static void yaffs_spare_init(struct yaffs_spare *spare)
+static void yaffs_spare_init(yaffs_spare *spare)
 {
-	memset(spare, 0xff, sizeof(struct yaffs_spare));
+	memset(spare, 0xFF, sizeof(yaffs_spare));
 }
 
-static int yaffs_wr_nand(struct yaffs_dev *dev,
-			 int nand_chunk, const u8 *data,
-			 struct yaffs_spare *spare)
+static int yaffs_wr_nand(struct yaffs_dev_s *dev,
+				int nand_chunk, const __u8 *data,
+				yaffs_spare *spare)
 {
-	int data_size = dev->data_bytes_per_chunk;
+	if (nand_chunk < dev->param.start_block * dev->param.chunks_per_block) {
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR("**>> yaffs chunk %d is not valid" TENDSTR),
+		   nand_chunk));
+		return YAFFS_FAIL;
+	}
 
-	return dev->drv.drv_write_chunk_fn(dev, nand_chunk,
-				data, data_size,
-				(u8 *) spare, sizeof(*spare));
+	return dev->param.write_chunk_fn(dev, nand_chunk, data, spare);
 }
 
-static int yaffs_rd_chunk_nand(struct yaffs_dev *dev,
-			       int nand_chunk,
-			       u8 *data,
-			       struct yaffs_spare *spare,
-			       enum yaffs_ecc_result *ecc_result,
-			       int correct_errors)
+static int yaffs_rd_chunk_nand(struct yaffs_dev_s *dev,
+				   int nand_chunk,
+				   __u8 *data,
+				   yaffs_spare *spare,
+				   yaffs_ecc_result *ecc_result,
+				   int doErrorCorrection)
 {
-	int ret_val;
-	struct yaffs_spare local_spare;
-	int data_size;
-	int spare_size;
-	int ecc_result1, ecc_result2;
-	u8 calc_ecc[3];
+	int retVal;
+	yaffs_spare localSpare;
 
-	if (!spare) {
+	if (!spare && data) {
 		/* If we don't have a real spare, then we use a local one. */
 		/* Need this for the calculation of the ecc */
-		spare = &local_spare;
-	}
-	data_size = dev->data_bytes_per_chunk;
-	spare_size = sizeof(struct yaffs_spare);
-
-	if (dev->param.use_nand_ecc)
-		return dev->drv.drv_read_chunk_fn(dev, nand_chunk,
-						data, data_size,
-						(u8 *) spare, spare_size,
-						ecc_result);
-
-
-	/* Handle the ECC at this level. */
-
-	ret_val = dev->drv.drv_read_chunk_fn(dev, nand_chunk,
-						 data, data_size,
-						 (u8 *)spare, spare_size,
-						NULL);
-	if (!data || !correct_errors)
-		return ret_val;
-
-	/* Do ECC correction if needed. */
-	yaffs_ecc_calc(data, calc_ecc);
-	ecc_result1 = yaffs_ecc_correct(data, spare->ecc1, calc_ecc);
-	yaffs_ecc_calc(&data[256], calc_ecc);
-	ecc_result2 = yaffs_ecc_correct(&data[256], spare->ecc2, calc_ecc);
-
-	if (ecc_result1 > 0) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"**>>yaffs ecc error fix performed on chunk %d:0",
-			nand_chunk);
-		dev->n_ecc_fixed++;
-	} else if (ecc_result1 < 0) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"**>>yaffs ecc error unfixed on chunk %d:0",
-			nand_chunk);
-		dev->n_ecc_unfixed++;
+		spare = &localSpare;
 	}
 
-	if (ecc_result2 > 0) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"**>>yaffs ecc error fix performed on chunk %d:1",
-			nand_chunk);
-		dev->n_ecc_fixed++;
-	} else if (ecc_result2 < 0) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"**>>yaffs ecc error unfixed on chunk %d:1",
-			nand_chunk);
-		dev->n_ecc_unfixed++;
+	if (!dev->param.use_nand_ecc) {
+		retVal = dev->param.read_chunk_fn(dev, nand_chunk, data, spare);
+		if (data && doErrorCorrection) {
+			/* Do ECC correction */
+			/* Todo handle any errors */
+			int ecc_result1, ecc_result2;
+			__u8 calcEcc[3];
+
+			yaffs_ecc_cacl(data, calcEcc);
+			ecc_result1 =
+			    yaffs_ecc_correct(data, spare->ecc1, calcEcc);
+			yaffs_ecc_cacl(&data[256], calcEcc);
+			ecc_result2 =
+			    yaffs_ecc_correct(&data[256], spare->ecc2, calcEcc);
+
+			if (ecc_result1 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error fix performed on chunk %d:0"
+				    TENDSTR), nand_chunk));
+				dev->n_ecc_fixed++;
+			} else if (ecc_result1 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error unfixed on chunk %d:0"
+				    TENDSTR), nand_chunk));
+				dev->n_ecc_unfixed++;
+			}
+
+			if (ecc_result2 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error fix performed on chunk %d:1"
+				    TENDSTR), nand_chunk));
+				dev->n_ecc_fixed++;
+			} else if (ecc_result2 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error unfixed on chunk %d:1"
+				    TENDSTR), nand_chunk));
+				dev->n_ecc_unfixed++;
+			}
+
+			if (ecc_result1 || ecc_result2) {
+				/* We had a data problem on this page */
+				yaffs_handle_rd_data_error(dev, nand_chunk);
+			}
+
+			if (ecc_result1 < 0 || ecc_result2 < 0)
+				*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+			else if (ecc_result1 > 0 || ecc_result2 > 0)
+				*ecc_result = YAFFS_ECC_RESULT_FIXED;
+			else
+				*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+		}
+	} else {
+		/* Must allocate enough memory for spare+2*sizeof(int) */
+		/* for ecc results from device. */
+		struct yaffs_nand_spare nspare;
+
+		memset(&nspare, 0, sizeof(nspare));
+
+		retVal = dev->param.read_chunk_fn(dev, nand_chunk, data,
+					(yaffs_spare *) &nspare);
+		memcpy(spare, &nspare, sizeof(yaffs_spare));
+		if (data && doErrorCorrection) {
+			if (nspare.eccres1 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error fix performed on chunk %d:0"
+				    TENDSTR), nand_chunk));
+			} else if (nspare.eccres1 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error unfixed on chunk %d:0"
+				    TENDSTR), nand_chunk));
+			}
+
+			if (nspare.eccres2 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error fix performed on chunk %d:1"
+				    TENDSTR), nand_chunk));
+			} else if (nspare.eccres2 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error unfixed on chunk %d:1"
+				    TENDSTR), nand_chunk));
+			}
+
+			if (nspare.eccres1 || nspare.eccres2) {
+				/* We had a data problem on this page */
+				yaffs_handle_rd_data_error(dev, nand_chunk);
+			}
+
+			if (nspare.eccres1 < 0 || nspare.eccres2 < 0)
+				*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+			else if (nspare.eccres1 > 0 || nspare.eccres2 > 0)
+				*ecc_result = YAFFS_ECC_RESULT_FIXED;
+			else
+				*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+
+		}
+	}
+	return retVal;
+}
+
+#ifdef NOTYET
+static int yaffs_check_chunk_erased(struct yaffs_dev_s *dev,
+				  int nand_chunk)
+{
+	static int init;
+	static __u8 cmpbuf[YAFFS_BYTES_PER_CHUNK];
+	static __u8 data[YAFFS_BYTES_PER_CHUNK];
+	/* Might as well always allocate the larger size for */
+	/* dev->param.use_nand_ecc == true; */
+	static __u8 spare[sizeof(struct yaffs_nand_spare)];
+
+	dev->param.read_chunk_fn(dev, nand_chunk, data, (yaffs_spare *) spare);
+
+	if (!init) {
+		memset(cmpbuf, 0xff, YAFFS_BYTES_PER_CHUNK);
+		init = 1;
 	}
 
-	if (ecc_result1 || ecc_result2) {
-		/* We had a data problem on this page */
-		yaffs_handle_rd_data_error(dev, nand_chunk);
-	}
+	if (memcmp(cmpbuf, data, YAFFS_BYTES_PER_CHUNK))
+		return YAFFS_FAIL;
+	if (memcmp(cmpbuf, spare, 16))
+		return YAFFS_FAIL;
 
-	if (ecc_result1 < 0 || ecc_result2 < 0)
-		*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
-	else if (ecc_result1 > 0 || ecc_result2 > 0)
-		*ecc_result = YAFFS_ECC_RESULT_FIXED;
-	else
-		*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+	return YAFFS_OK;
 
-	return ret_val;
 }
+#endif
 
 /*
  * Functions for robustisizing
  */
 
-static void yaffs_handle_rd_data_error(struct yaffs_dev *dev, int nand_chunk)
+static void yaffs_handle_rd_data_error(yaffs_dev_t *dev, int nand_chunk)
 {
 	int flash_block = nand_chunk / dev->param.chunks_per_block;
 
 	/* Mark the block for retirement */
-	yaffs_get_block_info(dev, flash_block + dev->block_offset)->
-		needs_retiring = 1;
-	yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
-		"**>>Block %d marked for retirement",
-		flash_block);
+	yaffs_get_block_info(dev, flash_block + dev->block_offset)->needs_retiring = 1;
+	T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+	  (TSTR("**>>Block %d marked for retirement" TENDSTR), flash_block));
 
 	/* TODO:
 	 * Just do a garbage collection on the affected block
@@ -234,148 +345,195 @@ static void yaffs_handle_rd_data_error(s
 	 */
 }
 
-static int yaffs_tags_compat_wr(struct yaffs_dev *dev,
-			 int nand_chunk,
-			 const u8 *data, const struct yaffs_ext_tags *ext_tags)
+#ifdef NOTYET
+static void yaffs_check_written_block(yaffs_dev_t *dev, int nand_chunk)
 {
-	struct yaffs_spare spare;
-	struct yaffs_tags tags;
+}
+
+static void yaffs_handle_chunk_wr_ok(yaffs_dev_t *dev, int nand_chunk,
+				     const __u8 *data,
+				     const yaffs_spare *spare)
+{
+}
+
+static void yaffs_handle_chunk_update(yaffs_dev_t *dev, int nand_chunk,
+				    const yaffs_spare *spare)
+{
+}
+
+static void yaffs_handle_chunk_wr_error(yaffs_dev_t *dev, int nand_chunk)
+{
+	int flash_block = nand_chunk / dev->param.chunks_per_block;
+
+	/* Mark the block for retirement */
+	yaffs_get_block_info(dev, flash_block)->needs_retiring = 1;
+	/* Delete the chunk */
+	yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+}
+
+static int yaffs_verify_cmp(const __u8 *d0, const __u8 *d1,
+			       const yaffs_spare *s0, const yaffs_spare *s1)
+{
+
+	if (memcmp(d0, d1, YAFFS_BYTES_PER_CHUNK) != 0 ||
+	    s0->tb0 != s1->tb0 ||
+	    s0->tb1 != s1->tb1 ||
+	    s0->tb2 != s1->tb2 ||
+	    s0->tb3 != s1->tb3 ||
+	    s0->tb4 != s1->tb4 ||
+	    s0->tb5 != s1->tb5 ||
+	    s0->tb6 != s1->tb6 ||
+	    s0->tb7 != s1->tb7 ||
+	    s0->ecc1[0] != s1->ecc1[0] ||
+	    s0->ecc1[1] != s1->ecc1[1] ||
+	    s0->ecc1[2] != s1->ecc1[2] ||
+	    s0->ecc2[0] != s1->ecc2[0] ||
+	    s0->ecc2[1] != s1->ecc2[1] || s0->ecc2[2] != s1->ecc2[2]) {
+		return 0;
+	}
+
+	return 1;
+}
+#endif				/* NOTYET */
+
+int yaffs_tags_compat_wr(yaffs_dev_t *dev,
+						int nand_chunk,
+						const __u8 *data,
+						const yaffs_ext_tags *eTags)
+{
+	yaffs_spare spare;
+	yaffs_tags_t tags;
 
 	yaffs_spare_init(&spare);
 
-	if (ext_tags->is_deleted)
+	if (eTags->is_deleted)
 		spare.page_status = 0;
 	else {
-		tags.obj_id = ext_tags->obj_id;
-		tags.chunk_id = ext_tags->chunk_id;
+		tags.obj_id = eTags->obj_id;
+		tags.chunk_id = eTags->chunk_id;
 
-		tags.n_bytes_lsb = ext_tags->n_bytes & (1024 - 1);
+		tags.n_bytes_lsb = eTags->n_bytes & 0x3ff;
 
 		if (dev->data_bytes_per_chunk >= 1024)
-			tags.n_bytes_msb = (ext_tags->n_bytes >> 10) & 3;
+			tags.n_bytes_msb = (eTags->n_bytes >> 10) & 3;
 		else
 			tags.n_bytes_msb = 3;
 
-		tags.serial_number = ext_tags->serial_number;
 
-		if (!dev->param.use_nand_ecc && data) {
-			yaffs_ecc_calc(data, spare.ecc1);
-			yaffs_ecc_calc(&data[256], spare.ecc2);
-		}
+		tags.serial_number = eTags->serial_number;
+
+		if (!dev->param.use_nand_ecc && data)
+			yaffs_calc_ecc(data, &spare);
 
 		yaffs_load_tags_to_spare(&spare, &tags);
+
 	}
+
 	return yaffs_wr_nand(dev, nand_chunk, data, &spare);
 }
 
-static int yaffs_tags_compat_rd(struct yaffs_dev *dev,
-			 int nand_chunk,
-			 u8 *data, struct yaffs_ext_tags *ext_tags)
+int yaffs_tags_compat_rd(yaffs_dev_t *dev,
+						     int nand_chunk,
+						     __u8 *data,
+						     yaffs_ext_tags *eTags)
 {
-	struct yaffs_spare spare;
-	struct yaffs_tags tags;
-	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
-	static struct yaffs_spare spare_ff;
+
+	yaffs_spare spare;
+	yaffs_tags_t tags;
+	yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
+
+	static yaffs_spare spareFF;
 	static int init;
-	int deleted;
 
 	if (!init) {
-		memset(&spare_ff, 0xff, sizeof(spare_ff));
+		memset(&spareFF, 0xFF, sizeof(spareFF));
 		init = 1;
 	}
 
-	if (!yaffs_rd_chunk_nand(dev, nand_chunk,
-					data, &spare, &ecc_result, 1))
+	if (yaffs_rd_chunk_nand
+	    (dev, nand_chunk, data, &spare, &ecc_result, 1)) {
+		/* eTags may be NULL */
+		if (eTags) {
+
+			int deleted =
+			    (yaffs_count_bits(spare.page_status) < 7) ? 1 : 0;
+
+			eTags->is_deleted = deleted;
+			eTags->ecc_result = ecc_result;
+			eTags->block_bad = 0;	/* We're reading it */
+			/* therefore it is not a bad block */
+			eTags->chunk_used =
+			    (memcmp(&spareFF, &spare, sizeof(spareFF)) !=
+			     0) ? 1 : 0;
+
+			if (eTags->chunk_used) {
+				yaffs_get_tags_from_spare(dev, &spare, &tags);
+
+				eTags->obj_id = tags.obj_id;
+				eTags->chunk_id = tags.chunk_id;
+				eTags->n_bytes = tags.n_bytes_lsb;
+
+				if (dev->data_bytes_per_chunk >= 1024)
+					eTags->n_bytes |= (((unsigned) tags.n_bytes_msb) << 10);
+
+				eTags->serial_number = tags.serial_number;
+			}
+		}
+
+		return YAFFS_OK;
+	} else {
 		return YAFFS_FAIL;
-
-	/* ext_tags may be NULL */
-	if (!ext_tags)
-		return YAFFS_OK;
-
-	deleted = (hweight8(spare.page_status) < 7) ? 1 : 0;
-
-	ext_tags->is_deleted = deleted;
-	ext_tags->ecc_result = ecc_result;
-	ext_tags->block_bad = 0;	/* We're reading it */
-	/* therefore it is not a bad block */
-	ext_tags->chunk_used =
-		memcmp(&spare_ff, &spare, sizeof(spare_ff)) ? 1 : 0;
-
-	if (ext_tags->chunk_used) {
-		yaffs_get_tags_from_spare(dev, &spare, &tags);
-		ext_tags->obj_id = tags.obj_id;
-		ext_tags->chunk_id = tags.chunk_id;
-		ext_tags->n_bytes = tags.n_bytes_lsb;
-
-		if (dev->data_bytes_per_chunk >= 1024)
-			ext_tags->n_bytes |=
-				(((unsigned)tags.n_bytes_msb) << 10);
-
-		ext_tags->serial_number = tags.serial_number;
 	}
-
-	return YAFFS_OK;
 }
 
-static int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int flash_block)
+int yaffs_tags_compat_mark_bad(struct yaffs_dev_s *dev,
+					    int flash_block)
 {
-	struct yaffs_spare spare;
 
-	memset(&spare, 0xff, sizeof(struct yaffs_spare));
+	yaffs_spare spare;
+
+	memset(&spare, 0xff, sizeof(yaffs_spare));
 
 	spare.block_status = 'Y';
 
 	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block, NULL,
-		      &spare);
+			       &spare);
 	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block + 1,
-		      NULL, &spare);
+			       NULL, &spare);
 
 	return YAFFS_OK;
+
 }
 
-static int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
-				  int block_no,
-				  enum yaffs_block_state *state,
-				  u32 *seq_number)
+int yaffs_tags_compat_query_block(struct yaffs_dev_s *dev,
+					  int block_no,
+					  yaffs_block_state_t *state,
+					  __u32 *seq_number)
 {
-	struct yaffs_spare spare0, spare1;
-	static struct yaffs_spare spare_ff;
+
+	yaffs_spare spare0, spare1;
+	static yaffs_spare spareFF;
 	static int init;
-	enum yaffs_ecc_result dummy;
+	yaffs_ecc_result dummy;
 
 	if (!init) {
-		memset(&spare_ff, 0xff, sizeof(spare_ff));
+		memset(&spareFF, 0xFF, sizeof(spareFF));
 		init = 1;
 	}
 
 	*seq_number = 0;
 
-	/* Look for bad block markers in the first two chunks */
-	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block,
-			    NULL, &spare0, &dummy, 0);
-	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block + 1,
-			    NULL, &spare1, &dummy, 0);
+	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block, NULL,
+				&spare0, &dummy, 1);
+	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block + 1, NULL,
+				&spare1, &dummy, 1);
 
-	if (hweight8(spare0.block_status & spare1.block_status) < 7)
+	if (yaffs_count_bits(spare0.block_status & spare1.block_status) < 7)
 		*state = YAFFS_BLOCK_STATE_DEAD;
-	else if (memcmp(&spare_ff, &spare0, sizeof(spare_ff)) == 0)
+	else if (memcmp(&spareFF, &spare0, sizeof(spareFF)) == 0)
 		*state = YAFFS_BLOCK_STATE_EMPTY;
 	else
-		*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+		*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
 
 	return YAFFS_OK;
 }
-
-void yaffs_tags_compat_install(struct yaffs_dev *dev)
-{
-	if(dev->param.is_yaffs2)
-		return;
-	if(!dev->tagger.write_chunk_tags_fn)
-		dev->tagger.write_chunk_tags_fn = yaffs_tags_compat_wr;
-	if(!dev->tagger.read_chunk_tags_fn)
-		dev->tagger.read_chunk_tags_fn = yaffs_tags_compat_rd;
-	if(!dev->tagger.query_block_fn)
-		dev->tagger.query_block_fn = yaffs_tags_compat_query_block;
-	if(!dev->tagger.mark_bad_fn)
-		dev->tagger.mark_bad_fn = yaffs_tags_compat_mark_bad;
-}
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_tagscompat.h b/target/linux/generic/files/fs/yaffs2/yaffs_tagscompat.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_tagscompat.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_tagscompat.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -16,29 +16,24 @@
 #ifndef __YAFFS_TAGSCOMPAT_H__
 #define __YAFFS_TAGSCOMPAT_H__
 
+#include "yaffs_guts.h"
+int yaffs_tags_compat_wr(yaffs_dev_t *dev,
+						int nand_chunk,
+						const __u8 *data,
+						const yaffs_ext_tags *tags);
+int yaffs_tags_compat_rd(yaffs_dev_t *dev,
+						int nand_chunk,
+						__u8 *data,
+						yaffs_ext_tags *tags);
+int yaffs_tags_compat_mark_bad(struct yaffs_dev_s *dev,
+					    int block_no);
+int yaffs_tags_compat_query_block(struct yaffs_dev_s *dev,
+					  int block_no,
+					  yaffs_block_state_t *state,
+					  __u32 *seq_number);
 
-#include "yaffs_guts.h"
-
-#if 0
-
-
-int yaffs_tags_compat_wr(struct yaffs_dev *dev,
-			 int nand_chunk,
-			 const u8 *data, const struct yaffs_ext_tags *tags);
-int yaffs_tags_compat_rd(struct yaffs_dev *dev,
-			 int nand_chunk,
-			 u8 *data, struct yaffs_ext_tags *tags);
-int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int block_no);
-int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
-				  int block_no,
-				  enum yaffs_block_state *state,
-				  u32 *seq_number);
+void yaffs_calc_tags_ecc(yaffs_tags_t *tags);
+int yaffs_check_tags_ecc(yaffs_tags_t *tags);
+int yaffs_count_bits(__u8 byte);
 
 #endif
-
-
-void yaffs_tags_compat_install(struct yaffs_dev *dev);
-void yaffs_calc_tags_ecc(struct yaffs_tags *tags);
-int yaffs_check_tags_ecc(struct yaffs_tags *tags);
-
-#endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_tagsvalidity.c b/target/linux/generic/files/fs/yaffs2/yaffs_tagsvalidity.c
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_tagsvalidity.c
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_tagsvalidity.h"
+
+void yaffs_init_tags(yaffs_ext_tags *tags)
+{
+	memset(tags, 0, sizeof(yaffs_ext_tags));
+	tags->validity1 = 0xAAAAAAAA;
+	tags->validty1 = 0x55555555;
+}
+
+int yaffs_validate_tags(yaffs_ext_tags *tags)
+{
+	return (tags->validity1 == 0xAAAAAAAA &&
+		tags->validty1 == 0x55555555);
+
+}
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_tagsvalidity.h b/target/linux/generic/files/fs/yaffs2/yaffs_tagsvalidity.h
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_tagsvalidity.h
@@ -0,0 +1,24 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+
+#ifndef __YAFFS_TAGS_VALIDITY_H__
+#define __YAFFS_TAGS_VALIDITY_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_init_tags(yaffs_ext_tags *tags);
+int yaffs_validate_tags(yaffs_ext_tags *tags);
+#endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_trace.h b/target/linux/generic/files/fs/yaffs2/yaffs_trace.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_trace.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_trace.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -13,6 +13,7 @@
  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
  */
 
+
 #ifndef __YTRACE_H__
 #define __YTRACE_H__
 
@@ -43,15 +44,17 @@ extern unsigned int yaffs_wr_attempts;
 #define YAFFS_TRACE_VERIFY		0x00010000
 #define YAFFS_TRACE_VERIFY_NAND		0x00020000
 #define YAFFS_TRACE_VERIFY_FULL		0x00040000
-#define YAFFS_TRACE_VERIFY_ALL		0x000f0000
+#define YAFFS_TRACE_VERIFY_ALL		0x000F0000
 
 #define YAFFS_TRACE_SYNC		0x00100000
 #define YAFFS_TRACE_BACKGROUND		0x00200000
 #define YAFFS_TRACE_LOCK		0x00400000
-#define YAFFS_TRACE_MOUNT		0x00800000
 
 #define YAFFS_TRACE_ERROR		0x40000000
 #define YAFFS_TRACE_BUG			0x80000000
-#define YAFFS_TRACE_ALWAYS		0xf0000000
+#define YAFFS_TRACE_ALWAYS		0xF0000000
+
+
+#define T(mask, p) do { if ((mask) & (yaffs_trace_mask | YAFFS_TRACE_ALWAYS)) TOUT(p); } while (0)
 
 #endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_verify.c b/target/linux/generic/files/fs/yaffs2/yaffs_verify.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_verify.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_verify.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -11,229 +11,271 @@
  * published by the Free Software Foundation.
  */
 
+
 #include "yaffs_verify.h"
 #include "yaffs_trace.h"
 #include "yaffs_bitmap.h"
 #include "yaffs_getblockinfo.h"
 #include "yaffs_nand.h"
 
-int yaffs_skip_verification(struct yaffs_dev *dev)
+int yaffs_skip_verification(yaffs_dev_t *dev)
 {
-	(void) dev;
-	return !(yaffs_trace_mask &
-		 (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
+	dev=dev;
+	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
 }
 
-static int yaffs_skip_full_verification(struct yaffs_dev *dev)
+static int yaffs_skip_full_verification(yaffs_dev_t *dev)
 {
-	(void) dev;
+	dev=dev;
 	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_FULL));
 }
 
-static int yaffs_skip_nand_verification(struct yaffs_dev *dev)
+static int yaffs_skip_nand_verification(yaffs_dev_t *dev)
 {
-	(void) dev;
+	dev=dev;
 	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_NAND));
 }
 
-static const char * const block_state_name[] = {
-	"Unknown",
-	"Needs scan",
-	"Scanning",
-	"Empty",
-	"Allocating",
-	"Full",
-	"Dirty",
-	"Checkpoint",
-	"Collecting",
-	"Dead"
+
+static const char *block_stateName[] = {
+"Unknown",
+"Needs scanning",
+"Scanning",
+"Empty",
+"Allocating",
+"Full",
+"Dirty",
+"Checkpoint",
+"Collecting",
+"Dead"
 };
 
-void yaffs_verify_blk(struct yaffs_dev *dev, struct yaffs_block_info *bi, int n)
+
+void yaffs_verify_blk(yaffs_dev_t *dev, yaffs_block_info_t *bi, int n)
 {
-	int actually_used;
-	int in_use;
+	int actuallyUsed;
+	int inUse;
 
 	if (yaffs_skip_verification(dev))
 		return;
 
 	/* Report illegal runtime states */
 	if (bi->block_state >= YAFFS_NUMBER_OF_BLOCK_STATES)
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Block %d has undefined state %d",
-			n, bi->block_state);
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has undefined state %d"TENDSTR), n, bi->block_state));
 
 	switch (bi->block_state) {
 	case YAFFS_BLOCK_STATE_UNKNOWN:
 	case YAFFS_BLOCK_STATE_SCANNING:
-	case YAFFS_BLOCK_STATE_NEEDS_SCAN:
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Block %d has bad run-state %s",
-			n, block_state_name[bi->block_state]);
+	case YAFFS_BLOCK_STATE_NEEDS_SCANNING:
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has bad run-state %s"TENDSTR),
+		n, block_stateName[bi->block_state]));
 	}
 
 	/* Check pages in use and soft deletions are legal */
 
-	actually_used = bi->pages_in_use - bi->soft_del_pages;
+	actuallyUsed = bi->pages_in_use - bi->soft_del_pages;
 
-	if (bi->pages_in_use < 0 ||
-	    bi->pages_in_use > dev->param.chunks_per_block ||
-	    bi->soft_del_pages < 0 ||
-	    bi->soft_del_pages > dev->param.chunks_per_block ||
-	    actually_used < 0 || actually_used > dev->param.chunks_per_block)
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Block %d has illegal values pages_in_used %d soft_del_pages %d",
-			n, bi->pages_in_use, bi->soft_del_pages);
+	if (bi->pages_in_use < 0 || bi->pages_in_use > dev->param.chunks_per_block ||
+	   bi->soft_del_pages < 0 || bi->soft_del_pages > dev->param.chunks_per_block ||
+	   actuallyUsed < 0 || actuallyUsed > dev->param.chunks_per_block)
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has illegal values pages_in_used %d soft_del_pages %d"TENDSTR),
+		n, bi->pages_in_use, bi->soft_del_pages));
+
 
 	/* Check chunk bitmap legal */
-	in_use = yaffs_count_chunk_bits(dev, n);
-	if (in_use != bi->pages_in_use)
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Block %d has inconsistent values pages_in_use %d counted chunk bits %d",
-			n, bi->pages_in_use, in_use);
+	inUse = yaffs_count_chunk_bits(dev, n);
+	if (inUse != bi->pages_in_use)
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has inconsistent values pages_in_use %d counted chunk bits %d"TENDSTR),
+			n, bi->pages_in_use, inUse));
+
 }
 
-void yaffs_verify_collected_blk(struct yaffs_dev *dev,
-				struct yaffs_block_info *bi, int n)
+
+
+void yaffs_verify_collected_blk(yaffs_dev_t *dev, yaffs_block_info_t *bi, int n)
 {
 	yaffs_verify_blk(dev, bi, n);
 
 	/* After collection the block should be in the erased state */
 
 	if (bi->block_state != YAFFS_BLOCK_STATE_COLLECTING &&
-	    bi->block_state != YAFFS_BLOCK_STATE_EMPTY) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"Block %d is in state %d after gc, should be erased",
-			n, bi->block_state);
+			bi->block_state != YAFFS_BLOCK_STATE_EMPTY) {
+		T(YAFFS_TRACE_ERROR, (TSTR("Block %d is in state %d after gc, should be erased"TENDSTR),
+			n, bi->block_state));
 	}
 }
 
-void yaffs_verify_blocks(struct yaffs_dev *dev)
+void yaffs_verify_blocks(yaffs_dev_t *dev)
 {
 	int i;
-	int state_count[YAFFS_NUMBER_OF_BLOCK_STATES];
-	int illegal_states = 0;
+	int nBlocksPerState[YAFFS_NUMBER_OF_BLOCK_STATES];
+	int nIllegalBlockStates = 0;
 
 	if (yaffs_skip_verification(dev))
 		return;
 
-	memset(state_count, 0, sizeof(state_count));
+	memset(nBlocksPerState, 0, sizeof(nBlocksPerState));
 
 	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
-		struct yaffs_block_info *bi = yaffs_get_block_info(dev, i);
+		yaffs_block_info_t *bi = yaffs_get_block_info(dev, i);
 		yaffs_verify_blk(dev, bi, i);
 
 		if (bi->block_state < YAFFS_NUMBER_OF_BLOCK_STATES)
-			state_count[bi->block_state]++;
+			nBlocksPerState[bi->block_state]++;
 		else
-			illegal_states++;
+			nIllegalBlockStates++;
 	}
 
-	yaffs_trace(YAFFS_TRACE_VERIFY,	"Block summary");
+	T(YAFFS_TRACE_VERIFY, (TSTR(""TENDSTR)));
+	T(YAFFS_TRACE_VERIFY, (TSTR("Block summary"TENDSTR)));
 
-	yaffs_trace(YAFFS_TRACE_VERIFY,
-		"%d blocks have illegal states",
-		illegal_states);
-	if (state_count[YAFFS_BLOCK_STATE_ALLOCATING] > 1)
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Too many allocating blocks");
+	T(YAFFS_TRACE_VERIFY, (TSTR("%d blocks have illegal states"TENDSTR), nIllegalBlockStates));
+	if (nBlocksPerState[YAFFS_BLOCK_STATE_ALLOCATING] > 1)
+		T(YAFFS_TRACE_VERIFY, (TSTR("Too many allocating blocks"TENDSTR)));
 
 	for (i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"%s %d blocks",
-			block_state_name[i], state_count[i]);
+		T(YAFFS_TRACE_VERIFY,
+		  (TSTR("%s %d blocks"TENDSTR),
+		  block_stateName[i], nBlocksPerState[i]));
 
-	if (dev->blocks_in_checkpt != state_count[YAFFS_BLOCK_STATE_CHECKPOINT])
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Checkpoint block count wrong dev %d count %d",
-			dev->blocks_in_checkpt,
-			state_count[YAFFS_BLOCK_STATE_CHECKPOINT]);
+	if (dev->blocks_in_checkpt != nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT])
+		T(YAFFS_TRACE_VERIFY,
+		 (TSTR("Checkpoint block count wrong dev %d count %d"TENDSTR),
+		 dev->blocks_in_checkpt, nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT]));
 
-	if (dev->n_erased_blocks != state_count[YAFFS_BLOCK_STATE_EMPTY])
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Erased block count wrong dev %d count %d",
-			dev->n_erased_blocks,
-			state_count[YAFFS_BLOCK_STATE_EMPTY]);
+	if (dev->n_erased_blocks != nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY])
+		T(YAFFS_TRACE_VERIFY,
+		 (TSTR("Erased block count wrong dev %d count %d"TENDSTR),
+		 dev->n_erased_blocks, nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY]));
 
-	if (state_count[YAFFS_BLOCK_STATE_COLLECTING] > 1)
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Too many collecting blocks %d (max is 1)",
-			state_count[YAFFS_BLOCK_STATE_COLLECTING]);
+	if (nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING] > 1)
+		T(YAFFS_TRACE_VERIFY,
+		 (TSTR("Too many collecting blocks %d (max is 1)"TENDSTR),
+		 nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING]));
+
+	T(YAFFS_TRACE_VERIFY, (TSTR(""TENDSTR)));
+
 }
 
 /*
- * Verify the object header. oh must be valid, but obj and tags may be NULL in
- * which case those tests will not be performed.
+ * Verify the object header. oh must be valid, but obj and tags may be NULL in which
+ * case those tests will not be performed.
  */
-void yaffs_verify_oh(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh,
-		     struct yaffs_ext_tags *tags, int parent_check)
+void yaffs_verify_oh(yaffs_obj_t *obj, yaffs_obj_header *oh, yaffs_ext_tags *tags, int parentCheck)
 {
 	if (obj && yaffs_skip_verification(obj->my_dev))
 		return;
 
 	if (!(tags && obj && oh)) {
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Verifying object header tags %p obj %p oh %p",
-			tags, obj, oh);
+		T(YAFFS_TRACE_VERIFY,
+				(TSTR("Verifying object header tags %p obj %p oh %p"TENDSTR),
+				tags, obj, oh));
 		return;
 	}
 
 	if (oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||
-	    oh->type > YAFFS_OBJECT_TYPE_MAX)
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Obj %d header type is illegal value 0x%x",
-			tags->obj_id, oh->type);
+			oh->type > YAFFS_OBJECT_TYPE_MAX)
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header type is illegal value 0x%x"TENDSTR),
+			tags->obj_id, oh->type));
 
 	if (tags->obj_id != obj->obj_id)
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Obj %d header mismatch obj_id %d",
-			tags->obj_id, obj->obj_id);
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header mismatch obj_id %d"TENDSTR),
+			tags->obj_id, obj->obj_id));
+
 
 	/*
-	 * Check that the object's parent ids match if parent_check requested.
+	 * Check that the object's parent ids match if parentCheck requested.
 	 *
 	 * Tests do not apply to the root object.
 	 */
 
-	if (parent_check && tags->obj_id > 1 && !obj->parent)
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Obj %d header mismatch parent_id %d obj->parent is NULL",
-			tags->obj_id, oh->parent_obj_id);
+	if (parentCheck && tags->obj_id > 1 && !obj->parent)
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header mismatch parent_id %d obj->parent is NULL"TENDSTR),
+			tags->obj_id, oh->parent_obj_id));
 
-	if (parent_check && obj->parent &&
-	    oh->parent_obj_id != obj->parent->obj_id &&
-	    (oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED ||
-	     obj->parent->obj_id != YAFFS_OBJECTID_DELETED))
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Obj %d header mismatch parent_id %d parent_obj_id %d",
-			tags->obj_id, oh->parent_obj_id,
-			obj->parent->obj_id);
+	if (parentCheck && obj->parent &&
+			oh->parent_obj_id != obj->parent->obj_id &&
+			(oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED ||
+			obj->parent->obj_id != YAFFS_OBJECTID_DELETED))
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header mismatch parent_id %d parent_obj_id %d"TENDSTR),
+			tags->obj_id, oh->parent_obj_id, obj->parent->obj_id));
 
-	if (tags->obj_id > 1 && oh->name[0] == 0)	/* Null name */
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Obj %d header name is NULL",
-			obj->obj_id);
+	if (tags->obj_id > 1 && oh->name[0] == 0) /* Null name */
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header name is NULL"TENDSTR),
+			obj->obj_id));
 
-	if (tags->obj_id > 1 && ((u8) (oh->name[0])) == 0xff)	/* Junk name */
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Obj %d header name is 0xff",
-			obj->obj_id);
+	if (tags->obj_id > 1 && ((__u8)(oh->name[0])) == 0xff) /* Trashed name */
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header name is 0xFF"TENDSTR),
+			obj->obj_id));
 }
 
-void yaffs_verify_file(struct yaffs_obj *obj)
+
+#if 0
+/* Not being used, but don't want to throw away yet */
+int yaffs_verify_tnode_worker(yaffs_obj_t *obj, yaffs_tnode_t *tn,
+					__u32 level, int chunk_offset)
 {
-	u32 x;
-	int required_depth;
-	int actual_depth;
-	int last_chunk;
-	u32 offset_in_chunk;
-	u32 the_chunk;
+	int i;
+	yaffs_dev_t *dev = obj->my_dev;
+	int ok = 1;
 
-	u32 i;
-	struct yaffs_dev *dev;
-	struct yaffs_ext_tags tags;
-	struct yaffs_tnode *tn;
-	u32 obj_id;
+	if (tn) {
+		if (level > 0) {
+
+			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+				if (tn->internal[i]) {
+					ok = yaffs_verify_tnode_worker(obj,
+							tn->internal[i],
+							level - 1,
+							(chunk_offset<<YAFFS_TNODES_INTERNAL_BITS) + i);
+				}
+			}
+		} else if (level == 0) {
+			yaffs_ext_tags tags;
+			__u32 obj_id = obj->obj_id;
+
+			chunk_offset <<=  YAFFS_TNODES_LEVEL0_BITS;
+
+			for (i = 0; i < YAFFS_NTNODES_LEVEL0; i++) {
+				__u32 theChunk = yaffs_get_group_base(dev, tn, i);
+
+				if (theChunk > 0) {
+					/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),tags.obj_id,tags.chunk_id,theChunk)); */
+					yaffs_rd_chunk_tags_nand(dev, theChunk, NULL, &tags);
+					if (tags.obj_id != obj_id || tags.chunk_id != chunk_offset) {
+						T(~0, (TSTR("Object %d chunk_id %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
+							obj_id, chunk_offset, theChunk,
+							tags.obj_id, tags.chunk_id));
+					}
+				}
+				chunk_offset++;
+			}
+		}
+	}
+
+	return ok;
+
+}
+
+#endif
+
+void yaffs_verify_file(yaffs_obj_t *obj)
+{
+	int requiredTallness;
+	int actualTallness;
+	__u32 lastChunk;
+	__u32 x;
+	__u32 i;
+	yaffs_dev_t *dev;
+	yaffs_ext_tags tags;
+	yaffs_tnode_t *tn;
+	__u32 obj_id;
 
 	if (!obj)
 		return;
@@ -244,19 +286,16 @@ void yaffs_verify_file(struct yaffs_obj 
 	dev = obj->my_dev;
 	obj_id = obj->obj_id;
 
-
 	/* Check file size is consistent with tnode depth */
-	yaffs_addr_to_chunk(dev, obj->variant.file_variant.file_size,
-				&last_chunk, &offset_in_chunk);
-	last_chunk++;
-	x = last_chunk >> YAFFS_TNODES_LEVEL0_BITS;
-	required_depth = 0;
+	lastChunk =  obj->variant.file_variant.file_size / dev->data_bytes_per_chunk + 1;
+	x = lastChunk >> YAFFS_TNODES_LEVEL0_BITS;
+	requiredTallness = 0;
 	while (x > 0) {
 		x >>= YAFFS_TNODES_INTERNAL_BITS;
-		required_depth++;
+		requiredTallness++;
 	}
 
-	actual_depth = obj->variant.file_variant.top_level;
+	actualTallness = obj->variant.file_variant.top_level;
 
 	/* Check that the chunks in the tnode tree are all correct.
 	 * We do this by scanning through the tnode tree and
@@ -266,26 +305,26 @@ void yaffs_verify_file(struct yaffs_obj 
 	if (yaffs_skip_nand_verification(dev))
 		return;
 
-	for (i = 1; i <= last_chunk; i++) {
+	for (i = 1; i <= lastChunk; i++) {
 		tn = yaffs_find_tnode_0(dev, &obj->variant.file_variant, i);
 
-		if (!tn)
-			continue;
-
-		the_chunk = yaffs_get_group_base(dev, tn, i);
-		if (the_chunk > 0) {
-			yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
-						 &tags);
-			if (tags.obj_id != obj_id || tags.chunk_id != i)
-				yaffs_trace(YAFFS_TRACE_VERIFY,
-					"Object %d chunk_id %d NAND mismatch chunk %d tags (%d:%d)",
-					obj_id, i, the_chunk,
-					tags.obj_id, tags.chunk_id);
+		if (tn) {
+			__u32 theChunk = yaffs_get_group_base(dev, tn, i);
+			if (theChunk > 0) {
+				/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),obj_id,i,theChunk)); */
+				yaffs_rd_chunk_tags_nand(dev, theChunk, NULL, &tags);
+				if (tags.obj_id != obj_id || tags.chunk_id != i) {
+					T(~0, (TSTR("Object %d chunk_id %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
+						obj_id, i, theChunk,
+						tags.obj_id, tags.chunk_id));
+				}
+			}
 		}
 	}
 }
 
-void yaffs_verify_link(struct yaffs_obj *obj)
+
+void yaffs_verify_link(yaffs_obj_t *obj)
 {
 	if (obj && yaffs_skip_verification(obj->my_dev))
 		return;
@@ -293,7 +332,7 @@ void yaffs_verify_link(struct yaffs_obj 
 	/* Verify sane equivalent object */
 }
 
-void yaffs_verify_symlink(struct yaffs_obj *obj)
+void yaffs_verify_symlink(yaffs_obj_t *obj)
 {
 	if (obj && yaffs_skip_verification(obj->my_dev))
 		return;
@@ -301,21 +340,23 @@ void yaffs_verify_symlink(struct yaffs_o
 	/* Verify symlink string */
 }
 
-void yaffs_verify_special(struct yaffs_obj *obj)
+void yaffs_verify_special(yaffs_obj_t *obj)
 {
 	if (obj && yaffs_skip_verification(obj->my_dev))
 		return;
 }
 
-void yaffs_verify_obj(struct yaffs_obj *obj)
+void yaffs_verify_obj(yaffs_obj_t *obj)
 {
-	struct yaffs_dev *dev;
-	u32 chunk_min;
-	u32 chunk_max;
-	u32 chunk_id_ok;
-	u32 chunk_in_range;
-	u32 chunk_wrongly_deleted;
-	u32 chunk_valid;
+	yaffs_dev_t *dev;
+
+	__u32 chunkMin;
+	__u32 chunkMax;
+
+	__u32 chunk_idOk;
+	__u32 chunkInRange;
+	__u32 chunkShouldNotBeDeleted;
+	__u32 chunkValid;
 
 	if (!obj)
 		return;
@@ -330,53 +371,54 @@ void yaffs_verify_obj(struct yaffs_obj *
 
 	/* Check sane object header chunk */
 
-	chunk_min = dev->internal_start_block * dev->param.chunks_per_block;
-	chunk_max =
-	    (dev->internal_end_block + 1) * dev->param.chunks_per_block - 1;
+	chunkMin = dev->internal_start_block * dev->param.chunks_per_block;
+	chunkMax = (dev->internal_end_block+1) * dev->param.chunks_per_block - 1;
 
-	chunk_in_range = (((unsigned)(obj->hdr_chunk)) >= chunk_min &&
-			  ((unsigned)(obj->hdr_chunk)) <= chunk_max);
-	chunk_id_ok = chunk_in_range || (obj->hdr_chunk == 0);
-	chunk_valid = chunk_in_range &&
-	    yaffs_check_chunk_bit(dev,
-				  obj->hdr_chunk / dev->param.chunks_per_block,
-				  obj->hdr_chunk % dev->param.chunks_per_block);
-	chunk_wrongly_deleted = chunk_in_range && !chunk_valid;
+	chunkInRange = (((unsigned)(obj->hdr_chunk)) >= chunkMin && ((unsigned)(obj->hdr_chunk)) <= chunkMax);
+	chunk_idOk = chunkInRange || (obj->hdr_chunk == 0);
+	chunkValid = chunkInRange &&
+			yaffs_check_chunk_bit(dev,
+					obj->hdr_chunk / dev->param.chunks_per_block,
+					obj->hdr_chunk % dev->param.chunks_per_block);
+	chunkShouldNotBeDeleted = chunkInRange && !chunkValid;
 
-	if (!obj->fake && (!chunk_id_ok || chunk_wrongly_deleted))
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Obj %d has chunk_id %d %s %s",
+	if (!obj->fake &&
+			(!chunk_idOk || chunkShouldNotBeDeleted)) {
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d has chunk_id %d %s %s"TENDSTR),
 			obj->obj_id, obj->hdr_chunk,
-			chunk_id_ok ? "" : ",out of range",
-			chunk_wrongly_deleted ? ",marked as deleted" : "");
+			chunk_idOk ? "" : ",out of range",
+			chunkShouldNotBeDeleted ? ",marked as deleted" : ""));
+	}
 
-	if (chunk_valid && !yaffs_skip_nand_verification(dev)) {
-		struct yaffs_ext_tags tags;
-		struct yaffs_obj_hdr *oh;
-		u8 *buffer = yaffs_get_temp_buffer(dev);
+	if (chunkValid && !yaffs_skip_nand_verification(dev)) {
+		yaffs_ext_tags tags;
+		yaffs_obj_header *oh;
+		__u8 *buffer = yaffs_get_temp_buffer(dev, __LINE__);
 
-		oh = (struct yaffs_obj_hdr *)buffer;
+		oh = (yaffs_obj_header *)buffer;
 
-		yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, buffer, &tags);
+		yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, buffer,
+				&tags);
 
 		yaffs_verify_oh(obj, oh, &tags, 1);
 
-		yaffs_release_temp_buffer(dev, buffer);
+		yaffs_release_temp_buffer(dev, buffer, __LINE__);
 	}
 
 	/* Verify it has a parent */
-	if (obj && !obj->fake && (!obj->parent || obj->parent->my_dev != dev)) {
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Obj %d has parent pointer %p which does not look like an object",
-			obj->obj_id, obj->parent);
+	if (obj && !obj->fake &&
+			(!obj->parent || obj->parent->my_dev != dev)) {
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d has parent pointer %p which does not look like an object"TENDSTR),
+			obj->obj_id, obj->parent));
 	}
 
 	/* Verify parent is a directory */
-	if (obj->parent &&
-	    obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Obj %d's parent is not a directory (type %d)",
-			obj->obj_id, obj->parent->variant_type);
+	if (obj->parent && obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d's parent is not a directory (type %d)"TENDSTR),
+			obj->obj_id, obj->parent->variant_type));
 	}
 
 	switch (obj->variant_type) {
@@ -397,41 +439,45 @@ void yaffs_verify_obj(struct yaffs_obj *
 		break;
 	case YAFFS_OBJECT_TYPE_UNKNOWN:
 	default:
-		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Obj %d has illegaltype %d",
-		   obj->obj_id, obj->variant_type);
+		T(YAFFS_TRACE_VERIFY,
+		(TSTR("Obj %d has illegaltype %d"TENDSTR),
+		obj->obj_id, obj->variant_type));
 		break;
 	}
 }
 
-void yaffs_verify_objects(struct yaffs_dev *dev)
+void yaffs_verify_objects(yaffs_dev_t *dev)
 {
-	struct yaffs_obj *obj;
+	yaffs_obj_t *obj;
 	int i;
-	struct list_head *lh;
+	struct ylist_head *lh;
 
 	if (yaffs_skip_verification(dev))
 		return;
 
 	/* Iterate through the objects in each hash entry */
 
-	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
-		list_for_each(lh, &dev->obj_bucket[i].list) {
-			obj = list_entry(lh, struct yaffs_obj, hash_link);
-			yaffs_verify_obj(obj);
+	for (i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++) {
+		ylist_for_each(lh, &dev->obj_bucket[i].list) {
+			if (lh) {
+				obj = ylist_entry(lh, yaffs_obj_t, hash_link);
+				yaffs_verify_obj(obj);
+			}
 		}
 	}
 }
 
-void yaffs_verify_obj_in_dir(struct yaffs_obj *obj)
+
+void yaffs_verify_obj_in_dir(yaffs_obj_t *obj)
 {
-	struct list_head *lh;
-	struct yaffs_obj *list_obj;
+	struct ylist_head *lh;
+	yaffs_obj_t *listObj;
+
 	int count = 0;
 
 	if (!obj) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS, "No object to verify");
-		BUG();
+		T(YAFFS_TRACE_ALWAYS, (TSTR("No object to verify" TENDSTR)));
+		YBUG();
 		return;
 	}
 
@@ -439,40 +485,40 @@ void yaffs_verify_obj_in_dir(struct yaff
 		return;
 
 	if (!obj->parent) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS, "Object does not have parent");
-		BUG();
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Object does not have parent" TENDSTR)));
+		YBUG();
 		return;
 	}
 
 	if (obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS, "Parent is not directory");
-		BUG();
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Parent is not directory" TENDSTR)));
+		YBUG();
 	}
 
 	/* Iterate through the objects in each hash entry */
 
-	list_for_each(lh, &obj->parent->variant.dir_variant.children) {
-		list_obj = list_entry(lh, struct yaffs_obj, siblings);
-		yaffs_verify_obj(list_obj);
-		if (obj == list_obj)
-			count++;
-	}
+	ylist_for_each(lh, &obj->parent->variant.dir_variant.children) {
+		if (lh) {
+			listObj = ylist_entry(lh, yaffs_obj_t, siblings);
+			yaffs_verify_obj(listObj);
+			if (obj == listObj)
+				count++;
+		}
+	 }
 
 	if (count != 1) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"Object in directory %d times",
-			count);
-		BUG();
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory %d times" TENDSTR), count));
+		YBUG();
 	}
 }
 
-void yaffs_verify_dir(struct yaffs_obj *directory)
+void yaffs_verify_dir(yaffs_obj_t *directory)
 {
-	struct list_head *lh;
-	struct yaffs_obj *list_obj;
+	struct ylist_head *lh;
+	yaffs_obj_t *listObj;
 
 	if (!directory) {
-		BUG();
+		YBUG();
 		return;
 	}
 
@@ -480,29 +526,27 @@ void yaffs_verify_dir(struct yaffs_obj *
 		return;
 
 	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"Directory has wrong type: %d",
-			directory->variant_type);
-		BUG();
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Directory has wrong type: %d" TENDSTR), directory->variant_type));
+		YBUG();
 	}
 
 	/* Iterate through the objects in each hash entry */
 
-	list_for_each(lh, &directory->variant.dir_variant.children) {
-		list_obj = list_entry(lh, struct yaffs_obj, siblings);
-		if (list_obj->parent != directory) {
-			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"Object in directory list has wrong parent %p",
-				list_obj->parent);
-			BUG();
+	ylist_for_each(lh, &directory->variant.dir_variant.children) {
+		if (lh) {
+			listObj = ylist_entry(lh, yaffs_obj_t, siblings);
+			if (listObj->parent != directory) {
+				T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory list has wrong parent %p" TENDSTR), listObj->parent));
+				YBUG();
+			}
+			yaffs_verify_obj_in_dir(listObj);
 		}
-		yaffs_verify_obj_in_dir(list_obj);
 	}
 }
 
 static int yaffs_free_verification_failures;
 
-void yaffs_verify_free_chunks(struct yaffs_dev *dev)
+void yaffs_verify_free_chunks(yaffs_dev_t *dev)
 {
 	int counted;
 	int difference;
@@ -515,15 +559,68 @@ void yaffs_verify_free_chunks(struct yaf
 	difference = dev->n_free_chunks - counted;
 
 	if (difference) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"Freechunks verification failure %d %d %d",
-			dev->n_free_chunks, counted, difference);
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("Freechunks verification failure %d %d %d" TENDSTR),
+		   dev->n_free_chunks, counted, difference));
 		yaffs_free_verification_failures++;
 	}
 }
 
-int yaffs_verify_file_sane(struct yaffs_obj *in)
+int yaffs_verify_file_sane(yaffs_obj_t *in)
 {
-	(void) in;
+#if 0
+	int chunk;
+	int n_chunks;
+	int fSize;
+	int failed = 0;
+	int obj_id;
+	yaffs_tnode_t *tn;
+	yaffs_tags_t localTags;
+	yaffs_tags_t *tags = &localTags;
+	int theChunk;
+	int is_deleted;
+
+	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	obj_id = in->obj_id;
+	fSize = in->variant.file_variant.file_size;
+	n_chunks =
+	    (fSize + in->my_dev->data_bytes_per_chunk - 1) / in->my_dev->data_bytes_per_chunk;
+
+	for (chunk = 1; chunk <= n_chunks; chunk++) {
+		tn = yaffs_find_tnode_0(in->my_dev, &in->variant.file_variant,
+					   chunk);
+
+		if (tn) {
+
+			theChunk = yaffs_get_group_base(dev, tn, chunk);
+
+			if (yaffs_check_chunk_bits
+			    (dev, theChunk / dev->param.chunks_per_block,
+			     theChunk % dev->param.chunks_per_block)) {
+
+				yaffs_rd_chunk_tags_nand(in->my_dev, theChunk,
+							    tags,
+							    &is_deleted);
+				if (yaffs_tags_match
+				    (tags, in->obj_id, chunk, is_deleted)) {
+					/* found it; */
+
+				}
+			} else {
+
+				failed = 1;
+			}
+
+		} else {
+			/* T(("No level 0 found for %d\n", chunk)); */
+		}
+	}
+
+	return failed ? YAFFS_FAIL : YAFFS_OK;
+#else
+	in=in;
 	return YAFFS_OK;
+#endif
 }
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_verify.h b/target/linux/generic/files/fs/yaffs2/yaffs_verify.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_verify.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_verify.h
@@ -1,16 +1,14 @@
 /*
- * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
  *
  * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
- *
- * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
  */
 
 #ifndef __YAFFS_VERIFY_H__
@@ -18,26 +16,24 @@
 
 #include "yaffs_guts.h"
 
-void yaffs_verify_blk(struct yaffs_dev *dev, struct yaffs_block_info *bi,
-		      int n);
-void yaffs_verify_collected_blk(struct yaffs_dev *dev,
-				struct yaffs_block_info *bi, int n);
-void yaffs_verify_blocks(struct yaffs_dev *dev);
+void yaffs_verify_blk(yaffs_dev_t *dev, yaffs_block_info_t *bi, int n);
+void yaffs_verify_collected_blk(yaffs_dev_t *dev, yaffs_block_info_t *bi, int n);
+void yaffs_verify_blocks(yaffs_dev_t *dev);
 
-void yaffs_verify_oh(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh,
-		     struct yaffs_ext_tags *tags, int parent_check);
-void yaffs_verify_file(struct yaffs_obj *obj);
-void yaffs_verify_link(struct yaffs_obj *obj);
-void yaffs_verify_symlink(struct yaffs_obj *obj);
-void yaffs_verify_special(struct yaffs_obj *obj);
-void yaffs_verify_obj(struct yaffs_obj *obj);
-void yaffs_verify_objects(struct yaffs_dev *dev);
-void yaffs_verify_obj_in_dir(struct yaffs_obj *obj);
-void yaffs_verify_dir(struct yaffs_obj *directory);
-void yaffs_verify_free_chunks(struct yaffs_dev *dev);
+void yaffs_verify_oh(yaffs_obj_t *obj, yaffs_obj_header *oh, yaffs_ext_tags *tags, int parentCheck);
+void yaffs_verify_file(yaffs_obj_t *obj);
+void yaffs_verify_link(yaffs_obj_t *obj);
+void yaffs_verify_symlink(yaffs_obj_t *obj);
+void yaffs_verify_special(yaffs_obj_t *obj);
+void yaffs_verify_obj(yaffs_obj_t *obj);
+void yaffs_verify_objects(yaffs_dev_t *dev);
+void yaffs_verify_obj_in_dir(yaffs_obj_t *obj);
+void yaffs_verify_dir(yaffs_obj_t *directory);
+void yaffs_verify_free_chunks(yaffs_dev_t *dev);
 
-int yaffs_verify_file_sane(struct yaffs_obj *obj);
+int yaffs_verify_file_sane(yaffs_obj_t *obj);
 
-int yaffs_skip_verification(struct yaffs_dev *dev);
+int yaffs_skip_verification(yaffs_dev_t *dev);
 
 #endif
+
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_vfs_glue.c b/target/linux/generic/files/fs/yaffs2/yaffs_vfs_glue.c
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_vfs_glue.c
@@ -0,0 +1,3576 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ * Acknowledgements:
+ * Luc van OostenRyck for numerous patches.
+ * Nick Bane for numerous patches.
+ * Nick Bane for 2.5/2.6 integration.
+ * Andras Toth for mknod rdev issue.
+ * Michael Fischer for finding the problem with inode inconsistency.
+ * Some code bodily lifted from JFFS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ *
+ * This is the file system front-end to YAFFS that hooks it up to
+ * the VFS.
+ *
+ * Special notes:
+ * >> 2.4: sb->u.generic_sbp points to the yaffs_dev_t associated with
+ *         this superblock
+ * >> 2.6: sb->s_fs_info  points to the yaffs_dev_t associated with this
+ *         superblock
+ * >> inode->u.generic_ip points to the associated yaffs_obj_t.
+ */
+
+/*
+ * There are two variants of the VFS glue code. This variant should compile
+ * for any version of Linux.
+ */
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10))
+#define YAFFS_COMPILE_BACKGROUND
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6, 23))
+#define YAFFS_COMPILE_FREEZER
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28))
+#define YAFFS_COMPILE_EXPORTFS
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35))
+#define YAFFS_USE_SETATTR_COPY
+#define YAFFS_USE_TRUNCATE_SETSIZE
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35))
+#define YAFFS_HAS_EVICT_INODE
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))
+#define YAFFS_NEW_FOLLOW_LINK 1
+#else
+#define YAFFS_NEW_FOLLOW_LINK 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/pagemap.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+#include <linux/namei.h>
+#endif
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+#include <linux/exportfs.h>
+#endif
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#endif
+#ifdef YAFFS_COMPILE_FREEZER
+#include <linux/freezer.h>
+#endif
+
+#include <asm/div64.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+#include <linux/statfs.h>
+
+#define UnlockPage(p) unlock_page(p)
+#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+
+/* FIXME: use sb->s_id instead ? */
+#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+
+#else
+
+#include <linux/locks.h>
+#define	BDEVNAME_SIZE		0
+#define	yaffs_devname(sb, buf)	kdevname(sb->s_dev)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0))
+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */
+#define __user
+#endif
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define YPROC_ROOT  (&proc_root)
+#else
+#define YPROC_ROOT  NULL
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#define Y_INIT_TIMER(a)	init_timer(a)
+#else
+#define Y_INIT_TIMER(a)	init_timer_on_stack(a)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+#define WRITE_SIZE_STR "writesize"
+#define WRITE_SIZE(mtd) ((mtd)->writesize)
+#else
+#define WRITE_SIZE_STR "oobblock"
+#define WRITE_SIZE(mtd) ((mtd)->oobblock)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28))
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+	do_div(result, block_size);
+	return (uint32_t)result;
+}
+#else
+#define YCALCBLOCKS(s, b) ((s)/(b))
+#endif
+
+#include <linux/uaccess.h>
+#include <linux/mtd/mtd.h>
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+
+#include "yaffs_linux.h"
+
+#include "yaffs_mtdif.h"
+#include "yaffs_mtdif1.h"
+#include "yaffs_mtdif2.h"
+
+unsigned int yaffs_trace_mask = YAFFS_TRACE_BAD_BLOCKS | YAFFS_TRACE_ALWAYS;
+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+unsigned int yaffs_auto_checkpoint = 1;
+unsigned int yaffs_gc_control = 1;
+unsigned int yaffs_bg_enable = 1;
+
+/* Module Parameters */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+module_param(yaffs_trace_mask, uint, 0644);
+module_param(yaffs_wr_attempts, uint, 0644);
+module_param(yaffs_auto_checkpoint, uint, 0644);
+module_param(yaffs_gc_control, uint, 0644);
+module_param(yaffs_bg_enable, uint, 0644);
+#else
+MODULE_PARM(yaffs_trace_mask, "i");
+MODULE_PARM(yaffs_wr_attempts, "i");
+MODULE_PARM(yaffs_auto_checkpoint, "i");
+MODULE_PARM(yaffs_gc_control, "i");
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+/* use iget and read_inode */
+#define Y_IGET(sb, inum) iget((sb), (inum))
+static void yaffs_read_inode(struct inode *inode);
+
+#else
+/* Call local equivalent */
+#define YAFFS_USE_OWN_IGET
+#define Y_IGET(sb, inum) yaffs_iget((sb), (inum))
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+#define yaffs_InodeToObjectLV(iptr) ((iptr)->i_private)
+#else
+#define yaffs_InodeToObjectLV(iptr) ((iptr)->u.generic_ip)
+#endif
+
+#define yaffs_InodeToObject(iptr) ((yaffs_obj_t *)(yaffs_InodeToObjectLV(iptr)))
+#define yaffs_dentry_to_obj(dptr) yaffs_InodeToObject((dptr)->d_inode)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define yaffs_SuperToDevice(sb)	((yaffs_dev_t *)sb->s_fs_info)
+#else
+#define yaffs_SuperToDevice(sb)	((yaffs_dev_t *)sb->u.generic_sbp)
+#endif
+
+
+#define update_dir_time(dir) do {\
+			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+		} while(0)
+		
+static void yaffs_put_super(struct super_block *sb);
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos);
+static ssize_t yaffs_hold_space(struct file *f);
+static void yaffs_release_space(struct file *f);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id);
+#else
+static int yaffs_file_flush(struct file *file);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync);
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+				int datasync);
+#endif
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+					struct nameidata *n);
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry);
+#endif
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *dentry);
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry);
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			const char *symname);
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			dev_t dev);
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			int dev);
+#endif
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry);
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait);
+static void yaffs_write_super(struct super_block *sb);
+#else
+static int yaffs_sync_fs(struct super_block *sb);
+static int yaffs_write_super(struct super_block *sb);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf);
+#endif
+
+#ifdef YAFFS_HAS_PUT_INODE
+static void yaffs_put_inode(struct inode *inode);
+#endif
+
+#ifdef YAFFS_HAS_EVICT_INODE
+static void yaffs_evict_inode(struct inode *);
+#else
+static void yaffs_delete_inode(struct inode *);
+static void yaffs_clear_inode(struct inode *);
+#endif
+
+static int yaffs_readpage(struct file *file, struct page *page);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc);
+#else
+static int yaffs_writepage(struct page *page);
+#endif
+
+#ifdef CONFIG_YAFFS_XATTR
+int yaffs_setxattr(struct dentry *dentry, const char *name,
+			const void *value, size_t size, int flags);
+ssize_t yaffs_getxattr(struct dentry *dentry, const char *name, void *buff,
+			size_t size);
+int yaffs_removexattr(struct dentry *dentry, const char *name);
+ssize_t yaffs_listxattr(struct dentry *dentry, char *buff, size_t size);
+#endif
+
+
+#if (YAFFS_USE_WRITE_BEGIN_END != 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned flags,
+				struct page **pagep, void **fsdata);
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned copied,
+				struct page *pg, void *fsdadata);
+#else
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+				unsigned offset, unsigned to);
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+				unsigned to);
+
+#endif
+
+static int yaffs_readlink(struct dentry *dentry, char __user *buffer,
+				int buflen);
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias);
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#endif
+
+static void yaffs_touch_super(yaffs_dev_t *dev);
+
+static loff_t yaffs_dir_llseek(struct file *file, loff_t offset, int origin);
+
+static int yaffs_vfs_setattr(struct inode *, struct iattr *);
+
+
+static struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
+	.prepare_write = yaffs_prepare_write,
+	.commit_write = yaffs_commit_write,
+#endif
+};
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
+};
+
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.sendfile = generic_file_sendfile,
+};
+
+#else
+
+static const struct file_operations yaffs_file_operations = {
+	.read = generic_file_read,
+	.write = generic_file_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	.sendfile = generic_file_sendfile,
+#endif
+};
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25))
+static void zero_user_segment(struct page *page, unsigned start, unsigned end)
+{
+	void * kaddr = kmap_atomic(page, KM_USER0);
+	memset(kaddr + start, 0, end - start);
+	kunmap_atomic(kaddr, KM_USER0);
+	flush_dcache_page(page);
+}
+#endif
+
+
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+#ifdef CONFIG_YAFFS_XATTR
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+#endif
+};
+
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	.put_link = yaffs_put_link,
+#endif
+	.setattr = yaffs_setattr,
+#ifdef CONFIG_YAFFS_XATTR
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+#endif
+};
+
+static const struct inode_operations yaffs_dir_inode_operations = {
+	.create = yaffs_create,
+	.lookup = yaffs_lookup,
+	.link = yaffs_link,
+	.unlink = yaffs_unlink,
+	.symlink = yaffs_symlink,
+	.mkdir = yaffs_mkdir,
+	.rmdir = yaffs_unlink,
+	.mknod = yaffs_mknod,
+	.rename = yaffs_rename,
+	.setattr = yaffs_setattr,
+#ifdef CONFIG_YAFFS_XATTR
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+#endif
+};
+
+static const struct file_operations yaffs_dir_operations = {
+	.read = generic_read_dir,
+	.readdir = yaffs_readdir,
+	.fsync = yaffs_sync_object,
+	.llseek = yaffs_dir_llseek,
+};
+
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
+
+#ifndef YAFFS_USE_OWN_IGET
+	.read_inode = yaffs_read_inode,
+#endif
+#ifdef YAFFS_HAS_PUT_INODE
+	.put_inode = yaffs_put_inode,
+#endif
+	.put_super = yaffs_put_super,
+#ifdef YAFFS_HAS_EVICT_INODE
+	.evict_inode = yaffs_evict_inode,
+#else
+	.delete_inode = yaffs_delete_inode,
+	.clear_inode = yaffs_clear_inode,
+#endif
+	.sync_fs = yaffs_sync_fs,
+	.write_super = yaffs_write_super,
+};
+
+
+static  int yaffs_vfs_setattr(struct inode *inode, struct iattr *attr)
+{
+#ifdef  YAFFS_USE_SETATTR_COPY
+	setattr_copy(inode,attr);
+	return 0;
+#else
+	return inode_setattr(inode, attr);
+#endif
+
+}
+
+static  int yaffs_vfs_setsize(struct inode *inode, loff_t newsize)
+{
+#ifdef  YAFFS_USE_TRUNCATE_SETSIZE
+	truncate_setsize(inode,newsize);
+	return 0;
+#else
+	truncate_inode_pages(&inode->i_data,newsize);
+	return 0;
+#endif
+
+}
+
+static unsigned yaffs_gc_control_callback(yaffs_dev_t *dev)
+{
+	return yaffs_gc_control;
+}
+                	                                                                                          	
+static void yaffs_gross_lock(yaffs_dev_t *dev)
+{
+	T(YAFFS_TRACE_LOCK, (TSTR("yaffs locking %p\n"), current));
+	down(&(yaffs_dev_to_lc(dev)->grossLock));
+	T(YAFFS_TRACE_LOCK, (TSTR("yaffs locked %p\n"), current));
+}
+
+static void yaffs_gross_unlock(yaffs_dev_t *dev)
+{
+	T(YAFFS_TRACE_LOCK, (TSTR("yaffs unlocking %p\n"), current));
+	up(&(yaffs_dev_to_lc(dev)->grossLock));
+}
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+
+static struct inode *
+yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino, uint32_t generation)
+{
+	return Y_IGET(sb, ino);
+}
+
+static struct dentry *
+yaffs2_fh_to_dentry(struct super_block *sb, struct fid *fid, int fh_len, int fh_type)
+{
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type, yaffs2_nfs_get_inode) ;
+}
+
+static struct dentry *
+ yaffs2_fh_to_parent(struct super_block *sb, struct fid *fid, int fh_len, int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type, yaffs2_nfs_get_inode);
+}
+
+struct dentry *yaffs2_get_parent(struct dentry *dentry)
+{
+
+	struct super_block *sb = dentry->d_inode->i_sb;
+	struct dentry *parent = ERR_PTR(-ENOENT);
+	struct inode *inode;
+	unsigned long parent_ino;
+	yaffs_obj_t *d_obj;
+	yaffs_obj_t *parent_obj;
+
+	d_obj = yaffs_InodeToObject(dentry->d_inode);
+
+	if (d_obj) {
+		parent_obj = d_obj->parent;
+		if (parent_obj) {
+			parent_ino = yaffs_get_obj_inode(parent_obj);
+			inode = Y_IGET(sb, parent_ino);
+
+			if (IS_ERR(inode)) {
+				parent = ERR_CAST(inode);
+			} else {
+				parent = d_obtain_alias(inode);
+				if (!IS_ERR(parent)) {
+					parent = ERR_PTR(-ENOMEM);
+					iput(inode);
+				}
+			}
+		}
+	}
+
+	return parent;
+}
+
+/* Just declare a zero structure as a NULL value implies
+ * using the default functions of exportfs.
+ */
+
+static struct export_operations yaffs_export_ops =
+{
+	.fh_to_dentry = yaffs2_fh_to_dentry,
+	.fh_to_parent = yaffs2_fh_to_parent,
+	.get_parent = yaffs2_get_parent,
+} ;
+
+#endif
+
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the remove_obj_fn to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each yaffs_dev_t has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_SearchContext {
+	yaffs_dev_t *dev;
+	yaffs_obj_t *dirObj;
+	yaffs_obj_t *nextReturn;
+	struct ylist_head others;
+};
+
+/*
+ * yaffs_NewSearch() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_SearchContext * yaffs_NewSearch(yaffs_obj_t *dir)
+{
+	yaffs_dev_t *dev = dir->my_dev;
+	struct yaffs_SearchContext *sc = YMALLOC(sizeof(struct yaffs_SearchContext));
+	if(sc){
+		sc->dirObj = dir;
+		sc->dev = dev;
+		if( ylist_empty(&sc->dirObj->variant.dir_variant.children))
+			sc->nextReturn = NULL;
+		else
+			sc->nextReturn = ylist_entry(
+                                dir->variant.dir_variant.children.next,
+				yaffs_obj_t,siblings);
+		YINIT_LIST_HEAD(&sc->others);
+		ylist_add(&sc->others,&(yaffs_dev_to_lc(dev)->searchContexts));
+	}
+	return sc;
+}
+
+/*
+ * yaffs_search_end() disposes of a search context and cleans up.
+ */
+static void yaffs_search_end(struct yaffs_SearchContext * sc)
+{
+	if(sc){
+		ylist_del(&sc->others);
+		YFREE(sc);
+	}
+}
+
+/*
+ * yaffs_search_advance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_search_advance(struct yaffs_SearchContext *sc)
+{
+        if(!sc)
+                return;
+
+        if( sc->nextReturn == NULL ||
+                ylist_empty(&sc->dirObj->variant.dir_variant.children))
+                sc->nextReturn = NULL;
+        else {
+                struct ylist_head *next = sc->nextReturn->siblings.next;
+
+                if( next == &sc->dirObj->variant.dir_variant.children)
+                        sc->nextReturn = NULL; /* end of list */
+                else
+                        sc->nextReturn = ylist_entry(next,yaffs_obj_t,siblings);
+        }
+}
+
+/*
+ * yaffs_remove_obj_callback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_remove_obj_callback(yaffs_obj_t *obj)
+{
+
+        struct ylist_head *i;
+        struct yaffs_SearchContext *sc;
+        struct ylist_head *search_contexts = &(yaffs_dev_to_lc(obj->my_dev)->searchContexts);
+
+
+        /* Iterate through the directory search contexts.
+         * If any are currently on the object being removed, then advance
+         * the search context to the next object to prevent a hanging pointer.
+         */
+         ylist_for_each(i, search_contexts) {
+                if (i) {
+                        sc = ylist_entry(i, struct yaffs_SearchContext,others);
+                        if(sc->nextReturn == obj)
+                                yaffs_search_advance(sc);
+                }
+	}
+
+}
+
+
+/*-----------------------------------------------------------------*/
+
+static int yaffs_readlink(struct dentry *dentry, char __user *buffer,
+			int buflen)
+{
+	unsigned char *alias;
+	int ret;
+
+	yaffs_dev_t *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+
+	yaffs_gross_unlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+	kfree(alias);
+	return ret;
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+#endif
+{
+	unsigned char *alias;
+	int ret;
+	yaffs_dev_t *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+	yaffs_gross_unlock(dev);
+
+	if (!alias) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	nd_set_link(nd, alias);
+	ret = (int)alias;
+out:
+	return ERR_PTR(ret);
+#else
+	ret = vfs_follow_link(nd, alias);
+	kfree(alias);
+out:
+	return ret;
+#endif
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias) {
+	kfree(alias);
+}
+#endif
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+				yaffs_obj_t *obj);
+
+/*
+ * Lookup is used to find objects in the fs
+ */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				struct nameidata *n)
+#else
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
+#endif
+{
+	yaffs_obj_t *obj;
+	struct inode *inode = NULL;	/* NCB 2.5/2.6 needs NULL here */
+
+	yaffs_dev_t *dev = yaffs_InodeToObject(dir)->my_dev;
+
+	if(current != yaffs_dev_to_lc(dev)->readdirProcess)
+		yaffs_gross_lock(dev);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_lookup for %d:%s\n"),
+		yaffs_InodeToObject(dir)->obj_id, dentry->d_name.name));
+
+	obj = yaffs_find_by_name(yaffs_InodeToObject(dir),
+					dentry->d_name.name);
+
+	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	if(current != yaffs_dev_to_lc(dev)->readdirProcess)
+		yaffs_gross_unlock(dev);
+
+	if (obj) {
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_lookup found %d\n"), obj->obj_id));
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+
+		if (inode) {
+			T(YAFFS_TRACE_OS,
+				(TSTR("yaffs_loookup dentry \n")));
+/* #if 0 asserted by NCB for 2.5/6 compatability - falls through to
+ * d_add even if NULL inode */
+#if 0
+			/*dget(dentry); // try to solve directory bug */
+			d_add(dentry, inode);
+
+			/* return dentry; */
+			return NULL;
+#endif
+		}
+
+	} else {
+		T(YAFFS_TRACE_OS,(TSTR("yaffs_lookup not found\n")));
+
+	}
+
+/* added NCB for 2.5/6 compatability - forces add even if inode is
+ * NULL which creates dentry hash */
+	d_add(dentry, inode);
+
+	return NULL;
+}
+
+
+#ifdef YAFFS_HAS_PUT_INODE
+
+/* For now put inode is just for debugging
+ * Put inode is called when the inode **structure** is put.
+ */
+static void yaffs_put_inode(struct inode *inode)
+{
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_put_inode: ino %d, count %d\n"), (int)inode->i_ino,
+		atomic_read(&inode->i_count)));
+
+}
+#endif
+
+
+static void yaffs_unstitch_obj(struct inode *inode, yaffs_obj_t *obj)
+{
+	/* Clear the association between the inode and
+	 * the yaffs_obj_t.
+	 */
+	obj->my_inode = NULL;
+	yaffs_InodeToObjectLV(inode) = NULL;
+
+	/* If the object freeing was deferred, then the real
+	 * free happens now.
+	 * This should fix the inode inconsistency problem.
+	 */
+	yaffs_handle_defered_free(obj);
+}
+
+#ifdef YAFFS_HAS_EVICT_INODE
+/* yaffs_evict_inode combines into one operation what was previously done in
+ * yaffs_clear_inode() and yaffs_delete_inode()
+ *
+ */
+static void yaffs_evict_inode( struct inode *inode)
+{
+	yaffs_obj_t *obj;
+	yaffs_dev_t *dev;
+	int deleteme = 0;
+
+	obj = yaffs_InodeToObject(inode);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_evict_inode: ino %d, count %d %s\n"), (int)inode->i_ino,
+		atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object"));
+
+	if (!inode->i_nlink && !is_bad_inode(inode))
+		deleteme = 1;
+	truncate_inode_pages(&inode->i_data,0);
+	end_writeback(inode);
+
+	if(deleteme && obj){
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode,obj);
+		yaffs_gross_unlock(dev);
+	}
+
+
+}
+#else
+
+/* clear is called to tell the fs to release any per-inode data it holds.
+ * The object might still exist on disk and is just being thrown out of the cache
+ * or else the object has actually been deleted and we're being called via
+ * the chain
+ *   yaffs_delete_inode() -> clear_inode()->yaffs_clear_inode()
+ */
+
+static void yaffs_clear_inode(struct inode *inode)
+{
+	yaffs_obj_t *obj;
+	yaffs_dev_t *dev;
+
+	obj = yaffs_InodeToObject(inode);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_clear_inode: ino %d, count %d %s\n"), (int)inode->i_ino,
+		atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object"));
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode,obj);
+		yaffs_gross_unlock(dev);
+	}
+
+}
+
+/* delete is called when the link count is zero and the inode
+ * is put (ie. nobody wants to know about it anymore, time to
+ * delete the file).
+ * NB Must call clear_inode()
+ */
+static void yaffs_delete_inode(struct inode *inode)
+{
+	yaffs_obj_t *obj = yaffs_InodeToObject(inode);
+	yaffs_dev_t *dev;
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_delete_inode: ino %d, count %d %s\n"), (int)inode->i_ino,
+		atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object"));
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	truncate_inode_pages(&inode->i_data, 0);
+#endif
+	clear_inode(inode);
+}
+#endif
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+#else
+static int yaffs_file_flush(struct file *file)
+#endif
+{
+	yaffs_obj_t *obj = yaffs_dentry_to_obj(file->f_dentry);
+
+	yaffs_dev_t *dev = obj->my_dev;
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_file_flush object %d (%s)\n"), obj->obj_id,
+		obj->dirty ? "dirty" : "clean"));
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_file(obj, 1, 0);
+
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+{
+	/* Lifted from jffs2 */
+
+	yaffs_obj_t *obj;
+	unsigned char *pg_buf;
+	int ret;
+
+	yaffs_dev_t *dev;
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_readpage_nolock at %08x, size %08x\n"),
+		(unsigned)(pg->index << PAGE_CACHE_SHIFT),
+		(unsigned)PAGE_CACHE_SIZE));
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	BUG_ON(!PageLocked(pg));
+#else
+	if (!PageLocked(pg))
+		PAGE_BUG(pg);
+#endif
+
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
+
+	yaffs_gross_lock(dev);
+
+	ret = yaffs_file_rd(obj, pg_buf,
+				pg->index << PAGE_CACHE_SHIFT,
+				PAGE_CACHE_SIZE);
+
+	yaffs_gross_unlock(dev);
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
+	}
+
+	flush_dcache_page(pg);
+	kunmap(pg);
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_readpage_nolock done\n")));
+	return ret;
+}
+
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+{
+	int ret = yaffs_readpage_nolock(f, pg);
+	UnlockPage(pg);
+	return ret;
+}
+
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	int ret;
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_readpage\n")));
+	ret=yaffs_readpage_unlock(f, pg);
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_readpage done\n")));
+	return ret;
+}
+
+/* writepage inspired by/stolen from smbfs */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+#else
+static int yaffs_writepage(struct page *page)
+#endif
+{
+	yaffs_dev_t *dev;
+	struct address_space *mapping = page->mapping;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	yaffs_obj_t *obj;
+	int nWritten = 0;
+	unsigned n_bytes;
+	loff_t i_size;
+
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+	i_size = i_size_read(inode);
+
+	end_index = i_size >> PAGE_CACHE_SHIFT;
+
+	if(page->index < end_index)
+		n_bytes = PAGE_CACHE_SIZE;
+	else {
+		n_bytes = i_size & (PAGE_CACHE_SIZE -1);
+
+		if (page->index > end_index || !n_bytes) {
+			T(YAFFS_TRACE_OS,
+				(TSTR("yaffs_writepage at %08x, inode size = %08x!!!\n"),
+				(unsigned)(page->index << PAGE_CACHE_SHIFT),
+				(unsigned)inode->i_size));
+			T(YAFFS_TRACE_OS,
+				(TSTR("                -> don't care!!\n")));
+
+			zero_user_segment(page,0,PAGE_CACHE_SIZE);
+			set_page_writeback(page);
+			unlock_page(page);
+			end_page_writeback(page);
+			return 0;
+		}
+	}
+
+	if(n_bytes != PAGE_CACHE_SIZE)
+		zero_user_segment(page,n_bytes,PAGE_CACHE_SIZE);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	obj = yaffs_InodeToObject(inode);
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_writepage at %08x, size %08x\n"),
+		(unsigned)(page->index << PAGE_CACHE_SHIFT), n_bytes));
+	T(YAFFS_TRACE_OS,
+		(TSTR("writepag0: obj = %05x, ino = %05x\n"),
+		(int)obj->variant.file_variant.file_size, (int)inode->i_size));
+
+	nWritten = yaffs_wr_file(obj, buffer,
+			page->index << PAGE_CACHE_SHIFT, n_bytes, 0);
+
+	yaffs_touch_super(dev);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("writepag1: obj = %05x, ino = %05x\n"),
+		(int)obj->variant.file_variant.file_size, (int)inode->i_size));
+
+	yaffs_gross_unlock(dev);
+
+	kunmap(page);
+	set_page_writeback(page);
+	unlock_page(page);
+	end_page_writeback(page);
+	put_page(page);
+
+	return (nWritten == n_bytes) ? 0 : -ENOSPC;
+}
+
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned flags,
+				struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+
+	int ret = 0;
+	int space_held = 0;
+
+	/* Get a page */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
+
+	*pagep = pg;
+	if (!pg) {
+		ret =  -ENOMEM;
+		goto out;
+	}
+	T(YAFFS_TRACE_OS,
+		(TSTR("start yaffs_write_begin index %d(%x) uptodate %d\n"),
+		(int)index,(int)index,Page_Uptodate(pg) ? 1 : 0));
+
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+
+	if (!Page_Uptodate(pg))
+		ret = yaffs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	T(YAFFS_TRACE_OS, (TSTR("end yaffs_write_begin - ok\n")));
+
+	return 0;
+
+out:
+	T(YAFFS_TRACE_OS,
+		(TSTR("end yaffs_write_begin fail returning %d\n"), ret));
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+				unsigned offset, unsigned to)
+{
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_prepair_write\n")));
+
+	if (!Page_Uptodate(pg))
+		return yaffs_readpage_nolock(f, pg);
+	return 0;
+}
+#endif
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned copied,
+				struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_write_end addr %p pos %x n_bytes %d\n",
+		addr,(unsigned)pos, copied));
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_write_end not same size ret %d  copied %d\n"),
+			ret, copied));
+		SetPageError(pg);
+	} else {
+		/* Nothing */
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
+
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+				unsigned to)
+{
+	void *addr, *kva;
+
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int n_bytes = to - offset;
+	int nWritten;
+
+	unsigned spos = pos;
+	unsigned saddr;
+
+	kva = kmap(pg);
+	addr = kva + offset;
+
+	saddr = (unsigned) addr;
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_commit_write addr %x pos %x n_bytes %d\n"),
+		saddr, spos, n_bytes));
+
+	nWritten = yaffs_file_write(f, addr, n_bytes, &pos);
+
+	if (nWritten != n_bytes) {
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_commit_write not same size nWritten %d  n_bytes %d\n"),
+			nWritten, n_bytes));
+		SetPageError(pg);
+	} else {
+		/* Nothing */
+	}
+
+	kunmap(pg);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_commit_write returning %d\n"),
+		nWritten == n_bytes ? 0 : nWritten));
+
+	return nWritten == n_bytes ? 0 : nWritten;
+}
+#endif
+
+
+static void yaffs_fill_inode_from_obj(struct inode *inode, yaffs_obj_t *obj)
+{
+	if (inode && obj) {
+
+
+		/* Check mode against the variant type and attempt to repair if broken. */
+		__u32 mode = obj->yst_mode;
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			if (!S_ISREG(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFREG;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			if (!S_ISLNK(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFLNK;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			if (!S_ISDIR(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFDIR;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		default:
+			/* TODO? */
+			break;
+		}
+
+		inode->i_flags |= S_NOATIME;
+
+		inode->i_ino = obj->obj_id;
+		inode->i_mode = obj->yst_mode;
+		inode->i_uid = obj->yst_uid;
+		inode->i_gid = obj->yst_gid;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+		inode->i_blksize = inode->i_sb->s_blocksize;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+		inode->i_atime.tv_nsec = 0;
+		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+		inode->i_mtime.tv_nsec = 0;
+		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+		inode->i_ctime.tv_nsec = 0;
+#else
+		inode->i_rdev = obj->yst_rdev;
+		inode->i_atime = obj->yst_atime;
+		inode->i_mtime = obj->yst_mtime;
+		inode->i_ctime = obj->yst_ctime;
+#endif
+		inode->i_size = yaffs_get_obj_length(obj);
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+
+		inode->i_nlink = yaffs_get_obj_link_count(obj);
+
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_fill_inode mode %x uid %d gid %d size %d count %d\n"),
+			inode->i_mode, inode->i_uid, inode->i_gid,
+			(int)inode->i_size, atomic_read(&inode->i_count)));
+
+		switch (obj->yst_mode & S_IFMT) {
+		default:	/* fifo, device or socket */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+			init_special_inode(inode, obj->yst_mode,
+					old_decode_dev(obj->yst_rdev));
+#else
+			init_special_inode(inode, obj->yst_mode,
+					(dev_t) (obj->yst_rdev));
+#endif
+			break;
+		case S_IFREG:	/* file */
+			inode->i_op = &yaffs_file_inode_operations;
+			inode->i_fop = &yaffs_file_operations;
+			inode->i_mapping->a_ops =
+				&yaffs_file_address_operations;
+			break;
+		case S_IFDIR:	/* directory */
+			inode->i_op = &yaffs_dir_inode_operations;
+			inode->i_fop = &yaffs_dir_operations;
+			break;
+		case S_IFLNK:	/* symlink */
+			inode->i_op = &yaffs_symlink_inode_operations;
+			break;
+		}
+
+		yaffs_InodeToObjectLV(inode) = obj;
+
+		obj->my_inode = inode;
+
+	} else {
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_FileInode invalid parameters\n")));
+	}
+
+}
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+				yaffs_obj_t *obj)
+{
+	struct inode *inode;
+
+	if (!sb) {
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_get_inode for NULL super_block!!\n")));
+		return NULL;
+
+	}
+
+	if (!obj) {
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_get_inode for NULL object!!\n")));
+		return NULL;
+
+	}
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_get_inode for object %d\n"), obj->obj_id));
+
+	inode = Y_IGET(sb, obj->obj_id);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding grossLock or deadlock will happen! */
+
+	return inode;
+}
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos)
+{
+	yaffs_obj_t *obj;
+	int nWritten, ipos;
+	struct inode *inode;
+	yaffs_dev_t *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	if (!obj)
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_file_write: hey obj is null!\n")));
+	else
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_file_write about to write writing %u(%x) bytes"
+			"to object %d at %d(%x)\n"),
+			(unsigned) n, (unsigned) n, obj->obj_id, ipos,ipos));
+
+	nWritten = yaffs_wr_file(obj, buf, ipos, n, 0);
+
+	yaffs_touch_super(dev);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_file_write: %d(%x) bytes written\n"),
+		(unsigned )n,(unsigned)n));
+
+	if (nWritten > 0) {
+		ipos += nWritten;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+
+			T(YAFFS_TRACE_OS,
+				(TSTR("yaffs_file_write size updated to %d bytes, "
+				"%d blocks\n"),
+				ipos, (int)(inode->i_blocks)));
+		}
+
+	}
+	yaffs_gross_unlock(dev);
+	return (nWritten == 0) && (n > 0) ? -ENOSPC : nWritten;
+}
+
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	yaffs_obj_t *obj;
+	yaffs_dev_t *dev;
+
+	int n_free_chunks;
+
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	n_free_chunks = yaffs_get_n_free_chunks(dev);
+
+	yaffs_gross_unlock(dev);
+
+	return (n_free_chunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	yaffs_obj_t *obj;
+	yaffs_dev_t *dev;
+
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+
+	yaffs_gross_unlock(dev);
+}
+
+
+static loff_t yaffs_dir_llseek(struct file *file, loff_t offset, int origin)
+{
+	long long retval;
+
+	lock_kernel();
+
+	switch (origin){
+	case 2:
+		offset += i_size_read(file->f_path.dentry->d_inode);
+		break;
+	case 1:
+		offset += file->f_pos;
+	}
+	retval = -EINVAL;
+
+	if (offset >= 0){
+		if (offset != file->f_pos)
+			file->f_pos = offset;
+
+		retval = offset;
+	}
+	unlock_kernel();
+	return retval;
+}
+
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+{
+	yaffs_obj_t *obj;
+	yaffs_dev_t *dev;
+        struct yaffs_SearchContext *sc;
+	struct inode *inode = f->f_dentry->d_inode;
+	unsigned long offset, curoffs;
+	yaffs_obj_t *l;
+        int retVal = 0;
+
+	char name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_dev_to_lc(dev)->readdirProcess = current;
+
+	offset = f->f_pos;
+
+        sc = yaffs_NewSearch(obj);
+        if(!sc){
+                retVal = -ENOMEM;
+                goto out;
+        }
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_readdir: starting at %d\n"), (int)offset));
+
+	if (offset == 0) {
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_readdir: entry . ino %d \n"),
+			(int)inode->i_ino));
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0){
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+	if (offset == 1) {
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_readdir: entry .. ino %d \n"),
+			(int)f->f_dentry->d_parent->d_inode->i_ino));
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, "..", 2, offset,
+			f->f_dentry->d_parent->d_inode->i_ino, DT_DIR) < 0){
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+
+	curoffs = 1;
+
+	/* If the directory has changed since the open or last call to
+	   readdir, rewind to after the 2 canned entries. */
+	if (f->f_version != inode->i_version) {
+		offset = 2;
+		f->f_pos = offset;
+		f->f_version = inode->i_version;
+	}
+
+	while(sc->nextReturn){
+		curoffs++;
+                l = sc->nextReturn;
+		if (curoffs >= offset) {
+                        int this_inode = yaffs_get_obj_inode(l);
+                        int this_type = yaffs_get_obj_type(l);
+
+			yaffs_get_obj_name(l, name,
+					    YAFFS_MAX_NAME_LENGTH + 1);
+			T(YAFFS_TRACE_OS,
+			  (TSTR("yaffs_readdir: %s inode %d\n"),
+			  name, yaffs_get_obj_inode(l)));
+
+                        yaffs_gross_unlock(dev);
+
+			if (filldir(dirent,
+					name,
+					strlen(name),
+					offset,
+					this_inode,
+					this_type) < 0){
+				yaffs_gross_lock(dev);
+				goto out;
+			}
+
+                        yaffs_gross_lock(dev);
+
+			offset++;
+			f->f_pos++;
+		}
+                yaffs_search_advance(sc);
+	}
+
+out:
+	yaffs_search_end(sc);
+	yaffs_dev_to_lc(dev)->readdirProcess = NULL;
+	yaffs_gross_unlock(dev);
+
+	return retVal;
+}
+
+
+
+/*
+ * File creation. Allocate an inode, and we're done..
+ */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+#define YCRED(x) x
+#else
+#define YCRED(x) (x->cred)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			dev_t rdev)
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			int rdev)
+#endif
+{
+	struct inode *inode;
+
+	yaffs_obj_t *obj = NULL;
+	yaffs_dev_t *dev;
+
+	yaffs_obj_t *parent = yaffs_InodeToObject(dir);
+
+	int error = -ENOSPC;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
+
+	if (parent) {
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_mknod: parent object %d type %d\n"),
+			parent->obj_id, parent->variant_type));
+	} else {
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_mknod: could not get parent object\n")));
+		return -EPERM;
+	}
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_mknod: making oject for %s, "
+			"mode %x dev %x\n"),
+			dentry->d_name.name, mode, rdev));
+
+	dev = parent->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		T(YAFFS_TRACE_OS, (TSTR("yaffs_mknod: making special\n")));
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+		obj = yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+				gid, old_encode_dev(rdev));
+#else
+		obj = yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+				gid, rdev);
+#endif
+		break;
+	case S_IFREG:		/* file          */
+		T(YAFFS_TRACE_OS, (TSTR("yaffs_mknod: making file\n")));
+		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
+				gid);
+		break;
+	case S_IFDIR:		/* directory */
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_mknod: making directory\n")));
+		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
+					uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		T(YAFFS_TRACE_OS, (TSTR("yaffs_mknod: making symlink\n")));
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
+
+	/* Can not call yaffs_get_inode() with gross lock held */
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_mknod created object %d count = %d\n"),
+			obj->obj_id, atomic_read(&inode->i_count)));
+		error = 0;
+		yaffs_fill_inode_from_obj(dir,parent);
+	} else {
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_mknod failed making object\n")));
+		error = -ENOMEM;
+	}
+
+	return error;
+}
+
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int retVal;
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_mkdir\n")));
+	retVal = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	return retVal;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	T(YAFFS_TRACE_OS,(TSTR("yaffs_create\n")));
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int retVal;
+
+	yaffs_dev_t *dev;
+	yaffs_obj_t *obj;
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_unlink %d:%s\n"),
+		(int)(dir->i_ino),
+		dentry->d_name.name));
+	obj = yaffs_InodeToObject(dir);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	retVal = yaffs_unlinker(obj, dentry->d_name.name);
+
+	if (retVal == YAFFS_OK) {
+		dentry->d_inode->i_nlink--;
+		dir->i_version++;
+		yaffs_gross_unlock(dev);
+		mark_inode_dirty(dentry->d_inode);
+		update_dir_time(dir);
+		return 0;
+	}
+	yaffs_gross_unlock(dev);
+	return -ENOTEMPTY;
+}
+
+/*
+ * Create a link...
+ */
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	yaffs_obj_t *obj = NULL;
+	yaffs_obj_t *link = NULL;
+	yaffs_dev_t *dev;
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_link\n")));
+
+	obj = yaffs_InodeToObject(inode);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	if (!S_ISDIR(inode->i_mode))		/* Don't link directories */
+		link = yaffs_link_obj(yaffs_InodeToObject(dir), dentry->d_name.name,
+			obj);
+
+	if (link) {
+		old_dentry->d_inode->i_nlink = yaffs_get_obj_link_count(obj);
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+		T(YAFFS_TRACE_OS,
+			(TSTR("yaffs_link link count %d i_count %d\n"),
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count)));
+	}
+
+	yaffs_gross_unlock(dev);
+
+	if (link){
+		update_dir_time(dir);
+		return 0;
+	}
+
+	return -EPERM;
+}
+
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+				const char *symname)
+{
+	yaffs_obj_t *obj;
+	yaffs_dev_t *dev;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_symlink\n")));
+
+	dev = yaffs_InodeToObject(dir)->my_dev;
+	yaffs_gross_lock(dev);
+	obj = yaffs_create_symlink(yaffs_InodeToObject(dir), dentry->d_name.name,
+				S_IFLNK | S_IRWXUGO, uid, gid, symname);
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		struct inode *inode;
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		T(YAFFS_TRACE_OS, (TSTR("symlink created OK\n")));
+		return 0;
+	} else {
+		T(YAFFS_TRACE_OS, (TSTR("symlink not created\n")));
+	}
+
+	return -ENOMEM;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync)
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+				int datasync)
+#endif
+{
+
+	yaffs_obj_t *obj;
+	yaffs_dev_t *dev;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+	struct dentry *dentry = file->f_path.dentry;
+#endif
+
+	obj = yaffs_dentry_to_obj(dentry);
+
+	dev = obj->my_dev;
+
+	T(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		(TSTR("yaffs_sync_object\n")));
+	yaffs_gross_lock(dev);
+	yaffs_flush_file(obj, 1, datasync);
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
+{
+	yaffs_dev_t *dev;
+	int retVal = YAFFS_FAIL;
+	yaffs_obj_t *target;
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_rename\n")));
+	dev = yaffs_InodeToObject(old_dir)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_find_by_name(yaffs_InodeToObject(new_dir),
+				new_dentry->d_name.name);
+
+
+
+	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+		!ylist_empty(&target->variant.dir_variant.children)) {
+
+		T(YAFFS_TRACE_OS, (TSTR("target is non-empty dir\n")));
+
+		retVal = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		T(YAFFS_TRACE_OS, (TSTR("calling yaffs_rename_obj\n")));
+
+		retVal = yaffs_rename_obj(yaffs_InodeToObject(old_dir),
+				old_dentry->d_name.name,
+				yaffs_InodeToObject(new_dir),
+				new_dentry->d_name.name);
+	}
+	yaffs_gross_unlock(dev);
+
+	if (retVal == YAFFS_OK) {
+		if (target) {
+			new_dentry->d_inode->i_nlink--;
+			mark_inode_dirty(new_dentry->d_inode);
+		}
+		
+		update_dir_time(old_dir);
+		if(old_dir != new_dir)
+			update_dir_time(new_dir);
+		return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	yaffs_dev_t *dev;
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_setattr of object %d\n"),
+		yaffs_InodeToObject(inode)->obj_id));
+
+	/* Fail if a requested resize >= 2GB */		
+	if (attr->ia_valid & ATTR_SIZE &&
+		(attr->ia_size >> 31))
+		error = -EINVAL;
+
+	if (error == 0)
+		error = inode_change_ok(inode, attr);
+	if (error == 0) {
+		int result;
+		if (!error){
+			error = yaffs_vfs_setattr(inode, attr);
+			T(YAFFS_TRACE_OS,(TSTR("inode_setattr called\n")));
+			if (attr->ia_valid & ATTR_SIZE){
+                        	yaffs_vfs_setsize(inode,attr->ia_size);
+                        	inode->i_blocks = (inode->i_size + 511) >> 9;
+			}
+		}
+		dev = yaffs_InodeToObject(inode)->my_dev;
+		if (attr->ia_valid & ATTR_SIZE){
+			T(YAFFS_TRACE_OS,(TSTR("resize to %d(%x)\n"),
+				(int)(attr->ia_size),(int)(attr->ia_size)));
+		}
+		yaffs_gross_lock(dev);
+		result = yaffs_set_attribs(yaffs_InodeToObject(inode), attr);
+		if(result == YAFFS_OK) {
+			error = 0;
+		} else {
+			error = -EPERM;
+		}
+		yaffs_gross_unlock(dev);
+
+	}
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_setattr done returning %d\n"),error));
+
+	return error;
+}
+
+#ifdef CONFIG_YAFFS_XATTR
+int yaffs_setxattr(struct dentry *dentry, const char *name,
+			const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	yaffs_dev_t *dev;
+	yaffs_obj_t *obj = yaffs_InodeToObject(inode);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_setxattr of object %d\n"),
+		obj->obj_id));
+
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_set_xattrib(obj, name, value, size, flags);
+		if(result == YAFFS_OK)
+			error = 0;
+		else if(result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_setxattr done returning %d\n"),error));
+
+	return error;
+}
+
+
+ssize_t yaffs_getxattr(struct dentry *dentry, const char *name, void *buff,
+			size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	yaffs_dev_t *dev;
+	yaffs_obj_t *obj = yaffs_InodeToObject(inode);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_getxattr \"%s\" from object %d\n"),
+		name, obj->obj_id));
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_get_xattrib(obj, name, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_getxattr done returning %d\n"),error));
+
+	return error;
+}
+
+int yaffs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	yaffs_dev_t *dev;
+	yaffs_obj_t *obj = yaffs_InodeToObject(inode);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_removexattr of object %d\n"),
+		obj->obj_id));
+
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_remove_xattrib(obj, name);
+		if(result == YAFFS_OK)
+			error = 0;
+		else if(result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_removexattr done returning %d\n"),error));
+
+	return error;
+}
+
+ssize_t yaffs_listxattr(struct dentry *dentry, char *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	yaffs_dev_t *dev;
+	yaffs_obj_t *obj = yaffs_InodeToObject(inode);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_listxattr of object %d\n"),
+		obj->obj_id));
+
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_list_xattrib(obj, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_listxattr done returning %d\n"),error));
+
+	return error;
+}
+
+#endif
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	yaffs_dev_t *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+	struct super_block *sb = dentry->d_sb;
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	yaffs_dev_t *dev = yaffs_SuperToDevice(sb);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
+{
+	yaffs_dev_t *dev = yaffs_SuperToDevice(sb);
+#endif
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_statfs\n")));
+
+	yaffs_gross_lock(dev);
+
+	buf->f_type = YAFFS_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_namelen = 255;
+
+	if (dev->data_bytes_per_chunk & (dev->data_bytes_per_chunk - 1)) {
+		/* Do this if chunk size is not a power of 2 */
+
+		uint64_t bytesInDev;
+		uint64_t bytesFree;
+
+		bytesInDev = ((uint64_t)((dev->param.end_block - dev->param.start_block + 1))) *
+			((uint64_t)(dev->param.chunks_per_block * dev->data_bytes_per_chunk));
+
+		do_div(bytesInDev, sb->s_blocksize); /* bytesInDev becomes the number of blocks */
+		buf->f_blocks = bytesInDev;
+
+		bytesFree  = ((uint64_t)(yaffs_get_n_free_chunks(dev))) *
+			((uint64_t)(dev->data_bytes_per_chunk));
+
+		do_div(bytesFree, sb->s_blocksize);
+
+		buf->f_bfree = bytesFree;
+
+	} else if (sb->s_blocksize > dev->data_bytes_per_chunk) {
+
+		buf->f_blocks =
+			(dev->param.end_block - dev->param.start_block + 1) *
+			dev->param.chunks_per_block /
+			(sb->s_blocksize / dev->data_bytes_per_chunk);
+		buf->f_bfree =
+			yaffs_get_n_free_chunks(dev) /
+			(sb->s_blocksize / dev->data_bytes_per_chunk);
+	} else {
+		buf->f_blocks =
+			(dev->param.end_block - dev->param.start_block + 1) *
+			dev->param.chunks_per_block *
+			(dev->data_bytes_per_chunk / sb->s_blocksize);
+
+		buf->f_bfree =
+			yaffs_get_n_free_chunks(dev) *
+			(dev->data_bytes_per_chunk / sb->s_blocksize);
+	}
+
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_bavail = buf->f_bfree;
+
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+
+
+static void yaffs_flush_inodes(struct super_block *sb)
+{
+	struct inode *iptr;
+	yaffs_obj_t *obj;
+	
+	list_for_each_entry(iptr,&sb->s_inodes, i_sb_list){
+		obj = yaffs_InodeToObject(iptr);
+		if(obj){
+			T(YAFFS_TRACE_OS, (TSTR("flushing obj %d\n"),
+				obj->obj_id));
+			yaffs_flush_file(obj,1,0);
+		}
+	}
+}
+
+
+static void yaffs_flush_super(struct super_block *sb, int do_checkpoint)
+{
+	yaffs_dev_t *dev = yaffs_SuperToDevice(sb);	
+	if(!dev)
+		return;
+	
+	yaffs_flush_inodes(sb);
+	yaffs_update_dirty_dirs(dev);
+	yaffs_flush_whole_cache(dev);
+	if(do_checkpoint)
+		yaffs_checkpoint_save(dev);
+}
+
+
+static unsigned yaffs_bg_gc_urgency(yaffs_dev_t *dev)
+{
+	unsigned erasedChunks = dev->n_erased_blocks * dev->param.chunks_per_block;
+	struct yaffs_LinuxContext *context = yaffs_dev_to_lc(dev);
+	unsigned scatteredFree = 0; /* Free chunks not in an erased block */
+
+	if(erasedChunks < dev->n_free_chunks)
+		scatteredFree = (dev->n_free_chunks - erasedChunks);
+
+	if(!context->bgRunning)
+		return 0;
+	else if(scatteredFree < (dev->param.chunks_per_block * 2))
+		return 0;
+	else if(erasedChunks > dev->n_free_chunks/2)
+		return 0;
+	else if(erasedChunks > dev->n_free_chunks/4)
+		return 1;
+	else
+		return 2;
+}
+
+static int yaffs_do_sync_fs(struct super_block *sb,
+				int request_checkpoint)
+{
+
+	yaffs_dev_t *dev = yaffs_SuperToDevice(sb);
+	unsigned int oneshot_checkpoint = (yaffs_auto_checkpoint & 4);
+	unsigned gc_urgent = yaffs_bg_gc_urgency(dev);
+	int do_checkpoint;
+
+	T(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		(TSTR("yaffs_do_sync_fs: gc-urgency %d %s %s%s\n"),
+		gc_urgent,
+		sb->s_dirt ? "dirty" : "clean",
+		request_checkpoint ? "checkpoint requested" : "no checkpoint",
+		oneshot_checkpoint ? " one-shot" : "" ));
+
+	yaffs_gross_lock(dev);
+	do_checkpoint = ((request_checkpoint && !gc_urgent) ||
+			oneshot_checkpoint) &&
+			!dev->is_checkpointed;
+
+	if (sb->s_dirt || do_checkpoint) {
+		yaffs_flush_super(sb, !dev->is_checkpointed && do_checkpoint);
+		sb->s_dirt = 0;
+		if(oneshot_checkpoint)
+			yaffs_auto_checkpoint &= ~4;
+	}
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+/*
+ * yaffs background thread functions .
+ * yaffs_bg_thread_fn() the thread function
+ * yaffs_bg_start() launches the background thread.
+ * yaffs_bg_stop() cleans up the background thread.
+ *
+ * NB: 
+ * The thread should only run after the yaffs is initialised
+ * The thread should be stopped before yaffs is unmounted.
+ * The thread should not do any writing while the fs is in read only.
+ */
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+
+void yaffs_background_waker(unsigned long data)
+{
+	wake_up_process((struct task_struct *)data);
+}
+
+static int yaffs_bg_thread_fn(void *data)
+{
+	yaffs_dev_t *dev = (yaffs_dev_t *)data;
+	struct yaffs_LinuxContext *context = yaffs_dev_to_lc(dev);
+	unsigned long now = jiffies;
+	unsigned long next_dir_update = now;
+	unsigned long next_gc = now;
+	unsigned long expires;
+	unsigned int urgency;
+
+	int gcResult;
+	struct timer_list timer;
+
+	T(YAFFS_TRACE_BACKGROUND,
+		(TSTR("yaffs_background starting for dev %p\n"),
+		(void *)dev));
+
+#ifdef YAFFS_COMPILE_FREEZER
+	set_freezable();
+#endif
+	while(context->bgRunning){
+		T(YAFFS_TRACE_BACKGROUND,
+			(TSTR("yaffs_background\n")));
+
+		if(kthread_should_stop())
+			break;
+
+#ifdef YAFFS_COMPILE_FREEZER
+		if(try_to_freeze())
+			continue;
+#endif
+		yaffs_gross_lock(dev);
+
+		now = jiffies;
+
+		if(time_after(now, next_dir_update) && yaffs_bg_enable){
+			yaffs_update_dirty_dirs(dev);
+			next_dir_update = now + HZ;
+		}
+
+		if(time_after(now,next_gc) && yaffs_bg_enable){
+			if(!dev->is_checkpointed){
+				urgency = yaffs_bg_gc_urgency(dev);
+				gcResult = yaffs_bg_gc(dev, urgency);
+				if(urgency > 1)
+					next_gc = now + HZ/20+1;
+				else if(urgency > 0)
+					next_gc = now + HZ/10+1;
+				else
+					next_gc = now + HZ * 2;
+			} else /*
+				* gc not running so set to next_dir_update
+				* to cut down on wake ups
+				*/
+				next_gc = next_dir_update;
+		}
+		yaffs_gross_unlock(dev);
+#if 1
+		expires = next_dir_update;
+		if (time_before(next_gc,expires))
+			expires = next_gc;
+		if(time_before(expires,now))
+			expires = now + HZ;
+
+		Y_INIT_TIMER(&timer);
+		timer.expires = expires+1;
+		timer.data = (unsigned long) current;
+		timer.function = yaffs_background_waker;
+
+                set_current_state(TASK_INTERRUPTIBLE);
+		add_timer(&timer);
+		schedule();
+		del_timer_sync(&timer);
+#else
+		msleep(10);
+#endif
+	}
+
+	return 0;
+}
+
+static int yaffs_bg_start(yaffs_dev_t *dev)
+{
+	int retval = 0;
+	struct yaffs_LinuxContext *context = yaffs_dev_to_lc(dev);
+
+	if(dev->read_only)
+		return -1;
+
+	context->bgRunning = 1;
+
+	context->bgThread = kthread_run(yaffs_bg_thread_fn,
+	                        (void *)dev,"yaffs-bg-%d",context->mount_id);
+
+	if(IS_ERR(context->bgThread)){
+		retval = PTR_ERR(context->bgThread);
+		context->bgThread = NULL;
+		context->bgRunning = 0;
+	}
+	return retval;
+}
+
+static void yaffs_bg_stop(yaffs_dev_t *dev)
+{
+	struct yaffs_LinuxContext *ctxt = yaffs_dev_to_lc(dev);
+
+	ctxt->bgRunning = 0;
+
+	if( ctxt->bgThread){
+		kthread_stop(ctxt->bgThread);
+		ctxt->bgThread = NULL;
+	}
+}
+#else
+static int yaffs_bg_thread_fn(void *data)
+{
+	return 0;
+}
+
+static int yaffs_bg_start(yaffs_dev_t *dev)
+{
+	return 0;
+}
+
+static void yaffs_bg_stop(yaffs_dev_t *dev)
+{
+}
+#endif
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static void yaffs_write_super(struct super_block *sb)
+#else
+static int yaffs_write_super(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 2);
+
+	T(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		(TSTR("yaffs_write_super%s\n"),
+		request_checkpoint ? " checkpt" : ""));
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+	return 0;
+#endif
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait)
+#else
+static int yaffs_sync_fs(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 1);
+
+	T(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		(TSTR("yaffs_sync_fs%s\n"),
+		request_checkpoint ? " checkpt" : ""));
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+	return 0;
+}
+
+#ifdef YAFFS_USE_OWN_IGET
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	yaffs_obj_t *obj;
+	yaffs_dev_t *dev = yaffs_SuperToDevice(sb);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_iget for %lu\n"), ino));
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	yaffs_gross_unlock(dev);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+
+#else
+
+static void yaffs_read_inode(struct inode *inode)
+{
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_obj_t *obj;
+	yaffs_dev_t *dev = yaffs_SuperToDevice(inode->i_sb);
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_read_inode for %d\n"), (int)inode->i_ino));
+
+	if(current != yaffs_dev_to_lc(dev)->readdirProcess)
+		yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	if(current != yaffs_dev_to_lc(dev)->readdirProcess)
+		yaffs_gross_unlock(dev);
+}
+
+#endif
+
+static YLIST_HEAD(yaffs_context_list);
+struct semaphore yaffs_context_lock;
+
+static void yaffs_put_super(struct super_block *sb)
+{
+	yaffs_dev_t *dev = yaffs_SuperToDevice(sb);
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_put_super\n")));
+
+	T(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		(TSTR("Shutting down yaffs background thread\n")));
+	yaffs_bg_stop(dev);
+	T(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		(TSTR("yaffs background thread shut down\n")));
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_super(sb,1);
+
+	if (yaffs_dev_to_lc(dev)->putSuperFunc)
+		yaffs_dev_to_lc(dev)->putSuperFunc(sb);
+
+
+	yaffs_deinitialise(dev);
+
+	yaffs_gross_unlock(dev);
+
+	down(&yaffs_context_lock);
+	ylist_del_init(&(yaffs_dev_to_lc(dev)->contextList));
+	up(&yaffs_context_lock);
+
+	if (yaffs_dev_to_lc(dev)->spareBuffer) {
+		YFREE(yaffs_dev_to_lc(dev)->spareBuffer);
+		yaffs_dev_to_lc(dev)->spareBuffer = NULL;
+	}
+
+	kfree(dev);
+}
+
+
+static void yaffs_MTDPutSuper(struct super_block *sb)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(yaffs_SuperToDevice(sb));
+
+	if (mtd->sync)
+		mtd->sync(mtd);
+
+	put_mtd_device(mtd);
+}
+
+
+static void yaffs_touch_super(yaffs_dev_t *dev)
+{
+	struct super_block *sb = yaffs_dev_to_lc(dev)->superBlock;
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_touch_super() sb = %p\n"), sb));
+	if (sb)
+		sb->s_dirt = 1;
+}
+
+typedef struct {
+	int inband_tags;
+	int skip_checkpoint_read;
+	int skip_checkpoint_write;
+	int no_cache;
+	int tags_ecc_on;
+	int tags_ecc_overridden;
+	int lazy_loading_enabled;
+	int lazy_loading_overridden;
+	int empty_lost_and_found;
+	int empty_lost_and_found_overridden;
+} yaffs_options;
+
+#define MAX_OPT_LEN 30
+static int yaffs_parse_options(yaffs_options *options, const char *options_str)
+{
+	char cur_opt[MAX_OPT_LEN + 1];
+	int p;
+	int error = 0;
+
+	/* Parse through the options which is a comma seperated list */
+
+	while (options_str && *options_str && !error) {
+		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+		p = 0;
+
+		while(*options_str == ',')
+			options_str++;
+
+		while (*options_str && *options_str != ',') {
+			if (p < MAX_OPT_LEN) {
+				cur_opt[p] = *options_str;
+				p++;
+			}
+			options_str++;
+		}
+
+		if (!strcmp(cur_opt, "inband-tags"))
+			options->inband_tags = 1;
+		else if (!strcmp(cur_opt, "tags-ecc-off")){
+			options->tags_ecc_on = 0;
+			options->tags_ecc_overridden=1;
+		} else if (!strcmp(cur_opt, "tags-ecc-on")){
+			options->tags_ecc_on = 1;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-off")){
+			options->lazy_loading_enabled = 0;
+			options->lazy_loading_overridden=1;
+		} else if (!strcmp(cur_opt, "lazy-loading-on")){
+			options->lazy_loading_enabled = 1;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")){
+			options->empty_lost_and_found = 0;
+			options->empty_lost_and_found_overridden=1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-on")){
+			options->empty_lost_and_found = 1;
+			options->empty_lost_and_found_overridden=1;
+		} else if (!strcmp(cur_opt, "no-cache"))
+			options->no_cache = 1;
+		else if (!strcmp(cur_opt, "no-checkpoint-read"))
+			options->skip_checkpoint_read = 1;
+		else if (!strcmp(cur_opt, "no-checkpoint-write"))
+			options->skip_checkpoint_write = 1;
+		else if (!strcmp(cur_opt, "no-checkpoint")) {
+			options->skip_checkpoint_read = 1;
+			options->skip_checkpoint_write = 1;
+		} else {
+			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+					cur_opt);
+			error = 1;
+		}
+	}
+
+	return error;
+}
+
+static struct super_block *yaffs_internal_read_super(int yaffs_version,
+						struct super_block *sb,
+						void *data, int silent)
+{
+	int nBlocks;
+	struct inode *inode = NULL;
+	struct dentry *root;
+	yaffs_dev_t *dev = 0;
+	char devname_buf[BDEVNAME_SIZE + 1];
+	struct mtd_info *mtd;
+	int err;
+	char *data_str = (char *)data;
+	struct yaffs_LinuxContext *context = NULL;
+	yaffs_param_t *param;
+
+	int read_only = 0;
+
+	yaffs_options options;
+
+	unsigned mount_id;
+	int found;
+	struct yaffs_LinuxContext *context_iterator;
+	struct ylist_head *l;
+
+	sb->s_magic = YAFFS_MAGIC;
+	sb->s_op = &yaffs_super_ops;
+	sb->s_flags |= MS_NOATIME;
+
+	read_only =((sb->s_flags & MS_RDONLY) != 0);
+
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+	sb->s_export_op = &yaffs_export_ops;
+#endif
+
+	if (!sb)
+		printk(KERN_INFO "yaffs: sb is NULL\n");
+	else if (!sb->s_dev)
+		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
+	else if (!yaffs_devname(sb, devname_buf))
+		printk(KERN_INFO "yaffs: devname is NULL\n");
+	else
+		printk(KERN_INFO "yaffs: dev is %d name is \"%s\" %s\n",
+		       sb->s_dev,
+		       yaffs_devname(sb, devname_buf),
+		       read_only ? "ro" : "rw");
+
+	if (!data_str)
+		data_str = "";
+
+	printk(KERN_INFO "yaffs: passed flags \"%s\"\n", data_str);
+
+	memset(&options, 0, sizeof(options));
+
+	if (yaffs_parse_options(&options, data_str)) {
+		/* Option parsing failed */
+		return NULL;
+	}
+
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_read_super: Using yaffs%d\n"), yaffs_version));
+	T(YAFFS_TRACE_OS,
+		(TSTR("yaffs_read_super: block size %d\n"),
+		(int)(sb->s_blocksize)));
+
+	T(YAFFS_TRACE_ALWAYS,
+		(TSTR("yaffs: Attempting MTD mount of %u.%u,\"%s\"\n"),
+	       MAJOR(sb->s_dev), MINOR(sb->s_dev),
+	       yaffs_devname(sb, devname_buf)));
+
+	/* Check it's an mtd device..... */
+	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR)
+		return NULL;	/* This isn't an mtd device */
+
+	/* Get the device */
+	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!mtd) {
+		T(YAFFS_TRACE_ALWAYS,
+			(TSTR("yaffs: MTD device #%u doesn't appear to exist\n"),
+			MINOR(sb->s_dev)));
+		return NULL;
+	}
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		T(YAFFS_TRACE_ALWAYS,
+			(TSTR("yaffs: MTD device is not NAND it's type %d\n"),
+			mtd->type));
+		return NULL;
+	}
+
+	T(YAFFS_TRACE_OS, (TSTR(" erase %p\n"), mtd->erase));
+	T(YAFFS_TRACE_OS, (TSTR(" read %p\n"), mtd->read));
+	T(YAFFS_TRACE_OS, (TSTR(" write %p\n"), mtd->write));
+	T(YAFFS_TRACE_OS, (TSTR(" readoob %p\n"), mtd->read_oob));
+	T(YAFFS_TRACE_OS, (TSTR(" writeoob %p\n"), mtd->write_oob));
+	T(YAFFS_TRACE_OS, (TSTR(" block_isbad %p\n"), mtd->block_isbad));
+	T(YAFFS_TRACE_OS, (TSTR(" block_markbad %p\n"), mtd->block_markbad));
+	T(YAFFS_TRACE_OS, (TSTR(" %s %d\n"), WRITE_SIZE_STR, WRITE_SIZE(mtd)));
+	T(YAFFS_TRACE_OS, (TSTR(" oobsize %d\n"), mtd->oobsize));
+	T(YAFFS_TRACE_OS, (TSTR(" erasesize %d\n"), mtd->erasesize));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+	T(YAFFS_TRACE_OS, (TSTR(" size %u\n"), mtd->size));
+#else
+	T(YAFFS_TRACE_OS, (TSTR(" size %lld\n"), mtd->size));
+#endif
+
+#ifdef CONFIG_YAFFS_AUTO_YAFFS2
+
+	if (yaffs_version == 1 && WRITE_SIZE(mtd) >= 2048) {
+		T(YAFFS_TRACE_ALWAYS,
+			(TSTR("yaffs: auto selecting yaffs2\n")));
+		yaffs_version = 2;
+	}
+
+	/* Added NCB 26/5/2006 for completeness */
+	if (yaffs_version == 2 && !options.inband_tags && WRITE_SIZE(mtd) == 512) {
+		T(YAFFS_TRACE_ALWAYS,
+			(TSTR("yaffs: auto selecting yaffs1\n")));
+		yaffs_version = 1;
+	}
+
+#endif
+
+	if (yaffs_version == 2) {
+		/* Check for version 2 style functions */
+		if (!mtd->erase ||
+		    !mtd->block_isbad ||
+		    !mtd->block_markbad ||
+		    !mtd->read ||
+		    !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			T(YAFFS_TRACE_ALWAYS,
+			  (TSTR("yaffs: MTD device does not support required "
+			   "functions\n")));
+			return NULL;
+		}
+
+		if ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+		    mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+		    !options.inband_tags) {
+			T(YAFFS_TRACE_ALWAYS,
+			  (TSTR("yaffs: MTD device does not have the "
+			   "right page sizes\n")));
+			return NULL;
+		}
+	} else {
+		/* Check for V1 style functions */
+		if (!mtd->erase ||
+		    !mtd->read ||
+		    !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			T(YAFFS_TRACE_ALWAYS,
+			  (TSTR("yaffs: MTD device does not support required "
+			   "functions\n")));
+			return NULL;
+		}
+
+		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
+		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+			T(YAFFS_TRACE_ALWAYS,
+			  (TSTR("yaffs: MTD device does not support have the "
+			   "right page sizes\n")));
+			return NULL;
+		}
+	}
+
+	/* OK, so if we got here, we have an MTD that's NAND and looks
+	 * like it has the right capabilities
+	 * Set the yaffs_dev_t up for mtd
+	 */
+
+	if (!read_only && !(mtd->flags & MTD_WRITEABLE)){
+		read_only = 1;
+		printk(KERN_INFO "yaffs: mtd is read only, setting superblock read only");
+		sb->s_flags |= MS_RDONLY;
+	}
+
+	dev = kmalloc(sizeof(yaffs_dev_t), GFP_KERNEL);
+	context = kmalloc(sizeof(struct yaffs_LinuxContext),GFP_KERNEL);
+	
+	if(!dev || !context ){
+		if(dev)
+			kfree(dev);
+		if(context)
+			kfree(context);
+		dev = NULL;
+		context = NULL;
+	}
+
+	if (!dev) {
+		/* Deep shit could not allocate device structure */
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs_read_super: Failed trying to allocate "
+		   "yaffs_dev_t. \n")));
+		return NULL;
+	}
+	memset(dev, 0, sizeof(yaffs_dev_t));
+	param = &(dev->param);
+
+	memset(context,0,sizeof(struct yaffs_LinuxContext));
+	dev->os_context = context;
+	YINIT_LIST_HEAD(&(context->contextList));
+	context->dev = dev;
+	context->superBlock = sb;
+
+	dev->read_only = read_only;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	sb->s_fs_info = dev;
+#else
+	sb->u.generic_sbp = dev;
+#endif
+	
+	dev->driver_context = mtd;
+	param->name = mtd->name;
+
+	/* Set up the memory size parameters.... */
+
+	nBlocks = YCALCBLOCKS(mtd->size, (YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
+
+	param->start_block = 0;
+	param->end_block = nBlocks - 1;
+	param->chunks_per_block = YAFFS_CHUNKS_PER_BLOCK;
+	param->total_bytes_per_chunk = YAFFS_BYTES_PER_CHUNK;
+	param->n_reserved_blocks = 5;
+	param->n_caches = (options.no_cache) ? 0 : 10;
+	param->inband_tags = options.inband_tags;
+
+#ifdef CONFIG_YAFFS_DISABLE_LAZY_LOAD
+	param->disable_lazy_load = 1;
+#endif
+#ifdef CONFIG_YAFFS_XATTR
+	param->enable_xattr = 1;
+#endif
+	if(options.lazy_loading_overridden)
+		param->disable_lazy_load = !options.lazy_loading_enabled;
+
+#ifdef CONFIG_YAFFS_DISABLE_TAGS_ECC
+	param->no_tags_ecc = 1;
+#endif
+
+#ifdef CONFIG_YAFFS_DISABLE_BACKGROUND
+#else
+	param->defered_dir_update = 1;
+#endif
+
+	if(options.tags_ecc_overridden)
+		param->no_tags_ecc = !options.tags_ecc_on;
+
+#ifdef CONFIG_YAFFS_EMPTY_LOST_AND_FOUND
+	param->empty_lost_n_found = 1;
+#endif
+
+#ifdef CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING
+	param->refresh_period = 0;
+#else
+	param->refresh_period = 500;
+#endif
+
+#ifdef CONFIG_YAFFS__ALWAYS_CHECK_CHUNK_ERASED
+	param->always_check_erased = 1;
+#endif
+
+	if(options.empty_lost_and_found_overridden)
+		param->empty_lost_n_found = options.empty_lost_and_found;
+
+	/* ... and the functions. */
+	if (yaffs_version == 2) {
+		param->write_chunk_tags_fn =
+		    nandmtd2_WriteChunkWithTagsToNAND;
+		param->read_chunk_tags_fn =
+		    nandmtd2_ReadChunkWithTagsFromNAND;
+		param->bad_block_fn = nandmtd2_MarkNANDBlockBad;
+		param->query_block_fn = nandmtd2_QueryNANDBlock;
+		yaffs_dev_to_lc(dev)->spareBuffer = YMALLOC(mtd->oobsize);
+		param->is_yaffs2 = 1;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		param->total_bytes_per_chunk = mtd->writesize;
+		param->chunks_per_block = mtd->erasesize / mtd->writesize;
+#else
+		param->total_bytes_per_chunk = mtd->oobblock;
+		param->chunks_per_block = mtd->erasesize / mtd->oobblock;
+#endif
+		nBlocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
+
+		param->start_block = 0;
+		param->end_block = nBlocks - 1;
+	} else {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		/* use the MTD interface in yaffs_mtdif1.c */
+		param->write_chunk_tags_fn =
+			nandmtd1_WriteChunkWithTagsToNAND;
+		param->read_chunk_tags_fn =
+			nandmtd1_ReadChunkWithTagsFromNAND;
+		param->bad_block_fn = nandmtd1_MarkNANDBlockBad;
+		param->query_block_fn = nandmtd1_QueryNANDBlock;
+#else
+		param->write_chunk_fn = nandmtd_WriteChunkToNAND;
+		param->read_chunk_fn = nandmtd_ReadChunkFromNAND;
+#endif
+		param->is_yaffs2 = 0;
+	}
+	/* ... and common functions */
+	param->erase_fn = nandmtd_EraseBlockInNAND;
+	param->initialise_flash_fn = nandmtd_InitialiseNAND;
+
+	yaffs_dev_to_lc(dev)->putSuperFunc = yaffs_MTDPutSuper;
+
+	param->sb_dirty_fn = yaffs_touch_super;
+	param->gc_control = yaffs_gc_control_callback;
+
+	yaffs_dev_to_lc(dev)->superBlock= sb;
+	
+
+#ifndef CONFIG_YAFFS_DOES_ECC
+	param->use_nand_ecc = 1;
+#endif
+
+#ifdef CONFIG_YAFFS_DISABLE_WIDE_TNODES
+	param->wide_tnodes_disabled = 1;
+#endif
+
+	param->skip_checkpt_rd = options.skip_checkpoint_read;
+	param->skip_checkpt_wr = options.skip_checkpoint_write;
+
+	down(&yaffs_context_lock);
+	/* Get a mount id */
+	found = 0;
+	for(mount_id=0; ! found; mount_id++){
+		found = 1;
+		ylist_for_each(l,&yaffs_context_list){
+			context_iterator = ylist_entry(l,struct yaffs_LinuxContext,contextList);
+			if(context_iterator->mount_id == mount_id)
+				found = 0;
+		}
+	}
+	context->mount_id = mount_id;
+
+	ylist_add_tail(&(yaffs_dev_to_lc(dev)->contextList), &yaffs_context_list);
+	up(&yaffs_context_lock);
+
+        /* Directory search handling...*/
+        YINIT_LIST_HEAD(&(yaffs_dev_to_lc(dev)->searchContexts));
+        param->remove_obj_fn = yaffs_remove_obj_callback;
+
+	init_MUTEX(&(yaffs_dev_to_lc(dev)->grossLock));
+
+	yaffs_gross_lock(dev);
+
+	err = yaffs_guts_initialise(dev);
+
+	T(YAFFS_TRACE_OS,
+	  (TSTR("yaffs_read_super: guts initialised %s\n"),
+	   (err == YAFFS_OK) ? "OK" : "FAILED"));
+	   
+	if(err == YAFFS_OK)
+		yaffs_bg_start(dev);
+		
+	if(!context->bgThread)
+		param->defered_dir_update = 0;
+
+
+	/* Release lock before yaffs_get_inode() */
+	yaffs_gross_unlock(dev);
+
+	/* Create root inode */
+	if (err == YAFFS_OK)
+		inode = yaffs_get_inode(sb, S_IFDIR | 0755, 0,
+					yaffs_root(dev));
+
+	if (!inode)
+		return NULL;
+
+	inode->i_op = &yaffs_dir_inode_operations;
+	inode->i_fop = &yaffs_dir_operations;
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_read_super: got root inode\n")));
+
+	root = d_alloc_root(inode);
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_read_super: d_alloc_root done\n")));
+
+	if (!root) {
+		iput(inode);
+		return NULL;
+	}
+	sb->s_root = root;
+	sb->s_dirt = !dev->is_checkpointed;
+	T(YAFFS_TRACE_ALWAYS,
+		(TSTR("yaffs_read_super: is_checkpointed %d\n"),
+		dev->is_checkpointed));
+
+	T(YAFFS_TRACE_OS, (TSTR("yaffs_read_super: done\n")));
+	return sb;
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
+					 int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_read_super(struct file_system_type *fs,
+			    int flags, const char *dev_name,
+			    void *data, struct vfsmount *mnt)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs_read_super(struct file_system_type *fs,
+					    int flags, const char *dev_name,
+					    void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs",
+	.get_sb = yaffs_read_super,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,
+					    int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+#ifdef CONFIG_YAFFS_YAFFS2
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
+					  int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs2_read_super(struct file_system_type *fs,
+			int flags, const char *dev_name, void *data,
+			struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs, flags, dev_name, data,
+			yaffs2_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs2_read_super(struct file_system_type *fs,
+					     int flags, const char *dev_name,
+					     void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs2_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs2",
+	.get_sb = yaffs2_read_super,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs2_read_super(struct super_block *sb,
+					     void *data, int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+#endif				/* CONFIG_YAFFS_YAFFS2 */
+
+static struct proc_dir_entry *my_proc_entry;
+static struct proc_dir_entry *debug_proc_entry;
+
+static char *yaffs_dump_dev_part0(char *buf, yaffs_dev_t * dev)
+{
+	buf += sprintf(buf, "start_block.......... %d\n", dev->param.start_block);
+	buf += sprintf(buf, "end_block............ %d\n", dev->param.end_block);
+	buf += sprintf(buf, "total_bytes_per_chunk %d\n", dev->param.total_bytes_per_chunk);
+	buf += sprintf(buf, "use_nand_ecc......... %d\n", dev->param.use_nand_ecc);
+	buf += sprintf(buf, "no_tags_ecc.......... %d\n", dev->param.no_tags_ecc);
+	buf += sprintf(buf, "is_yaffs2............ %d\n", dev->param.is_yaffs2);
+	buf += sprintf(buf, "inband_tags.......... %d\n", dev->param.inband_tags);
+	buf += sprintf(buf, "empty_lost_n_found... %d\n", dev->param.empty_lost_n_found);
+	buf += sprintf(buf, "disable_lazy_load.... %d\n", dev->param.disable_lazy_load);
+	buf += sprintf(buf, "refresh_period....... %d\n", dev->param.refresh_period);
+	buf += sprintf(buf, "n_caches............. %d\n", dev->param.n_caches);
+	buf += sprintf(buf, "n_reserved_blocks.... %d\n", dev->param.n_reserved_blocks);
+	buf += sprintf(buf, "always_check_erased.. %d\n", dev->param.always_check_erased);
+
+	buf += sprintf(buf, "\n");
+
+	return buf;
+}
+
+
+static char *yaffs_dump_dev_part1(char *buf, yaffs_dev_t * dev)
+{
+	buf += sprintf(buf, "data_bytes_per_chunk. %d\n", dev->data_bytes_per_chunk);
+	buf += sprintf(buf, "chunk_grp_bits....... %d\n", dev->chunk_grp_bits);
+	buf += sprintf(buf, "chunk_grp_size....... %d\n", dev->chunk_grp_size);
+	buf += sprintf(buf, "n_erased_blocks...... %d\n", dev->n_erased_blocks);
+	buf += sprintf(buf, "blocks_in_checkpt.... %d\n", dev->blocks_in_checkpt);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_tnodes............. %d\n", dev->n_tnodes);
+	buf += sprintf(buf, "n_obj................ %d\n", dev->n_obj);
+	buf += sprintf(buf, "n_free_chunks........ %d\n", dev->n_free_chunks);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_page_writes........ %u\n", dev->n_page_writes);
+	buf += sprintf(buf, "n_page_reads......... %u\n", dev->n_page_reads);
+	buf += sprintf(buf, "n_erasures........... %u\n", dev->n_erasures);
+	buf += sprintf(buf, "n_gc_copies.......... %u\n", dev->n_gc_copies);
+	buf += sprintf(buf, "all_gcs.............. %u\n", dev->all_gcs);
+	buf += sprintf(buf, "passive_gc_count..... %u\n", dev->passive_gc_count);
+	buf += sprintf(buf, "oldest_dirty_gc_count %u\n", dev->oldest_dirty_gc_count);
+	buf += sprintf(buf, "n_gc_blocks.......... %u\n", dev->n_gc_blocks);
+	buf += sprintf(buf, "bg_gcs............... %u\n", dev->bg_gcs);
+	buf += sprintf(buf, "n_retired_writes..... %u\n", dev->n_retired_writes);
+	buf += sprintf(buf, "nRetireBlocks........ %u\n", dev->n_retired_blocks);
+	buf += sprintf(buf, "n_ecc_fixed.......... %u\n", dev->n_ecc_fixed);
+	buf += sprintf(buf, "n_ecc_unfixed........ %u\n", dev->n_ecc_unfixed);
+	buf += sprintf(buf, "n_tags_ecc_fixed..... %u\n", dev->n_tags_ecc_fixed);
+	buf += sprintf(buf, "n_tags_ecc_unfixed... %u\n", dev->n_tags_ecc_unfixed);
+	buf += sprintf(buf, "cache_hits........... %u\n", dev->cache_hits);
+	buf += sprintf(buf, "n_deleted_files...... %u\n", dev->n_deleted_files);
+	buf += sprintf(buf, "n_unlinked_files..... %u\n", dev->n_unlinked_files);
+	buf += sprintf(buf, "refresh_count........ %u\n", dev->refresh_count);
+	buf += sprintf(buf, "n_bg_deletions....... %u\n", dev->n_bg_deletions);
+
+	return buf;
+}
+
+static int yaffs_proc_read(char *page,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data)
+{
+	struct ylist_head *item;
+	char *buf = page;
+	int step = offset;
+	int n = 0;
+
+	/* Get proc_file_read() to step 'offset' by one on each sucessive call.
+	 * We use 'offset' (*ppos) to indicate where we are in dev_list.
+	 * This also assumes the user has posted a read buffer large
+	 * enough to hold the complete output; but that's life in /proc.
+	 */
+
+	*(int *)start = 1;
+
+	/* Print header first */
+	if (step == 0)
+		buf += sprintf(buf, "Multi-version YAFFS built:" __DATE__ " " __TIME__"\n");
+	else if (step == 1)
+		buf += sprintf(buf,"\n");
+	else {
+		step-=2;
+		
+		down(&yaffs_context_lock);
+
+		/* Locate and print the Nth entry.  Order N-squared but N is small. */
+		ylist_for_each(item, &yaffs_context_list) {
+			struct yaffs_LinuxContext *dc = ylist_entry(item, struct yaffs_LinuxContext, contextList);
+			yaffs_dev_t *dev = dc->dev;
+
+			if (n < (step & ~1)) {
+				n+=2;
+				continue;
+			}
+			if((step & 1)==0){
+				buf += sprintf(buf, "\nDevice %d \"%s\"\n", n, dev->param.name);
+				buf = yaffs_dump_dev_part0(buf, dev);
+			} else
+				buf = yaffs_dump_dev_part1(buf, dev);
+			
+			break;
+		}
+		up(&yaffs_context_lock);
+	}
+
+	return buf - page < count ? buf - page : count;
+}
+
+static int yaffs_stats_proc_read(char *page,
+				char **start,
+				off_t offset, int count, int *eof, void *data)
+{
+	struct ylist_head *item;
+	char *buf = page;
+	int n = 0;
+
+	down(&yaffs_context_lock);
+
+	/* Locate and print the Nth entry.  Order N-squared but N is small. */
+	ylist_for_each(item, &yaffs_context_list) {
+		struct yaffs_LinuxContext *dc = ylist_entry(item, struct yaffs_LinuxContext, contextList);
+		yaffs_dev_t *dev = dc->dev;
+
+		int erasedChunks;
+
+		erasedChunks = dev->n_erased_blocks * dev->param.chunks_per_block;
+		
+		buf += sprintf(buf,"%d, %d, %d, %u, %u, %u, %u\n",
+				n, dev->n_free_chunks, erasedChunks,
+				dev->bg_gcs, dev->oldest_dirty_gc_count,
+				dev->n_obj, dev->n_tnodes);
+	}
+	up(&yaffs_context_lock);
+
+
+	return buf - page < count ? buf - page : count;
+}
+
+/**
+ * Set the verbosity of the warnings and error messages.
+ *
+ * Note that the names can only be a..z or _ with the current code.
+ */
+
+static struct {
+	char *mask_name;
+	unsigned mask_bitfield;
+} mask_flags[] = {
+	{"allocate", YAFFS_TRACE_ALLOCATE},
+	{"always", YAFFS_TRACE_ALWAYS},
+	{"background", YAFFS_TRACE_BACKGROUND},
+	{"bad_blocks", YAFFS_TRACE_BAD_BLOCKS},
+	{"buffers", YAFFS_TRACE_BUFFERS},
+	{"bug", YAFFS_TRACE_BUG},
+	{"checkpt", YAFFS_TRACE_CHECKPOINT},
+	{"deletion", YAFFS_TRACE_DELETION},
+	{"erase", YAFFS_TRACE_ERASE},
+	{"error", YAFFS_TRACE_ERROR},
+	{"gc_detail", YAFFS_TRACE_GC_DETAIL},
+	{"gc", YAFFS_TRACE_GC},
+	{"lock", YAFFS_TRACE_LOCK},
+	{"mtd", YAFFS_TRACE_MTD},
+	{"nandaccess", YAFFS_TRACE_NANDACCESS},
+	{"os", YAFFS_TRACE_OS},
+	{"scan_debug", YAFFS_TRACE_SCAN_DEBUG},
+	{"scan", YAFFS_TRACE_SCAN},
+	{"tracing", YAFFS_TRACE_TRACING},
+	{"sync", YAFFS_TRACE_SYNC},
+	{"write", YAFFS_TRACE_WRITE},
+
+	{"verify", YAFFS_TRACE_VERIFY},
+	{"verify_nand", YAFFS_TRACE_VERIFY_NAND},
+	{"verify_full", YAFFS_TRACE_VERIFY_FULL},
+	{"verify_all", YAFFS_TRACE_VERIFY_ALL},
+
+	{"all", 0xffffffff},
+	{"none", 0},
+	{NULL, 0},
+};
+
+#define MAX_MASK_NAME_LENGTH 40
+static int yaffs_proc_write_trace_options(struct file *file, const char *buf,
+					 unsigned long count, void *data)
+{
+	unsigned rg = 0, mask_bitfield;
+	char *end;
+	char *mask_name;
+	const char *x;
+	char substring[MAX_MASK_NAME_LENGTH + 1];
+	int i;
+	int done = 0;
+	int add, len = 0;
+	int pos = 0;
+
+	rg = yaffs_trace_mask;
+
+	while (!done && (pos < count)) {
+		done = 1;
+		while ((pos < count) && isspace(buf[pos]))
+			pos++;
+
+		switch (buf[pos]) {
+		case '+':
+		case '-':
+		case '=':
+			add = buf[pos];
+			pos++;
+			break;
+
+		default:
+			add = ' ';
+			break;
+		}
+		mask_name = NULL;
+
+		mask_bitfield = simple_strtoul(buf + pos, &end, 0);
+
+		if (end > buf + pos) {
+			mask_name = "numeral";
+			len = end - (buf + pos);
+			pos += len;
+			done = 0;
+		} else {
+			for (x = buf + pos, i = 0;
+			    (*x == '_' || (*x >= 'a' && *x <= 'z')) &&
+			    i < MAX_MASK_NAME_LENGTH; x++, i++, pos++)
+				substring[i] = *x;
+			substring[i] = '\0';
+
+			for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+				if (strcmp(substring, mask_flags[i].mask_name) == 0) {
+					mask_name = mask_flags[i].mask_name;
+					mask_bitfield = mask_flags[i].mask_bitfield;
+					done = 0;
+					break;
+				}
+			}
+		}
+
+		if (mask_name != NULL) {
+			done = 0;
+			switch (add) {
+			case '-':
+				rg &= ~mask_bitfield;
+				break;
+			case '+':
+				rg |= mask_bitfield;
+				break;
+			case '=':
+				rg = mask_bitfield;
+				break;
+			default:
+				rg |= mask_bitfield;
+				break;
+			}
+		}
+	}
+
+	yaffs_trace_mask = rg | YAFFS_TRACE_ALWAYS;
+
+	printk(KERN_DEBUG "new trace = 0x%08X\n", yaffs_trace_mask);
+
+	if (rg & YAFFS_TRACE_ALWAYS) {
+		for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+			char flag;
+			flag = ((rg & mask_flags[i].mask_bitfield) ==
+				mask_flags[i].mask_bitfield) ? '+' : '-';
+			printk(KERN_DEBUG "%c%s\n", flag, mask_flags[i].mask_name);
+		}
+	}
+
+	return count;
+}
+
+
+static int yaffs_proc_write(struct file *file, const char *buf,
+					 unsigned long count, void *data)
+{
+        return yaffs_proc_write_trace_options(file, buf, count, data);
+}
+
+/* Stuff to handle installation of file systems */
+struct file_system_to_install {
+	struct file_system_type *fst;
+	int installed;
+};
+
+static struct file_system_to_install fs_to_install[] = {
+	{&yaffs_fs_type, 0},
+	{&yaffs2_fs_type, 0},
+	{NULL, 0}
+};
+
+static int __init init_yaffs_fs(void)
+{
+	int error = 0;
+	struct file_system_to_install *fsinst;
+
+	T(YAFFS_TRACE_ALWAYS,
+	  (TSTR("yaffs built " __DATE__ " " __TIME__ " Installing. \n")));
+
+#ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+	T(YAFFS_TRACE_ALWAYS,
+	  (TSTR(" \n\n\n\nYAFFS-WARNING CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED selected.\n\n\n\n")));
+#endif
+
+
+
+
+	init_MUTEX(&yaffs_context_lock);
+
+	/* Install the proc_fs entries */
+	my_proc_entry = create_proc_entry("yaffs",
+					       S_IRUGO | S_IFREG,
+					       YPROC_ROOT);
+
+	if (my_proc_entry) {
+		my_proc_entry->write_proc = yaffs_proc_write;
+		my_proc_entry->read_proc = yaffs_proc_read;
+		my_proc_entry->data = NULL;
+	} else
+		return -ENOMEM;
+
+	debug_proc_entry = create_proc_entry("yaffs_stats",
+					       S_IRUGO | S_IFREG,
+					       YPROC_ROOT);
+
+	if (debug_proc_entry) {
+		debug_proc_entry->write_proc = NULL;
+		debug_proc_entry->read_proc = yaffs_stats_proc_read;
+		debug_proc_entry->data = NULL;
+	} else
+		return -ENOMEM;
+
+	/* Now add the file system entries */
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst && !error) {
+		error = register_filesystem(fsinst->fst);
+		if (!error)
+			fsinst->installed = 1;
+		fsinst++;
+	}
+
+	/* Any errors? uninstall  */
+	if (error) {
+		fsinst = fs_to_install;
+
+		while (fsinst->fst) {
+			if (fsinst->installed) {
+				unregister_filesystem(fsinst->fst);
+				fsinst->installed = 0;
+			}
+			fsinst++;
+		}
+	}
+
+	return error;
+}
+
+static void __exit exit_yaffs_fs(void)
+{
+
+	struct file_system_to_install *fsinst;
+
+	T(YAFFS_TRACE_ALWAYS,
+		(TSTR("yaffs built " __DATE__ " " __TIME__ " removing. \n")));
+
+	remove_proc_entry("yaffs", YPROC_ROOT);
+	remove_proc_entry("yaffs_stats", YPROC_ROOT);
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst) {
+		if (fsinst->installed) {
+			unregister_filesystem(fsinst->fst);
+			fsinst->installed = 0;
+		}
+		fsinst++;
+	}
+}
+
+module_init(init_yaffs_fs)
+module_exit(exit_yaffs_fs)
+
+MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2010");
+MODULE_LICENSE("GPL");
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_yaffs1.c b/target/linux/generic/files/fs/yaffs2/yaffs_yaffs1.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_yaffs1.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_yaffs1.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -10,46 +10,54 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-
 #include "yaffs_yaffs1.h"
 #include "yportenv.h"
 #include "yaffs_trace.h"
 #include "yaffs_bitmap.h"
 #include "yaffs_getblockinfo.h"
 #include "yaffs_nand.h"
-#include "yaffs_attribs.h"
 
-int yaffs1_scan(struct yaffs_dev *dev)
+
+int yaffs1_scan(yaffs_dev_t *dev)
 {
-	struct yaffs_ext_tags tags;
+	yaffs_ext_tags tags;
 	int blk;
+	int blockIterator;
+	int startIterator;
+	int endIterator;
 	int result;
+
 	int chunk;
 	int c;
 	int deleted;
-	enum yaffs_block_state state;
-	LIST_HEAD(hard_list);
-	struct yaffs_block_info *bi;
-	u32 seq_number;
-	struct yaffs_obj_hdr *oh;
-	struct yaffs_obj *in;
-	struct yaffs_obj *parent;
+	yaffs_block_state_t state;
+	yaffs_obj_t *hard_list = NULL;
+	yaffs_block_info_t *bi;
+	__u32 seq_number;
+	yaffs_obj_header *oh;
+	yaffs_obj_t *in;
+	yaffs_obj_t *parent;
+
 	int alloc_failed = 0;
-	struct yaffs_shadow_fixer *shadow_fixers = NULL;
-	u8 *chunk_data;
 
-	yaffs_trace(YAFFS_TRACE_SCAN,
-		"yaffs1_scan starts  intstartblk %d intendblk %d...",
-		dev->internal_start_block, dev->internal_end_block);
+	struct yaffs_shadow_fixer_s *shadowFixerList = NULL;
 
-	chunk_data = yaffs_get_temp_buffer(dev);
+
+	__u8 *chunkData;
+
+
+
+	T(YAFFS_TRACE_SCAN,
+	  (TSTR("yaffs1_scan starts  intstartblk %d intendblk %d..." TENDSTR),
+	   dev->internal_start_block, dev->internal_end_block));
+
+	chunkData = yaffs_get_temp_buffer(dev, __LINE__);
 
 	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
 
 	/* Scan all the blocks to determine their state */
 	bi = dev->block_info;
-	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
-	     blk++) {
+	for (blk = dev->internal_start_block; blk <= dev->internal_end_block; blk++) {
 		yaffs_clear_chunk_bits(dev, blk);
 		bi->pages_in_use = 0;
 		bi->soft_del_pages = 0;
@@ -62,51 +70,58 @@ int yaffs1_scan(struct yaffs_dev *dev)
 		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
 			bi->block_state = state = YAFFS_BLOCK_STATE_DEAD;
 
-		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
-			"Block scanning block %d state %d seq %d",
-			blk, state, seq_number);
+		T(YAFFS_TRACE_SCAN_DEBUG,
+		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
+		   state, seq_number));
 
 		if (state == YAFFS_BLOCK_STATE_DEAD) {
-			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
-				"block %d is bad", blk);
+			T(YAFFS_TRACE_BAD_BLOCKS,
+			  (TSTR("block %d is bad" TENDSTR), blk));
 		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
-			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
+			T(YAFFS_TRACE_SCAN_DEBUG,
+			  (TSTR("Block empty " TENDSTR)));
 			dev->n_erased_blocks++;
 			dev->n_free_chunks += dev->param.chunks_per_block;
 		}
 		bi++;
 	}
 
+	startIterator = dev->internal_start_block;
+	endIterator = dev->internal_end_block;
+
 	/* For each block.... */
-	for (blk = dev->internal_start_block;
-	     !alloc_failed && blk <= dev->internal_end_block; blk++) {
+	for (blockIterator = startIterator; !alloc_failed && blockIterator <= endIterator;
+	     blockIterator++) {
 
-		cond_resched();
+		YYIELD();
+
+		YYIELD();
+
+		blk = blockIterator;
 
 		bi = yaffs_get_block_info(dev, blk);
 		state = bi->block_state;
 
 		deleted = 0;
 
-		/* For each chunk in each block that needs scanning.... */
-		for (c = 0;
-			!alloc_failed && c < dev->param.chunks_per_block &&
-			state == YAFFS_BLOCK_STATE_NEEDS_SCAN; c++) {
+		/* For each chunk in each block that needs scanning....*/
+		for (c = 0; !alloc_failed && c < dev->param.chunks_per_block &&
+		     state == YAFFS_BLOCK_STATE_NEEDS_SCANNING; c++) {
 			/* Read the tags and decide what to do */
 			chunk = blk * dev->param.chunks_per_block + c;
 
 			result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL,
-							  &tags);
+							&tags);
 
 			/* Let's have a good look at this chunk... */
 
-			if (tags.ecc_result == YAFFS_ECC_RESULT_UNFIXED ||
-			    tags.is_deleted) {
+			if (tags.ecc_result == YAFFS_ECC_RESULT_UNFIXED || tags.is_deleted) {
 				/* YAFFS1 only...
 				 * A deleted chunk
 				 */
 				deleted++;
 				dev->n_free_chunks++;
+				/*T((" %d %d deleted\n",blk,c)); */
 			} else if (!tags.chunk_used) {
 				/* An unassigned chunk in the block
 				 * This means that either the block is empty or
@@ -114,24 +129,24 @@ int yaffs1_scan(struct yaffs_dev *dev)
 				 */
 
 				if (c == 0) {
-					/* We're looking at the first chunk in
-					 *the block so the block is unused */
+					/* We're looking at the first chunk in the block so the block is unused */
 					state = YAFFS_BLOCK_STATE_EMPTY;
 					dev->n_erased_blocks++;
 				} else {
-					/* this is the block being allocated */
-					yaffs_trace(YAFFS_TRACE_SCAN,
-						" Allocating from %d %d",
-						blk, c);
+					/* this is the block being allocated from */
+					T(YAFFS_TRACE_SCAN,
+					  (TSTR
+					   (" Allocating from %d %d" TENDSTR),
+					   blk, c));
 					state = YAFFS_BLOCK_STATE_ALLOCATING;
 					dev->alloc_block = blk;
 					dev->alloc_page = c;
 					dev->alloc_block_finder = blk;
+					/* Set block finder here to encourage the allocator to go forth from here. */
 
 				}
 
-				dev->n_free_chunks +=
-				    (dev->param.chunks_per_block - c);
+				dev->n_free_chunks += (dev->param.chunks_per_block - c);
 			} else if (tags.chunk_id > 0) {
 				/* chunk_id > 0 so it is a data chunk... */
 				unsigned int endpos;
@@ -140,131 +155,133 @@ int yaffs1_scan(struct yaffs_dev *dev)
 				bi->pages_in_use++;
 
 				in = yaffs_find_or_create_by_number(dev,
-							tags.obj_id,
-							YAFFS_OBJECT_TYPE_FILE);
-				/* PutChunkIntoFile checks for a clash
-				 * (two data chunks with the same chunk_id).
+								      tags.
+								      obj_id,
+								      YAFFS_OBJECT_TYPE_FILE);
+				/* PutChunkIntoFile checks for a clash (two data chunks with
+				 * the same chunk_id).
 				 */
 
 				if (!in)
 					alloc_failed = 1;
 
 				if (in) {
-					if (!yaffs_put_chunk_in_file
-					    (in, tags.chunk_id, chunk, 1))
+					if (!yaffs_put_chunk_in_file(in, tags.chunk_id, chunk, 1))
 						alloc_failed = 1;
 				}
 
 				endpos =
-				    (tags.chunk_id - 1) *
-				    dev->data_bytes_per_chunk +
+				    (tags.chunk_id - 1) * dev->data_bytes_per_chunk +
 				    tags.n_bytes;
 				if (in &&
-				    in->variant_type ==
-				     YAFFS_OBJECT_TYPE_FILE &&
-				    in->variant.file_variant.scanned_size <
-				      endpos) {
-					in->variant.file_variant.scanned_size =
-					    endpos;
+				    in->variant_type == YAFFS_OBJECT_TYPE_FILE
+				    && in->variant.file_variant.scanned_size <
+				    endpos) {
+					in->variant.file_variant.
+					    scanned_size = endpos;
 					if (!dev->param.use_header_file_size) {
-						in->variant.
-						    file_variant.file_size =
-						    in->variant.
-						    file_variant.scanned_size;
+						in->variant.file_variant.
+						    file_size =
+						    in->variant.file_variant.
+						    scanned_size;
 					}
 
 				}
+				/* T((" %d %d data %d %d\n",blk,c,tags.obj_id,tags.chunk_id));   */
 			} else {
 				/* chunk_id == 0, so it is an ObjectHeader.
-				 * Make the object
+				 * Thus, we read in the object header and make the object
 				 */
 				yaffs_set_chunk_bit(dev, blk, c);
 				bi->pages_in_use++;
 
 				result = yaffs_rd_chunk_tags_nand(dev, chunk,
-								  chunk_data,
-								  NULL);
+								chunkData,
+								NULL);
 
-				oh = (struct yaffs_obj_hdr *)chunk_data;
+				oh = (yaffs_obj_header *) chunkData;
 
-				in = yaffs_find_by_number(dev, tags.obj_id);
+				in = yaffs_find_by_number(dev,
+							      tags.obj_id);
 				if (in && in->variant_type != oh->type) {
 					/* This should not happen, but somehow
-					 * Wev'e ended up with an obj_id that
-					 * has been reused but not yet deleted,
-					 * and worse still it has changed type.
-					 * Delete the old object.
+					 * Wev'e ended up with an obj_id that has been reused but not yet
+					 * deleted, and worse still it has changed type. Delete the old object.
 					 */
 
 					yaffs_del_obj(in);
-					in = NULL;
+
+					in = 0;
 				}
 
 				in = yaffs_find_or_create_by_number(dev,
-								tags.obj_id,
-								oh->type);
+								      tags.
+								      obj_id,
+								      oh->type);
 
 				if (!in)
 					alloc_failed = 1;
 
 				if (in && oh->shadows_obj > 0) {
 
-					struct yaffs_shadow_fixer *fixer;
-					fixer =
-						kmalloc(sizeof
-						(struct yaffs_shadow_fixer),
-						GFP_NOFS);
+					struct yaffs_shadow_fixer_s *fixer;
+					fixer = YMALLOC(sizeof(struct yaffs_shadow_fixer_s));
 					if (fixer) {
-						fixer->next = shadow_fixers;
-						shadow_fixers = fixer;
+						fixer->next = shadowFixerList;
+						shadowFixerList = fixer;
 						fixer->obj_id = tags.obj_id;
-						fixer->shadowed_id =
-						    oh->shadows_obj;
-						yaffs_trace(YAFFS_TRACE_SCAN,
-							" Shadow fixer: %d shadows %d",
-							fixer->obj_id,
-							fixer->shadowed_id);
+						fixer->shadowed_id = oh->shadows_obj;
+						T(YAFFS_TRACE_SCAN,
+						  (TSTR
+						   (" Shadow fixer: %d shadows %d" TENDSTR),
+						   fixer->obj_id, fixer->shadowed_id));
 
 					}
 
 				}
 
 				if (in && in->valid) {
-					/* We have already filled this one.
-					 * We have a duplicate and need to
-					 * resolve it. */
+					/* We have already filled this one. We have a duplicate and need to resolve it. */
 
-					unsigned existing_serial = in->serial;
-					unsigned new_serial =
-					    tags.serial_number;
+					unsigned existingSerial = in->serial;
+					unsigned newSerial = tags.serial_number;
 
-					if (((existing_serial + 1) & 3) ==
-					    new_serial) {
-						/* Use new one - destroy the
-						 * exisiting one */
+					if (((existingSerial + 1) & 3) == newSerial) {
+						/* Use new one - destroy the exisiting one */
 						yaffs_chunk_del(dev,
-								in->hdr_chunk,
-								1, __LINE__);
+								  in->hdr_chunk,
+								  1, __LINE__);
 						in->valid = 0;
 					} else {
-						/* Use existing - destroy
-						 * this one. */
+						/* Use existing - destroy this one. */
 						yaffs_chunk_del(dev, chunk, 1,
-								__LINE__);
+								  __LINE__);
 					}
 				}
 
 				if (in && !in->valid &&
 				    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
-				     tags.obj_id ==
-				     YAFFS_OBJECTID_LOSTNFOUND)) {
-					/* We only load some info, don't fiddle
-					 * with directory structure */
+				     tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND)) {
+					/* We only load some info, don't fiddle with directory structure */
 					in->valid = 1;
 					in->variant_type = oh->type;
 
 					in->yst_mode = oh->yst_mode;
-					yaffs_load_attribs(in, oh);
+#ifdef CONFIG_YAFFS_WINCE
+					in->win_atime[0] = oh->win_atime[0];
+					in->win_ctime[0] = oh->win_ctime[0];
+					in->win_mtime[0] = oh->win_mtime[0];
+					in->win_atime[1] = oh->win_atime[1];
+					in->win_ctime[1] = oh->win_ctime[1];
+					in->win_mtime[1] = oh->win_mtime[1];
+#else
+					in->yst_uid = oh->yst_uid;
+					in->yst_gid = oh->yst_gid;
+					in->yst_atime = oh->yst_atime;
+					in->yst_mtime = oh->yst_mtime;
+					in->yst_ctime = oh->yst_ctime;
+					in->yst_rdev = oh->yst_rdev;
+#endif
 					in->hdr_chunk = chunk;
 					in->serial = tags.serial_number;
 
@@ -275,7 +292,21 @@ int yaffs1_scan(struct yaffs_dev *dev)
 					in->variant_type = oh->type;
 
 					in->yst_mode = oh->yst_mode;
-					yaffs_load_attribs(in, oh);
+#ifdef CONFIG_YAFFS_WINCE
+					in->win_atime[0] = oh->win_atime[0];
+					in->win_ctime[0] = oh->win_ctime[0];
+					in->win_mtime[0] = oh->win_mtime[0];
+					in->win_atime[1] = oh->win_atime[1];
+					in->win_ctime[1] = oh->win_ctime[1];
+					in->win_mtime[1] = oh->win_mtime[1];
+#else
+					in->yst_uid = oh->yst_uid;
+					in->yst_gid = oh->yst_gid;
+					in->yst_atime = oh->yst_atime;
+					in->yst_mtime = oh->yst_mtime;
+					in->yst_ctime = oh->yst_ctime;
+					in->yst_rdev = oh->yst_rdev;
+#endif
 					in->hdr_chunk = chunk;
 					in->serial = tags.serial_number;
 
@@ -296,43 +327,57 @@ int yaffs1_scan(struct yaffs_dev *dev)
 					    YAFFS_OBJECT_TYPE_UNKNOWN) {
 						/* Set up as a directory */
 						parent->variant_type =
-						    YAFFS_OBJECT_TYPE_DIRECTORY;
-						INIT_LIST_HEAD(&parent->
-							variant.dir_variant.
-							children);
-					} else if (!parent ||
-						parent->variant_type !=
-						YAFFS_OBJECT_TYPE_DIRECTORY) {
-						/* Hoosterman, a problem....
-						 * We're trying to use a
-						 * non-directory as a directory
+							YAFFS_OBJECT_TYPE_DIRECTORY;
+						YINIT_LIST_HEAD(&parent->variant.
+								dir_variant.
+								children);
+					} else if (!parent || parent->variant_type !=
+						   YAFFS_OBJECT_TYPE_DIRECTORY) {
+						/* Hoosterman, another problem....
+						 * We're trying to use a non-directory as a directory
 						 */
 
-						yaffs_trace(YAFFS_TRACE_ERROR,
-							"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
-							);
+						T(YAFFS_TRACE_ERROR,
+						  (TSTR
+						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+						    TENDSTR)));
 						parent = dev->lost_n_found;
 					}
 
 					yaffs_add_obj_to_dir(parent, in);
 
+					if (0 && (parent == dev->del_dir ||
+						  parent == dev->unlinked_dir)) {
+						in->deleted = 1;	/* If it is unlinked at start up then it wants deleting */
+						dev->n_deleted_files++;
+					}
+					/* Note re hardlinks.
+					 * Since we might scan a hardlink before its equivalent object is scanned
+					 * we put them all in a list.
+					 * After scanning is complete, we should have all the objects, so we run through this
+					 * list and fix up all the chains.
+					 */
+
 					switch (in->variant_type) {
 					case YAFFS_OBJECT_TYPE_UNKNOWN:
 						/* Todo got a problem */
 						break;
 					case YAFFS_OBJECT_TYPE_FILE:
-						if (dev->param.
-						    use_header_file_size)
-							in->variant.
-							file_variant.file_size
-							= yaffs_oh_to_size(oh);
+						if (dev->param.use_header_file_size)
+
+							in->variant.file_variant.
+							    file_size =
+							    oh->file_size;
+
 						break;
 					case YAFFS_OBJECT_TYPE_HARDLINK:
-						in->variant.
-						    hardlink_variant.equiv_id =
-						    oh->equiv_id;
-						list_add(&in->hard_links,
-								&hard_list);
+						in->variant.hardlink_variant.
+							equiv_id =
+							oh->equiv_id;
+						in->hard_links.next =
+							(struct ylist_head *)
+							hard_list;
+						hard_list = in;
 						break;
 					case YAFFS_OBJECT_TYPE_DIRECTORY:
 						/* Do nothing */
@@ -341,27 +386,24 @@ int yaffs1_scan(struct yaffs_dev *dev)
 						/* Do nothing */
 						break;
 					case YAFFS_OBJECT_TYPE_SYMLINK:
-						in->variant.symlink_variant.
-						    alias =
+						in->variant.symlink_variant.alias =
 						    yaffs_clone_str(oh->alias);
-						if (!in->variant.
-						    symlink_variant.alias)
+						if (!in->variant.symlink_variant.alias)
 							alloc_failed = 1;
 						break;
 					}
+
 				}
 			}
 		}
 
-		if (state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
-			/* If we got this far while scanning,
-			 * then the block is fully allocated. */
+		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+			/* If we got this far while scanning, then the block is fully allocated.*/
 			state = YAFFS_BLOCK_STATE_FULL;
 		}
 
 		if (state == YAFFS_BLOCK_STATE_ALLOCATING) {
-			/* If the block was partially allocated then
-			 * treat it as fully allocated. */
+			/* If the block was partially allocated then treat it as fully allocated.*/
 			state = YAFFS_BLOCK_STATE_FULL;
 			dev->alloc_block = -1;
 		}
@@ -371,32 +413,31 @@ int yaffs1_scan(struct yaffs_dev *dev)
 		/* Now let's see if it was dirty */
 		if (bi->pages_in_use == 0 &&
 		    !bi->has_shrink_hdr &&
-		    bi->block_state == YAFFS_BLOCK_STATE_FULL)
+		    bi->block_state == YAFFS_BLOCK_STATE_FULL) {
 			yaffs_block_became_dirty(dev, blk);
+		}
+
 	}
 
+
 	/* Ok, we've done all the scanning.
 	 * Fix up the hard link chains.
-	 * We should now have scanned all the objects, now it's time to add
-	 * these hardlinks.
+	 * We should now have scanned all the objects, now it's time to add these
+	 * hardlinks.
 	 */
 
-	yaffs_link_fixup(dev, &hard_list);
+	yaffs_link_fixup(dev, hard_list);
 
-	/*
-	 * Fix up any shadowed objects.
-	 * There should not be more than one of these.
-	 */
+	/* Fix up any shadowed objects */
 	{
-		struct yaffs_shadow_fixer *fixer;
-		struct yaffs_obj *obj;
+		struct yaffs_shadow_fixer_s *fixer;
+		yaffs_obj_t *obj;
 
-		while (shadow_fixers) {
-			fixer = shadow_fixers;
-			shadow_fixers = fixer->next;
-			/* Complete the rename transaction by deleting the
-			 * shadowed object then setting the object header
-			 to unshadowed.
+		while (shadowFixerList) {
+			fixer = shadowFixerList;
+			shadowFixerList = fixer->next;
+			/* Complete the rename transaction by deleting the shadowed object
+			 * then setting the object header to unshadowed.
 			 */
 			obj = yaffs_find_by_number(dev, fixer->shadowed_id);
 			if (obj)
@@ -407,16 +448,18 @@ int yaffs1_scan(struct yaffs_dev *dev)
 			if (obj)
 				yaffs_update_oh(obj, NULL, 1, 0, 0, NULL);
 
-			kfree(fixer);
+			YFREE(fixer);
 		}
 	}
 
-	yaffs_release_temp_buffer(dev, chunk_data);
+	yaffs_release_temp_buffer(dev, chunkData, __LINE__);
 
 	if (alloc_failed)
 		return YAFFS_FAIL;
 
-	yaffs_trace(YAFFS_TRACE_SCAN, "yaffs1_scan ends");
+	T(YAFFS_TRACE_SCAN, (TSTR("yaffs1_scan ends" TENDSTR)));
+
 
 	return YAFFS_OK;
 }
+
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_yaffs1.h b/target/linux/generic/files/fs/yaffs2/yaffs_yaffs1.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_yaffs1.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_yaffs1.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -17,6 +17,6 @@
 #define __YAFFS_YAFFS1_H__
 
 #include "yaffs_guts.h"
-int yaffs1_scan(struct yaffs_dev *dev);
+int yaffs1_scan(yaffs_dev_t *dev);
 
 #endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_yaffs2.c b/target/linux/generic/files/fs/yaffs2/yaffs_yaffs2.c
--- a/target/linux/generic/files/fs/yaffs2/yaffs_yaffs2.c
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_yaffs2.c
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -11,16 +11,16 @@
  * published by the Free Software Foundation.
  */
 
+
 #include "yaffs_guts.h"
 #include "yaffs_trace.h"
 #include "yaffs_yaffs2.h"
 #include "yaffs_checkptrw.h"
 #include "yaffs_bitmap.h"
+#include "yaffs_qsort.h"
 #include "yaffs_nand.h"
 #include "yaffs_getblockinfo.h"
 #include "yaffs_verify.h"
-#include "yaffs_attribs.h"
-#include "yaffs_summary.h"
 
 /*
  * Checkpoints are really no benefit on very small partitions.
@@ -29,24 +29,26 @@
  * the partition is at least this big.
  */
 #define YAFFS_CHECKPOINT_MIN_BLOCKS 60
+
 #define YAFFS_SMALL_HOLE_THRESHOLD 4
 
+
 /*
  * Oldest Dirty Sequence Number handling.
  */
-
+ 
 /* yaffs_calc_oldest_dirty_seq()
  * yaffs2_find_oldest_dirty_seq()
  * Calculate the oldest dirty sequence number if we don't know it.
  */
-void yaffs_calc_oldest_dirty_seq(struct yaffs_dev *dev)
+void yaffs_calc_oldest_dirty_seq(yaffs_dev_t *dev)
 {
 	int i;
 	unsigned seq;
 	unsigned block_no = 0;
-	struct yaffs_block_info *b;
+	yaffs_block_info_t *b;
 
-	if (!dev->param.is_yaffs2)
+	if(!dev->param.is_yaffs2)
 		return;
 
 	/* Find the oldest dirty sequence number. */
@@ -54,44 +56,44 @@ void yaffs_calc_oldest_dirty_seq(struct 
 	b = dev->block_info;
 	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
 		if (b->block_state == YAFFS_BLOCK_STATE_FULL &&
-		    (b->pages_in_use - b->soft_del_pages) <
-		    dev->param.chunks_per_block &&
-		    b->seq_number < seq) {
+			(b->pages_in_use - b->soft_del_pages) < dev->param.chunks_per_block &&
+			b->seq_number < seq) {
 			seq = b->seq_number;
 			block_no = i;
 		}
 		b++;
 	}
 
-	if (block_no) {
+	if(block_no){
 		dev->oldest_dirty_seq = seq;
 		dev->oldest_dirty_block = block_no;
 	}
+
 }
 
-void yaffs2_find_oldest_dirty_seq(struct yaffs_dev *dev)
+
+void yaffs2_find_oldest_dirty_seq(yaffs_dev_t *dev)
 {
-	if (!dev->param.is_yaffs2)
+	if(!dev->param.is_yaffs2)
 		return;
 
-	if (!dev->oldest_dirty_seq)
+	if(!dev->oldest_dirty_seq)
 		yaffs_calc_oldest_dirty_seq(dev);
 }
 
 /*
  * yaffs_clear_oldest_dirty_seq()
  * Called when a block is erased or marked bad. (ie. when its seq_number
- * becomes invalid). If the value matches the oldest then we clear
+ * becomes invalid). If the value matches the oldest then we clear 
  * dev->oldest_dirty_seq to force its recomputation.
  */
-void yaffs2_clear_oldest_dirty_seq(struct yaffs_dev *dev,
-				   struct yaffs_block_info *bi)
+void yaffs2_clear_oldest_dirty_seq(yaffs_dev_t *dev, yaffs_block_info_t *bi)
 {
 
-	if (!dev->param.is_yaffs2)
+	if(!dev->param.is_yaffs2)
 		return;
 
-	if (!bi || bi->seq_number == dev->oldest_dirty_seq) {
+	if(!bi || bi->seq_number == dev->oldest_dirty_seq){
 		dev->oldest_dirty_seq = 0;
 		dev->oldest_dirty_block = 0;
 	}
@@ -102,21 +104,21 @@ void yaffs2_clear_oldest_dirty_seq(struc
  * Update the oldest dirty sequence number whenever we dirty a block.
  * Only do this if the oldest_dirty_seq is actually being tracked.
  */
-void yaffs2_update_oldest_dirty_seq(struct yaffs_dev *dev, unsigned block_no,
-				    struct yaffs_block_info *bi)
+void yaffs2_update_oldest_dirty_seq(yaffs_dev_t *dev, unsigned block_no, yaffs_block_info_t *bi)
 {
-	if (!dev->param.is_yaffs2)
+	if(!dev->param.is_yaffs2)
 		return;
 
-	if (dev->oldest_dirty_seq) {
-		if (dev->oldest_dirty_seq > bi->seq_number) {
+	if(dev->oldest_dirty_seq){
+		if(dev->oldest_dirty_seq > bi->seq_number){
 			dev->oldest_dirty_seq = bi->seq_number;
 			dev->oldest_dirty_block = block_no;
 		}
 	}
 }
 
-int yaffs_block_ok_for_gc(struct yaffs_dev *dev, struct yaffs_block_info *bi)
+int yaffs_block_ok_for_gc(yaffs_dev_t *dev,
+					yaffs_block_info_t *bi)
 {
 
 	if (!dev->param.is_yaffs2)
@@ -127,8 +129,8 @@ int yaffs_block_ok_for_gc(struct yaffs_d
 
 	yaffs2_find_oldest_dirty_seq(dev);
 
-	/* Can't do gc of this block if there are any blocks older than this
-	 * one that have discarded pages.
+	/* Can't do gc of this block if there are any blocks older than this one that have
+	 * discarded pages.
 	 */
 	return (bi->seq_number <= dev->oldest_dirty_seq);
 }
@@ -138,30 +140,32 @@ int yaffs_block_ok_for_gc(struct yaffs_d
  * periodically finds the oldest full block by sequence number for refreshing.
  * Only for yaffs2.
  */
-u32 yaffs2_find_refresh_block(struct yaffs_dev *dev)
+__u32 yaffs2_find_refresh_block(yaffs_dev_t *dev)
 {
-	u32 b;
-	u32 oldest = 0;
-	u32 oldest_seq = 0;
-	struct yaffs_block_info *bi;
+	__u32 b ;
 
-	if (!dev->param.is_yaffs2)
+	__u32 oldest = 0;
+	__u32 oldestSequence = 0;
+
+	yaffs_block_info_t *bi;
+
+	if(!dev->param.is_yaffs2)
 		return oldest;
 
 	/*
 	 * If refresh period < 10 then refreshing is disabled.
 	 */
-	if (dev->param.refresh_period < 10)
-		return oldest;
+	if(dev->param.refresh_period < 10)
+	        return oldest;
 
-	/*
-	 * Fix broken values.
-	 */
-	if (dev->refresh_skip > dev->param.refresh_period)
-		dev->refresh_skip = dev->param.refresh_period;
+        /*
+         * Fix broken values.
+         */
+        if(dev->refresh_skip > dev->param.refresh_period)
+                dev->refresh_skip = dev->param.refresh_period;
 
-	if (dev->refresh_skip > 0)
-		return oldest;
+	if(dev->refresh_skip > 0)
+	        return oldest;
 
 	/*
 	 * Refresh skip is now zero.
@@ -171,86 +175,84 @@ u32 yaffs2_find_refresh_block(struct yaf
 	dev->refresh_skip = dev->param.refresh_period;
 	dev->refresh_count++;
 	bi = dev->block_info;
-	for (b = dev->internal_start_block; b <= dev->internal_end_block; b++) {
+	for (b = dev->internal_start_block; b <=dev->internal_end_block; b++){
 
-		if (bi->block_state == YAFFS_BLOCK_STATE_FULL) {
+		if (bi->block_state == YAFFS_BLOCK_STATE_FULL){
 
-			if (oldest < 1 || bi->seq_number < oldest_seq) {
-				oldest = b;
-				oldest_seq = bi->seq_number;
-			}
+			if(oldest < 1 ||
+                                bi->seq_number < oldestSequence){
+                                oldest = b;
+                                oldestSequence = bi->seq_number;
+                        }
 		}
 		bi++;
 	}
 
 	if (oldest > 0) {
-		yaffs_trace(YAFFS_TRACE_GC,
-			"GC refresh count %d selected block %d with seq_number %d",
-			dev->refresh_count, oldest, oldest_seq);
+		T(YAFFS_TRACE_GC,
+		  (TSTR("GC refresh count %d selected block %d with seq_number %d" TENDSTR),
+		   dev->refresh_count, oldest, oldestSequence));
 	}
 
 	return oldest;
 }
 
-int yaffs2_checkpt_required(struct yaffs_dev *dev)
+int yaffs2_checkpt_required(yaffs_dev_t *dev)
 {
 	int nblocks;
+	
+	if(!dev->param.is_yaffs2)
+		return 0;
+	
+	nblocks = dev->internal_end_block - dev->internal_start_block + 1 ;
 
-	if (!dev->param.is_yaffs2)
+	return 	!dev->param.skip_checkpt_wr &&
+		!dev->read_only &&
+		(nblocks >= YAFFS_CHECKPOINT_MIN_BLOCKS);
+}
+
+int yaffs_calc_checkpt_blocks_required(yaffs_dev_t *dev)
+{
+	int retval;
+
+	if(!dev->param.is_yaffs2)
 		return 0;
 
-	nblocks = dev->internal_end_block - dev->internal_start_block + 1;
+	if (!dev->checkpoint_blocks_required &&
+		yaffs2_checkpt_required(dev)){
+		/* Not a valid value so recalculate */
+		int n_bytes = 0;
+		int nBlocks;
+		int devBlocks = (dev->param.end_block - dev->param.start_block + 1);
 
-	return !dev->param.skip_checkpt_wr &&
-	    !dev->read_only && (nblocks >= YAFFS_CHECKPOINT_MIN_BLOCKS);
-}
+		n_bytes += sizeof(yaffs_checkpt_validty_t);
+		n_bytes += sizeof(yaffs_checkpt_dev_t);
+		n_bytes += devBlocks * sizeof(yaffs_block_info_t);
+		n_bytes += devBlocks * dev->chunk_bit_stride;
+		n_bytes += (sizeof(yaffs_checkpt_obj_t) + sizeof(__u32)) * (dev->n_obj);
+		n_bytes += (dev->tnode_size + sizeof(__u32)) * (dev->n_tnodes);
+		n_bytes += sizeof(yaffs_checkpt_validty_t);
+		n_bytes += sizeof(__u32); /* checksum*/
 
-int yaffs_calc_checkpt_blocks_required(struct yaffs_dev *dev)
-{
-	int retval;
-	int n_bytes = 0;
-	int n_blocks;
-	int dev_blocks;
+		/* Round up and add 2 blocks to allow for some bad blocks, so add 3 */
 
-	if (!dev->param.is_yaffs2)
-		return 0;
+		nBlocks = (n_bytes/(dev->data_bytes_per_chunk * dev->param.chunks_per_block)) + 3;
 
-	if (!dev->checkpoint_blocks_required && yaffs2_checkpt_required(dev)) {
-		/* Not a valid value so recalculate */
-		dev_blocks = dev->param.end_block - dev->param.start_block + 1;
-		n_bytes += sizeof(struct yaffs_checkpt_validity);
-		n_bytes += sizeof(struct yaffs_checkpt_dev);
-		n_bytes += dev_blocks * sizeof(struct yaffs_block_info);
-		n_bytes += dev_blocks * dev->chunk_bit_stride;
-		n_bytes +=
-		    (sizeof(struct yaffs_checkpt_obj) + sizeof(u32)) *
-		    dev->n_obj;
-		n_bytes += (dev->tnode_size + sizeof(u32)) * dev->n_tnodes;
-		n_bytes += sizeof(struct yaffs_checkpt_validity);
-		n_bytes += sizeof(u32);	/* checksum */
-
-		/* Round up and add 2 blocks to allow for some bad blocks,
-		 * so add 3 */
-
-		n_blocks =
-		    (n_bytes /
-		     (dev->data_bytes_per_chunk *
-		      dev->param.chunks_per_block)) + 3;
-
-		dev->checkpoint_blocks_required = n_blocks;
+		dev->checkpoint_blocks_required = nBlocks;
 	}
 
 	retval = dev->checkpoint_blocks_required - dev->blocks_in_checkpt;
-	if (retval < 0)
+	if(retval < 0)
 		retval = 0;
 	return retval;
 }
 
 /*--------------------- Checkpointing --------------------*/
 
-static int yaffs2_wr_checkpt_validity_marker(struct yaffs_dev *dev, int head)
+
+static int yaffs2_wr_checkpt_validity_marker(yaffs_dev_t *dev, int head)
 {
-	struct yaffs_checkpt_validity cp;
+	yaffs_checkpt_validty_t cp;
 
 	memset(&cp, 0, sizeof(cp));
 
@@ -259,26 +261,27 @@ static int yaffs2_wr_checkpt_validity_ma
 	cp.version = YAFFS_CHECKPOINT_VERSION;
 	cp.head = (head) ? 1 : 0;
 
-	return (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp)) ? 1 : 0;
+	return (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp)) ?
+		1 : 0;
 }
 
-static int yaffs2_rd_checkpt_validity_marker(struct yaffs_dev *dev, int head)
+static int yaffs2_rd_checkpt_validty_marker(yaffs_dev_t *dev, int head)
 {
-	struct yaffs_checkpt_validity cp;
+	yaffs_checkpt_validty_t cp;
 	int ok;
 
 	ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
 
 	if (ok)
 		ok = (cp.struct_type == sizeof(cp)) &&
-		    (cp.magic == YAFFS_MAGIC) &&
-		    (cp.version == YAFFS_CHECKPOINT_VERSION) &&
-		    (cp.head == ((head) ? 1 : 0));
+		     (cp.magic == YAFFS_MAGIC) &&
+		     (cp.version == YAFFS_CHECKPOINT_VERSION) &&
+		     (cp.head == ((head) ? 1 : 0));
 	return ok ? 1 : 0;
 }
 
-static void yaffs2_dev_to_checkpt_dev(struct yaffs_checkpt_dev *cp,
-				      struct yaffs_dev *dev)
+static void yaffs2_dev_to_checkpt_dev(yaffs_checkpt_dev_t *cp,
+					   yaffs_dev_t *dev)
 {
 	cp->n_erased_blocks = dev->n_erased_blocks;
 	cp->alloc_block = dev->alloc_block;
@@ -292,8 +295,8 @@ static void yaffs2_dev_to_checkpt_dev(st
 
 }
 
-static void yaffs_checkpt_dev_to_dev(struct yaffs_dev *dev,
-				     struct yaffs_checkpt_dev *cp)
+static void yaffs_checkpt_dev_to_dev(yaffs_dev_t *dev,
+					   yaffs_checkpt_dev_t *cp)
 {
 	dev->n_erased_blocks = cp->n_erased_blocks;
 	dev->alloc_block = cp->alloc_block;
@@ -306,40 +309,42 @@ static void yaffs_checkpt_dev_to_dev(str
 	dev->seq_number = cp->seq_number;
 }
 
-static int yaffs2_wr_checkpt_dev(struct yaffs_dev *dev)
+
+static int yaffs2_wr_checkpt_dev(yaffs_dev_t *dev)
 {
-	struct yaffs_checkpt_dev cp;
-	u32 n_bytes;
-	u32 n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+	yaffs_checkpt_dev_t cp;
+	__u32 n_bytes;
+	__u32 nBlocks = (dev->internal_end_block - dev->internal_start_block + 1);
+
 	int ok;
 
-	/* Write device runtime values */
+	/* Write device runtime values*/
 	yaffs2_dev_to_checkpt_dev(&cp, dev);
 	cp.struct_type = sizeof(cp);
 
 	ok = (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp));
-	if (!ok)
-		return 0;
 
 	/* Write block info */
-	n_bytes = n_blocks * sizeof(struct yaffs_block_info);
-	ok = (yaffs2_checkpt_wr(dev, dev->block_info, n_bytes) == n_bytes);
-	if (!ok)
-		return 0;
+	if (ok) {
+		n_bytes = nBlocks * sizeof(yaffs_block_info_t);
+		ok = (yaffs2_checkpt_wr(dev, dev->block_info, n_bytes) == n_bytes);
+	}
 
 	/* Write chunk bits */
-	n_bytes = n_blocks * dev->chunk_bit_stride;
-	ok = (yaffs2_checkpt_wr(dev, dev->chunk_bits, n_bytes) == n_bytes);
+	if (ok) {
+		n_bytes = nBlocks * dev->chunk_bit_stride;
+		ok = (yaffs2_checkpt_wr(dev, dev->chunk_bits, n_bytes) == n_bytes);
+	}
+	return	 ok ? 1 : 0;
 
-	return ok ? 1 : 0;
 }
 
-static int yaffs2_rd_checkpt_dev(struct yaffs_dev *dev)
+static int yaffs2_rd_checkpt_dev(yaffs_dev_t *dev)
 {
-	struct yaffs_checkpt_dev cp;
-	u32 n_bytes;
-	u32 n_blocks =
-	    (dev->internal_end_block - dev->internal_start_block + 1);
+	yaffs_checkpt_dev_t cp;
+	__u32 n_bytes;
+	__u32 nBlocks = (dev->internal_end_block - dev->internal_start_block + 1);
+
 	int ok;
 
 	ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
@@ -349,25 +354,26 @@ static int yaffs2_rd_checkpt_dev(struct 
 	if (cp.struct_type != sizeof(cp))
 		return 0;
 
+
 	yaffs_checkpt_dev_to_dev(dev, &cp);
 
-	n_bytes = n_blocks * sizeof(struct yaffs_block_info);
+	n_bytes = nBlocks * sizeof(yaffs_block_info_t);
 
 	ok = (yaffs2_checkpt_rd(dev, dev->block_info, n_bytes) == n_bytes);
 
 	if (!ok)
 		return 0;
-
-	n_bytes = n_blocks * dev->chunk_bit_stride;
+	n_bytes = nBlocks * dev->chunk_bit_stride;
 
 	ok = (yaffs2_checkpt_rd(dev, dev->chunk_bits, n_bytes) == n_bytes);
 
 	return ok ? 1 : 0;
 }
 
-static void yaffs2_obj_checkpt_obj(struct yaffs_checkpt_obj *cp,
-				   struct yaffs_obj *obj)
+static void yaffs2_obj_checkpt_obj(yaffs_checkpt_obj_t *cp,
+					   yaffs_obj_t *obj)
 {
+
 	cp->obj_id = obj->obj_id;
 	cp->parent_id = (obj->parent) ? obj->parent->obj_id : 0;
 	cp->hdr_chunk = obj->hdr_chunk;
@@ -387,35 +393,36 @@ static void yaffs2_obj_checkpt_obj(struc
 		cp->size_or_equiv_obj = obj->variant.hardlink_variant.equiv_id;
 }
 
-static int yaffs2_checkpt_obj_to_obj(struct yaffs_obj *obj,
-				     struct yaffs_checkpt_obj *cp)
+static int taffs2_checkpt_obj_to_obj(yaffs_obj_t *obj, yaffs_checkpt_obj_t *cp)
 {
-	struct yaffs_obj *parent;
+
+	yaffs_obj_t *parent;
 
 	if (obj->variant_type != cp->variant_type) {
-		yaffs_trace(YAFFS_TRACE_ERROR,
-			"Checkpoint read object %d type %d chunk %d does not match existing object type %d",
-			cp->obj_id, cp->variant_type, cp->hdr_chunk,
-			obj->variant_type);
+		T(YAFFS_TRACE_ERROR, (TSTR("Checkpoint read object %d type %d "
+			TCONT("chunk %d does not match existing object type %d")
+			TENDSTR), cp->obj_id, cp->variant_type, cp->hdr_chunk,
+			obj->variant_type));
 		return 0;
 	}
 
 	obj->obj_id = cp->obj_id;
 
 	if (cp->parent_id)
-		parent = yaffs_find_or_create_by_number(obj->my_dev,
-						cp->parent_id,
-						YAFFS_OBJECT_TYPE_DIRECTORY);
+		parent = yaffs_find_or_create_by_number(
+					obj->my_dev,
+					cp->parent_id,
+					YAFFS_OBJECT_TYPE_DIRECTORY);
 	else
 		parent = NULL;
 
 	if (parent) {
 		if (parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
-			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"Checkpoint read object %d parent %d type %d chunk %d Parent type, %d, not directory",
-				cp->obj_id, cp->parent_id,
-				cp->variant_type, cp->hdr_chunk,
-				parent->variant_type);
+			T(YAFFS_TRACE_ALWAYS, (TSTR("Checkpoint read object %d parent %d type %d"
+				TCONT(" chunk %d Parent type, %d, not directory")
+				TENDSTR),
+				cp->obj_id, cp->parent_id, cp->variant_type,
+				cp->hdr_chunk, parent->variant_type));
 			return 0;
 		}
 		yaffs_add_obj_to_dir(parent, obj);
@@ -442,139 +449,133 @@ static int yaffs2_checkpt_obj_to_obj(str
 	return 1;
 }
 
-static int yaffs2_checkpt_tnode_worker(struct yaffs_obj *in,
-				       struct yaffs_tnode *tn, u32 level,
-				       int chunk_offset)
+
+
+static int yaffs2_checkpt_tnode_worker(yaffs_obj_t *in, yaffs_tnode_t *tn,
+					__u32 level, int chunk_offset)
 {
 	int i;
-	struct yaffs_dev *dev = in->my_dev;
+	yaffs_dev_t *dev = in->my_dev;
 	int ok = 1;
-	u32 base_offset;
 
-	if (!tn)
-		return 1;
+	if (tn) {
+		if (level > 0) {
 
-	if (level > 0) {
-		for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
-			if (!tn->internal[i])
-				continue;
-			ok = yaffs2_checkpt_tnode_worker(in,
-				 tn->internal[i],
-				 level - 1,
-				 (chunk_offset <<
-				  YAFFS_TNODES_INTERNAL_BITS) + i);
+			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+				if (tn->internal[i]) {
+					ok = yaffs2_checkpt_tnode_worker(in,
+							tn->internal[i],
+							level - 1,
+							(chunk_offset<<YAFFS_TNODES_INTERNAL_BITS) + i);
+				}
+			}
+		} else if (level == 0) {
+			__u32 baseOffset = chunk_offset <<  YAFFS_TNODES_LEVEL0_BITS;
+			ok = (yaffs2_checkpt_wr(dev, &baseOffset, sizeof(baseOffset)) == sizeof(baseOffset));
+			if (ok)
+				ok = (yaffs2_checkpt_wr(dev, tn, dev->tnode_size) == dev->tnode_size);
 		}
-		return ok;
 	}
 
-	/* Level 0 tnode */
-	base_offset = chunk_offset << YAFFS_TNODES_LEVEL0_BITS;
-	ok = (yaffs2_checkpt_wr(dev, &base_offset, sizeof(base_offset)) ==
-			sizeof(base_offset));
-	if (ok)
-		ok = (yaffs2_checkpt_wr(dev, tn, dev->tnode_size) ==
-			dev->tnode_size);
+	return ok;
 
-	return ok;
 }
 
-static int yaffs2_wr_checkpt_tnodes(struct yaffs_obj *obj)
+static int yaffs2_wr_checkpt_tnodes(yaffs_obj_t *obj)
 {
-	u32 end_marker = ~0;
+	__u32 endMarker = ~0;
 	int ok = 1;
 
-	if (obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
-		return ok;
-
-	ok = yaffs2_checkpt_tnode_worker(obj,
-					 obj->variant.file_variant.top,
-					 obj->variant.file_variant.
-					 top_level, 0);
-	if (ok)
-		ok = (yaffs2_checkpt_wr(obj->my_dev, &end_marker,
-				sizeof(end_marker)) == sizeof(end_marker));
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE) {
+		ok = yaffs2_checkpt_tnode_worker(obj,
+					    obj->variant.file_variant.top,
+					    obj->variant.file_variant.top_level,
+					    0);
+		if (ok)
+			ok = (yaffs2_checkpt_wr(obj->my_dev, &endMarker, sizeof(endMarker)) ==
+				sizeof(endMarker));
+	}
 
 	return ok ? 1 : 0;
 }
 
-static int yaffs2_rd_checkpt_tnodes(struct yaffs_obj *obj)
+static int yaffs2_rd_checkpt_tnodes(yaffs_obj_t *obj)
 {
-	u32 base_chunk;
+	__u32 baseChunk;
 	int ok = 1;
-	struct yaffs_dev *dev = obj->my_dev;
-	struct yaffs_file_var *file_stuct_ptr = &obj->variant.file_variant;
-	struct yaffs_tnode *tn;
+	yaffs_dev_t *dev = obj->my_dev;
+	yaffs_file_s *fileStructPtr = &obj->variant.file_variant;
+	yaffs_tnode_t *tn;
 	int nread = 0;
 
-	ok = (yaffs2_checkpt_rd(dev, &base_chunk, sizeof(base_chunk)) ==
-	      sizeof(base_chunk));
+	ok = (yaffs2_checkpt_rd(dev, &baseChunk, sizeof(baseChunk)) == sizeof(baseChunk));
 
-	while (ok && (~base_chunk)) {
+	while (ok && (~baseChunk)) {
 		nread++;
 		/* Read level 0 tnode */
 
+
 		tn = yaffs_get_tnode(dev);
-		if (tn)
-			ok = (yaffs2_checkpt_rd(dev, tn, dev->tnode_size) ==
-				dev->tnode_size);
-		else
+		if (tn){
+			ok = (yaffs2_checkpt_rd(dev, tn, dev->tnode_size) == dev->tnode_size);
+		} else
 			ok = 0;
 
 		if (tn && ok)
 			ok = yaffs_add_find_tnode_0(dev,
-						    file_stuct_ptr,
-						    base_chunk, tn) ? 1 : 0;
+							fileStructPtr,
+							baseChunk,
+							tn) ? 1 : 0;
 
 		if (ok)
-			ok = (yaffs2_checkpt_rd
-			      (dev, &base_chunk,
-			       sizeof(base_chunk)) == sizeof(base_chunk));
+			ok = (yaffs2_checkpt_rd(dev, &baseChunk, sizeof(baseChunk)) == sizeof(baseChunk));
+
 	}
 
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-		"Checkpoint read tnodes %d records, last %d. ok %d",
-		nread, base_chunk, ok);
+	T(YAFFS_TRACE_CHECKPOINT, (
+		TSTR("Checkpoint read tnodes %d records, last %d. ok %d" TENDSTR),
+		nread, baseChunk, ok));
 
 	return ok ? 1 : 0;
 }
 
-static int yaffs2_wr_checkpt_objs(struct yaffs_dev *dev)
+
+static int yaffs2_wr_checkpt_objs(yaffs_dev_t *dev)
 {
-	struct yaffs_obj *obj;
-	struct yaffs_checkpt_obj cp;
+	yaffs_obj_t *obj;
+	yaffs_checkpt_obj_t cp;
 	int i;
 	int ok = 1;
-	struct list_head *lh;
+	struct ylist_head *lh;
+
 
 	/* Iterate through the objects in each hash entry,
 	 * dumping them to the checkpointing stream.
 	 */
 
-	for (i = 0; ok && i < YAFFS_NOBJECT_BUCKETS; i++) {
-		list_for_each(lh, &dev->obj_bucket[i].list) {
-			obj = list_entry(lh, struct yaffs_obj, hash_link);
-			if (!obj->defered_free) {
-				yaffs2_obj_checkpt_obj(&cp, obj);
-				cp.struct_type = sizeof(cp);
+	for (i = 0; ok &&  i <  YAFFS_NOBJECT_BUCKETS; i++) {
+		ylist_for_each(lh, &dev->obj_bucket[i].list) {
+			if (lh) {
+				obj = ylist_entry(lh, yaffs_obj_t, hash_link);
+				if (!obj->defered_free) {
+					yaffs2_obj_checkpt_obj(&cp, obj);
+					cp.struct_type = sizeof(cp);
 
-				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-					"Checkpoint write object %d parent %d type %d chunk %d obj addr %p",
-					cp.obj_id, cp.parent_id,
-					cp.variant_type, cp.hdr_chunk, obj);
+					T(YAFFS_TRACE_CHECKPOINT, (
+						TSTR("Checkpoint write object %d parent %d type %d chunk %d obj addr %p" TENDSTR),
+						cp.obj_id, cp.parent_id, cp.variant_type, cp.hdr_chunk, obj));
 
-				ok = (yaffs2_checkpt_wr(dev, &cp,
-						sizeof(cp)) == sizeof(cp));
+					ok = (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp));
 
-				if (ok &&
-					obj->variant_type ==
-					YAFFS_OBJECT_TYPE_FILE)
-					ok = yaffs2_wr_checkpt_tnodes(obj);
+					if (ok && obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+						ok = yaffs2_wr_checkpt_tnodes(obj);
+				}
 			}
 		}
 	}
 
 	/* Dump end of list */
-	memset(&cp, 0xff, sizeof(struct yaffs_checkpt_obj));
+	memset(&cp, 0xFF, sizeof(yaffs_checkpt_obj_t));
 	cp.struct_type = sizeof(cp);
 
 	if (ok)
@@ -583,67 +584,59 @@ static int yaffs2_wr_checkpt_objs(struct
 	return ok ? 1 : 0;
 }
 
-static int yaffs2_rd_checkpt_objs(struct yaffs_dev *dev)
+static int yaffs2_rd_checkpt_objs(yaffs_dev_t *dev)
 {
-	struct yaffs_obj *obj;
-	struct yaffs_checkpt_obj cp;
+	yaffs_obj_t *obj;
+	yaffs_checkpt_obj_t cp;
 	int ok = 1;
 	int done = 0;
-	LIST_HEAD(hard_list);
-
+	yaffs_obj_t *hard_list = NULL;
 
 	while (ok && !done) {
 		ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
 		if (cp.struct_type != sizeof(cp)) {
-			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-				"struct size %d instead of %d ok %d",
-				cp.struct_type, (int)sizeof(cp), ok);
+			T(YAFFS_TRACE_CHECKPOINT, (TSTR("struct size %d instead of %d ok %d"TENDSTR),
+				cp.struct_type, (int)sizeof(cp), ok));
 			ok = 0;
 		}
 
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"Checkpoint read object %d parent %d type %d chunk %d ",
-			cp.obj_id, cp.parent_id, cp.variant_type,
-			cp.hdr_chunk);
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("Checkpoint read object %d parent %d type %d chunk %d " TENDSTR),
+			cp.obj_id, cp.parent_id, cp.variant_type, cp.hdr_chunk));
 
-		if (ok && cp.obj_id == ~0) {
+		if (ok && cp.obj_id == ~0)
 			done = 1;
-		} else if (ok) {
-			obj =
-			    yaffs_find_or_create_by_number(dev, cp.obj_id,
-							   cp.variant_type);
+		else if (ok) {
+			obj = yaffs_find_or_create_by_number(dev, cp.obj_id, cp.variant_type);
 			if (obj) {
-				ok = yaffs2_checkpt_obj_to_obj(obj, &cp);
+				ok = taffs2_checkpt_obj_to_obj(obj, &cp);
 				if (!ok)
 					break;
-				if (obj->variant_type ==
-					YAFFS_OBJECT_TYPE_FILE) {
+				if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE) {
 					ok = yaffs2_rd_checkpt_tnodes(obj);
-				} else if (obj->variant_type ==
-					YAFFS_OBJECT_TYPE_HARDLINK) {
-					list_add(&obj->hard_links, &hard_list);
+				} else if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+					obj->hard_links.next =
+						(struct ylist_head *) hard_list;
+					hard_list = obj;
 				}
-			} else {
+			} else
 				ok = 0;
-			}
 		}
 	}
 
 	if (ok)
-		yaffs_link_fixup(dev, &hard_list);
+		yaffs_link_fixup(dev, hard_list);
 
 	return ok ? 1 : 0;
 }
 
-static int yaffs2_wr_checkpt_sum(struct yaffs_dev *dev)
+static int yaffs2_wr_checkpt_sum(yaffs_dev_t *dev)
 {
-	u32 checkpt_sum;
+	__u32 checkpt_sum;
 	int ok;
 
 	yaffs2_get_checkpt_sum(dev, &checkpt_sum);
 
-	ok = (yaffs2_checkpt_wr(dev, &checkpt_sum, sizeof(checkpt_sum)) ==
-		sizeof(checkpt_sum));
+	ok = (yaffs2_checkpt_wr(dev, &checkpt_sum, sizeof(checkpt_sum)) == sizeof(checkpt_sum));
 
 	if (!ok)
 		return 0;
@@ -651,16 +644,15 @@ static int yaffs2_wr_checkpt_sum(struct 
 	return 1;
 }
 
-static int yaffs2_rd_checkpt_sum(struct yaffs_dev *dev)
+static int yaffs2_rd_checkpt_sum(yaffs_dev_t *dev)
 {
-	u32 checkpt_sum0;
-	u32 checkpt_sum1;
+	__u32 checkpt_sum0;
+	__u32 checkpt_sum1;
 	int ok;
 
 	yaffs2_get_checkpt_sum(dev, &checkpt_sum0);
 
-	ok = (yaffs2_checkpt_rd(dev, &checkpt_sum1, sizeof(checkpt_sum1)) ==
-		sizeof(checkpt_sum1));
+	ok = (yaffs2_checkpt_rd(dev, &checkpt_sum1, sizeof(checkpt_sum1)) == sizeof(checkpt_sum1));
 
 	if (!ok)
 		return 0;
@@ -671,13 +663,13 @@ static int yaffs2_rd_checkpt_sum(struct 
 	return 1;
 }
 
-static int yaffs2_wr_checkpt_data(struct yaffs_dev *dev)
+
+static int yaffs2_wr_checkpt_data(yaffs_dev_t *dev)
 {
 	int ok = 1;
 
 	if (!yaffs2_checkpt_required(dev)) {
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"skipping checkpoint write");
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("skipping checkpoint write" TENDSTR)));
 		ok = 0;
 	}
 
@@ -685,23 +677,19 @@ static int yaffs2_wr_checkpt_data(struct
 		ok = yaffs2_checkpt_open(dev, 1);
 
 	if (ok) {
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"write checkpoint validity");
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint validity" TENDSTR)));
 		ok = yaffs2_wr_checkpt_validity_marker(dev, 1);
 	}
 	if (ok) {
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"write checkpoint device");
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint device" TENDSTR)));
 		ok = yaffs2_wr_checkpt_dev(dev);
 	}
 	if (ok) {
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"write checkpoint objects");
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint objects" TENDSTR)));
 		ok = yaffs2_wr_checkpt_objs(dev);
 	}
 	if (ok) {
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"write checkpoint validity");
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint validity" TENDSTR)));
 		ok = yaffs2_wr_checkpt_validity_marker(dev, 0);
 	}
 
@@ -719,16 +707,15 @@ static int yaffs2_wr_checkpt_data(struct
 	return dev->is_checkpointed;
 }
 
-static int yaffs2_rd_checkpt_data(struct yaffs_dev *dev)
+static int yaffs2_rd_checkpt_data(yaffs_dev_t *dev)
 {
 	int ok = 1;
-
-	if (!dev->param.is_yaffs2)
+	
+	if(!dev->param.is_yaffs2)
 		ok = 0;
 
 	if (ok && dev->param.skip_checkpt_rd) {
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"skipping checkpoint read");
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("skipping checkpoint read" TENDSTR)));
 		ok = 0;
 	}
 
@@ -736,30 +723,25 @@ static int yaffs2_rd_checkpt_data(struct
 		ok = yaffs2_checkpt_open(dev, 0); /* open for read */
 
 	if (ok) {
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"read checkpoint validity");
-		ok = yaffs2_rd_checkpt_validity_marker(dev, 1);
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint validity" TENDSTR)));
+		ok = yaffs2_rd_checkpt_validty_marker(dev, 1);
 	}
 	if (ok) {
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"read checkpoint device");
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint device" TENDSTR)));
 		ok = yaffs2_rd_checkpt_dev(dev);
 	}
 	if (ok) {
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"read checkpoint objects");
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint objects" TENDSTR)));
 		ok = yaffs2_rd_checkpt_objs(dev);
 	}
 	if (ok) {
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"read checkpoint validity");
-		ok = yaffs2_rd_checkpt_validity_marker(dev, 0);
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint validity" TENDSTR)));
+		ok = yaffs2_rd_checkpt_validty_marker(dev, 0);
 	}
 
 	if (ok) {
 		ok = yaffs2_rd_checkpt_sum(dev);
-		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-			"read checkpoint checksum %d", ok);
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint checksum %d" TENDSTR), ok));
 	}
 
 	if (!yaffs_checkpt_close(dev))
@@ -771,11 +753,13 @@ static int yaffs2_rd_checkpt_data(struct
 		dev->is_checkpointed = 0;
 
 	return ok ? 1 : 0;
+
 }
 
-void yaffs2_checkpt_invalidate(struct yaffs_dev *dev)
+void yaffs2_checkpt_invalidate(yaffs_dev_t *dev)
 {
-	if (dev->is_checkpointed || dev->blocks_in_checkpt > 0) {
+	if (dev->is_checkpointed ||
+			dev->blocks_in_checkpt > 0) {
 		dev->is_checkpointed = 0;
 		yaffs2_checkpt_invalidate_stream(dev);
 	}
@@ -783,11 +767,11 @@ void yaffs2_checkpt_invalidate(struct ya
 		dev->param.sb_dirty_fn(dev);
 }
 
-int yaffs_checkpoint_save(struct yaffs_dev *dev)
+
+int yaffs_checkpoint_save(yaffs_dev_t *dev)
 {
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-		"save entry: is_checkpointed %d",
-		dev->is_checkpointed);
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("save entry: is_checkpointed %d"TENDSTR), dev->is_checkpointed));
 
 	yaffs_verify_objects(dev);
 	yaffs_verify_blocks(dev);
@@ -798,20 +782,15 @@ int yaffs_checkpoint_save(struct yaffs_d
 		yaffs2_wr_checkpt_data(dev);
 	}
 
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT | YAFFS_TRACE_MOUNT,
-		"save exit: is_checkpointed %d",
-		dev->is_checkpointed);
+	T(YAFFS_TRACE_ALWAYS, (TSTR("save exit: is_checkpointed %d"TENDSTR), dev->is_checkpointed));
 
 	return dev->is_checkpointed;
 }
 
-int yaffs2_checkpt_restore(struct yaffs_dev *dev)
+int yaffs2_checkpt_restore(yaffs_dev_t *dev)
 {
 	int retval;
-
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-		"restore entry: is_checkpointed %d",
-		dev->is_checkpointed);
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("restore entry: is_checkpointed %d"TENDSTR), dev->is_checkpointed));
 
 	retval = yaffs2_rd_checkpt_data(dev);
 
@@ -821,578 +800,177 @@ int yaffs2_checkpt_restore(struct yaffs_
 		yaffs_verify_free_chunks(dev);
 	}
 
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-		"restore exit: is_checkpointed %d",
-		dev->is_checkpointed);
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("restore exit: is_checkpointed %d"TENDSTR), dev->is_checkpointed));
 
 	return retval;
 }
 
-int yaffs2_handle_hole(struct yaffs_obj *obj, loff_t new_size)
+int yaffs2_handle_hole(yaffs_obj_t *obj, loff_t new_size)
 {
-	/* if new_size > old_file_size.
+	/* if newsSize > oldFileSize.
 	 * We're going to be writing a hole.
-	 * If the hole is small then write zeros otherwise write a start
-	 * of hole marker.
+	 * If the hole is small then write zeros otherwise write a start of hole marker.
 	 */
-	loff_t old_file_size;
-	loff_t increase;
-	int small_hole;
+		
+
+	loff_t oldFileSize;
+	int increase;
+	int smallHole   ;
 	int result = YAFFS_OK;
-	struct yaffs_dev *dev = NULL;
-	u8 *local_buffer = NULL;
-	int small_increase_ok = 0;
+	yaffs_dev_t *dev = NULL;
 
-	if (!obj)
+	__u8 *localBuffer = NULL;
+	
+	int smallIncreaseOk = 0;
+	
+	if(!obj)
 		return YAFFS_FAIL;
 
-	if (obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
+	if(obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
 		return YAFFS_FAIL;
-
+	
 	dev = obj->my_dev;
-
+	
 	/* Bail out if not yaffs2 mode */
-	if (!dev->param.is_yaffs2)
+	if(!dev->param.is_yaffs2)
 		return YAFFS_OK;
 
-	old_file_size = obj->variant.file_variant.file_size;
+	oldFileSize = obj->variant.file_variant.file_size;
 
-	if (new_size <= old_file_size)
+	if (new_size <= oldFileSize)
 		return YAFFS_OK;
 
-	increase = new_size - old_file_size;
+	increase = new_size - oldFileSize;
 
-	if (increase < YAFFS_SMALL_HOLE_THRESHOLD * dev->data_bytes_per_chunk &&
-	    yaffs_check_alloc_available(dev, YAFFS_SMALL_HOLE_THRESHOLD + 1))
-		small_hole = 1;
+	if(increase < YAFFS_SMALL_HOLE_THRESHOLD * dev->data_bytes_per_chunk &&
+		yaffs_check_alloc_available(dev, YAFFS_SMALL_HOLE_THRESHOLD + 1))
+		smallHole = 1;
 	else
-		small_hole = 0;
+		smallHole = 0;
 
-	if (small_hole)
-		local_buffer = yaffs_get_temp_buffer(dev);
+	if(smallHole)
+		localBuffer= yaffs_get_temp_buffer(dev, __LINE__);
+	
+	if(localBuffer){
+		/* fill hole with zero bytes */
+		int pos = oldFileSize;
+		int thisWrite;
+		int written;
+		memset(localBuffer,0,dev->data_bytes_per_chunk);
+		smallIncreaseOk = 1;
 
-	if (local_buffer) {
-		/* fill hole with zero bytes */
-		loff_t pos = old_file_size;
-		int this_write;
-		int written;
-		memset(local_buffer, 0, dev->data_bytes_per_chunk);
-		small_increase_ok = 1;
-
-		while (increase > 0 && small_increase_ok) {
-			this_write = increase;
-			if (this_write > dev->data_bytes_per_chunk)
-				this_write = dev->data_bytes_per_chunk;
-			written =
-			    yaffs_do_file_wr(obj, local_buffer, pos, this_write,
-					     0);
-			if (written == this_write) {
-				pos += this_write;
-				increase -= this_write;
-			} else {
-				small_increase_ok = 0;
-			}
+		while(increase > 0 && smallIncreaseOk){
+			thisWrite = increase;
+			if(thisWrite > dev->data_bytes_per_chunk)
+				thisWrite = dev->data_bytes_per_chunk;
+			written = yaffs_do_file_wr(obj,localBuffer,pos,thisWrite,0);
+			if(written == thisWrite){
+				pos += thisWrite;
+				increase -= thisWrite;
+			} else
+				smallIncreaseOk = 0;
 		}
 
-		yaffs_release_temp_buffer(dev, local_buffer);
+		yaffs_release_temp_buffer(dev,localBuffer,__LINE__);
 
-		/* If out of space then reverse any chunks we've added */
-		if (!small_increase_ok)
-			yaffs_resize_file_down(obj, old_file_size);
+		/* If we were out of space then reverse any chunks we've added */		
+		if(!smallIncreaseOk)
+			yaffs_resize_file_down(obj, oldFileSize);
 	}
-
-	if (!small_increase_ok &&
-	    obj->parent &&
-	    obj->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
-	    obj->parent->obj_id != YAFFS_OBJECTID_DELETED) {
+	
+	if (!smallIncreaseOk &&
+		obj->parent &&
+		obj->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
+		obj->parent->obj_id != YAFFS_OBJECTID_DELETED){
 		/* Write a hole start header with the old file size */
 		yaffs_update_oh(obj, NULL, 0, 1, 0, NULL);
 	}
 
 	return result;
+
 }
 
-struct yaffs_block_index {
+
+typedef struct {
 	int seq;
 	int block;
-};
+} yaffs_BlockIndex;
+
 
 static int yaffs2_ybicmp(const void *a, const void *b)
 {
-	int aseq = ((struct yaffs_block_index *)a)->seq;
-	int bseq = ((struct yaffs_block_index *)b)->seq;
-	int ablock = ((struct yaffs_block_index *)a)->block;
-	int bblock = ((struct yaffs_block_index *)b)->block;
-
+	register int aseq = ((yaffs_BlockIndex *)a)->seq;
+	register int bseq = ((yaffs_BlockIndex *)b)->seq;
+	register int ablock = ((yaffs_BlockIndex *)a)->block;
+	register int bblock = ((yaffs_BlockIndex *)b)->block;
 	if (aseq == bseq)
 		return ablock - bblock;
-
-	return aseq - bseq;
+	else
+		return aseq - bseq;
 }
 
-static inline int yaffs2_scan_chunk(struct yaffs_dev *dev,
-		struct yaffs_block_info *bi,
-		int blk, int chunk_in_block,
-		int *found_chunks,
-		u8 *chunk_data,
-		struct list_head *hard_list,
-		int summary_available)
+int yaffs2_scan_backwards(yaffs_dev_t *dev)
 {
-	struct yaffs_obj_hdr *oh;
-	struct yaffs_obj *in;
-	struct yaffs_obj *parent;
-	int equiv_id;
-	loff_t file_size;
-	int is_shrink;
-	int is_unlinked;
-	struct yaffs_ext_tags tags;
+	yaffs_ext_tags tags;
+	int blk;
+	int blockIterator;
+	int startIterator;
+	int endIterator;
+	int nBlocksToScan = 0;
+
+	int chunk;
 	int result;
-	int alloc_failed = 0;
-	int chunk = blk * dev->param.chunks_per_block + chunk_in_block;
-	struct yaffs_file_var *file_var;
-	struct yaffs_hardlink_var *hl_var;
-	struct yaffs_symlink_var *sl_var;
-
-	if (summary_available) {
-		result = yaffs_summary_fetch(dev, &tags, chunk_in_block);
-		tags.seq_number = bi->seq_number;
-	}
-
-	if (!summary_available || tags.obj_id == 0) {
-		result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL, &tags);
-		dev->tags_used++;
-	} else {
-		dev->summary_used++;
-	}
-
-	/* Let's have a good look at this chunk... */
-
-	if (!tags.chunk_used) {
-		/* An unassigned chunk in the block.
-		 * If there are used chunks after this one, then
-		 * it is a chunk that was skipped due to failing
-		 * the erased check. Just skip it so that it can
-		 * be deleted.
-		 * But, more typically, We get here when this is
-		 * an unallocated chunk and his means that
-		 * either the block is empty or this is the one
-		 * being allocated from
-		 */
-
-		if (*found_chunks) {
-			/* This is a chunk that was skipped due
-			 * to failing the erased check */
-		} else if (chunk_in_block == 0) {
-			/* We're looking at the first chunk in
-			 * the block so the block is unused */
-			bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
-			dev->n_erased_blocks++;
-		} else {
-			if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
-			    bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
-				if (dev->seq_number == bi->seq_number) {
-					/* Allocating from this block*/
-					yaffs_trace(YAFFS_TRACE_SCAN,
-					    " Allocating from %d %d",
-					    blk, chunk_in_block);
-
-					bi->block_state =
-						YAFFS_BLOCK_STATE_ALLOCATING;
-					dev->alloc_block = blk;
-					dev->alloc_page = chunk_in_block;
-					dev->alloc_block_finder = blk;
-				} else {
-					/* This is a partially written block
-					 * that is not the current
-					 * allocation block.
-					 */
-					yaffs_trace(YAFFS_TRACE_SCAN,
-						"Partially written block %d detected. gc will fix this.",
-						blk);
-				}
-			}
-		}
-
-		dev->n_free_chunks++;
-
-	} else if (tags.ecc_result ==
-		YAFFS_ECC_RESULT_UNFIXED) {
-		yaffs_trace(YAFFS_TRACE_SCAN,
-			" Unfixed ECC in chunk(%d:%d), chunk ignored",
-			blk, chunk_in_block);
-			dev->n_free_chunks++;
-	} else if (tags.obj_id > YAFFS_MAX_OBJECT_ID ||
-		   tags.chunk_id > YAFFS_MAX_CHUNK_ID ||
-		   tags.obj_id == YAFFS_OBJECTID_SUMMARY ||
-		   (tags.chunk_id > 0 &&
-		     tags.n_bytes > dev->data_bytes_per_chunk) ||
-		   tags.seq_number != bi->seq_number) {
-		yaffs_trace(YAFFS_TRACE_SCAN,
-			"Chunk (%d:%d) with bad tags:obj = %d, chunk_id = %d, n_bytes = %d, ignored",
-			blk, chunk_in_block, tags.obj_id,
-			tags.chunk_id, tags.n_bytes);
-		dev->n_free_chunks++;
-	} else if (tags.chunk_id > 0) {
-		/* chunk_id > 0 so it is a data chunk... */
-		loff_t endpos;
-		loff_t chunk_base = (tags.chunk_id - 1) *
-					dev->data_bytes_per_chunk;
-
-		*found_chunks = 1;
-
-		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
-		bi->pages_in_use++;
-
-		in = yaffs_find_or_create_by_number(dev,
-					tags.obj_id,
-					YAFFS_OBJECT_TYPE_FILE);
-		if (!in)
-			/* Out of memory */
-			alloc_failed = 1;
-
-		if (in &&
-		    in->variant_type == YAFFS_OBJECT_TYPE_FILE &&
-		    chunk_base < in->variant.file_variant.shrink_size) {
-			/* This has not been invalidated by
-			 * a resize */
-			if (!yaffs_put_chunk_in_file(in, tags.chunk_id,
-								chunk, -1))
-				alloc_failed = 1;
-
-			/* File size is calculated by looking at
-			 * the data chunks if we have not
-			 * seen an object header yet.
-			 * Stop this practice once we find an
-			 * object header.
-			 */
-			endpos = chunk_base + tags.n_bytes;
-
-			if (!in->valid &&
-			    in->variant.file_variant.scanned_size < endpos) {
-				in->variant.file_variant.
-				    scanned_size = endpos;
-				in->variant.file_variant.
-				    file_size = endpos;
-			}
-		} else if (in) {
-			/* This chunk has been invalidated by a
-			 * resize, or a past file deletion
-			 * so delete the chunk*/
-			yaffs_chunk_del(dev, chunk, 1, __LINE__);
-		}
-	} else {
-		/* chunk_id == 0, so it is an ObjectHeader.
-		 * Thus, we read in the object header and make
-		 * the object
-		 */
-		*found_chunks = 1;
-
-		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
-		bi->pages_in_use++;
-
-		oh = NULL;
-		in = NULL;
-
-		if (tags.extra_available) {
-			in = yaffs_find_or_create_by_number(dev,
-					tags.obj_id,
-					tags.extra_obj_type);
-			if (!in)
-				alloc_failed = 1;
-		}
-
-		if (!in ||
-		    (!in->valid && dev->param.disable_lazy_load) ||
-		    tags.extra_shadows ||
-		    (!in->valid && (tags.obj_id == YAFFS_OBJECTID_ROOT ||
-				 tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND))) {
-
-			/* If we don't have  valid info then we
-			 * need to read the chunk
-			 * TODO In future we can probably defer
-			 * reading the chunk and living with
-			 * invalid data until needed.
-			 */
-
-			result = yaffs_rd_chunk_tags_nand(dev,
-						  chunk,
-						  chunk_data,
-						  NULL);
-
-			oh = (struct yaffs_obj_hdr *)chunk_data;
-
-			if (dev->param.inband_tags) {
-				/* Fix up the header if they got
-				 * corrupted by inband tags */
-				oh->shadows_obj =
-				    oh->inband_shadowed_obj_id;
-				oh->is_shrink =
-				    oh->inband_is_shrink;
-			}
-
-			if (!in) {
-				in = yaffs_find_or_create_by_number(dev,
-							tags.obj_id, oh->type);
-				if (!in)
-					alloc_failed = 1;
-			}
-		}
-
-		if (!in) {
-			/* TODO Hoosterman we have a problem! */
-			yaffs_trace(YAFFS_TRACE_ERROR,
-				"yaffs tragedy: Could not make object for object  %d at chunk %d during scan",
-				tags.obj_id, chunk);
-			return YAFFS_FAIL;
-		}
-
-		if (in->valid) {
-			/* We have already filled this one.
-			 * We have a duplicate that will be
-			 * discarded, but we first have to suck
-			 * out resize info if it is a file.
-			 */
-			if ((in->variant_type == YAFFS_OBJECT_TYPE_FILE) &&
-				((oh && oh->type == YAFFS_OBJECT_TYPE_FILE) ||
-				 (tags.extra_available &&
-				  tags.extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
-				)) {
-				loff_t this_size = (oh) ?
-					yaffs_oh_to_size(oh) :
-					tags.extra_file_size;
-				u32 parent_obj_id = (oh) ?
-					oh->parent_obj_id :
-					tags.extra_parent_id;
-
-				is_shrink = (oh) ?
-					oh->is_shrink :
-					tags.extra_is_shrink;
-
-				/* If it is deleted (unlinked
-				 * at start also means deleted)
-				 * we treat the file size as
-				 * being zeroed at this point.
-				 */
-				if (parent_obj_id == YAFFS_OBJECTID_DELETED ||
-				    parent_obj_id == YAFFS_OBJECTID_UNLINKED) {
-					this_size = 0;
-					is_shrink = 1;
-				}
-
-				if (is_shrink &&
-				    in->variant.file_variant.shrink_size >
-				    this_size)
-					in->variant.file_variant.shrink_size =
-					this_size;
-
-				if (is_shrink)
-					bi->has_shrink_hdr = 1;
-			}
-			/* Use existing - destroy this one. */
-			yaffs_chunk_del(dev, chunk, 1, __LINE__);
-		}
-
-		if (!in->valid && in->variant_type !=
-		    (oh ? oh->type : tags.extra_obj_type)) {
-			yaffs_trace(YAFFS_TRACE_ERROR,
-				"yaffs tragedy: Bad type, %d != %d, for object %d at chunk %d during scan",
-				oh ? oh->type : tags.extra_obj_type,
-				in->variant_type, tags.obj_id,
-				chunk);
-			in = yaffs_retype_obj(in, oh ? oh->type : tags.extra_obj_type);
-		}
-
-		if (!in->valid &&
-		    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
-		     tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND)) {
-			/* We only load some info, don't fiddle
-			 * with directory structure */
-			in->valid = 1;
-
-			if (oh) {
-				in->yst_mode = oh->yst_mode;
-				yaffs_load_attribs(in, oh);
-				in->lazy_loaded = 0;
-			} else {
-				in->lazy_loaded = 1;
-			}
-			in->hdr_chunk = chunk;
-
-		} else if (!in->valid) {
-			/* we need to load this info */
-			in->valid = 1;
-			in->hdr_chunk = chunk;
-			if (oh) {
-				in->variant_type = oh->type;
-				in->yst_mode = oh->yst_mode;
-				yaffs_load_attribs(in, oh);
-
-				if (oh->shadows_obj > 0)
-					yaffs_handle_shadowed_obj(dev,
-					     oh->shadows_obj, 1);
-
-				yaffs_set_obj_name_from_oh(in, oh);
-				parent = yaffs_find_or_create_by_number(dev,
-						oh->parent_obj_id,
-						YAFFS_OBJECT_TYPE_DIRECTORY);
-				file_size = yaffs_oh_to_size(oh);
-				is_shrink = oh->is_shrink;
-				equiv_id = oh->equiv_id;
-			} else {
-				in->variant_type = tags.extra_obj_type;
-				parent = yaffs_find_or_create_by_number(dev,
-						tags.extra_parent_id,
-						YAFFS_OBJECT_TYPE_DIRECTORY);
-				file_size = tags.extra_file_size;
-				is_shrink = tags.extra_is_shrink;
-				equiv_id = tags.extra_equiv_id;
-				in->lazy_loaded = 1;
-			}
-			in->dirty = 0;
-
-			if (!parent)
-				alloc_failed = 1;
-
-			/* directory stuff...
-			 * hook up to parent
-			 */
-
-			if (parent &&
-			    parent->variant_type == YAFFS_OBJECT_TYPE_UNKNOWN) {
-				/* Set up as a directory */
-				parent->variant_type =
-					YAFFS_OBJECT_TYPE_DIRECTORY;
-				INIT_LIST_HEAD(&parent->
-						variant.dir_variant.children);
-			} else if (!parent ||
-				   parent->variant_type !=
-					YAFFS_OBJECT_TYPE_DIRECTORY) {
-				/* Hoosterman, another problem....
-				 * Trying to use a non-directory as a directory
-				 */
-
-				yaffs_trace(YAFFS_TRACE_ERROR,
-					"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
-					);
-				parent = dev->lost_n_found;
-			}
-			yaffs_add_obj_to_dir(parent, in);
-
-			is_unlinked = (parent == dev->del_dir) ||
-					(parent == dev->unlinked_dir);
-
-			if (is_shrink)
-				/* Mark the block */
-				bi->has_shrink_hdr = 1;
-
-			/* Note re hardlinks.
-			 * Since we might scan a hardlink before its equivalent
-			 * object is scanned we put them all in a list.
-			 * After scanning is complete, we should have all the
-			 * objects, so we run through this list and fix up all
-			 * the chains.
-			 */
-
-			switch (in->variant_type) {
-			case YAFFS_OBJECT_TYPE_UNKNOWN:
-				/* Todo got a problem */
-				break;
-			case YAFFS_OBJECT_TYPE_FILE:
-				file_var = &in->variant.file_variant;
-				if (file_var->scanned_size < file_size) {
-					/* This covers the case where the file
-					 * size is greater than the data held.
-					 * This will happen if the file is
-					 * resized to be larger than its
-					 * current data extents.
-					 */
-					file_var->file_size = file_size;
-					file_var->scanned_size = file_size;
-				}
-
-				if (file_var->shrink_size > file_size)
-					file_var->shrink_size = file_size;
-
-				break;
-			case YAFFS_OBJECT_TYPE_HARDLINK:
-				hl_var = &in->variant.hardlink_variant;
-				if (!is_unlinked) {
-					hl_var->equiv_id = equiv_id;
-					list_add(&in->hard_links, hard_list);
-				}
-				break;
-			case YAFFS_OBJECT_TYPE_DIRECTORY:
-				/* Do nothing */
-				break;
-			case YAFFS_OBJECT_TYPE_SPECIAL:
-				/* Do nothing */
-				break;
-			case YAFFS_OBJECT_TYPE_SYMLINK:
-				sl_var = &in->variant.symlink_variant;
-				if (oh) {
-					sl_var->alias =
-					    yaffs_clone_str(oh->alias);
-					if (!sl_var->alias)
-						alloc_failed = 1;
-				}
-				break;
-			}
-		}
-	}
-	return alloc_failed ? YAFFS_FAIL : YAFFS_OK;
-}
-
-int yaffs2_scan_backwards(struct yaffs_dev *dev)
-{
-	int blk;
-	int block_iter;
-	int start_iter;
-	int end_iter;
-	int n_to_scan = 0;
-	enum yaffs_block_state state;
 	int c;
 	int deleted;
-	LIST_HEAD(hard_list);
-	struct yaffs_block_info *bi;
-	u32 seq_number;
-	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
-	u8 *chunk_data;
-	int found_chunks;
+	yaffs_block_state_t state;
+	yaffs_obj_t *hard_list = NULL;
+	yaffs_block_info_t *bi;
+	__u32 seq_number;
+	yaffs_obj_header *oh;
+	yaffs_obj_t *in;
+	yaffs_obj_t *parent;
+	int nBlocks = dev->internal_end_block - dev->internal_start_block + 1;
+	int itsUnlinked;
+	__u8 *chunkData;
+
+	int file_size;
+	int is_shrink;
+	int foundChunksInBlock;
+	int equiv_id;
 	int alloc_failed = 0;
-	struct yaffs_block_index *block_index = NULL;
-	int alt_block_index = 0;
-	int summary_available;
 
-	yaffs_trace(YAFFS_TRACE_SCAN,
-		"yaffs2_scan_backwards starts  intstartblk %d intendblk %d...",
-		dev->internal_start_block, dev->internal_end_block);
+
+	yaffs_BlockIndex *blockIndex = NULL;
+	int altBlockIndex = 0;
+
+	T(YAFFS_TRACE_SCAN,
+	  (TSTR
+	   ("yaffs2_scan_backwards starts  intstartblk %d intendblk %d..."
+	    TENDSTR), dev->internal_start_block, dev->internal_end_block));
+
 
 	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
 
-	block_index =
-		kmalloc(n_blocks * sizeof(struct yaffs_block_index), GFP_NOFS);
+	blockIndex = YMALLOC(nBlocks * sizeof(yaffs_BlockIndex));
 
-	if (!block_index) {
-		block_index =
-		    vmalloc(n_blocks * sizeof(struct yaffs_block_index));
-		alt_block_index = 1;
+	if (!blockIndex) {
+		blockIndex = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockIndex));
+		altBlockIndex = 1;
 	}
 
-	if (!block_index) {
-		yaffs_trace(YAFFS_TRACE_SCAN,
-			"yaffs2_scan_backwards() could not allocate block index!"
-			);
+	if (!blockIndex) {
+		T(YAFFS_TRACE_SCAN,
+		  (TSTR("yaffs2_scan_backwards() could not allocate block index!" TENDSTR)));
 		return YAFFS_FAIL;
 	}
 
 	dev->blocks_in_checkpt = 0;
 
-	chunk_data = yaffs_get_temp_buffer(dev);
+	chunkData = yaffs_get_temp_buffer(dev, __LINE__);
 
 	/* Scan all the blocks to determine their state */
 	bi = dev->block_info;
-	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
-	     blk++) {
+	for (blk = dev->internal_start_block; blk <= dev->internal_end_block; blk++) {
 		yaffs_clear_chunk_bits(dev, blk);
 		bi->pages_in_use = 0;
 		bi->soft_del_pages = 0;
@@ -1403,103 +981,529 @@ int yaffs2_scan_backwards(struct yaffs_d
 		bi->seq_number = seq_number;
 
 		if (bi->seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA)
-			bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+			bi->block_state = state = YAFFS_BLOCK_STATE_CHECKPOINT;
 		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
-			bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+			bi->block_state = state = YAFFS_BLOCK_STATE_DEAD;
 
-		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
-			"Block scanning block %d state %d seq %d",
-			blk, bi->block_state, seq_number);
+		T(YAFFS_TRACE_SCAN_DEBUG,
+		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
+		   state, seq_number));
 
-		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+
+		if (state == YAFFS_BLOCK_STATE_CHECKPOINT) {
 			dev->blocks_in_checkpt++;
 
-		} else if (bi->block_state == YAFFS_BLOCK_STATE_DEAD) {
-			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
-				"block %d is bad", blk);
-		} else if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
-			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
+		} else if (state == YAFFS_BLOCK_STATE_DEAD) {
+			T(YAFFS_TRACE_BAD_BLOCKS,
+			  (TSTR("block %d is bad" TENDSTR), blk));
+		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
+			T(YAFFS_TRACE_SCAN_DEBUG,
+			  (TSTR("Block empty " TENDSTR)));
 			dev->n_erased_blocks++;
 			dev->n_free_chunks += dev->param.chunks_per_block;
-		} else if (bi->block_state ==
-				YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+		} else if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+
 			/* Determine the highest sequence number */
 			if (seq_number >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
 			    seq_number < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
-				block_index[n_to_scan].seq = seq_number;
-				block_index[n_to_scan].block = blk;
-				n_to_scan++;
+
+				blockIndex[nBlocksToScan].seq = seq_number;
+				blockIndex[nBlocksToScan].block = blk;
+
+				nBlocksToScan++;
+
 				if (seq_number >= dev->seq_number)
 					dev->seq_number = seq_number;
 			} else {
 				/* TODO: Nasty sequence number! */
-				yaffs_trace(YAFFS_TRACE_SCAN,
-					"Block scanning block %d has bad sequence number %d",
-					blk, seq_number);
+				T(YAFFS_TRACE_SCAN,
+				  (TSTR
+				   ("Block scanning block %d has bad sequence number %d"
+				    TENDSTR), blk, seq_number));
+
 			}
 		}
 		bi++;
 	}
 
-	yaffs_trace(YAFFS_TRACE_ALWAYS, "%d blocks to be sorted...", n_to_scan);
+	T(YAFFS_TRACE_SCAN,
+	(TSTR("%d blocks to be sorted..." TENDSTR), nBlocksToScan));
 
-	cond_resched();
 
-	/* Sort the blocks by sequence number */
-	sort(block_index, n_to_scan, sizeof(struct yaffs_block_index),
-		   yaffs2_ybicmp, NULL);
 
-	cond_resched();
+	YYIELD();
 
-	yaffs_trace(YAFFS_TRACE_SCAN, "...done");
+	/* Sort the blocks by sequence number*/
+	yaffs_qsort(blockIndex, nBlocksToScan, sizeof(yaffs_BlockIndex), yaffs2_ybicmp);
+
+	YYIELD();
+
+	T(YAFFS_TRACE_SCAN, (TSTR("...done" TENDSTR)));
 
 	/* Now scan the blocks looking at the data. */
-	start_iter = 0;
-	end_iter = n_to_scan - 1;
-	yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "%d blocks to scan", n_to_scan);
+	startIterator = 0;
+	endIterator = nBlocksToScan - 1;
+	T(YAFFS_TRACE_SCAN_DEBUG,
+	  (TSTR("%d blocks to be scanned" TENDSTR), nBlocksToScan));
 
 	/* For each block.... backwards */
-	for (block_iter = end_iter;
-	     !alloc_failed && block_iter >= start_iter;
-	     block_iter--) {
+	for (blockIterator = endIterator; !alloc_failed && blockIterator >= startIterator;
+			blockIterator--) {
 		/* Cooperative multitasking! This loop can run for so
 		   long that watchdog timers expire. */
-		cond_resched();
+		YYIELD();
 
 		/* get the block to scan in the correct order */
-		blk = block_index[block_iter].block;
+		blk = blockIndex[blockIterator].block;
+
 		bi = yaffs_get_block_info(dev, blk);
+
+
+		state = bi->block_state;
+
 		deleted = 0;
 
-		summary_available = yaffs_summary_read(dev, dev->sum_tags, blk);
-
 		/* For each chunk in each block that needs scanning.... */
-		found_chunks = 0;
-		if (summary_available)
-			c = dev->chunks_per_summary - 1;
-		else
-			c = dev->param.chunks_per_block - 1;
-
-		for (/* c is already initialised */;
+		foundChunksInBlock = 0;
+		for (c = dev->param.chunks_per_block - 1;
 		     !alloc_failed && c >= 0 &&
-		     (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
-		      bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING);
-		      c--) {
+		     (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+		      state == YAFFS_BLOCK_STATE_ALLOCATING); c--) {
 			/* Scan backwards...
 			 * Read the tags and decide what to do
 			 */
-			if (yaffs2_scan_chunk(dev, bi, blk, c,
-					&found_chunks, chunk_data,
-					&hard_list, summary_available) ==
-					YAFFS_FAIL)
-				alloc_failed = 1;
+
+			chunk = blk * dev->param.chunks_per_block + c;
+
+			result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL,
+							&tags);
+
+			/* Let's have a good look at this chunk... */
+
+			if (!tags.chunk_used) {
+				/* An unassigned chunk in the block.
+				 * If there are used chunks after this one, then
+				 * it is a chunk that was skipped due to failing the erased
+				 * check. Just skip it so that it can be deleted.
+				 * But, more typically, We get here when this is an unallocated
+				 * chunk and his means that either the block is empty or
+				 * this is the one being allocated from
+				 */
+
+				if (foundChunksInBlock) {
+					/* This is a chunk that was skipped due to failing the erased check */
+				} else if (c == 0) {
+					/* We're looking at the first chunk in the block so the block is unused */
+					state = YAFFS_BLOCK_STATE_EMPTY;
+					dev->n_erased_blocks++;
+				} else {
+					if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+					    state == YAFFS_BLOCK_STATE_ALLOCATING) {
+						if (dev->seq_number == bi->seq_number) {
+							/* this is the block being allocated from */
+
+							T(YAFFS_TRACE_SCAN,
+							  (TSTR
+							   (" Allocating from %d %d"
+							    TENDSTR), blk, c));
+
+							state = YAFFS_BLOCK_STATE_ALLOCATING;
+							dev->alloc_block = blk;
+							dev->alloc_page = c;
+							dev->alloc_block_finder = blk;
+						} else {
+							/* This is a partially written block that is not
+							 * the current allocation block.
+							 */
+
+							 T(YAFFS_TRACE_SCAN,
+							 (TSTR("Partially written block %d detected" TENDSTR),
+							 blk));
+						}
+					}
+				}
+
+				dev->n_free_chunks++;
+
+			} else if (tags.ecc_result == YAFFS_ECC_RESULT_UNFIXED) {
+				T(YAFFS_TRACE_SCAN,
+				  (TSTR(" Unfixed ECC in chunk(%d:%d), chunk ignored"TENDSTR),
+				  blk, c));
+
+				  dev->n_free_chunks++;
+
+			} else if (tags.obj_id > YAFFS_MAX_OBJECT_ID ||
+				tags.chunk_id > YAFFS_MAX_CHUNK_ID ||
+				(tags.chunk_id > 0 && tags.n_bytes > dev->data_bytes_per_chunk) ||
+				tags.seq_number != bi->seq_number ) {
+				T(YAFFS_TRACE_SCAN,
+				  (TSTR("Chunk (%d:%d) with bad tags:obj = %d, chunk_id = %d, n_bytes = %d, ignored"TENDSTR),
+				  blk, c,tags.obj_id, tags.chunk_id, tags.n_bytes));
+
+				  dev->n_free_chunks++;
+
+			} else if (tags.chunk_id > 0) {
+				/* chunk_id > 0 so it is a data chunk... */
+				unsigned int endpos;
+				__u32 chunkBase =
+				    (tags.chunk_id - 1) * dev->data_bytes_per_chunk;
+
+				foundChunksInBlock = 1;
+
+
+				yaffs_set_chunk_bit(dev, blk, c);
+				bi->pages_in_use++;
+
+				in = yaffs_find_or_create_by_number(dev,
+								      tags.
+								      obj_id,
+								      YAFFS_OBJECT_TYPE_FILE);
+				if (!in) {
+					/* Out of memory */
+					alloc_failed = 1;
+				}
+
+				if (in &&
+				    in->variant_type == YAFFS_OBJECT_TYPE_FILE
+				    && chunkBase < in->variant.file_variant.shrink_size) {
+					/* This has not been invalidated by a resize */
+					if (!yaffs_put_chunk_in_file(in, tags.chunk_id, chunk, -1)) {
+						alloc_failed = 1;
+					}
+
+					/* File size is calculated by looking at the data chunks if we have not
+					 * seen an object header yet. Stop this practice once we find an object header.
+					 */
+					endpos = chunkBase + tags.n_bytes;
+
+					if (!in->valid &&	/* have not got an object header yet */
+					    in->variant.file_variant.scanned_size < endpos) {
+						in->variant.file_variant.scanned_size = endpos;
+						in->variant.file_variant.file_size = endpos;
+					}
+
+				} else if (in) {
+					/* This chunk has been invalidated by a resize, or a past file deletion
+					 * so delete the chunk*/
+					yaffs_chunk_del(dev, chunk, 1, __LINE__);
+
+				}
+			} else {
+				/* chunk_id == 0, so it is an ObjectHeader.
+				 * Thus, we read in the object header and make the object
+				 */
+				foundChunksInBlock = 1;
+
+				yaffs_set_chunk_bit(dev, blk, c);
+				bi->pages_in_use++;
+
+				oh = NULL;
+				in = NULL;
+
+				if (tags.extra_available) {
+					in = yaffs_find_or_create_by_number(dev,
+						tags.obj_id,
+						tags.extra_obj_type);
+					if (!in)
+						alloc_failed = 1;
+				}
+
+				if (!in ||
+				    (!in->valid && dev->param.disable_lazy_load) ||
+				    tags.extra_shadows ||
+				    (!in->valid &&
+				    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+				     tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND))) {
+
+					/* If we don't have  valid info then we need to read the chunk
+					 * TODO In future we can probably defer reading the chunk and
+					 * living with invalid data until needed.
+					 */
+
+					result = yaffs_rd_chunk_tags_nand(dev,
+									chunk,
+									chunkData,
+									NULL);
+
+					oh = (yaffs_obj_header *) chunkData;
+
+					if (dev->param.inband_tags) {
+						/* Fix up the header if they got corrupted by inband tags */
+						oh->shadows_obj = oh->inband_shadowed_obj_id;
+						oh->is_shrink = oh->inband_is_shrink;
+					}
+
+					if (!in) {
+						in = yaffs_find_or_create_by_number(dev, tags.obj_id, oh->type);
+						if (!in)
+							alloc_failed = 1;
+					}
+
+				}
+
+				if (!in) {
+					/* TODO Hoosterman we have a problem! */
+					T(YAFFS_TRACE_ERROR,
+					  (TSTR
+					   ("yaffs tragedy: Could not make object for object  %d at chunk %d during scan"
+					    TENDSTR), tags.obj_id, chunk));
+					continue;
+				}
+
+				if (in->valid) {
+					/* We have already filled this one.
+					 * We have a duplicate that will be discarded, but
+					 * we first have to suck out resize info if it is a file.
+					 */
+
+					if ((in->variant_type == YAFFS_OBJECT_TYPE_FILE) &&
+					     ((oh &&
+					       oh->type == YAFFS_OBJECT_TYPE_FILE) ||
+					      (tags.extra_available  &&
+					       tags.extra_obj_type == YAFFS_OBJECT_TYPE_FILE))) {
+						__u32 thisSize =
+						    (oh) ? oh->file_size : tags.
+						    extra_length;
+						__u32 parent_obj_id =
+						    (oh) ? oh->
+						    parent_obj_id : tags.
+						    extra_parent_id;
+
+
+						is_shrink =
+						    (oh) ? oh->is_shrink : tags.
+						    extra_is_shrink;
+
+						/* If it is deleted (unlinked at start also means deleted)
+						 * we treat the file size as being zeroed at this point.
+						 */
+						if (parent_obj_id ==
+						    YAFFS_OBJECTID_DELETED
+						    || parent_obj_id ==
+						    YAFFS_OBJECTID_UNLINKED) {
+							thisSize = 0;
+							is_shrink = 1;
+						}
+
+						if (is_shrink && in->variant.file_variant.shrink_size > thisSize)
+							in->variant.file_variant.shrink_size = thisSize;
+
+						if (is_shrink)
+							bi->has_shrink_hdr = 1;
+
+					}
+					/* Use existing - destroy this one. */
+					yaffs_chunk_del(dev, chunk, 1, __LINE__);
+
+				}
+
+				if (!in->valid && in->variant_type !=
+				    (oh ? oh->type : tags.extra_obj_type))
+					T(YAFFS_TRACE_ERROR, (
+						TSTR("yaffs tragedy: Bad object type, "
+					    TCONT("%d != %d, for object %d at chunk ")
+					    TCONT("%d during scan")
+						TENDSTR), oh ?
+					    oh->type : tags.extra_obj_type,
+					    in->variant_type, tags.obj_id,
+					    chunk));
+
+				if (!in->valid &&
+				    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+				     tags.obj_id ==
+				     YAFFS_OBJECTID_LOSTNFOUND)) {
+					/* We only load some info, don't fiddle with directory structure */
+					in->valid = 1;
+
+					if (oh) {
+
+						in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+						in->win_atime[0] = oh->win_atime[0];
+						in->win_ctime[0] = oh->win_ctime[0];
+						in->win_mtime[0] = oh->win_mtime[0];
+						in->win_atime[1] = oh->win_atime[1];
+						in->win_ctime[1] = oh->win_ctime[1];
+						in->win_mtime[1] = oh->win_mtime[1];
+#else
+						in->yst_uid = oh->yst_uid;
+						in->yst_gid = oh->yst_gid;
+						in->yst_atime = oh->yst_atime;
+						in->yst_mtime = oh->yst_mtime;
+						in->yst_ctime = oh->yst_ctime;
+						in->yst_rdev = oh->yst_rdev;
+
+						in->lazy_loaded = 0;
+
+#endif
+					} else
+						in->lazy_loaded = 1;
+
+					in->hdr_chunk = chunk;
+
+				} else if (!in->valid) {
+					/* we need to load this info */
+
+					in->valid = 1;
+					in->hdr_chunk = chunk;
+
+					if (oh) {
+						in->variant_type = oh->type;
+
+						in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+						in->win_atime[0] = oh->win_atime[0];
+						in->win_ctime[0] = oh->win_ctime[0];
+						in->win_mtime[0] = oh->win_mtime[0];
+						in->win_atime[1] = oh->win_atime[1];
+						in->win_ctime[1] = oh->win_ctime[1];
+						in->win_mtime[1] = oh->win_mtime[1];
+#else
+						in->yst_uid = oh->yst_uid;
+						in->yst_gid = oh->yst_gid;
+						in->yst_atime = oh->yst_atime;
+						in->yst_mtime = oh->yst_mtime;
+						in->yst_ctime = oh->yst_ctime;
+						in->yst_rdev = oh->yst_rdev;
+#endif
+
+						if (oh->shadows_obj > 0)
+							yaffs_handle_shadowed_obj(dev,
+									   oh->
+									   shadows_obj,
+									   1);
+							
+
+
+						yaffs_set_obj_name_from_oh(in, oh);
+						parent =
+						    yaffs_find_or_create_by_number
+							(dev, oh->parent_obj_id,
+							 YAFFS_OBJECT_TYPE_DIRECTORY);
+
+						 file_size = oh->file_size;
+						 is_shrink = oh->is_shrink;
+						 equiv_id = oh->equiv_id;
+
+					} else {
+						in->variant_type = tags.extra_obj_type;
+						parent =
+						    yaffs_find_or_create_by_number
+							(dev, tags.extra_parent_id,
+							 YAFFS_OBJECT_TYPE_DIRECTORY);
+						 file_size = tags.extra_length;
+						 is_shrink = tags.extra_is_shrink;
+						 equiv_id = tags.extra_equiv_id;
+						in->lazy_loaded = 1;
+
+					}
+					in->dirty = 0;
+
+					if (!parent)
+						alloc_failed = 1;
+
+					/* directory stuff...
+					 * hook up to parent
+					 */
+
+					if (parent && parent->variant_type ==
+					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+						/* Set up as a directory */
+						parent->variant_type =
+							YAFFS_OBJECT_TYPE_DIRECTORY;
+						YINIT_LIST_HEAD(&parent->variant.
+							dir_variant.
+							children);
+					} else if (!parent || parent->variant_type !=
+						   YAFFS_OBJECT_TYPE_DIRECTORY) {
+						/* Hoosterman, another problem....
+						 * We're trying to use a non-directory as a directory
+						 */
+
+						T(YAFFS_TRACE_ERROR,
+						  (TSTR
+						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+						    TENDSTR)));
+						parent = dev->lost_n_found;
+					}
+
+					yaffs_add_obj_to_dir(parent, in);
+
+					itsUnlinked = (parent == dev->del_dir) ||
+						      (parent == dev->unlinked_dir);
+
+					if (is_shrink) {
+						/* Mark the block as having a shrinkHeader */
+						bi->has_shrink_hdr = 1;
+					}
+
+					/* Note re hardlinks.
+					 * Since we might scan a hardlink before its equivalent object is scanned
+					 * we put them all in a list.
+					 * After scanning is complete, we should have all the objects, so we run
+					 * through this list and fix up all the chains.
+					 */
+
+					switch (in->variant_type) {
+					case YAFFS_OBJECT_TYPE_UNKNOWN:
+						/* Todo got a problem */
+						break;
+					case YAFFS_OBJECT_TYPE_FILE:
+
+						if (in->variant.file_variant.
+						    scanned_size < file_size) {
+							/* This covers the case where the file size is greater
+							 * than where the data is
+							 * This will happen if the file is resized to be larger
+							 * than its current data extents.
+							 */
+							in->variant.file_variant.file_size = file_size;
+							in->variant.file_variant.scanned_size = file_size;
+						}
+
+						if (in->variant.file_variant.shrink_size > file_size)
+							in->variant.file_variant.shrink_size = file_size;
+				
+
+						break;
+					case YAFFS_OBJECT_TYPE_HARDLINK:
+						if (!itsUnlinked) {
+							in->variant.hardlink_variant.equiv_id =
+								equiv_id;
+							in->hard_links.next =
+								(struct ylist_head *) hard_list;
+							hard_list = in;
+						}
+						break;
+					case YAFFS_OBJECT_TYPE_DIRECTORY:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SPECIAL:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SYMLINK:
+						if (oh) {
+							in->variant.symlink_variant.alias =
+								yaffs_clone_str(oh->alias);
+							if (!in->variant.symlink_variant.alias)
+								alloc_failed = 1;
+						}
+						break;
+					}
+
+				}
+
+			}
+
+		} /* End of scanning for each chunk */
+
+		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+			/* If we got this far while scanning, then the block is fully allocated. */
+			state = YAFFS_BLOCK_STATE_FULL;
 		}
 
-		if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
-			/* If we got this far while scanning, then the block
-			 * is fully allocated. */
-			bi->block_state = YAFFS_BLOCK_STATE_FULL;
-		}
+
+		bi->block_state = state;
 
 		/* Now let's see if it was dirty */
 		if (bi->pages_in_use == 0 &&
@@ -1507,28 +1511,30 @@ int yaffs2_scan_backwards(struct yaffs_d
 		    bi->block_state == YAFFS_BLOCK_STATE_FULL) {
 			yaffs_block_became_dirty(dev, blk);
 		}
+
 	}
-
+	
 	yaffs_skip_rest_of_block(dev);
 
-	if (alt_block_index)
-		vfree(block_index);
+	if (altBlockIndex)
+		YFREE_ALT(blockIndex);
 	else
-		kfree(block_index);
+		YFREE(blockIndex);
 
 	/* Ok, we've done all the scanning.
 	 * Fix up the hard link chains.
-	 * We have scanned all the objects, now it's time to add these
+	 * We should now have scanned all the objects, now it's time to add these
 	 * hardlinks.
 	 */
-	yaffs_link_fixup(dev, &hard_list);
+	yaffs_link_fixup(dev, hard_list);
 
-	yaffs_release_temp_buffer(dev, chunk_data);
+
+	yaffs_release_temp_buffer(dev, chunkData, __LINE__);
 
 	if (alloc_failed)
 		return YAFFS_FAIL;
 
-	yaffs_trace(YAFFS_TRACE_SCAN, "yaffs2_scan_backwards ends");
+	T(YAFFS_TRACE_SCAN, (TSTR("yaffs2_scan_backwards ends" TENDSTR)));
 
 	return YAFFS_OK;
 }
diff --git a/target/linux/generic/files/fs/yaffs2/yaffs_yaffs2.h b/target/linux/generic/files/fs/yaffs2/yaffs_yaffs2.h
--- a/target/linux/generic/files/fs/yaffs2/yaffs_yaffs2.h
+++ b/target/linux/generic/files/fs/yaffs2/yaffs_yaffs2.h
@@ -1,16 +1,14 @@
 /*
- * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
  *
  * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
- *
- * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
  */
 
 #ifndef __YAFFS_YAFFS2_H__
@@ -18,22 +16,21 @@
 
 #include "yaffs_guts.h"
 
-void yaffs_calc_oldest_dirty_seq(struct yaffs_dev *dev);
-void yaffs2_find_oldest_dirty_seq(struct yaffs_dev *dev);
-void yaffs2_clear_oldest_dirty_seq(struct yaffs_dev *dev,
-				   struct yaffs_block_info *bi);
-void yaffs2_update_oldest_dirty_seq(struct yaffs_dev *dev, unsigned block_no,
-				    struct yaffs_block_info *bi);
-int yaffs_block_ok_for_gc(struct yaffs_dev *dev, struct yaffs_block_info *bi);
-u32 yaffs2_find_refresh_block(struct yaffs_dev *dev);
-int yaffs2_checkpt_required(struct yaffs_dev *dev);
-int yaffs_calc_checkpt_blocks_required(struct yaffs_dev *dev);
+void yaffs_calc_oldest_dirty_seq(yaffs_dev_t *dev);
+void yaffs2_find_oldest_dirty_seq(yaffs_dev_t *dev);
+void yaffs2_clear_oldest_dirty_seq(yaffs_dev_t *dev, yaffs_block_info_t *bi);
+void yaffs2_update_oldest_dirty_seq(yaffs_dev_t *dev, unsigned block_no, yaffs_block_info_t *bi);
+int yaffs_block_ok_for_gc(yaffs_dev_t *dev, yaffs_block_info_t *bi);
+__u32 yaffs2_find_refresh_block(yaffs_dev_t *dev);
+int yaffs2_checkpt_required(yaffs_dev_t *dev);
+int yaffs_calc_checkpt_blocks_required(yaffs_dev_t *dev);
 
-void yaffs2_checkpt_invalidate(struct yaffs_dev *dev);
-int yaffs2_checkpt_save(struct yaffs_dev *dev);
-int yaffs2_checkpt_restore(struct yaffs_dev *dev);
 
-int yaffs2_handle_hole(struct yaffs_obj *obj, loff_t new_size);
-int yaffs2_scan_backwards(struct yaffs_dev *dev);
+void yaffs2_checkpt_invalidate(yaffs_dev_t *dev);
+int yaffs2_checkpt_save(yaffs_dev_t *dev);
+int yaffs2_checkpt_restore(yaffs_dev_t *dev);
+
+int yaffs2_handle_hole(yaffs_obj_t *obj, loff_t new_size);
+int yaffs2_scan_backwards(yaffs_dev_t *dev);
 
 #endif
diff --git a/target/linux/generic/files/fs/yaffs2/yaffsinterface.h b/target/linux/generic/files/fs/yaffs2/yaffsinterface.h
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/files/fs/yaffs2/yaffsinterface.h
@@ -0,0 +1,21 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2010 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFSINTERFACE_H__
+#define __YAFFSINTERFACE_H__
+
+int yaffs_initialise(unsigned nBlocks);
+
+#endif
diff --git a/target/linux/generic/files/fs/yaffs2/yportenv.h b/target/linux/generic/files/fs/yaffs2/yportenv.h
--- a/target/linux/generic/files/fs/yaffs2/yportenv.h
+++ b/target/linux/generic/files/fs/yaffs2/yportenv.h
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2011 Aleph One Ltd.
+ * Copyright (C) 2002-2010 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -13,6 +13,7 @@
  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
  */
 
+
 #ifndef __YPORTENV_H__
 #define __YPORTENV_H__
 
@@ -24,9 +25,15 @@
 
 #define MTD_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
 
-#ifdef YAFFS_OUT_OF_TREE
+#if defined CONFIG_YAFFS_WINCE
+
+#include "ywinceenv.h"
+
+#elif defined __KERNEL__
+
 #include "moduleconfig.h"
-#endif
+
+/* Linux kernel */
 
 #include <linux/version.h>
 #define MTD_VERSION_CODE LINUX_VERSION_CODE
@@ -34,7 +41,7 @@
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
 #include <linux/config.h>
 #endif
-#include <linux/version.h>
+
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/sched.h>
@@ -42,21 +49,32 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/xattr.h>
-#include <linux/list.h>
-#include <linux/types.h>
-#include <linux/fs.h>
-#include <linux/stat.h>
-#include <linux/sort.h>
-#include <linux/bitops.h>
 
-/*  These type wrappings are used to support Unicode names in WinCE. */
 #define YCHAR char
 #define YUCHAR unsigned char
 #define _Y(x)     x
+#define yaffs_strcat(a, b)     strcat(a, b)
+#define yaffs_strcpy(a, b)     strcpy(a, b)
+#define yaffs_strncpy(a, b, c) strncpy(a, b, c)
+#define yaffs_strncmp(a, b, c) strncmp(a, b, c)
+#define yaffs_strnlen(s,m)	strnlen(s,m)
+#define yaffs_sprintf	       sprintf
+#define yaffs_toupper(a)       toupper(a)
+
+#define Y_INLINE __inline__
 
 #define YAFFS_LOSTNFOUND_NAME		"lost+found"
 #define YAFFS_LOSTNFOUND_PREFIX		"obj"
 
+/* #define YPRINTF(x) printk x */
+#define YMALLOC(x) kmalloc(x, GFP_NOFS)
+#define YFREE(x)   kfree(x)
+#define YMALLOC_ALT(x) vmalloc(x)
+#define YFREE_ALT(x)   vfree(x)
+#define YMALLOC_DMA(x) YMALLOC(x)
+
+#define YYIELD() schedule()
+#define Y_DUMP_STACK() dump_stack()
 
 #define YAFFS_ROOT_MODE			0755
 #define YAFFS_LOSTNFOUND_MODE		0700
@@ -69,17 +87,247 @@
 #define Y_TIME_CONVERT(x) (x)
 #endif
 
+#define yaffs_sum_cmp(x, y) ((x) == (y))
+#define yaffs_strcmp(a, b) strcmp(a, b)
+
+#define TENDSTR "\n"
+#define TSTR(x) KERN_DEBUG x
+#define TCONT(x) x
+#define TOUT(p) printk p
+
 #define compile_time_assertion(assertion) \
 	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
 
+#elif defined CONFIG_YAFFS_DIRECT
 
-#define yaffs_printf(msk, fmt, ...) \
-	printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__)
+#define MTD_VERSION_CODE MTD_VERSION(2, 6, 22)
 
-#define yaffs_trace(msk, fmt, ...) do { \
-	if (yaffs_trace_mask & (msk)) \
-		printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__); \
-} while (0)
+/* Direct interface */
+#include "ydirectenv.h"
 
+#elif defined CONFIG_YAFFS_UTIL
+
+/* Stuff for YAFFS utilities */
+
+#include "stdlib.h"
+#include "stdio.h"
+#include "string.h"
+
+
+#define YMALLOC(x) malloc(x)
+#define YFREE(x)   free(x)
+#define YMALLOC_ALT(x) malloc(x)
+#define YFREE_ALT(x) free(x)
+
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+#define yaffs_strcat(a, b)     strcat(a, b)
+#define yaffs_strcpy(a, b)     strcpy(a, b)
+#define yaffs_strncpy(a, b, c) strncpy(a, b, c)
+#define yaffs_strnlen(s,m)	       strnlen(s,m)
+#define yaffs_sprintf	       sprintf
+#define yaffs_toupper(a)       toupper(a)
+
+#define Y_INLINE inline
+
+/* #define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s)) */
+/* #define YALERT(s) YINFO(s) */
+
+#define TENDSTR "\n"
+#define TSTR(x) x
+#define TOUT(p) printf p
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+/* #define YPRINTF(x) printf x */
+
+#define YAFFS_ROOT_MODE			0755
+#define YAFFS_LOSTNFOUND_MODE		0700
+
+#define yaffs_sum_cmp(x, y) ((x) == (y))
+#define yaffs_strcmp(a, b) strcmp(a, b)
+
+#else
+/* Should have specified a configuration type */
+#error Unknown configuration
 
 #endif
+
+#if defined(CONFIG_YAFFS_DIRECT) || defined(CONFIG_YAFFS_WINCE)
+
+#ifdef CONFIG_YAFFSFS_PROVIDE_VALUES
+
+#ifndef O_RDONLY
+#define O_RDONLY        00
+#endif
+
+#ifndef O_WRONLY
+#define O_WRONLY	01
+#endif
+
+#ifndef O_RDWR
+#define O_RDWR		02
+#endif
+
+#ifndef O_CREAT		
+#define O_CREAT 	0100
+#endif
+
+#ifndef O_EXCL
+#define O_EXCL		0200
+#endif
+
+#ifndef O_TRUNC
+#define O_TRUNC		01000
+#endif
+
+#ifndef O_APPEND
+#define O_APPEND	02000
+#endif
+
+#ifndef SEEK_SET
+#define SEEK_SET	0
+#endif
+
+#ifndef SEEK_CUR
+#define SEEK_CUR	1
+#endif
+
+#ifndef SEEK_END
+#define SEEK_END	2
+#endif
+
+#ifndef EBUSY
+#define EBUSY	16
+#endif
+
+#ifndef ENODEV
+#define ENODEV	19
+#endif
+
+#ifndef EINVAL
+#define EINVAL	22
+#endif
+
+#ifndef EBADF
+#define EBADF	9
+#endif
+
+#ifndef EACCES
+#define EACCES	13
+#endif
+
+#ifndef EXDEV	
+#define EXDEV	18
+#endif
+
+#ifndef ENOENT
+#define ENOENT	2
+#endif
+
+#ifndef ENOSPC
+#define ENOSPC	28
+#endif
+
+#ifndef ERANGE
+#define ERANGE 34
+#endif
+
+#ifndef ENODATA
+#define ENODATA 61
+#endif
+
+#ifndef ENOTEMPTY
+#define ENOTEMPTY 39
+#endif
+
+#ifndef ENAMETOOLONG
+#define ENAMETOOLONG 36
+#endif
+
+#ifndef ENOMEM
+#define ENOMEM 12
+#endif
+
+#ifndef EEXIST
+#define EEXIST 17
+#endif
+
+#ifndef ENOTDIR
+#define ENOTDIR 20
+#endif
+
+#ifndef EISDIR
+#define EISDIR 21
+#endif
+
+
+// Mode flags
+
+#ifndef S_IFMT
+#define S_IFMT		0170000
+#endif
+
+#ifndef S_IFLNK
+#define S_IFLNK		0120000
+#endif
+
+#ifndef S_IFDIR
+#define S_IFDIR		0040000
+#endif
+
+#ifndef S_IFREG
+#define S_IFREG		0100000
+#endif
+
+#ifndef S_IREAD 
+#define S_IREAD		0000400
+#endif
+
+#ifndef S_IWRITE
+#define	S_IWRITE	0000200
+#endif
+
+#ifndef S_IEXEC
+#define	S_IEXEC	0000100
+#endif
+
+#ifndef XATTR_CREATE
+#define XATTR_CREATE 1
+#endif
+
+#ifndef XATTR_REPLACE
+#define XATTR_REPLACE 2
+#endif
+
+#ifndef R_OK
+#define R_OK	4
+#define W_OK	2
+#define X_OK	1
+#define F_OK	0
+#endif
+
+#else
+#include <errno.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#endif
+
+#endif
+
+#ifndef Y_DUMP_STACK
+#define Y_DUMP_STACK() do { } while (0)
+#endif
+
+#ifndef YBUG
+#define YBUG() do {\
+	T(YAFFS_TRACE_BUG,\
+		(TSTR("==>> yaffs bug: " __FILE__ " %d" TENDSTR),\
+		__LINE__));\
+	Y_DUMP_STACK();\
+} while (0)
+#endif
+
+
+#endif
diff --git a/target/linux/generic/files/include/linux/ar8216_platform.h b/target/linux/generic/files/include/linux/ar8216_platform.h
--- a/target/linux/generic/files/include/linux/ar8216_platform.h
+++ b/target/linux/generic/files/include/linux/ar8216_platform.h
@@ -47,7 +47,6 @@ struct ar8327_pad_cfg {
 	bool sgmii_delay_en;
 	enum ar8327_clk_delay_sel txclk_delay_sel;
 	enum ar8327_clk_delay_sel rxclk_delay_sel;
-	bool mac06_exchange_en;
 };
 
 enum ar8327_port_speed {
@@ -77,43 +76,6 @@ struct ar8327_led_cfg {
 	bool open_drain;
 };
 
-enum ar8327_led_num {
-	AR8327_LED_PHY0_0 = 0,
-	AR8327_LED_PHY0_1,
-	AR8327_LED_PHY0_2,
-	AR8327_LED_PHY1_0,
-	AR8327_LED_PHY1_1,
-	AR8327_LED_PHY1_2,
-	AR8327_LED_PHY2_0,
-	AR8327_LED_PHY2_1,
-	AR8327_LED_PHY2_2,
-	AR8327_LED_PHY3_0,
-	AR8327_LED_PHY3_1,
-	AR8327_LED_PHY3_2,
-	AR8327_LED_PHY4_0,
-	AR8327_LED_PHY4_1,
-	AR8327_LED_PHY4_2,
-};
-
-enum ar8327_led_mode {
-	AR8327_LED_MODE_HW = 0,
-	AR8327_LED_MODE_SW,
-};
-
-struct ar8327_led_info {
-	const char *name;
-	const char *default_trigger;
-	bool active_low;
-	enum ar8327_led_num led_num;
-	enum ar8327_led_mode mode;
-};
-
-#define AR8327_LED_INFO(_led, _mode, _name) {	\
-	.name = (_name), 	   		\
-	.led_num = AR8327_LED_ ## _led,		\
-	.mode = AR8327_LED_MODE_ ## _mode 	\
-}
-
 struct ar8327_platform_data {
 	struct ar8327_pad_cfg *pad0_cfg;
 	struct ar8327_pad_cfg *pad5_cfg;
@@ -124,10 +86,6 @@ struct ar8327_platform_data {
 	struct ar8327_led_cfg *led_cfg;
 
 	int (*get_port_link)(unsigned port);
-
-	unsigned num_leds;
-	const struct ar8327_led_info *leds;
 };
 
-#endif /* AR8216_PLATFORM_H */
-
+#endif /* AR8216_PLATFORM_H */
\ No newline at end of file
diff --git a/target/linux/generic/files/include/linux/ath9k_platform.h b/target/linux/generic/files/include/linux/ath9k_platform.h
--- a/target/linux/generic/files/include/linux/ath9k_platform.h
+++ b/target/linux/generic/files/include/linux/ath9k_platform.h
@@ -33,15 +33,12 @@ struct ath9k_platform_data {
 
 	bool endian_check;
 	bool is_clk_25mhz;
-	bool tx_gain_buffalo;
 	bool disable_2ghz;
 	bool disable_5ghz;
 
 	int (*get_mac_revision)(void);
 	int (*external_reset)(void);
 
-	bool use_eeprom;
-
 	int num_leds;
 	const struct gpio_led *leds;
 };
diff --git a/target/linux/generic/files/include/linux/routerboot.h b/target/linux/generic/files/include/linux/routerboot.h
--- a/target/linux/generic/files/include/linux/routerboot.h
+++ b/target/linux/generic/files/include/linux/routerboot.h
@@ -40,7 +40,6 @@
 #define RB_ID_HARD_12		12
 #define RB_ID_MEMORY_SIZE	13
 #define RB_ID_MAC_ADDRESS_COUNT	14
-#define RB_ID_HW_OPTIONS	21
 #define RB_ID_WLAN_DATA		22
 
 /*
diff --git a/target/linux/generic/files/include/linux/switch.h b/target/linux/generic/files/include/linux/switch.h
--- a/target/linux/generic/files/include/linux/switch.h
+++ b/target/linux/generic/files/include/linux/switch.h
@@ -54,8 +54,6 @@ struct switch_port_link {
 	bool tx_flow;
 	bool rx_flow;
 	enum switch_port_speed speed;
-	/* in ethtool adv_t format */
-	u32 eee;
 };
 
 struct switch_port_stats {
diff --git a/target/linux/generic/patches-3.10/001-MIPS-Declare-emulate_load_store_microMIPS-as-a-stati.patch b/target/linux/generic/patches-3.10/001-MIPS-Declare-emulate_load_store_microMIPS-as-a-stati.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/001-MIPS-Declare-emulate_load_store_microMIPS-as-a-stati.patch
@@ -0,0 +1,34 @@
+From 2b76d9221a02fa69bbb8c1045616afb923fc6bad Mon Sep 17 00:00:00 2001
+From: David Daney <david.daney@cavium.com>
+Date: Fri, 24 May 2013 20:54:08 +0000
+Subject: [PATCH] MIPS: Declare emulate_load_store_microMIPS as a static
+ function.
+
+commit 74338805ec6869594d583535f941cb478c94dd73 upstream.
+
+It is only used from within a single file, it should not be globally
+visible.
+
+Signed-off-by: David Daney <david.daney@cavium.com>
+Acked-by: Steven J. Hill <Steven.Hill@imgtec.com>
+Cc: linux-mips@linux-mips.org
+Patchwork: https://patchwork.linux-mips.org/patch/5325/
+Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
+---
+ arch/mips/kernel/unaligned.c |    3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+Index: kernel_tree/arch/mips/kernel/unaligned.c
+===================================================================
+--- kernel_tree.orig/arch/mips/kernel/unaligned.c
++++ kernel_tree/arch/mips/kernel/unaligned.c
+@@ -683,7 +683,8 @@ const int reg16to32[] = { 16, 17, 2, 3,
+ /* Recode table from 16-bit STORE register notation to 32-bit GPR. */
+ const int reg16to32st[] = { 0, 17, 2, 3, 4, 5, 6, 7 };
+ 
+-void emulate_load_store_microMIPS(struct pt_regs *regs, void __user * addr)
++static void emulate_load_store_microMIPS(struct pt_regs *regs,
++					 void __user *addr)
+ {
+ 	unsigned long value;
+ 	unsigned int res;
diff --git a/target/linux/generic/patches-3.10/002-MIPS-Only-set-cpu_has_mmips-if-SYS_SUPPORTS_MICROMIP.patch b/target/linux/generic/patches-3.10/002-MIPS-Only-set-cpu_has_mmips-if-SYS_SUPPORTS_MICROMIP.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/002-MIPS-Only-set-cpu_has_mmips-if-SYS_SUPPORTS_MICROMIP.patch
@@ -0,0 +1,45 @@
+From 15a051ad98309f71989f9bda4b020fff160f4022 Mon Sep 17 00:00:00 2001
+From: David Daney <david.daney@cavium.com>
+Date: Fri, 24 May 2013 20:54:10 +0000
+Subject: [PATCH 2/2] MIPS: Only set cpu_has_mmips if SYS_SUPPORTS_MICROMIPS
+
+commit 3ddc14add5e6341cf8ef4058c34c67ba7fd15317 upstream.
+
+As Jonas Gorske said in his patch:
+
+   Disable cpu_has_mmips for everything but SEAD3 and MALTA. Most of
+   these platforms are from before the micromips introduction, so they
+   are very unlikely to implement it.
+
+   Reduces an -Os compiled, uncompressed kernel image by 8KiB for
+   BCM63XX.
+
+This patch taks a different approach than his, we gate the runtime
+test for microMIPS by the config symbol SYS_SUPPORTS_MICROMIPS.
+
+Signed-off-by: David Daney <david.daney@cavium.com>
+Cc: Jonas Gorski <jogo@openwrt.org>
+Cc: Steven J. Hill <Steven.Hill@imgtec.com>
+Acked-by: Steven J. Hill <Steven.Hill@imgtec.com>
+Cc: linux-mips@linux-mips.org
+Patchwork: https://patchwork.linux-mips.org/patch/5327/
+Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
+---
+ arch/mips/include/asm/cpu-features.h |    6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+--- a/arch/mips/include/asm/cpu-features.h
++++ b/arch/mips/include/asm/cpu-features.h
+@@ -99,7 +99,11 @@
+ #define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
+ #endif
+ #ifndef cpu_has_mmips
+-#define cpu_has_mmips		(cpu_data[0].options & MIPS_CPU_MICROMIPS)
++# ifdef CONFIG_SYS_SUPPORTS_MICROMIPS
++#  define cpu_has_mmips		(cpu_data[0].options & MIPS_CPU_MICROMIPS)
++# else
++#  define cpu_has_mmips		0
++# endif
+ #endif
+ #ifndef cpu_has_vtag_icache
+ #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
diff --git a/target/linux/generic/patches-3.10/003-of-pci-Add-of_pci_get_devfn-function.patch b/target/linux/generic/patches-3.10/003-of-pci-Add-of_pci_get_devfn-function.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/003-of-pci-Add-of_pci_get_devfn-function.patch
@@ -0,0 +1,78 @@
+From 45ab9702fb47d18dca116b3a0509efa19fbcb27a Mon Sep 17 00:00:00 2001
+From: Thierry Reding <thierry.reding@avionic-design.de>
+Date: Thu, 16 May 2013 17:55:18 +0200
+Subject: [PATCH] of/pci: Add of_pci_get_devfn() function
+
+commit 45ab9702fb47d18dca116b3a0509efa19fbcb27a upstream.
+
+This function can be used to parse the device and function number from a
+standard 5-cell PCI resource. PCI_SLOT() and PCI_FUNC() can be used on
+the returned value obtain the device and function numbers respectively.
+
+Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
+Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
+Signed-off-by: Jason Cooper <jason@lakedaemon.net>
+---
+ drivers/of/of_pci.c    |   34 +++++++++++++++++++++++++++++-----
+ include/linux/of_pci.h |    1 +
+ 2 files changed, 30 insertions(+), 5 deletions(-)
+
+--- a/drivers/of/of_pci.c
++++ b/drivers/of/of_pci.c
+@@ -5,14 +5,15 @@
+ #include <asm/prom.h>
+ 
+ static inline int __of_pci_pci_compare(struct device_node *node,
+-				       unsigned int devfn)
++				       unsigned int data)
+ {
+-	unsigned int size;
+-	const __be32 *reg = of_get_property(node, "reg", &size);
++	int devfn;
+ 
+-	if (!reg || size < 5 * sizeof(__be32))
++	devfn = of_pci_get_devfn(node);
++	if (devfn < 0)
+ 		return 0;
+-	return ((be32_to_cpup(&reg[0]) >> 8) & 0xff) == devfn;
++
++	return devfn == data;
+ }
+ 
+ struct device_node *of_pci_find_child_device(struct device_node *parent,
+@@ -40,3 +41,26 @@ struct device_node *of_pci_find_child_de
+ 	return NULL;
+ }
+ EXPORT_SYMBOL_GPL(of_pci_find_child_device);
++
++/**
++ * of_pci_get_devfn() - Get device and function numbers for a device node
++ * @np: device node
++ *
++ * Parses a standard 5-cell PCI resource and returns an 8-bit value that can
++ * be passed to the PCI_SLOT() and PCI_FUNC() macros to extract the device
++ * and function numbers respectively. On error a negative error code is
++ * returned.
++ */
++int of_pci_get_devfn(struct device_node *np)
++{
++	unsigned int size;
++	const __be32 *reg;
++
++	reg = of_get_property(np, "reg", &size);
++
++	if (!reg || size < 5 * sizeof(__be32))
++		return -EINVAL;
++
++	return (be32_to_cpup(reg) >> 8) & 0xff;
++}
++EXPORT_SYMBOL_GPL(of_pci_get_devfn);
+--- a/include/linux/of_pci.h
++++ b/include/linux/of_pci.h
+@@ -10,5 +10,6 @@ int of_irq_map_pci(const struct pci_dev
+ struct device_node;
+ struct device_node *of_pci_find_child_device(struct device_node *parent,
+ 					     unsigned int devfn);
++int of_pci_get_devfn(struct device_node *np);
+ 
+ #endif
diff --git a/target/linux/generic/patches-3.10/007-hso-Earlier-catch-of-error-condition.patch b/target/linux/generic/patches-3.10/007-hso-Earlier-catch-of-error-condition.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/007-hso-Earlier-catch-of-error-condition.patch
@@ -0,0 +1,40 @@
+From 35e57e1b49a351aa804dab6010cd46ae6112a541 Mon Sep 17 00:00:00 2001
+From: Daniel Gimpelevich <daniel@gimpelevich.san-francisco.ca.us>
+Date: Wed, 21 Aug 2013 01:43:07 -0700
+Subject: [PATCH 1/2] hso: Earlier catch of error condition
+
+There is no need to get an interface specification if we know it's the
+wrong one.
+
+Signed-off-by: Daniel Gimpelevich <daniel@gimpelevich.san-francisco.ca.us>
+Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/usb/hso.c |    9 +++++----
+ 1 file changed, 5 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/usb/hso.c
++++ b/drivers/net/usb/hso.c
+@@ -2886,6 +2886,11 @@ static int hso_probe(struct usb_interfac
+ 	struct hso_shared_int *shared_int;
+ 	struct hso_device *tmp_dev = NULL;
+ 
++	if (interface->cur_altsetting->desc.bInterfaceClass != 0xFF) {
++		dev_err(&interface->dev, "Not our interface\n");
++		return -ENODEV;
++	}
++
+ 	if_num = interface->altsetting->desc.bInterfaceNumber;
+ 
+ 	/* Get the interface/port specification from either driver_info or from
+@@ -2895,10 +2900,6 @@ static int hso_probe(struct usb_interfac
+ 	else
+ 		port_spec = hso_get_config_data(interface);
+ 
+-	if (interface->cur_altsetting->desc.bInterfaceClass != 0xFF) {
+-		dev_err(&interface->dev, "Not our interface\n");
+-		return -ENODEV;
+-	}
+ 	/* Check if we need to switch to alt interfaces prior to port
+ 	 * configuration */
+ 	if (interface->num_altsetting > 1)
diff --git a/target/linux/generic/patches-3.10/008-hso-Fix-stack-corruption-on-some-architectures.patch b/target/linux/generic/patches-3.10/008-hso-Fix-stack-corruption-on-some-architectures.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/008-hso-Fix-stack-corruption-on-some-architectures.patch
@@ -0,0 +1,48 @@
+From e75dc677ff8d06ffa61bef6fee436227ae5440c6 Mon Sep 17 00:00:00 2001
+From: Daniel Gimpelevich <daniel@gimpelevich.san-francisco.ca.us>
+Date: Wed, 21 Aug 2013 01:43:19 -0700
+Subject: [PATCH 2/2] hso: Fix stack corruption on some architectures
+
+As Sergei Shtylyov explained in the #mipslinux IRC channel:
+[Mon 2013-08-19 12:28:21 PM PDT] <headless> guys, are you sure it's not "DMA off stack" case?
+[Mon 2013-08-19 12:28:35 PM PDT] <headless> it's a known stack corruptor on non-coherent arches
+[Mon 2013-08-19 12:31:48 PM PDT] <DonkeyHotei> headless: for usb/ehci?
+[Mon 2013-08-19 12:34:11 PM PDT] <DonkeyHotei> headless: explain
+[Mon 2013-08-19 12:35:38 PM PDT] <headless> usb_control_msg() (or other such func) should not use buffer on stack. DMA from/to stack is prohibited
+[Mon 2013-08-19 12:35:58 PM PDT] <headless> and EHCI uses DMA on control xfers (as well as all the others)
+
+Signed-off-by: Daniel Gimpelevich <daniel@gimpelevich.san-francisco.ca.us>
+Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/usb/hso.c |    6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/usb/hso.c
++++ b/drivers/net/usb/hso.c
+@@ -2816,13 +2816,16 @@ exit:
+ static int hso_get_config_data(struct usb_interface *interface)
+ {
+ 	struct usb_device *usbdev = interface_to_usbdev(interface);
+-	u8 config_data[17];
++	u8 *config_data = kmalloc(17, GFP_KERNEL);
+ 	u32 if_num = interface->altsetting->desc.bInterfaceNumber;
+ 	s32 result;
+ 
++	if (!config_data)
++		return -ENOMEM;
+ 	if (usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
+ 			    0x86, 0xC0, 0, 0, config_data, 17,
+ 			    USB_CTRL_SET_TIMEOUT) != 0x11) {
++		kfree(config_data);
+ 		return -EIO;
+ 	}
+ 
+@@ -2873,6 +2876,7 @@ static int hso_get_config_data(struct us
+ 	if (config_data[16] & 0x1)
+ 		result |= HSO_INFO_CRC_BUG;
+ 
++	kfree(config_data);
+ 	return result;
+ }
+ 
diff --git a/target/linux/generic/patches-3.10/009-mtd_m25p80_add_support_for_esmt_f25l32pa.patch b/target/linux/generic/patches-3.10/009-mtd_m25p80_add_support_for_esmt_f25l32pa.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/009-mtd_m25p80_add_support_for_esmt_f25l32pa.patch
@@ -0,0 +1,37 @@
+From 7d75ef5f56dbc2bedb9a893eb9ecfd03c456338d Mon Sep 17 00:00:00 2001
+From: Flavio Silveira <fggs@terra.com.br>
+Date: Thu, 29 Aug 2013 08:51:48 -0300
+Subject: [PATCH v2] mtd: m25p80: Add support for ESMT F25L32PA
+
+This flashchip is used in D-Link DIR-610 A1 router board 
+and maybe several others, yet is not kernel upstream.
+
+So add support for it according to datasheet [0], making it easier
+to support other boards using this flashchip in the future.
+
+Changelog v2:
+ - Better description
+ - Datasheet link at the bottom, similar to other patches.
+
+[0] http://www.esmt.com.tw/DB/manager/upload/F25L32PA.pdf 
+
+Signed-off-by: Flavio Silveira <fggs@terra.com.br>
+---
+ drivers/mtd/devices/m25p80.c |    3 +++
+ 1 file changed, 3 insertions(+)
+
+ http://patchwork.ozlabs.org/patch/272438/
+ http://lists.infradead.org/pipermail/linux-mtd/2013-September/048511.html
+
+--- a/drivers/mtd/devices/m25p80.c
++++ b/drivers/mtd/devices/m25p80.c
+@@ -731,6 +731,9 @@ static const struct spi_device_id m25p_i
+ 	{ "en25q64", INFO(0x1c3017, 0, 64 * 1024, 128, SECT_4K) },
+ 	{ "en25qh256", INFO(0x1c7019, 0, 64 * 1024, 512, 0) },
+ 
++	/* ESMT */
++	{ "f25l32pa", INFO(0x8c2016, 0, 64 * 1024, 64, SECT_4K) },
++
+ 	/* Everspin */
+ 	{ "mr25h256", CAT25_INFO(  32 * 1024, 1, 256, 2) },
+ 
diff --git a/target/linux/generic/patches-3.10/020-ssb_update.patch b/target/linux/generic/patches-3.10/020-ssb_update.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/020-ssb_update.patch
@@ -0,0 +1,196 @@
+--- a/drivers/ssb/Kconfig
++++ b/drivers/ssb/Kconfig
+@@ -138,13 +138,13 @@ config SSB_DRIVER_MIPS
+ 
+ config SSB_SFLASH
+ 	bool "SSB serial flash support"
+-	depends on SSB_DRIVER_MIPS && BROKEN
++	depends on SSB_DRIVER_MIPS
+ 	default y
+ 
+ # Assumption: We are on embedded, if we compile the MIPS core.
+ config SSB_EMBEDDED
+ 	bool
+-	depends on SSB_DRIVER_MIPS
++	depends on SSB_DRIVER_MIPS && SSB_PCICORE_HOSTMODE
+ 	default y
+ 
+ config SSB_DRIVER_EXTIF
+--- a/drivers/ssb/driver_chipcommon_sflash.c
++++ b/drivers/ssb/driver_chipcommon_sflash.c
+@@ -9,6 +9,19 @@
+ 
+ #include "ssb_private.h"
+ 
++static struct resource ssb_sflash_resource = {
++	.name	= "ssb_sflash",
++	.start	= SSB_FLASH2,
++	.end	= 0,
++	.flags  = IORESOURCE_MEM | IORESOURCE_READONLY,
++};
++
++struct platform_device ssb_sflash_dev = {
++	.name		= "ssb_sflash",
++	.resource	= &ssb_sflash_resource,
++	.num_resources	= 1,
++};
++
+ struct ssb_sflash_tbl_e {
+ 	char *name;
+ 	u32 id;
+@@ -16,7 +29,7 @@ struct ssb_sflash_tbl_e {
+ 	u16 numblocks;
+ };
+ 
+-static struct ssb_sflash_tbl_e ssb_sflash_st_tbl[] = {
++static const struct ssb_sflash_tbl_e ssb_sflash_st_tbl[] = {
+ 	{ "M25P20", 0x11, 0x10000, 4, },
+ 	{ "M25P40", 0x12, 0x10000, 8, },
+ 
+@@ -27,7 +40,7 @@ static struct ssb_sflash_tbl_e ssb_sflas
+ 	{ 0 },
+ };
+ 
+-static struct ssb_sflash_tbl_e ssb_sflash_sst_tbl[] = {
++static const struct ssb_sflash_tbl_e ssb_sflash_sst_tbl[] = {
+ 	{ "SST25WF512", 1, 0x1000, 16, },
+ 	{ "SST25VF512", 0x48, 0x1000, 16, },
+ 	{ "SST25WF010", 2, 0x1000, 32, },
+@@ -45,7 +58,7 @@ static struct ssb_sflash_tbl_e ssb_sflas
+ 	{ 0 },
+ };
+ 
+-static struct ssb_sflash_tbl_e ssb_sflash_at_tbl[] = {
++static const struct ssb_sflash_tbl_e ssb_sflash_at_tbl[] = {
+ 	{ "AT45DB011", 0xc, 256, 512, },
+ 	{ "AT45DB021", 0x14, 256, 1024, },
+ 	{ "AT45DB041", 0x1c, 256, 2048, },
+@@ -73,7 +86,8 @@ static void ssb_sflash_cmd(struct ssb_ch
+ /* Initialize serial flash access */
+ int ssb_sflash_init(struct ssb_chipcommon *cc)
+ {
+-	struct ssb_sflash_tbl_e *e;
++	struct ssb_sflash *sflash = &cc->dev->bus->mipscore.sflash;
++	const struct ssb_sflash_tbl_e *e;
+ 	u32 id, id2;
+ 
+ 	switch (cc->capabilities & SSB_CHIPCO_CAP_FLASHT) {
+@@ -131,10 +145,20 @@ int ssb_sflash_init(struct ssb_chipcommo
+ 		return -ENOTSUPP;
+ 	}
+ 
+-	pr_info("Found %s serial flash (blocksize: 0x%X, blocks: %d)\n",
+-		e->name, e->blocksize, e->numblocks);
+-
+-	pr_err("Serial flash support is not implemented yet!\n");
++	sflash->window = SSB_FLASH2;
++	sflash->blocksize = e->blocksize;
++	sflash->numblocks = e->numblocks;
++	sflash->size = sflash->blocksize * sflash->numblocks;
++	sflash->present = true;
++
++	pr_info("Found %s serial flash (size: %dKiB, blocksize: 0x%X, blocks: %d)\n",
++		e->name, sflash->size / 1024, e->blocksize, e->numblocks);
++
++	/* Prepare platform device, but don't register it yet. It's too early,
++	 * malloc (required by device_private_init) is not available yet. */
++	ssb_sflash_dev.resource[0].end = ssb_sflash_dev.resource[0].start +
++					 sflash->size;
++	ssb_sflash_dev.dev.platform_data = sflash;
+ 
+-	return -ENOTSUPP;
++	return 0;
+ }
+--- a/drivers/ssb/main.c
++++ b/drivers/ssb/main.c
+@@ -553,6 +553,14 @@ static int ssb_devices_register(struct s
+ 	}
+ #endif
+ 
++#ifdef CONFIG_SSB_SFLASH
++	if (bus->mipscore.sflash.present) {
++		err = platform_device_register(&ssb_sflash_dev);
++		if (err)
++			pr_err("Error registering serial flash\n");
++	}
++#endif
++
+ 	return 0;
+ error:
+ 	/* Unwind the already registered devices. */
+--- a/drivers/ssb/pcihost_wrapper.c
++++ b/drivers/ssb/pcihost_wrapper.c
+@@ -38,7 +38,7 @@ static int ssb_pcihost_resume(struct pci
+ 	struct ssb_bus *ssb = pci_get_drvdata(dev);
+ 	int err;
+ 
+-	pci_set_power_state(dev, 0);
++	pci_set_power_state(dev, PCI_D0);
+ 	err = pci_enable_device(dev);
+ 	if (err)
+ 		return err;
+--- a/drivers/ssb/sprom.c
++++ b/drivers/ssb/sprom.c
+@@ -54,7 +54,7 @@ static int hex2sprom(u16 *sprom, const c
+ 	while (cnt < sprom_size_words) {
+ 		memcpy(tmp, dump, 4);
+ 		dump += 4;
+-		err = strict_strtoul(tmp, 16, &parsed);
++		err = kstrtoul(tmp, 16, &parsed);
+ 		if (err)
+ 			return err;
+ 		sprom[cnt++] = swab16((u16)parsed);
+--- a/drivers/ssb/ssb_private.h
++++ b/drivers/ssb/ssb_private.h
+@@ -243,6 +243,10 @@ static inline int ssb_sflash_init(struct
+ extern struct platform_device ssb_pflash_dev;
+ #endif
+ 
++#ifdef CONFIG_SSB_SFLASH
++extern struct platform_device ssb_sflash_dev;
++#endif
++
+ #ifdef CONFIG_SSB_DRIVER_EXTIF
+ extern u32 ssb_extif_watchdog_timer_set_wdt(struct bcm47xx_wdt *wdt, u32 ticks);
+ extern u32 ssb_extif_watchdog_timer_set_ms(struct bcm47xx_wdt *wdt, u32 ms);
+--- a/include/linux/ssb/ssb_driver_mips.h
++++ b/include/linux/ssb/ssb_driver_mips.h
+@@ -20,6 +20,18 @@ struct ssb_pflash {
+ 	u32 window_size;
+ };
+ 
++#ifdef CONFIG_SSB_SFLASH
++struct ssb_sflash {
++	bool present;
++	u32 window;
++	u32 blocksize;
++	u16 numblocks;
++	u32 size;
++
++	void *priv;
++};
++#endif
++
+ struct ssb_mipscore {
+ 	struct ssb_device *dev;
+ 
+@@ -27,6 +39,9 @@ struct ssb_mipscore {
+ 	struct ssb_serial_port serial_ports[4];
+ 
+ 	struct ssb_pflash pflash;
++#ifdef CONFIG_SSB_SFLASH
++	struct ssb_sflash sflash;
++#endif
+ };
+ 
+ extern void ssb_mipscore_init(struct ssb_mipscore *mcore);
+--- a/include/linux/ssb/ssb_regs.h
++++ b/include/linux/ssb/ssb_regs.h
+@@ -172,6 +172,7 @@
+ #define SSB_SPROMSIZE_WORDS_R4		220
+ #define SSB_SPROMSIZE_BYTES_R123	(SSB_SPROMSIZE_WORDS_R123 * sizeof(u16))
+ #define SSB_SPROMSIZE_BYTES_R4		(SSB_SPROMSIZE_WORDS_R4 * sizeof(u16))
++#define SSB_SPROMSIZE_WORDS_R10		230
+ #define SSB_SPROM_BASE1			0x1000
+ #define SSB_SPROM_BASE31		0x0800
+ #define SSB_SPROM_REVISION		0x007E
diff --git a/target/linux/generic/patches-3.10/025-bcma_backport.patch b/target/linux/generic/patches-3.10/025-bcma_backport.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/025-bcma_backport.patch
@@ -0,0 +1,988 @@
+--- a/drivers/bcma/Kconfig
++++ b/drivers/bcma/Kconfig
+@@ -26,6 +26,7 @@ config BCMA_HOST_PCI_POSSIBLE
+ config BCMA_HOST_PCI
+ 	bool "Support for BCMA on PCI-host bus"
+ 	depends on BCMA_HOST_PCI_POSSIBLE
++	default y
+ 
+ config BCMA_DRIVER_PCI_HOSTMODE
+ 	bool "Driver for PCI core working in hostmode"
+@@ -34,8 +35,14 @@ config BCMA_DRIVER_PCI_HOSTMODE
+ 	  PCI core hostmode operation (external PCI bus).
+ 
+ config BCMA_HOST_SOC
+-	bool
+-	depends on BCMA_DRIVER_MIPS
++	bool "Support for BCMA in a SoC"
++	depends on BCMA
++	help
++	  Host interface for a Broadcom AIX bus directly mapped into
++	  the memory. This only works with the Broadcom SoCs from the
++	  BCM47XX line.
++
++	  If unsure, say N
+ 
+ config BCMA_DRIVER_MIPS
+ 	bool "BCMA Broadcom MIPS core driver"
+--- a/drivers/bcma/bcma_private.h
++++ b/drivers/bcma/bcma_private.h
+@@ -22,6 +22,8 @@
+ struct bcma_bus;
+ 
+ /* main.c */
++bool bcma_wait_value(struct bcma_device *core, u16 reg, u32 mask, u32 value,
++		     int timeout);
+ int bcma_bus_register(struct bcma_bus *bus);
+ void bcma_bus_unregister(struct bcma_bus *bus);
+ int __init bcma_bus_early_register(struct bcma_bus *bus,
+--- a/drivers/bcma/core.c
++++ b/drivers/bcma/core.c
+@@ -9,6 +9,25 @@
+ #include <linux/export.h>
+ #include <linux/bcma/bcma.h>
+ 
++static bool bcma_core_wait_value(struct bcma_device *core, u16 reg, u32 mask,
++				 u32 value, int timeout)
++{
++	unsigned long deadline = jiffies + timeout;
++	u32 val;
++
++	do {
++		val = bcma_aread32(core, reg);
++		if ((val & mask) == value)
++			return true;
++		cpu_relax();
++		udelay(10);
++	} while (!time_after_eq(jiffies, deadline));
++
++	bcma_warn(core->bus, "Timeout waiting for register 0x%04X!\n", reg);
++
++	return false;
++}
++
+ bool bcma_core_is_enabled(struct bcma_device *core)
+ {
+ 	if ((bcma_aread32(core, BCMA_IOCTL) & (BCMA_IOCTL_CLK | BCMA_IOCTL_FGC))
+@@ -25,13 +44,15 @@ void bcma_core_disable(struct bcma_devic
+ 	if (bcma_aread32(core, BCMA_RESET_CTL) & BCMA_RESET_CTL_RESET)
+ 		return;
+ 
+-	bcma_awrite32(core, BCMA_IOCTL, flags);
+-	bcma_aread32(core, BCMA_IOCTL);
+-	udelay(10);
++	bcma_core_wait_value(core, BCMA_RESET_ST, ~0, 0, 300);
+ 
+ 	bcma_awrite32(core, BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);
+ 	bcma_aread32(core, BCMA_RESET_CTL);
+ 	udelay(1);
++
++	bcma_awrite32(core, BCMA_IOCTL, flags);
++	bcma_aread32(core, BCMA_IOCTL);
++	udelay(10);
+ }
+ EXPORT_SYMBOL_GPL(bcma_core_disable);
+ 
+@@ -43,6 +64,7 @@ int bcma_core_enable(struct bcma_device
+ 	bcma_aread32(core, BCMA_IOCTL);
+ 
+ 	bcma_awrite32(core, BCMA_RESET_CTL, 0);
++	bcma_aread32(core, BCMA_RESET_CTL);
+ 	udelay(1);
+ 
+ 	bcma_awrite32(core, BCMA_IOCTL, (BCMA_IOCTL_CLK | flags));
+--- a/drivers/bcma/driver_chipcommon.c
++++ b/drivers/bcma/driver_chipcommon.c
+@@ -140,8 +140,15 @@ void bcma_core_chipcommon_init(struct bc
+ 	bcma_core_chipcommon_early_init(cc);
+ 
+ 	if (cc->core->id.rev >= 20) {
+-		bcma_cc_write32(cc, BCMA_CC_GPIOPULLUP, 0);
+-		bcma_cc_write32(cc, BCMA_CC_GPIOPULLDOWN, 0);
++		u32 pullup = 0, pulldown = 0;
++
++		if (cc->core->bus->chipinfo.id == BCMA_CHIP_ID_BCM43142) {
++			pullup = 0x402e0;
++			pulldown = 0x20500;
++		}
++
++		bcma_cc_write32(cc, BCMA_CC_GPIOPULLUP, pullup);
++		bcma_cc_write32(cc, BCMA_CC_GPIOPULLDOWN, pulldown);
+ 	}
+ 
+ 	if (cc->capabilities & BCMA_CC_CAP_PMU)
+--- a/drivers/bcma/driver_chipcommon_pmu.c
++++ b/drivers/bcma/driver_chipcommon_pmu.c
+@@ -56,6 +56,109 @@ void bcma_chipco_regctl_maskset(struct b
+ }
+ EXPORT_SYMBOL_GPL(bcma_chipco_regctl_maskset);
+ 
++static u32 bcma_pmu_xtalfreq(struct bcma_drv_cc *cc)
++{
++	u32 ilp_ctl, alp_hz;
++
++	if (!(bcma_cc_read32(cc, BCMA_CC_PMU_STAT) &
++	      BCMA_CC_PMU_STAT_EXT_LPO_AVAIL))
++		return 0;
++
++	bcma_cc_write32(cc, BCMA_CC_PMU_XTAL_FREQ,
++			BIT(BCMA_CC_PMU_XTAL_FREQ_MEASURE_SHIFT));
++	usleep_range(1000, 2000);
++
++	ilp_ctl = bcma_cc_read32(cc, BCMA_CC_PMU_XTAL_FREQ);
++	ilp_ctl &= BCMA_CC_PMU_XTAL_FREQ_ILPCTL_MASK;
++
++	bcma_cc_write32(cc, BCMA_CC_PMU_XTAL_FREQ, 0);
++
++	alp_hz = ilp_ctl * 32768 / 4;
++	return (alp_hz + 50000) / 100000 * 100;
++}
++
++static void bcma_pmu2_pll_init0(struct bcma_drv_cc *cc, u32 xtalfreq)
++{
++	struct bcma_bus *bus = cc->core->bus;
++	u32 freq_tgt_target = 0, freq_tgt_current;
++	u32 pll0, mask;
++
++	switch (bus->chipinfo.id) {
++	case BCMA_CHIP_ID_BCM43142:
++		/* pmu2_xtaltab0_adfll_485 */
++		switch (xtalfreq) {
++		case 12000:
++			freq_tgt_target = 0x50D52;
++			break;
++		case 20000:
++			freq_tgt_target = 0x307FE;
++			break;
++		case 26000:
++			freq_tgt_target = 0x254EA;
++			break;
++		case 37400:
++			freq_tgt_target = 0x19EF8;
++			break;
++		case 52000:
++			freq_tgt_target = 0x12A75;
++			break;
++		}
++		break;
++	}
++
++	if (!freq_tgt_target) {
++		bcma_err(bus, "Unknown TGT frequency for xtalfreq %d\n",
++			 xtalfreq);
++		return;
++	}
++
++	pll0 = bcma_chipco_pll_read(cc, BCMA_CC_PMU15_PLL_PLLCTL0);
++	freq_tgt_current = (pll0 & BCMA_CC_PMU15_PLL_PC0_FREQTGT_MASK) >>
++		BCMA_CC_PMU15_PLL_PC0_FREQTGT_SHIFT;
++
++	if (freq_tgt_current == freq_tgt_target) {
++		bcma_debug(bus, "Target TGT frequency already set\n");
++		return;
++	}
++
++	/* Turn off PLL */
++	switch (bus->chipinfo.id) {
++	case BCMA_CHIP_ID_BCM43142:
++		mask = (u32)~(BCMA_RES_4314_HT_AVAIL |
++			      BCMA_RES_4314_MACPHY_CLK_AVAIL);
++
++		bcma_cc_mask32(cc, BCMA_CC_PMU_MINRES_MSK, mask);
++		bcma_cc_mask32(cc, BCMA_CC_PMU_MAXRES_MSK, mask);
++		bcma_wait_value(cc->core, BCMA_CLKCTLST,
++				BCMA_CLKCTLST_HAVEHT, 0, 20000);
++		break;
++	}
++
++	pll0 &= ~BCMA_CC_PMU15_PLL_PC0_FREQTGT_MASK;
++	pll0 |= freq_tgt_target << BCMA_CC_PMU15_PLL_PC0_FREQTGT_SHIFT;
++	bcma_chipco_pll_write(cc, BCMA_CC_PMU15_PLL_PLLCTL0, pll0);
++
++	/* Flush */
++	if (cc->pmu.rev >= 2)
++		bcma_cc_set32(cc, BCMA_CC_PMU_CTL, BCMA_CC_PMU_CTL_PLL_UPD);
++
++	/* TODO: Do we need to update OTP? */
++}
++
++static void bcma_pmu_pll_init(struct bcma_drv_cc *cc)
++{
++	struct bcma_bus *bus = cc->core->bus;
++	u32 xtalfreq = bcma_pmu_xtalfreq(cc);
++
++	switch (bus->chipinfo.id) {
++	case BCMA_CHIP_ID_BCM43142:
++		if (xtalfreq == 0)
++			xtalfreq = 20000;
++		bcma_pmu2_pll_init0(cc, xtalfreq);
++		break;
++	}
++}
++
+ static void bcma_pmu_resources_init(struct bcma_drv_cc *cc)
+ {
+ 	struct bcma_bus *bus = cc->core->bus;
+@@ -66,6 +169,25 @@ static void bcma_pmu_resources_init(stru
+ 		min_msk = 0x200D;
+ 		max_msk = 0xFFFF;
+ 		break;
++	case BCMA_CHIP_ID_BCM43142:
++		min_msk = BCMA_RES_4314_LPLDO_PU |
++			  BCMA_RES_4314_PMU_SLEEP_DIS |
++			  BCMA_RES_4314_PMU_BG_PU |
++			  BCMA_RES_4314_CBUCK_LPOM_PU |
++			  BCMA_RES_4314_CBUCK_PFM_PU |
++			  BCMA_RES_4314_CLDO_PU |
++			  BCMA_RES_4314_LPLDO2_LVM |
++			  BCMA_RES_4314_WL_PMU_PU |
++			  BCMA_RES_4314_LDO3P3_PU |
++			  BCMA_RES_4314_OTP_PU |
++			  BCMA_RES_4314_WL_PWRSW_PU |
++			  BCMA_RES_4314_LQ_AVAIL |
++			  BCMA_RES_4314_LOGIC_RET |
++			  BCMA_RES_4314_MEM_SLEEP |
++			  BCMA_RES_4314_MACPHY_RET |
++			  BCMA_RES_4314_WL_CORE_READY;
++		max_msk = 0x3FFFFFFF;
++		break;
+ 	default:
+ 		bcma_debug(bus, "PMU resource config unknown or not needed for device 0x%04X\n",
+ 			   bus->chipinfo.id);
+@@ -165,6 +287,7 @@ void bcma_pmu_init(struct bcma_drv_cc *c
+ 		bcma_cc_set32(cc, BCMA_CC_PMU_CTL,
+ 			     BCMA_CC_PMU_CTL_NOILPONW);
+ 
++	bcma_pmu_pll_init(cc);
+ 	bcma_pmu_resources_init(cc);
+ 	bcma_pmu_workarounds(cc);
+ }
+--- a/drivers/bcma/driver_chipcommon_sflash.c
++++ b/drivers/bcma/driver_chipcommon_sflash.c
+@@ -30,7 +30,7 @@ struct bcma_sflash_tbl_e {
+ 	u16 numblocks;
+ };
+ 
+-static struct bcma_sflash_tbl_e bcma_sflash_st_tbl[] = {
++static const struct bcma_sflash_tbl_e bcma_sflash_st_tbl[] = {
+ 	{ "M25P20", 0x11, 0x10000, 4, },
+ 	{ "M25P40", 0x12, 0x10000, 8, },
+ 
+@@ -41,7 +41,7 @@ static struct bcma_sflash_tbl_e bcma_sfl
+ 	{ 0 },
+ };
+ 
+-static struct bcma_sflash_tbl_e bcma_sflash_sst_tbl[] = {
++static const struct bcma_sflash_tbl_e bcma_sflash_sst_tbl[] = {
+ 	{ "SST25WF512", 1, 0x1000, 16, },
+ 	{ "SST25VF512", 0x48, 0x1000, 16, },
+ 	{ "SST25WF010", 2, 0x1000, 32, },
+@@ -59,7 +59,7 @@ static struct bcma_sflash_tbl_e bcma_sfl
+ 	{ 0 },
+ };
+ 
+-static struct bcma_sflash_tbl_e bcma_sflash_at_tbl[] = {
++static const struct bcma_sflash_tbl_e bcma_sflash_at_tbl[] = {
+ 	{ "AT45DB011", 0xc, 256, 512, },
+ 	{ "AT45DB021", 0x14, 256, 1024, },
+ 	{ "AT45DB041", 0x1c, 256, 2048, },
+@@ -89,7 +89,7 @@ int bcma_sflash_init(struct bcma_drv_cc
+ {
+ 	struct bcma_bus *bus = cc->core->bus;
+ 	struct bcma_sflash *sflash = &cc->sflash;
+-	struct bcma_sflash_tbl_e *e;
++	const struct bcma_sflash_tbl_e *e;
+ 	u32 id, id2;
+ 
+ 	switch (cc->capabilities & BCMA_CC_CAP_FLASHT) {
+--- a/drivers/bcma/host_pci.c
++++ b/drivers/bcma/host_pci.c
+@@ -275,6 +275,7 @@ static DEFINE_PCI_DEVICE_TABLE(bcma_pci_
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4357) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4358) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4359) },
++	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4365) },
+ 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4727) },
+ 	{ 0, },
+ };
+--- a/drivers/bcma/main.c
++++ b/drivers/bcma/main.c
+@@ -93,6 +93,25 @@ struct bcma_device *bcma_find_core_unit(
+ 	return NULL;
+ }
+ 
++bool bcma_wait_value(struct bcma_device *core, u16 reg, u32 mask, u32 value,
++		     int timeout)
++{
++	unsigned long deadline = jiffies + timeout;
++	u32 val;
++
++	do {
++		val = bcma_read32(core, reg);
++		if ((val & mask) == value)
++			return true;
++		cpu_relax();
++		udelay(10);
++	} while (!time_after_eq(jiffies, deadline));
++
++	bcma_warn(core->bus, "Timeout waiting for register 0x%04X!\n", reg);
++
++	return false;
++}
++
+ static void bcma_release_core_dev(struct device *dev)
+ {
+ 	struct bcma_device *core = container_of(dev, struct bcma_device, dev);
+@@ -218,7 +237,7 @@ int bcma_bus_register(struct bcma_bus *b
+ 	err = bcma_bus_scan(bus);
+ 	if (err) {
+ 		bcma_err(bus, "Failed to scan: %d\n", err);
+-		return -1;
++		return err;
+ 	}
+ 
+ 	/* Early init CC core */
+--- a/drivers/bcma/sprom.c
++++ b/drivers/bcma/sprom.c
+@@ -72,12 +72,12 @@ fail:
+  * R/W ops.
+  **************************************************/
+ 
+-static void bcma_sprom_read(struct bcma_bus *bus, u16 offset, u16 *sprom)
++static void bcma_sprom_read(struct bcma_bus *bus, u16 offset, u16 *sprom,
++			    size_t words)
+ {
+ 	int i;
+-	for (i = 0; i < SSB_SPROMSIZE_WORDS_R4; i++)
+-		sprom[i] = bcma_read16(bus->drv_cc.core,
+-				       offset + (i * 2));
++	for (i = 0; i < words; i++)
++		sprom[i] = bcma_read16(bus->drv_cc.core, offset + (i * 2));
+ }
+ 
+ /**************************************************
+@@ -124,29 +124,29 @@ static inline u8 bcma_crc8(u8 crc, u8 da
+ 	return t[crc ^ data];
+ }
+ 
+-static u8 bcma_sprom_crc(const u16 *sprom)
++static u8 bcma_sprom_crc(const u16 *sprom, size_t words)
+ {
+ 	int word;
+ 	u8 crc = 0xFF;
+ 
+-	for (word = 0; word < SSB_SPROMSIZE_WORDS_R4 - 1; word++) {
++	for (word = 0; word < words - 1; word++) {
+ 		crc = bcma_crc8(crc, sprom[word] & 0x00FF);
+ 		crc = bcma_crc8(crc, (sprom[word] & 0xFF00) >> 8);
+ 	}
+-	crc = bcma_crc8(crc, sprom[SSB_SPROMSIZE_WORDS_R4 - 1] & 0x00FF);
++	crc = bcma_crc8(crc, sprom[words - 1] & 0x00FF);
+ 	crc ^= 0xFF;
+ 
+ 	return crc;
+ }
+ 
+-static int bcma_sprom_check_crc(const u16 *sprom)
++static int bcma_sprom_check_crc(const u16 *sprom, size_t words)
+ {
+ 	u8 crc;
+ 	u8 expected_crc;
+ 	u16 tmp;
+ 
+-	crc = bcma_sprom_crc(sprom);
+-	tmp = sprom[SSB_SPROMSIZE_WORDS_R4 - 1] & SSB_SPROM_REVISION_CRC;
++	crc = bcma_sprom_crc(sprom, words);
++	tmp = sprom[words - 1] & SSB_SPROM_REVISION_CRC;
+ 	expected_crc = tmp >> SSB_SPROM_REVISION_CRC_SHIFT;
+ 	if (crc != expected_crc)
+ 		return -EPROTO;
+@@ -154,21 +154,25 @@ static int bcma_sprom_check_crc(const u1
+ 	return 0;
+ }
+ 
+-static int bcma_sprom_valid(const u16 *sprom)
++static int bcma_sprom_valid(struct bcma_bus *bus, const u16 *sprom,
++			    size_t words)
+ {
+ 	u16 revision;
+ 	int err;
+ 
+-	err = bcma_sprom_check_crc(sprom);
++	err = bcma_sprom_check_crc(sprom, words);
+ 	if (err)
+ 		return err;
+ 
+-	revision = sprom[SSB_SPROMSIZE_WORDS_R4 - 1] & SSB_SPROM_REVISION_REV;
+-	if (revision != 8 && revision != 9) {
++	revision = sprom[words - 1] & SSB_SPROM_REVISION_REV;
++	if (revision != 8 && revision != 9 && revision != 10) {
+ 		pr_err("Unsupported SPROM revision: %d\n", revision);
+ 		return -ENOENT;
+ 	}
+ 
++	bus->sprom.revision = revision;
++	bcma_debug(bus, "Found SPROM revision %d\n", revision);
++
+ 	return 0;
+ }
+ 
+@@ -208,9 +212,6 @@ static void bcma_sprom_extract_r8(struct
+ 	BUILD_BUG_ON(ARRAY_SIZE(pwr_info_offset) !=
+ 			ARRAY_SIZE(bus->sprom.core_pwr_info));
+ 
+-	bus->sprom.revision = sprom[SSB_SPROMSIZE_WORDS_R4 - 1] &
+-		SSB_SPROM_REVISION_REV;
+-
+ 	for (i = 0; i < 3; i++) {
+ 		v = sprom[SPOFF(SSB_SPROM8_IL0MAC) + i];
+ 		*(((__be16 *)bus->sprom.il0mac) + i) = cpu_to_be16(v);
+@@ -502,7 +503,7 @@ static bool bcma_sprom_onchip_available(
+ 	case BCMA_CHIP_ID_BCM4331:
+ 		present = chip_status & BCMA_CC_CHIPST_4331_OTP_PRESENT;
+ 		break;
+-
++	case BCMA_CHIP_ID_BCM43142:
+ 	case BCMA_CHIP_ID_BCM43224:
+ 	case BCMA_CHIP_ID_BCM43225:
+ 		/* for these chips OTP is always available */
+@@ -550,7 +551,9 @@ int bcma_sprom_get(struct bcma_bus *bus)
+ {
+ 	u16 offset = BCMA_CC_SPROM;
+ 	u16 *sprom;
+-	int err = 0;
++	size_t sprom_sizes[] = { SSB_SPROMSIZE_WORDS_R4,
++				 SSB_SPROMSIZE_WORDS_R10, };
++	int i, err = 0;
+ 
+ 	if (!bus->drv_cc.core)
+ 		return -EOPNOTSUPP;
+@@ -579,32 +582,37 @@ int bcma_sprom_get(struct bcma_bus *bus)
+ 		}
+ 	}
+ 
+-	sprom = kcalloc(SSB_SPROMSIZE_WORDS_R4, sizeof(u16),
+-			GFP_KERNEL);
+-	if (!sprom)
+-		return -ENOMEM;
+-
+ 	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4331 ||
+ 	    bus->chipinfo.id == BCMA_CHIP_ID_BCM43431)
+ 		bcma_chipco_bcm4331_ext_pa_lines_ctl(&bus->drv_cc, false);
+ 
+ 	bcma_debug(bus, "SPROM offset 0x%x\n", offset);
+-	bcma_sprom_read(bus, offset, sprom);
++	for (i = 0; i < ARRAY_SIZE(sprom_sizes); i++) {
++		size_t words = sprom_sizes[i];
++
++		sprom = kcalloc(words, sizeof(u16), GFP_KERNEL);
++		if (!sprom)
++			return -ENOMEM;
++
++		bcma_sprom_read(bus, offset, sprom, words);
++		err = bcma_sprom_valid(bus, sprom, words);
++		if (!err)
++			break;
++
++		kfree(sprom);
++	}
+ 
+ 	if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4331 ||
+ 	    bus->chipinfo.id == BCMA_CHIP_ID_BCM43431)
+ 		bcma_chipco_bcm4331_ext_pa_lines_ctl(&bus->drv_cc, true);
+ 
+-	err = bcma_sprom_valid(sprom);
+ 	if (err) {
+-		bcma_warn(bus, "invalid sprom read from the PCIe card, try to use fallback sprom\n");
++		bcma_warn(bus, "Invalid SPROM read from the PCIe card, trying to use fallback SPROM\n");
+ 		err = bcma_fill_sprom_with_fallback(bus, &bus->sprom);
+-		goto out;
++	} else {
++		bcma_sprom_extract_r8(bus, sprom);
++		kfree(sprom);
+ 	}
+ 
+-	bcma_sprom_extract_r8(bus, sprom);
+-
+-out:
+-	kfree(sprom);
+ 	return err;
+ }
+--- a/include/linux/bcma/bcma.h
++++ b/include/linux/bcma/bcma.h
+@@ -72,7 +72,19 @@ struct bcma_host_ops {
+ /* Core-ID values. */
+ #define BCMA_CORE_OOB_ROUTER		0x367	/* Out of band */
+ #define BCMA_CORE_4706_CHIPCOMMON	0x500
++#define BCMA_CORE_PCIEG2		0x501
++#define BCMA_CORE_DMA			0x502
++#define BCMA_CORE_SDIO3			0x503
++#define BCMA_CORE_USB20			0x504
++#define BCMA_CORE_USB30			0x505
++#define BCMA_CORE_A9JTAG		0x506
++#define BCMA_CORE_DDR23			0x507
++#define BCMA_CORE_ROM			0x508
++#define BCMA_CORE_NAND			0x509
++#define BCMA_CORE_QSPI			0x50A
++#define BCMA_CORE_CHIPCOMMON_B		0x50B
+ #define BCMA_CORE_4706_SOC_RAM		0x50E
++#define BCMA_CORE_ARMCA9		0x510
+ #define BCMA_CORE_4706_MAC_GBIT		0x52D
+ #define BCMA_CORE_AMEMC			0x52E	/* DDR1/2 memory controller core */
+ #define BCMA_CORE_ALTA			0x534	/* I2S core */
+@@ -144,6 +156,7 @@ struct bcma_host_ops {
+ 
+ /* Chip IDs of PCIe devices */
+ #define BCMA_CHIP_ID_BCM4313	0x4313
++#define BCMA_CHIP_ID_BCM43142	43142
+ #define BCMA_CHIP_ID_BCM43224	43224
+ #define  BCMA_PKG_ID_BCM43224_FAB_CSM	0x8
+ #define  BCMA_PKG_ID_BCM43224_FAB_SMIC	0xa
+@@ -176,6 +189,11 @@ struct bcma_host_ops {
+ #define  BCMA_PKG_ID_BCM5357	11
+ #define BCMA_CHIP_ID_BCM53572	53572
+ #define  BCMA_PKG_ID_BCM47188	9
++#define BCMA_CHIP_ID_BCM4707	53010
++#define  BCMA_PKG_ID_BCM4707	1
++#define  BCMA_PKG_ID_BCM4708	2
++#define  BCMA_PKG_ID_BCM4709	0
++#define BCMA_CHIP_ID_BCM53018	53018
+ 
+ /* Board types (on PCI usually equals to the subsystem dev id) */
+ /* BCM4313 */
+--- a/include/linux/bcma/bcma_driver_chipcommon.h
++++ b/include/linux/bcma/bcma_driver_chipcommon.h
+@@ -330,6 +330,8 @@
+ #define BCMA_CC_PMU_CAP			0x0604 /* PMU capabilities */
+ #define  BCMA_CC_PMU_CAP_REVISION	0x000000FF /* Revision mask */
+ #define BCMA_CC_PMU_STAT		0x0608 /* PMU status */
++#define  BCMA_CC_PMU_STAT_EXT_LPO_AVAIL	0x00000100
++#define  BCMA_CC_PMU_STAT_WDRESET	0x00000080
+ #define  BCMA_CC_PMU_STAT_INTPEND	0x00000040 /* Interrupt pending */
+ #define  BCMA_CC_PMU_STAT_SBCLKST	0x00000030 /* Backplane clock status? */
+ #define  BCMA_CC_PMU_STAT_HAVEALP	0x00000008 /* ALP available */
+@@ -355,6 +357,11 @@
+ #define BCMA_CC_REGCTL_DATA		0x065C
+ #define BCMA_CC_PLLCTL_ADDR		0x0660
+ #define BCMA_CC_PLLCTL_DATA		0x0664
++#define BCMA_CC_PMU_STRAPOPT		0x0668 /* (corerev >= 28) */
++#define BCMA_CC_PMU_XTAL_FREQ		0x066C /* (pmurev >= 10) */
++#define  BCMA_CC_PMU_XTAL_FREQ_ILPCTL_MASK	0x00001FFF
++#define  BCMA_CC_PMU_XTAL_FREQ_MEASURE_MASK	0x80000000
++#define  BCMA_CC_PMU_XTAL_FREQ_MEASURE_SHIFT	31
+ #define BCMA_CC_SPROM			0x0800 /* SPROM beginning */
+ /* NAND flash MLC controller registers (corerev >= 38) */
+ #define BCMA_CC_NAND_REVISION		0x0C00
+@@ -435,6 +442,23 @@
+ #define  BCMA_CC_PMU6_4706_PROC_NDIV_MODE_MASK	0x00000007
+ #define  BCMA_CC_PMU6_4706_PROC_NDIV_MODE_SHIFT	0
+ 
++/* PMU rev 15 */
++#define BCMA_CC_PMU15_PLL_PLLCTL0	0
++#define  BCMA_CC_PMU15_PLL_PC0_CLKSEL_MASK	0x00000003
++#define  BCMA_CC_PMU15_PLL_PC0_CLKSEL_SHIFT	0
++#define  BCMA_CC_PMU15_PLL_PC0_FREQTGT_MASK	0x003FFFFC
++#define  BCMA_CC_PMU15_PLL_PC0_FREQTGT_SHIFT	2
++#define  BCMA_CC_PMU15_PLL_PC0_PRESCALE_MASK	0x00C00000
++#define  BCMA_CC_PMU15_PLL_PC0_PRESCALE_SHIFT	22
++#define  BCMA_CC_PMU15_PLL_PC0_KPCTRL_MASK	0x07000000
++#define  BCMA_CC_PMU15_PLL_PC0_KPCTRL_SHIFT	24
++#define  BCMA_CC_PMU15_PLL_PC0_FCNTCTRL_MASK	0x38000000
++#define  BCMA_CC_PMU15_PLL_PC0_FCNTCTRL_SHIFT	27
++#define  BCMA_CC_PMU15_PLL_PC0_FDCMODE_MASK	0x40000000
++#define  BCMA_CC_PMU15_PLL_PC0_FDCMODE_SHIFT	30
++#define  BCMA_CC_PMU15_PLL_PC0_CTRLBIAS_MASK	0x80000000
++#define  BCMA_CC_PMU15_PLL_PC0_CTRLBIAS_SHIFT	31
++
+ /* ALP clock on pre-PMU chips */
+ #define BCMA_CC_PMU_ALP_CLOCK		20000000
+ /* HT clock for systems with PMU-enabled chipcommon */
+@@ -507,6 +531,37 @@
+ #define BCMA_CHIPCTL_5357_I2S_PINS_ENABLE	BIT(18)
+ #define BCMA_CHIPCTL_5357_I2CSPI_PINS_ENABLE	BIT(19)
+ 
++#define BCMA_RES_4314_LPLDO_PU			BIT(0)
++#define BCMA_RES_4314_PMU_SLEEP_DIS		BIT(1)
++#define BCMA_RES_4314_PMU_BG_PU			BIT(2)
++#define BCMA_RES_4314_CBUCK_LPOM_PU		BIT(3)
++#define BCMA_RES_4314_CBUCK_PFM_PU		BIT(4)
++#define BCMA_RES_4314_CLDO_PU			BIT(5)
++#define BCMA_RES_4314_LPLDO2_LVM		BIT(6)
++#define BCMA_RES_4314_WL_PMU_PU			BIT(7)
++#define BCMA_RES_4314_LNLDO_PU			BIT(8)
++#define BCMA_RES_4314_LDO3P3_PU			BIT(9)
++#define BCMA_RES_4314_OTP_PU			BIT(10)
++#define BCMA_RES_4314_XTAL_PU			BIT(11)
++#define BCMA_RES_4314_WL_PWRSW_PU		BIT(12)
++#define BCMA_RES_4314_LQ_AVAIL			BIT(13)
++#define BCMA_RES_4314_LOGIC_RET			BIT(14)
++#define BCMA_RES_4314_MEM_SLEEP			BIT(15)
++#define BCMA_RES_4314_MACPHY_RET		BIT(16)
++#define BCMA_RES_4314_WL_CORE_READY		BIT(17)
++#define BCMA_RES_4314_ILP_REQ			BIT(18)
++#define BCMA_RES_4314_ALP_AVAIL			BIT(19)
++#define BCMA_RES_4314_MISC_PWRSW_PU		BIT(20)
++#define BCMA_RES_4314_SYNTH_PWRSW_PU		BIT(21)
++#define BCMA_RES_4314_RX_PWRSW_PU		BIT(22)
++#define BCMA_RES_4314_RADIO_PU			BIT(23)
++#define BCMA_RES_4314_VCO_LDO_PU		BIT(24)
++#define BCMA_RES_4314_AFE_LDO_PU		BIT(25)
++#define BCMA_RES_4314_RX_LDO_PU			BIT(26)
++#define BCMA_RES_4314_TX_LDO_PU			BIT(27)
++#define BCMA_RES_4314_HT_AVAIL			BIT(28)
++#define BCMA_RES_4314_MACPHY_CLK_AVAIL		BIT(29)
++
+ /* Data for the PMU, if available.
+  * Check availability with ((struct bcma_chipcommon)->capabilities & BCMA_CC_CAP_PMU)
+  */
+--- a/drivers/bcma/driver_pci.c
++++ b/drivers/bcma/driver_pci.c
+@@ -31,7 +31,7 @@ static void bcma_pcie_write(struct bcma_
+ 	pcicore_write32(pc, BCMA_CORE_PCI_PCIEIND_DATA, data);
+ }
+ 
+-static void bcma_pcie_mdio_set_phy(struct bcma_drv_pci *pc, u8 phy)
++static void bcma_pcie_mdio_set_phy(struct bcma_drv_pci *pc, u16 phy)
+ {
+ 	u32 v;
+ 	int i;
+@@ -55,7 +55,7 @@ static void bcma_pcie_mdio_set_phy(struc
+ 	}
+ }
+ 
+-static u16 bcma_pcie_mdio_read(struct bcma_drv_pci *pc, u8 device, u8 address)
++static u16 bcma_pcie_mdio_read(struct bcma_drv_pci *pc, u16 device, u8 address)
+ {
+ 	int max_retries = 10;
+ 	u16 ret = 0;
+@@ -98,7 +98,7 @@ static u16 bcma_pcie_mdio_read(struct bc
+ 	return ret;
+ }
+ 
+-static void bcma_pcie_mdio_write(struct bcma_drv_pci *pc, u8 device,
++static void bcma_pcie_mdio_write(struct bcma_drv_pci *pc, u16 device,
+ 				u8 address, u16 data)
+ {
+ 	int max_retries = 10;
+@@ -137,6 +137,13 @@ static void bcma_pcie_mdio_write(struct
+ 	pcicore_write32(pc, BCMA_CORE_PCI_MDIO_CONTROL, 0);
+ }
+ 
++static u16 bcma_pcie_mdio_writeread(struct bcma_drv_pci *pc, u16 device,
++				    u8 address, u16 data)
++{
++	bcma_pcie_mdio_write(pc, device, address, data);
++	return bcma_pcie_mdio_read(pc, device, address);
++}
++
+ /**************************************************
+  * Workarounds.
+  **************************************************/
+@@ -203,6 +210,25 @@ static void bcma_core_pci_config_fixup(s
+ 	}
+ }
+ 
++static void bcma_core_pci_power_save(struct bcma_drv_pci *pc, bool up)
++{
++	u16 data;
++
++	if (pc->core->id.rev >= 15 && pc->core->id.rev <= 20) {
++		data = up ? 0x74 : 0x7C;
++		bcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,
++					 BCMA_CORE_PCI_MDIO_BLK1_MGMT1, 0x7F64);
++		bcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,
++					 BCMA_CORE_PCI_MDIO_BLK1_MGMT3, data);
++	} else if (pc->core->id.rev >= 21 && pc->core->id.rev <= 22) {
++		data = up ? 0x75 : 0x7D;
++		bcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,
++					 BCMA_CORE_PCI_MDIO_BLK1_MGMT1, 0x7E65);
++		bcma_pcie_mdio_writeread(pc, BCMA_CORE_PCI_MDIO_BLK1,
++					 BCMA_CORE_PCI_MDIO_BLK1_MGMT3, data);
++	}
++}
++
+ /**************************************************
+  * Init.
+  **************************************************/
+@@ -262,7 +288,7 @@ out:
+ }
+ EXPORT_SYMBOL_GPL(bcma_core_pci_irq_ctl);
+ 
+-void bcma_core_pci_extend_L1timer(struct bcma_drv_pci *pc, bool extend)
++static void bcma_core_pci_extend_L1timer(struct bcma_drv_pci *pc, bool extend)
+ {
+ 	u32 w;
+ 
+@@ -274,4 +300,33 @@ void bcma_core_pci_extend_L1timer(struct
+ 	bcma_pcie_write(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG, w);
+ 	bcma_pcie_read(pc, BCMA_CORE_PCI_DLLP_PMTHRESHREG);
+ }
+-EXPORT_SYMBOL_GPL(bcma_core_pci_extend_L1timer);
++
++void bcma_core_pci_up(struct bcma_bus *bus)
++{
++	struct bcma_drv_pci *pc;
++
++	if (bus->hosttype != BCMA_HOSTTYPE_PCI)
++		return;
++
++	pc = &bus->drv_pci[0];
++
++	bcma_core_pci_power_save(pc, true);
++
++	bcma_core_pci_extend_L1timer(pc, true);
++}
++EXPORT_SYMBOL_GPL(bcma_core_pci_up);
++
++void bcma_core_pci_down(struct bcma_bus *bus)
++{
++	struct bcma_drv_pci *pc;
++
++	if (bus->hosttype != BCMA_HOSTTYPE_PCI)
++		return;
++
++	pc = &bus->drv_pci[0];
++
++	bcma_core_pci_extend_L1timer(pc, false);
++
++	bcma_core_pci_power_save(pc, false);
++}
++EXPORT_SYMBOL_GPL(bcma_core_pci_down);
+--- a/drivers/bcma/driver_pci_host.c
++++ b/drivers/bcma/driver_pci_host.c
+@@ -581,6 +581,7 @@ DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI
+ int bcma_core_pci_plat_dev_init(struct pci_dev *dev)
+ {
+ 	struct bcma_drv_pci_host *pc_host;
++	int readrq;
+ 
+ 	if (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {
+ 		/* This is not a device on the PCI-core bridge. */
+@@ -595,6 +596,11 @@ int bcma_core_pci_plat_dev_init(struct p
+ 	dev->irq = bcma_core_irq(pc_host->pdev->core);
+ 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
+ 
++	readrq = pcie_get_readrq(dev);
++	if (readrq > 128) {
++		pr_info("change PCIe max read request size from %i to 128\n", readrq);
++		pcie_set_readrq(dev, 128);
++	}
+ 	return 0;
+ }
+ EXPORT_SYMBOL(bcma_core_pci_plat_dev_init);
+--- a/drivers/bcma/scan.c
++++ b/drivers/bcma/scan.c
+@@ -32,6 +32,18 @@ static const struct bcma_device_id_name
+ 	{ BCMA_CORE_4706_CHIPCOMMON, "BCM4706 ChipCommon" },
+ 	{ BCMA_CORE_4706_SOC_RAM, "BCM4706 SOC RAM" },
+ 	{ BCMA_CORE_4706_MAC_GBIT, "BCM4706 GBit MAC" },
++	{ BCMA_CORE_PCIEG2, "PCIe Gen 2" },
++	{ BCMA_CORE_DMA, "DMA" },
++	{ BCMA_CORE_SDIO3, "SDIO3" },
++	{ BCMA_CORE_USB20, "USB 2.0" },
++	{ BCMA_CORE_USB30, "USB 3.0" },
++	{ BCMA_CORE_A9JTAG, "ARM Cortex A9 JTAG" },
++	{ BCMA_CORE_DDR23, "Denali DDR2/DDR3 memory controller" },
++	{ BCMA_CORE_ROM, "ROM" },
++	{ BCMA_CORE_NAND, "NAND flash controller" },
++	{ BCMA_CORE_QSPI, "SPI flash controller" },
++	{ BCMA_CORE_CHIPCOMMON_B, "Chipcommon B" },
++	{ BCMA_CORE_ARMCA9, "ARM Cortex A9 core (ihost)" },
+ 	{ BCMA_CORE_AMEMC, "AMEMC (DDR)" },
+ 	{ BCMA_CORE_ALTA, "ALTA (I2S)" },
+ 	{ BCMA_CORE_INVALID, "Invalid" },
+@@ -201,7 +213,7 @@ static s32 bcma_erom_get_mst_port(struct
+ 	return ent;
+ }
+ 
+-static s32 bcma_erom_get_addr_desc(struct bcma_bus *bus, u32 __iomem **eromptr,
++static u32 bcma_erom_get_addr_desc(struct bcma_bus *bus, u32 __iomem **eromptr,
+ 				  u32 type, u8 port)
+ {
+ 	u32 addrl, addrh, sizel, sizeh = 0;
+@@ -213,7 +225,7 @@ static s32 bcma_erom_get_addr_desc(struc
+ 	    ((ent & SCAN_ADDR_TYPE) != type) ||
+ 	    (((ent & SCAN_ADDR_PORT) >> SCAN_ADDR_PORT_SHIFT) != port)) {
+ 		bcma_erom_push_ent(eromptr);
+-		return -EINVAL;
++		return (u32)-EINVAL;
+ 	}
+ 
+ 	addrl = ent & SCAN_ADDR_ADDR;
+@@ -257,11 +269,13 @@ static struct bcma_device *bcma_find_cor
+ 	return NULL;
+ }
+ 
++#define IS_ERR_VALUE_U32(x) ((x) >= (u32)-MAX_ERRNO)
++
+ static int bcma_get_next_core(struct bcma_bus *bus, u32 __iomem **eromptr,
+ 			      struct bcma_device_id *match, int core_num,
+ 			      struct bcma_device *core)
+ {
+-	s32 tmp;
++	u32 tmp;
+ 	u8 i, j;
+ 	s32 cia, cib;
+ 	u8 ports[2], wrappers[2];
+@@ -339,11 +353,11 @@ static int bcma_get_next_core(struct bcm
+ 	 * the main register space for the core
+ 	 */
+ 	tmp = bcma_erom_get_addr_desc(bus, eromptr, SCAN_ADDR_TYPE_SLAVE, 0);
+-	if (tmp <= 0) {
++	if (tmp == 0 || IS_ERR_VALUE_U32(tmp)) {
+ 		/* Try again to see if it is a bridge */
+ 		tmp = bcma_erom_get_addr_desc(bus, eromptr,
+ 					      SCAN_ADDR_TYPE_BRIDGE, 0);
+-		if (tmp <= 0) {
++		if (tmp == 0 || IS_ERR_VALUE_U32(tmp)) {
+ 			return -EILSEQ;
+ 		} else {
+ 			bcma_info(bus, "Bridge found\n");
+@@ -357,7 +371,7 @@ static int bcma_get_next_core(struct bcm
+ 		for (j = 0; ; j++) {
+ 			tmp = bcma_erom_get_addr_desc(bus, eromptr,
+ 				SCAN_ADDR_TYPE_SLAVE, i);
+-			if (tmp < 0) {
++			if (IS_ERR_VALUE_U32(tmp)) {
+ 				/* no more entries for port _i_ */
+ 				/* pr_debug("erom: slave port %d "
+ 				 * "has %d descriptors\n", i, j); */
+@@ -374,7 +388,7 @@ static int bcma_get_next_core(struct bcm
+ 		for (j = 0; ; j++) {
+ 			tmp = bcma_erom_get_addr_desc(bus, eromptr,
+ 				SCAN_ADDR_TYPE_MWRAP, i);
+-			if (tmp < 0) {
++			if (IS_ERR_VALUE_U32(tmp)) {
+ 				/* no more entries for port _i_ */
+ 				/* pr_debug("erom: master wrapper %d "
+ 				 * "has %d descriptors\n", i, j); */
+@@ -392,7 +406,7 @@ static int bcma_get_next_core(struct bcm
+ 		for (j = 0; ; j++) {
+ 			tmp = bcma_erom_get_addr_desc(bus, eromptr,
+ 				SCAN_ADDR_TYPE_SWRAP, i + hack);
+-			if (tmp < 0) {
++			if (IS_ERR_VALUE_U32(tmp)) {
+ 				/* no more entries for port _i_ */
+ 				/* pr_debug("erom: master wrapper %d "
+ 				 * has %d descriptors\n", i, j); */
+--- a/include/linux/bcma/bcma_driver_pci.h
++++ b/include/linux/bcma/bcma_driver_pci.h
+@@ -181,10 +181,31 @@ struct pci_dev;
+ 
+ #define BCMA_CORE_PCI_CFG_DEVCTRL		0xd8
+ 
++#define BCMA_CORE_PCI_
++
++/* MDIO devices (SERDES modules) */
++#define BCMA_CORE_PCI_MDIO_IEEE0		0x000
++#define BCMA_CORE_PCI_MDIO_IEEE1		0x001
++#define BCMA_CORE_PCI_MDIO_BLK0			0x800
++#define BCMA_CORE_PCI_MDIO_BLK1			0x801
++#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT0		0x16
++#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT1		0x17
++#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT2		0x18
++#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT3		0x19
++#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT4		0x1A
++#define BCMA_CORE_PCI_MDIO_BLK2			0x802
++#define BCMA_CORE_PCI_MDIO_BLK3			0x803
++#define BCMA_CORE_PCI_MDIO_BLK4			0x804
++#define BCMA_CORE_PCI_MDIO_TXPLL		0x808	/* TXPLL register block idx */
++#define BCMA_CORE_PCI_MDIO_TXCTRL0		0x820
++#define BCMA_CORE_PCI_MDIO_SERDESID		0x831
++#define BCMA_CORE_PCI_MDIO_RXCTRL0		0x840
++
+ /* PCIE Root Capability Register bits (Host mode only) */
+ #define BCMA_CORE_PCI_RC_CRS_VISIBILITY		0x0001
+ 
+ struct bcma_drv_pci;
++struct bcma_bus;
+ 
+ #ifdef CONFIG_BCMA_DRIVER_PCI_HOSTMODE
+ struct bcma_drv_pci_host {
+@@ -219,7 +240,8 @@ struct bcma_drv_pci {
+ extern void bcma_core_pci_init(struct bcma_drv_pci *pc);
+ extern int bcma_core_pci_irq_ctl(struct bcma_drv_pci *pc,
+ 				 struct bcma_device *core, bool enable);
+-extern void bcma_core_pci_extend_L1timer(struct bcma_drv_pci *pc, bool extend);
++extern void bcma_core_pci_up(struct bcma_bus *bus);
++extern void bcma_core_pci_down(struct bcma_bus *bus);
+ 
+ extern int bcma_core_pci_pcibios_map_irq(const struct pci_dev *dev);
+ extern int bcma_core_pci_plat_dev_init(struct pci_dev *dev);
+--- a/drivers/net/wireless/brcm80211/brcmsmac/aiutils.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/aiutils.c
+@@ -679,27 +679,6 @@ bool ai_clkctl_cc(struct si_pub *sih, en
+ 	return mode == BCMA_CLKMODE_FAST;
+ }
+ 
+-void ai_pci_up(struct si_pub *sih)
+-{
+-	struct si_info *sii;
+-
+-	sii = container_of(sih, struct si_info, pub);
+-
+-	if (sii->icbus->hosttype == BCMA_HOSTTYPE_PCI)
+-		bcma_core_pci_extend_L1timer(&sii->icbus->drv_pci[0], true);
+-}
+-
+-/* Unconfigure and/or apply various WARs when going down */
+-void ai_pci_down(struct si_pub *sih)
+-{
+-	struct si_info *sii;
+-
+-	sii = container_of(sih, struct si_info, pub);
+-
+-	if (sii->icbus->hosttype == BCMA_HOSTTYPE_PCI)
+-		bcma_core_pci_extend_L1timer(&sii->icbus->drv_pci[0], false);
+-}
+-
+ /* Enable BT-COEX & Ex-PA for 4313 */
+ void ai_epa_4313war(struct si_pub *sih)
+ {
+--- a/drivers/net/wireless/brcm80211/brcmsmac/aiutils.h
++++ b/drivers/net/wireless/brcm80211/brcmsmac/aiutils.h
+@@ -183,9 +183,6 @@ extern u16 ai_clkctl_fast_pwrup_delay(st
+ extern bool ai_clkctl_cc(struct si_pub *sih, enum bcma_clkmode mode);
+ extern bool ai_deviceremoved(struct si_pub *sih);
+ 
+-extern void ai_pci_down(struct si_pub *sih);
+-extern void ai_pci_up(struct si_pub *sih);
+-
+ /* Enable Ex-PA for 4313 */
+ extern void ai_epa_4313war(struct si_pub *sih);
+ 
+--- a/drivers/net/wireless/brcm80211/brcmsmac/main.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/main.c
+@@ -4667,7 +4667,7 @@ static int brcms_b_attach(struct brcms_c
+ 	brcms_c_coredisable(wlc_hw);
+ 
+ 	/* Match driver "down" state */
+-	ai_pci_down(wlc_hw->sih);
++	bcma_core_pci_down(wlc_hw->d11core->bus);
+ 
+ 	/* turn off pll and xtal to match driver "down" state */
+ 	brcms_b_xtal(wlc_hw, OFF);
+@@ -5010,12 +5010,12 @@ static int brcms_b_up_prep(struct brcms_
+ 	 */
+ 	if (brcms_b_radio_read_hwdisabled(wlc_hw)) {
+ 		/* put SB PCI in down state again */
+-		ai_pci_down(wlc_hw->sih);
++		bcma_core_pci_down(wlc_hw->d11core->bus);
+ 		brcms_b_xtal(wlc_hw, OFF);
+ 		return -ENOMEDIUM;
+ 	}
+ 
+-	ai_pci_up(wlc_hw->sih);
++	bcma_core_pci_up(wlc_hw->d11core->bus);
+ 
+ 	/* reset the d11 core */
+ 	brcms_b_corereset(wlc_hw, BRCMS_USE_COREFLAGS);
+@@ -5212,7 +5212,7 @@ static int brcms_b_down_finish(struct br
+ 
+ 		/* turn off primary xtal and pll */
+ 		if (!wlc_hw->noreset) {
+-			ai_pci_down(wlc_hw->sih);
++			bcma_core_pci_down(wlc_hw->d11core->bus);
+ 			brcms_b_xtal(wlc_hw, OFF);
+ 		}
+ 	}
diff --git a/target/linux/generic/patches-3.10/060-hso_devices.patch b/target/linux/generic/patches-3.10/060-hso_devices.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/060-hso_devices.patch
@@ -0,0 +1,40 @@
+Index: kernel_tree/drivers/net/usb/hso.c
+===================================================================
+--- kernel_tree.orig/drivers/net/usb/hso.c
++++ kernel_tree/drivers/net/usb/hso.c
+@@ -468,8 +468,10 @@ static const struct usb_device_id hso_id
+ 	{USB_DEVICE(0x0af0, 0x8400)},
+ 	{USB_DEVICE(0x0af0, 0x8600)},
+ 	{USB_DEVICE(0x0af0, 0x8800)},
+-	{USB_DEVICE(0x0af0, 0x8900)},
+-	{USB_DEVICE(0x0af0, 0x9000)},
++	{USB_DEVICE(0x0af0, 0x8900)},  /* GTM 67xx */
++	{USB_DEVICE(0x0af0, 0x9000)},  /* GTM 66xx */
++	{USB_DEVICE(0x0af0, 0x9200)},  /* GTM 67xxWFS */
++	{USB_DEVICE(0x0af0, 0x9300)},  /* GTM 66xxWFS */
+ 	{USB_DEVICE(0x0af0, 0xd035)},
+ 	{USB_DEVICE(0x0af0, 0xd055)},
+ 	{USB_DEVICE(0x0af0, 0xd155)},
+Index: kernel_tree/drivers/usb/storage/unusual_devs.h
+===================================================================
+--- kernel_tree.orig/drivers/usb/storage/unusual_devs.h
++++ kernel_tree/drivers/usb/storage/unusual_devs.h
+@@ -1311,6 +1311,18 @@ UNUSUAL_DEV( 0x0af0, 0x8304, 0x0000, 0x0
+ 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+ 		0 ),
+ 
++UNUSUAL_DEV( 0x0af0, 0x9200, 0x0000, 0x0000,
++		"Option",
++		"Globetrotter 67xxWFS SD-Card",
++		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
++		0 ),
++
++UNUSUAL_DEV( 0x0af0, 0x9300, 0x0000, 0x0000,
++		"Option",
++		"Globetrotter 66xxWFS SD-Card",
++		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
++		0 ),
++
+ UNUSUAL_DEV( 0x0af0, 0xc100, 0x0000, 0x0000,
+ 		"Option",
+ 		"GI 070x SD-Card",
diff --git a/target/linux/generic/patches-3.10/061-arm_xz_decompressor_build_fix.patch b/target/linux/generic/patches-3.10/061-arm_xz_decompressor_build_fix.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/061-arm_xz_decompressor_build_fix.patch
@@ -0,0 +1,10 @@
+--- a/arch/arm/boot/compressed/decompress.c
++++ b/arch/arm/boot/compressed/decompress.c
+@@ -48,6 +48,7 @@ extern char * strstr(const char * s1, co
+ #ifdef CONFIG_KERNEL_XZ
+ #define memmove memmove
+ #define memcpy memcpy
++extern char * strstr(const char *, const char *);
+ #include "../../../../lib/decompress_unxz.c"
+ #endif
+ 
diff --git a/target/linux/generic/patches-3.10/062-mips_decompressor_build_fix.patch b/target/linux/generic/patches-3.10/062-mips_decompressor_build_fix.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/062-mips_decompressor_build_fix.patch
@@ -0,0 +1,68 @@
+From 0db3db45f5bd6df4bdc03bbd5dec672e16164c4e Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <florian@openwrt.org>
+Date: Mon, 12 Nov 2012 12:31:55 +0100
+Subject: [PATCH] MIPS: decompressor: fix build failure on memcpy() in
+ decompress.c
+
+The decompress.c file includes linux/kernel.h which causes the following
+inclusion chain to be pulled:
+linux/kernel.h ->
+	linux/dynamic_debug.h ->
+		linux/string.h ->
+			asm/string.h
+
+We end up having a the GCC builtin + architecture specific memcpy() expanding
+into this:
+
+void *({ size_t __len = (size_t n); void *__ret; if
+(__builtin_constant_p(size_t n) && __len >= 64) __ret = memcpy((void *dest),
+(const void *src), __len); else __ret = __builtin_memcpy((void *dest), (const
+void *src), __len); __ret; })
+{
+ [memcpy implementation in decompress.c starts here]
+ int i;
+ const char *s = src;
+ char *d = dest;
+
+ for (i = 0; i < n; i++)
+  d[i] = s[i];
+ return dest;
+}
+
+raising the following compilation error:
+arch/mips/boot/compressed/decompress.c:46:8: error: expected identifier or '('
+before '{' token
+
+There are at least three possibilities to fix this issue:
+
+1) define _LINUX_STRING_H_ at the beginning of decompress.c to prevent
+   further linux/string.h definitions and declarations from being used, and add
+   an explicit strstr() declaration for linux/dynamic_debug.h
+
+2) remove the inclusion of linux/kernel.h because we actually use no definition
+   or declaration from this header file
+
+3) undefine memcpy or re-define memcpy to memcpy thus resulting in picking up
+   the local memcpy() implementation to this compilation unit
+
+This patch uses the second option which is the less intrusive one.
+
+Signed-off-by: Florian Fainelli <florian@openwrt.org>
+---
+ arch/mips/boot/compressed/decompress.c |    2 --
+ 1 file changed, 2 deletions(-)
+
+--- a/arch/mips/boot/compressed/decompress.c
++++ b/arch/mips/boot/compressed/decompress.c
+@@ -10,11 +10,7 @@
+  * Free Software Foundation;  either version 2 of the  License, or (at your
+  * option) any later version.
+  */
+-
+ #include <linux/types.h>
+-#include <linux/kernel.h>
+-#include <linux/string.h>
+-
+ #include <asm/addrspace.h>
+ 
+ /*
diff --git a/target/linux/generic/patches-3.10/100-overlayfs.patch b/target/linux/generic/patches-3.10/100-overlayfs.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/100-overlayfs.patch
@@ -0,0 +1,3276 @@
+Index: kernel_tree/Documentation/filesystems/Locking
+===================================================================
+--- kernel_tree.orig/Documentation/filesystems/Locking
++++ kernel_tree/Documentation/filesystems/Locking
+@@ -66,6 +66,7 @@ prototypes:
+ 	int (*atomic_open)(struct inode *, struct dentry *,
+ 				struct file *, unsigned open_flag,
+ 				umode_t create_mode, int *opened);
++	int (*dentry_open)(struct dentry *, struct file *, const struct cred *);
+ 
+ locking rules:
+ 	all may block
+@@ -93,6 +94,7 @@ removexattr:	yes
+ fiemap:		no
+ update_time:	no
+ atomic_open:	yes
++dentry_open:	no
+ 
+ 	Additionally, ->rmdir(), ->unlink() and ->rename() have ->i_mutex on
+ victim.
+Index: kernel_tree/Documentation/filesystems/overlayfs.txt
+===================================================================
+--- /dev/null
++++ kernel_tree/Documentation/filesystems/overlayfs.txt
+@@ -0,0 +1,199 @@
++Written by: Neil Brown <neilb@suse.de>
++
++Overlay Filesystem
++==================
++
++This document describes a prototype for a new approach to providing
++overlay-filesystem functionality in Linux (sometimes referred to as
++union-filesystems).  An overlay-filesystem tries to present a
++filesystem which is the result over overlaying one filesystem on top
++of the other.
++
++The result will inevitably fail to look exactly like a normal
++filesystem for various technical reasons.  The expectation is that
++many use cases will be able to ignore these differences.
++
++This approach is 'hybrid' because the objects that appear in the
++filesystem do not all appear to belong to that filesystem.  In many
++cases an object accessed in the union will be indistinguishable
++from accessing the corresponding object from the original filesystem.
++This is most obvious from the 'st_dev' field returned by stat(2).
++
++While directories will report an st_dev from the overlay-filesystem,
++all non-directory objects will report an st_dev from the lower or
++upper filesystem that is providing the object.  Similarly st_ino will
++only be unique when combined with st_dev, and both of these can change
++over the lifetime of a non-directory object.  Many applications and
++tools ignore these values and will not be affected.
++
++Upper and Lower
++---------------
++
++An overlay filesystem combines two filesystems - an 'upper' filesystem
++and a 'lower' filesystem.  When a name exists in both filesystems, the
++object in the 'upper' filesystem is visible while the object in the
++'lower' filesystem is either hidden or, in the case of directories,
++merged with the 'upper' object.
++
++It would be more correct to refer to an upper and lower 'directory
++tree' rather than 'filesystem' as it is quite possible for both
++directory trees to be in the same filesystem and there is no
++requirement that the root of a filesystem be given for either upper or
++lower.
++
++The lower filesystem can be any filesystem supported by Linux and does
++not need to be writable.  The lower filesystem can even be another
++overlayfs.  The upper filesystem will normally be writable and if it
++is it must support the creation of trusted.* extended attributes, and
++must provide valid d_type in readdir responses, at least for symbolic
++links - so NFS is not suitable.
++
++A read-only overlay of two read-only filesystems may use any
++filesystem type.
++
++Directories
++-----------
++
++Overlaying mainly involves directories.  If a given name appears in both
++upper and lower filesystems and refers to a non-directory in either,
++then the lower object is hidden - the name refers only to the upper
++object.
++
++Where both upper and lower objects are directories, a merged directory
++is formed.
++
++At mount time, the two directories given as mount options are combined
++into a merged directory:
++
++  mount -t overlayfs overlayfs -olowerdir=/lower,upperdir=/upper /overlay
++
++Then whenever a lookup is requested in such a merged directory, the
++lookup is performed in each actual directory and the combined result
++is cached in the dentry belonging to the overlay filesystem.  If both
++actual lookups find directories, both are stored and a merged
++directory is created, otherwise only one is stored: the upper if it
++exists, else the lower.
++
++Only the lists of names from directories are merged.  Other content
++such as metadata and extended attributes are reported for the upper
++directory only.  These attributes of the lower directory are hidden.
++
++whiteouts and opaque directories
++--------------------------------
++
++In order to support rm and rmdir without changing the lower
++filesystem, an overlay filesystem needs to record in the upper filesystem
++that files have been removed.  This is done using whiteouts and opaque
++directories (non-directories are always opaque).
++
++The overlay filesystem uses extended attributes with a
++"trusted.overlay."  prefix to record these details.
++
++A whiteout is created as a symbolic link with target
++"(overlay-whiteout)" and with xattr "trusted.overlay.whiteout" set to "y".
++When a whiteout is found in the upper level of a merged directory, any
++matching name in the lower level is ignored, and the whiteout itself
++is also hidden.
++
++A directory is made opaque by setting the xattr "trusted.overlay.opaque"
++to "y".  Where the upper filesystem contains an opaque directory, any
++directory in the lower filesystem with the same name is ignored.
++
++readdir
++-------
++
++When a 'readdir' request is made on a merged directory, the upper and
++lower directories are each read and the name lists merged in the
++obvious way (upper is read first, then lower - entries that already
++exist are not re-added).  This merged name list is cached in the
++'struct file' and so remains as long as the file is kept open.  If the
++directory is opened and read by two processes at the same time, they
++will each have separate caches.  A seekdir to the start of the
++directory (offset 0) followed by a readdir will cause the cache to be
++discarded and rebuilt.
++
++This means that changes to the merged directory do not appear while a
++directory is being read.  This is unlikely to be noticed by many
++programs.
++
++seek offsets are assigned sequentially when the directories are read.
++Thus if
++  - read part of a directory
++  - remember an offset, and close the directory
++  - re-open the directory some time later
++  - seek to the remembered offset
++
++there may be little correlation between the old and new locations in
++the list of filenames, particularly if anything has changed in the
++directory.
++
++Readdir on directories that are not merged is simply handled by the
++underlying directory (upper or lower).
++
++
++Non-directories
++---------------
++
++Objects that are not directories (files, symlinks, device-special
++files etc.) are presented either from the upper or lower filesystem as
++appropriate.  When a file in the lower filesystem is accessed in a way
++the requires write-access, such as opening for write access, changing
++some metadata etc., the file is first copied from the lower filesystem
++to the upper filesystem (copy_up).  Note that creating a hard-link
++also requires copy_up, though of course creation of a symlink does
++not.
++
++The copy_up may turn out to be unnecessary, for example if the file is
++opened for read-write but the data is not modified.
++
++The copy_up process first makes sure that the containing directory
++exists in the upper filesystem - creating it and any parents as
++necessary.  It then creates the object with the same metadata (owner,
++mode, mtime, symlink-target etc.) and then if the object is a file, the
++data is copied from the lower to the upper filesystem.  Finally any
++extended attributes are copied up.
++
++Once the copy_up is complete, the overlay filesystem simply
++provides direct access to the newly created file in the upper
++filesystem - future operations on the file are barely noticed by the
++overlay filesystem (though an operation on the name of the file such as
++rename or unlink will of course be noticed and handled).
++
++
++Non-standard behavior
++---------------------
++
++The copy_up operation essentially creates a new, identical file and
++moves it over to the old name.  The new file may be on a different
++filesystem, so both st_dev and st_ino of the file may change.
++
++Any open files referring to this inode will access the old data and
++metadata.  Similarly any file locks obtained before copy_up will not
++apply to the copied up file.
++
++On a file opened with O_RDONLY fchmod(2), fchown(2), futimesat(2) and
++fsetxattr(2) will fail with EROFS.
++
++If a file with multiple hard links is copied up, then this will
++"break" the link.  Changes will not be propagated to other names
++referring to the same inode.
++
++Symlinks in /proc/PID/ and /proc/PID/fd which point to a non-directory
++object in overlayfs will not contain valid absolute paths, only
++relative paths leading up to the filesystem's root.  This will be
++fixed in the future.
++
++Some operations are not atomic, for example a crash during copy_up or
++rename will leave the filesystem in an inconsistent state.  This will
++be addressed in the future.
++
++Changes to underlying filesystems
++---------------------------------
++
++Offline changes, when the overlay is not mounted, are allowed to either
++the upper or the lower trees.
++
++Changes to the underlying filesystems while part of a mounted overlay
++filesystem are not allowed.  If the underlying filesystem is changed,
++the behavior of the overlay is undefined, though it will not result in
++a crash or deadlock.
+Index: kernel_tree/Documentation/filesystems/vfs.txt
+===================================================================
+--- kernel_tree.orig/Documentation/filesystems/vfs.txt
++++ kernel_tree/Documentation/filesystems/vfs.txt
+@@ -362,6 +362,7 @@ struct inode_operations {
+ 	int (*atomic_open)(struct inode *, struct dentry *,
+ 				struct file *, unsigned open_flag,
+ 				umode_t create_mode, int *opened);
++	int (*dentry_open)(struct dentry *, struct file *, const struct cred *);
+ };
+ 
+ Again, all methods are called without any locks being held, unless
+@@ -681,6 +682,12 @@ struct address_space_operations {
+   	but instead uses bmap to find out where the blocks in the file
+   	are and uses those addresses directly.
+ 
++  dentry_open: this is an alternative to f_op->open(), the difference is that
++	this method may open a file not necessarily originating from the same
++	filesystem as the one i_op->open() was called on.  It may be
++	useful for stacking filesystems which want to allow native I/O directly
++	on underlying files.
++
+ 
+   invalidatepage: If a page has PagePrivate set, then invalidatepage
+         will be called when part or all of the page is to be removed
+Index: kernel_tree/MAINTAINERS
+===================================================================
+--- kernel_tree.orig/MAINTAINERS
++++ kernel_tree/MAINTAINERS
+@@ -6019,6 +6019,13 @@ F:	drivers/scsi/osd/
+ F:	include/scsi/osd_*
+ F:	fs/exofs/
+ 
++OVERLAYFS FILESYSTEM
++M:	Miklos Szeredi <miklos@szeredi.hu>
++L:	linux-fsdevel@vger.kernel.org
++S:	Supported
++F:	fs/overlayfs/*
++F:	Documentation/filesystems/overlayfs.txt
++
+ P54 WIRELESS DRIVER
+ M:	Christian Lamparter <chunkeey@googlemail.com>
+ L:	linux-wireless@vger.kernel.org
+Index: kernel_tree/fs/Kconfig
+===================================================================
+--- kernel_tree.orig/fs/Kconfig
++++ kernel_tree/fs/Kconfig
+@@ -67,6 +67,7 @@ source "fs/quota/Kconfig"
+ 
+ source "fs/autofs4/Kconfig"
+ source "fs/fuse/Kconfig"
++source "fs/overlayfs/Kconfig"
+ 
+ config GENERIC_ACL
+ 	bool
+Index: kernel_tree/fs/Makefile
+===================================================================
+--- kernel_tree.orig/fs/Makefile
++++ kernel_tree/fs/Makefile
+@@ -105,6 +105,7 @@ obj-$(CONFIG_QNX6FS_FS)		+= qnx6/
+ obj-$(CONFIG_AUTOFS4_FS)	+= autofs4/
+ obj-$(CONFIG_ADFS_FS)		+= adfs/
+ obj-$(CONFIG_FUSE_FS)		+= fuse/
++obj-$(CONFIG_OVERLAYFS_FS)	+= overlayfs/
+ obj-$(CONFIG_UDF_FS)		+= udf/
+ obj-$(CONFIG_SUN_OPENPROMFS)	+= openpromfs/
+ obj-$(CONFIG_OMFS_FS)		+= omfs/
+Index: kernel_tree/fs/ecryptfs/main.c
+===================================================================
+--- kernel_tree.orig/fs/ecryptfs/main.c
++++ kernel_tree/fs/ecryptfs/main.c
+@@ -577,6 +577,13 @@ static struct dentry *ecryptfs_mount(str
+ 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
+ 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
+ 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
++	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;
++
++	rc = -EINVAL;
++	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
++		pr_err("eCryptfs: maximum fs stacking depth exceeded\n");
++		goto out_free;
++	}
+ 
+ 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
+ 	rc = PTR_ERR(inode);
+Index: kernel_tree/fs/internal.h
+===================================================================
+--- kernel_tree.orig/fs/internal.h
++++ kernel_tree/fs/internal.h
+@@ -42,11 +42,6 @@ static inline int __sync_blockdev(struct
+ extern void __init chrdev_init(void);
+ 
+ /*
+- * namei.c
+- */
+-extern int __inode_permission(struct inode *, int);
+-
+-/*
+  * namespace.c
+  */
+ extern int copy_mount_options(const void __user *, unsigned long *);
+@@ -129,12 +124,6 @@ extern struct dentry *__d_alloc(struct s
+ extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
+ 
+ /*
+- * splice.c
+- */
+-extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
+-		loff_t *opos, size_t len, unsigned int flags);
+-
+-/*
+  * pipe.c
+  */
+ extern const struct file_operations pipefifo_fops;
+Index: kernel_tree/fs/namei.c
+===================================================================
+--- kernel_tree.orig/fs/namei.c
++++ kernel_tree/fs/namei.c
+@@ -404,6 +404,7 @@ int __inode_permission(struct inode *ino
+ 
+ 	return security_inode_permission(inode, mask);
+ }
++EXPORT_SYMBOL(__inode_permission);
+ 
+ /**
+  * sb_permission - Check superblock-level permissions
+@@ -2896,9 +2897,12 @@ finish_open_created:
+ 	error = may_open(&nd->path, acc_mode, open_flag);
+ 	if (error)
+ 		goto out;
+-	file->f_path.mnt = nd->path.mnt;
+-	error = finish_open(file, nd->path.dentry, NULL, opened);
+-	if (error) {
++
++	BUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */
++	error = vfs_open(&nd->path, file, current_cred());
++	if (!error) {
++		*opened |= FILE_OPENED;
++	} else {
+ 		if (error == -EOPENSTALE)
+ 			goto stale_open;
+ 		goto out;
+Index: kernel_tree/fs/namespace.c
+===================================================================
+--- kernel_tree.orig/fs/namespace.c
++++ kernel_tree/fs/namespace.c
+@@ -1460,6 +1460,33 @@ void drop_collected_mounts(struct vfsmou
+ 	namespace_unlock();
+ }
+ 
++/**
++ * clone_private_mount - create a private clone of a path
++ *
++ * This creates a new vfsmount, which will be the clone of @path.  The new will
++ * not be attached anywhere in the namespace and will be private (i.e. changes
++ * to the originating mount won't be propagated into this).
++ *
++ * Release with mntput().
++ */
++struct vfsmount *clone_private_mount(struct path *path)
++{
++	struct mount *old_mnt = real_mount(path->mnt);
++	struct mount *new_mnt;
++
++	if (IS_MNT_UNBINDABLE(old_mnt))
++		return ERR_PTR(-EINVAL);
++
++	down_read(&namespace_sem);
++	new_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);
++	up_read(&namespace_sem);
++	if (IS_ERR(new_mnt))
++		return ERR_CAST(new_mnt);
++
++	return &new_mnt->mnt;
++}
++EXPORT_SYMBOL_GPL(clone_private_mount);
++
+ int iterate_mounts(int (*f)(struct vfsmount *, void *), void *arg,
+ 		   struct vfsmount *root)
+ {
+Index: kernel_tree/fs/open.c
+===================================================================
+--- kernel_tree.orig/fs/open.c
++++ kernel_tree/fs/open.c
+@@ -786,8 +786,7 @@ struct file *dentry_open(const struct pa
+ 	f = get_empty_filp();
+ 	if (!IS_ERR(f)) {
+ 		f->f_flags = flags;
+-		f->f_path = *path;
+-		error = do_dentry_open(f, NULL, cred);
++		error = vfs_open(path, f, cred);
+ 		if (!error) {
+ 			/* from now on we need fput() to dispose of f */
+ 			error = open_check_o_direct(f);
+@@ -804,6 +803,26 @@ struct file *dentry_open(const struct pa
+ }
+ EXPORT_SYMBOL(dentry_open);
+ 
++/**
++ * vfs_open - open the file at the given path
++ * @path: path to open
++ * @filp: newly allocated file with f_flag initialized
++ * @cred: credentials to use
++ */
++int vfs_open(const struct path *path, struct file *filp,
++	     const struct cred *cred)
++{
++	struct inode *inode = path->dentry->d_inode;
++
++	if (inode->i_op->dentry_open)
++		return inode->i_op->dentry_open(path->dentry, filp, cred);
++	else {
++		filp->f_path = *path;
++		return do_dentry_open(filp, NULL, cred);
++	}
++}
++EXPORT_SYMBOL(vfs_open);
++
+ static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)
+ {
+ 	int lookup_flags = 0;
+Index: kernel_tree/fs/overlayfs/Kconfig
+===================================================================
+--- /dev/null
++++ kernel_tree/fs/overlayfs/Kconfig
+@@ -0,0 +1,10 @@
++config OVERLAYFS_FS
++	tristate "Overlay filesystem support"
++	help
++	  An overlay filesystem combines two filesystems - an 'upper' filesystem
++	  and a 'lower' filesystem.  When a name exists in both filesystems, the
++	  object in the 'upper' filesystem is visible while the object in the
++	  'lower' filesystem is either hidden or, in the case of directories,
++	  merged with the 'upper' object.
++
++	  For more information see Documentation/filesystems/overlayfs.txt
+Index: kernel_tree/fs/overlayfs/Makefile
+===================================================================
+--- /dev/null
++++ kernel_tree/fs/overlayfs/Makefile
+@@ -0,0 +1,7 @@
++#
++# Makefile for the overlay filesystem.
++#
++
++obj-$(CONFIG_OVERLAYFS_FS) += overlayfs.o
++
++overlayfs-objs := super.o inode.o dir.o readdir.o copy_up.o
+Index: kernel_tree/fs/overlayfs/copy_up.c
+===================================================================
+--- /dev/null
++++ kernel_tree/fs/overlayfs/copy_up.c
+@@ -0,0 +1,387 @@
++/*
++ *
++ * Copyright (C) 2011 Novell Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 as published by
++ * the Free Software Foundation.
++ */
++
++#include <linux/fs.h>
++#include <linux/slab.h>
++#include <linux/file.h>
++#include <linux/splice.h>
++#include <linux/xattr.h>
++#include <linux/security.h>
++#include <linux/uaccess.h>
++#include <linux/sched.h>
++#include "overlayfs.h"
++
++#define OVL_COPY_UP_CHUNK_SIZE (1 << 20)
++
++static int ovl_copy_up_xattr(struct dentry *old, struct dentry *new)
++{
++	ssize_t list_size, size;
++	char *buf, *name, *value;
++	int error;
++
++	if (!old->d_inode->i_op->getxattr ||
++	    !new->d_inode->i_op->getxattr)
++		return 0;
++
++	list_size = vfs_listxattr(old, NULL, 0);
++	if (list_size <= 0) {
++		if (list_size == -EOPNOTSUPP)
++			return 0;
++		return list_size;
++	}
++
++	buf = kzalloc(list_size, GFP_KERNEL);
++	if (!buf)
++		return -ENOMEM;
++
++	error = -ENOMEM;
++	value = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);
++	if (!value)
++		goto out;
++
++	list_size = vfs_listxattr(old, buf, list_size);
++	if (list_size <= 0) {
++		error = list_size;
++		goto out_free_value;
++	}
++
++	for (name = buf; name < (buf + list_size); name += strlen(name) + 1) {
++		size = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);
++		if (size <= 0) {
++			error = size;
++			goto out_free_value;
++		}
++		error = vfs_setxattr(new, name, value, size, 0);
++		if (error)
++			goto out_free_value;
++	}
++
++out_free_value:
++	kfree(value);
++out:
++	kfree(buf);
++	return error;
++}
++
++static int ovl_copy_up_data(struct path *old, struct path *new, loff_t len)
++{
++	struct file *old_file;
++	struct file *new_file;
++	loff_t old_pos = 0;
++	loff_t new_pos = 0;
++	int error = 0;
++
++	if (len == 0)
++		return 0;
++
++	old_file = ovl_path_open(old, O_RDONLY);
++	if (IS_ERR(old_file))
++		return PTR_ERR(old_file);
++
++	new_file = ovl_path_open(new, O_WRONLY);
++	if (IS_ERR(new_file)) {
++		error = PTR_ERR(new_file);
++		goto out_fput;
++	}
++
++	/* FIXME: copy up sparse files efficiently */
++	while (len) {
++		size_t this_len = OVL_COPY_UP_CHUNK_SIZE;
++		long bytes;
++
++		if (len < this_len)
++			this_len = len;
++
++		if (signal_pending_state(TASK_KILLABLE, current)) {
++			error = -EINTR;
++			break;
++		}
++
++		bytes = do_splice_direct(old_file, &old_pos,
++					 new_file, &new_pos,
++					 this_len, SPLICE_F_MOVE);
++		if (bytes <= 0) {
++			error = bytes;
++			break;
++		}
++
++		len -= bytes;
++	}
++
++	fput(new_file);
++out_fput:
++	fput(old_file);
++	return error;
++}
++
++static char *ovl_read_symlink(struct dentry *realdentry)
++{
++	int res;
++	char *buf;
++	struct inode *inode = realdentry->d_inode;
++	mm_segment_t old_fs;
++
++	res = -EINVAL;
++	if (!inode->i_op->readlink)
++		goto err;
++
++	res = -ENOMEM;
++	buf = (char *) __get_free_page(GFP_KERNEL);
++	if (!buf)
++		goto err;
++
++	old_fs = get_fs();
++	set_fs(get_ds());
++	/* The cast to a user pointer is valid due to the set_fs() */
++	res = inode->i_op->readlink(realdentry,
++				    (char __user *)buf, PAGE_SIZE - 1);
++	set_fs(old_fs);
++	if (res < 0) {
++		free_page((unsigned long) buf);
++		goto err;
++	}
++	buf[res] = '\0';
++
++	return buf;
++
++err:
++	return ERR_PTR(res);
++}
++
++static int ovl_set_timestamps(struct dentry *upperdentry, struct kstat *stat)
++{
++	struct iattr attr = {
++		.ia_valid =
++		     ATTR_ATIME | ATTR_MTIME | ATTR_ATIME_SET | ATTR_MTIME_SET,
++		.ia_atime = stat->atime,
++		.ia_mtime = stat->mtime,
++	};
++
++	return notify_change(upperdentry, &attr);
++}
++
++static int ovl_set_mode(struct dentry *upperdentry, umode_t mode)
++{
++	struct iattr attr = {
++		.ia_valid = ATTR_MODE,
++		.ia_mode = mode,
++	};
++
++	return notify_change(upperdentry, &attr);
++}
++
++static int ovl_copy_up_locked(struct dentry *upperdir, struct dentry *dentry,
++			      struct path *lowerpath, struct kstat *stat,
++			      const char *link)
++{
++	int err;
++	struct path newpath;
++	umode_t mode = stat->mode;
++
++	/* Can't properly set mode on creation because of the umask */
++	stat->mode &= S_IFMT;
++
++	ovl_path_upper(dentry, &newpath);
++	WARN_ON(newpath.dentry);
++	newpath.dentry = ovl_upper_create(upperdir, dentry, stat, link);
++	if (IS_ERR(newpath.dentry))
++		return PTR_ERR(newpath.dentry);
++
++	if (S_ISREG(stat->mode)) {
++		err = ovl_copy_up_data(lowerpath, &newpath, stat->size);
++		if (err)
++			goto err_remove;
++	}
++
++	err = ovl_copy_up_xattr(lowerpath->dentry, newpath.dentry);
++	if (err)
++		goto err_remove;
++
++	mutex_lock(&newpath.dentry->d_inode->i_mutex);
++	if (!S_ISLNK(stat->mode))
++		err = ovl_set_mode(newpath.dentry, mode);
++	if (!err)
++		err = ovl_set_timestamps(newpath.dentry, stat);
++	mutex_unlock(&newpath.dentry->d_inode->i_mutex);
++	if (err)
++		goto err_remove;
++
++	ovl_dentry_update(dentry, newpath.dentry);
++
++	/*
++	 * Easiest way to get rid of the lower dentry reference is to
++	 * drop this dentry.  This is neither needed nor possible for
++	 * directories.
++	 */
++	if (!S_ISDIR(stat->mode))
++		d_drop(dentry);
++
++	return 0;
++
++err_remove:
++	if (S_ISDIR(stat->mode))
++		vfs_rmdir(upperdir->d_inode, newpath.dentry);
++	else
++		vfs_unlink(upperdir->d_inode, newpath.dentry);
++
++	dput(newpath.dentry);
++
++	return err;
++}
++
++/*
++ * Copy up a single dentry
++ *
++ * Directory renames only allowed on "pure upper" (already created on
++ * upper filesystem, never copied up).  Directories which are on lower or
++ * are merged may not be renamed.  For these -EXDEV is returned and
++ * userspace has to deal with it.  This means, when copying up a
++ * directory we can rely on it and ancestors being stable.
++ *
++ * Non-directory renames start with copy up of source if necessary.  The
++ * actual rename will only proceed once the copy up was successful.  Copy
++ * up uses upper parent i_mutex for exclusion.  Since rename can change
++ * d_parent it is possible that the copy up will lock the old parent.  At
++ * that point the file will have already been copied up anyway.
++ */
++static int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,
++			   struct path *lowerpath, struct kstat *stat)
++{
++	int err;
++	struct kstat pstat;
++	struct path parentpath;
++	struct dentry *upperdir;
++	const struct cred *old_cred;
++	struct cred *override_cred;
++	char *link = NULL;
++
++	ovl_path_upper(parent, &parentpath);
++	upperdir = parentpath.dentry;
++
++	err = vfs_getattr(&parentpath, &pstat);
++	if (err)
++		return err;
++
++	if (S_ISLNK(stat->mode)) {
++		link = ovl_read_symlink(lowerpath->dentry);
++		if (IS_ERR(link))
++			return PTR_ERR(link);
++	}
++
++	err = -ENOMEM;
++	override_cred = prepare_creds();
++	if (!override_cred)
++		goto out_free_link;
++
++	override_cred->fsuid = stat->uid;
++	override_cred->fsgid = stat->gid;
++	/*
++	 * CAP_SYS_ADMIN for copying up extended attributes
++	 * CAP_DAC_OVERRIDE for create
++	 * CAP_FOWNER for chmod, timestamp update
++	 * CAP_FSETID for chmod
++	 * CAP_MKNOD for mknod
++	 */
++	cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
++	cap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);
++	cap_raise(override_cred->cap_effective, CAP_FOWNER);
++	cap_raise(override_cred->cap_effective, CAP_FSETID);
++	cap_raise(override_cred->cap_effective, CAP_MKNOD);
++	old_cred = override_creds(override_cred);
++
++	mutex_lock_nested(&upperdir->d_inode->i_mutex, I_MUTEX_PARENT);
++	if (ovl_path_type(dentry) != OVL_PATH_LOWER) {
++		err = 0;
++	} else {
++		err = ovl_copy_up_locked(upperdir, dentry, lowerpath,
++					 stat, link);
++		if (!err) {
++			/* Restore timestamps on parent (best effort) */
++			ovl_set_timestamps(upperdir, &pstat);
++		}
++	}
++
++	mutex_unlock(&upperdir->d_inode->i_mutex);
++
++	revert_creds(old_cred);
++	put_cred(override_cred);
++
++out_free_link:
++	if (link)
++		free_page((unsigned long) link);
++
++	return err;
++}
++
++int ovl_copy_up(struct dentry *dentry)
++{
++	int err;
++
++	err = 0;
++	while (!err) {
++		struct dentry *next;
++		struct dentry *parent;
++		struct path lowerpath;
++		struct kstat stat;
++		enum ovl_path_type type = ovl_path_type(dentry);
++
++		if (type != OVL_PATH_LOWER)
++			break;
++
++		next = dget(dentry);
++		/* find the topmost dentry not yet copied up */
++		for (;;) {
++			parent = dget_parent(next);
++
++			type = ovl_path_type(parent);
++			if (type != OVL_PATH_LOWER)
++				break;
++
++			dput(next);
++			next = parent;
++		}
++
++		ovl_path_lower(next, &lowerpath);
++		err = vfs_getattr(&lowerpath, &stat);
++		if (!err)
++			err = ovl_copy_up_one(parent, next, &lowerpath, &stat);
++
++		dput(parent);
++		dput(next);
++	}
++
++	return err;
++}
++
++/* Optimize by not copying up the file first and truncating later */
++int ovl_copy_up_truncate(struct dentry *dentry, loff_t size)
++{
++	int err;
++	struct kstat stat;
++	struct path lowerpath;
++	struct dentry *parent = dget_parent(dentry);
++
++	err = ovl_copy_up(parent);
++	if (err)
++		goto out_dput_parent;
++
++	ovl_path_lower(dentry, &lowerpath);
++	err = vfs_getattr(&lowerpath, &stat);
++	if (err)
++		goto out_dput_parent;
++
++	if (size < stat.size)
++		stat.size = size;
++
++	err = ovl_copy_up_one(parent, dentry, &lowerpath, &stat);
++
++out_dput_parent:
++	dput(parent);
++	return err;
++}
+Index: kernel_tree/fs/overlayfs/dir.c
+===================================================================
+--- /dev/null
++++ kernel_tree/fs/overlayfs/dir.c
+@@ -0,0 +1,605 @@
++/*
++ *
++ * Copyright (C) 2011 Novell Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 as published by
++ * the Free Software Foundation.
++ */
++
++#include <linux/fs.h>
++#include <linux/namei.h>
++#include <linux/xattr.h>
++#include <linux/security.h>
++#include <linux/cred.h>
++#include "overlayfs.h"
++
++static const char *ovl_whiteout_symlink = "(overlay-whiteout)";
++
++static int ovl_whiteout(struct dentry *upperdir, struct dentry *dentry)
++{
++	int err;
++	struct dentry *newdentry;
++	const struct cred *old_cred;
++	struct cred *override_cred;
++
++	/* FIXME: recheck lower dentry to see if whiteout is really needed */
++
++	err = -ENOMEM;
++	override_cred = prepare_creds();
++	if (!override_cred)
++		goto out;
++
++	/*
++	 * CAP_SYS_ADMIN for setxattr
++	 * CAP_DAC_OVERRIDE for symlink creation
++	 * CAP_FOWNER for unlink in sticky directory
++	 */
++	cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
++	cap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);
++	cap_raise(override_cred->cap_effective, CAP_FOWNER);
++	override_cred->fsuid = GLOBAL_ROOT_UID;
++	override_cred->fsgid = GLOBAL_ROOT_GID;
++	old_cred = override_creds(override_cred);
++
++	newdentry = lookup_one_len(dentry->d_name.name, upperdir,
++				   dentry->d_name.len);
++	err = PTR_ERR(newdentry);
++	if (IS_ERR(newdentry))
++		goto out_put_cred;
++
++	/* Just been removed within the same locked region */
++	WARN_ON(newdentry->d_inode);
++
++	err = vfs_symlink(upperdir->d_inode, newdentry, ovl_whiteout_symlink);
++	if (err)
++		goto out_dput;
++
++	ovl_dentry_version_inc(dentry->d_parent);
++
++	err = vfs_setxattr(newdentry, ovl_whiteout_xattr, "y", 1, 0);
++	if (err)
++		vfs_unlink(upperdir->d_inode, newdentry);
++
++out_dput:
++	dput(newdentry);
++out_put_cred:
++	revert_creds(old_cred);
++	put_cred(override_cred);
++out:
++	if (err) {
++		/*
++		 * There's no way to recover from failure to whiteout.
++		 * What should we do?  Log a big fat error and... ?
++		 */
++		pr_err("overlayfs: ERROR - failed to whiteout '%s'\n",
++		       dentry->d_name.name);
++	}
++
++	return err;
++}
++
++static struct dentry *ovl_lookup_create(struct dentry *upperdir,
++					struct dentry *template)
++{
++	int err;
++	struct dentry *newdentry;
++	struct qstr *name = &template->d_name;
++
++	newdentry = lookup_one_len(name->name, upperdir, name->len);
++	if (IS_ERR(newdentry))
++		return newdentry;
++
++	if (newdentry->d_inode) {
++		const struct cred *old_cred;
++		struct cred *override_cred;
++
++		/* No need to check whiteout if lower parent is non-existent */
++		err = -EEXIST;
++		if (!ovl_dentry_lower(template->d_parent))
++			goto out_dput;
++
++		if (!S_ISLNK(newdentry->d_inode->i_mode))
++			goto out_dput;
++
++		err = -ENOMEM;
++		override_cred = prepare_creds();
++		if (!override_cred)
++			goto out_dput;
++
++		/*
++		 * CAP_SYS_ADMIN for getxattr
++		 * CAP_FOWNER for unlink in sticky directory
++		 */
++		cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
++		cap_raise(override_cred->cap_effective, CAP_FOWNER);
++		old_cred = override_creds(override_cred);
++
++		err = -EEXIST;
++		if (ovl_is_whiteout(newdentry))
++			err = vfs_unlink(upperdir->d_inode, newdentry);
++
++		revert_creds(old_cred);
++		put_cred(override_cred);
++		if (err)
++			goto out_dput;
++
++		dput(newdentry);
++		newdentry = lookup_one_len(name->name, upperdir, name->len);
++		if (IS_ERR(newdentry)) {
++			ovl_whiteout(upperdir, template);
++			return newdentry;
++		}
++
++		/*
++		 * Whiteout just been successfully removed, parent
++		 * i_mutex is still held, there's no way the lookup
++		 * could return positive.
++		 */
++		WARN_ON(newdentry->d_inode);
++	}
++
++	return newdentry;
++
++out_dput:
++	dput(newdentry);
++	return ERR_PTR(err);
++}
++
++struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
++				struct kstat *stat, const char *link)
++{
++	int err;
++	struct dentry *newdentry;
++	struct inode *dir = upperdir->d_inode;
++
++	newdentry = ovl_lookup_create(upperdir, dentry);
++	if (IS_ERR(newdentry))
++		goto out;
++
++	switch (stat->mode & S_IFMT) {
++	case S_IFREG:
++		err = vfs_create(dir, newdentry, stat->mode, NULL);
++		break;
++
++	case S_IFDIR:
++		err = vfs_mkdir(dir, newdentry, stat->mode);
++		break;
++
++	case S_IFCHR:
++	case S_IFBLK:
++	case S_IFIFO:
++	case S_IFSOCK:
++		err = vfs_mknod(dir, newdentry, stat->mode, stat->rdev);
++		break;
++
++	case S_IFLNK:
++		err = vfs_symlink(dir, newdentry, link);
++		break;
++
++	default:
++		err = -EPERM;
++	}
++	if (err) {
++		if (ovl_dentry_is_opaque(dentry))
++			ovl_whiteout(upperdir, dentry);
++		dput(newdentry);
++		newdentry = ERR_PTR(err);
++	} else if (WARN_ON(!newdentry->d_inode)) {
++		/*
++		 * Not quite sure if non-instantiated dentry is legal or not.
++		 * VFS doesn't seem to care so check and warn here.
++		 */
++		dput(newdentry);
++		newdentry = ERR_PTR(-ENOENT);
++	}
++
++out:
++	return newdentry;
++
++}
++
++static int ovl_set_opaque(struct dentry *upperdentry)
++{
++	int err;
++	const struct cred *old_cred;
++	struct cred *override_cred;
++
++	override_cred = prepare_creds();
++	if (!override_cred)
++		return -ENOMEM;
++
++	/* CAP_SYS_ADMIN for setxattr of "trusted" namespace */
++	cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
++	old_cred = override_creds(override_cred);
++	err = vfs_setxattr(upperdentry, ovl_opaque_xattr, "y", 1, 0);
++	revert_creds(old_cred);
++	put_cred(override_cred);
++
++	return err;
++}
++
++static int ovl_remove_opaque(struct dentry *upperdentry)
++{
++	int err;
++	const struct cred *old_cred;
++	struct cred *override_cred;
++
++	override_cred = prepare_creds();
++	if (!override_cred)
++		return -ENOMEM;
++
++	/* CAP_SYS_ADMIN for removexattr of "trusted" namespace */
++	cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
++	old_cred = override_creds(override_cred);
++	err = vfs_removexattr(upperdentry, ovl_opaque_xattr);
++	revert_creds(old_cred);
++	put_cred(override_cred);
++
++	return err;
++}
++
++static int ovl_dir_getattr(struct vfsmount *mnt, struct dentry *dentry,
++			 struct kstat *stat)
++{
++	int err;
++	enum ovl_path_type type;
++	struct path realpath;
++
++	type = ovl_path_real(dentry, &realpath);
++	err = vfs_getattr(&realpath, stat);
++	if (err)
++		return err;
++
++	stat->dev = dentry->d_sb->s_dev;
++	stat->ino = dentry->d_inode->i_ino;
++
++	/*
++	 * It's probably not worth it to count subdirs to get the
++	 * correct link count.  nlink=1 seems to pacify 'find' and
++	 * other utilities.
++	 */
++	if (type == OVL_PATH_MERGE)
++		stat->nlink = 1;
++
++	return 0;
++}
++
++static int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,
++			     const char *link)
++{
++	int err;
++	struct dentry *newdentry;
++	struct dentry *upperdir;
++	struct inode *inode;
++	struct kstat stat = {
++		.mode = mode,
++		.rdev = rdev,
++	};
++
++	err = -ENOMEM;
++	inode = ovl_new_inode(dentry->d_sb, mode, dentry->d_fsdata);
++	if (!inode)
++		goto out;
++
++	err = ovl_copy_up(dentry->d_parent);
++	if (err)
++		goto out_iput;
++
++	upperdir = ovl_dentry_upper(dentry->d_parent);
++	mutex_lock_nested(&upperdir->d_inode->i_mutex, I_MUTEX_PARENT);
++
++	newdentry = ovl_upper_create(upperdir, dentry, &stat, link);
++	err = PTR_ERR(newdentry);
++	if (IS_ERR(newdentry))
++		goto out_unlock;
++
++	ovl_dentry_version_inc(dentry->d_parent);
++	if (ovl_dentry_is_opaque(dentry) && S_ISDIR(mode)) {
++		err = ovl_set_opaque(newdentry);
++		if (err) {
++			vfs_rmdir(upperdir->d_inode, newdentry);
++			ovl_whiteout(upperdir, dentry);
++			goto out_dput;
++		}
++	}
++	ovl_dentry_update(dentry, newdentry);
++	ovl_copyattr(newdentry->d_inode, inode);
++	d_instantiate(dentry, inode);
++	inode = NULL;
++	newdentry = NULL;
++	err = 0;
++
++out_dput:
++	dput(newdentry);
++out_unlock:
++	mutex_unlock(&upperdir->d_inode->i_mutex);
++out_iput:
++	iput(inode);
++out:
++	return err;
++}
++
++static int ovl_create(struct inode *dir, struct dentry *dentry, umode_t mode,
++		      bool excl)
++{
++	return ovl_create_object(dentry, (mode & 07777) | S_IFREG, 0, NULL);
++}
++
++static int ovl_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
++{
++	return ovl_create_object(dentry, (mode & 07777) | S_IFDIR, 0, NULL);
++}
++
++static int ovl_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,
++		     dev_t rdev)
++{
++	return ovl_create_object(dentry, mode, rdev, NULL);
++}
++
++static int ovl_symlink(struct inode *dir, struct dentry *dentry,
++			 const char *link)
++{
++	return ovl_create_object(dentry, S_IFLNK, 0, link);
++}
++
++static int ovl_do_remove(struct dentry *dentry, bool is_dir)
++{
++	int err;
++	enum ovl_path_type type;
++	struct path realpath;
++	struct dentry *upperdir;
++
++	err = ovl_copy_up(dentry->d_parent);
++	if (err)
++		return err;
++
++	upperdir = ovl_dentry_upper(dentry->d_parent);
++	mutex_lock_nested(&upperdir->d_inode->i_mutex, I_MUTEX_PARENT);
++	type = ovl_path_real(dentry, &realpath);
++	if (type != OVL_PATH_LOWER) {
++		err = -ESTALE;
++		if (realpath.dentry->d_parent != upperdir)
++			goto out_d_drop;
++
++		/* FIXME: create whiteout up front and rename to target */
++
++		if (is_dir)
++			err = vfs_rmdir(upperdir->d_inode, realpath.dentry);
++		else
++			err = vfs_unlink(upperdir->d_inode, realpath.dentry);
++		if (err)
++			goto out_d_drop;
++
++		ovl_dentry_version_inc(dentry->d_parent);
++	}
++
++	if (type != OVL_PATH_UPPER || ovl_dentry_is_opaque(dentry))
++		err = ovl_whiteout(upperdir, dentry);
++
++	/*
++	 * Keeping this dentry hashed would mean having to release
++	 * upperpath/lowerpath, which could only be done if we are the
++	 * sole user of this dentry.  Too tricky...  Just unhash for
++	 * now.
++	 */
++out_d_drop:
++	d_drop(dentry);
++	mutex_unlock(&upperdir->d_inode->i_mutex);
++
++	return err;
++}
++
++static int ovl_unlink(struct inode *dir, struct dentry *dentry)
++{
++	return ovl_do_remove(dentry, false);
++}
++
++
++static int ovl_rmdir(struct inode *dir, struct dentry *dentry)
++{
++	int err;
++	enum ovl_path_type type;
++
++	type = ovl_path_type(dentry);
++	if (type != OVL_PATH_UPPER) {
++		err = ovl_check_empty_and_clear(dentry, type);
++		if (err)
++			return err;
++	}
++
++	return ovl_do_remove(dentry, true);
++}
++
++static int ovl_link(struct dentry *old, struct inode *newdir,
++		    struct dentry *new)
++{
++	int err;
++	struct dentry *olddentry;
++	struct dentry *newdentry;
++	struct dentry *upperdir;
++	struct inode *newinode;
++
++	err = ovl_copy_up(old);
++	if (err)
++		goto out;
++
++	err = ovl_copy_up(new->d_parent);
++	if (err)
++		goto out;
++
++	upperdir = ovl_dentry_upper(new->d_parent);
++	mutex_lock_nested(&upperdir->d_inode->i_mutex, I_MUTEX_PARENT);
++	newdentry = ovl_lookup_create(upperdir, new);
++	err = PTR_ERR(newdentry);
++	if (IS_ERR(newdentry))
++		goto out_unlock;
++
++	olddentry = ovl_dentry_upper(old);
++	err = vfs_link(olddentry, upperdir->d_inode, newdentry);
++	if (!err) {
++		if (WARN_ON(!newdentry->d_inode)) {
++			dput(newdentry);
++			err = -ENOENT;
++			goto out_unlock;
++		}
++		newinode = ovl_new_inode(old->d_sb, newdentry->d_inode->i_mode,
++				new->d_fsdata);
++		if (!newinode) {
++			err = -ENOMEM;
++			goto link_fail;
++		}
++		ovl_copyattr(upperdir->d_inode, newinode);
++
++		ovl_dentry_version_inc(new->d_parent);
++		ovl_dentry_update(new, newdentry);
++
++		d_instantiate(new, newinode);
++	} else {
++link_fail:
++		if (ovl_dentry_is_opaque(new))
++			ovl_whiteout(upperdir, new);
++		dput(newdentry);
++	}
++out_unlock:
++	mutex_unlock(&upperdir->d_inode->i_mutex);
++out:
++	return err;
++}
++
++static int ovl_rename(struct inode *olddir, struct dentry *old,
++			struct inode *newdir, struct dentry *new)
++{
++	int err;
++	enum ovl_path_type old_type;
++	enum ovl_path_type new_type;
++	struct dentry *old_upperdir;
++	struct dentry *new_upperdir;
++	struct dentry *olddentry;
++	struct dentry *newdentry;
++	struct dentry *trap;
++	bool old_opaque;
++	bool new_opaque;
++	bool new_create = false;
++	bool is_dir = S_ISDIR(old->d_inode->i_mode);
++
++	/* Don't copy up directory trees */
++	old_type = ovl_path_type(old);
++	if (old_type != OVL_PATH_UPPER && is_dir)
++		return -EXDEV;
++
++	if (new->d_inode) {
++		new_type = ovl_path_type(new);
++
++		if (new_type == OVL_PATH_LOWER && old_type == OVL_PATH_LOWER) {
++			if (ovl_dentry_lower(old)->d_inode ==
++			    ovl_dentry_lower(new)->d_inode)
++				return 0;
++		}
++		if (new_type != OVL_PATH_LOWER && old_type != OVL_PATH_LOWER) {
++			if (ovl_dentry_upper(old)->d_inode ==
++			    ovl_dentry_upper(new)->d_inode)
++				return 0;
++		}
++
++		if (new_type != OVL_PATH_UPPER &&
++		    S_ISDIR(new->d_inode->i_mode)) {
++			err = ovl_check_empty_and_clear(new, new_type);
++			if (err)
++				return err;
++		}
++	} else {
++		new_type = OVL_PATH_UPPER;
++	}
++
++	err = ovl_copy_up(old);
++	if (err)
++		return err;
++
++	err = ovl_copy_up(new->d_parent);
++	if (err)
++		return err;
++
++	old_upperdir = ovl_dentry_upper(old->d_parent);
++	new_upperdir = ovl_dentry_upper(new->d_parent);
++
++	trap = lock_rename(new_upperdir, old_upperdir);
++
++	olddentry = ovl_dentry_upper(old);
++	newdentry = ovl_dentry_upper(new);
++	if (newdentry) {
++		dget(newdentry);
++	} else {
++		new_create = true;
++		newdentry = ovl_lookup_create(new_upperdir, new);
++		err = PTR_ERR(newdentry);
++		if (IS_ERR(newdentry))
++			goto out_unlock;
++	}
++
++	err = -ESTALE;
++	if (olddentry->d_parent != old_upperdir)
++		goto out_dput;
++	if (newdentry->d_parent != new_upperdir)
++		goto out_dput;
++	if (olddentry == trap)
++		goto out_dput;
++	if (newdentry == trap)
++		goto out_dput;
++
++	old_opaque = ovl_dentry_is_opaque(old);
++	new_opaque = ovl_dentry_is_opaque(new) || new_type != OVL_PATH_UPPER;
++
++	if (is_dir && !old_opaque && new_opaque) {
++		err = ovl_set_opaque(olddentry);
++		if (err)
++			goto out_dput;
++	}
++
++	err = vfs_rename(old_upperdir->d_inode, olddentry,
++			 new_upperdir->d_inode, newdentry);
++
++	if (err) {
++		if (new_create && ovl_dentry_is_opaque(new))
++			ovl_whiteout(new_upperdir, new);
++		if (is_dir && !old_opaque && new_opaque)
++			ovl_remove_opaque(olddentry);
++		goto out_dput;
++	}
++
++	if (old_type != OVL_PATH_UPPER || old_opaque)
++		err = ovl_whiteout(old_upperdir, old);
++	if (is_dir && old_opaque && !new_opaque)
++		ovl_remove_opaque(olddentry);
++
++	if (old_opaque != new_opaque)
++		ovl_dentry_set_opaque(old, new_opaque);
++
++	ovl_dentry_version_inc(old->d_parent);
++	ovl_dentry_version_inc(new->d_parent);
++
++out_dput:
++	dput(newdentry);
++out_unlock:
++	unlock_rename(new_upperdir, old_upperdir);
++	return err;
++}
++
++const struct inode_operations ovl_dir_inode_operations = {
++	.lookup		= ovl_lookup,
++	.mkdir		= ovl_mkdir,
++	.symlink	= ovl_symlink,
++	.unlink		= ovl_unlink,
++	.rmdir		= ovl_rmdir,
++	.rename		= ovl_rename,
++	.link		= ovl_link,
++	.setattr	= ovl_setattr,
++	.create		= ovl_create,
++	.mknod		= ovl_mknod,
++	.permission	= ovl_permission,
++	.getattr	= ovl_dir_getattr,
++	.setxattr	= ovl_setxattr,
++	.getxattr	= ovl_getxattr,
++	.listxattr	= ovl_listxattr,
++	.removexattr	= ovl_removexattr,
++};
+Index: kernel_tree/fs/overlayfs/inode.c
+===================================================================
+--- /dev/null
++++ kernel_tree/fs/overlayfs/inode.c
+@@ -0,0 +1,372 @@
++/*
++ *
++ * Copyright (C) 2011 Novell Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 as published by
++ * the Free Software Foundation.
++ */
++
++#include <linux/fs.h>
++#include <linux/slab.h>
++#include <linux/xattr.h>
++#include "overlayfs.h"
++
++int ovl_setattr(struct dentry *dentry, struct iattr *attr)
++{
++	struct dentry *upperdentry;
++	int err;
++
++	if ((attr->ia_valid & ATTR_SIZE) && !ovl_dentry_upper(dentry))
++		err = ovl_copy_up_truncate(dentry, attr->ia_size);
++	else
++		err = ovl_copy_up(dentry);
++	if (err)
++		return err;
++
++	upperdentry = ovl_dentry_upper(dentry);
++
++	if (attr->ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID))
++		attr->ia_valid &= ~ATTR_MODE;
++
++	mutex_lock(&upperdentry->d_inode->i_mutex);
++	err = notify_change(upperdentry, attr);
++	if (!err)
++		ovl_copyattr(upperdentry->d_inode, dentry->d_inode);
++	mutex_unlock(&upperdentry->d_inode->i_mutex);
++
++	return err;
++}
++
++static int ovl_getattr(struct vfsmount *mnt, struct dentry *dentry,
++			 struct kstat *stat)
++{
++	struct path realpath;
++
++	ovl_path_real(dentry, &realpath);
++	return vfs_getattr(&realpath, stat);
++}
++
++int ovl_permission(struct inode *inode, int mask)
++{
++	struct ovl_entry *oe;
++	struct dentry *alias = NULL;
++	struct inode *realinode;
++	struct dentry *realdentry;
++	bool is_upper;
++	int err;
++
++	if (S_ISDIR(inode->i_mode)) {
++		oe = inode->i_private;
++	} else if (mask & MAY_NOT_BLOCK) {
++		return -ECHILD;
++	} else {
++		/*
++		 * For non-directories find an alias and get the info
++		 * from there.
++		 */
++		alias = d_find_any_alias(inode);
++		if (WARN_ON(!alias))
++			return -ENOENT;
++
++		oe = alias->d_fsdata;
++	}
++
++	realdentry = ovl_entry_real(oe, &is_upper);
++
++	/* Careful in RCU walk mode */
++	realinode = ACCESS_ONCE(realdentry->d_inode);
++	if (!realinode) {
++		WARN_ON(!(mask & MAY_NOT_BLOCK));
++		err = -ENOENT;
++		goto out_dput;
++	}
++
++	if (mask & MAY_WRITE) {
++		umode_t mode = realinode->i_mode;
++
++		/*
++		 * Writes will always be redirected to upper layer, so
++		 * ignore lower layer being read-only.
++		 *
++		 * If the overlay itself is read-only then proceed
++		 * with the permission check, don't return EROFS.
++		 * This will only happen if this is the lower layer of
++		 * another overlayfs.
++		 *
++		 * If upper fs becomes read-only after the overlay was
++		 * constructed return EROFS to prevent modification of
++		 * upper layer.
++		 */
++		err = -EROFS;
++		if (is_upper && !IS_RDONLY(inode) && IS_RDONLY(realinode) &&
++		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
++			goto out_dput;
++	}
++
++	err = __inode_permission(realinode, mask);
++out_dput:
++	dput(alias);
++	return err;
++}
++
++
++struct ovl_link_data {
++	struct dentry *realdentry;
++	void *cookie;
++};
++
++static void *ovl_follow_link(struct dentry *dentry, struct nameidata *nd)
++{
++	void *ret;
++	struct dentry *realdentry;
++	struct inode *realinode;
++
++	realdentry = ovl_dentry_real(dentry);
++	realinode = realdentry->d_inode;
++
++	if (WARN_ON(!realinode->i_op->follow_link))
++		return ERR_PTR(-EPERM);
++
++	ret = realinode->i_op->follow_link(realdentry, nd);
++	if (IS_ERR(ret))
++		return ret;
++
++	if (realinode->i_op->put_link) {
++		struct ovl_link_data *data;
++
++		data = kmalloc(sizeof(struct ovl_link_data), GFP_KERNEL);
++		if (!data) {
++			realinode->i_op->put_link(realdentry, nd, ret);
++			return ERR_PTR(-ENOMEM);
++		}
++		data->realdentry = realdentry;
++		data->cookie = ret;
++
++		return data;
++	} else {
++		return NULL;
++	}
++}
++
++static void ovl_put_link(struct dentry *dentry, struct nameidata *nd, void *c)
++{
++	struct inode *realinode;
++	struct ovl_link_data *data = c;
++
++	if (!data)
++		return;
++
++	realinode = data->realdentry->d_inode;
++	realinode->i_op->put_link(data->realdentry, nd, data->cookie);
++	kfree(data);
++}
++
++static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
++{
++	struct path realpath;
++	struct inode *realinode;
++
++	ovl_path_real(dentry, &realpath);
++	realinode = realpath.dentry->d_inode;
++
++	if (!realinode->i_op->readlink)
++		return -EINVAL;
++
++	touch_atime(&realpath);
++
++	return realinode->i_op->readlink(realpath.dentry, buf, bufsiz);
++}
++
++
++static bool ovl_is_private_xattr(const char *name)
++{
++	return strncmp(name, "trusted.overlay.", 14) == 0;
++}
++
++int ovl_setxattr(struct dentry *dentry, const char *name,
++		 const void *value, size_t size, int flags)
++{
++	int err;
++	struct dentry *upperdentry;
++
++	if (ovl_is_private_xattr(name))
++		return -EPERM;
++
++	err = ovl_copy_up(dentry);
++	if (err)
++		return err;
++
++	upperdentry = ovl_dentry_upper(dentry);
++	return  vfs_setxattr(upperdentry, name, value, size, flags);
++}
++
++ssize_t ovl_getxattr(struct dentry *dentry, const char *name,
++		     void *value, size_t size)
++{
++	if (ovl_path_type(dentry->d_parent) == OVL_PATH_MERGE &&
++	    ovl_is_private_xattr(name))
++		return -ENODATA;
++
++	return vfs_getxattr(ovl_dentry_real(dentry), name, value, size);
++}
++
++ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size)
++{
++	ssize_t res;
++	int off;
++
++	res = vfs_listxattr(ovl_dentry_real(dentry), list, size);
++	if (res <= 0 || size == 0)
++		return res;
++
++	if (ovl_path_type(dentry->d_parent) != OVL_PATH_MERGE)
++		return res;
++
++	/* filter out private xattrs */
++	for (off = 0; off < res;) {
++		char *s = list + off;
++		size_t slen = strlen(s) + 1;
++
++		BUG_ON(off + slen > res);
++
++		if (ovl_is_private_xattr(s)) {
++			res -= slen;
++			memmove(s, s + slen, res - off);
++		} else {
++			off += slen;
++		}
++	}
++
++	return res;
++}
++
++int ovl_removexattr(struct dentry *dentry, const char *name)
++{
++	int err;
++	struct path realpath;
++	enum ovl_path_type type;
++
++	if (ovl_path_type(dentry->d_parent) == OVL_PATH_MERGE &&
++	    ovl_is_private_xattr(name))
++		return -ENODATA;
++
++	type = ovl_path_real(dentry, &realpath);
++	if (type == OVL_PATH_LOWER) {
++		err = vfs_getxattr(realpath.dentry, name, NULL, 0);
++		if (err < 0)
++			return err;
++
++		err = ovl_copy_up(dentry);
++		if (err)
++			return err;
++
++		ovl_path_upper(dentry, &realpath);
++	}
++
++	return vfs_removexattr(realpath.dentry, name);
++}
++
++static bool ovl_open_need_copy_up(int flags, enum ovl_path_type type,
++				  struct dentry *realdentry)
++{
++	if (type != OVL_PATH_LOWER)
++		return false;
++
++	if (special_file(realdentry->d_inode->i_mode))
++		return false;
++
++	if (!(OPEN_FMODE(flags) & FMODE_WRITE) && !(flags & O_TRUNC))
++		return false;
++
++	return true;
++}
++
++static int ovl_dentry_open(struct dentry *dentry, struct file *file,
++		    const struct cred *cred)
++{
++	int err;
++	struct path realpath;
++	enum ovl_path_type type;
++
++	type = ovl_path_real(dentry, &realpath);
++	if (ovl_open_need_copy_up(file->f_flags, type, realpath.dentry)) {
++		if (file->f_flags & O_TRUNC)
++			err = ovl_copy_up_truncate(dentry, 0);
++		else
++			err = ovl_copy_up(dentry);
++		if (err)
++			return err;
++
++		ovl_path_upper(dentry, &realpath);
++	}
++
++	return vfs_open(&realpath, file, cred);
++}
++
++static const struct inode_operations ovl_file_inode_operations = {
++	.setattr	= ovl_setattr,
++	.permission	= ovl_permission,
++	.getattr	= ovl_getattr,
++	.setxattr	= ovl_setxattr,
++	.getxattr	= ovl_getxattr,
++	.listxattr	= ovl_listxattr,
++	.removexattr	= ovl_removexattr,
++	.dentry_open	= ovl_dentry_open,
++};
++
++static const struct inode_operations ovl_symlink_inode_operations = {
++	.setattr	= ovl_setattr,
++	.follow_link	= ovl_follow_link,
++	.put_link	= ovl_put_link,
++	.readlink	= ovl_readlink,
++	.getattr	= ovl_getattr,
++	.setxattr	= ovl_setxattr,
++	.getxattr	= ovl_getxattr,
++	.listxattr	= ovl_listxattr,
++	.removexattr	= ovl_removexattr,
++};
++
++struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,
++			    struct ovl_entry *oe)
++{
++	struct inode *inode;
++
++	inode = new_inode(sb);
++	if (!inode)
++		return NULL;
++
++	mode &= S_IFMT;
++
++	inode->i_ino = get_next_ino();
++	inode->i_mode = mode;
++	inode->i_flags |= S_NOATIME | S_NOCMTIME;
++
++	switch (mode) {
++	case S_IFDIR:
++		inode->i_private = oe;
++		inode->i_op = &ovl_dir_inode_operations;
++		inode->i_fop = &ovl_dir_operations;
++		break;
++
++	case S_IFLNK:
++		inode->i_op = &ovl_symlink_inode_operations;
++		break;
++
++	case S_IFREG:
++	case S_IFSOCK:
++	case S_IFBLK:
++	case S_IFCHR:
++	case S_IFIFO:
++		inode->i_op = &ovl_file_inode_operations;
++		break;
++
++	default:
++		WARN(1, "illegal file type: %i\n", mode);
++		iput(inode);
++		inode = NULL;
++	}
++
++	return inode;
++
++}
+Index: kernel_tree/fs/overlayfs/overlayfs.h
+===================================================================
+--- /dev/null
++++ kernel_tree/fs/overlayfs/overlayfs.h
+@@ -0,0 +1,70 @@
++/*
++ *
++ * Copyright (C) 2011 Novell Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 as published by
++ * the Free Software Foundation.
++ */
++
++struct ovl_entry;
++
++enum ovl_path_type {
++	OVL_PATH_UPPER,
++	OVL_PATH_MERGE,
++	OVL_PATH_LOWER,
++};
++
++extern const char *ovl_opaque_xattr;
++extern const char *ovl_whiteout_xattr;
++extern const struct dentry_operations ovl_dentry_operations;
++
++enum ovl_path_type ovl_path_type(struct dentry *dentry);
++u64 ovl_dentry_version_get(struct dentry *dentry);
++void ovl_dentry_version_inc(struct dentry *dentry);
++void ovl_path_upper(struct dentry *dentry, struct path *path);
++void ovl_path_lower(struct dentry *dentry, struct path *path);
++enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path);
++struct dentry *ovl_dentry_upper(struct dentry *dentry);
++struct dentry *ovl_dentry_lower(struct dentry *dentry);
++struct dentry *ovl_dentry_real(struct dentry *dentry);
++struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper);
++bool ovl_dentry_is_opaque(struct dentry *dentry);
++void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
++bool ovl_is_whiteout(struct dentry *dentry);
++void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
++struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
++			  unsigned int flags);
++struct file *ovl_path_open(struct path *path, int flags);
++
++struct dentry *ovl_upper_create(struct dentry *upperdir, struct dentry *dentry,
++				struct kstat *stat, const char *link);
++
++/* readdir.c */
++extern const struct file_operations ovl_dir_operations;
++int ovl_check_empty_and_clear(struct dentry *dentry, enum ovl_path_type type);
++
++/* inode.c */
++int ovl_setattr(struct dentry *dentry, struct iattr *attr);
++int ovl_permission(struct inode *inode, int mask);
++int ovl_setxattr(struct dentry *dentry, const char *name,
++		 const void *value, size_t size, int flags);
++ssize_t ovl_getxattr(struct dentry *dentry, const char *name,
++		     void *value, size_t size);
++ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
++int ovl_removexattr(struct dentry *dentry, const char *name);
++
++struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,
++			    struct ovl_entry *oe);
++static inline void ovl_copyattr(struct inode *from, struct inode *to)
++{
++	to->i_uid = from->i_uid;
++	to->i_gid = from->i_gid;
++}
++
++/* dir.c */
++extern const struct inode_operations ovl_dir_inode_operations;
++
++/* copy_up.c */
++int ovl_copy_up(struct dentry *dentry);
++int ovl_copy_up_truncate(struct dentry *dentry, loff_t size);
+Index: kernel_tree/fs/overlayfs/readdir.c
+===================================================================
+--- /dev/null
++++ kernel_tree/fs/overlayfs/readdir.c
+@@ -0,0 +1,566 @@
++/*
++ *
++ * Copyright (C) 2011 Novell Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 as published by
++ * the Free Software Foundation.
++ */
++
++#include <linux/fs.h>
++#include <linux/slab.h>
++#include <linux/namei.h>
++#include <linux/file.h>
++#include <linux/xattr.h>
++#include <linux/rbtree.h>
++#include <linux/security.h>
++#include <linux/cred.h>
++#include "overlayfs.h"
++
++struct ovl_cache_entry {
++	const char *name;
++	unsigned int len;
++	unsigned int type;
++	u64 ino;
++	bool is_whiteout;
++	struct list_head l_node;
++	struct rb_node node;
++};
++
++struct ovl_readdir_data {
++	struct rb_root *root;
++	struct list_head *list;
++	struct list_head *middle;
++	struct dentry *dir;
++	int count;
++	int err;
++};
++
++struct ovl_dir_file {
++	bool is_real;
++	bool is_cached;
++	struct list_head cursor;
++	u64 cache_version;
++	struct list_head cache;
++	struct file *realfile;
++};
++
++static struct ovl_cache_entry *ovl_cache_entry_from_node(struct rb_node *n)
++{
++	return container_of(n, struct ovl_cache_entry, node);
++}
++
++static struct ovl_cache_entry *ovl_cache_entry_find(struct rb_root *root,
++						    const char *name, int len)
++{
++	struct rb_node *node = root->rb_node;
++	int cmp;
++
++	while (node) {
++		struct ovl_cache_entry *p = ovl_cache_entry_from_node(node);
++
++		cmp = strncmp(name, p->name, len);
++		if (cmp > 0)
++			node = p->node.rb_right;
++		else if (cmp < 0 || len < p->len)
++			node = p->node.rb_left;
++		else
++			return p;
++	}
++
++	return NULL;
++}
++
++static struct ovl_cache_entry *ovl_cache_entry_new(const char *name, int len,
++						   u64 ino, unsigned int d_type)
++{
++	struct ovl_cache_entry *p;
++
++	p = kmalloc(sizeof(*p) + len + 1, GFP_KERNEL);
++	if (p) {
++		char *name_copy = (char *) (p + 1);
++		memcpy(name_copy, name, len);
++		name_copy[len] = '\0';
++		p->name = name_copy;
++		p->len = len;
++		p->type = d_type;
++		p->ino = ino;
++		p->is_whiteout = false;
++	}
++
++	return p;
++}
++
++static int ovl_cache_entry_add_rb(struct ovl_readdir_data *rdd,
++				  const char *name, int len, u64 ino,
++				  unsigned int d_type)
++{
++	struct rb_node **newp = &rdd->root->rb_node;
++	struct rb_node *parent = NULL;
++	struct ovl_cache_entry *p;
++
++	while (*newp) {
++		int cmp;
++		struct ovl_cache_entry *tmp;
++
++		parent = *newp;
++		tmp = ovl_cache_entry_from_node(*newp);
++		cmp = strncmp(name, tmp->name, len);
++		if (cmp > 0)
++			newp = &tmp->node.rb_right;
++		else if (cmp < 0 || len < tmp->len)
++			newp = &tmp->node.rb_left;
++		else
++			return 0;
++	}
++
++	p = ovl_cache_entry_new(name, len, ino, d_type);
++	if (p == NULL)
++		return -ENOMEM;
++
++	list_add_tail(&p->l_node, rdd->list);
++	rb_link_node(&p->node, parent, newp);
++	rb_insert_color(&p->node, rdd->root);
++
++	return 0;
++}
++
++static int ovl_fill_lower(void *buf, const char *name, int namelen,
++			    loff_t offset, u64 ino, unsigned int d_type)
++{
++	struct ovl_readdir_data *rdd = buf;
++	struct ovl_cache_entry *p;
++
++	rdd->count++;
++	p = ovl_cache_entry_find(rdd->root, name, namelen);
++	if (p) {
++		list_move_tail(&p->l_node, rdd->middle);
++	} else {
++		p = ovl_cache_entry_new(name, namelen, ino, d_type);
++		if (p == NULL)
++			rdd->err = -ENOMEM;
++		else
++			list_add_tail(&p->l_node, rdd->middle);
++	}
++
++	return rdd->err;
++}
++
++static void ovl_cache_free(struct list_head *list)
++{
++	struct ovl_cache_entry *p;
++	struct ovl_cache_entry *n;
++
++	list_for_each_entry_safe(p, n, list, l_node)
++		kfree(p);
++
++	INIT_LIST_HEAD(list);
++}
++
++static int ovl_fill_upper(void *buf, const char *name, int namelen,
++			  loff_t offset, u64 ino, unsigned int d_type)
++{
++	struct ovl_readdir_data *rdd = buf;
++
++	rdd->count++;
++	return ovl_cache_entry_add_rb(rdd, name, namelen, ino, d_type);
++}
++
++static inline int ovl_dir_read(struct path *realpath,
++			       struct ovl_readdir_data *rdd, filldir_t filler)
++{
++	struct file *realfile;
++	int err;
++
++	realfile = ovl_path_open(realpath, O_RDONLY | O_DIRECTORY);
++	if (IS_ERR(realfile))
++		return PTR_ERR(realfile);
++
++	do {
++		rdd->count = 0;
++		rdd->err = 0;
++		err = vfs_readdir(realfile, filler, rdd);
++		if (err >= 0)
++			err = rdd->err;
++	} while (!err && rdd->count);
++	fput(realfile);
++
++	return 0;
++}
++
++static void ovl_dir_reset(struct file *file)
++{
++	struct ovl_dir_file *od = file->private_data;
++	enum ovl_path_type type = ovl_path_type(file->f_path.dentry);
++
++	if (ovl_dentry_version_get(file->f_path.dentry) != od->cache_version) {
++		list_del_init(&od->cursor);
++		ovl_cache_free(&od->cache);
++		od->is_cached = false;
++	}
++	WARN_ON(!od->is_real && type != OVL_PATH_MERGE);
++	if (od->is_real && type == OVL_PATH_MERGE) {
++		fput(od->realfile);
++		od->realfile = NULL;
++		od->is_real = false;
++	}
++}
++
++static int ovl_dir_mark_whiteouts(struct ovl_readdir_data *rdd)
++{
++	struct ovl_cache_entry *p;
++	struct dentry *dentry;
++	const struct cred *old_cred;
++	struct cred *override_cred;
++
++	override_cred = prepare_creds();
++	if (!override_cred) {
++		ovl_cache_free(rdd->list);
++		return -ENOMEM;
++	}
++
++	/*
++	 * CAP_SYS_ADMIN for getxattr
++	 * CAP_DAC_OVERRIDE for lookup
++	 */
++	cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
++	cap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);
++	old_cred = override_creds(override_cred);
++
++	mutex_lock(&rdd->dir->d_inode->i_mutex);
++	list_for_each_entry(p, rdd->list, l_node) {
++		if (p->type != DT_LNK)
++			continue;
++
++		dentry = lookup_one_len(p->name, rdd->dir, p->len);
++		if (IS_ERR(dentry))
++			continue;
++
++		p->is_whiteout = ovl_is_whiteout(dentry);
++		dput(dentry);
++	}
++	mutex_unlock(&rdd->dir->d_inode->i_mutex);
++
++	revert_creds(old_cred);
++	put_cred(override_cred);
++
++	return 0;
++}
++
++static inline int ovl_dir_read_merged(struct path *upperpath,
++				      struct path *lowerpath,
++				      struct ovl_readdir_data *rdd)
++{
++	int err;
++	struct rb_root root = RB_ROOT;
++	struct list_head middle;
++
++	rdd->root = &root;
++	if (upperpath->dentry) {
++		rdd->dir = upperpath->dentry;
++		err = ovl_dir_read(upperpath, rdd, ovl_fill_upper);
++		if (err)
++			goto out;
++
++		err = ovl_dir_mark_whiteouts(rdd);
++		if (err)
++			goto out;
++	}
++	/*
++	 * Insert lowerpath entries before upperpath ones, this allows
++	 * offsets to be reasonably constant
++	 */
++	list_add(&middle, rdd->list);
++	rdd->middle = &middle;
++	err = ovl_dir_read(lowerpath, rdd, ovl_fill_lower);
++	list_del(&middle);
++out:
++	rdd->root = NULL;
++
++	return err;
++}
++
++static void ovl_seek_cursor(struct ovl_dir_file *od, loff_t pos)
++{
++	struct list_head *l;
++	loff_t off;
++
++	l = od->cache.next;
++	for (off = 0; off < pos; off++) {
++		if (l == &od->cache)
++			break;
++		l = l->next;
++	}
++	list_move_tail(&od->cursor, l);
++}
++
++static int ovl_readdir(struct file *file, void *buf, filldir_t filler)
++{
++	struct ovl_dir_file *od = file->private_data;
++	int res;
++
++	if (!file->f_pos)
++		ovl_dir_reset(file);
++
++	if (od->is_real) {
++		res = vfs_readdir(od->realfile, filler, buf);
++		file->f_pos = od->realfile->f_pos;
++
++		return res;
++	}
++
++	if (!od->is_cached) {
++		struct path lowerpath;
++		struct path upperpath;
++		struct ovl_readdir_data rdd = { .list = &od->cache };
++
++		ovl_path_lower(file->f_path.dentry, &lowerpath);
++		ovl_path_upper(file->f_path.dentry, &upperpath);
++
++		res = ovl_dir_read_merged(&upperpath, &lowerpath, &rdd);
++		if (res) {
++			ovl_cache_free(rdd.list);
++			return res;
++		}
++
++		od->cache_version = ovl_dentry_version_get(file->f_path.dentry);
++		od->is_cached = true;
++
++		ovl_seek_cursor(od, file->f_pos);
++	}
++
++	while (od->cursor.next != &od->cache) {
++		int over;
++		loff_t off;
++		struct ovl_cache_entry *p;
++
++		p = list_entry(od->cursor.next, struct ovl_cache_entry, l_node);
++		off = file->f_pos;
++		if (!p->is_whiteout) {
++			over = filler(buf, p->name, p->len, off, p->ino,
++				      p->type);
++			if (over)
++				break;
++		}
++		file->f_pos++;
++		list_move(&od->cursor, &p->l_node);
++	}
++
++	return 0;
++}
++
++static loff_t ovl_dir_llseek(struct file *file, loff_t offset, int origin)
++{
++	loff_t res;
++	struct ovl_dir_file *od = file->private_data;
++
++	mutex_lock(&file_inode(file)->i_mutex);
++	if (!file->f_pos)
++		ovl_dir_reset(file);
++
++	if (od->is_real) {
++		res = vfs_llseek(od->realfile, offset, origin);
++		file->f_pos = od->realfile->f_pos;
++	} else {
++		res = -EINVAL;
++
++		switch (origin) {
++		case SEEK_CUR:
++			offset += file->f_pos;
++			break;
++		case SEEK_SET:
++			break;
++		default:
++			goto out_unlock;
++		}
++		if (offset < 0)
++			goto out_unlock;
++
++		if (offset != file->f_pos) {
++			file->f_pos = offset;
++			if (od->is_cached)
++				ovl_seek_cursor(od, offset);
++		}
++		res = offset;
++	}
++out_unlock:
++	mutex_unlock(&file_inode(file)->i_mutex);
++
++	return res;
++}
++
++static int ovl_dir_fsync(struct file *file, loff_t start, loff_t end,
++			 int datasync)
++{
++	struct ovl_dir_file *od = file->private_data;
++
++	/* May need to reopen directory if it got copied up */
++	if (!od->realfile) {
++		struct path upperpath;
++
++		ovl_path_upper(file->f_path.dentry, &upperpath);
++		od->realfile = ovl_path_open(&upperpath, O_RDONLY);
++		if (IS_ERR(od->realfile))
++			return PTR_ERR(od->realfile);
++	}
++
++	return vfs_fsync_range(od->realfile, start, end, datasync);
++}
++
++static int ovl_dir_release(struct inode *inode, struct file *file)
++{
++	struct ovl_dir_file *od = file->private_data;
++
++	list_del(&od->cursor);
++	ovl_cache_free(&od->cache);
++	if (od->realfile)
++		fput(od->realfile);
++	kfree(od);
++
++	return 0;
++}
++
++static int ovl_dir_open(struct inode *inode, struct file *file)
++{
++	struct path realpath;
++	struct file *realfile;
++	struct ovl_dir_file *od;
++	enum ovl_path_type type;
++
++	od = kzalloc(sizeof(struct ovl_dir_file), GFP_KERNEL);
++	if (!od)
++		return -ENOMEM;
++
++	type = ovl_path_real(file->f_path.dentry, &realpath);
++	realfile = ovl_path_open(&realpath, file->f_flags);
++	if (IS_ERR(realfile)) {
++		kfree(od);
++		return PTR_ERR(realfile);
++	}
++	INIT_LIST_HEAD(&od->cache);
++	INIT_LIST_HEAD(&od->cursor);
++	od->is_cached = false;
++	od->realfile = realfile;
++	od->is_real = (type != OVL_PATH_MERGE);
++	file->private_data = od;
++
++	return 0;
++}
++
++const struct file_operations ovl_dir_operations = {
++	.read		= generic_read_dir,
++	.open		= ovl_dir_open,
++	.readdir	= ovl_readdir,
++	.llseek		= ovl_dir_llseek,
++	.fsync		= ovl_dir_fsync,
++	.release	= ovl_dir_release,
++};
++
++static int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list)
++{
++	int err;
++	struct path lowerpath;
++	struct path upperpath;
++	struct ovl_cache_entry *p;
++	struct ovl_readdir_data rdd = { .list = list };
++
++	ovl_path_upper(dentry, &upperpath);
++	ovl_path_lower(dentry, &lowerpath);
++
++	err = ovl_dir_read_merged(&upperpath, &lowerpath, &rdd);
++	if (err)
++		return err;
++
++	err = 0;
++
++	list_for_each_entry(p, list, l_node) {
++		if (p->is_whiteout)
++			continue;
++
++		if (p->name[0] == '.') {
++			if (p->len == 1)
++				continue;
++			if (p->len == 2 && p->name[1] == '.')
++				continue;
++		}
++		err = -ENOTEMPTY;
++		break;
++	}
++
++	return err;
++}
++
++static int ovl_remove_whiteouts(struct dentry *dir, struct list_head *list)
++{
++	struct path upperpath;
++	struct dentry *upperdir;
++	struct ovl_cache_entry *p;
++	const struct cred *old_cred;
++	struct cred *override_cred;
++	int err;
++
++	ovl_path_upper(dir, &upperpath);
++	upperdir = upperpath.dentry;
++
++	override_cred = prepare_creds();
++	if (!override_cred)
++		return -ENOMEM;
++
++	/*
++	 * CAP_DAC_OVERRIDE for lookup and unlink
++	 * CAP_SYS_ADMIN for setxattr of "trusted" namespace
++	 * CAP_FOWNER for unlink in sticky directory
++	 */
++	cap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);
++	cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
++	cap_raise(override_cred->cap_effective, CAP_FOWNER);
++	old_cred = override_creds(override_cred);
++
++	err = vfs_setxattr(upperdir, ovl_opaque_xattr, "y", 1, 0);
++	if (err)
++		goto out_revert_creds;
++
++	mutex_lock_nested(&upperdir->d_inode->i_mutex, I_MUTEX_PARENT);
++	list_for_each_entry(p, list, l_node) {
++		struct dentry *dentry;
++		int ret;
++
++		if (!p->is_whiteout)
++			continue;
++
++		dentry = lookup_one_len(p->name, upperdir, p->len);
++		if (IS_ERR(dentry)) {
++			pr_warn(
++			    "overlayfs: failed to lookup whiteout %.*s: %li\n",
++			    p->len, p->name, PTR_ERR(dentry));
++			continue;
++		}
++		ret = vfs_unlink(upperdir->d_inode, dentry);
++		dput(dentry);
++		if (ret)
++			pr_warn(
++			    "overlayfs: failed to unlink whiteout %.*s: %i\n",
++			    p->len, p->name, ret);
++	}
++	mutex_unlock(&upperdir->d_inode->i_mutex);
++
++out_revert_creds:
++	revert_creds(old_cred);
++	put_cred(override_cred);
++
++	return err;
++}
++
++int ovl_check_empty_and_clear(struct dentry *dentry, enum ovl_path_type type)
++{
++	int err;
++	LIST_HEAD(list);
++
++	err = ovl_check_empty_dir(dentry, &list);
++	if (!err && type == OVL_PATH_MERGE)
++		err = ovl_remove_whiteouts(dentry, &list);
++
++	ovl_cache_free(&list);
++
++	return err;
++}
+Index: kernel_tree/fs/overlayfs/super.c
+===================================================================
+--- /dev/null
++++ kernel_tree/fs/overlayfs/super.c
+@@ -0,0 +1,685 @@
++/*
++ *
++ * Copyright (C) 2011 Novell Inc.
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 as published by
++ * the Free Software Foundation.
++ */
++
++#include <linux/fs.h>
++#include <linux/namei.h>
++#include <linux/xattr.h>
++#include <linux/security.h>
++#include <linux/mount.h>
++#include <linux/slab.h>
++#include <linux/parser.h>
++#include <linux/module.h>
++#include <linux/cred.h>
++#include <linux/sched.h>
++#include <linux/statfs.h>
++#include <linux/seq_file.h>
++#include "overlayfs.h"
++
++MODULE_AUTHOR("Miklos Szeredi <miklos@szeredi.hu>");
++MODULE_DESCRIPTION("Overlay filesystem");
++MODULE_LICENSE("GPL");
++
++#define OVERLAYFS_SUPER_MAGIC 0x794c764f
++
++struct ovl_config {
++	char *lowerdir;
++	char *upperdir;
++};
++
++/* private information held for overlayfs's superblock */
++struct ovl_fs {
++	struct vfsmount *upper_mnt;
++	struct vfsmount *lower_mnt;
++	long lower_namelen;
++	/* pathnames of lower and upper dirs, for show_options */
++	struct ovl_config config;
++};
++
++/* private information held for every overlayfs dentry */
++struct ovl_entry {
++	/*
++	 * Keep "double reference" on upper dentries, so that
++	 * d_delete() doesn't think it's OK to reset d_inode to NULL.
++	 */
++	struct dentry *__upperdentry;
++	struct dentry *lowerdentry;
++	union {
++		struct {
++			u64 version;
++			bool opaque;
++		};
++		struct rcu_head rcu;
++	};
++};
++
++const char *ovl_whiteout_xattr = "trusted.overlay.whiteout";
++const char *ovl_opaque_xattr = "trusted.overlay.opaque";
++
++
++enum ovl_path_type ovl_path_type(struct dentry *dentry)
++{
++	struct ovl_entry *oe = dentry->d_fsdata;
++
++	if (oe->__upperdentry) {
++		if (oe->lowerdentry && S_ISDIR(dentry->d_inode->i_mode))
++			return OVL_PATH_MERGE;
++		else
++			return OVL_PATH_UPPER;
++	} else {
++		return OVL_PATH_LOWER;
++	}
++}
++
++static struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)
++{
++	struct dentry *upperdentry = ACCESS_ONCE(oe->__upperdentry);
++	smp_read_barrier_depends();
++	return upperdentry;
++}
++
++void ovl_path_upper(struct dentry *dentry, struct path *path)
++{
++	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
++	struct ovl_entry *oe = dentry->d_fsdata;
++
++	path->mnt = ofs->upper_mnt;
++	path->dentry = ovl_upperdentry_dereference(oe);
++}
++
++void ovl_path_lower(struct dentry *dentry, struct path *path)
++{
++	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
++	struct ovl_entry *oe = dentry->d_fsdata;
++
++	path->mnt = ofs->lower_mnt;
++	path->dentry = oe->lowerdentry;
++}
++
++enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)
++{
++
++	enum ovl_path_type type = ovl_path_type(dentry);
++
++	if (type == OVL_PATH_LOWER)
++		ovl_path_lower(dentry, path);
++	else
++		ovl_path_upper(dentry, path);
++
++	return type;
++}
++
++struct dentry *ovl_dentry_upper(struct dentry *dentry)
++{
++	struct ovl_entry *oe = dentry->d_fsdata;
++
++	return ovl_upperdentry_dereference(oe);
++}
++
++struct dentry *ovl_dentry_lower(struct dentry *dentry)
++{
++	struct ovl_entry *oe = dentry->d_fsdata;
++
++	return oe->lowerdentry;
++}
++
++struct dentry *ovl_dentry_real(struct dentry *dentry)
++{
++	struct ovl_entry *oe = dentry->d_fsdata;
++	struct dentry *realdentry;
++
++	realdentry = ovl_upperdentry_dereference(oe);
++	if (!realdentry)
++		realdentry = oe->lowerdentry;
++
++	return realdentry;
++}
++
++struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper)
++{
++	struct dentry *realdentry;
++
++	realdentry = ovl_upperdentry_dereference(oe);
++	if (realdentry) {
++		*is_upper = true;
++	} else {
++		realdentry = oe->lowerdentry;
++		*is_upper = false;
++	}
++	return realdentry;
++}
++
++bool ovl_dentry_is_opaque(struct dentry *dentry)
++{
++	struct ovl_entry *oe = dentry->d_fsdata;
++	return oe->opaque;
++}
++
++void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque)
++{
++	struct ovl_entry *oe = dentry->d_fsdata;
++	oe->opaque = opaque;
++}
++
++void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry)
++{
++	struct ovl_entry *oe = dentry->d_fsdata;
++
++	WARN_ON(!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex));
++	WARN_ON(oe->__upperdentry);
++	BUG_ON(!upperdentry->d_inode);
++	smp_wmb();
++	oe->__upperdentry = dget(upperdentry);
++}
++
++void ovl_dentry_version_inc(struct dentry *dentry)
++{
++	struct ovl_entry *oe = dentry->d_fsdata;
++
++	WARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));
++	oe->version++;
++}
++
++u64 ovl_dentry_version_get(struct dentry *dentry)
++{
++	struct ovl_entry *oe = dentry->d_fsdata;
++
++	WARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));
++	return oe->version;
++}
++
++bool ovl_is_whiteout(struct dentry *dentry)
++{
++	int res;
++	char val;
++
++	if (!dentry)
++		return false;
++	if (!dentry->d_inode)
++		return false;
++	if (!S_ISLNK(dentry->d_inode->i_mode))
++		return false;
++
++	res = vfs_getxattr(dentry, ovl_whiteout_xattr, &val, 1);
++	if (res == 1 && val == 'y')
++		return true;
++
++	return false;
++}
++
++static bool ovl_is_opaquedir(struct dentry *dentry)
++{
++	int res;
++	char val;
++
++	if (!S_ISDIR(dentry->d_inode->i_mode))
++		return false;
++
++	res = vfs_getxattr(dentry, ovl_opaque_xattr, &val, 1);
++	if (res == 1 && val == 'y')
++		return true;
++
++	return false;
++}
++
++static void ovl_entry_free(struct rcu_head *head)
++{
++	struct ovl_entry *oe = container_of(head, struct ovl_entry, rcu);
++	kfree(oe);
++}
++
++static void ovl_dentry_release(struct dentry *dentry)
++{
++	struct ovl_entry *oe = dentry->d_fsdata;
++
++	if (oe) {
++		dput(oe->__upperdentry);
++		dput(oe->__upperdentry);
++		dput(oe->lowerdentry);
++		call_rcu(&oe->rcu, ovl_entry_free);
++	}
++}
++
++const struct dentry_operations ovl_dentry_operations = {
++	.d_release = ovl_dentry_release,
++};
++
++static struct ovl_entry *ovl_alloc_entry(void)
++{
++	return kzalloc(sizeof(struct ovl_entry), GFP_KERNEL);
++}
++
++static inline struct dentry *ovl_lookup_real(struct dentry *dir,
++					     struct qstr *name)
++{
++	struct dentry *dentry;
++
++	mutex_lock(&dir->d_inode->i_mutex);
++	dentry = lookup_one_len(name->name, dir, name->len);
++	mutex_unlock(&dir->d_inode->i_mutex);
++
++	if (IS_ERR(dentry)) {
++		if (PTR_ERR(dentry) == -ENOENT)
++			dentry = NULL;
++	} else if (!dentry->d_inode) {
++		dput(dentry);
++		dentry = NULL;
++	}
++	return dentry;
++}
++
++static int ovl_do_lookup(struct dentry *dentry)
++{
++	struct ovl_entry *oe;
++	struct dentry *upperdir;
++	struct dentry *lowerdir;
++	struct dentry *upperdentry = NULL;
++	struct dentry *lowerdentry = NULL;
++	struct inode *inode = NULL;
++	int err;
++
++	err = -ENOMEM;
++	oe = ovl_alloc_entry();
++	if (!oe)
++		goto out;
++
++	upperdir = ovl_dentry_upper(dentry->d_parent);
++	lowerdir = ovl_dentry_lower(dentry->d_parent);
++
++	if (upperdir) {
++		upperdentry = ovl_lookup_real(upperdir, &dentry->d_name);
++		err = PTR_ERR(upperdentry);
++		if (IS_ERR(upperdentry))
++			goto out_put_dir;
++
++		if (lowerdir && upperdentry &&
++		    (S_ISLNK(upperdentry->d_inode->i_mode) ||
++		     S_ISDIR(upperdentry->d_inode->i_mode))) {
++			const struct cred *old_cred;
++			struct cred *override_cred;
++
++			err = -ENOMEM;
++			override_cred = prepare_creds();
++			if (!override_cred)
++				goto out_dput_upper;
++
++			/* CAP_SYS_ADMIN needed for getxattr */
++			cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);
++			old_cred = override_creds(override_cred);
++
++			if (ovl_is_opaquedir(upperdentry)) {
++				oe->opaque = true;
++			} else if (ovl_is_whiteout(upperdentry)) {
++				dput(upperdentry);
++				upperdentry = NULL;
++				oe->opaque = true;
++			}
++			revert_creds(old_cred);
++			put_cred(override_cred);
++		}
++	}
++	if (lowerdir && !oe->opaque) {
++		lowerdentry = ovl_lookup_real(lowerdir, &dentry->d_name);
++		err = PTR_ERR(lowerdentry);
++		if (IS_ERR(lowerdentry))
++			goto out_dput_upper;
++	}
++
++	if (lowerdentry && upperdentry &&
++	    (!S_ISDIR(upperdentry->d_inode->i_mode) ||
++	     !S_ISDIR(lowerdentry->d_inode->i_mode))) {
++		dput(lowerdentry);
++		lowerdentry = NULL;
++		oe->opaque = true;
++	}
++
++	if (lowerdentry || upperdentry) {
++		struct dentry *realdentry;
++
++		realdentry = upperdentry ? upperdentry : lowerdentry;
++		err = -ENOMEM;
++		inode = ovl_new_inode(dentry->d_sb, realdentry->d_inode->i_mode,
++				      oe);
++		if (!inode)
++			goto out_dput;
++		ovl_copyattr(realdentry->d_inode, inode);
++	}
++
++	if (upperdentry)
++		oe->__upperdentry = dget(upperdentry);
++
++	if (lowerdentry)
++		oe->lowerdentry = lowerdentry;
++
++	dentry->d_fsdata = oe;
++	dentry->d_op = &ovl_dentry_operations;
++	d_add(dentry, inode);
++
++	return 0;
++
++out_dput:
++	dput(lowerdentry);
++out_dput_upper:
++	dput(upperdentry);
++out_put_dir:
++	kfree(oe);
++out:
++	return err;
++}
++
++struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
++			  unsigned int flags)
++{
++	int err = ovl_do_lookup(dentry);
++
++	if (err)
++		return ERR_PTR(err);
++
++	return NULL;
++}
++
++struct file *ovl_path_open(struct path *path, int flags)
++{
++	return dentry_open(path, flags, current_cred());
++}
++
++static void ovl_put_super(struct super_block *sb)
++{
++	struct ovl_fs *ufs = sb->s_fs_info;
++
++	if (!(sb->s_flags & MS_RDONLY))
++		mnt_drop_write(ufs->upper_mnt);
++
++	mntput(ufs->upper_mnt);
++	mntput(ufs->lower_mnt);
++
++	kfree(ufs->config.lowerdir);
++	kfree(ufs->config.upperdir);
++	kfree(ufs);
++}
++
++static int ovl_remount_fs(struct super_block *sb, int *flagsp, char *data)
++{
++	int flags = *flagsp;
++	struct ovl_fs *ufs = sb->s_fs_info;
++
++	/* When remounting rw or ro, we need to adjust the write access to the
++	 * upper fs.
++	 */
++	if (((flags ^ sb->s_flags) & MS_RDONLY) == 0)
++		/* No change to readonly status */
++		return 0;
++
++	if (flags & MS_RDONLY) {
++		mnt_drop_write(ufs->upper_mnt);
++		return 0;
++	} else
++		return mnt_want_write(ufs->upper_mnt);
++}
++
++/**
++ * ovl_statfs
++ * @sb: The overlayfs super block
++ * @buf: The struct kstatfs to fill in with stats
++ *
++ * Get the filesystem statistics.  As writes always target the upper layer
++ * filesystem pass the statfs to the same filesystem.
++ */
++static int ovl_statfs(struct dentry *dentry, struct kstatfs *buf)
++{
++	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
++	struct dentry *root_dentry = dentry->d_sb->s_root;
++	struct path path;
++	int err;
++
++	ovl_path_upper(root_dentry, &path);
++
++	err = vfs_statfs(&path, buf);
++	if (!err) {
++		buf->f_namelen = max(buf->f_namelen, ofs->lower_namelen);
++		buf->f_type = OVERLAYFS_SUPER_MAGIC;
++	}
++
++	return err;
++}
++
++/**
++ * ovl_show_options
++ *
++ * Prints the mount options for a given superblock.
++ * Returns zero; does not fail.
++ */
++static int ovl_show_options(struct seq_file *m, struct dentry *dentry)
++{
++	struct super_block *sb = dentry->d_sb;
++	struct ovl_fs *ufs = sb->s_fs_info;
++
++	seq_printf(m, ",lowerdir=%s", ufs->config.lowerdir);
++	seq_printf(m, ",upperdir=%s", ufs->config.upperdir);
++	return 0;
++}
++
++static const struct super_operations ovl_super_operations = {
++	.put_super	= ovl_put_super,
++	.remount_fs	= ovl_remount_fs,
++	.statfs		= ovl_statfs,
++	.show_options	= ovl_show_options,
++};
++
++enum {
++	OPT_LOWERDIR,
++	OPT_UPPERDIR,
++	OPT_ERR,
++};
++
++static const match_table_t ovl_tokens = {
++	{OPT_LOWERDIR,			"lowerdir=%s"},
++	{OPT_UPPERDIR,			"upperdir=%s"},
++	{OPT_ERR,			NULL}
++};
++
++static int ovl_parse_opt(char *opt, struct ovl_config *config)
++{
++	char *p;
++
++	config->upperdir = NULL;
++	config->lowerdir = NULL;
++
++	while ((p = strsep(&opt, ",")) != NULL) {
++		int token;
++		substring_t args[MAX_OPT_ARGS];
++
++		if (!*p)
++			continue;
++
++		token = match_token(p, ovl_tokens, args);
++		switch (token) {
++		case OPT_UPPERDIR:
++			kfree(config->upperdir);
++			config->upperdir = match_strdup(&args[0]);
++			if (!config->upperdir)
++				return -ENOMEM;
++			break;
++
++		case OPT_LOWERDIR:
++			kfree(config->lowerdir);
++			config->lowerdir = match_strdup(&args[0]);
++			if (!config->lowerdir)
++				return -ENOMEM;
++			break;
++
++		default:
++			return -EINVAL;
++		}
++	}
++	return 0;
++}
++
++static int ovl_fill_super(struct super_block *sb, void *data, int silent)
++{
++	struct path lowerpath;
++	struct path upperpath;
++	struct inode *root_inode;
++	struct dentry *root_dentry;
++	struct ovl_entry *oe;
++	struct ovl_fs *ufs;
++	struct kstatfs statfs;
++	int err;
++
++	err = -ENOMEM;
++	ufs = kmalloc(sizeof(struct ovl_fs), GFP_KERNEL);
++	if (!ufs)
++		goto out;
++
++	err = ovl_parse_opt((char *) data, &ufs->config);
++	if (err)
++		goto out_free_ufs;
++
++	err = -EINVAL;
++	if (!ufs->config.upperdir || !ufs->config.lowerdir) {
++		pr_err("overlayfs: missing upperdir or lowerdir\n");
++		goto out_free_config;
++	}
++
++	oe = ovl_alloc_entry();
++	if (oe == NULL)
++		goto out_free_config;
++
++	err = kern_path(ufs->config.upperdir, LOOKUP_FOLLOW, &upperpath);
++	if (err)
++		goto out_free_oe;
++
++	err = kern_path(ufs->config.lowerdir, LOOKUP_FOLLOW, &lowerpath);
++	if (err)
++		goto out_put_upperpath;
++
++	err = -ENOTDIR;
++	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
++	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode))
++		goto out_put_lowerpath;
++
++	err = vfs_statfs(&lowerpath, &statfs);
++	if (err) {
++		pr_err("overlayfs: statfs failed on lowerpath\n");
++		goto out_put_lowerpath;
++	}
++	ufs->lower_namelen = statfs.f_namelen;
++
++	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
++				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;
++
++	err = -EINVAL;
++	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
++		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
++		goto out_put_lowerpath;
++	}
++
++
++	ufs->upper_mnt = clone_private_mount(&upperpath);
++	err = PTR_ERR(ufs->upper_mnt);
++	if (IS_ERR(ufs->upper_mnt)) {
++		pr_err("overlayfs: failed to clone upperpath\n");
++		goto out_put_lowerpath;
++	}
++
++	ufs->lower_mnt = clone_private_mount(&lowerpath);
++	err = PTR_ERR(ufs->lower_mnt);
++	if (IS_ERR(ufs->lower_mnt)) {
++		pr_err("overlayfs: failed to clone lowerpath\n");
++		goto out_put_upper_mnt;
++	}
++
++	/*
++	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
++	 * will fail instead of modifying lower fs.
++	 */
++	ufs->lower_mnt->mnt_flags |= MNT_READONLY;
++
++	/* If the upper fs is r/o, we mark overlayfs r/o too */
++	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
++		sb->s_flags |= MS_RDONLY;
++
++	if (!(sb->s_flags & MS_RDONLY)) {
++		err = mnt_want_write(ufs->upper_mnt);
++		if (err)
++			goto out_put_lower_mnt;
++	}
++
++	err = -ENOMEM;
++	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
++	if (!root_inode)
++		goto out_drop_write;
++
++	root_dentry = d_make_root(root_inode);
++	if (!root_dentry)
++		goto out_drop_write;
++
++	mntput(upperpath.mnt);
++	mntput(lowerpath.mnt);
++
++	oe->__upperdentry = dget(upperpath.dentry);
++	oe->lowerdentry = lowerpath.dentry;
++
++	root_dentry->d_fsdata = oe;
++	root_dentry->d_op = &ovl_dentry_operations;
++
++	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
++	sb->s_op = &ovl_super_operations;
++	sb->s_root = root_dentry;
++	sb->s_fs_info = ufs;
++
++	return 0;
++
++out_drop_write:
++	if (!(sb->s_flags & MS_RDONLY))
++		mnt_drop_write(ufs->upper_mnt);
++out_put_lower_mnt:
++	mntput(ufs->lower_mnt);
++out_put_upper_mnt:
++	mntput(ufs->upper_mnt);
++out_put_lowerpath:
++	path_put(&lowerpath);
++out_put_upperpath:
++	path_put(&upperpath);
++out_free_oe:
++	kfree(oe);
++out_free_config:
++	kfree(ufs->config.lowerdir);
++	kfree(ufs->config.upperdir);
++out_free_ufs:
++	kfree(ufs);
++out:
++	return err;
++}
++
++static struct dentry *ovl_mount(struct file_system_type *fs_type, int flags,
++				const char *dev_name, void *raw_data)
++{
++	return mount_nodev(fs_type, flags, raw_data, ovl_fill_super);
++}
++
++static struct file_system_type ovl_fs_type = {
++	.owner		= THIS_MODULE,
++	.name		= "overlayfs",
++	.mount		= ovl_mount,
++	.kill_sb	= kill_anon_super,
++};
++MODULE_ALIAS_FS("overlayfs");
++
++static int __init ovl_init(void)
++{
++	return register_filesystem(&ovl_fs_type);
++}
++
++static void __exit ovl_exit(void)
++{
++	unregister_filesystem(&ovl_fs_type);
++}
++
++module_init(ovl_init);
++module_exit(ovl_exit);
+Index: kernel_tree/fs/splice.c
+===================================================================
+--- kernel_tree.orig/fs/splice.c
++++ kernel_tree/fs/splice.c
+@@ -1346,6 +1346,7 @@ long do_splice_direct(struct file *in, l
+ 
+ 	return ret;
+ }
++EXPORT_SYMBOL(do_splice_direct);
+ 
+ static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,
+ 			       struct pipe_inode_info *opipe,
+Index: kernel_tree/include/linux/fs.h
+===================================================================
+--- kernel_tree.orig/include/linux/fs.h
++++ kernel_tree/include/linux/fs.h
+@@ -245,6 +245,12 @@ struct iattr {
+  */
+ #include <linux/quota.h>
+ 
++/*
++ * Maximum number of layers of fs stack.  Needs to be limited to
++ * prevent kernel stack overflow
++ */
++#define FILESYSTEM_MAX_STACK_DEPTH 2
++
+ /** 
+  * enum positive_aop_returns - aop return codes with specific semantics
+  *
+@@ -1311,6 +1317,11 @@ struct super_block {
+ 
+ 	/* Being remounted read-only */
+ 	int s_readonly_remount;
++
++	/*
++	 * Indicates how deep in a filesystem stack this SB is
++	 */
++	int s_stack_depth;
+ };
+ 
+ /* superblock cache pruning functions */
+@@ -1564,6 +1575,7 @@ struct inode_operations {
+ 	int (*atomic_open)(struct inode *, struct dentry *,
+ 			   struct file *, unsigned open_flag,
+ 			   umode_t create_mode, int *opened);
++	int (*dentry_open)(struct dentry *, struct file *, const struct cred *);
+ } ____cacheline_aligned;
+ 
+ ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
+@@ -1997,6 +2009,7 @@ extern struct file *file_open_name(struc
+ extern struct file *filp_open(const char *, int, umode_t);
+ extern struct file *file_open_root(struct dentry *, struct vfsmount *,
+ 				   const char *, int);
++extern int vfs_open(const struct path *, struct file *, const struct cred *);
+ extern struct file * dentry_open(const struct path *, int, const struct cred *);
+ extern int filp_close(struct file *, fl_owner_t id);
+ 
+@@ -2197,6 +2210,7 @@ extern sector_t bmap(struct inode *, sec
+ #endif
+ extern int notify_change(struct dentry *, struct iattr *);
+ extern int inode_permission(struct inode *, int);
++extern int __inode_permission(struct inode *, int);
+ extern int generic_permission(struct inode *, int);
+ 
+ static inline bool execute_ok(struct inode *inode)
+@@ -2403,6 +2417,9 @@ extern ssize_t generic_file_splice_write
+ 		struct file *, loff_t *, size_t, unsigned int);
+ extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
+ 		struct file *out, loff_t *, size_t len, unsigned int flags);
++extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
++		loff_t *opos, size_t len, unsigned int flags);
++
+ 
+ extern void
+ file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
+Index: kernel_tree/include/linux/mount.h
+===================================================================
+--- kernel_tree.orig/include/linux/mount.h
++++ kernel_tree/include/linux/mount.h
+@@ -75,6 +75,9 @@ extern void mnt_pin(struct vfsmount *mnt
+ extern void mnt_unpin(struct vfsmount *mnt);
+ extern int __mnt_is_readonly(struct vfsmount *mnt);
+ 
++struct path;
++extern struct vfsmount *clone_private_mount(struct path *path);
++
+ struct file_system_type;
+ extern struct vfsmount *vfs_kern_mount(struct file_system_type *type,
+ 				      int flags, const char *name,
diff --git a/target/linux/generic/patches-3.10/102-ehci_hcd_ignore_oc.patch b/target/linux/generic/patches-3.10/102-ehci_hcd_ignore_oc.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/102-ehci_hcd_ignore_oc.patch
@@ -0,0 +1,81 @@
+From 1e311820ec3055e3f08e687de6564692a7cec675 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <florian@openwrt.org>
+Date: Mon, 28 Jan 2013 20:06:29 +0100
+Subject: [PATCH 11/12] USB: EHCI: add ignore_oc flag to disable overcurrent
+ checking
+
+This patch adds an ignore_oc flag which can be set by EHCI controller
+not supporting or wanting to disable overcurrent checking. The EHCI
+platform data in include/linux/usb/ehci_pdriver.h is also augmented to
+take advantage of this new flag.
+
+Signed-off-by: Florian Fainelli <florian@openwrt.org>
+---
+ drivers/usb/host/ehci-hcd.c      |    2 +-
+ drivers/usb/host/ehci-hub.c      |    4 ++--
+ drivers/usb/host/ehci-platform.c |    1 +
+ drivers/usb/host/ehci.h          |    1 +
+ include/linux/usb/ehci_pdriver.h |    1 +
+ 5 files changed, 6 insertions(+), 3 deletions(-)
+
+--- a/drivers/usb/host/ehci-hcd.c
++++ b/drivers/usb/host/ehci-hcd.c
+@@ -634,7 +634,7 @@ static int ehci_run (struct usb_hcd *hcd
+ 		"USB %x.%x started, EHCI %x.%02x%s\n",
+ 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
+ 		temp >> 8, temp & 0xff,
+-		ignore_oc ? ", overcurrent ignored" : "");
++		(ignore_oc || ehci->ignore_oc) ? ", overcurrent ignored" : "");
+ 
+ 	ehci_writel(ehci, INTR_MASK,
+ 		    &ehci->regs->intr_enable); /* Turn On Interrupts */
+--- a/drivers/usb/host/ehci-hub.c
++++ b/drivers/usb/host/ehci-hub.c
+@@ -611,7 +611,7 @@ ehci_hub_status_data (struct usb_hcd *hc
+ 	 * always set, seem to clear PORT_OCC and PORT_CSC when writing to
+ 	 * PORT_POWER; that's surprising, but maybe within-spec.
+ 	 */
+-	if (!ignore_oc)
++	if (!ignore_oc && !ehci->ignore_oc)
+ 		mask = PORT_CSC | PORT_PEC | PORT_OCC;
+ 	else
+ 		mask = PORT_CSC | PORT_PEC;
+@@ -830,7 +830,7 @@ static int ehci_hub_control (
+ 		if (temp & PORT_PEC)
+ 			status |= USB_PORT_STAT_C_ENABLE << 16;
+ 
+-		if ((temp & PORT_OCC) && !ignore_oc){
++		if ((temp & PORT_OCC) && (!ignore_oc && !ehci->ignore_oc)){
+ 			status |= USB_PORT_STAT_C_OVERCURRENT << 16;
+ 
+ 			/*
+--- a/drivers/usb/host/ehci-platform.c
++++ b/drivers/usb/host/ehci-platform.c
+@@ -47,6 +47,7 @@ static int ehci_platform_reset(struct us
+ 	ehci->has_synopsys_hc_bug = pdata->has_synopsys_hc_bug;
+ 	ehci->big_endian_desc = pdata->big_endian_desc;
+ 	ehci->big_endian_mmio = pdata->big_endian_mmio;
++	ehci->ignore_oc = pdata->ignore_oc;
+ 
+ 	ehci->caps = hcd->regs + pdata->caps_offset;
+ 	retval = ehci_setup(hcd);
+--- a/drivers/usb/host/ehci.h
++++ b/drivers/usb/host/ehci.h
+@@ -201,6 +201,7 @@ struct ehci_hcd {			/* one per controlle
+ 	unsigned		frame_index_bug:1; /* MosChip (AKA NetMos) */
+ 	unsigned		need_oc_pp_cycle:1; /* MPC834X port power */
+ 	unsigned		imx28_write_fix:1; /* For Freescale i.MX28 */
++	unsigned		ignore_oc:1;
+ 
+ 	/* required for usb32 quirk */
+ 	#define OHCI_CTRL_HCFS          (3 << 6)
+--- a/include/linux/usb/ehci_pdriver.h
++++ b/include/linux/usb/ehci_pdriver.h
+@@ -42,6 +42,7 @@ struct usb_ehci_pdata {
+ 	unsigned	big_endian_desc:1;
+ 	unsigned	big_endian_mmio:1;
+ 	unsigned	no_io_watchdog:1;
++	unsigned	ignore_oc:1;
+ 
+ 	/* Turn on all power and clocks */
+ 	int (*power_on)(struct platform_device *pdev);
diff --git a/target/linux/generic/patches-3.10/120-bridge_allow_receiption_on_disabled_port.patch b/target/linux/generic/patches-3.10/120-bridge_allow_receiption_on_disabled_port.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/120-bridge_allow_receiption_on_disabled_port.patch
@@ -0,0 +1,54 @@
+From: Stephen Hemminger <stephen@networkplumber.org>
+Subject: bridge: allow receiption on disabled port
+
+When an ethernet device is enslaved to a bridge, and the bridge STP
+detects loss of carrier (or operational state down), then normally
+packet receiption is blocked.
+
+This breaks control applications like WPA which maybe expecting to
+receive packets to negotiate to bring link up. The bridge needs to
+block forwarding packets from these disabled ports, but there is no
+hard requirement to not allow local packet delivery.
+
+Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
+Signed-off-by: Felix Fietkau <nbd@openwrt.org>
+
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -139,10 +139,14 @@ drop:
+ static int br_handle_local_finish(struct sk_buff *skb)
+ {
+ 	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
+-	u16 vid = 0;
+ 
+-	br_vlan_get_tag(skb, &vid);
+-	br_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid);
++	if (p->state != BR_STATE_DISABLED) {
++		u16 vid = 0;
++
++		br_vlan_get_tag(skb, &vid);
++		br_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid);
++	}
++
+ 	return 0;	 /* process further */
+ }
+ 
+@@ -212,6 +216,18 @@ rx_handler_result_t br_handle_frame(stru
+ 
+ forward:
+ 	switch (p->state) {
++	case BR_STATE_DISABLED:
++		if (ether_addr_equal(p->br->dev->dev_addr, dest))
++			skb->pkt_type = PACKET_HOST;
++
++		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,
++			br_handle_local_finish))
++			break;
++
++		BR_INPUT_SKB_CB(skb)->brdev = p->br->dev;
++		br_pass_frame_up(skb);
++		break;
++
+ 	case BR_STATE_FORWARDING:
+ 		rhook = rcu_dereference(br_should_route_hook);
+ 		if (rhook) {
diff --git a/target/linux/generic/patches-3.10/130-mips_remove_plat_dma_functions.patch b/target/linux/generic/patches-3.10/130-mips_remove_plat_dma_functions.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/130-mips_remove_plat_dma_functions.patch
@@ -0,0 +1,200 @@
+From 151c4e4a06b0b8d16c2fd392bb0e33868b12357f Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@openwrt.org>
+Date: Mon, 12 Aug 2013 12:45:52 +0200
+Subject: [PATCH] MIPS: remove unnecessary platform dma helper functions
+
+Signed-off-by: Felix Fietkau <nbd@openwrt.org>
+---
+ arch/mips/include/asm/mach-cavium-octeon/dma-coherence.h | 12 ------------
+ arch/mips/include/asm/mach-generic/dma-coherence.h       | 10 ----------
+ arch/mips/include/asm/mach-ip27/dma-coherence.h          | 10 ----------
+ arch/mips/include/asm/mach-ip32/dma-coherence.h          | 11 -----------
+ arch/mips/include/asm/mach-jazz/dma-coherence.h          | 10 ----------
+ arch/mips/include/asm/mach-loongson/dma-coherence.h      | 10 ----------
+ arch/mips/include/asm/mach-powertv/dma-coherence.h       | 10 ----------
+ arch/mips/mm/dma-default.c                               |  4 +---
+ 8 files changed, 1 insertion(+), 76 deletions(-)
+
+Index: kernel_tree/arch/mips/include/asm/mach-cavium-octeon/dma-coherence.h
+===================================================================
+--- kernel_tree.orig/arch/mips/include/asm/mach-cavium-octeon/dma-coherence.h
++++ kernel_tree/arch/mips/include/asm/mach-cavium-octeon/dma-coherence.h
+@@ -46,22 +46,11 @@ static inline int plat_dma_supported(str
+ 	BUG();
+ }
+ 
+-static inline void plat_extra_sync_for_device(struct device *dev)
+-{
+-	BUG();
+-}
+-
+ static inline int plat_device_is_coherent(struct device *dev)
+ {
+ 	return 1;
+ }
+ 
+-static inline int plat_dma_mapping_error(struct device *dev,
+-					 dma_addr_t dma_addr)
+-{
+-	BUG();
+-}
+-
+ dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr);
+ phys_addr_t dma_to_phys(struct device *dev, dma_addr_t daddr);
+ 
+Index: kernel_tree/arch/mips/include/asm/mach-generic/dma-coherence.h
+===================================================================
+--- kernel_tree.orig/arch/mips/include/asm/mach-generic/dma-coherence.h
++++ kernel_tree/arch/mips/include/asm/mach-generic/dma-coherence.h
+@@ -47,16 +47,6 @@ static inline int plat_dma_supported(str
+ 	return 1;
+ }
+ 
+-static inline void plat_extra_sync_for_device(struct device *dev)
+-{
+-}
+-
+-static inline int plat_dma_mapping_error(struct device *dev,
+-					 dma_addr_t dma_addr)
+-{
+-	return 0;
+-}
+-
+ static inline int plat_device_is_coherent(struct device *dev)
+ {
+ #ifdef CONFIG_DMA_COHERENT
+Index: kernel_tree/arch/mips/include/asm/mach-ip27/dma-coherence.h
+===================================================================
+--- kernel_tree.orig/arch/mips/include/asm/mach-ip27/dma-coherence.h
++++ kernel_tree/arch/mips/include/asm/mach-ip27/dma-coherence.h
+@@ -58,16 +58,6 @@ static inline int plat_dma_supported(str
+ 	return 1;
+ }
+ 
+-static inline void plat_extra_sync_for_device(struct device *dev)
+-{
+-}
+-
+-static inline int plat_dma_mapping_error(struct device *dev,
+-					 dma_addr_t dma_addr)
+-{
+-	return 0;
+-}
+-
+ static inline int plat_device_is_coherent(struct device *dev)
+ {
+ 	return 1;		/* IP27 non-cohernet mode is unsupported */
+Index: kernel_tree/arch/mips/include/asm/mach-ip32/dma-coherence.h
+===================================================================
+--- kernel_tree.orig/arch/mips/include/asm/mach-ip32/dma-coherence.h
++++ kernel_tree/arch/mips/include/asm/mach-ip32/dma-coherence.h
+@@ -80,17 +80,6 @@ static inline int plat_dma_supported(str
+ 	return 1;
+ }
+ 
+-static inline void plat_extra_sync_for_device(struct device *dev)
+-{
+-	return;
+-}
+-
+-static inline int plat_dma_mapping_error(struct device *dev,
+-					 dma_addr_t dma_addr)
+-{
+-	return 0;
+-}
+-
+ static inline int plat_device_is_coherent(struct device *dev)
+ {
+ 	return 0;		/* IP32 is non-cohernet */
+Index: kernel_tree/arch/mips/include/asm/mach-jazz/dma-coherence.h
+===================================================================
+--- kernel_tree.orig/arch/mips/include/asm/mach-jazz/dma-coherence.h
++++ kernel_tree/arch/mips/include/asm/mach-jazz/dma-coherence.h
+@@ -48,16 +48,6 @@ static inline int plat_dma_supported(str
+ 	return 1;
+ }
+ 
+-static inline void plat_extra_sync_for_device(struct device *dev)
+-{
+-}
+-
+-static inline int plat_dma_mapping_error(struct device *dev,
+-					 dma_addr_t dma_addr)
+-{
+-	return 0;
+-}
+-
+ static inline int plat_device_is_coherent(struct device *dev)
+ {
+ 	return 0;
+Index: kernel_tree/arch/mips/include/asm/mach-loongson/dma-coherence.h
+===================================================================
+--- kernel_tree.orig/arch/mips/include/asm/mach-loongson/dma-coherence.h
++++ kernel_tree/arch/mips/include/asm/mach-loongson/dma-coherence.h
+@@ -53,16 +53,6 @@ static inline int plat_dma_supported(str
+ 	return 1;
+ }
+ 
+-static inline void plat_extra_sync_for_device(struct device *dev)
+-{
+-}
+-
+-static inline int plat_dma_mapping_error(struct device *dev,
+-					 dma_addr_t dma_addr)
+-{
+-	return 0;
+-}
+-
+ static inline int plat_device_is_coherent(struct device *dev)
+ {
+ 	return 0;
+Index: kernel_tree/arch/mips/include/asm/mach-powertv/dma-coherence.h
+===================================================================
+--- kernel_tree.orig/arch/mips/include/asm/mach-powertv/dma-coherence.h
++++ kernel_tree/arch/mips/include/asm/mach-powertv/dma-coherence.h
+@@ -99,16 +99,6 @@ static inline int plat_dma_supported(str
+ 	return 1;
+ }
+ 
+-static inline void plat_extra_sync_for_device(struct device *dev)
+-{
+-}
+-
+-static inline int plat_dma_mapping_error(struct device *dev,
+-					 dma_addr_t dma_addr)
+-{
+-	return 0;
+-}
+-
+ static inline int plat_device_is_coherent(struct device *dev)
+ {
+ 	return 0;
+Index: kernel_tree/arch/mips/mm/dma-default.c
+===================================================================
+--- kernel_tree.orig/arch/mips/mm/dma-default.c
++++ kernel_tree/arch/mips/mm/dma-default.c
+@@ -293,7 +293,6 @@ static void mips_dma_sync_single_for_cpu
+ static void mips_dma_sync_single_for_device(struct device *dev,
+ 	dma_addr_t dma_handle, size_t size, enum dma_data_direction direction)
+ {
+-	plat_extra_sync_for_device(dev);
+ 	if (!plat_device_is_coherent(dev))
+ 		__dma_sync(dma_addr_to_page(dev, dma_handle),
+ 			   dma_handle & ~PAGE_MASK, size, direction);
+@@ -327,7 +326,7 @@ static void mips_dma_sync_sg_for_device(
+ 
+ int mips_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
+ {
+-	return plat_dma_mapping_error(dev, dma_addr);
++	return 0;
+ }
+ 
+ int mips_dma_supported(struct device *dev, u64 mask)
+@@ -340,7 +339,6 @@ void dma_cache_sync(struct device *dev,
+ {
+ 	BUG_ON(direction == DMA_NONE);
+ 
+-	plat_extra_sync_for_device(dev);
+ 	if (!plat_device_is_coherent(dev))
+ 		__dma_sync_virtual(vaddr, size, direction);
+ }
diff --git a/target/linux/generic/patches-3.10/131-improve_noncoherent_dma_checks.patch b/target/linux/generic/patches-3.10/131-improve_noncoherent_dma_checks.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/131-improve_noncoherent_dma_checks.patch
@@ -0,0 +1,91 @@
+From d593f8fc627f8cdaee9c14e4d22b0770a09baaf1 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@openwrt.org>
+Date: Thu, 15 Aug 2013 10:47:47 +0200
+Subject: [PATCH] MIPS: improve checks for noncoherent DMA
+
+Only one MIPS development board actually supports enabling/disabling DMA
+coherency at runtime, so it's not a good idea to push the overhead of
+checking that configuration setting onto every other supported target as
+well.
+
+Signed-off-by: Felix Fietkau <nbd@openwrt.org>
+---
+ arch/mips/Kconfig                                  | 6 +++++-
+ arch/mips/include/asm/dma-coherence.h              | 7 +++++++
+ arch/mips/include/asm/mach-generic/dma-coherence.h | 4 ----
+ arch/mips/mm/dma-default.c                         | 2 ++
+ 4 files changed, 14 insertions(+), 5 deletions(-)
+
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -297,7 +297,7 @@ config MIPS_MALTA
+ 	select CEVT_R4K
+ 	select CSRC_R4K
+ 	select CSRC_GIC
+-	select DMA_NONCOHERENT
++	select DMA_MAYBE_COHERENT
+ 	select GENERIC_ISA_DMA
+ 	select HAVE_PCSPKR_PLATFORM
+ 	select IRQ_CPU
+@@ -948,6 +948,10 @@ config FW_CFE
+ config ARCH_DMA_ADDR_T_64BIT
+ 	def_bool (HIGHMEM && 64BIT_PHYS_ADDR) || 64BIT
+ 
++config DMA_MAYBE_COHERENT
++	select DMA_NONCOHERENT
++	bool
++
+ config DMA_COHERENT
+ 	bool
+ 
+--- a/arch/mips/include/asm/dma-coherence.h
++++ b/arch/mips/include/asm/dma-coherence.h
+@@ -9,7 +9,16 @@
+ #ifndef __ASM_DMA_COHERENCE_H
+ #define __ASM_DMA_COHERENCE_H
+ 
++#ifdef CONFIG_DMA_MAYBE_COHERENT
+ extern int coherentio;
+ extern int hw_coherentio;
++#else
++#ifdef CONFIG_DMA_COHERENT
++#define coherentio	1
++#else
++#define coherentio	0
++#endif
++#define hw_coherentio	0
++#endif /* CONFIG_DMA_MAYBE_COHERENT */
+ 
+ #endif
+--- a/arch/mips/include/asm/mach-generic/dma-coherence.h
++++ b/arch/mips/include/asm/mach-generic/dma-coherence.h
+@@ -49,11 +49,7 @@ static inline int plat_dma_supported(str
+ 
+ static inline int plat_device_is_coherent(struct device *dev)
+ {
+-#ifdef CONFIG_DMA_COHERENT
+-	return 1;
+-#else
+ 	return coherentio;
+-#endif
+ }
+ 
+ #endif /* __ASM_MACH_GENERIC_DMA_COHERENCE_H */
+--- a/arch/mips/mm/dma-default.c
++++ b/arch/mips/mm/dma-default.c
+@@ -22,6 +22,7 @@
+ 
+ #include <dma-coherence.h>
+ 
++#ifdef CONFIG_DMA_MAYBE_COHERENT
+ int coherentio = 0;	/* User defined DMA coherency from command line. */
+ EXPORT_SYMBOL_GPL(coherentio);
+ int hw_coherentio = 0;	/* Actual hardware supported DMA coherency setting. */
+@@ -41,6 +42,7 @@ static int __init setnocoherentio(char *
+ 	return 0;
+ }
+ early_param("nocoherentio", setnocoherentio);
++#endif
+ 
+ static inline struct page *dma_addr_to_page(struct device *dev,
+ 	dma_addr_t dma_addr)
diff --git a/target/linux/generic/patches-3.10/132-mips_inline_dma_ops.patch b/target/linux/generic/patches-3.10/132-mips_inline_dma_ops.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/132-mips_inline_dma_ops.patch
@@ -0,0 +1,685 @@
+From 2c58080407554e1bac8fd50d23cb02420524caed Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@openwrt.org>
+Date: Mon, 12 Aug 2013 12:50:22 +0200
+Subject: [PATCH] MIPS: partially inline dma ops
+
+Several DMA ops are no-op on many platforms, and the indirection through
+the mips_dma_map_ops function table is causing the compiler to emit
+unnecessary code.
+
+Inlining visibly improves network performance in my tests (on a 24Kc
+based system), and also slightly reduces code size of a few drivers.
+
+Signed-off-by: Felix Fietkau <nbd@openwrt.org>
+---
+ arch/mips/Kconfig                   |   4 +
+ arch/mips/include/asm/dma-mapping.h | 360 +++++++++++++++++++++++++++++++++++-
+ arch/mips/mm/dma-default.c          | 163 ++--------------
+ 3 files changed, 373 insertions(+), 154 deletions(-)
+
+diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -1431,6 +1431,7 @@ config CPU_CAVIUM_OCTEON
+ 	select LIBFDT
+ 	select USE_OF
+ 	select USB_EHCI_BIG_ENDIAN_MMIO
++	select SYS_HAS_DMA_OPS
+ 	help
+ 	  The Cavium Octeon processor is a highly integrated chip containing
+ 	  many ethernet hardware widgets for networking tasks. The processor
+@@ -1651,6 +1652,9 @@ config SYS_HAS_CPU_XLR
+ config SYS_HAS_CPU_XLP
+ 	bool
+ 
++config SYS_HAS_DMA_OPS
++	bool
++
+ #
+ # CPU may reorder R->R, R->W, W->R, W->W
+ # Reordering beyond LL and SC is handled in WEAK_REORDERING_BEYOND_LLSC
+diff --git a/arch/mips/include/asm/dma-mapping.h b/arch/mips/include/asm/dma-mapping.h
+--- a/arch/mips/include/asm/dma-mapping.h
++++ b/arch/mips/include/asm/dma-mapping.h
+@@ -1,6 +1,12 @@
+ #ifndef _ASM_DMA_MAPPING_H
+ #define _ASM_DMA_MAPPING_H
+ 
++#include <linux/kmemcheck.h>
++#include <linux/bug.h>
++#include <linux/scatterlist.h>
++#include <linux/dma-debug.h>
++#include <linux/dma-attrs.h>
++
+ #include <asm/scatterlist.h>
+ #include <asm/dma-coherence.h>
+ #include <asm/cache.h>
+@@ -12,12 +18,47 @@
+ 
+ extern struct dma_map_ops *mips_dma_map_ops;
+ 
++void __dma_sync(struct page *page, unsigned long offset, size_t size,
++		enum dma_data_direction direction);
++void *mips_dma_alloc_coherent(struct device *dev, size_t size,
++			      dma_addr_t *dma_handle, gfp_t gfp,
++			      struct dma_attrs *attrs);
++void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
++			    dma_addr_t dma_handle, struct dma_attrs *attrs);
++
+ static inline struct dma_map_ops *get_dma_ops(struct device *dev)
+ {
++#ifdef CONFIG_SYS_HAS_DMA_OPS
+ 	if (dev && dev->archdata.dma_ops)
+ 		return dev->archdata.dma_ops;
+ 	else
+ 		return mips_dma_map_ops;
++#else
++	return NULL;
++#endif
++}
++
++/*
++ * Warning on the terminology - Linux calls an uncached area coherent;
++ * MIPS terminology calls memory areas with hardware maintained coherency
++ * coherent.
++ */
++
++static inline int cpu_is_noncoherent_r10000(struct device *dev)
++{
++#ifndef CONFIG_SYS_HAS_CPU_R10000
++	return 0;
++#endif
++	return !plat_device_is_coherent(dev) &&
++	       (current_cpu_type() == CPU_R10000 ||
++	       current_cpu_type() == CPU_R12000);
++}
++
++static inline struct page *dma_addr_to_page(struct device *dev,
++	dma_addr_t dma_addr)
++{
++	return pfn_to_page(
++		plat_dma_addr_to_phys(dev, dma_addr) >> PAGE_SHIFT);
+ }
+ 
+ static inline bool dma_capable(struct device *dev, dma_addr_t addr, size_t size)
+@@ -30,12 +71,309 @@ static inline bool dma_capable(struct de
+ 
+ static inline void dma_mark_clean(void *addr, size_t size) {}
+ 
+-#include <asm-generic/dma-mapping-common.h>
++static inline dma_addr_t dma_map_single_attrs(struct device *dev, void *ptr,
++					      size_t size,
++					      enum dma_data_direction dir,
++					      struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	unsigned long offset = (unsigned long)ptr & ~PAGE_MASK;
++	struct page *page = virt_to_page(ptr);
++	dma_addr_t addr;
++
++	kmemcheck_mark_initialized(ptr, size);
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		addr = ops->map_page(dev, page, offset, size, dir, attrs);
++	} else {
++		if (!plat_device_is_coherent(dev))
++			__dma_sync(page, offset, size, dir);
++
++		addr = plat_map_dma_mem_page(dev, page) + offset;
++	}
++	debug_dma_map_page(dev, page, offset, size, dir, addr, true);
++	return addr;
++}
++
++static inline void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr,
++					  size_t size,
++					  enum dma_data_direction dir,
++					  struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		ops->unmap_page(dev, addr, size, dir, attrs);
++	} else {
++		if (cpu_is_noncoherent_r10000(dev))
++			__dma_sync(dma_addr_to_page(dev, addr),
++				   addr & ~PAGE_MASK, size, dir);
++
++		plat_unmap_dma_mem(dev, addr, size, dir);
++	}
++	debug_dma_unmap_page(dev, addr, size, dir, true);
++}
++
++static inline int dma_map_sg_attrs(struct device *dev, struct scatterlist *sg,
++				   int nents, enum dma_data_direction dir,
++				   struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	int i, ents;
++	struct scatterlist *s;
++
++	for_each_sg(sg, s, nents, i)
++		kmemcheck_mark_initialized(sg_virt(s), s->length);
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		ents = ops->map_sg(dev, sg, nents, dir, attrs);
++	} else {
++		for_each_sg(sg, s, nents, i) {
++			struct page *page = sg_page(s);
++
++			if (!plat_device_is_coherent(dev))
++				__dma_sync(page, s->offset, s->length, dir);
++			s->dma_address =
++				plat_map_dma_mem_page(dev, page) + s->offset;
++		}
++		ents = nents;
++	}
++	debug_dma_map_sg(dev, sg, nents, ents, dir);
++
++	return ents;
++}
++
++static inline void dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sg,
++				      int nents, enum dma_data_direction dir,
++				      struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	struct scatterlist *s;
++	int i;
++
++	BUG_ON(!valid_dma_direction(dir));
++	debug_dma_unmap_sg(dev, sg, nents, dir);
++	if (ops) {
++		ops->unmap_sg(dev, sg, nents, dir, attrs);
++		return;
++	}
++
++	for_each_sg(sg, s, nents, i) {
++		if (!plat_device_is_coherent(dev) && dir != DMA_TO_DEVICE)
++			__dma_sync(sg_page(s), s->offset, s->length, dir);
++		plat_unmap_dma_mem(dev, s->dma_address, s->length, dir);
++	}
++}
++
++static inline dma_addr_t dma_map_page(struct device *dev, struct page *page,
++				      size_t offset, size_t size,
++				      enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	dma_addr_t addr;
++
++	kmemcheck_mark_initialized(page_address(page) + offset, size);
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		addr = ops->map_page(dev, page, offset, size, dir, NULL);
++	} else {
++		if (!plat_device_is_coherent(dev))
++			__dma_sync(page, offset, size, dir);
++
++		addr = plat_map_dma_mem_page(dev, page) + offset;
++	}
++	debug_dma_map_page(dev, page, offset, size, dir, addr, false);
++
++	return addr;
++}
++
++static inline void dma_unmap_page(struct device *dev, dma_addr_t addr,
++				  size_t size, enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops) {
++		ops->unmap_page(dev, addr, size, dir, NULL);
++	} else {
++		if (cpu_is_noncoherent_r10000(dev))
++			__dma_sync(dma_addr_to_page(dev, addr),
++				   addr & ~PAGE_MASK, size, dir);
++
++		plat_unmap_dma_mem(dev, addr, size, dir);
++	}
++	debug_dma_unmap_page(dev, addr, size, dir, false);
++}
++
++static inline void dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr,
++					   size_t size,
++					   enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops)
++		ops->sync_single_for_cpu(dev, addr, size, dir);
++	else if (cpu_is_noncoherent_r10000(dev))
++		__dma_sync(dma_addr_to_page(dev, addr),
++			   addr & ~PAGE_MASK, size, dir);
++	debug_dma_sync_single_for_cpu(dev, addr, size, dir);
++}
++
++static inline void dma_sync_single_for_device(struct device *dev,
++					      dma_addr_t addr, size_t size,
++					      enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops)
++		ops->sync_single_for_device(dev, addr, size, dir);
++	else if (!plat_device_is_coherent(dev))
++		__dma_sync(dma_addr_to_page(dev, addr),
++			   addr & ~PAGE_MASK, size, dir);
++	debug_dma_sync_single_for_device(dev, addr, size, dir);
++}
++
++static inline void dma_sync_single_range_for_cpu(struct device *dev,
++						 dma_addr_t addr,
++						 unsigned long offset,
++						 size_t size,
++						 enum dma_data_direction dir)
++{
++	const struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops)
++		ops->sync_single_for_cpu(dev, addr + offset, size, dir);
++	else if (cpu_is_noncoherent_r10000(dev))
++		__dma_sync(dma_addr_to_page(dev, addr + offset),
++			   (addr + offset) & ~PAGE_MASK, size, dir);
++	debug_dma_sync_single_range_for_cpu(dev, addr, offset, size, dir);
++}
++
++static inline void dma_sync_single_range_for_device(struct device *dev,
++						    dma_addr_t addr,
++						    unsigned long offset,
++						    size_t size,
++						    enum dma_data_direction dir)
++{
++	const struct dma_map_ops *ops = get_dma_ops(dev);
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops)
++		ops->sync_single_for_device(dev, addr + offset, size, dir);
++	else if (!plat_device_is_coherent(dev))
++		__dma_sync(dma_addr_to_page(dev, addr + offset),
++			   (addr + offset) & ~PAGE_MASK, size, dir);
++	debug_dma_sync_single_range_for_device(dev, addr, offset, size, dir);
++}
++
++static inline void
++dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
++		    int nelems, enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	struct scatterlist *s;
++	int i;
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops)
++		ops->sync_sg_for_cpu(dev, sg, nelems, dir);
++	else if (cpu_is_noncoherent_r10000(dev)) {
++		for_each_sg(sg, s, nelems, i)
++			__dma_sync(sg_page(s), s->offset, s->length, dir);
++	}
++	debug_dma_sync_sg_for_cpu(dev, sg, nelems, dir);
++}
++
++static inline void
++dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
++		       int nelems, enum dma_data_direction dir)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	struct scatterlist *s;
++	int i;
++
++	BUG_ON(!valid_dma_direction(dir));
++	if (ops)
++		ops->sync_sg_for_device(dev, sg, nelems, dir);
++	else if (!plat_device_is_coherent(dev)) {
++		for_each_sg(sg, s, nelems, i)
++			__dma_sync(sg_page(s), s->offset, s->length, dir);
++	}
++	debug_dma_sync_sg_for_device(dev, sg, nelems, dir);
++
++}
++
++#define dma_map_single(d, a, s, r) dma_map_single_attrs(d, a, s, r, NULL)
++#define dma_unmap_single(d, a, s, r) dma_unmap_single_attrs(d, a, s, r, NULL)
++#define dma_map_sg(d, s, n, r) dma_map_sg_attrs(d, s, n, r, NULL)
++#define dma_unmap_sg(d, s, n, r) dma_unmap_sg_attrs(d, s, n, r, NULL)
++
++extern int dma_common_mmap(struct device *dev, struct vm_area_struct *vma,
++			   void *cpu_addr, dma_addr_t dma_addr, size_t size);
++
++/**
++ * dma_mmap_attrs - map a coherent DMA allocation into user space
++ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
++ * @vma: vm_area_struct describing requested user mapping
++ * @cpu_addr: kernel CPU-view address returned from dma_alloc_attrs
++ * @handle: device-view address returned from dma_alloc_attrs
++ * @size: size of memory originally requested in dma_alloc_attrs
++ * @attrs: attributes of mapping properties requested in dma_alloc_attrs
++ *
++ * Map a coherent DMA buffer previously allocated by dma_alloc_attrs
++ * into user space.  The coherent DMA buffer must not be freed by the
++ * driver until the user space mapping has been released.
++ */
++static inline int
++dma_mmap_attrs(struct device *dev, struct vm_area_struct *vma, void *cpu_addr,
++	       dma_addr_t dma_addr, size_t size, struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	BUG_ON(!ops);
++	if (ops && ops->mmap)
++		return ops->mmap(dev, vma, cpu_addr, dma_addr, size, attrs);
++	return dma_common_mmap(dev, vma, cpu_addr, dma_addr, size);
++}
++
++#define dma_mmap_coherent(d, v, c, h, s) dma_mmap_attrs(d, v, c, h, s, NULL)
++
++static inline int dma_mmap_writecombine(struct device *dev, struct vm_area_struct *vma,
++		      void *cpu_addr, dma_addr_t dma_addr, size_t size)
++{
++	DEFINE_DMA_ATTRS(attrs);
++	dma_set_attr(DMA_ATTR_WRITE_COMBINE, &attrs);
++	return dma_mmap_attrs(dev, vma, cpu_addr, dma_addr, size, &attrs);
++}
++
++int
++dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,
++		       void *cpu_addr, dma_addr_t dma_addr, size_t size);
++
++static inline int
++dma_get_sgtable_attrs(struct device *dev, struct sg_table *sgt, void *cpu_addr,
++		      dma_addr_t dma_addr, size_t size, struct dma_attrs *attrs)
++{
++	struct dma_map_ops *ops = get_dma_ops(dev);
++	BUG_ON(!ops);
++	if (ops && ops->get_sgtable)
++		return ops->get_sgtable(dev, sgt, cpu_addr, dma_addr, size,
++					attrs);
++	return dma_common_get_sgtable(dev, sgt, cpu_addr, dma_addr, size);
++}
++
++#define dma_get_sgtable(d, t, v, h, s) dma_get_sgtable_attrs(d, t, v, h, s, NULL)
++
+ 
+ static inline int dma_supported(struct device *dev, u64 mask)
+ {
+ 	struct dma_map_ops *ops = get_dma_ops(dev);
+-	return ops->dma_supported(dev, mask);
++	if (ops)
++		return ops->dma_supported(dev, mask);
++	return plat_dma_supported(dev, mask);
+ }
+ 
+ static inline int dma_mapping_error(struct device *dev, u64 mask)
+@@ -43,7 +381,9 @@ static inline int dma_mapping_error(stru
+ 	struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+ 	debug_dma_mapping_error(dev, mask);
+-	return ops->mapping_error(dev, mask);
++	if (ops)
++		return ops->mapping_error(dev, mask);
++	return 0;
+ }
+ 
+ static inline int
+@@ -69,7 +409,11 @@ static inline void *dma_alloc_attrs(stru
+ 	void *ret;
+ 	struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+-	ret = ops->alloc(dev, size, dma_handle, gfp, attrs);
++	if (ops)
++		ret = ops->alloc(dev, size, dma_handle, gfp, attrs);
++	else
++		ret = mips_dma_alloc_coherent(dev, size, dma_handle, gfp,
++					      attrs);
+ 
+ 	debug_dma_alloc_coherent(dev, size, *dma_handle, ret);
+ 
+@@ -84,7 +428,10 @@ static inline void dma_free_attrs(struct
+ {
+ 	struct dma_map_ops *ops = get_dma_ops(dev);
+ 
+-	ops->free(dev, size, vaddr, dma_handle, attrs);
++	if (ops)
++		ops->free(dev, size, vaddr, dma_handle, attrs);
++	else
++		mips_dma_free_coherent(dev, size, vaddr, dma_handle, attrs);
+ 
+ 	debug_dma_free_coherent(dev, size, vaddr, dma_handle);
+ }
+diff --git a/arch/mips/mm/dma-default.c b/arch/mips/mm/dma-default.c
+--- a/arch/mips/mm/dma-default.c
++++ b/arch/mips/mm/dma-default.c
+@@ -24,7 +24,7 @@
+ 
+ #ifdef CONFIG_DMA_MAYBE_COHERENT
+ int coherentio = 0;	/* User defined DMA coherency from command line. */
+-EXPORT_SYMBOL_GPL(coherentio);
++EXPORT_SYMBOL(coherentio);
+ int hw_coherentio = 0;	/* Actual hardware supported DMA coherency setting. */
+ 
+ static int __init setcoherentio(char *str)
+@@ -43,31 +43,7 @@ static int __init setnocoherentio(char *
+ }
+ early_param("nocoherentio", setnocoherentio);
+ #endif
+-
+-static inline struct page *dma_addr_to_page(struct device *dev,
+-	dma_addr_t dma_addr)
+-{
+-	return pfn_to_page(
+-		plat_dma_addr_to_phys(dev, dma_addr) >> PAGE_SHIFT);
+-}
+-
+-/*
+- * The affected CPUs below in 'cpu_needs_post_dma_flush()' can
+- * speculatively fill random cachelines with stale data at any time,
+- * requiring an extra flush post-DMA.
+- *
+- * Warning on the terminology - Linux calls an uncached area coherent;
+- * MIPS terminology calls memory areas with hardware maintained coherency
+- * coherent.
+- */
+-static inline int cpu_needs_post_dma_flush(struct device *dev)
+-{
+-	return !plat_device_is_coherent(dev) &&
+-	       (current_cpu_type() == CPU_R10000 ||
+-		current_cpu_type() == CPU_R12000 ||
+-		current_cpu_type() == CPU_BMIPS5000);
+-}
+-
++	   
+ static gfp_t massage_gfp_flags(const struct device *dev, gfp_t gfp)
+ {
+ 	gfp_t dma_flag;
+@@ -123,8 +99,9 @@ void *dma_alloc_noncoherent(struct devic
+ }
+ EXPORT_SYMBOL(dma_alloc_noncoherent);
+ 
+-static void *mips_dma_alloc_coherent(struct device *dev, size_t size,
+-	dma_addr_t * dma_handle, gfp_t gfp, struct dma_attrs *attrs)
++void *mips_dma_alloc_coherent(struct device *dev, size_t size,
++			      dma_addr_t *dma_handle, gfp_t gfp,
++			      struct dma_attrs *attrs)
+ {
+ 	void *ret;
+ 
+@@ -148,6 +125,7 @@ static void *mips_dma_alloc_coherent(str
+ 
+ 	return ret;
+ }
++EXPORT_SYMBOL(mips_dma_alloc_coherent);
+ 
+ 
+ void dma_free_noncoherent(struct device *dev, size_t size, void *vaddr,
+@@ -158,8 +136,8 @@ void dma_free_noncoherent(struct device 
+ }
+ EXPORT_SYMBOL(dma_free_noncoherent);
+ 
+-static void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
+-	dma_addr_t dma_handle, struct dma_attrs *attrs)
++void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
++			    dma_addr_t dma_handle, struct dma_attrs *attrs)
+ {
+ 	unsigned long addr = (unsigned long) vaddr;
+ 	int order = get_order(size);
+@@ -174,6 +152,7 @@ static void mips_dma_free_coherent(struc
+ 
+ 	free_pages(addr, get_order(size));
+ }
++EXPORT_SYMBOL(mips_dma_free_coherent);
+ 
+ static inline void __dma_sync_virtual(void *addr, size_t size,
+ 	enum dma_data_direction direction)
+@@ -202,8 +181,8 @@ static inline void __dma_sync_virtual(vo
+  * If highmem is not configured then the bulk of this loop gets
+  * optimized out.
+  */
+-static inline void __dma_sync(struct page *page,
+-	unsigned long offset, size_t size, enum dma_data_direction direction)
++void __dma_sync(struct page *page, unsigned long offset, size_t size,
++		enum dma_data_direction direction)
+ {
+ 	size_t left = size;
+ 
+@@ -232,109 +211,7 @@ static inline void __dma_sync(struct pag
+ 		left -= len;
+ 	} while (left);
+ }
+-
+-static void mips_dma_unmap_page(struct device *dev, dma_addr_t dma_addr,
+-	size_t size, enum dma_data_direction direction, struct dma_attrs *attrs)
+-{
+-	if (cpu_needs_post_dma_flush(dev))
+-		__dma_sync(dma_addr_to_page(dev, dma_addr),
+-			   dma_addr & ~PAGE_MASK, size, direction);
+-
+-	plat_unmap_dma_mem(dev, dma_addr, size, direction);
+-}
+-
+-static int mips_dma_map_sg(struct device *dev, struct scatterlist *sg,
+-	int nents, enum dma_data_direction direction, struct dma_attrs *attrs)
+-{
+-	int i;
+-
+-	for (i = 0; i < nents; i++, sg++) {
+-		if (!plat_device_is_coherent(dev))
+-			__dma_sync(sg_page(sg), sg->offset, sg->length,
+-				   direction);
+-		sg->dma_address = plat_map_dma_mem_page(dev, sg_page(sg)) +
+-				  sg->offset;
+-	}
+-
+-	return nents;
+-}
+-
+-static dma_addr_t mips_dma_map_page(struct device *dev, struct page *page,
+-	unsigned long offset, size_t size, enum dma_data_direction direction,
+-	struct dma_attrs *attrs)
+-{
+-	if (!plat_device_is_coherent(dev))
+-		__dma_sync(page, offset, size, direction);
+-
+-	return plat_map_dma_mem_page(dev, page) + offset;
+-}
+-
+-static void mips_dma_unmap_sg(struct device *dev, struct scatterlist *sg,
+-	int nhwentries, enum dma_data_direction direction,
+-	struct dma_attrs *attrs)
+-{
+-	int i;
+-
+-	for (i = 0; i < nhwentries; i++, sg++) {
+-		if (!plat_device_is_coherent(dev) &&
+-		    direction != DMA_TO_DEVICE)
+-			__dma_sync(sg_page(sg), sg->offset, sg->length,
+-				   direction);
+-		plat_unmap_dma_mem(dev, sg->dma_address, sg->length, direction);
+-	}
+-}
+-
+-static void mips_dma_sync_single_for_cpu(struct device *dev,
+-	dma_addr_t dma_handle, size_t size, enum dma_data_direction direction)
+-{
+-	if (cpu_needs_post_dma_flush(dev))
+-		__dma_sync(dma_addr_to_page(dev, dma_handle),
+-			   dma_handle & ~PAGE_MASK, size, direction);
+-}
+-
+-static void mips_dma_sync_single_for_device(struct device *dev,
+-	dma_addr_t dma_handle, size_t size, enum dma_data_direction direction)
+-{
+-	if (!plat_device_is_coherent(dev))
+-		__dma_sync(dma_addr_to_page(dev, dma_handle),
+-			   dma_handle & ~PAGE_MASK, size, direction);
+-}
+-
+-static void mips_dma_sync_sg_for_cpu(struct device *dev,
+-	struct scatterlist *sg, int nelems, enum dma_data_direction direction)
+-{
+-	int i;
+-
+-	/* Make sure that gcc doesn't leave the empty loop body.  */
+-	for (i = 0; i < nelems; i++, sg++) {
+-		if (cpu_needs_post_dma_flush(dev))
+-			__dma_sync(sg_page(sg), sg->offset, sg->length,
+-				   direction);
+-	}
+-}
+-
+-static void mips_dma_sync_sg_for_device(struct device *dev,
+-	struct scatterlist *sg, int nelems, enum dma_data_direction direction)
+-{
+-	int i;
+-
+-	/* Make sure that gcc doesn't leave the empty loop body.  */
+-	for (i = 0; i < nelems; i++, sg++) {
+-		if (!plat_device_is_coherent(dev))
+-			__dma_sync(sg_page(sg), sg->offset, sg->length,
+-				   direction);
+-	}
+-}
+-
+-int mips_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
+-{
+-	return 0;
+-}
+-
+-int mips_dma_supported(struct device *dev, u64 mask)
+-{
+-	return plat_dma_supported(dev, mask);
+-}
++EXPORT_SYMBOL(__dma_sync);
+ 
+ void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
+ 			 enum dma_data_direction direction)
+@@ -347,23 +224,10 @@ void dma_cache_sync(struct device *dev, 
+ 
+ EXPORT_SYMBOL(dma_cache_sync);
+ 
+-static struct dma_map_ops mips_default_dma_map_ops = {
+-	.alloc = mips_dma_alloc_coherent,
+-	.free = mips_dma_free_coherent,
+-	.map_page = mips_dma_map_page,
+-	.unmap_page = mips_dma_unmap_page,
+-	.map_sg = mips_dma_map_sg,
+-	.unmap_sg = mips_dma_unmap_sg,
+-	.sync_single_for_cpu = mips_dma_sync_single_for_cpu,
+-	.sync_single_for_device = mips_dma_sync_single_for_device,
+-	.sync_sg_for_cpu = mips_dma_sync_sg_for_cpu,
+-	.sync_sg_for_device = mips_dma_sync_sg_for_device,
+-	.mapping_error = mips_dma_mapping_error,
+-	.dma_supported = mips_dma_supported
+-};
+-
+-struct dma_map_ops *mips_dma_map_ops = &mips_default_dma_map_ops;
++#ifdef CONFIG_SYS_HAS_DMA_OPS
++struct dma_map_ops *mips_dma_map_ops = NULL;
+ EXPORT_SYMBOL(mips_dma_map_ops);
++#endif
+ 
+ #define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
+ 
diff --git a/target/linux/generic/patches-3.10/200-fix_localversion.patch b/target/linux/generic/patches-3.10/200-fix_localversion.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/200-fix_localversion.patch
@@ -0,0 +1,11 @@
+--- a/scripts/setlocalversion
++++ b/scripts/setlocalversion
+@@ -167,7 +167,7 @@ else
+ 	# annotated or signed tagged state (as git describe only
+ 	# looks at signed or annotated tags - git tag -a/-s) and
+ 	# LOCALVERSION= is not specified
+-	if test "${LOCALVERSION+set}" != "set"; then
++	if test "${CONFIG_LOCALVERSION+set}" != "set"; then
+ 		scm=$(scm_version --short)
+ 		res="$res${scm:++}"
+ 	fi
diff --git a/target/linux/generic/patches-3.10/201-extra_optimization.patch b/target/linux/generic/patches-3.10/201-extra_optimization.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/201-extra_optimization.patch
@@ -0,0 +1,14 @@
+--- a/Makefile
++++ b/Makefile
+@@ -571,9 +571,9 @@ endif # $(dot-config)
+ all: vmlinux
+ 
+ ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
+-KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)
++KBUILD_CFLAGS	+= -Os $(EXTRA_OPTIMIZATION) $(call cc-disable-warning,maybe-uninitialized,)
+ else
+-KBUILD_CFLAGS	+= -O2
++KBUILD_CFLAGS	+= -O2 -fno-reorder-blocks -fno-tree-ch $(EXTRA_OPTIMIZATION)
+ endif
+ 
+ include $(srctree)/arch/$(SRCARCH)/Makefile
diff --git a/target/linux/generic/patches-3.10/202-reduce_module_size.patch b/target/linux/generic/patches-3.10/202-reduce_module_size.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/202-reduce_module_size.patch
@@ -0,0 +1,13 @@
+Index: kernel_tree/Makefile
+===================================================================
+--- kernel_tree.orig/Makefile
++++ kernel_tree/Makefile
+@@ -381,7 +381,7 @@ KBUILD_CFLAGS_KERNEL :=
+ KBUILD_AFLAGS   := -D__ASSEMBLY__
+ KBUILD_AFLAGS_MODULE  := -DMODULE
+ KBUILD_CFLAGS_MODULE  := -DMODULE
+-KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds
++KBUILD_LDFLAGS_MODULE = -T $(srctree)/scripts/module-common.lds $(if $(CONFIG_PROFILING),,-s)
+ 
+ # Read KERNELRELEASE from include/config/kernel.release (if it exists)
+ KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
diff --git a/target/linux/generic/patches-3.10/203-kallsyms_uncompressed.patch b/target/linux/generic/patches-3.10/203-kallsyms_uncompressed.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/203-kallsyms_uncompressed.patch
@@ -0,0 +1,108 @@
+--- a/scripts/kallsyms.c
++++ b/scripts/kallsyms.c
+@@ -54,6 +54,7 @@ static struct text_range text_ranges[] =
+ static struct sym_entry *table;
+ static unsigned int table_size, table_cnt;
+ static int all_symbols = 0;
++static int uncompressed = 0;
+ static char symbol_prefix_char = '\0';
+ static unsigned long long kernel_start_addr = 0;
+ 
+@@ -367,6 +368,9 @@ static void write_src(void)
+ 
+ 	free(markers);
+ 
++	if (uncompressed)
++		return;
++
+ 	output_label("kallsyms_token_table");
+ 	off = 0;
+ 	for (i = 0; i < 256; i++) {
+@@ -425,6 +429,9 @@ static void *find_token(unsigned char *s
+ {
+ 	int i;
+ 
++	if (uncompressed)
++		return NULL;
++
+ 	for (i = 0; i < len - 1; i++) {
+ 		if (str[i] == token[0] && str[i+1] == token[1])
+ 			return &str[i];
+@@ -497,6 +504,9 @@ static void optimize_result(void)
+ {
+ 	int i, best;
+ 
++	if (uncompressed)
++		return;
++
+ 	/* using the '\0' symbol last allows compress_symbols to use standard
+ 	 * fast string functions */
+ 	for (i = 255; i >= 0; i--) {
+@@ -656,7 +666,9 @@ int main(int argc, char **argv)
+ 			} else if (strncmp(argv[i], "--page-offset=", 14) == 0) {
+ 				const char *p = &argv[i][14];
+ 				kernel_start_addr = strtoull(p, NULL, 16);
+-			} else
++			} else if (strcmp(argv[i], "--uncompressed") == 0)
++				uncompressed = 1;
++			else
+ 				usage();
+ 		}
+ 	} else if (argc != 1)
+--- a/init/Kconfig
++++ b/init/Kconfig
+@@ -1245,6 +1245,17 @@ config SYSCTL_ARCH_UNALIGN_ALLOW
+ 	  the unaligned access emulation.
+ 	  see arch/parisc/kernel/unaligned.c for reference
+ 
++config KALLSYMS_UNCOMPRESSED
++	bool "Keep kallsyms uncompressed"
++	depends on KALLSYMS
++	help
++		Normally kallsyms contains compressed symbols (using a token table),
++		reducing the uncompressed kernel image size. Keeping the symbol table
++		uncompressed significantly improves the size of this part in compressed
++		kernel images.
++
++		Say N unless you need compressed kernel images to be small.
++
+ config HOTPLUG
+ 	def_bool y
+ 
+--- a/scripts/link-vmlinux.sh
++++ b/scripts/link-vmlinux.sh
+@@ -84,6 +84,10 @@ kallsyms()
+ 
+ 	kallsymopt="${kallsymopt} --page-offset=$CONFIG_PAGE_OFFSET"
+ 
++	if [ -n "${CONFIG_KALLSYMS_UNCOMPRESSED}" ]; then
++		kallsymopt="${kallsymopt} --uncompressed"
++	fi
++
+ 	local aflags="${KBUILD_AFLAGS} ${KBUILD_AFLAGS_KERNEL}               \
+ 		      ${NOSTDINC_FLAGS} ${LINUXINCLUDE} ${KBUILD_CPPFLAGS}"
+ 
+--- a/kernel/kallsyms.c
++++ b/kernel/kallsyms.c
+@@ -108,6 +108,11 @@ static unsigned int kallsyms_expand_symb
+ 	 * For every byte on the compressed symbol data, copy the table
+ 	 * entry for that byte.
+ 	 */
++#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
++	memcpy(result, data + 1, len - 1);
++	result += len - 1;
++	len = 0;
++#endif
+ 	while (len) {
+ 		tptr = &kallsyms_token_table[kallsyms_token_index[*data]];
+ 		data++;
+@@ -140,6 +145,9 @@ tail:
+  */
+ static char kallsyms_get_symbol_type(unsigned int off)
+ {
++#ifdef CONFIG_KALLSYMS_UNCOMPRESSED
++	return kallsyms_names[off + 1];
++#endif
+ 	/*
+ 	 * Get just the first code, look it up in the token table,
+ 	 * and return the first char from this token.
diff --git a/target/linux/generic/patches-3.10/204-module_strip.patch b/target/linux/generic/patches-3.10/204-module_strip.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/204-module_strip.patch
@@ -0,0 +1,210 @@
+From: Felix Fietkau <nbd@openwrt.org>
+Subject: [PATCH] build: add a hack for removing non-essential module info
+
+Signed-off-by: Felix Fietkau <nbd@openwrt.org>
+---
+Index: kernel_tree/include/linux/module.h
+===================================================================
+--- kernel_tree.orig/include/linux/module.h
++++ kernel_tree/include/linux/module.h
+@@ -82,7 +82,7 @@ void sort_extable(struct exception_table
+ void sort_main_extable(void);
+ void trim_init_extable(struct module *m);
+ 
+-#ifdef MODULE
++#if defined(MODULE) && !defined(CONFIG_MODULE_STRIPPED)
+ #define MODULE_GENERIC_TABLE(gtype,name)			\
+ extern const struct gtype##_id __mod_##gtype##_table		\
+   __attribute__ ((unused, alias(__stringify(name))))
+@@ -93,9 +93,10 @@ extern const struct gtype##_id __mod_##g
+ 
+ /* Generic info of form tag = "info" */
+ #define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)
++#define MODULE_INFO_STRIP(tag, info) __MODULE_INFO_STRIP(tag, tag, info)
+ 
+ /* For userspace: you can also call me... */
+-#define MODULE_ALIAS(_alias) MODULE_INFO(alias, _alias)
++#define MODULE_ALIAS(_alias) MODULE_INFO_STRIP(alias, _alias)
+ 
+ /*
+  * The following license idents are currently accepted as indicating free
+@@ -131,10 +132,10 @@ extern const struct gtype##_id __mod_##g
+  * Author(s), use "Name <email>" or just "Name", for multiple
+  * authors use multiple MODULE_AUTHOR() statements/lines.
+  */
+-#define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)
++#define MODULE_AUTHOR(_author) MODULE_INFO_STRIP(author, _author)
+   
+ /* What your module does. */
+-#define MODULE_DESCRIPTION(_description) MODULE_INFO(description, _description)
++#define MODULE_DESCRIPTION(_description) MODULE_INFO_STRIP(description, _description)
+ 
+ #define MODULE_DEVICE_TABLE(type,name)		\
+   MODULE_GENERIC_TABLE(type##_device,name)
+@@ -155,7 +156,9 @@ extern const struct gtype##_id __mod_##g
+ */
+ 
+ #if defined(MODULE) || !defined(CONFIG_SYSFS)
+-#define MODULE_VERSION(_version) MODULE_INFO(version, _version)
++#define MODULE_VERSION(_version) MODULE_INFO_STRIP(version, _version)
++#elif defined(CONFIG_MODULE_STRIPPED)
++#define MODULE_VERSION(_version) __MODULE_INFO_DISABLED(version)
+ #else
+ #define MODULE_VERSION(_version)					\
+ 	static struct module_version_attribute ___modver_attr = {	\
+@@ -177,7 +180,7 @@ extern const struct gtype##_id __mod_##g
+ /* Optional firmware file (or files) needed by the module
+  * format is simply firmware file name.  Multiple firmware
+  * files require multiple MODULE_FIRMWARE() specifiers */
+-#define MODULE_FIRMWARE(_firmware) MODULE_INFO(firmware, _firmware)
++#define MODULE_FIRMWARE(_firmware) MODULE_INFO_STRIP(firmware, _firmware)
+ 
+ /* Given an address, look for it in the exception tables */
+ const struct exception_table_entry *search_exception_tables(unsigned long add);
+Index: kernel_tree/include/linux/moduleparam.h
+===================================================================
+--- kernel_tree.orig/include/linux/moduleparam.h
++++ kernel_tree/include/linux/moduleparam.h
+@@ -16,6 +16,16 @@
+ /* Chosen so that structs with an unsigned long line up. */
+ #define MAX_PARAM_PREFIX_LEN (64 - sizeof(unsigned long))
+ 
++/* This struct is here for syntactic coherency, it is not used */
++#define __MODULE_INFO_DISABLED(name)					  \
++  struct __UNIQUE_ID(name) {}
++
++#ifdef CONFIG_MODULE_STRIPPED
++#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO_DISABLED(name)
++#else
++#define __MODULE_INFO_STRIP(tag, name, info) __MODULE_INFO(tag, name, info)
++#endif
++
+ #ifdef MODULE
+ #define __MODULE_INFO(tag, name, info)					  \
+ static const char __UNIQUE_ID(name)[]					  \
+@@ -23,8 +33,7 @@ static const char __UNIQUE_ID(name)[]
+   = __stringify(tag) "=" info
+ #else  /* !MODULE */
+ /* This struct is here for syntactic coherency, it is not used */
+-#define __MODULE_INFO(tag, name, info)					  \
+-  struct __UNIQUE_ID(name) {}
++#define __MODULE_INFO(tag, name, info) __MODULE_INFO_DISABLED(name)
+ #endif
+ #define __MODULE_PARM_TYPE(name, _type)					  \
+   __MODULE_INFO(parmtype, name##type, #name ":" _type)
+@@ -32,7 +41,7 @@ static const char __UNIQUE_ID(name)[]
+ /* One for each parameter, describing how to use it.  Some files do
+    multiple of these per line, so can't just use MODULE_INFO. */
+ #define MODULE_PARM_DESC(_parm, desc) \
+-	__MODULE_INFO(parm, _parm, #_parm ":" desc)
++	__MODULE_INFO_STRIP(parm, _parm, #_parm ":" desc)
+ 
+ struct kernel_param;
+ 
+Index: kernel_tree/init/Kconfig
+===================================================================
+--- kernel_tree.orig/init/Kconfig
++++ kernel_tree/init/Kconfig
+@@ -1784,6 +1784,13 @@ config MODULE_SIG_HASH
+ 	default "sha384" if MODULE_SIG_SHA384
+ 	default "sha512" if MODULE_SIG_SHA512
+ 
++config MODULE_STRIPPED
++	bool "Reduce module size"
++	depends on MODULES
++	help
++	  Remove module parameter descriptions, author info, version, aliases,
++	  device tables, etc.
++
+ endif # MODULES
+ 
+ config INIT_ALL_POSSIBLE
+Index: kernel_tree/kernel/module.c
+===================================================================
+--- kernel_tree.orig/kernel/module.c
++++ kernel_tree/kernel/module.c
+@@ -2716,6 +2716,7 @@ static struct module *setup_load_info(st
+ 
+ static int check_modinfo(struct module *mod, struct load_info *info, int flags)
+ {
++#ifndef CONFIG_MODULE_STRIPPED
+ 	const char *modmagic = get_modinfo(info, "vermagic");
+ 	int err;
+ 
+@@ -2742,6 +2743,7 @@ static int check_modinfo(struct module *
+ 		       " the quality is unknown, you have been warned.\n",
+ 		       mod->name);
+ 	}
++#endif
+ 
+ 	/* Set up license info based on the info section */
+ 	set_license(mod, get_modinfo(info, "license"));
+Index: kernel_tree/scripts/mod/modpost.c
+===================================================================
+--- kernel_tree.orig/scripts/mod/modpost.c
++++ kernel_tree/scripts/mod/modpost.c
+@@ -1744,7 +1744,9 @@ static void read_symbols(char *modname)
+ 		symname = info.strtab + sym->st_name;
+ 
+ 		handle_modversions(mod, &info, sym, symname);
++#ifndef CONFIG_MODULE_STRIPPED
+ 		handle_moddevtable(mod, &info, sym, symname);
++#endif
+ 	}
+ 	if (!is_vmlinux(modname) ||
+ 	     (is_vmlinux(modname) && vmlinux_section_warnings))
+@@ -1888,7 +1890,9 @@ static void add_header(struct buffer *b,
+ 	buf_printf(b, "#include <linux/vermagic.h>\n");
+ 	buf_printf(b, "#include <linux/compiler.h>\n");
+ 	buf_printf(b, "\n");
++#ifndef CONFIG_MODULE_STRIPPED
+ 	buf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");
++#endif
+ 	buf_printf(b, "\n");
+ 	buf_printf(b, "struct module __this_module\n");
+ 	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");
+@@ -1905,16 +1909,20 @@ static void add_header(struct buffer *b,
+ 
+ static void add_intree_flag(struct buffer *b, int is_intree)
+ {
++#ifndef CONFIG_MODULE_STRIPPED
+ 	if (is_intree)
+ 		buf_printf(b, "\nMODULE_INFO(intree, \"Y\");\n");
++#endif
+ }
+ 
+ static void add_staging_flag(struct buffer *b, const char *name)
+ {
++#ifndef CONFIG_MODULE_STRIPPED
+ 	static const char *staging_dir = "drivers/staging";
+ 
+ 	if (strncmp(staging_dir, name, strlen(staging_dir)) == 0)
+ 		buf_printf(b, "\nMODULE_INFO(staging, \"Y\");\n");
++#endif
+ }
+ 
+ /**
+@@ -2007,11 +2015,13 @@ static void add_depends(struct buffer *b
+ 
+ static void add_srcversion(struct buffer *b, struct module *mod)
+ {
++#ifndef CONFIG_MODULE_STRIPPED
+ 	if (mod->srcversion[0]) {
+ 		buf_printf(b, "\n");
+ 		buf_printf(b, "MODULE_INFO(srcversion, \"%s\");\n",
+ 			   mod->srcversion);
+ 	}
++#endif
+ }
+ 
+ static void write_if_changed(struct buffer *b, const char *fname)
+@@ -2237,7 +2247,9 @@ int main(int argc, char **argv)
+ 		add_staging_flag(&buf, mod->name);
+ 		err |= add_versions(&buf, mod);
+ 		add_depends(&buf, mod, modules);
++#ifndef CONFIG_MODULE_STRIPPED
+ 		add_moddevtable(&buf, mod);
++#endif
+ 		add_srcversion(&buf, mod);
+ 
+ 		sprintf(fname, "%s.mod.c", mod->name);
diff --git a/target/linux/generic/patches-3.10/210-darwin_scripts_include.patch b/target/linux/generic/patches-3.10/210-darwin_scripts_include.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/210-darwin_scripts_include.patch
@@ -0,0 +1,3088 @@
+--- a/scripts/kallsyms.c
++++ b/scripts/kallsyms.c
+@@ -22,6 +22,35 @@
+ #include <stdlib.h>
+ #include <string.h>
+ #include <ctype.h>
++#ifdef __APPLE__
++/* Darwin has no memmem implementation, this one is ripped of the uClibc-0.9.28 source */
++void *memmem (const void *haystack, size_t haystack_len,
++                          const void *needle,  size_t needle_len)
++{
++  const char *begin;
++  const char *const last_possible
++    = (const char *) haystack + haystack_len - needle_len;
++
++  if (needle_len == 0)
++    /* The first occurrence of the empty string is deemed to occur at
++       the beginning of the string.  */
++    return (void *) haystack;
++
++  /* Sanity check, otherwise the loop might search through the whole
++     memory.  */
++  if (__builtin_expect (haystack_len < needle_len, 0))
++    return NULL;
++
++  for (begin = (const char *) haystack; begin <= last_possible; ++begin)
++    if (begin[0] == ((const char *) needle)[0] &&
++        !memcmp ((const void *) &begin[1],
++                 (const void *) ((const char *) needle + 1),
++                 needle_len - 1))
++      return (void *) begin;
++
++  return NULL;
++}
++#endif
+ 
+ #ifndef ARRAY_SIZE
+ #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
+--- a/scripts/kconfig/Makefile
++++ b/scripts/kconfig/Makefile
+@@ -132,6 +132,9 @@ check-lxdialog  := $(srctree)/$(src)/lxd
+ # we really need to do so. (Do not call gcc as part of make mrproper)
+ HOST_EXTRACFLAGS += $(shell $(CONFIG_SHELL) $(check-lxdialog) -ccflags) \
+                     -DLOCALE
++ifeq ($(shell uname -s),Darwin)
++HOST_LOADLIBES  += -lncurses
++endif
+ 
+ # ===========================================================================
+ # Shared Makefile for the various kconfig executables:
+--- a/scripts/mod/mk_elfconfig.c
++++ b/scripts/mod/mk_elfconfig.c
+@@ -1,7 +1,11 @@
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
++#ifndef __APPLE__
+ #include <elf.h>
++#else
++#include "elf.h"
++#endif
+ 
+ int
+ main(int argc, char **argv)
+--- a/scripts/mod/modpost.h
++++ b/scripts/mod/modpost.h
+@@ -7,7 +7,11 @@
+ #include <sys/mman.h>
+ #include <fcntl.h>
+ #include <unistd.h>
++#if !(defined(__APPLE__) || defined(__CYGWIN__))
+ #include <elf.h>
++#else
++#include "elf.h"
++#endif
+ 
+ #include "elfconfig.h"
+ 
+--- /dev/null
++++ b/scripts/mod/elf.h
+@@ -0,0 +1,3007 @@
++/* This file defines standard ELF types, structures, and macros.
++   Copyright (C) 1995-2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _ELF_H
++#define	_ELF_H 1
++
++/* Standard ELF types.  */
++
++#include <stdint.h>
++
++/* Type for a 16-bit quantity.  */
++typedef uint16_t Elf32_Half;
++typedef uint16_t Elf64_Half;
++
++/* Types for signed and unsigned 32-bit quantities.  */
++typedef uint32_t Elf32_Word;
++typedef	int32_t  Elf32_Sword;
++typedef uint32_t Elf64_Word;
++typedef	int32_t  Elf64_Sword;
++
++/* Types for signed and unsigned 64-bit quantities.  */
++typedef uint64_t Elf32_Xword;
++typedef	int64_t  Elf32_Sxword;
++typedef uint64_t Elf64_Xword;
++typedef	int64_t  Elf64_Sxword;
++
++/* Type of addresses.  */
++typedef uint32_t Elf32_Addr;
++typedef uint64_t Elf64_Addr;
++
++/* Type of file offsets.  */
++typedef uint32_t Elf32_Off;
++typedef uint64_t Elf64_Off;
++
++/* Type for section indices, which are 16-bit quantities.  */
++typedef uint16_t Elf32_Section;
++typedef uint16_t Elf64_Section;
++
++/* Type for version symbol information.  */
++typedef Elf32_Half Elf32_Versym;
++typedef Elf64_Half Elf64_Versym;
++
++
++/* The ELF file header.  This appears at the start of every ELF file.  */
++
++#define EI_NIDENT (16)
++
++typedef struct
++{
++  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
++  Elf32_Half	e_type;			/* Object file type */
++  Elf32_Half	e_machine;		/* Architecture */
++  Elf32_Word	e_version;		/* Object file version */
++  Elf32_Addr	e_entry;		/* Entry point virtual address */
++  Elf32_Off	e_phoff;		/* Program header table file offset */
++  Elf32_Off	e_shoff;		/* Section header table file offset */
++  Elf32_Word	e_flags;		/* Processor-specific flags */
++  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
++  Elf32_Half	e_phentsize;		/* Program header table entry size */
++  Elf32_Half	e_phnum;		/* Program header table entry count */
++  Elf32_Half	e_shentsize;		/* Section header table entry size */
++  Elf32_Half	e_shnum;		/* Section header table entry count */
++  Elf32_Half	e_shstrndx;		/* Section header string table index */
++} Elf32_Ehdr;
++
++typedef struct
++{
++  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
++  Elf64_Half	e_type;			/* Object file type */
++  Elf64_Half	e_machine;		/* Architecture */
++  Elf64_Word	e_version;		/* Object file version */
++  Elf64_Addr	e_entry;		/* Entry point virtual address */
++  Elf64_Off	e_phoff;		/* Program header table file offset */
++  Elf64_Off	e_shoff;		/* Section header table file offset */
++  Elf64_Word	e_flags;		/* Processor-specific flags */
++  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
++  Elf64_Half	e_phentsize;		/* Program header table entry size */
++  Elf64_Half	e_phnum;		/* Program header table entry count */
++  Elf64_Half	e_shentsize;		/* Section header table entry size */
++  Elf64_Half	e_shnum;		/* Section header table entry count */
++  Elf64_Half	e_shstrndx;		/* Section header string table index */
++} Elf64_Ehdr;
++
++/* Fields in the e_ident array.  The EI_* macros are indices into the
++   array.  The macros under each EI_* macro are the values the byte
++   may have.  */
++
++#define EI_MAG0		0		/* File identification byte 0 index */
++#define ELFMAG0		0x7f		/* Magic number byte 0 */
++
++#define EI_MAG1		1		/* File identification byte 1 index */
++#define ELFMAG1		'E'		/* Magic number byte 1 */
++
++#define EI_MAG2		2		/* File identification byte 2 index */
++#define ELFMAG2		'L'		/* Magic number byte 2 */
++
++#define EI_MAG3		3		/* File identification byte 3 index */
++#define ELFMAG3		'F'		/* Magic number byte 3 */
++
++/* Conglomeration of the identification bytes, for easy testing as a word.  */
++#define	ELFMAG		"\177ELF"
++#define	SELFMAG		4
++
++#define EI_CLASS	4		/* File class byte index */
++#define ELFCLASSNONE	0		/* Invalid class */
++#define ELFCLASS32	1		/* 32-bit objects */
++#define ELFCLASS64	2		/* 64-bit objects */
++#define ELFCLASSNUM	3
++
++#define EI_DATA		5		/* Data encoding byte index */
++#define ELFDATANONE	0		/* Invalid data encoding */
++#define ELFDATA2LSB	1		/* 2's complement, little endian */
++#define ELFDATA2MSB	2		/* 2's complement, big endian */
++#define ELFDATANUM	3
++
++#define EI_VERSION	6		/* File version byte index */
++					/* Value must be EV_CURRENT */
++
++#define EI_OSABI	7		/* OS ABI identification */
++#define ELFOSABI_NONE		0	/* UNIX System V ABI */
++#define ELFOSABI_SYSV		0	/* Alias.  */
++#define ELFOSABI_HPUX		1	/* HP-UX */
++#define ELFOSABI_NETBSD		2	/* NetBSD.  */
++#define ELFOSABI_GNU		3	/* Object uses GNU ELF extensions.  */
++#define ELFOSABI_LINUX		ELFOSABI_GNU /* Compatibility alias.  */
++#define ELFOSABI_SOLARIS	6	/* Sun Solaris.  */
++#define ELFOSABI_AIX		7	/* IBM AIX.  */
++#define ELFOSABI_IRIX		8	/* SGI Irix.  */
++#define ELFOSABI_FREEBSD	9	/* FreeBSD.  */
++#define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX.  */
++#define ELFOSABI_MODESTO	11	/* Novell Modesto.  */
++#define ELFOSABI_OPENBSD	12	/* OpenBSD.  */
++#define ELFOSABI_ARM_AEABI	64	/* ARM EABI */
++#define ELFOSABI_ARM		97	/* ARM */
++#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
++
++#define EI_ABIVERSION	8		/* ABI version */
++
++#define EI_PAD		9		/* Byte index of padding bytes */
++
++/* Legal values for e_type (object file type).  */
++
++#define ET_NONE		0		/* No file type */
++#define ET_REL		1		/* Relocatable file */
++#define ET_EXEC		2		/* Executable file */
++#define ET_DYN		3		/* Shared object file */
++#define ET_CORE		4		/* Core file */
++#define	ET_NUM		5		/* Number of defined types */
++#define ET_LOOS		0xfe00		/* OS-specific range start */
++#define ET_HIOS		0xfeff		/* OS-specific range end */
++#define ET_LOPROC	0xff00		/* Processor-specific range start */
++#define ET_HIPROC	0xffff		/* Processor-specific range end */
++
++/* Legal values for e_machine (architecture).  */
++
++#define EM_NONE		 0		/* No machine */
++#define EM_M32		 1		/* AT&T WE 32100 */
++#define EM_SPARC	 2		/* SUN SPARC */
++#define EM_386		 3		/* Intel 80386 */
++#define EM_68K		 4		/* Motorola m68k family */
++#define EM_88K		 5		/* Motorola m88k family */
++#define EM_860		 7		/* Intel 80860 */
++#define EM_MIPS		 8		/* MIPS R3000 big-endian */
++#define EM_S370		 9		/* IBM System/370 */
++#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
++
++#define EM_PARISC	15		/* HPPA */
++#define EM_VPP500	17		/* Fujitsu VPP500 */
++#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
++#define EM_960		19		/* Intel 80960 */
++#define EM_PPC		20		/* PowerPC */
++#define EM_PPC64	21		/* PowerPC 64-bit */
++#define EM_S390		22		/* IBM S390 */
++
++#define EM_V800		36		/* NEC V800 series */
++#define EM_FR20		37		/* Fujitsu FR20 */
++#define EM_RH32		38		/* TRW RH-32 */
++#define EM_RCE		39		/* Motorola RCE */
++#define EM_ARM		40		/* ARM */
++#define EM_FAKE_ALPHA	41		/* Digital Alpha */
++#define EM_SH		42		/* Hitachi SH */
++#define EM_SPARCV9	43		/* SPARC v9 64-bit */
++#define EM_TRICORE	44		/* Siemens Tricore */
++#define EM_ARC		45		/* Argonaut RISC Core */
++#define EM_H8_300	46		/* Hitachi H8/300 */
++#define EM_H8_300H	47		/* Hitachi H8/300H */
++#define EM_H8S		48		/* Hitachi H8S */
++#define EM_H8_500	49		/* Hitachi H8/500 */
++#define EM_IA_64	50		/* Intel Merced */
++#define EM_MIPS_X	51		/* Stanford MIPS-X */
++#define EM_COLDFIRE	52		/* Motorola Coldfire */
++#define EM_68HC12	53		/* Motorola M68HC12 */
++#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
++#define EM_PCP		55		/* Siemens PCP */
++#define EM_NCPU		56		/* Sony nCPU embeeded RISC */
++#define EM_NDR1		57		/* Denso NDR1 microprocessor */
++#define EM_STARCORE	58		/* Motorola Start*Core processor */
++#define EM_ME16		59		/* Toyota ME16 processor */
++#define EM_ST100	60		/* STMicroelectronic ST100 processor */
++#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
++#define EM_X86_64	62		/* AMD x86-64 architecture */
++#define EM_PDSP		63		/* Sony DSP Processor */
++
++#define EM_FX66		66		/* Siemens FX66 microcontroller */
++#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
++#define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
++#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
++#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
++#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
++#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
++#define EM_SVX		73		/* Silicon Graphics SVx */
++#define EM_ST19		74		/* STMicroelectronics ST19 8 bit mc */
++#define EM_VAX		75		/* Digital VAX */
++#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
++#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
++#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
++#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
++#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
++#define EM_HUANY	81		/* Harvard University machine-independent object files */
++#define EM_PRISM	82		/* SiTera Prism */
++#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
++#define EM_FR30		84		/* Fujitsu FR30 */
++#define EM_D10V		85		/* Mitsubishi D10V */
++#define EM_D30V		86		/* Mitsubishi D30V */
++#define EM_V850		87		/* NEC v850 */
++#define EM_M32R		88		/* Mitsubishi M32R */
++#define EM_MN10300	89		/* Matsushita MN10300 */
++#define EM_MN10200	90		/* Matsushita MN10200 */
++#define EM_PJ		91		/* picoJava */
++#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
++#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
++#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
++#define EM_TILEPRO	188		/* Tilera TILEPro */
++#define EM_TILEGX	191		/* Tilera TILE-Gx */
++#define EM_NUM		192
++
++/* If it is necessary to assign new unofficial EM_* values, please
++   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
++   chances of collision with official or non-GNU unofficial values.  */
++
++#define EM_ALPHA	0x9026
++
++/* Legal values for e_version (version).  */
++
++#define EV_NONE		0		/* Invalid ELF version */
++#define EV_CURRENT	1		/* Current version */
++#define EV_NUM		2
++
++/* Section header.  */
++
++typedef struct
++{
++  Elf32_Word	sh_name;		/* Section name (string tbl index) */
++  Elf32_Word	sh_type;		/* Section type */
++  Elf32_Word	sh_flags;		/* Section flags */
++  Elf32_Addr	sh_addr;		/* Section virtual addr at execution */
++  Elf32_Off	sh_offset;		/* Section file offset */
++  Elf32_Word	sh_size;		/* Section size in bytes */
++  Elf32_Word	sh_link;		/* Link to another section */
++  Elf32_Word	sh_info;		/* Additional section information */
++  Elf32_Word	sh_addralign;		/* Section alignment */
++  Elf32_Word	sh_entsize;		/* Entry size if section holds table */
++} Elf32_Shdr;
++
++typedef struct
++{
++  Elf64_Word	sh_name;		/* Section name (string tbl index) */
++  Elf64_Word	sh_type;		/* Section type */
++  Elf64_Xword	sh_flags;		/* Section flags */
++  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
++  Elf64_Off	sh_offset;		/* Section file offset */
++  Elf64_Xword	sh_size;		/* Section size in bytes */
++  Elf64_Word	sh_link;		/* Link to another section */
++  Elf64_Word	sh_info;		/* Additional section information */
++  Elf64_Xword	sh_addralign;		/* Section alignment */
++  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
++} Elf64_Shdr;
++
++/* Special section indices.  */
++
++#define SHN_UNDEF	0		/* Undefined section */
++#define SHN_LORESERVE	0xff00		/* Start of reserved indices */
++#define SHN_LOPROC	0xff00		/* Start of processor-specific */
++#define SHN_BEFORE	0xff00		/* Order section before all others
++					   (Solaris).  */
++#define SHN_AFTER	0xff01		/* Order section after all others
++					   (Solaris).  */
++#define SHN_HIPROC	0xff1f		/* End of processor-specific */
++#define SHN_LOOS	0xff20		/* Start of OS-specific */
++#define SHN_HIOS	0xff3f		/* End of OS-specific */
++#define SHN_ABS		0xfff1		/* Associated symbol is absolute */
++#define SHN_COMMON	0xfff2		/* Associated symbol is common */
++#define SHN_XINDEX	0xffff		/* Index is in extra table.  */
++#define SHN_HIRESERVE	0xffff		/* End of reserved indices */
++
++/* Legal values for sh_type (section type).  */
++
++#define SHT_NULL	  0		/* Section header table entry unused */
++#define SHT_PROGBITS	  1		/* Program data */
++#define SHT_SYMTAB	  2		/* Symbol table */
++#define SHT_STRTAB	  3		/* String table */
++#define SHT_RELA	  4		/* Relocation entries with addends */
++#define SHT_HASH	  5		/* Symbol hash table */
++#define SHT_DYNAMIC	  6		/* Dynamic linking information */
++#define SHT_NOTE	  7		/* Notes */
++#define SHT_NOBITS	  8		/* Program space with no data (bss) */
++#define SHT_REL		  9		/* Relocation entries, no addends */
++#define SHT_SHLIB	  10		/* Reserved */
++#define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
++#define SHT_INIT_ARRAY	  14		/* Array of constructors */
++#define SHT_FINI_ARRAY	  15		/* Array of destructors */
++#define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
++#define SHT_GROUP	  17		/* Section group */
++#define SHT_SYMTAB_SHNDX  18		/* Extended section indeces */
++#define	SHT_NUM		  19		/* Number of defined types.  */
++#define SHT_LOOS	  0x60000000	/* Start OS-specific.  */
++#define SHT_GNU_ATTRIBUTES 0x6ffffff5	/* Object attributes.  */
++#define SHT_GNU_HASH	  0x6ffffff6	/* GNU-style hash table.  */
++#define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
++#define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
++#define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
++#define SHT_SUNW_move	  0x6ffffffa
++#define SHT_SUNW_COMDAT   0x6ffffffb
++#define SHT_SUNW_syminfo  0x6ffffffc
++#define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
++#define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
++#define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
++#define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
++#define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
++#define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
++#define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
++#define SHT_LOUSER	  0x80000000	/* Start of application-specific */
++#define SHT_HIUSER	  0x8fffffff	/* End of application-specific */
++
++/* Legal values for sh_flags (section flags).  */
++
++#define SHF_WRITE	     (1 << 0)	/* Writable */
++#define SHF_ALLOC	     (1 << 1)	/* Occupies memory during execution */
++#define SHF_EXECINSTR	     (1 << 2)	/* Executable */
++#define SHF_MERGE	     (1 << 4)	/* Might be merged */
++#define SHF_STRINGS	     (1 << 5)	/* Contains nul-terminated strings */
++#define SHF_INFO_LINK	     (1 << 6)	/* `sh_info' contains SHT index */
++#define SHF_LINK_ORDER	     (1 << 7)	/* Preserve order after combining */
++#define SHF_OS_NONCONFORMING (1 << 8)	/* Non-standard OS specific handling
++					   required */
++#define SHF_GROUP	     (1 << 9)	/* Section is member of a group.  */
++#define SHF_TLS		     (1 << 10)	/* Section hold thread-local data.  */
++#define SHF_MASKOS	     0x0ff00000	/* OS-specific.  */
++#define SHF_MASKPROC	     0xf0000000	/* Processor-specific */
++#define SHF_ORDERED	     (1 << 30)	/* Special ordering requirement
++					   (Solaris).  */
++#define SHF_EXCLUDE	     (1 << 31)	/* Section is excluded unless
++					   referenced or allocated (Solaris).*/
++
++/* Section group handling.  */
++#define GRP_COMDAT	0x1		/* Mark group as COMDAT.  */
++
++/* Symbol table entry.  */
++
++typedef struct
++{
++  Elf32_Word	st_name;		/* Symbol name (string tbl index) */
++  Elf32_Addr	st_value;		/* Symbol value */
++  Elf32_Word	st_size;		/* Symbol size */
++  unsigned char	st_info;		/* Symbol type and binding */
++  unsigned char	st_other;		/* Symbol visibility */
++  Elf32_Section	st_shndx;		/* Section index */
++} Elf32_Sym;
++
++typedef struct
++{
++  Elf64_Word	st_name;		/* Symbol name (string tbl index) */
++  unsigned char	st_info;		/* Symbol type and binding */
++  unsigned char st_other;		/* Symbol visibility */
++  Elf64_Section	st_shndx;		/* Section index */
++  Elf64_Addr	st_value;		/* Symbol value */
++  Elf64_Xword	st_size;		/* Symbol size */
++} Elf64_Sym;
++
++/* The syminfo section if available contains additional information about
++   every dynamic symbol.  */
++
++typedef struct
++{
++  Elf32_Half si_boundto;		/* Direct bindings, symbol bound to */
++  Elf32_Half si_flags;			/* Per symbol flags */
++} Elf32_Syminfo;
++
++typedef struct
++{
++  Elf64_Half si_boundto;		/* Direct bindings, symbol bound to */
++  Elf64_Half si_flags;			/* Per symbol flags */
++} Elf64_Syminfo;
++
++/* Possible values for si_boundto.  */
++#define SYMINFO_BT_SELF		0xffff	/* Symbol bound to self */
++#define SYMINFO_BT_PARENT	0xfffe	/* Symbol bound to parent */
++#define SYMINFO_BT_LOWRESERVE	0xff00	/* Beginning of reserved entries */
++
++/* Possible bitmasks for si_flags.  */
++#define SYMINFO_FLG_DIRECT	0x0001	/* Direct bound symbol */
++#define SYMINFO_FLG_PASSTHRU	0x0002	/* Pass-thru symbol for translator */
++#define SYMINFO_FLG_COPY	0x0004	/* Symbol is a copy-reloc */
++#define SYMINFO_FLG_LAZYLOAD	0x0008	/* Symbol bound to object to be lazy
++					   loaded */
++/* Syminfo version values.  */
++#define SYMINFO_NONE		0
++#define SYMINFO_CURRENT		1
++#define SYMINFO_NUM		2
++
++
++/* How to extract and insert information held in the st_info field.  */
++
++#define ELF32_ST_BIND(val)		(((unsigned char) (val)) >> 4)
++#define ELF32_ST_TYPE(val)		((val) & 0xf)
++#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
++
++/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
++#define ELF64_ST_BIND(val)		ELF32_ST_BIND (val)
++#define ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)
++#define ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))
++
++/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
++
++#define STB_LOCAL	0		/* Local symbol */
++#define STB_GLOBAL	1		/* Global symbol */
++#define STB_WEAK	2		/* Weak symbol */
++#define	STB_NUM		3		/* Number of defined types.  */
++#define STB_LOOS	10		/* Start of OS-specific */
++#define STB_GNU_UNIQUE	10		/* Unique symbol.  */
++#define STB_HIOS	12		/* End of OS-specific */
++#define STB_LOPROC	13		/* Start of processor-specific */
++#define STB_HIPROC	15		/* End of processor-specific */
++
++/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
++
++#define STT_NOTYPE	0		/* Symbol type is unspecified */
++#define STT_OBJECT	1		/* Symbol is a data object */
++#define STT_FUNC	2		/* Symbol is a code object */
++#define STT_SECTION	3		/* Symbol associated with a section */
++#define STT_FILE	4		/* Symbol's name is file name */
++#define STT_COMMON	5		/* Symbol is a common data object */
++#define STT_TLS		6		/* Symbol is thread-local data object*/
++#define	STT_NUM		7		/* Number of defined types.  */
++#define STT_LOOS	10		/* Start of OS-specific */
++#define STT_GNU_IFUNC	10		/* Symbol is indirect code object */
++#define STT_HIOS	12		/* End of OS-specific */
++#define STT_LOPROC	13		/* Start of processor-specific */
++#define STT_HIPROC	15		/* End of processor-specific */
++
++
++/* Symbol table indices are found in the hash buckets and chain table
++   of a symbol hash table section.  This special index value indicates
++   the end of a chain, meaning no further symbols are found in that bucket.  */
++
++#define STN_UNDEF	0		/* End of a chain.  */
++
++
++/* How to extract and insert information held in the st_other field.  */
++
++#define ELF32_ST_VISIBILITY(o)	((o) & 0x03)
++
++/* For ELF64 the definitions are the same.  */
++#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)
++
++/* Symbol visibility specification encoded in the st_other field.  */
++#define STV_DEFAULT	0		/* Default symbol visibility rules */
++#define STV_INTERNAL	1		/* Processor specific hidden class */
++#define STV_HIDDEN	2		/* Sym unavailable in other modules */
++#define STV_PROTECTED	3		/* Not preemptible, not exported */
++
++
++/* Relocation table entry without addend (in section of type SHT_REL).  */
++
++typedef struct
++{
++  Elf32_Addr	r_offset;		/* Address */
++  Elf32_Word	r_info;			/* Relocation type and symbol index */
++} Elf32_Rel;
++
++/* I have seen two different definitions of the Elf64_Rel and
++   Elf64_Rela structures, so we'll leave them out until Novell (or
++   whoever) gets their act together.  */
++/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
++
++typedef struct
++{
++  Elf64_Addr	r_offset;		/* Address */
++  Elf64_Xword	r_info;			/* Relocation type and symbol index */
++} Elf64_Rel;
++
++/* Relocation table entry with addend (in section of type SHT_RELA).  */
++
++typedef struct
++{
++  Elf32_Addr	r_offset;		/* Address */
++  Elf32_Word	r_info;			/* Relocation type and symbol index */
++  Elf32_Sword	r_addend;		/* Addend */
++} Elf32_Rela;
++
++typedef struct
++{
++  Elf64_Addr	r_offset;		/* Address */
++  Elf64_Xword	r_info;			/* Relocation type and symbol index */
++  Elf64_Sxword	r_addend;		/* Addend */
++} Elf64_Rela;
++
++/* How to extract and insert information held in the r_info field.  */
++
++#define ELF32_R_SYM(val)		((val) >> 8)
++#define ELF32_R_TYPE(val)		((val) & 0xff)
++#define ELF32_R_INFO(sym, type)		(((sym) << 8) + ((type) & 0xff))
++
++#define ELF64_R_SYM(i)			((i) >> 32)
++#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
++#define ELF64_R_INFO(sym,type)		((((Elf64_Xword) (sym)) << 32) + (type))
++
++/* Program segment header.  */
++
++typedef struct
++{
++  Elf32_Word	p_type;			/* Segment type */
++  Elf32_Off	p_offset;		/* Segment file offset */
++  Elf32_Addr	p_vaddr;		/* Segment virtual address */
++  Elf32_Addr	p_paddr;		/* Segment physical address */
++  Elf32_Word	p_filesz;		/* Segment size in file */
++  Elf32_Word	p_memsz;		/* Segment size in memory */
++  Elf32_Word	p_flags;		/* Segment flags */
++  Elf32_Word	p_align;		/* Segment alignment */
++} Elf32_Phdr;
++
++typedef struct
++{
++  Elf64_Word	p_type;			/* Segment type */
++  Elf64_Word	p_flags;		/* Segment flags */
++  Elf64_Off	p_offset;		/* Segment file offset */
++  Elf64_Addr	p_vaddr;		/* Segment virtual address */
++  Elf64_Addr	p_paddr;		/* Segment physical address */
++  Elf64_Xword	p_filesz;		/* Segment size in file */
++  Elf64_Xword	p_memsz;		/* Segment size in memory */
++  Elf64_Xword	p_align;		/* Segment alignment */
++} Elf64_Phdr;
++
++/* Special value for e_phnum.  This indicates that the real number of
++   program headers is too large to fit into e_phnum.  Instead the real
++   value is in the field sh_info of section 0.  */
++
++#define PN_XNUM		0xffff
++
++/* Legal values for p_type (segment type).  */
++
++#define	PT_NULL		0		/* Program header table entry unused */
++#define PT_LOAD		1		/* Loadable program segment */
++#define PT_DYNAMIC	2		/* Dynamic linking information */
++#define PT_INTERP	3		/* Program interpreter */
++#define PT_NOTE		4		/* Auxiliary information */
++#define PT_SHLIB	5		/* Reserved */
++#define PT_PHDR		6		/* Entry for header table itself */
++#define PT_TLS		7		/* Thread-local storage segment */
++#define	PT_NUM		8		/* Number of defined types */
++#define PT_LOOS		0x60000000	/* Start of OS-specific */
++#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
++#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
++#define PT_GNU_RELRO	0x6474e552	/* Read-only after relocation */
++#define PT_LOSUNW	0x6ffffffa
++#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
++#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
++#define PT_HISUNW	0x6fffffff
++#define PT_HIOS		0x6fffffff	/* End of OS-specific */
++#define PT_LOPROC	0x70000000	/* Start of processor-specific */
++#define PT_HIPROC	0x7fffffff	/* End of processor-specific */
++
++/* Legal values for p_flags (segment flags).  */
++
++#define PF_X		(1 << 0)	/* Segment is executable */
++#define PF_W		(1 << 1)	/* Segment is writable */
++#define PF_R		(1 << 2)	/* Segment is readable */
++#define PF_MASKOS	0x0ff00000	/* OS-specific */
++#define PF_MASKPROC	0xf0000000	/* Processor-specific */
++
++/* Legal values for note segment descriptor types for core files. */
++
++#define NT_PRSTATUS	1		/* Contains copy of prstatus struct */
++#define NT_FPREGSET	2		/* Contains copy of fpregset struct */
++#define NT_PRPSINFO	3		/* Contains copy of prpsinfo struct */
++#define NT_PRXREG	4		/* Contains copy of prxregset struct */
++#define NT_TASKSTRUCT	4		/* Contains copy of task structure */
++#define NT_PLATFORM	5		/* String from sysinfo(SI_PLATFORM) */
++#define NT_AUXV		6		/* Contains copy of auxv array */
++#define NT_GWINDOWS	7		/* Contains copy of gwindows struct */
++#define NT_ASRS		8		/* Contains copy of asrset struct */
++#define NT_PSTATUS	10		/* Contains copy of pstatus struct */
++#define NT_PSINFO	13		/* Contains copy of psinfo struct */
++#define NT_PRCRED	14		/* Contains copy of prcred struct */
++#define NT_UTSNAME	15		/* Contains copy of utsname struct */
++#define NT_LWPSTATUS	16		/* Contains copy of lwpstatus struct */
++#define NT_LWPSINFO	17		/* Contains copy of lwpinfo struct */
++#define NT_PRFPXREG	20		/* Contains copy of fprxregset struct */
++#define NT_PRXFPREG	0x46e62b7f	/* Contains copy of user_fxsr_struct */
++#define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
++#define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
++#define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
++#define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
++#define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
++#define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */
++
++/* Legal values for the note segment descriptor types for object files.  */
++
++#define NT_VERSION	1		/* Contains a version string.  */
++
++
++/* Dynamic section entry.  */
++
++typedef struct
++{
++  Elf32_Sword	d_tag;			/* Dynamic entry type */
++  union
++    {
++      Elf32_Word d_val;			/* Integer value */
++      Elf32_Addr d_ptr;			/* Address value */
++    } d_un;
++} Elf32_Dyn;
++
++typedef struct
++{
++  Elf64_Sxword	d_tag;			/* Dynamic entry type */
++  union
++    {
++      Elf64_Xword d_val;		/* Integer value */
++      Elf64_Addr d_ptr;			/* Address value */
++    } d_un;
++} Elf64_Dyn;
++
++/* Legal values for d_tag (dynamic entry type).  */
++
++#define DT_NULL		0		/* Marks end of dynamic section */
++#define DT_NEEDED	1		/* Name of needed library */
++#define DT_PLTRELSZ	2		/* Size in bytes of PLT relocs */
++#define DT_PLTGOT	3		/* Processor defined value */
++#define DT_HASH		4		/* Address of symbol hash table */
++#define DT_STRTAB	5		/* Address of string table */
++#define DT_SYMTAB	6		/* Address of symbol table */
++#define DT_RELA		7		/* Address of Rela relocs */
++#define DT_RELASZ	8		/* Total size of Rela relocs */
++#define DT_RELAENT	9		/* Size of one Rela reloc */
++#define DT_STRSZ	10		/* Size of string table */
++#define DT_SYMENT	11		/* Size of one symbol table entry */
++#define DT_INIT		12		/* Address of init function */
++#define DT_FINI		13		/* Address of termination function */
++#define DT_SONAME	14		/* Name of shared object */
++#define DT_RPATH	15		/* Library search path (deprecated) */
++#define DT_SYMBOLIC	16		/* Start symbol search here */
++#define DT_REL		17		/* Address of Rel relocs */
++#define DT_RELSZ	18		/* Total size of Rel relocs */
++#define DT_RELENT	19		/* Size of one Rel reloc */
++#define DT_PLTREL	20		/* Type of reloc in PLT */
++#define DT_DEBUG	21		/* For debugging; unspecified */
++#define DT_TEXTREL	22		/* Reloc might modify .text */
++#define DT_JMPREL	23		/* Address of PLT relocs */
++#define	DT_BIND_NOW	24		/* Process relocations of object */
++#define	DT_INIT_ARRAY	25		/* Array with addresses of init fct */
++#define	DT_FINI_ARRAY	26		/* Array with addresses of fini fct */
++#define	DT_INIT_ARRAYSZ	27		/* Size in bytes of DT_INIT_ARRAY */
++#define	DT_FINI_ARRAYSZ	28		/* Size in bytes of DT_FINI_ARRAY */
++#define DT_RUNPATH	29		/* Library search path */
++#define DT_FLAGS	30		/* Flags for the object being loaded */
++#define DT_ENCODING	32		/* Start of encoded range */
++#define DT_PREINIT_ARRAY 32		/* Array with addresses of preinit fct*/
++#define DT_PREINIT_ARRAYSZ 33		/* size in bytes of DT_PREINIT_ARRAY */
++#define	DT_NUM		34		/* Number used */
++#define DT_LOOS		0x6000000d	/* Start of OS-specific */
++#define DT_HIOS		0x6ffff000	/* End of OS-specific */
++#define DT_LOPROC	0x70000000	/* Start of processor-specific */
++#define DT_HIPROC	0x7fffffff	/* End of processor-specific */
++#define	DT_PROCNUM	DT_MIPS_NUM	/* Most used by any processor */
++
++/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
++   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
++   approach.  */
++#define DT_VALRNGLO	0x6ffffd00
++#define DT_GNU_PRELINKED 0x6ffffdf5	/* Prelinking timestamp */
++#define DT_GNU_CONFLICTSZ 0x6ffffdf6	/* Size of conflict section */
++#define DT_GNU_LIBLISTSZ 0x6ffffdf7	/* Size of library list */
++#define DT_CHECKSUM	0x6ffffdf8
++#define DT_PLTPADSZ	0x6ffffdf9
++#define DT_MOVEENT	0x6ffffdfa
++#define DT_MOVESZ	0x6ffffdfb
++#define DT_FEATURE_1	0x6ffffdfc	/* Feature selection (DTF_*).  */
++#define DT_POSFLAG_1	0x6ffffdfd	/* Flags for DT_* entries, effecting
++					   the following DT_* entry.  */
++#define DT_SYMINSZ	0x6ffffdfe	/* Size of syminfo table (in bytes) */
++#define DT_SYMINENT	0x6ffffdff	/* Entry size of syminfo */
++#define DT_VALRNGHI	0x6ffffdff
++#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))	/* Reverse order! */
++#define DT_VALNUM 12
++
++/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
++   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.
++
++   If any adjustment is made to the ELF object after it has been
++   built these entries will need to be adjusted.  */
++#define DT_ADDRRNGLO	0x6ffffe00
++#define DT_GNU_HASH	0x6ffffef5	/* GNU-style hash table.  */
++#define DT_TLSDESC_PLT	0x6ffffef6
++#define DT_TLSDESC_GOT	0x6ffffef7
++#define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
++#define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
++#define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
++#define DT_DEPAUDIT	0x6ffffefb	/* Dependency auditing.  */
++#define DT_AUDIT	0x6ffffefc	/* Object auditing.  */
++#define	DT_PLTPAD	0x6ffffefd	/* PLT padding.  */
++#define	DT_MOVETAB	0x6ffffefe	/* Move table.  */
++#define DT_SYMINFO	0x6ffffeff	/* Syminfo table.  */
++#define DT_ADDRRNGHI	0x6ffffeff
++#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))	/* Reverse order! */
++#define DT_ADDRNUM 11
++
++/* The versioning entry types.  The next are defined as part of the
++   GNU extension.  */
++#define DT_VERSYM	0x6ffffff0
++
++#define DT_RELACOUNT	0x6ffffff9
++#define DT_RELCOUNT	0x6ffffffa
++
++/* These were chosen by Sun.  */
++#define DT_FLAGS_1	0x6ffffffb	/* State flags, see DF_1_* below.  */
++#define	DT_VERDEF	0x6ffffffc	/* Address of version definition
++					   table */
++#define	DT_VERDEFNUM	0x6ffffffd	/* Number of version definitions */
++#define	DT_VERNEED	0x6ffffffe	/* Address of table with needed
++					   versions */
++#define	DT_VERNEEDNUM	0x6fffffff	/* Number of needed versions */
++#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order! */
++#define DT_VERSIONTAGNUM 16
++
++/* Sun added these machine-independent extensions in the "processor-specific"
++   range.  Be compatible.  */
++#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */
++#define DT_FILTER       0x7fffffff      /* Shared object to get values from */
++#define DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
++#define DT_EXTRANUM	3
++
++/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
++#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
++#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions starts here */
++#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
++#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
++#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */
++
++/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
++   entry in the dynamic section.  */
++#define DF_1_NOW	0x00000001	/* Set RTLD_NOW for this object.  */
++#define DF_1_GLOBAL	0x00000002	/* Set RTLD_GLOBAL for this object.  */
++#define DF_1_GROUP	0x00000004	/* Set RTLD_GROUP for this object.  */
++#define DF_1_NODELETE	0x00000008	/* Set RTLD_NODELETE for this object.*/
++#define DF_1_LOADFLTR	0x00000010	/* Trigger filtee loading at runtime.*/
++#define DF_1_INITFIRST	0x00000020	/* Set RTLD_INITFIRST for this object*/
++#define DF_1_NOOPEN	0x00000040	/* Set RTLD_NOOPEN for this object.  */
++#define DF_1_ORIGIN	0x00000080	/* $ORIGIN must be handled.  */
++#define DF_1_DIRECT	0x00000100	/* Direct binding enabled.  */
++#define DF_1_TRANS	0x00000200
++#define DF_1_INTERPOSE	0x00000400	/* Object is used to interpose.  */
++#define DF_1_NODEFLIB	0x00000800	/* Ignore default lib search path.  */
++#define DF_1_NODUMP	0x00001000	/* Object can't be dldump'ed.  */
++#define DF_1_CONFALT	0x00002000	/* Configuration alternative created.*/
++#define DF_1_ENDFILTEE	0x00004000	/* Filtee terminates filters search. */
++#define	DF_1_DISPRELDNE	0x00008000	/* Disp reloc applied at build time. */
++#define	DF_1_DISPRELPND	0x00010000	/* Disp reloc applied at run-time.  */
++
++/* Flags for the feature selection in DT_FEATURE_1.  */
++#define DTF_1_PARINIT	0x00000001
++#define DTF_1_CONFEXP	0x00000002
++
++/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
++#define DF_P1_LAZYLOAD	0x00000001	/* Lazyload following object.  */
++#define DF_P1_GROUPPERM	0x00000002	/* Symbols from next object are not
++					   generally available.  */
++
++/* Version definition sections.  */
++
++typedef struct
++{
++  Elf32_Half	vd_version;		/* Version revision */
++  Elf32_Half	vd_flags;		/* Version information */
++  Elf32_Half	vd_ndx;			/* Version Index */
++  Elf32_Half	vd_cnt;			/* Number of associated aux entries */
++  Elf32_Word	vd_hash;		/* Version name hash value */
++  Elf32_Word	vd_aux;			/* Offset in bytes to verdaux array */
++  Elf32_Word	vd_next;		/* Offset in bytes to next verdef
++					   entry */
++} Elf32_Verdef;
++
++typedef struct
++{
++  Elf64_Half	vd_version;		/* Version revision */
++  Elf64_Half	vd_flags;		/* Version information */
++  Elf64_Half	vd_ndx;			/* Version Index */
++  Elf64_Half	vd_cnt;			/* Number of associated aux entries */
++  Elf64_Word	vd_hash;		/* Version name hash value */
++  Elf64_Word	vd_aux;			/* Offset in bytes to verdaux array */
++  Elf64_Word	vd_next;		/* Offset in bytes to next verdef
++					   entry */
++} Elf64_Verdef;
++
++
++/* Legal values for vd_version (version revision).  */
++#define VER_DEF_NONE	0		/* No version */
++#define VER_DEF_CURRENT	1		/* Current version */
++#define VER_DEF_NUM	2		/* Given version number */
++
++/* Legal values for vd_flags (version information flags).  */
++#define VER_FLG_BASE	0x1		/* Version definition of file itself */
++#define VER_FLG_WEAK	0x2		/* Weak version identifier */
++
++/* Versym symbol index values.  */
++#define	VER_NDX_LOCAL		0	/* Symbol is local.  */
++#define	VER_NDX_GLOBAL		1	/* Symbol is global.  */
++#define	VER_NDX_LORESERVE	0xff00	/* Beginning of reserved entries.  */
++#define	VER_NDX_ELIMINATE	0xff01	/* Symbol is to be eliminated.  */
++
++/* Auxialiary version information.  */
++
++typedef struct
++{
++  Elf32_Word	vda_name;		/* Version or dependency names */
++  Elf32_Word	vda_next;		/* Offset in bytes to next verdaux
++					   entry */
++} Elf32_Verdaux;
++
++typedef struct
++{
++  Elf64_Word	vda_name;		/* Version or dependency names */
++  Elf64_Word	vda_next;		/* Offset in bytes to next verdaux
++					   entry */
++} Elf64_Verdaux;
++
++
++/* Version dependency section.  */
++
++typedef struct
++{
++  Elf32_Half	vn_version;		/* Version of structure */
++  Elf32_Half	vn_cnt;			/* Number of associated aux entries */
++  Elf32_Word	vn_file;		/* Offset of filename for this
++					   dependency */
++  Elf32_Word	vn_aux;			/* Offset in bytes to vernaux array */
++  Elf32_Word	vn_next;		/* Offset in bytes to next verneed
++					   entry */
++} Elf32_Verneed;
++
++typedef struct
++{
++  Elf64_Half	vn_version;		/* Version of structure */
++  Elf64_Half	vn_cnt;			/* Number of associated aux entries */
++  Elf64_Word	vn_file;		/* Offset of filename for this
++					   dependency */
++  Elf64_Word	vn_aux;			/* Offset in bytes to vernaux array */
++  Elf64_Word	vn_next;		/* Offset in bytes to next verneed
++					   entry */
++} Elf64_Verneed;
++
++
++/* Legal values for vn_version (version revision).  */
++#define VER_NEED_NONE	 0		/* No version */
++#define VER_NEED_CURRENT 1		/* Current version */
++#define VER_NEED_NUM	 2		/* Given version number */
++
++/* Auxiliary needed version information.  */
++
++typedef struct
++{
++  Elf32_Word	vna_hash;		/* Hash value of dependency name */
++  Elf32_Half	vna_flags;		/* Dependency specific information */
++  Elf32_Half	vna_other;		/* Unused */
++  Elf32_Word	vna_name;		/* Dependency name string offset */
++  Elf32_Word	vna_next;		/* Offset in bytes to next vernaux
++					   entry */
++} Elf32_Vernaux;
++
++typedef struct
++{
++  Elf64_Word	vna_hash;		/* Hash value of dependency name */
++  Elf64_Half	vna_flags;		/* Dependency specific information */
++  Elf64_Half	vna_other;		/* Unused */
++  Elf64_Word	vna_name;		/* Dependency name string offset */
++  Elf64_Word	vna_next;		/* Offset in bytes to next vernaux
++					   entry */
++} Elf64_Vernaux;
++
++
++/* Legal values for vna_flags.  */
++#define VER_FLG_WEAK	0x2		/* Weak version identifier */
++
++
++/* Auxiliary vector.  */
++
++/* This vector is normally only used by the program interpreter.  The
++   usual definition in an ABI supplement uses the name auxv_t.  The
++   vector is not usually defined in a standard <elf.h> file, but it
++   can't hurt.  We rename it to avoid conflicts.  The sizes of these
++   types are an arrangement between the exec server and the program
++   interpreter, so we don't fully specify them here.  */
++
++typedef struct
++{
++  uint32_t a_type;		/* Entry type */
++  union
++    {
++      uint32_t a_val;		/* Integer value */
++      /* We use to have pointer elements added here.  We cannot do that,
++	 though, since it does not work when using 32-bit definitions
++	 on 64-bit platforms and vice versa.  */
++    } a_un;
++} Elf32_auxv_t;
++
++typedef struct
++{
++  uint64_t a_type;		/* Entry type */
++  union
++    {
++      uint64_t a_val;		/* Integer value */
++      /* We use to have pointer elements added here.  We cannot do that,
++	 though, since it does not work when using 32-bit definitions
++	 on 64-bit platforms and vice versa.  */
++    } a_un;
++} Elf64_auxv_t;
++
++/* Legal values for a_type (entry type).  */
++
++#define AT_NULL		0		/* End of vector */
++#define AT_IGNORE	1		/* Entry should be ignored */
++#define AT_EXECFD	2		/* File descriptor of program */
++#define AT_PHDR		3		/* Program headers for program */
++#define AT_PHENT	4		/* Size of program header entry */
++#define AT_PHNUM	5		/* Number of program headers */
++#define AT_PAGESZ	6		/* System page size */
++#define AT_BASE		7		/* Base address of interpreter */
++#define AT_FLAGS	8		/* Flags */
++#define AT_ENTRY	9		/* Entry point of program */
++#define AT_NOTELF	10		/* Program is not ELF */
++#define AT_UID		11		/* Real uid */
++#define AT_EUID		12		/* Effective uid */
++#define AT_GID		13		/* Real gid */
++#define AT_EGID		14		/* Effective gid */
++#define AT_CLKTCK	17		/* Frequency of times() */
++
++/* Some more special a_type values describing the hardware.  */
++#define AT_PLATFORM	15		/* String identifying platform.  */
++#define AT_HWCAP	16		/* Machine dependent hints about
++					   processor capabilities.  */
++
++/* This entry gives some information about the FPU initialization
++   performed by the kernel.  */
++#define AT_FPUCW	18		/* Used FPU control word.  */
++
++/* Cache block sizes.  */
++#define AT_DCACHEBSIZE	19		/* Data cache block size.  */
++#define AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
++#define AT_UCACHEBSIZE	21		/* Unified cache block size.  */
++
++/* A special ignored value for PPC, used by the kernel to control the
++   interpretation of the AUXV. Must be > 16.  */
++#define AT_IGNOREPPC	22		/* Entry should be ignored.  */
++
++#define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */
++
++#define AT_BASE_PLATFORM 24		/* String identifying real platforms.*/
++
++#define AT_RANDOM	25		/* Address of 16 random bytes.  */
++
++#define AT_EXECFN	31		/* Filename of executable.  */
++
++/* Pointer to the global system page used for system calls and other
++   nice things.  */
++#define AT_SYSINFO	32
++#define AT_SYSINFO_EHDR	33
++
++/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
++   log2 of line size; mask those to get cache size.  */
++#define AT_L1I_CACHESHAPE	34
++#define AT_L1D_CACHESHAPE	35
++#define AT_L2_CACHESHAPE	36
++#define AT_L3_CACHESHAPE	37
++
++/* Note section contents.  Each entry in the note section begins with
++   a header of a fixed form.  */
++
++typedef struct
++{
++  Elf32_Word n_namesz;			/* Length of the note's name.  */
++  Elf32_Word n_descsz;			/* Length of the note's descriptor.  */
++  Elf32_Word n_type;			/* Type of the note.  */
++} Elf32_Nhdr;
++
++typedef struct
++{
++  Elf64_Word n_namesz;			/* Length of the note's name.  */
++  Elf64_Word n_descsz;			/* Length of the note's descriptor.  */
++  Elf64_Word n_type;			/* Type of the note.  */
++} Elf64_Nhdr;
++
++/* Known names of notes.  */
++
++/* Solaris entries in the note section have this name.  */
++#define ELF_NOTE_SOLARIS	"SUNW Solaris"
++
++/* Note entries for GNU systems have this name.  */
++#define ELF_NOTE_GNU		"GNU"
++
++
++/* Defined types of notes for Solaris.  */
++
++/* Value of descriptor (one word) is desired pagesize for the binary.  */
++#define ELF_NOTE_PAGESIZE_HINT	1
++
++
++/* Defined note types for GNU systems.  */
++
++/* ABI information.  The descriptor consists of words:
++   word 0: OS descriptor
++   word 1: major version of the ABI
++   word 2: minor version of the ABI
++   word 3: subminor version of the ABI
++*/
++#define NT_GNU_ABI_TAG	1
++#define ELF_NOTE_ABI	NT_GNU_ABI_TAG /* Old name.  */
++
++/* Known OSes.  These values can appear in word 0 of an
++   NT_GNU_ABI_TAG note section entry.  */
++#define ELF_NOTE_OS_LINUX	0
++#define ELF_NOTE_OS_GNU		1
++#define ELF_NOTE_OS_SOLARIS2	2
++#define ELF_NOTE_OS_FREEBSD	3
++
++/* Synthetic hwcap information.  The descriptor begins with two words:
++   word 0: number of entries
++   word 1: bitmask of enabled entries
++   Then follow variable-length entries, one byte followed by a
++   '\0'-terminated hwcap name string.  The byte gives the bit
++   number to test if enabled, (1U << bit) & bitmask.  */
++#define NT_GNU_HWCAP	2
++
++/* Build ID bits as generated by ld --build-id.
++   The descriptor consists of any nonzero number of bytes.  */
++#define NT_GNU_BUILD_ID	3
++
++/* Version note generated by GNU gold containing a version string.  */
++#define NT_GNU_GOLD_VERSION	4
++
++
++/* Move records.  */
++typedef struct
++{
++  Elf32_Xword m_value;		/* Symbol value.  */
++  Elf32_Word m_info;		/* Size and index.  */
++  Elf32_Word m_poffset;		/* Symbol offset.  */
++  Elf32_Half m_repeat;		/* Repeat count.  */
++  Elf32_Half m_stride;		/* Stride info.  */
++} Elf32_Move;
++
++typedef struct
++{
++  Elf64_Xword m_value;		/* Symbol value.  */
++  Elf64_Xword m_info;		/* Size and index.  */
++  Elf64_Xword m_poffset;	/* Symbol offset.  */
++  Elf64_Half m_repeat;		/* Repeat count.  */
++  Elf64_Half m_stride;		/* Stride info.  */
++} Elf64_Move;
++
++/* Macro to construct move records.  */
++#define ELF32_M_SYM(info)	((info) >> 8)
++#define ELF32_M_SIZE(info)	((unsigned char) (info))
++#define ELF32_M_INFO(sym, size)	(((sym) << 8) + (unsigned char) (size))
++
++#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
++#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
++#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
++
++
++/* Motorola 68k specific definitions.  */
++
++/* Values for Elf32_Ehdr.e_flags.  */
++#define EF_CPU32	0x00810000
++
++/* m68k relocs.  */
++
++#define R_68K_NONE	0		/* No reloc */
++#define R_68K_32	1		/* Direct 32 bit  */
++#define R_68K_16	2		/* Direct 16 bit  */
++#define R_68K_8		3		/* Direct 8 bit  */
++#define R_68K_PC32	4		/* PC relative 32 bit */
++#define R_68K_PC16	5		/* PC relative 16 bit */
++#define R_68K_PC8	6		/* PC relative 8 bit */
++#define R_68K_GOT32	7		/* 32 bit PC relative GOT entry */
++#define R_68K_GOT16	8		/* 16 bit PC relative GOT entry */
++#define R_68K_GOT8	9		/* 8 bit PC relative GOT entry */
++#define R_68K_GOT32O	10		/* 32 bit GOT offset */
++#define R_68K_GOT16O	11		/* 16 bit GOT offset */
++#define R_68K_GOT8O	12		/* 8 bit GOT offset */
++#define R_68K_PLT32	13		/* 32 bit PC relative PLT address */
++#define R_68K_PLT16	14		/* 16 bit PC relative PLT address */
++#define R_68K_PLT8	15		/* 8 bit PC relative PLT address */
++#define R_68K_PLT32O	16		/* 32 bit PLT offset */
++#define R_68K_PLT16O	17		/* 16 bit PLT offset */
++#define R_68K_PLT8O	18		/* 8 bit PLT offset */
++#define R_68K_COPY	19		/* Copy symbol at runtime */
++#define R_68K_GLOB_DAT	20		/* Create GOT entry */
++#define R_68K_JMP_SLOT	21		/* Create PLT entry */
++#define R_68K_RELATIVE	22		/* Adjust by program base */
++#define R_68K_TLS_GD32      25          /* 32 bit GOT offset for GD */
++#define R_68K_TLS_GD16      26          /* 16 bit GOT offset for GD */
++#define R_68K_TLS_GD8       27          /* 8 bit GOT offset for GD */
++#define R_68K_TLS_LDM32     28          /* 32 bit GOT offset for LDM */
++#define R_68K_TLS_LDM16     29          /* 16 bit GOT offset for LDM */
++#define R_68K_TLS_LDM8      30          /* 8 bit GOT offset for LDM */
++#define R_68K_TLS_LDO32     31          /* 32 bit module-relative offset */
++#define R_68K_TLS_LDO16     32          /* 16 bit module-relative offset */
++#define R_68K_TLS_LDO8      33          /* 8 bit module-relative offset */
++#define R_68K_TLS_IE32      34          /* 32 bit GOT offset for IE */
++#define R_68K_TLS_IE16      35          /* 16 bit GOT offset for IE */
++#define R_68K_TLS_IE8       36          /* 8 bit GOT offset for IE */
++#define R_68K_TLS_LE32      37          /* 32 bit offset relative to
++					   static TLS block */
++#define R_68K_TLS_LE16      38          /* 16 bit offset relative to
++					   static TLS block */
++#define R_68K_TLS_LE8       39          /* 8 bit offset relative to
++					   static TLS block */
++#define R_68K_TLS_DTPMOD32  40          /* 32 bit module number */
++#define R_68K_TLS_DTPREL32  41          /* 32 bit module-relative offset */
++#define R_68K_TLS_TPREL32   42          /* 32 bit TP-relative offset */
++/* Keep this the last entry.  */
++#define R_68K_NUM	43
++
++/* Intel 80386 specific definitions.  */
++
++/* i386 relocs.  */
++
++#define R_386_NONE	   0		/* No reloc */
++#define R_386_32	   1		/* Direct 32 bit  */
++#define R_386_PC32	   2		/* PC relative 32 bit */
++#define R_386_GOT32	   3		/* 32 bit GOT entry */
++#define R_386_PLT32	   4		/* 32 bit PLT address */
++#define R_386_COPY	   5		/* Copy symbol at runtime */
++#define R_386_GLOB_DAT	   6		/* Create GOT entry */
++#define R_386_JMP_SLOT	   7		/* Create PLT entry */
++#define R_386_RELATIVE	   8		/* Adjust by program base */
++#define R_386_GOTOFF	   9		/* 32 bit offset to GOT */
++#define R_386_GOTPC	   10		/* 32 bit PC relative offset to GOT */
++#define R_386_32PLT	   11
++#define R_386_TLS_TPOFF	   14		/* Offset in static TLS block */
++#define R_386_TLS_IE	   15		/* Address of GOT entry for static TLS
++					   block offset */
++#define R_386_TLS_GOTIE	   16		/* GOT entry for static TLS block
++					   offset */
++#define R_386_TLS_LE	   17		/* Offset relative to static TLS
++					   block */
++#define R_386_TLS_GD	   18		/* Direct 32 bit for GNU version of
++					   general dynamic thread local data */
++#define R_386_TLS_LDM	   19		/* Direct 32 bit for GNU version of
++					   local dynamic thread local data
++					   in LE code */
++#define R_386_16	   20
++#define R_386_PC16	   21
++#define R_386_8		   22
++#define R_386_PC8	   23
++#define R_386_TLS_GD_32	   24		/* Direct 32 bit for general dynamic
++					   thread local data */
++#define R_386_TLS_GD_PUSH  25		/* Tag for pushl in GD TLS code */
++#define R_386_TLS_GD_CALL  26		/* Relocation for call to
++					   __tls_get_addr() */
++#define R_386_TLS_GD_POP   27		/* Tag for popl in GD TLS code */
++#define R_386_TLS_LDM_32   28		/* Direct 32 bit for local dynamic
++					   thread local data in LE code */
++#define R_386_TLS_LDM_PUSH 29		/* Tag for pushl in LDM TLS code */
++#define R_386_TLS_LDM_CALL 30		/* Relocation for call to
++					   __tls_get_addr() in LDM code */
++#define R_386_TLS_LDM_POP  31		/* Tag for popl in LDM TLS code */
++#define R_386_TLS_LDO_32   32		/* Offset relative to TLS block */
++#define R_386_TLS_IE_32	   33		/* GOT entry for negated static TLS
++					   block offset */
++#define R_386_TLS_LE_32	   34		/* Negated offset relative to static
++					   TLS block */
++#define R_386_TLS_DTPMOD32 35		/* ID of module containing symbol */
++#define R_386_TLS_DTPOFF32 36		/* Offset in TLS block */
++#define R_386_TLS_TPOFF32  37		/* Negated offset in static TLS block */
++/* 38? */
++#define R_386_TLS_GOTDESC  39		/* GOT offset for TLS descriptor.  */
++#define R_386_TLS_DESC_CALL 40		/* Marker of call through TLS
++					   descriptor for
++					   relaxation.  */
++#define R_386_TLS_DESC     41		/* TLS descriptor containing
++					   pointer to code and to
++					   argument, returning the TLS
++					   offset for the symbol.  */
++#define R_386_IRELATIVE	   42		/* Adjust indirectly by program base */
++/* Keep this the last entry.  */
++#define R_386_NUM	   43
++
++/* SUN SPARC specific definitions.  */
++
++/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
++
++#define STT_SPARC_REGISTER	13	/* Global register reserved to app. */
++
++/* Values for Elf64_Ehdr.e_flags.  */
++
++#define EF_SPARCV9_MM		3
++#define EF_SPARCV9_TSO		0
++#define EF_SPARCV9_PSO		1
++#define EF_SPARCV9_RMO		2
++#define EF_SPARC_LEDATA		0x800000 /* little endian data */
++#define EF_SPARC_EXT_MASK	0xFFFF00
++#define EF_SPARC_32PLUS		0x000100 /* generic V8+ features */
++#define EF_SPARC_SUN_US1	0x000200 /* Sun UltraSPARC1 extensions */
++#define EF_SPARC_HAL_R1		0x000400 /* HAL R1 extensions */
++#define EF_SPARC_SUN_US3	0x000800 /* Sun UltraSPARCIII extensions */
++
++/* SPARC relocs.  */
++
++#define R_SPARC_NONE		0	/* No reloc */
++#define R_SPARC_8		1	/* Direct 8 bit */
++#define R_SPARC_16		2	/* Direct 16 bit */
++#define R_SPARC_32		3	/* Direct 32 bit */
++#define R_SPARC_DISP8		4	/* PC relative 8 bit */
++#define R_SPARC_DISP16		5	/* PC relative 16 bit */
++#define R_SPARC_DISP32		6	/* PC relative 32 bit */
++#define R_SPARC_WDISP30		7	/* PC relative 30 bit shifted */
++#define R_SPARC_WDISP22		8	/* PC relative 22 bit shifted */
++#define R_SPARC_HI22		9	/* High 22 bit */
++#define R_SPARC_22		10	/* Direct 22 bit */
++#define R_SPARC_13		11	/* Direct 13 bit */
++#define R_SPARC_LO10		12	/* Truncated 10 bit */
++#define R_SPARC_GOT10		13	/* Truncated 10 bit GOT entry */
++#define R_SPARC_GOT13		14	/* 13 bit GOT entry */
++#define R_SPARC_GOT22		15	/* 22 bit GOT entry shifted */
++#define R_SPARC_PC10		16	/* PC relative 10 bit truncated */
++#define R_SPARC_PC22		17	/* PC relative 22 bit shifted */
++#define R_SPARC_WPLT30		18	/* 30 bit PC relative PLT address */
++#define R_SPARC_COPY		19	/* Copy symbol at runtime */
++#define R_SPARC_GLOB_DAT	20	/* Create GOT entry */
++#define R_SPARC_JMP_SLOT	21	/* Create PLT entry */
++#define R_SPARC_RELATIVE	22	/* Adjust by program base */
++#define R_SPARC_UA32		23	/* Direct 32 bit unaligned */
++
++/* Additional Sparc64 relocs.  */
++
++#define R_SPARC_PLT32		24	/* Direct 32 bit ref to PLT entry */
++#define R_SPARC_HIPLT22		25	/* High 22 bit PLT entry */
++#define R_SPARC_LOPLT10		26	/* Truncated 10 bit PLT entry */
++#define R_SPARC_PCPLT32		27	/* PC rel 32 bit ref to PLT entry */
++#define R_SPARC_PCPLT22		28	/* PC rel high 22 bit PLT entry */
++#define R_SPARC_PCPLT10		29	/* PC rel trunc 10 bit PLT entry */
++#define R_SPARC_10		30	/* Direct 10 bit */
++#define R_SPARC_11		31	/* Direct 11 bit */
++#define R_SPARC_64		32	/* Direct 64 bit */
++#define R_SPARC_OLO10		33	/* 10bit with secondary 13bit addend */
++#define R_SPARC_HH22		34	/* Top 22 bits of direct 64 bit */
++#define R_SPARC_HM10		35	/* High middle 10 bits of ... */
++#define R_SPARC_LM22		36	/* Low middle 22 bits of ... */
++#define R_SPARC_PC_HH22		37	/* Top 22 bits of pc rel 64 bit */
++#define R_SPARC_PC_HM10		38	/* High middle 10 bit of ... */
++#define R_SPARC_PC_LM22		39	/* Low miggle 22 bits of ... */
++#define R_SPARC_WDISP16		40	/* PC relative 16 bit shifted */
++#define R_SPARC_WDISP19		41	/* PC relative 19 bit shifted */
++#define R_SPARC_GLOB_JMP	42	/* was part of v9 ABI but was removed */
++#define R_SPARC_7		43	/* Direct 7 bit */
++#define R_SPARC_5		44	/* Direct 5 bit */
++#define R_SPARC_6		45	/* Direct 6 bit */
++#define R_SPARC_DISP64		46	/* PC relative 64 bit */
++#define R_SPARC_PLT64		47	/* Direct 64 bit ref to PLT entry */
++#define R_SPARC_HIX22		48	/* High 22 bit complemented */
++#define R_SPARC_LOX10		49	/* Truncated 11 bit complemented */
++#define R_SPARC_H44		50	/* Direct high 12 of 44 bit */
++#define R_SPARC_M44		51	/* Direct mid 22 of 44 bit */
++#define R_SPARC_L44		52	/* Direct low 10 of 44 bit */
++#define R_SPARC_REGISTER	53	/* Global register usage */
++#define R_SPARC_UA64		54	/* Direct 64 bit unaligned */
++#define R_SPARC_UA16		55	/* Direct 16 bit unaligned */
++#define R_SPARC_TLS_GD_HI22	56
++#define R_SPARC_TLS_GD_LO10	57
++#define R_SPARC_TLS_GD_ADD	58
++#define R_SPARC_TLS_GD_CALL	59
++#define R_SPARC_TLS_LDM_HI22	60
++#define R_SPARC_TLS_LDM_LO10	61
++#define R_SPARC_TLS_LDM_ADD	62
++#define R_SPARC_TLS_LDM_CALL	63
++#define R_SPARC_TLS_LDO_HIX22	64
++#define R_SPARC_TLS_LDO_LOX10	65
++#define R_SPARC_TLS_LDO_ADD	66
++#define R_SPARC_TLS_IE_HI22	67
++#define R_SPARC_TLS_IE_LO10	68
++#define R_SPARC_TLS_IE_LD	69
++#define R_SPARC_TLS_IE_LDX	70
++#define R_SPARC_TLS_IE_ADD	71
++#define R_SPARC_TLS_LE_HIX22	72
++#define R_SPARC_TLS_LE_LOX10	73
++#define R_SPARC_TLS_DTPMOD32	74
++#define R_SPARC_TLS_DTPMOD64	75
++#define R_SPARC_TLS_DTPOFF32	76
++#define R_SPARC_TLS_DTPOFF64	77
++#define R_SPARC_TLS_TPOFF32	78
++#define R_SPARC_TLS_TPOFF64	79
++#define R_SPARC_GOTDATA_HIX22	80
++#define R_SPARC_GOTDATA_LOX10	81
++#define R_SPARC_GOTDATA_OP_HIX22	82
++#define R_SPARC_GOTDATA_OP_LOX10	83
++#define R_SPARC_GOTDATA_OP	84
++#define R_SPARC_H34		85
++#define R_SPARC_SIZE32		86
++#define R_SPARC_SIZE64		87
++#define R_SPARC_WDISP10		88
++#define R_SPARC_JMP_IREL	248
++#define R_SPARC_IRELATIVE	249
++#define R_SPARC_GNU_VTINHERIT	250
++#define R_SPARC_GNU_VTENTRY	251
++#define R_SPARC_REV32		252
++/* Keep this the last entry.  */
++#define R_SPARC_NUM		253
++
++/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */
++
++#define DT_SPARC_REGISTER 0x70000001
++#define DT_SPARC_NUM	2
++
++/* MIPS R3000 specific definitions.  */
++
++/* Legal values for e_flags field of Elf32_Ehdr.  */
++
++#define EF_MIPS_NOREORDER   1		/* A .noreorder directive was used */
++#define EF_MIPS_PIC	    2		/* Contains PIC code */
++#define EF_MIPS_CPIC	    4		/* Uses PIC calling sequence */
++#define EF_MIPS_XGOT	    8
++#define EF_MIPS_64BIT_WHIRL 16
++#define EF_MIPS_ABI2	    32
++#define EF_MIPS_ABI_ON32    64
++#define EF_MIPS_ARCH	    0xf0000000	/* MIPS architecture level */
++
++/* Legal values for MIPS architecture level.  */
++
++#define EF_MIPS_ARCH_1	    0x00000000	/* -mips1 code.  */
++#define EF_MIPS_ARCH_2	    0x10000000	/* -mips2 code.  */
++#define EF_MIPS_ARCH_3	    0x20000000	/* -mips3 code.  */
++#define EF_MIPS_ARCH_4	    0x30000000	/* -mips4 code.  */
++#define EF_MIPS_ARCH_5	    0x40000000	/* -mips5 code.  */
++#define EF_MIPS_ARCH_32	    0x60000000	/* MIPS32 code.  */
++#define EF_MIPS_ARCH_64	    0x70000000	/* MIPS64 code.  */
++
++/* The following are non-official names and should not be used.  */
++
++#define E_MIPS_ARCH_1	  0x00000000	/* -mips1 code.  */
++#define E_MIPS_ARCH_2	  0x10000000	/* -mips2 code.  */
++#define E_MIPS_ARCH_3	  0x20000000	/* -mips3 code.  */
++#define E_MIPS_ARCH_4	  0x30000000	/* -mips4 code.  */
++#define E_MIPS_ARCH_5	  0x40000000	/* -mips5 code.  */
++#define E_MIPS_ARCH_32	  0x60000000	/* MIPS32 code.  */
++#define E_MIPS_ARCH_64	  0x70000000	/* MIPS64 code.  */
++
++/* Special section indices.  */
++
++#define SHN_MIPS_ACOMMON    0xff00	/* Allocated common symbols */
++#define SHN_MIPS_TEXT	    0xff01	/* Allocated test symbols.  */
++#define SHN_MIPS_DATA	    0xff02	/* Allocated data symbols.  */
++#define SHN_MIPS_SCOMMON    0xff03	/* Small common symbols */
++#define SHN_MIPS_SUNDEFINED 0xff04	/* Small undefined symbols */
++
++/* Legal values for sh_type field of Elf32_Shdr.  */
++
++#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */
++#define SHT_MIPS_MSYM	       0x70000001
++#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */
++#define SHT_MIPS_GPTAB	       0x70000003 /* Global data area sizes */
++#define SHT_MIPS_UCODE	       0x70000004 /* Reserved for SGI/MIPS compilers */
++#define SHT_MIPS_DEBUG	       0x70000005 /* MIPS ECOFF debugging information*/
++#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */
++#define SHT_MIPS_PACKAGE       0x70000007
++#define SHT_MIPS_PACKSYM       0x70000008
++#define SHT_MIPS_RELD	       0x70000009
++#define SHT_MIPS_IFACE         0x7000000b
++#define SHT_MIPS_CONTENT       0x7000000c
++#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */
++#define SHT_MIPS_SHDR	       0x70000010
++#define SHT_MIPS_FDESC	       0x70000011
++#define SHT_MIPS_EXTSYM	       0x70000012
++#define SHT_MIPS_DENSE	       0x70000013
++#define SHT_MIPS_PDESC	       0x70000014
++#define SHT_MIPS_LOCSYM	       0x70000015
++#define SHT_MIPS_AUXSYM	       0x70000016
++#define SHT_MIPS_OPTSYM	       0x70000017
++#define SHT_MIPS_LOCSTR	       0x70000018
++#define SHT_MIPS_LINE	       0x70000019
++#define SHT_MIPS_RFDESC	       0x7000001a
++#define SHT_MIPS_DELTASYM      0x7000001b
++#define SHT_MIPS_DELTAINST     0x7000001c
++#define SHT_MIPS_DELTACLASS    0x7000001d
++#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */
++#define SHT_MIPS_DELTADECL     0x7000001f
++#define SHT_MIPS_SYMBOL_LIB    0x70000020
++#define SHT_MIPS_EVENTS	       0x70000021 /* Event section.  */
++#define SHT_MIPS_TRANSLATE     0x70000022
++#define SHT_MIPS_PIXIE	       0x70000023
++#define SHT_MIPS_XLATE	       0x70000024
++#define SHT_MIPS_XLATE_DEBUG   0x70000025
++#define SHT_MIPS_WHIRL	       0x70000026
++#define SHT_MIPS_EH_REGION     0x70000027
++#define SHT_MIPS_XLATE_OLD     0x70000028
++#define SHT_MIPS_PDR_EXCEPTION 0x70000029
++
++/* Legal values for sh_flags field of Elf32_Shdr.  */
++
++#define SHF_MIPS_GPREL	 0x10000000	/* Must be part of global data area */
++#define SHF_MIPS_MERGE	 0x20000000
++#define SHF_MIPS_ADDR	 0x40000000
++#define SHF_MIPS_STRINGS 0x80000000
++#define SHF_MIPS_NOSTRIP 0x08000000
++#define SHF_MIPS_LOCAL	 0x04000000
++#define SHF_MIPS_NAMES	 0x02000000
++#define SHF_MIPS_NODUPE	 0x01000000
++
++
++/* Symbol tables.  */
++
++/* MIPS specific values for `st_other'.  */
++#define STO_MIPS_DEFAULT		0x0
++#define STO_MIPS_INTERNAL		0x1
++#define STO_MIPS_HIDDEN			0x2
++#define STO_MIPS_PROTECTED		0x3
++#define STO_MIPS_PLT			0x8
++#define STO_MIPS_SC_ALIGN_UNUSED	0xff
++
++/* MIPS specific values for `st_info'.  */
++#define STB_MIPS_SPLIT_COMMON		13
++
++/* Entries found in sections of type SHT_MIPS_GPTAB.  */
++
++typedef union
++{
++  struct
++    {
++      Elf32_Word gt_current_g_value;	/* -G value used for compilation */
++      Elf32_Word gt_unused;		/* Not used */
++    } gt_header;			/* First entry in section */
++  struct
++    {
++      Elf32_Word gt_g_value;		/* If this value were used for -G */
++      Elf32_Word gt_bytes;		/* This many bytes would be used */
++    } gt_entry;				/* Subsequent entries in section */
++} Elf32_gptab;
++
++/* Entry found in sections of type SHT_MIPS_REGINFO.  */
++
++typedef struct
++{
++  Elf32_Word	ri_gprmask;		/* General registers used */
++  Elf32_Word	ri_cprmask[4];		/* Coprocessor registers used */
++  Elf32_Sword	ri_gp_value;		/* $gp register value */
++} Elf32_RegInfo;
++
++/* Entries found in sections of type SHT_MIPS_OPTIONS.  */
++
++typedef struct
++{
++  unsigned char kind;		/* Determines interpretation of the
++				   variable part of descriptor.  */
++  unsigned char size;		/* Size of descriptor, including header.  */
++  Elf32_Section section;	/* Section header index of section affected,
++				   0 for global options.  */
++  Elf32_Word info;		/* Kind-specific information.  */
++} Elf_Options;
++
++/* Values for `kind' field in Elf_Options.  */
++
++#define ODK_NULL	0	/* Undefined.  */
++#define ODK_REGINFO	1	/* Register usage information.  */
++#define ODK_EXCEPTIONS	2	/* Exception processing options.  */
++#define ODK_PAD		3	/* Section padding options.  */
++#define ODK_HWPATCH	4	/* Hardware workarounds performed */
++#define ODK_FILL	5	/* record the fill value used by the linker. */
++#define ODK_TAGS	6	/* reserve space for desktop tools to write. */
++#define ODK_HWAND	7	/* HW workarounds.  'AND' bits when merging. */
++#define ODK_HWOR	8	/* HW workarounds.  'OR' bits when merging.  */
++
++/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */
++
++#define OEX_FPU_MIN	0x1f	/* FPE's which MUST be enabled.  */
++#define OEX_FPU_MAX	0x1f00	/* FPE's which MAY be enabled.  */
++#define OEX_PAGE0	0x10000	/* page zero must be mapped.  */
++#define OEX_SMM		0x20000	/* Force sequential memory mode?  */
++#define OEX_FPDBUG	0x40000	/* Force floating point debug mode?  */
++#define OEX_PRECISEFP	OEX_FPDBUG
++#define OEX_DISMISS	0x80000	/* Dismiss invalid address faults?  */
++
++#define OEX_FPU_INVAL	0x10
++#define OEX_FPU_DIV0	0x08
++#define OEX_FPU_OFLO	0x04
++#define OEX_FPU_UFLO	0x02
++#define OEX_FPU_INEX	0x01
++
++/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */
++
++#define OHW_R4KEOP	0x1	/* R4000 end-of-page patch.  */
++#define OHW_R8KPFETCH	0x2	/* may need R8000 prefetch patch.  */
++#define OHW_R5KEOP	0x4	/* R5000 end-of-page patch.  */
++#define OHW_R5KCVTL	0x8	/* R5000 cvt.[ds].l bug.  clean=1.  */
++
++#define OPAD_PREFIX	0x1
++#define OPAD_POSTFIX	0x2
++#define OPAD_SYMBOL	0x4
++
++/* Entry found in `.options' section.  */
++
++typedef struct
++{
++  Elf32_Word hwp_flags1;	/* Extra flags.  */
++  Elf32_Word hwp_flags2;	/* Extra flags.  */
++} Elf_Options_Hw;
++
++/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */
++
++#define OHWA0_R4KEOP_CHECKED	0x00000001
++#define OHWA1_R4KEOP_CLEAN	0x00000002
++
++/* MIPS relocs.  */
++
++#define R_MIPS_NONE		0	/* No reloc */
++#define R_MIPS_16		1	/* Direct 16 bit */
++#define R_MIPS_32		2	/* Direct 32 bit */
++#define R_MIPS_REL32		3	/* PC relative 32 bit */
++#define R_MIPS_26		4	/* Direct 26 bit shifted */
++#define R_MIPS_HI16		5	/* High 16 bit */
++#define R_MIPS_LO16		6	/* Low 16 bit */
++#define R_MIPS_GPREL16		7	/* GP relative 16 bit */
++#define R_MIPS_LITERAL		8	/* 16 bit literal entry */
++#define R_MIPS_GOT16		9	/* 16 bit GOT entry */
++#define R_MIPS_PC16		10	/* PC relative 16 bit */
++#define R_MIPS_CALL16		11	/* 16 bit GOT entry for function */
++#define R_MIPS_GPREL32		12	/* GP relative 32 bit */
++
++#define R_MIPS_SHIFT5		16
++#define R_MIPS_SHIFT6		17
++#define R_MIPS_64		18
++#define R_MIPS_GOT_DISP		19
++#define R_MIPS_GOT_PAGE		20
++#define R_MIPS_GOT_OFST		21
++#define R_MIPS_GOT_HI16		22
++#define R_MIPS_GOT_LO16		23
++#define R_MIPS_SUB		24
++#define R_MIPS_INSERT_A		25
++#define R_MIPS_INSERT_B		26
++#define R_MIPS_DELETE		27
++#define R_MIPS_HIGHER		28
++#define R_MIPS_HIGHEST		29
++#define R_MIPS_CALL_HI16	30
++#define R_MIPS_CALL_LO16	31
++#define R_MIPS_SCN_DISP		32
++#define R_MIPS_REL16		33
++#define R_MIPS_ADD_IMMEDIATE	34
++#define R_MIPS_PJUMP		35
++#define R_MIPS_RELGOT		36
++#define R_MIPS_JALR		37
++#define R_MIPS_TLS_DTPMOD32	38	/* Module number 32 bit */
++#define R_MIPS_TLS_DTPREL32	39	/* Module-relative offset 32 bit */
++#define R_MIPS_TLS_DTPMOD64	40	/* Module number 64 bit */
++#define R_MIPS_TLS_DTPREL64	41	/* Module-relative offset 64 bit */
++#define R_MIPS_TLS_GD		42	/* 16 bit GOT offset for GD */
++#define R_MIPS_TLS_LDM		43	/* 16 bit GOT offset for LDM */
++#define R_MIPS_TLS_DTPREL_HI16	44	/* Module-relative offset, high 16 bits */
++#define R_MIPS_TLS_DTPREL_LO16	45	/* Module-relative offset, low 16 bits */
++#define R_MIPS_TLS_GOTTPREL	46	/* 16 bit GOT offset for IE */
++#define R_MIPS_TLS_TPREL32	47	/* TP-relative offset, 32 bit */
++#define R_MIPS_TLS_TPREL64	48	/* TP-relative offset, 64 bit */
++#define R_MIPS_TLS_TPREL_HI16	49	/* TP-relative offset, high 16 bits */
++#define R_MIPS_TLS_TPREL_LO16	50	/* TP-relative offset, low 16 bits */
++#define R_MIPS_GLOB_DAT		51
++#define R_MIPS_COPY		126
++#define R_MIPS_JUMP_SLOT        127
++/* Keep this the last entry.  */
++#define R_MIPS_NUM		128
++
++/* Legal values for p_type field of Elf32_Phdr.  */
++
++#define PT_MIPS_REGINFO	0x70000000	/* Register usage information */
++#define PT_MIPS_RTPROC  0x70000001	/* Runtime procedure table. */
++#define PT_MIPS_OPTIONS 0x70000002
++
++/* Special program header types.  */
++
++#define PF_MIPS_LOCAL	0x10000000
++
++/* Legal values for d_tag field of Elf32_Dyn.  */
++
++#define DT_MIPS_RLD_VERSION  0x70000001	/* Runtime linker interface version */
++#define DT_MIPS_TIME_STAMP   0x70000002	/* Timestamp */
++#define DT_MIPS_ICHECKSUM    0x70000003	/* Checksum */
++#define DT_MIPS_IVERSION     0x70000004	/* Version string (string tbl index) */
++#define DT_MIPS_FLAGS	     0x70000005	/* Flags */
++#define DT_MIPS_BASE_ADDRESS 0x70000006	/* Base address */
++#define DT_MIPS_MSYM	     0x70000007
++#define DT_MIPS_CONFLICT     0x70000008	/* Address of CONFLICT section */
++#define DT_MIPS_LIBLIST	     0x70000009	/* Address of LIBLIST section */
++#define DT_MIPS_LOCAL_GOTNO  0x7000000a	/* Number of local GOT entries */
++#define DT_MIPS_CONFLICTNO   0x7000000b	/* Number of CONFLICT entries */
++#define DT_MIPS_LIBLISTNO    0x70000010	/* Number of LIBLIST entries */
++#define DT_MIPS_SYMTABNO     0x70000011	/* Number of DYNSYM entries */
++#define DT_MIPS_UNREFEXTNO   0x70000012	/* First external DYNSYM */
++#define DT_MIPS_GOTSYM	     0x70000013	/* First GOT entry in DYNSYM */
++#define DT_MIPS_HIPAGENO     0x70000014	/* Number of GOT page table entries */
++#define DT_MIPS_RLD_MAP	     0x70000016	/* Address of run time loader map.  */
++#define DT_MIPS_DELTA_CLASS  0x70000017	/* Delta C++ class definition.  */
++#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in
++						DT_MIPS_DELTA_CLASS.  */
++#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */
++#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in
++						DT_MIPS_DELTA_INSTANCE.  */
++#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */
++#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in
++					     DT_MIPS_DELTA_RELOC.  */
++#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta
++					   relocations refer to.  */
++#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in
++					   DT_MIPS_DELTA_SYM.  */
++#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the
++					     class declaration.  */
++#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in
++						DT_MIPS_DELTA_CLASSSYM.  */
++#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */
++#define DT_MIPS_PIXIE_INIT   0x70000023
++#define DT_MIPS_SYMBOL_LIB   0x70000024
++#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
++#define DT_MIPS_LOCAL_GOTIDX 0x70000026
++#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
++#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
++#define DT_MIPS_OPTIONS	     0x70000029 /* Address of .options.  */
++#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */
++#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
++#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */
++#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve
++						    function stored in GOT.  */
++#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added
++					   by rld on dlopen() calls.  */
++#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */
++#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */
++#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */
++/* The address of .got.plt in an executable using the new non-PIC ABI.  */
++#define DT_MIPS_PLTGOT	     0x70000032
++/* The base of the PLT in an executable using the new non-PIC ABI if that
++   PLT is writable.  For a non-writable PLT, this is omitted or has a zero
++   value.  */
++#define DT_MIPS_RWPLT        0x70000034
++#define DT_MIPS_NUM	     0x35
++
++/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */
++
++#define RHF_NONE		   0		/* No flags */
++#define RHF_QUICKSTART		   (1 << 0)	/* Use quickstart */
++#define RHF_NOTPOT		   (1 << 1)	/* Hash size not power of 2 */
++#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)	/* Ignore LD_LIBRARY_PATH */
++#define RHF_NO_MOVE		   (1 << 3)
++#define RHF_SGI_ONLY		   (1 << 4)
++#define RHF_GUARANTEE_INIT	   (1 << 5)
++#define RHF_DELTA_C_PLUS_PLUS	   (1 << 6)
++#define RHF_GUARANTEE_START_INIT   (1 << 7)
++#define RHF_PIXIE		   (1 << 8)
++#define RHF_DEFAULT_DELAY_LOAD	   (1 << 9)
++#define RHF_REQUICKSTART	   (1 << 10)
++#define RHF_REQUICKSTARTED	   (1 << 11)
++#define RHF_CORD		   (1 << 12)
++#define RHF_NO_UNRES_UNDEF	   (1 << 13)
++#define RHF_RLD_ORDER_SAFE	   (1 << 14)
++
++/* Entries found in sections of type SHT_MIPS_LIBLIST.  */
++
++typedef struct
++{
++  Elf32_Word l_name;		/* Name (string table index) */
++  Elf32_Word l_time_stamp;	/* Timestamp */
++  Elf32_Word l_checksum;	/* Checksum */
++  Elf32_Word l_version;		/* Interface version */
++  Elf32_Word l_flags;		/* Flags */
++} Elf32_Lib;
++
++typedef struct
++{
++  Elf64_Word l_name;		/* Name (string table index) */
++  Elf64_Word l_time_stamp;	/* Timestamp */
++  Elf64_Word l_checksum;	/* Checksum */
++  Elf64_Word l_version;		/* Interface version */
++  Elf64_Word l_flags;		/* Flags */
++} Elf64_Lib;
++
++
++/* Legal values for l_flags.  */
++
++#define LL_NONE		  0
++#define LL_EXACT_MATCH	  (1 << 0)	/* Require exact match */
++#define LL_IGNORE_INT_VER (1 << 1)	/* Ignore interface version */
++#define LL_REQUIRE_MINOR  (1 << 2)
++#define LL_EXPORTS	  (1 << 3)
++#define LL_DELAY_LOAD	  (1 << 4)
++#define LL_DELTA	  (1 << 5)
++
++/* Entries found in sections of type SHT_MIPS_CONFLICT.  */
++
++typedef Elf32_Addr Elf32_Conflict;
++
++
++/* HPPA specific definitions.  */
++
++/* Legal values for e_flags field of Elf32_Ehdr.  */
++
++#define EF_PARISC_TRAPNIL	0x00010000 /* Trap nil pointer dereference.  */
++#define EF_PARISC_EXT		0x00020000 /* Program uses arch. extensions. */
++#define EF_PARISC_LSB		0x00040000 /* Program expects little endian. */
++#define EF_PARISC_WIDE		0x00080000 /* Program expects wide mode.  */
++#define EF_PARISC_NO_KABP	0x00100000 /* No kernel assisted branch
++					      prediction.  */
++#define EF_PARISC_LAZYSWAP	0x00400000 /* Allow lazy swapping.  */
++#define EF_PARISC_ARCH		0x0000ffff /* Architecture version.  */
++
++/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */
++
++#define EFA_PARISC_1_0		    0x020b /* PA-RISC 1.0 big-endian.  */
++#define EFA_PARISC_1_1		    0x0210 /* PA-RISC 1.1 big-endian.  */
++#define EFA_PARISC_2_0		    0x0214 /* PA-RISC 2.0 big-endian.  */
++
++/* Additional section indeces.  */
++
++#define SHN_PARISC_ANSI_COMMON	0xff00	   /* Section for tenatively declared
++					      symbols in ANSI C.  */
++#define SHN_PARISC_HUGE_COMMON	0xff01	   /* Common blocks in huge model.  */
++
++/* Legal values for sh_type field of Elf32_Shdr.  */
++
++#define SHT_PARISC_EXT		0x70000000 /* Contains product specific ext. */
++#define SHT_PARISC_UNWIND	0x70000001 /* Unwind information.  */
++#define SHT_PARISC_DOC		0x70000002 /* Debug info for optimized code. */
++
++/* Legal values for sh_flags field of Elf32_Shdr.  */
++
++#define SHF_PARISC_SHORT	0x20000000 /* Section with short addressing. */
++#define SHF_PARISC_HUGE		0x40000000 /* Section far from gp.  */
++#define SHF_PARISC_SBP		0x80000000 /* Static branch prediction code. */
++
++/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
++
++#define STT_PARISC_MILLICODE	13	/* Millicode function entry point.  */
++
++#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
++#define STT_HP_STUB		(STT_LOOS + 0x2)
++
++/* HPPA relocs.  */
++
++#define R_PARISC_NONE		0	/* No reloc.  */
++#define R_PARISC_DIR32		1	/* Direct 32-bit reference.  */
++#define R_PARISC_DIR21L		2	/* Left 21 bits of eff. address.  */
++#define R_PARISC_DIR17R		3	/* Right 17 bits of eff. address.  */
++#define R_PARISC_DIR17F		4	/* 17 bits of eff. address.  */
++#define R_PARISC_DIR14R		6	/* Right 14 bits of eff. address.  */
++#define R_PARISC_PCREL32	9	/* 32-bit rel. address.  */
++#define R_PARISC_PCREL21L	10	/* Left 21 bits of rel. address.  */
++#define R_PARISC_PCREL17R	11	/* Right 17 bits of rel. address.  */
++#define R_PARISC_PCREL17F	12	/* 17 bits of rel. address.  */
++#define R_PARISC_PCREL14R	14	/* Right 14 bits of rel. address.  */
++#define R_PARISC_DPREL21L	18	/* Left 21 bits of rel. address.  */
++#define R_PARISC_DPREL14R	22	/* Right 14 bits of rel. address.  */
++#define R_PARISC_GPREL21L	26	/* GP-relative, left 21 bits.  */
++#define R_PARISC_GPREL14R	30	/* GP-relative, right 14 bits.  */
++#define R_PARISC_LTOFF21L	34	/* LT-relative, left 21 bits.  */
++#define R_PARISC_LTOFF14R	38	/* LT-relative, right 14 bits.  */
++#define R_PARISC_SECREL32	41	/* 32 bits section rel. address.  */
++#define R_PARISC_SEGBASE	48	/* No relocation, set segment base.  */
++#define R_PARISC_SEGREL32	49	/* 32 bits segment rel. address.  */
++#define R_PARISC_PLTOFF21L	50	/* PLT rel. address, left 21 bits.  */
++#define R_PARISC_PLTOFF14R	54	/* PLT rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF_FPTR32	57	/* 32 bits LT-rel. function pointer. */
++#define R_PARISC_LTOFF_FPTR21L	58	/* LT-rel. fct ptr, left 21 bits. */
++#define R_PARISC_LTOFF_FPTR14R	62	/* LT-rel. fct ptr, right 14 bits. */
++#define R_PARISC_FPTR64		64	/* 64 bits function address.  */
++#define R_PARISC_PLABEL32	65	/* 32 bits function address.  */
++#define R_PARISC_PLABEL21L	66	/* Left 21 bits of fdesc address.  */
++#define R_PARISC_PLABEL14R	70	/* Right 14 bits of fdesc address.  */
++#define R_PARISC_PCREL64	72	/* 64 bits PC-rel. address.  */
++#define R_PARISC_PCREL22F	74	/* 22 bits PC-rel. address.  */
++#define R_PARISC_PCREL14WR	75	/* PC-rel. address, right 14 bits.  */
++#define R_PARISC_PCREL14DR	76	/* PC rel. address, right 14 bits.  */
++#define R_PARISC_PCREL16F	77	/* 16 bits PC-rel. address.  */
++#define R_PARISC_PCREL16WF	78	/* 16 bits PC-rel. address.  */
++#define R_PARISC_PCREL16DF	79	/* 16 bits PC-rel. address.  */
++#define R_PARISC_DIR64		80	/* 64 bits of eff. address.  */
++#define R_PARISC_DIR14WR	83	/* 14 bits of eff. address.  */
++#define R_PARISC_DIR14DR	84	/* 14 bits of eff. address.  */
++#define R_PARISC_DIR16F		85	/* 16 bits of eff. address.  */
++#define R_PARISC_DIR16WF	86	/* 16 bits of eff. address.  */
++#define R_PARISC_DIR16DF	87	/* 16 bits of eff. address.  */
++#define R_PARISC_GPREL64	88	/* 64 bits of GP-rel. address.  */
++#define R_PARISC_GPREL14WR	91	/* GP-rel. address, right 14 bits.  */
++#define R_PARISC_GPREL14DR	92	/* GP-rel. address, right 14 bits.  */
++#define R_PARISC_GPREL16F	93	/* 16 bits GP-rel. address.  */
++#define R_PARISC_GPREL16WF	94	/* 16 bits GP-rel. address.  */
++#define R_PARISC_GPREL16DF	95	/* 16 bits GP-rel. address.  */
++#define R_PARISC_LTOFF64	96	/* 64 bits LT-rel. address.  */
++#define R_PARISC_LTOFF14WR	99	/* LT-rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF14DR	100	/* LT-rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF16F	101	/* 16 bits LT-rel. address.  */
++#define R_PARISC_LTOFF16WF	102	/* 16 bits LT-rel. address.  */
++#define R_PARISC_LTOFF16DF	103	/* 16 bits LT-rel. address.  */
++#define R_PARISC_SECREL64	104	/* 64 bits section rel. address.  */
++#define R_PARISC_SEGREL64	112	/* 64 bits segment rel. address.  */
++#define R_PARISC_PLTOFF14WR	115	/* PLT-rel. address, right 14 bits.  */
++#define R_PARISC_PLTOFF14DR	116	/* PLT-rel. address, right 14 bits.  */
++#define R_PARISC_PLTOFF16F	117	/* 16 bits LT-rel. address.  */
++#define R_PARISC_PLTOFF16WF	118	/* 16 bits PLT-rel. address.  */
++#define R_PARISC_PLTOFF16DF	119	/* 16 bits PLT-rel. address.  */
++#define R_PARISC_LTOFF_FPTR64	120	/* 64 bits LT-rel. function ptr.  */
++#define R_PARISC_LTOFF_FPTR14WR	123	/* LT-rel. fct. ptr., right 14 bits. */
++#define R_PARISC_LTOFF_FPTR14DR	124	/* LT-rel. fct. ptr., right 14 bits. */
++#define R_PARISC_LTOFF_FPTR16F	125	/* 16 bits LT-rel. function ptr.  */
++#define R_PARISC_LTOFF_FPTR16WF	126	/* 16 bits LT-rel. function ptr.  */
++#define R_PARISC_LTOFF_FPTR16DF	127	/* 16 bits LT-rel. function ptr.  */
++#define R_PARISC_LORESERVE	128
++#define R_PARISC_COPY		128	/* Copy relocation.  */
++#define R_PARISC_IPLT		129	/* Dynamic reloc, imported PLT */
++#define R_PARISC_EPLT		130	/* Dynamic reloc, exported PLT */
++#define R_PARISC_TPREL32	153	/* 32 bits TP-rel. address.  */
++#define R_PARISC_TPREL21L	154	/* TP-rel. address, left 21 bits.  */
++#define R_PARISC_TPREL14R	158	/* TP-rel. address, right 14 bits.  */
++#define R_PARISC_LTOFF_TP21L	162	/* LT-TP-rel. address, left 21 bits. */
++#define R_PARISC_LTOFF_TP14R	166	/* LT-TP-rel. address, right 14 bits.*/
++#define R_PARISC_LTOFF_TP14F	167	/* 14 bits LT-TP-rel. address.  */
++#define R_PARISC_TPREL64	216	/* 64 bits TP-rel. address.  */
++#define R_PARISC_TPREL14WR	219	/* TP-rel. address, right 14 bits.  */
++#define R_PARISC_TPREL14DR	220	/* TP-rel. address, right 14 bits.  */
++#define R_PARISC_TPREL16F	221	/* 16 bits TP-rel. address.  */
++#define R_PARISC_TPREL16WF	222	/* 16 bits TP-rel. address.  */
++#define R_PARISC_TPREL16DF	223	/* 16 bits TP-rel. address.  */
++#define R_PARISC_LTOFF_TP64	224	/* 64 bits LT-TP-rel. address.  */
++#define R_PARISC_LTOFF_TP14WR	227	/* LT-TP-rel. address, right 14 bits.*/
++#define R_PARISC_LTOFF_TP14DR	228	/* LT-TP-rel. address, right 14 bits.*/
++#define R_PARISC_LTOFF_TP16F	229	/* 16 bits LT-TP-rel. address.  */
++#define R_PARISC_LTOFF_TP16WF	230	/* 16 bits LT-TP-rel. address.  */
++#define R_PARISC_LTOFF_TP16DF	231	/* 16 bits LT-TP-rel. address.  */
++#define R_PARISC_GNU_VTENTRY	232
++#define R_PARISC_GNU_VTINHERIT	233
++#define R_PARISC_TLS_GD21L	234	/* GD 21-bit left.  */
++#define R_PARISC_TLS_GD14R	235	/* GD 14-bit right.  */
++#define R_PARISC_TLS_GDCALL	236	/* GD call to __t_g_a.  */
++#define R_PARISC_TLS_LDM21L	237	/* LD module 21-bit left.  */
++#define R_PARISC_TLS_LDM14R	238	/* LD module 14-bit right.  */
++#define R_PARISC_TLS_LDMCALL	239	/* LD module call to __t_g_a.  */
++#define R_PARISC_TLS_LDO21L	240	/* LD offset 21-bit left.  */
++#define R_PARISC_TLS_LDO14R	241	/* LD offset 14-bit right.  */
++#define R_PARISC_TLS_DTPMOD32	242	/* DTP module 32-bit.  */
++#define R_PARISC_TLS_DTPMOD64	243	/* DTP module 64-bit.  */
++#define R_PARISC_TLS_DTPOFF32	244	/* DTP offset 32-bit.  */
++#define R_PARISC_TLS_DTPOFF64	245	/* DTP offset 32-bit.  */
++#define R_PARISC_TLS_LE21L	R_PARISC_TPREL21L
++#define R_PARISC_TLS_LE14R	R_PARISC_TPREL14R
++#define R_PARISC_TLS_IE21L	R_PARISC_LTOFF_TP21L
++#define R_PARISC_TLS_IE14R	R_PARISC_LTOFF_TP14R
++#define R_PARISC_TLS_TPREL32	R_PARISC_TPREL32
++#define R_PARISC_TLS_TPREL64	R_PARISC_TPREL64
++#define R_PARISC_HIRESERVE	255
++
++/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */
++
++#define PT_HP_TLS		(PT_LOOS + 0x0)
++#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
++#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
++#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
++#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
++#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
++#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
++#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
++#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
++#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
++#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
++#define PT_HP_FASTBIND		(PT_LOOS + 0x11)
++#define PT_HP_OPT_ANNOT		(PT_LOOS + 0x12)
++#define PT_HP_HSL_ANNOT		(PT_LOOS + 0x13)
++#define PT_HP_STACK		(PT_LOOS + 0x14)
++
++#define PT_PARISC_ARCHEXT	0x70000000
++#define PT_PARISC_UNWIND	0x70000001
++
++/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */
++
++#define PF_PARISC_SBP		0x08000000
++
++#define PF_HP_PAGE_SIZE		0x00100000
++#define PF_HP_FAR_SHARED	0x00200000
++#define PF_HP_NEAR_SHARED	0x00400000
++#define PF_HP_CODE		0x01000000
++#define PF_HP_MODIFY		0x02000000
++#define PF_HP_LAZYSWAP		0x04000000
++#define PF_HP_SBP		0x08000000
++
++
++/* Alpha specific definitions.  */
++
++/* Legal values for e_flags field of Elf64_Ehdr.  */
++
++#define EF_ALPHA_32BIT		1	/* All addresses must be < 2GB.  */
++#define EF_ALPHA_CANRELAX	2	/* Relocations for relaxing exist.  */
++
++/* Legal values for sh_type field of Elf64_Shdr.  */
++
++/* These two are primerily concerned with ECOFF debugging info.  */
++#define SHT_ALPHA_DEBUG		0x70000001
++#define SHT_ALPHA_REGINFO	0x70000002
++
++/* Legal values for sh_flags field of Elf64_Shdr.  */
++
++#define SHF_ALPHA_GPREL		0x10000000
++
++/* Legal values for st_other field of Elf64_Sym.  */
++#define STO_ALPHA_NOPV		0x80	/* No PV required.  */
++#define STO_ALPHA_STD_GPLOAD	0x88	/* PV only used for initial ldgp.  */
++
++/* Alpha relocs.  */
++
++#define R_ALPHA_NONE		0	/* No reloc */
++#define R_ALPHA_REFLONG		1	/* Direct 32 bit */
++#define R_ALPHA_REFQUAD		2	/* Direct 64 bit */
++#define R_ALPHA_GPREL32		3	/* GP relative 32 bit */
++#define R_ALPHA_LITERAL		4	/* GP relative 16 bit w/optimization */
++#define R_ALPHA_LITUSE		5	/* Optimization hint for LITERAL */
++#define R_ALPHA_GPDISP		6	/* Add displacement to GP */
++#define R_ALPHA_BRADDR		7	/* PC+4 relative 23 bit shifted */
++#define R_ALPHA_HINT		8	/* PC+4 relative 16 bit shifted */
++#define R_ALPHA_SREL16		9	/* PC relative 16 bit */
++#define R_ALPHA_SREL32		10	/* PC relative 32 bit */
++#define R_ALPHA_SREL64		11	/* PC relative 64 bit */
++#define R_ALPHA_GPRELHIGH	17	/* GP relative 32 bit, high 16 bits */
++#define R_ALPHA_GPRELLOW	18	/* GP relative 32 bit, low 16 bits */
++#define R_ALPHA_GPREL16		19	/* GP relative 16 bit */
++#define R_ALPHA_COPY		24	/* Copy symbol at runtime */
++#define R_ALPHA_GLOB_DAT	25	/* Create GOT entry */
++#define R_ALPHA_JMP_SLOT	26	/* Create PLT entry */
++#define R_ALPHA_RELATIVE	27	/* Adjust by program base */
++#define R_ALPHA_TLS_GD_HI	28
++#define R_ALPHA_TLSGD		29
++#define R_ALPHA_TLS_LDM		30
++#define R_ALPHA_DTPMOD64	31
++#define R_ALPHA_GOTDTPREL	32
++#define R_ALPHA_DTPREL64	33
++#define R_ALPHA_DTPRELHI	34
++#define R_ALPHA_DTPRELLO	35
++#define R_ALPHA_DTPREL16	36
++#define R_ALPHA_GOTTPREL	37
++#define R_ALPHA_TPREL64		38
++#define R_ALPHA_TPRELHI		39
++#define R_ALPHA_TPRELLO		40
++#define R_ALPHA_TPREL16		41
++/* Keep this the last entry.  */
++#define R_ALPHA_NUM		46
++
++/* Magic values of the LITUSE relocation addend.  */
++#define LITUSE_ALPHA_ADDR	0
++#define LITUSE_ALPHA_BASE	1
++#define LITUSE_ALPHA_BYTOFF	2
++#define LITUSE_ALPHA_JSR	3
++#define LITUSE_ALPHA_TLS_GD	4
++#define LITUSE_ALPHA_TLS_LDM	5
++
++/* Legal values for d_tag of Elf64_Dyn.  */
++#define DT_ALPHA_PLTRO		(DT_LOPROC + 0)
++#define DT_ALPHA_NUM		1
++
++/* PowerPC specific declarations */
++
++/* Values for Elf32/64_Ehdr.e_flags.  */
++#define EF_PPC_EMB		0x80000000	/* PowerPC embedded flag */
++
++/* Cygnus local bits below */
++#define EF_PPC_RELOCATABLE	0x00010000	/* PowerPC -mrelocatable flag*/
++#define EF_PPC_RELOCATABLE_LIB	0x00008000	/* PowerPC -mrelocatable-lib
++						   flag */
++
++/* PowerPC relocations defined by the ABIs */
++#define R_PPC_NONE		0
++#define R_PPC_ADDR32		1	/* 32bit absolute address */
++#define R_PPC_ADDR24		2	/* 26bit address, 2 bits ignored.  */
++#define R_PPC_ADDR16		3	/* 16bit absolute address */
++#define R_PPC_ADDR16_LO		4	/* lower 16bit of absolute address */
++#define R_PPC_ADDR16_HI		5	/* high 16bit of absolute address */
++#define R_PPC_ADDR16_HA		6	/* adjusted high 16bit */
++#define R_PPC_ADDR14		7	/* 16bit address, 2 bits ignored */
++#define R_PPC_ADDR14_BRTAKEN	8
++#define R_PPC_ADDR14_BRNTAKEN	9
++#define R_PPC_REL24		10	/* PC relative 26 bit */
++#define R_PPC_REL14		11	/* PC relative 16 bit */
++#define R_PPC_REL14_BRTAKEN	12
++#define R_PPC_REL14_BRNTAKEN	13
++#define R_PPC_GOT16		14
++#define R_PPC_GOT16_LO		15
++#define R_PPC_GOT16_HI		16
++#define R_PPC_GOT16_HA		17
++#define R_PPC_PLTREL24		18
++#define R_PPC_COPY		19
++#define R_PPC_GLOB_DAT		20
++#define R_PPC_JMP_SLOT		21
++#define R_PPC_RELATIVE		22
++#define R_PPC_LOCAL24PC		23
++#define R_PPC_UADDR32		24
++#define R_PPC_UADDR16		25
++#define R_PPC_REL32		26
++#define R_PPC_PLT32		27
++#define R_PPC_PLTREL32		28
++#define R_PPC_PLT16_LO		29
++#define R_PPC_PLT16_HI		30
++#define R_PPC_PLT16_HA		31
++#define R_PPC_SDAREL16		32
++#define R_PPC_SECTOFF		33
++#define R_PPC_SECTOFF_LO	34
++#define R_PPC_SECTOFF_HI	35
++#define R_PPC_SECTOFF_HA	36
++
++/* PowerPC relocations defined for the TLS access ABI.  */
++#define R_PPC_TLS		67 /* none	(sym+add)@tls */
++#define R_PPC_DTPMOD32		68 /* word32	(sym+add)@dtpmod */
++#define R_PPC_TPREL16		69 /* half16*	(sym+add)@tprel */
++#define R_PPC_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
++#define R_PPC_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
++#define R_PPC_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
++#define R_PPC_TPREL32		73 /* word32	(sym+add)@tprel */
++#define R_PPC_DTPREL16		74 /* half16*	(sym+add)@dtprel */
++#define R_PPC_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
++#define R_PPC_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
++#define R_PPC_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
++#define R_PPC_DTPREL32		78 /* word32	(sym+add)@dtprel */
++#define R_PPC_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
++#define R_PPC_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
++#define R_PPC_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
++#define R_PPC_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
++#define R_PPC_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
++#define R_PPC_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
++#define R_PPC_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
++#define R_PPC_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
++#define R_PPC_GOT_TPREL16	87 /* half16*	(sym+add)@got@tprel */
++#define R_PPC_GOT_TPREL16_LO	88 /* half16	(sym+add)@got@tprel@l */
++#define R_PPC_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
++#define R_PPC_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
++#define R_PPC_GOT_DTPREL16	91 /* half16*	(sym+add)@got@dtprel */
++#define R_PPC_GOT_DTPREL16_LO	92 /* half16*	(sym+add)@got@dtprel@l */
++#define R_PPC_GOT_DTPREL16_HI	93 /* half16*	(sym+add)@got@dtprel@h */
++#define R_PPC_GOT_DTPREL16_HA	94 /* half16*	(sym+add)@got@dtprel@ha */
++
++/* The remaining relocs are from the Embedded ELF ABI, and are not
++   in the SVR4 ELF ABI.  */
++#define R_PPC_EMB_NADDR32	101
++#define R_PPC_EMB_NADDR16	102
++#define R_PPC_EMB_NADDR16_LO	103
++#define R_PPC_EMB_NADDR16_HI	104
++#define R_PPC_EMB_NADDR16_HA	105
++#define R_PPC_EMB_SDAI16	106
++#define R_PPC_EMB_SDA2I16	107
++#define R_PPC_EMB_SDA2REL	108
++#define R_PPC_EMB_SDA21		109	/* 16 bit offset in SDA */
++#define R_PPC_EMB_MRKREF	110
++#define R_PPC_EMB_RELSEC16	111
++#define R_PPC_EMB_RELST_LO	112
++#define R_PPC_EMB_RELST_HI	113
++#define R_PPC_EMB_RELST_HA	114
++#define R_PPC_EMB_BIT_FLD	115
++#define R_PPC_EMB_RELSDA	116	/* 16 bit relative offset in SDA */
++
++/* Diab tool relocations.  */
++#define R_PPC_DIAB_SDA21_LO	180	/* like EMB_SDA21, but lower 16 bit */
++#define R_PPC_DIAB_SDA21_HI	181	/* like EMB_SDA21, but high 16 bit */
++#define R_PPC_DIAB_SDA21_HA	182	/* like EMB_SDA21, adjusted high 16 */
++#define R_PPC_DIAB_RELSDA_LO	183	/* like EMB_RELSDA, but lower 16 bit */
++#define R_PPC_DIAB_RELSDA_HI	184	/* like EMB_RELSDA, but high 16 bit */
++#define R_PPC_DIAB_RELSDA_HA	185	/* like EMB_RELSDA, adjusted high 16 */
++
++/* GNU extension to support local ifunc.  */
++#define R_PPC_IRELATIVE		248
++
++/* GNU relocs used in PIC code sequences.  */
++#define R_PPC_REL16		249	/* half16   (sym+add-.) */
++#define R_PPC_REL16_LO		250	/* half16   (sym+add-.)@l */
++#define R_PPC_REL16_HI		251	/* half16   (sym+add-.)@h */
++#define R_PPC_REL16_HA		252	/* half16   (sym+add-.)@ha */
++
++/* This is a phony reloc to handle any old fashioned TOC16 references
++   that may still be in object files.  */
++#define R_PPC_TOC16		255
++
++/* PowerPC specific values for the Dyn d_tag field.  */
++#define DT_PPC_GOT		(DT_LOPROC + 0)
++#define DT_PPC_NUM		1
++
++/* PowerPC64 relocations defined by the ABIs */
++#define R_PPC64_NONE		R_PPC_NONE
++#define R_PPC64_ADDR32		R_PPC_ADDR32 /* 32bit absolute address */
++#define R_PPC64_ADDR24		R_PPC_ADDR24 /* 26bit address, word aligned */
++#define R_PPC64_ADDR16		R_PPC_ADDR16 /* 16bit absolute address */
++#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO	/* lower 16bits of address */
++#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI	/* high 16bits of address. */
++#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA /* adjusted high 16bits.  */
++#define R_PPC64_ADDR14		R_PPC_ADDR14 /* 16bit address, word aligned */
++#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
++#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
++#define R_PPC64_REL24		R_PPC_REL24 /* PC-rel. 26 bit, word aligned */
++#define R_PPC64_REL14		R_PPC_REL14 /* PC relative 16 bit */
++#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
++#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
++#define R_PPC64_GOT16		R_PPC_GOT16
++#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
++#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
++#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
++
++#define R_PPC64_COPY		R_PPC_COPY
++#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
++#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
++#define R_PPC64_RELATIVE	R_PPC_RELATIVE
++
++#define R_PPC64_UADDR32		R_PPC_UADDR32
++#define R_PPC64_UADDR16		R_PPC_UADDR16
++#define R_PPC64_REL32		R_PPC_REL32
++#define R_PPC64_PLT32		R_PPC_PLT32
++#define R_PPC64_PLTREL32	R_PPC_PLTREL32
++#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
++#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
++#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
++
++#define R_PPC64_SECTOFF		R_PPC_SECTOFF
++#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
++#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
++#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
++#define R_PPC64_ADDR30		37 /* word30 (S + A - P) >> 2 */
++#define R_PPC64_ADDR64		38 /* doubleword64 S + A */
++#define R_PPC64_ADDR16_HIGHER	39 /* half16 #higher(S + A) */
++#define R_PPC64_ADDR16_HIGHERA	40 /* half16 #highera(S + A) */
++#define R_PPC64_ADDR16_HIGHEST	41 /* half16 #highest(S + A) */
++#define R_PPC64_ADDR16_HIGHESTA	42 /* half16 #highesta(S + A) */
++#define R_PPC64_UADDR64		43 /* doubleword64 S + A */
++#define R_PPC64_REL64		44 /* doubleword64 S + A - P */
++#define R_PPC64_PLT64		45 /* doubleword64 L + A */
++#define R_PPC64_PLTREL64	46 /* doubleword64 L + A - P */
++#define R_PPC64_TOC16		47 /* half16* S + A - .TOC */
++#define R_PPC64_TOC16_LO	48 /* half16 #lo(S + A - .TOC.) */
++#define R_PPC64_TOC16_HI	49 /* half16 #hi(S + A - .TOC.) */
++#define R_PPC64_TOC16_HA	50 /* half16 #ha(S + A - .TOC.) */
++#define R_PPC64_TOC		51 /* doubleword64 .TOC */
++#define R_PPC64_PLTGOT16	52 /* half16* M + A */
++#define R_PPC64_PLTGOT16_LO	53 /* half16 #lo(M + A) */
++#define R_PPC64_PLTGOT16_HI	54 /* half16 #hi(M + A) */
++#define R_PPC64_PLTGOT16_HA	55 /* half16 #ha(M + A) */
++
++#define R_PPC64_ADDR16_DS	56 /* half16ds* (S + A) >> 2 */
++#define R_PPC64_ADDR16_LO_DS	57 /* half16ds  #lo(S + A) >> 2 */
++#define R_PPC64_GOT16_DS	58 /* half16ds* (G + A) >> 2 */
++#define R_PPC64_GOT16_LO_DS	59 /* half16ds  #lo(G + A) >> 2 */
++#define R_PPC64_PLT16_LO_DS	60 /* half16ds  #lo(L + A) >> 2 */
++#define R_PPC64_SECTOFF_DS	61 /* half16ds* (R + A) >> 2 */
++#define R_PPC64_SECTOFF_LO_DS	62 /* half16ds  #lo(R + A) >> 2 */
++#define R_PPC64_TOC16_DS	63 /* half16ds* (S + A - .TOC.) >> 2 */
++#define R_PPC64_TOC16_LO_DS	64 /* half16ds  #lo(S + A - .TOC.) >> 2 */
++#define R_PPC64_PLTGOT16_DS	65 /* half16ds* (M + A) >> 2 */
++#define R_PPC64_PLTGOT16_LO_DS	66 /* half16ds  #lo(M + A) >> 2 */
++
++/* PowerPC64 relocations defined for the TLS access ABI.  */
++#define R_PPC64_TLS		67 /* none	(sym+add)@tls */
++#define R_PPC64_DTPMOD64	68 /* doubleword64 (sym+add)@dtpmod */
++#define R_PPC64_TPREL16		69 /* half16*	(sym+add)@tprel */
++#define R_PPC64_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
++#define R_PPC64_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
++#define R_PPC64_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
++#define R_PPC64_TPREL64		73 /* doubleword64 (sym+add)@tprel */
++#define R_PPC64_DTPREL16	74 /* half16*	(sym+add)@dtprel */
++#define R_PPC64_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
++#define R_PPC64_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
++#define R_PPC64_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
++#define R_PPC64_DTPREL64	78 /* doubleword64 (sym+add)@dtprel */
++#define R_PPC64_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
++#define R_PPC64_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
++#define R_PPC64_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
++#define R_PPC64_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
++#define R_PPC64_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
++#define R_PPC64_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
++#define R_PPC64_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
++#define R_PPC64_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
++#define R_PPC64_GOT_TPREL16_DS	87 /* half16ds*	(sym+add)@got@tprel */
++#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */
++#define R_PPC64_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
++#define R_PPC64_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
++#define R_PPC64_GOT_DTPREL16_DS	91 /* half16ds*	(sym+add)@got@dtprel */
++#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */
++#define R_PPC64_GOT_DTPREL16_HI	93 /* half16	(sym+add)@got@dtprel@h */
++#define R_PPC64_GOT_DTPREL16_HA	94 /* half16	(sym+add)@got@dtprel@ha */
++#define R_PPC64_TPREL16_DS	95 /* half16ds*	(sym+add)@tprel */
++#define R_PPC64_TPREL16_LO_DS	96 /* half16ds	(sym+add)@tprel@l */
++#define R_PPC64_TPREL16_HIGHER	97 /* half16	(sym+add)@tprel@higher */
++#define R_PPC64_TPREL16_HIGHERA	98 /* half16	(sym+add)@tprel@highera */
++#define R_PPC64_TPREL16_HIGHEST	99 /* half16	(sym+add)@tprel@highest */
++#define R_PPC64_TPREL16_HIGHESTA 100 /* half16	(sym+add)@tprel@highesta */
++#define R_PPC64_DTPREL16_DS	101 /* half16ds* (sym+add)@dtprel */
++#define R_PPC64_DTPREL16_LO_DS	102 /* half16ds	(sym+add)@dtprel@l */
++#define R_PPC64_DTPREL16_HIGHER	103 /* half16	(sym+add)@dtprel@higher */
++#define R_PPC64_DTPREL16_HIGHERA 104 /* half16	(sym+add)@dtprel@highera */
++#define R_PPC64_DTPREL16_HIGHEST 105 /* half16	(sym+add)@dtprel@highest */
++#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16	(sym+add)@dtprel@highesta */
++
++/* GNU extension to support local ifunc.  */
++#define R_PPC64_JMP_IREL	247
++#define R_PPC64_IRELATIVE	248
++#define R_PPC64_REL16		249	/* half16   (sym+add-.) */
++#define R_PPC64_REL16_LO	250	/* half16   (sym+add-.)@l */
++#define R_PPC64_REL16_HI	251	/* half16   (sym+add-.)@h */
++#define R_PPC64_REL16_HA	252	/* half16   (sym+add-.)@ha */
++
++/* PowerPC64 specific values for the Dyn d_tag field.  */
++#define DT_PPC64_GLINK  (DT_LOPROC + 0)
++#define DT_PPC64_OPD	(DT_LOPROC + 1)
++#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
++#define DT_PPC64_NUM    3
++
++
++/* ARM specific declarations */
++
++/* Processor specific flags for the ELF header e_flags field.  */
++#define EF_ARM_RELEXEC		0x01
++#define EF_ARM_HASENTRY		0x02
++#define EF_ARM_INTERWORK	0x04
++#define EF_ARM_APCS_26		0x08
++#define EF_ARM_APCS_FLOAT	0x10
++#define EF_ARM_PIC		0x20
++#define EF_ARM_ALIGN8		0x40 /* 8-bit structure alignment is in use */
++#define EF_ARM_NEW_ABI		0x80
++#define EF_ARM_OLD_ABI		0x100
++#define EF_ARM_SOFT_FLOAT	0x200
++#define EF_ARM_VFP_FLOAT	0x400
++#define EF_ARM_MAVERICK_FLOAT	0x800
++
++
++/* Other constants defined in the ARM ELF spec. version B-01.  */
++/* NB. These conflict with values defined above.  */
++#define EF_ARM_SYMSARESORTED	0x04
++#define EF_ARM_DYNSYMSUSESEGIDX	0x08
++#define EF_ARM_MAPSYMSFIRST	0x10
++#define EF_ARM_EABIMASK		0XFF000000
++
++/* Constants defined in AAELF.  */
++#define EF_ARM_BE8	    0x00800000
++#define EF_ARM_LE8	    0x00400000
++
++#define EF_ARM_EABI_VERSION(flags)	((flags) & EF_ARM_EABIMASK)
++#define EF_ARM_EABI_UNKNOWN	0x00000000
++#define EF_ARM_EABI_VER1	0x01000000
++#define EF_ARM_EABI_VER2	0x02000000
++#define EF_ARM_EABI_VER3	0x03000000
++#define EF_ARM_EABI_VER4	0x04000000
++#define EF_ARM_EABI_VER5	0x05000000
++
++/* Additional symbol types for Thumb.  */
++#define STT_ARM_TFUNC		STT_LOPROC /* A Thumb function.  */
++#define STT_ARM_16BIT		STT_HIPROC /* A Thumb label.  */
++
++/* ARM-specific values for sh_flags */
++#define SHF_ARM_ENTRYSECT	0x10000000 /* Section contains an entry point */
++#define SHF_ARM_COMDEF		0x80000000 /* Section may be multiply defined
++					      in the input to a link step.  */
++
++/* ARM-specific program header flags */
++#define PF_ARM_SB		0x10000000 /* Segment contains the location
++					      addressed by the static base. */
++#define PF_ARM_PI		0x20000000 /* Position-independent segment.  */
++#define PF_ARM_ABS		0x40000000 /* Absolute segment.  */
++
++/* Processor specific values for the Phdr p_type field.  */
++#define PT_ARM_EXIDX		(PT_LOPROC + 1)	/* ARM unwind segment.  */
++
++/* Processor specific values for the Shdr sh_type field.  */
++#define SHT_ARM_EXIDX		(SHT_LOPROC + 1) /* ARM unwind section.  */
++#define SHT_ARM_PREEMPTMAP	(SHT_LOPROC + 2) /* Preemption details.  */
++#define SHT_ARM_ATTRIBUTES	(SHT_LOPROC + 3) /* ARM attributes section.  */
++
++
++/* ARM relocs.  */
++
++#define R_ARM_NONE		0	/* No reloc */
++#define R_ARM_PC24		1	/* PC relative 26 bit branch */
++#define R_ARM_ABS32		2	/* Direct 32 bit  */
++#define R_ARM_REL32		3	/* PC relative 32 bit */
++#define R_ARM_PC13		4
++#define R_ARM_ABS16		5	/* Direct 16 bit */
++#define R_ARM_ABS12		6	/* Direct 12 bit */
++#define R_ARM_THM_ABS5		7
++#define R_ARM_ABS8		8	/* Direct 8 bit */
++#define R_ARM_SBREL32		9
++#define R_ARM_THM_PC22		10
++#define R_ARM_THM_PC8		11
++#define R_ARM_AMP_VCALL9	12
++#define R_ARM_SWI24		13	/* Obsolete static relocation.  */
++#define R_ARM_TLS_DESC		13      /* Dynamic relocation.  */
++#define R_ARM_THM_SWI8		14
++#define R_ARM_XPC25		15
++#define R_ARM_THM_XPC22		16
++#define R_ARM_TLS_DTPMOD32	17	/* ID of module containing symbol */
++#define R_ARM_TLS_DTPOFF32	18	/* Offset in TLS block */
++#define R_ARM_TLS_TPOFF32	19	/* Offset in static TLS block */
++#define R_ARM_COPY		20	/* Copy symbol at runtime */
++#define R_ARM_GLOB_DAT		21	/* Create GOT entry */
++#define R_ARM_JUMP_SLOT		22	/* Create PLT entry */
++#define R_ARM_RELATIVE		23	/* Adjust by program base */
++#define R_ARM_GOTOFF		24	/* 32 bit offset to GOT */
++#define R_ARM_GOTPC		25	/* 32 bit PC relative offset to GOT */
++#define R_ARM_GOT32		26	/* 32 bit GOT entry */
++#define R_ARM_PLT32		27	/* 32 bit PLT address */
++#define R_ARM_ALU_PCREL_7_0	32
++#define R_ARM_ALU_PCREL_15_8	33
++#define R_ARM_ALU_PCREL_23_15	34
++#define R_ARM_LDR_SBREL_11_0	35
++#define R_ARM_ALU_SBREL_19_12	36
++#define R_ARM_ALU_SBREL_27_20	37
++#define R_ARM_TLS_GOTDESC	90
++#define R_ARM_TLS_CALL		91
++#define R_ARM_TLS_DESCSEQ	92
++#define R_ARM_THM_TLS_CALL	93
++#define R_ARM_GNU_VTENTRY	100
++#define R_ARM_GNU_VTINHERIT	101
++#define R_ARM_THM_PC11		102	/* thumb unconditional branch */
++#define R_ARM_THM_PC9		103	/* thumb conditional branch */
++#define R_ARM_TLS_GD32		104	/* PC-rel 32 bit for global dynamic
++					   thread local data */
++#define R_ARM_TLS_LDM32		105	/* PC-rel 32 bit for local dynamic
++					   thread local data */
++#define R_ARM_TLS_LDO32		106	/* 32 bit offset relative to TLS
++					   block */
++#define R_ARM_TLS_IE32		107	/* PC-rel 32 bit for GOT entry of
++					   static TLS block offset */
++#define R_ARM_TLS_LE32		108	/* 32 bit offset relative to static
++					   TLS block */
++#define	R_ARM_THM_TLS_DESCSEQ	129
++#define R_ARM_IRELATIVE		160
++#define R_ARM_RXPC25		249
++#define R_ARM_RSBREL32		250
++#define R_ARM_THM_RPC22		251
++#define R_ARM_RREL32		252
++#define R_ARM_RABS22		253
++#define R_ARM_RPC24		254
++#define R_ARM_RBASE		255
++/* Keep this the last entry.  */
++#define R_ARM_NUM		256
++
++/* IA-64 specific declarations.  */
++
++/* Processor specific flags for the Ehdr e_flags field.  */
++#define EF_IA_64_MASKOS		0x0000000f	/* os-specific flags */
++#define EF_IA_64_ABI64		0x00000010	/* 64-bit ABI */
++#define EF_IA_64_ARCH		0xff000000	/* arch. version mask */
++
++/* Processor specific values for the Phdr p_type field.  */
++#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)	/* arch extension bits */
++#define PT_IA_64_UNWIND		(PT_LOPROC + 1)	/* ia64 unwind bits */
++#define PT_IA_64_HP_OPT_ANOT	(PT_LOOS + 0x12)
++#define PT_IA_64_HP_HSL_ANOT	(PT_LOOS + 0x13)
++#define PT_IA_64_HP_STACK	(PT_LOOS + 0x14)
++
++/* Processor specific flags for the Phdr p_flags field.  */
++#define PF_IA_64_NORECOV	0x80000000	/* spec insns w/o recovery */
++
++/* Processor specific values for the Shdr sh_type field.  */
++#define SHT_IA_64_EXT		(SHT_LOPROC + 0) /* extension bits */
++#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1) /* unwind bits */
++
++/* Processor specific flags for the Shdr sh_flags field.  */
++#define SHF_IA_64_SHORT		0x10000000	/* section near gp */
++#define SHF_IA_64_NORECOV	0x20000000	/* spec insns w/o recovery */
++
++/* Processor specific values for the Dyn d_tag field.  */
++#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
++#define DT_IA_64_NUM		1
++
++/* IA-64 relocations.  */
++#define R_IA64_NONE		0x00	/* none */
++#define R_IA64_IMM14		0x21	/* symbol + addend, add imm14 */
++#define R_IA64_IMM22		0x22	/* symbol + addend, add imm22 */
++#define R_IA64_IMM64		0x23	/* symbol + addend, mov imm64 */
++#define R_IA64_DIR32MSB		0x24	/* symbol + addend, data4 MSB */
++#define R_IA64_DIR32LSB		0x25	/* symbol + addend, data4 LSB */
++#define R_IA64_DIR64MSB		0x26	/* symbol + addend, data8 MSB */
++#define R_IA64_DIR64LSB		0x27	/* symbol + addend, data8 LSB */
++#define R_IA64_GPREL22		0x2a	/* @gprel(sym + add), add imm22 */
++#define R_IA64_GPREL64I		0x2b	/* @gprel(sym + add), mov imm64 */
++#define R_IA64_GPREL32MSB	0x2c	/* @gprel(sym + add), data4 MSB */
++#define R_IA64_GPREL32LSB	0x2d	/* @gprel(sym + add), data4 LSB */
++#define R_IA64_GPREL64MSB	0x2e	/* @gprel(sym + add), data8 MSB */
++#define R_IA64_GPREL64LSB	0x2f	/* @gprel(sym + add), data8 LSB */
++#define R_IA64_LTOFF22		0x32	/* @ltoff(sym + add), add imm22 */
++#define R_IA64_LTOFF64I		0x33	/* @ltoff(sym + add), mov imm64 */
++#define R_IA64_PLTOFF22		0x3a	/* @pltoff(sym + add), add imm22 */
++#define R_IA64_PLTOFF64I	0x3b	/* @pltoff(sym + add), mov imm64 */
++#define R_IA64_PLTOFF64MSB	0x3e	/* @pltoff(sym + add), data8 MSB */
++#define R_IA64_PLTOFF64LSB	0x3f	/* @pltoff(sym + add), data8 LSB */
++#define R_IA64_FPTR64I		0x43	/* @fptr(sym + add), mov imm64 */
++#define R_IA64_FPTR32MSB	0x44	/* @fptr(sym + add), data4 MSB */
++#define R_IA64_FPTR32LSB	0x45	/* @fptr(sym + add), data4 LSB */
++#define R_IA64_FPTR64MSB	0x46	/* @fptr(sym + add), data8 MSB */
++#define R_IA64_FPTR64LSB	0x47	/* @fptr(sym + add), data8 LSB */
++#define R_IA64_PCREL60B		0x48	/* @pcrel(sym + add), brl */
++#define R_IA64_PCREL21B		0x49	/* @pcrel(sym + add), ptb, call */
++#define R_IA64_PCREL21M		0x4a	/* @pcrel(sym + add), chk.s */
++#define R_IA64_PCREL21F		0x4b	/* @pcrel(sym + add), fchkf */
++#define R_IA64_PCREL32MSB	0x4c	/* @pcrel(sym + add), data4 MSB */
++#define R_IA64_PCREL32LSB	0x4d	/* @pcrel(sym + add), data4 LSB */
++#define R_IA64_PCREL64MSB	0x4e	/* @pcrel(sym + add), data8 MSB */
++#define R_IA64_PCREL64LSB	0x4f	/* @pcrel(sym + add), data8 LSB */
++#define R_IA64_LTOFF_FPTR22	0x52	/* @ltoff(@fptr(s+a)), imm22 */
++#define R_IA64_LTOFF_FPTR64I	0x53	/* @ltoff(@fptr(s+a)), imm64 */
++#define R_IA64_LTOFF_FPTR32MSB	0x54	/* @ltoff(@fptr(s+a)), data4 MSB */
++#define R_IA64_LTOFF_FPTR32LSB	0x55	/* @ltoff(@fptr(s+a)), data4 LSB */
++#define R_IA64_LTOFF_FPTR64MSB	0x56	/* @ltoff(@fptr(s+a)), data8 MSB */
++#define R_IA64_LTOFF_FPTR64LSB	0x57	/* @ltoff(@fptr(s+a)), data8 LSB */
++#define R_IA64_SEGREL32MSB	0x5c	/* @segrel(sym + add), data4 MSB */
++#define R_IA64_SEGREL32LSB	0x5d	/* @segrel(sym + add), data4 LSB */
++#define R_IA64_SEGREL64MSB	0x5e	/* @segrel(sym + add), data8 MSB */
++#define R_IA64_SEGREL64LSB	0x5f	/* @segrel(sym + add), data8 LSB */
++#define R_IA64_SECREL32MSB	0x64	/* @secrel(sym + add), data4 MSB */
++#define R_IA64_SECREL32LSB	0x65	/* @secrel(sym + add), data4 LSB */
++#define R_IA64_SECREL64MSB	0x66	/* @secrel(sym + add), data8 MSB */
++#define R_IA64_SECREL64LSB	0x67	/* @secrel(sym + add), data8 LSB */
++#define R_IA64_REL32MSB		0x6c	/* data 4 + REL */
++#define R_IA64_REL32LSB		0x6d	/* data 4 + REL */
++#define R_IA64_REL64MSB		0x6e	/* data 8 + REL */
++#define R_IA64_REL64LSB		0x6f	/* data 8 + REL */
++#define R_IA64_LTV32MSB		0x74	/* symbol + addend, data4 MSB */
++#define R_IA64_LTV32LSB		0x75	/* symbol + addend, data4 LSB */
++#define R_IA64_LTV64MSB		0x76	/* symbol + addend, data8 MSB */
++#define R_IA64_LTV64LSB		0x77	/* symbol + addend, data8 LSB */
++#define R_IA64_PCREL21BI	0x79	/* @pcrel(sym + add), 21bit inst */
++#define R_IA64_PCREL22		0x7a	/* @pcrel(sym + add), 22bit inst */
++#define R_IA64_PCREL64I		0x7b	/* @pcrel(sym + add), 64bit inst */
++#define R_IA64_IPLTMSB		0x80	/* dynamic reloc, imported PLT, MSB */
++#define R_IA64_IPLTLSB		0x81	/* dynamic reloc, imported PLT, LSB */
++#define R_IA64_COPY		0x84	/* copy relocation */
++#define R_IA64_SUB		0x85	/* Addend and symbol difference */
++#define R_IA64_LTOFF22X		0x86	/* LTOFF22, relaxable.  */
++#define R_IA64_LDXMOV		0x87	/* Use of LTOFF22X.  */
++#define R_IA64_TPREL14		0x91	/* @tprel(sym + add), imm14 */
++#define R_IA64_TPREL22		0x92	/* @tprel(sym + add), imm22 */
++#define R_IA64_TPREL64I		0x93	/* @tprel(sym + add), imm64 */
++#define R_IA64_TPREL64MSB	0x96	/* @tprel(sym + add), data8 MSB */
++#define R_IA64_TPREL64LSB	0x97	/* @tprel(sym + add), data8 LSB */
++#define R_IA64_LTOFF_TPREL22	0x9a	/* @ltoff(@tprel(s+a)), imm2 */
++#define R_IA64_DTPMOD64MSB	0xa6	/* @dtpmod(sym + add), data8 MSB */
++#define R_IA64_DTPMOD64LSB	0xa7	/* @dtpmod(sym + add), data8 LSB */
++#define R_IA64_LTOFF_DTPMOD22	0xaa	/* @ltoff(@dtpmod(sym + add)), imm22 */
++#define R_IA64_DTPREL14		0xb1	/* @dtprel(sym + add), imm14 */
++#define R_IA64_DTPREL22		0xb2	/* @dtprel(sym + add), imm22 */
++#define R_IA64_DTPREL64I	0xb3	/* @dtprel(sym + add), imm64 */
++#define R_IA64_DTPREL32MSB	0xb4	/* @dtprel(sym + add), data4 MSB */
++#define R_IA64_DTPREL32LSB	0xb5	/* @dtprel(sym + add), data4 LSB */
++#define R_IA64_DTPREL64MSB	0xb6	/* @dtprel(sym + add), data8 MSB */
++#define R_IA64_DTPREL64LSB	0xb7	/* @dtprel(sym + add), data8 LSB */
++#define R_IA64_LTOFF_DTPREL22	0xba	/* @ltoff(@dtprel(s+a)), imm22 */
++
++/* SH specific declarations */
++
++/* Processor specific flags for the ELF header e_flags field.  */
++#define EF_SH_MACH_MASK		0x1f
++#define EF_SH_UNKNOWN		0x0
++#define EF_SH1			0x1
++#define EF_SH2			0x2
++#define EF_SH3			0x3
++#define EF_SH_DSP		0x4
++#define EF_SH3_DSP		0x5
++#define EF_SH4AL_DSP		0x6
++#define EF_SH3E			0x8
++#define EF_SH4			0x9
++#define EF_SH2E			0xb
++#define EF_SH4A			0xc
++#define EF_SH2A			0xd
++#define EF_SH4_NOFPU		0x10
++#define EF_SH4A_NOFPU		0x11
++#define EF_SH4_NOMMU_NOFPU	0x12
++#define EF_SH2A_NOFPU		0x13
++#define EF_SH3_NOMMU		0x14
++#define EF_SH2A_SH4_NOFPU	0x15
++#define EF_SH2A_SH3_NOFPU	0x16
++#define EF_SH2A_SH4		0x17
++#define EF_SH2A_SH3E		0x18
++
++/* SH relocs.  */
++#define	R_SH_NONE		0
++#define	R_SH_DIR32		1
++#define	R_SH_REL32		2
++#define	R_SH_DIR8WPN		3
++#define	R_SH_IND12W		4
++#define	R_SH_DIR8WPL		5
++#define	R_SH_DIR8WPZ		6
++#define	R_SH_DIR8BP		7
++#define	R_SH_DIR8W		8
++#define	R_SH_DIR8L		9
++#define	R_SH_SWITCH16		25
++#define	R_SH_SWITCH32		26
++#define	R_SH_USES		27
++#define	R_SH_COUNT		28
++#define	R_SH_ALIGN		29
++#define	R_SH_CODE		30
++#define	R_SH_DATA		31
++#define	R_SH_LABEL		32
++#define	R_SH_SWITCH8		33
++#define	R_SH_GNU_VTINHERIT	34
++#define	R_SH_GNU_VTENTRY	35
++#define	R_SH_TLS_GD_32		144
++#define	R_SH_TLS_LD_32		145
++#define	R_SH_TLS_LDO_32		146
++#define	R_SH_TLS_IE_32		147
++#define	R_SH_TLS_LE_32		148
++#define	R_SH_TLS_DTPMOD32	149
++#define	R_SH_TLS_DTPOFF32	150
++#define	R_SH_TLS_TPOFF32	151
++#define	R_SH_GOT32		160
++#define	R_SH_PLT32		161
++#define	R_SH_COPY		162
++#define	R_SH_GLOB_DAT		163
++#define	R_SH_JMP_SLOT		164
++#define	R_SH_RELATIVE		165
++#define	R_SH_GOTOFF		166
++#define	R_SH_GOTPC		167
++/* Keep this the last entry.  */
++#define	R_SH_NUM		256
++
++/* S/390 specific definitions.  */
++
++/* Valid values for the e_flags field.  */
++
++#define EF_S390_HIGH_GPRS    0x00000001  /* High GPRs kernel facility needed.  */
++
++/* Additional s390 relocs */
++
++#define R_390_NONE		0	/* No reloc.  */
++#define R_390_8			1	/* Direct 8 bit.  */
++#define R_390_12		2	/* Direct 12 bit.  */
++#define R_390_16		3	/* Direct 16 bit.  */
++#define R_390_32		4	/* Direct 32 bit.  */
++#define R_390_PC32		5	/* PC relative 32 bit.	*/
++#define R_390_GOT12		6	/* 12 bit GOT offset.  */
++#define R_390_GOT32		7	/* 32 bit GOT offset.  */
++#define R_390_PLT32		8	/* 32 bit PC relative PLT address.  */
++#define R_390_COPY		9	/* Copy symbol at runtime.  */
++#define R_390_GLOB_DAT		10	/* Create GOT entry.  */
++#define R_390_JMP_SLOT		11	/* Create PLT entry.  */
++#define R_390_RELATIVE		12	/* Adjust by program base.  */
++#define R_390_GOTOFF32		13	/* 32 bit offset to GOT.	 */
++#define R_390_GOTPC		14	/* 32 bit PC relative offset to GOT.  */
++#define R_390_GOT16		15	/* 16 bit GOT offset.  */
++#define R_390_PC16		16	/* PC relative 16 bit.	*/
++#define R_390_PC16DBL		17	/* PC relative 16 bit shifted by 1.  */
++#define R_390_PLT16DBL		18	/* 16 bit PC rel. PLT shifted by 1.  */
++#define R_390_PC32DBL		19	/* PC relative 32 bit shifted by 1.  */
++#define R_390_PLT32DBL		20	/* 32 bit PC rel. PLT shifted by 1.  */
++#define R_390_GOTPCDBL		21	/* 32 bit PC rel. GOT shifted by 1.  */
++#define R_390_64		22	/* Direct 64 bit.  */
++#define R_390_PC64		23	/* PC relative 64 bit.	*/
++#define R_390_GOT64		24	/* 64 bit GOT offset.  */
++#define R_390_PLT64		25	/* 64 bit PC relative PLT address.  */
++#define R_390_GOTENT		26	/* 32 bit PC rel. to GOT entry >> 1. */
++#define R_390_GOTOFF16		27	/* 16 bit offset to GOT. */
++#define R_390_GOTOFF64		28	/* 64 bit offset to GOT. */
++#define R_390_GOTPLT12		29	/* 12 bit offset to jump slot.	*/
++#define R_390_GOTPLT16		30	/* 16 bit offset to jump slot.	*/
++#define R_390_GOTPLT32		31	/* 32 bit offset to jump slot.	*/
++#define R_390_GOTPLT64		32	/* 64 bit offset to jump slot.	*/
++#define R_390_GOTPLTENT		33	/* 32 bit rel. offset to jump slot.  */
++#define R_390_PLTOFF16		34	/* 16 bit offset from GOT to PLT. */
++#define R_390_PLTOFF32		35	/* 32 bit offset from GOT to PLT. */
++#define R_390_PLTOFF64		36	/* 16 bit offset from GOT to PLT. */
++#define R_390_TLS_LOAD		37	/* Tag for load insn in TLS code.  */
++#define R_390_TLS_GDCALL	38	/* Tag for function call in general
++					   dynamic TLS code. */
++#define R_390_TLS_LDCALL	39	/* Tag for function call in local
++					   dynamic TLS code. */
++#define R_390_TLS_GD32		40	/* Direct 32 bit for general dynamic
++					   thread local data.  */
++#define R_390_TLS_GD64		41	/* Direct 64 bit for general dynamic
++					  thread local data.  */
++#define R_390_TLS_GOTIE12	42	/* 12 bit GOT offset for static TLS
++					   block offset.  */
++#define R_390_TLS_GOTIE32	43	/* 32 bit GOT offset for static TLS
++					   block offset.  */
++#define R_390_TLS_GOTIE64	44	/* 64 bit GOT offset for static TLS
++					   block offset. */
++#define R_390_TLS_LDM32		45	/* Direct 32 bit for local dynamic
++					   thread local data in LE code.  */
++#define R_390_TLS_LDM64		46	/* Direct 64 bit for local dynamic
++					   thread local data in LE code.  */
++#define R_390_TLS_IE32		47	/* 32 bit address of GOT entry for
++					   negated static TLS block offset.  */
++#define R_390_TLS_IE64		48	/* 64 bit address of GOT entry for
++					   negated static TLS block offset.  */
++#define R_390_TLS_IEENT		49	/* 32 bit rel. offset to GOT entry for
++					   negated static TLS block offset.  */
++#define R_390_TLS_LE32		50	/* 32 bit negated offset relative to
++					   static TLS block.  */
++#define R_390_TLS_LE64		51	/* 64 bit negated offset relative to
++					   static TLS block.  */
++#define R_390_TLS_LDO32		52	/* 32 bit offset relative to TLS
++					   block.  */
++#define R_390_TLS_LDO64		53	/* 64 bit offset relative to TLS
++					   block.  */
++#define R_390_TLS_DTPMOD	54	/* ID of module containing symbol.  */
++#define R_390_TLS_DTPOFF	55	/* Offset in TLS block.	 */
++#define R_390_TLS_TPOFF		56	/* Negated offset in static TLS
++					   block.  */
++#define R_390_20		57	/* Direct 20 bit.  */
++#define R_390_GOT20		58	/* 20 bit GOT offset.  */
++#define R_390_GOTPLT20		59	/* 20 bit offset to jump slot.  */
++#define R_390_TLS_GOTIE20	60	/* 20 bit GOT offset for static TLS
++					   block offset.  */
++#define R_390_IRELATIVE         61      /* STT_GNU_IFUNC relocation.  */
++/* Keep this the last entry.  */
++#define R_390_NUM		62
++
++
++/* CRIS relocations.  */
++#define R_CRIS_NONE		0
++#define R_CRIS_8		1
++#define R_CRIS_16		2
++#define R_CRIS_32		3
++#define R_CRIS_8_PCREL		4
++#define R_CRIS_16_PCREL		5
++#define R_CRIS_32_PCREL		6
++#define R_CRIS_GNU_VTINHERIT	7
++#define R_CRIS_GNU_VTENTRY	8
++#define R_CRIS_COPY		9
++#define R_CRIS_GLOB_DAT		10
++#define R_CRIS_JUMP_SLOT	11
++#define R_CRIS_RELATIVE		12
++#define R_CRIS_16_GOT		13
++#define R_CRIS_32_GOT		14
++#define R_CRIS_16_GOTPLT	15
++#define R_CRIS_32_GOTPLT	16
++#define R_CRIS_32_GOTREL	17
++#define R_CRIS_32_PLT_GOTREL	18
++#define R_CRIS_32_PLT_PCREL	19
++
++#define R_CRIS_NUM		20
++
++
++/* AMD x86-64 relocations.  */
++#define R_X86_64_NONE		0	/* No reloc */
++#define R_X86_64_64		1	/* Direct 64 bit  */
++#define R_X86_64_PC32		2	/* PC relative 32 bit signed */
++#define R_X86_64_GOT32		3	/* 32 bit GOT entry */
++#define R_X86_64_PLT32		4	/* 32 bit PLT address */
++#define R_X86_64_COPY		5	/* Copy symbol at runtime */
++#define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
++#define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
++#define R_X86_64_RELATIVE	8	/* Adjust by program base */
++#define R_X86_64_GOTPCREL	9	/* 32 bit signed PC relative
++					   offset to GOT */
++#define R_X86_64_32		10	/* Direct 32 bit zero extended */
++#define R_X86_64_32S		11	/* Direct 32 bit sign extended */
++#define R_X86_64_16		12	/* Direct 16 bit zero extended */
++#define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
++#define R_X86_64_8		14	/* Direct 8 bit sign extended  */
++#define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
++#define R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
++#define R_X86_64_DTPOFF64	17	/* Offset in module's TLS block */
++#define R_X86_64_TPOFF64	18	/* Offset in initial TLS block */
++#define R_X86_64_TLSGD		19	/* 32 bit signed PC relative offset
++					   to two GOT entries for GD symbol */
++#define R_X86_64_TLSLD		20	/* 32 bit signed PC relative offset
++					   to two GOT entries for LD symbol */
++#define R_X86_64_DTPOFF32	21	/* Offset in TLS block */
++#define R_X86_64_GOTTPOFF	22	/* 32 bit signed PC relative offset
++					   to GOT entry for IE symbol */
++#define R_X86_64_TPOFF32	23	/* Offset in initial TLS block */
++#define R_X86_64_PC64		24	/* PC relative 64 bit */
++#define R_X86_64_GOTOFF64	25	/* 64 bit offset to GOT */
++#define R_X86_64_GOTPC32	26	/* 32 bit signed pc relative
++					   offset to GOT */
++#define R_X86_64_GOT64		27	/* 64-bit GOT entry offset */
++#define R_X86_64_GOTPCREL64	28	/* 64-bit PC relative offset
++					   to GOT entry */
++#define R_X86_64_GOTPC64	29	/* 64-bit PC relative offset to GOT */
++#define R_X86_64_GOTPLT64	30 	/* like GOT64, says PLT entry needed */
++#define R_X86_64_PLTOFF64	31	/* 64-bit GOT relative offset
++					   to PLT entry */
++#define R_X86_64_SIZE32		32	/* Size of symbol plus 32-bit addend */
++#define R_X86_64_SIZE64		33	/* Size of symbol plus 64-bit addend */
++#define R_X86_64_GOTPC32_TLSDESC 34	/* GOT offset for TLS descriptor.  */
++#define R_X86_64_TLSDESC_CALL   35	/* Marker for call through TLS
++					   descriptor.  */
++#define R_X86_64_TLSDESC        36	/* TLS descriptor.  */
++#define R_X86_64_IRELATIVE	37	/* Adjust indirectly by program base */
++#define R_X86_64_RELATIVE64	38	/* 64-bit adjust by program base */
++
++#define R_X86_64_NUM		39
++
++
++/* AM33 relocations.  */
++#define R_MN10300_NONE		0	/* No reloc.  */
++#define R_MN10300_32		1	/* Direct 32 bit.  */
++#define R_MN10300_16		2	/* Direct 16 bit.  */
++#define R_MN10300_8		3	/* Direct 8 bit.  */
++#define R_MN10300_PCREL32	4	/* PC-relative 32-bit.  */
++#define R_MN10300_PCREL16	5	/* PC-relative 16-bit signed.  */
++#define R_MN10300_PCREL8	6	/* PC-relative 8-bit signed.  */
++#define R_MN10300_GNU_VTINHERIT	7	/* Ancient C++ vtable garbage... */
++#define R_MN10300_GNU_VTENTRY	8	/* ... collection annotation.  */
++#define R_MN10300_24		9	/* Direct 24 bit.  */
++#define R_MN10300_GOTPC32	10	/* 32-bit PCrel offset to GOT.  */
++#define R_MN10300_GOTPC16	11	/* 16-bit PCrel offset to GOT.  */
++#define R_MN10300_GOTOFF32	12	/* 32-bit offset from GOT.  */
++#define R_MN10300_GOTOFF24	13	/* 24-bit offset from GOT.  */
++#define R_MN10300_GOTOFF16	14	/* 16-bit offset from GOT.  */
++#define R_MN10300_PLT32		15	/* 32-bit PCrel to PLT entry.  */
++#define R_MN10300_PLT16		16	/* 16-bit PCrel to PLT entry.  */
++#define R_MN10300_GOT32		17	/* 32-bit offset to GOT entry.  */
++#define R_MN10300_GOT24		18	/* 24-bit offset to GOT entry.  */
++#define R_MN10300_GOT16		19	/* 16-bit offset to GOT entry.  */
++#define R_MN10300_COPY		20	/* Copy symbol at runtime.  */
++#define R_MN10300_GLOB_DAT	21	/* Create GOT entry.  */
++#define R_MN10300_JMP_SLOT	22	/* Create PLT entry.  */
++#define R_MN10300_RELATIVE	23	/* Adjust by program base.  */
++
++#define R_MN10300_NUM		24
++
++
++/* M32R relocs.  */
++#define R_M32R_NONE		0	/* No reloc. */
++#define R_M32R_16		1	/* Direct 16 bit. */
++#define R_M32R_32		2	/* Direct 32 bit. */
++#define R_M32R_24		3	/* Direct 24 bit. */
++#define R_M32R_10_PCREL		4	/* PC relative 10 bit shifted. */
++#define R_M32R_18_PCREL		5	/* PC relative 18 bit shifted. */
++#define R_M32R_26_PCREL		6	/* PC relative 26 bit shifted. */
++#define R_M32R_HI16_ULO		7	/* High 16 bit with unsigned low. */
++#define R_M32R_HI16_SLO		8	/* High 16 bit with signed low. */
++#define R_M32R_LO16		9	/* Low 16 bit. */
++#define R_M32R_SDA16		10	/* 16 bit offset in SDA. */
++#define R_M32R_GNU_VTINHERIT	11
++#define R_M32R_GNU_VTENTRY	12
++/* M32R relocs use SHT_RELA.  */
++#define R_M32R_16_RELA		33	/* Direct 16 bit. */
++#define R_M32R_32_RELA		34	/* Direct 32 bit. */
++#define R_M32R_24_RELA		35	/* Direct 24 bit. */
++#define R_M32R_10_PCREL_RELA	36	/* PC relative 10 bit shifted. */
++#define R_M32R_18_PCREL_RELA	37	/* PC relative 18 bit shifted. */
++#define R_M32R_26_PCREL_RELA	38	/* PC relative 26 bit shifted. */
++#define R_M32R_HI16_ULO_RELA	39	/* High 16 bit with unsigned low */
++#define R_M32R_HI16_SLO_RELA	40	/* High 16 bit with signed low */
++#define R_M32R_LO16_RELA	41	/* Low 16 bit */
++#define R_M32R_SDA16_RELA	42	/* 16 bit offset in SDA */
++#define R_M32R_RELA_GNU_VTINHERIT	43
++#define R_M32R_RELA_GNU_VTENTRY	44
++#define R_M32R_REL32		45	/* PC relative 32 bit.  */
++
++#define R_M32R_GOT24		48	/* 24 bit GOT entry */
++#define R_M32R_26_PLTREL	49	/* 26 bit PC relative to PLT shifted */
++#define R_M32R_COPY		50	/* Copy symbol at runtime */
++#define R_M32R_GLOB_DAT		51	/* Create GOT entry */
++#define R_M32R_JMP_SLOT		52	/* Create PLT entry */
++#define R_M32R_RELATIVE		53	/* Adjust by program base */
++#define R_M32R_GOTOFF		54	/* 24 bit offset to GOT */
++#define R_M32R_GOTPC24		55	/* 24 bit PC relative offset to GOT */
++#define R_M32R_GOT16_HI_ULO	56	/* High 16 bit GOT entry with unsigned
++					   low */
++#define R_M32R_GOT16_HI_SLO	57	/* High 16 bit GOT entry with signed
++					   low */
++#define R_M32R_GOT16_LO		58	/* Low 16 bit GOT entry */
++#define R_M32R_GOTPC_HI_ULO	59	/* High 16 bit PC relative offset to
++					   GOT with unsigned low */
++#define R_M32R_GOTPC_HI_SLO	60	/* High 16 bit PC relative offset to
++					   GOT with signed low */
++#define R_M32R_GOTPC_LO		61	/* Low 16 bit PC relative offset to
++					   GOT */
++#define R_M32R_GOTOFF_HI_ULO	62	/* High 16 bit offset to GOT
++					   with unsigned low */
++#define R_M32R_GOTOFF_HI_SLO	63	/* High 16 bit offset to GOT
++					   with signed low */
++#define R_M32R_GOTOFF_LO	64	/* Low 16 bit offset to GOT */
++#define R_M32R_NUM		256	/* Keep this the last entry. */
++
++
++/* TILEPro relocations.  */
++#define R_TILEPRO_NONE		0	/* No reloc */
++#define R_TILEPRO_32		1	/* Direct 32 bit */
++#define R_TILEPRO_16		2	/* Direct 16 bit */
++#define R_TILEPRO_8		3	/* Direct 8 bit */
++#define R_TILEPRO_32_PCREL	4	/* PC relative 32 bit */
++#define R_TILEPRO_16_PCREL	5	/* PC relative 16 bit */
++#define R_TILEPRO_8_PCREL	6	/* PC relative 8 bit */
++#define R_TILEPRO_LO16		7	/* Low 16 bit */
++#define R_TILEPRO_HI16		8	/* High 16 bit */
++#define R_TILEPRO_HA16		9	/* High 16 bit, adjusted */
++#define R_TILEPRO_COPY		10	/* Copy relocation */
++#define R_TILEPRO_GLOB_DAT	11	/* Create GOT entry */
++#define R_TILEPRO_JMP_SLOT	12	/* Create PLT entry */
++#define R_TILEPRO_RELATIVE	13	/* Adjust by program base */
++#define R_TILEPRO_BROFF_X1	14	/* X1 pipe branch offset */
++#define R_TILEPRO_JOFFLONG_X1	15	/* X1 pipe jump offset */
++#define R_TILEPRO_JOFFLONG_X1_PLT 16	/* X1 pipe jump offset to PLT */
++#define R_TILEPRO_IMM8_X0	17	/* X0 pipe 8-bit */
++#define R_TILEPRO_IMM8_Y0	18	/* Y0 pipe 8-bit */
++#define R_TILEPRO_IMM8_X1	19	/* X1 pipe 8-bit */
++#define R_TILEPRO_IMM8_Y1	20	/* Y1 pipe 8-bit */
++#define R_TILEPRO_MT_IMM15_X1	21	/* X1 pipe mtspr */
++#define R_TILEPRO_MF_IMM15_X1	22	/* X1 pipe mfspr */
++#define R_TILEPRO_IMM16_X0	23	/* X0 pipe 16-bit */
++#define R_TILEPRO_IMM16_X1	24	/* X1 pipe 16-bit */
++#define R_TILEPRO_IMM16_X0_LO	25	/* X0 pipe low 16-bit */
++#define R_TILEPRO_IMM16_X1_LO	26	/* X1 pipe low 16-bit */
++#define R_TILEPRO_IMM16_X0_HI	27	/* X0 pipe high 16-bit */
++#define R_TILEPRO_IMM16_X1_HI	28	/* X1 pipe high 16-bit */
++#define R_TILEPRO_IMM16_X0_HA	29	/* X0 pipe high 16-bit, adjusted */
++#define R_TILEPRO_IMM16_X1_HA	30	/* X1 pipe high 16-bit, adjusted */
++#define R_TILEPRO_IMM16_X0_PCREL 31	/* X0 pipe PC relative 16 bit */
++#define R_TILEPRO_IMM16_X1_PCREL 32	/* X1 pipe PC relative 16 bit */
++#define R_TILEPRO_IMM16_X0_LO_PCREL 33	/* X0 pipe PC relative low 16 bit */
++#define R_TILEPRO_IMM16_X1_LO_PCREL 34	/* X1 pipe PC relative low 16 bit */
++#define R_TILEPRO_IMM16_X0_HI_PCREL 35	/* X0 pipe PC relative high 16 bit */
++#define R_TILEPRO_IMM16_X1_HI_PCREL 36	/* X1 pipe PC relative high 16 bit */
++#define R_TILEPRO_IMM16_X0_HA_PCREL 37	/* X0 pipe PC relative ha() 16 bit */
++#define R_TILEPRO_IMM16_X1_HA_PCREL 38	/* X1 pipe PC relative ha() 16 bit */
++#define R_TILEPRO_IMM16_X0_GOT	39	/* X0 pipe 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT	40	/* X1 pipe 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X0_GOT_LO 41	/* X0 pipe low 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT_LO 42	/* X1 pipe low 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X0_GOT_HI 43	/* X0 pipe high 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT_HI 44	/* X1 pipe high 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X0_GOT_HA 45	/* X0 pipe ha() 16-bit GOT offset */
++#define R_TILEPRO_IMM16_X1_GOT_HA 46	/* X1 pipe ha() 16-bit GOT offset */
++#define R_TILEPRO_MMSTART_X0	47	/* X0 pipe mm "start" */
++#define R_TILEPRO_MMEND_X0	48	/* X0 pipe mm "end" */
++#define R_TILEPRO_MMSTART_X1	49	/* X1 pipe mm "start" */
++#define R_TILEPRO_MMEND_X1	50	/* X1 pipe mm "end" */
++#define R_TILEPRO_SHAMT_X0	51	/* X0 pipe shift amount */
++#define R_TILEPRO_SHAMT_X1	52	/* X1 pipe shift amount */
++#define R_TILEPRO_SHAMT_Y0	53	/* Y0 pipe shift amount */
++#define R_TILEPRO_SHAMT_Y1	54	/* Y1 pipe shift amount */
++#define R_TILEPRO_DEST_IMM8_X1	55	/* X1 pipe destination 8-bit */
++/* Relocs 56-59 are currently not defined.  */
++#define R_TILEPRO_TLS_GD_CALL	60	/* "jal" for TLS GD */
++#define R_TILEPRO_IMM8_X0_TLS_GD_ADD 61	/* X0 pipe "addi" for TLS GD */
++#define R_TILEPRO_IMM8_X1_TLS_GD_ADD 62	/* X1 pipe "addi" for TLS GD */
++#define R_TILEPRO_IMM8_Y0_TLS_GD_ADD 63	/* Y0 pipe "addi" for TLS GD */
++#define R_TILEPRO_IMM8_Y1_TLS_GD_ADD 64	/* Y1 pipe "addi" for TLS GD */
++#define R_TILEPRO_TLS_IE_LOAD	65	/* "lw_tls" for TLS IE */
++#define R_TILEPRO_IMM16_X0_TLS_GD 66	/* X0 pipe 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD 67	/* X1 pipe 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_GD_LO 68	/* X0 pipe low 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD_LO 69	/* X1 pipe low 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_GD_HI 70	/* X0 pipe high 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD_HI 71	/* X1 pipe high 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_GD_HA 72	/* X0 pipe ha() 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X1_TLS_GD_HA 73	/* X1 pipe ha() 16-bit TLS GD offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE 74	/* X0 pipe 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE 75	/* X1 pipe 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE_LO 76	/* X0 pipe low 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE_LO 77	/* X1 pipe low 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE_HI 78	/* X0 pipe high 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE_HI 79	/* X1 pipe high 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X0_TLS_IE_HA 80	/* X0 pipe ha() 16-bit TLS IE offset */
++#define R_TILEPRO_IMM16_X1_TLS_IE_HA 81	/* X1 pipe ha() 16-bit TLS IE offset */
++#define R_TILEPRO_TLS_DTPMOD32	82	/* ID of module containing symbol */
++#define R_TILEPRO_TLS_DTPOFF32	83	/* Offset in TLS block */
++#define R_TILEPRO_TLS_TPOFF32	84	/* Offset in static TLS block */
++#define R_TILEPRO_IMM16_X0_TLS_LE 85	/* X0 pipe 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE 86	/* X1 pipe 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X0_TLS_LE_LO 87	/* X0 pipe low 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE_LO 88	/* X1 pipe low 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X0_TLS_LE_HI 89	/* X0 pipe high 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE_HI 90	/* X1 pipe high 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X0_TLS_LE_HA 91	/* X0 pipe ha() 16-bit TLS LE offset */
++#define R_TILEPRO_IMM16_X1_TLS_LE_HA 92	/* X1 pipe ha() 16-bit TLS LE offset */
++
++#define R_TILEPRO_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
++#define R_TILEPRO_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
++
++#define R_TILEPRO_NUM		130
++
++
++/* TILE-Gx relocations.  */
++#define R_TILEGX_NONE		0	/* No reloc */
++#define R_TILEGX_64		1	/* Direct 64 bit */
++#define R_TILEGX_32		2	/* Direct 32 bit */
++#define R_TILEGX_16		3	/* Direct 16 bit */
++#define R_TILEGX_8		4	/* Direct 8 bit */
++#define R_TILEGX_64_PCREL	5	/* PC relative 64 bit */
++#define R_TILEGX_32_PCREL	6	/* PC relative 32 bit */
++#define R_TILEGX_16_PCREL	7	/* PC relative 16 bit */
++#define R_TILEGX_8_PCREL	8	/* PC relative 8 bit */
++#define R_TILEGX_HW0		9	/* hword 0 16-bit */
++#define R_TILEGX_HW1		10	/* hword 1 16-bit */
++#define R_TILEGX_HW2		11	/* hword 2 16-bit */
++#define R_TILEGX_HW3		12	/* hword 3 16-bit */
++#define R_TILEGX_HW0_LAST	13	/* last hword 0 16-bit */
++#define R_TILEGX_HW1_LAST	14	/* last hword 1 16-bit */
++#define R_TILEGX_HW2_LAST	15	/* last hword 2 16-bit */
++#define R_TILEGX_COPY		16	/* Copy relocation */
++#define R_TILEGX_GLOB_DAT	17	/* Create GOT entry */
++#define R_TILEGX_JMP_SLOT	18	/* Create PLT entry */
++#define R_TILEGX_RELATIVE	19	/* Adjust by program base */
++#define R_TILEGX_BROFF_X1	20	/* X1 pipe branch offset */
++#define R_TILEGX_JUMPOFF_X1	21	/* X1 pipe jump offset */
++#define R_TILEGX_JUMPOFF_X1_PLT	22	/* X1 pipe jump offset to PLT */
++#define R_TILEGX_IMM8_X0	23	/* X0 pipe 8-bit */
++#define R_TILEGX_IMM8_Y0	24	/* Y0 pipe 8-bit */
++#define R_TILEGX_IMM8_X1	25	/* X1 pipe 8-bit */
++#define R_TILEGX_IMM8_Y1	26	/* Y1 pipe 8-bit */
++#define R_TILEGX_DEST_IMM8_X1	27	/* X1 pipe destination 8-bit */
++#define R_TILEGX_MT_IMM14_X1	28	/* X1 pipe mtspr */
++#define R_TILEGX_MF_IMM14_X1	29	/* X1 pipe mfspr */
++#define R_TILEGX_MMSTART_X0	30	/* X0 pipe mm "start" */
++#define R_TILEGX_MMEND_X0	31	/* X0 pipe mm "end" */
++#define R_TILEGX_SHAMT_X0	32	/* X0 pipe shift amount */
++#define R_TILEGX_SHAMT_X1	33	/* X1 pipe shift amount */
++#define R_TILEGX_SHAMT_Y0	34	/* Y0 pipe shift amount */
++#define R_TILEGX_SHAMT_Y1	35	/* Y1 pipe shift amount */
++#define R_TILEGX_IMM16_X0_HW0	36	/* X0 pipe hword 0 */
++#define R_TILEGX_IMM16_X1_HW0	37	/* X1 pipe hword 0 */
++#define R_TILEGX_IMM16_X0_HW1	38	/* X0 pipe hword 1 */
++#define R_TILEGX_IMM16_X1_HW1	39	/* X1 pipe hword 1 */
++#define R_TILEGX_IMM16_X0_HW2	40	/* X0 pipe hword 2 */
++#define R_TILEGX_IMM16_X1_HW2	41	/* X1 pipe hword 2 */
++#define R_TILEGX_IMM16_X0_HW3	42	/* X0 pipe hword 3 */
++#define R_TILEGX_IMM16_X1_HW3	43	/* X1 pipe hword 3 */
++#define R_TILEGX_IMM16_X0_HW0_LAST 44	/* X0 pipe last hword 0 */
++#define R_TILEGX_IMM16_X1_HW0_LAST 45	/* X1 pipe last hword 0 */
++#define R_TILEGX_IMM16_X0_HW1_LAST 46	/* X0 pipe last hword 1 */
++#define R_TILEGX_IMM16_X1_HW1_LAST 47	/* X1 pipe last hword 1 */
++#define R_TILEGX_IMM16_X0_HW2_LAST 48	/* X0 pipe last hword 2 */
++#define R_TILEGX_IMM16_X1_HW2_LAST 49	/* X1 pipe last hword 2 */
++#define R_TILEGX_IMM16_X0_HW0_PCREL 50	/* X0 pipe PC relative hword 0 */
++#define R_TILEGX_IMM16_X1_HW0_PCREL 51	/* X1 pipe PC relative hword 0 */
++#define R_TILEGX_IMM16_X0_HW1_PCREL 52	/* X0 pipe PC relative hword 1 */
++#define R_TILEGX_IMM16_X1_HW1_PCREL 53	/* X1 pipe PC relative hword 1 */
++#define R_TILEGX_IMM16_X0_HW2_PCREL 54	/* X0 pipe PC relative hword 2 */
++#define R_TILEGX_IMM16_X1_HW2_PCREL 55	/* X1 pipe PC relative hword 2 */
++#define R_TILEGX_IMM16_X0_HW3_PCREL 56	/* X0 pipe PC relative hword 3 */
++#define R_TILEGX_IMM16_X1_HW3_PCREL 57	/* X1 pipe PC relative hword 3 */
++#define R_TILEGX_IMM16_X0_HW0_LAST_PCREL 58 /* X0 pipe PC-rel last hword 0 */
++#define R_TILEGX_IMM16_X1_HW0_LAST_PCREL 59 /* X1 pipe PC-rel last hword 0 */
++#define R_TILEGX_IMM16_X0_HW1_LAST_PCREL 60 /* X0 pipe PC-rel last hword 1 */
++#define R_TILEGX_IMM16_X1_HW1_LAST_PCREL 61 /* X1 pipe PC-rel last hword 1 */
++#define R_TILEGX_IMM16_X0_HW2_LAST_PCREL 62 /* X0 pipe PC-rel last hword 2 */
++#define R_TILEGX_IMM16_X1_HW2_LAST_PCREL 63 /* X1 pipe PC-rel last hword 2 */
++#define R_TILEGX_IMM16_X0_HW0_GOT 64	/* X0 pipe hword 0 GOT offset */
++#define R_TILEGX_IMM16_X1_HW0_GOT 65	/* X1 pipe hword 0 GOT offset */
++/* Relocs 66-71 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_LAST_GOT 72 /* X0 pipe last hword 0 GOT offset */
++#define R_TILEGX_IMM16_X1_HW0_LAST_GOT 73 /* X1 pipe last hword 0 GOT offset */
++#define R_TILEGX_IMM16_X0_HW1_LAST_GOT 74 /* X0 pipe last hword 1 GOT offset */
++#define R_TILEGX_IMM16_X1_HW1_LAST_GOT 75 /* X1 pipe last hword 1 GOT offset */
++/* Relocs 76-77 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_TLS_GD 78	/* X0 pipe hword 0 TLS GD offset */
++#define R_TILEGX_IMM16_X1_HW0_TLS_GD 79	/* X1 pipe hword 0 TLS GD offset */
++#define R_TILEGX_IMM16_X0_HW0_TLS_LE 80	/* X0 pipe hword 0 TLS LE offset */
++#define R_TILEGX_IMM16_X1_HW0_TLS_LE 81	/* X1 pipe hword 0 TLS LE offset */
++#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE 82 /* X0 pipe last hword 0 LE off */
++#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE 83 /* X1 pipe last hword 0 LE off */
++#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE 84 /* X0 pipe last hword 1 LE off */
++#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE 85 /* X1 pipe last hword 1 LE off */
++#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD 86 /* X0 pipe last hword 0 GD off */
++#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD 87 /* X1 pipe last hword 0 GD off */
++#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD 88 /* X0 pipe last hword 1 GD off */
++#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD 89 /* X1 pipe last hword 1 GD off */
++/* Relocs 90-91 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_TLS_IE 92	/* X0 pipe hword 0 TLS IE offset */
++#define R_TILEGX_IMM16_X1_HW0_TLS_IE 93	/* X1 pipe hword 0 TLS IE offset */
++/* Relocs 94-99 are currently not defined.  */
++#define R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE 100 /* X0 pipe last hword 0 IE off */
++#define R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE 101 /* X1 pipe last hword 0 IE off */
++#define R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE 102 /* X0 pipe last hword 1 IE off */
++#define R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE 103 /* X1 pipe last hword 1 IE off */
++/* Relocs 104-105 are currently not defined.  */
++#define R_TILEGX_TLS_DTPMOD64	106	/* 64-bit ID of symbol's module */
++#define R_TILEGX_TLS_DTPOFF64	107	/* 64-bit offset in TLS block */
++#define R_TILEGX_TLS_TPOFF64	108	/* 64-bit offset in static TLS block */
++#define R_TILEGX_TLS_DTPMOD32	109	/* 32-bit ID of symbol's module */
++#define R_TILEGX_TLS_DTPOFF32	110	/* 32-bit offset in TLS block */
++#define R_TILEGX_TLS_TPOFF32	111	/* 32-bit offset in static TLS block */
++#define R_TILEGX_TLS_GD_CALL	112	/* "jal" for TLS GD */
++#define R_TILEGX_IMM8_X0_TLS_GD_ADD 113	/* X0 pipe "addi" for TLS GD */
++#define R_TILEGX_IMM8_X1_TLS_GD_ADD 114	/* X1 pipe "addi" for TLS GD */
++#define R_TILEGX_IMM8_Y0_TLS_GD_ADD 115	/* Y0 pipe "addi" for TLS GD */
++#define R_TILEGX_IMM8_Y1_TLS_GD_ADD 116	/* Y1 pipe "addi" for TLS GD */
++#define R_TILEGX_TLS_IE_LOAD	117	/* "ld_tls" for TLS IE */
++#define R_TILEGX_IMM8_X0_TLS_ADD 118	/* X0 pipe "addi" for TLS GD/IE */
++#define R_TILEGX_IMM8_X1_TLS_ADD 119	/* X1 pipe "addi" for TLS GD/IE */
++#define R_TILEGX_IMM8_Y0_TLS_ADD 120	/* Y0 pipe "addi" for TLS GD/IE */
++#define R_TILEGX_IMM8_Y1_TLS_ADD 121	/* Y1 pipe "addi" for TLS GD/IE */
++
++#define R_TILEGX_GNU_VTINHERIT	128	/* GNU C++ vtable hierarchy */
++#define R_TILEGX_GNU_VTENTRY	129	/* GNU C++ vtable member usage */
++
++#define R_TILEGX_NUM		130
++
++#endif	/* elf.h */
diff --git a/target/linux/generic/patches-3.10/212-byteshift_portability.patch b/target/linux/generic/patches-3.10/212-byteshift_portability.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/212-byteshift_portability.patch
@@ -0,0 +1,53 @@
+--- a/tools/include/tools/be_byteshift.h
++++ b/tools/include/tools/be_byteshift.h
+@@ -1,7 +1,11 @@
+ #ifndef _TOOLS_BE_BYTESHIFT_H
+ #define _TOOLS_BE_BYTESHIFT_H
+ 
++#ifdef __linux__
+ #include <linux/types.h>
++#else
++#include "linux_types.h"
++#endif
+ 
+ static inline __u16 __get_unaligned_be16(const __u8 *p)
+ {
+--- a/tools/include/tools/le_byteshift.h
++++ b/tools/include/tools/le_byteshift.h
+@@ -1,7 +1,11 @@
+ #ifndef _TOOLS_LE_BYTESHIFT_H
+ #define _TOOLS_LE_BYTESHIFT_H
+ 
++#ifdef __linux__
+ #include <linux/types.h>
++#else
++#include "linux_types.h"
++#endif
+ 
+ static inline __u16 __get_unaligned_le16(const __u8 *p)
+ {
+--- /dev/null
++++ b/tools/include/tools/linux_types.h
+@@ -0,0 +1,22 @@
++#ifndef __LINUX_TYPES_H
++#define __LINUX_TYPES_H
++
++#include <stdint.h>
++
++typedef uint8_t __u8;
++typedef uint8_t __be8;
++typedef uint8_t __le8;
++
++typedef uint16_t __u16;
++typedef uint16_t __be16;
++typedef uint16_t __le16;
++
++typedef uint32_t __u32;
++typedef uint32_t __be32;
++typedef uint32_t __le32;
++
++typedef uint64_t __u64;
++typedef uint64_t __be64;
++typedef uint64_t __le64;
++
++#endif
diff --git a/target/linux/generic/patches-3.10/220-gc_sections.patch b/target/linux/generic/patches-3.10/220-gc_sections.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/220-gc_sections.patch
@@ -0,0 +1,545 @@
+From: Felix Fietkau <nbd@openwrt.org>
+
+use -ffunction-sections, -fdata-sections and --gc-sections
+
+In combination with kernel symbol export stripping this significantly reduces
+the kernel image size. Used on both ARM and MIPS architectures.
+
+Signed-off-by: Felix Fietkau <nbd@openwrt.org>
+Signed-off-by: Jonas Gorski <jogo@openwrt.org>
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+---
+
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -89,10 +89,14 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
+ #
+ cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
+ cflags-y			+= -msoft-float
+-LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
++LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib --gc-sections
+ KBUILD_AFLAGS_MODULE		+= -mlong-calls
+ KBUILD_CFLAGS_MODULE		+= -mlong-calls
+ 
++ifndef CONFIG_FUNCTION_TRACER
++KBUILD_CFLAGS_KERNEL		+= -ffunction-sections -fdata-sections
++endif
++
+ cflags-y += -ffreestanding
+ 
+ #
+--- a/arch/mips/kernel/vmlinux.lds.S
++++ b/arch/mips/kernel/vmlinux.lds.S
+@@ -67,7 +67,7 @@ SECTIONS
+ 	/* Exception table for data bus errors */
+ 	__dbe_table : {
+ 		__start___dbe_table = .;
+-		*(__dbe_table)
++		KEEP(*(__dbe_table))
+ 		__stop___dbe_table = .;
+ 	}
+ 
+@@ -112,7 +112,7 @@ SECTIONS
+ 	. = ALIGN(4);
+ 	.mips.machines.init : AT(ADDR(.mips.machines.init) - LOAD_OFFSET) {
+ 		__mips_machines_start = .;
+-		*(.mips.machines.init)
++		KEEP(*(.mips.machines.init))
+ 		__mips_machines_end = .;
+ 	}
+ 
+--- a/include/asm-generic/vmlinux.lds.h
++++ b/include/asm-generic/vmlinux.lds.h
+@@ -95,7 +95,7 @@
+ #ifdef CONFIG_FTRACE_MCOUNT_RECORD
+ #define MCOUNT_REC()	. = ALIGN(8);				\
+ 			VMLINUX_SYMBOL(__start_mcount_loc) = .; \
+-			*(__mcount_loc)				\
++			KEEP(*(__mcount_loc))			\
+ 			VMLINUX_SYMBOL(__stop_mcount_loc) = .;
+ #else
+ #define MCOUNT_REC()
+@@ -103,7 +103,7 @@
+ 
+ #ifdef CONFIG_TRACE_BRANCH_PROFILING
+ #define LIKELY_PROFILE()	VMLINUX_SYMBOL(__start_annotated_branch_profile) = .; \
+-				*(_ftrace_annotated_branch)			      \
++				KEEP(*(_ftrace_annotated_branch))		      \
+ 				VMLINUX_SYMBOL(__stop_annotated_branch_profile) = .;
+ #else
+ #define LIKELY_PROFILE()
+@@ -111,7 +111,7 @@
+ 
+ #ifdef CONFIG_PROFILE_ALL_BRANCHES
+ #define BRANCH_PROFILE()	VMLINUX_SYMBOL(__start_branch_profile) = .;   \
+-				*(_ftrace_branch)			      \
++				KEEP(*(_ftrace_branch))			      \
+ 				VMLINUX_SYMBOL(__stop_branch_profile) = .;
+ #else
+ #define BRANCH_PROFILE()
+@@ -120,7 +120,7 @@
+ #ifdef CONFIG_EVENT_TRACING
+ #define FTRACE_EVENTS()	. = ALIGN(8);					\
+ 			VMLINUX_SYMBOL(__start_ftrace_events) = .;	\
+-			*(_ftrace_events)				\
++			KEEP(*(_ftrace_events))				\
+ 			VMLINUX_SYMBOL(__stop_ftrace_events) = .;
+ #else
+ #define FTRACE_EVENTS()
+@@ -128,7 +128,7 @@
+ 
+ #ifdef CONFIG_TRACING
+ #define TRACE_PRINTKS() VMLINUX_SYMBOL(__start___trace_bprintk_fmt) = .;      \
+-			 *(__trace_printk_fmt) /* Trace_printk fmt' pointer */ \
++			 KEEP(*(__trace_printk_fmt)) /* Trace_printk fmt' pointer */ \
+ 			 VMLINUX_SYMBOL(__stop___trace_bprintk_fmt) = .;
+ #else
+ #define TRACE_PRINTKS()
+@@ -137,7 +137,7 @@
+ #ifdef CONFIG_FTRACE_SYSCALLS
+ #define TRACE_SYSCALLS() . = ALIGN(8);					\
+ 			 VMLINUX_SYMBOL(__start_syscalls_metadata) = .;	\
+-			 *(__syscalls_metadata)				\
++			 KEEP(*(__syscalls_metadata))			\
+ 			 VMLINUX_SYMBOL(__stop_syscalls_metadata) = .;
+ #else
+ #define TRACE_SYSCALLS()
+@@ -146,8 +146,8 @@
+ #ifdef CONFIG_CLKSRC_OF
+ #define CLKSRC_OF_TABLES() . = ALIGN(8);				\
+ 			   VMLINUX_SYMBOL(__clksrc_of_table) = .;	\
+-			   *(__clksrc_of_table)				\
+-			   *(__clksrc_of_table_end)
++			   KEEP(*(__clksrc_of_table))			\
++			   KEEP(*(__clksrc_of_table_end))
+ #else
+ #define CLKSRC_OF_TABLES()
+ #endif
+@@ -156,8 +156,8 @@
+ #define IRQCHIP_OF_MATCH_TABLE()					\
+ 	. = ALIGN(8);							\
+ 	VMLINUX_SYMBOL(__irqchip_begin) = .;				\
+-	*(__irqchip_of_table)		  				\
+-	*(__irqchip_of_end)
++	KEEP(*(__irqchip_of_table))	  				\
++	KEEP(*(__irqchip_of_end))
+ #else
+ #define IRQCHIP_OF_MATCH_TABLE()
+ #endif
+@@ -165,8 +165,8 @@
+ #ifdef CONFIG_COMMON_CLK
+ #define CLK_OF_TABLES() . = ALIGN(8);				\
+ 			VMLINUX_SYMBOL(__clk_of_table) = .;	\
+-			*(__clk_of_table)			\
+-			*(__clk_of_table_end)
++			KEEP(*(__clk_of_table))			\
++			KEEP(*(__clk_of_table_end))
+ #else
+ #define CLK_OF_TABLES()
+ #endif
+@@ -174,7 +174,7 @@
+ #define KERNEL_DTB()							\
+ 	STRUCT_ALIGN();							\
+ 	VMLINUX_SYMBOL(__dtb_start) = .;				\
+-	*(.dtb.init.rodata)						\
++	KEEP(*(.dtb.init.rodata))					\
+ 	VMLINUX_SYMBOL(__dtb_end) = .;
+ 
+ /* .data section */
+@@ -194,15 +194,16 @@
+ 	/* implement dynamic printk debug */				\
+ 	. = ALIGN(8);                                                   \
+ 	VMLINUX_SYMBOL(__start___jump_table) = .;                       \
+-	*(__jump_table)                                                 \
++	KEEP(*(__jump_table))                                           \
+ 	VMLINUX_SYMBOL(__stop___jump_table) = .;                        \
+ 	. = ALIGN(8);							\
+ 	VMLINUX_SYMBOL(__start___verbose) = .;                          \
+-	*(__verbose)                                                    \
++	KEEP(*(__verbose))                                              \
+ 	VMLINUX_SYMBOL(__stop___verbose) = .;				\
+ 	LIKELY_PROFILE()		       				\
+ 	BRANCH_PROFILE()						\
+-	TRACE_PRINTKS()
++	TRACE_PRINTKS()							\
++	*(.data.[a-zA-Z_]*)
+ 
+ /*
+  * Data section helpers
+@@ -256,39 +257,39 @@
+ 	/* PCI quirks */						\
+ 	.pci_fixup        : AT(ADDR(.pci_fixup) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_early) = .;		\
+-		*(.pci_fixup_early)					\
++		KEEP(*(.pci_fixup_early))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_early) = .;		\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_header) = .;		\
+-		*(.pci_fixup_header)					\
++		KEEP(*(.pci_fixup_header))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_header) = .;		\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_final) = .;		\
+-		*(.pci_fixup_final)					\
++		KEEP(*(.pci_fixup_final))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_final) = .;		\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_enable) = .;		\
+-		*(.pci_fixup_enable)					\
++		KEEP(*(.pci_fixup_enable))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_enable) = .;		\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_resume) = .;		\
+-		*(.pci_fixup_resume)					\
++		KEEP(*(.pci_fixup_resume))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_resume) = .;		\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_resume_early) = .;	\
+-		*(.pci_fixup_resume_early)				\
++		KEEP(*(.pci_fixup_resume_early))			\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_resume_early) = .;	\
+ 		VMLINUX_SYMBOL(__start_pci_fixups_suspend) = .;		\
+-		*(.pci_fixup_suspend)					\
++		KEEP(*(.pci_fixup_suspend))				\
+ 		VMLINUX_SYMBOL(__end_pci_fixups_suspend) = .;		\
+ 	}								\
+ 									\
+ 	/* Built-in firmware blobs */					\
+ 	.builtin_fw        : AT(ADDR(.builtin_fw) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start_builtin_fw) = .;			\
+-		*(.builtin_fw)						\
++		KEEP(*(.builtin_fw))					\
+ 		VMLINUX_SYMBOL(__end_builtin_fw) = .;			\
+ 	}								\
+ 									\
+ 	/* RapidIO route ops */						\
+ 	.rio_ops        : AT(ADDR(.rio_ops) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__start_rio_switch_ops) = .;		\
+-		*(.rio_switch_ops)					\
++		KEEP(*(.rio_switch_ops))				\
+ 		VMLINUX_SYMBOL(__end_rio_switch_ops) = .;		\
+ 	}								\
+ 									\
+@@ -297,49 +298,49 @@
+ 	/* Kernel symbol table: Normal symbols */			\
+ 	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__start___ksymtab) = .;			\
+-		*(SORT(___ksymtab+*))					\
++		KEEP(*(SORT(___ksymtab+*)))				\
+ 		VMLINUX_SYMBOL(__stop___ksymtab) = .;			\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-only symbols */			\
+ 	__ksymtab_gpl     : AT(ADDR(__ksymtab_gpl) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start___ksymtab_gpl) = .;		\
+-		*(SORT(___ksymtab_gpl+*))				\
++		KEEP(*(SORT(___ksymtab_gpl+*)))				\
+ 		VMLINUX_SYMBOL(__stop___ksymtab_gpl) = .;		\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: Normal unused symbols */		\
+ 	__ksymtab_unused  : AT(ADDR(__ksymtab_unused) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start___ksymtab_unused) = .;		\
+-		*(SORT(___ksymtab_unused+*))				\
++		KEEP(*(SORT(___ksymtab_unused+*)))			\
+ 		VMLINUX_SYMBOL(__stop___ksymtab_unused) = .;		\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-only unused symbols */		\
+ 	__ksymtab_unused_gpl : AT(ADDR(__ksymtab_unused_gpl) - LOAD_OFFSET) { \
+ 		VMLINUX_SYMBOL(__start___ksymtab_unused_gpl) = .;	\
+-		*(SORT(___ksymtab_unused_gpl+*))			\
++		KEEP(*(SORT(___ksymtab_unused_gpl+*)))			\
+ 		VMLINUX_SYMBOL(__stop___ksymtab_unused_gpl) = .;	\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-future-only symbols */		\
+ 	__ksymtab_gpl_future : AT(ADDR(__ksymtab_gpl_future) - LOAD_OFFSET) { \
+ 		VMLINUX_SYMBOL(__start___ksymtab_gpl_future) = .;	\
+-		*(SORT(___ksymtab_gpl_future+*))			\
++		KEEP(*(SORT(___ksymtab_gpl_future+*)))			\
+ 		VMLINUX_SYMBOL(__stop___ksymtab_gpl_future) = .;	\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: Normal symbols */			\
+ 	__kcrctab         : AT(ADDR(__kcrctab) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__start___kcrctab) = .;			\
+-		*(SORT(___kcrctab+*))					\
++		KEEP(*(SORT(___kcrctab+*)))				\
+ 		VMLINUX_SYMBOL(__stop___kcrctab) = .;			\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-only symbols */			\
+ 	__kcrctab_gpl     : AT(ADDR(__kcrctab_gpl) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start___kcrctab_gpl) = .;		\
+-		*(SORT(___kcrctab_gpl+*))				\
++		KEEP(*(SORT(___kcrctab_gpl+*)))				\
+ 		VMLINUX_SYMBOL(__stop___kcrctab_gpl) = .;		\
+ 	}								\
+ 									\
+@@ -353,14 +354,14 @@
+ 	/* Kernel symbol table: GPL-only unused symbols */		\
+ 	__kcrctab_unused_gpl : AT(ADDR(__kcrctab_unused_gpl) - LOAD_OFFSET) { \
+ 		VMLINUX_SYMBOL(__start___kcrctab_unused_gpl) = .;	\
+-		*(SORT(___kcrctab_unused_gpl+*))			\
++		KEEP(*(SORT(___kcrctab_unused_gpl+*)))			\
+ 		VMLINUX_SYMBOL(__stop___kcrctab_unused_gpl) = .;	\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-future-only symbols */		\
+ 	__kcrctab_gpl_future : AT(ADDR(__kcrctab_gpl_future) - LOAD_OFFSET) { \
+ 		VMLINUX_SYMBOL(__start___kcrctab_gpl_future) = .;	\
+-		*(SORT(___kcrctab_gpl_future+*))			\
++		KEEP(*(SORT(___kcrctab_gpl_future+*)))			\
+ 		VMLINUX_SYMBOL(__stop___kcrctab_gpl_future) = .;	\
+ 	}								\
+ 									\
+@@ -383,14 +384,14 @@
+ 	/* Built-in module parameters. */				\
+ 	__param : AT(ADDR(__param) - LOAD_OFFSET) {			\
+ 		VMLINUX_SYMBOL(__start___param) = .;			\
+-		*(__param)						\
++		KEEP(*(__param))					\
+ 		VMLINUX_SYMBOL(__stop___param) = .;			\
+ 	}								\
+ 									\
+ 	/* Built-in module versions. */					\
+ 	__modver : AT(ADDR(__modver) - LOAD_OFFSET) {			\
+ 		VMLINUX_SYMBOL(__start___modver) = .;			\
+-		*(__modver)						\
++		KEEP(*(__modver))					\
+ 		VMLINUX_SYMBOL(__stop___modver) = .;			\
+ 		. = ALIGN((align));					\
+ 		VMLINUX_SYMBOL(__end_rodata) = .;			\
+@@ -450,7 +451,7 @@
+ #define ENTRY_TEXT							\
+ 		ALIGN_FUNCTION();					\
+ 		VMLINUX_SYMBOL(__entry_text_start) = .;			\
+-		*(.entry.text)						\
++		KEEP(*(.entry.text))					\
+ 		VMLINUX_SYMBOL(__entry_text_end) = .;
+ 
+ #ifdef CONFIG_FUNCTION_GRAPH_TRACER
+@@ -478,7 +479,7 @@
+ 	. = ALIGN(align);						\
+ 	__ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__start___ex_table) = .;			\
+-		*(__ex_table)						\
++		KEEP(*(__ex_table))						\
+ 		VMLINUX_SYMBOL(__stop___ex_table) = .;			\
+ 	}
+ 
+@@ -494,7 +495,7 @@
+ #ifdef CONFIG_CONSTRUCTORS
+ #define KERNEL_CTORS()	. = ALIGN(8);			   \
+ 			VMLINUX_SYMBOL(__ctors_start) = .; \
+-			*(.ctors)			   \
++			KEEP(*(.ctors))			   \
+ 			VMLINUX_SYMBOL(__ctors_end) = .;
+ #else
+ #define KERNEL_CTORS()
+@@ -550,7 +551,7 @@
+ #define SBSS(sbss_align)						\
+ 	. = ALIGN(sbss_align);						\
+ 	.sbss : AT(ADDR(.sbss) - LOAD_OFFSET) {				\
+-		*(.sbss)						\
++		*(.sbss .sbss.*)					\
+ 		*(.scommon)						\
+ 	}
+ 
+@@ -568,7 +569,7 @@
+ 		BSS_FIRST_SECTIONS					\
+ 		*(.bss..page_aligned)					\
+ 		*(.dynbss)						\
+-		*(.bss)							\
++		*(.bss .bss.*)						\
+ 		*(COMMON)						\
+ 	}
+ 
+@@ -617,7 +618,7 @@
+ 	. = ALIGN(8);							\
+ 	__bug_table : AT(ADDR(__bug_table) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__start___bug_table) = .;		\
+-		*(__bug_table)						\
++		KEEP(*(__bug_table))					\
+ 		VMLINUX_SYMBOL(__stop___bug_table) = .;			\
+ 	}
+ #else
+@@ -629,7 +630,7 @@
+ 	. = ALIGN(4);							\
+ 	.tracedata : AT(ADDR(.tracedata) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__tracedata_start) = .;			\
+-		*(.tracedata)						\
++		KEEP(*(.tracedata))					\
+ 		VMLINUX_SYMBOL(__tracedata_end) = .;			\
+ 	}
+ #else
+@@ -646,17 +647,17 @@
+ #define INIT_SETUP(initsetup_align)					\
+ 		. = ALIGN(initsetup_align);				\
+ 		VMLINUX_SYMBOL(__setup_start) = .;			\
+-		*(.init.setup)						\
++		KEEP(*(.init.setup))					\
+ 		VMLINUX_SYMBOL(__setup_end) = .;
+ 
+ #define INIT_CALLS_LEVEL(level)						\
+ 		VMLINUX_SYMBOL(__initcall##level##_start) = .;		\
+-		*(.initcall##level##.init)				\
+-		*(.initcall##level##s.init)				\
++		KEEP(*(.initcall##level##.init))			\
++		KEEP(*(.initcall##level##s.init))			\
+ 
+ #define INIT_CALLS							\
+ 		VMLINUX_SYMBOL(__initcall_start) = .;			\
+-		*(.initcallearly.init)					\
++		KEEP(*(.initcallearly.init))				\
+ 		INIT_CALLS_LEVEL(0)					\
+ 		INIT_CALLS_LEVEL(1)					\
+ 		INIT_CALLS_LEVEL(2)					\
+@@ -670,21 +671,21 @@
+ 
+ #define CON_INITCALL							\
+ 		VMLINUX_SYMBOL(__con_initcall_start) = .;		\
+-		*(.con_initcall.init)					\
++		KEEP(*(.con_initcall.init))				\
+ 		VMLINUX_SYMBOL(__con_initcall_end) = .;
+ 
+ #define SECURITY_INITCALL						\
+ 		VMLINUX_SYMBOL(__security_initcall_start) = .;		\
+-		*(.security_initcall.init)				\
++		KEEP(*(.security_initcall.init))			\
+ 		VMLINUX_SYMBOL(__security_initcall_end) = .;
+ 
+ #ifdef CONFIG_BLK_DEV_INITRD
+ #define INIT_RAM_FS							\
+ 	. = ALIGN(4);							\
+ 	VMLINUX_SYMBOL(__initramfs_start) = .;				\
+-	*(.init.ramfs)							\
++	KEEP(*(.init.ramfs))						\
+ 	. = ALIGN(8);							\
+-	*(.init.ramfs.info)
++	KEEP(*(.init.ramfs.info))
+ #else
+ #define INIT_RAM_FS
+ #endif
+--- a/arch/arm/Makefile
++++ b/arch/arm/Makefile
+@@ -17,11 +17,16 @@ LDFLAGS_vmlinux	:=-p --no-undefined -X
+ ifeq ($(CONFIG_CPU_ENDIAN_BE8),y)
+ LDFLAGS_vmlinux	+= --be8
+ endif
++LDFLAGS_vmlinux += --gc-sections
+ 
+ OBJCOPYFLAGS	:=-O binary -R .comment -S
+ GZFLAGS		:=-9
+ #KBUILD_CFLAGS	+=-pipe
+ 
++ifndef CONFIG_FUNCTION_TRACER
++KBUILD_CFLAGS_KERNEL += -ffunction-sections -fdata-sections
++endif
++
+ # Never generate .eh_frame
+ KBUILD_CFLAGS	+= $(call cc-option,-fno-dwarf2-cfi-asm)
+ 
+--- a/arch/arm/kernel/vmlinux.lds.S
++++ b/arch/arm/kernel/vmlinux.lds.S
+@@ -12,13 +12,13 @@
+ #define PROC_INFO							\
+ 	. = ALIGN(4);							\
+ 	VMLINUX_SYMBOL(__proc_info_begin) = .;				\
+-	*(.proc.info.init)						\
++	KEEP(*(.proc.info.init))					\
+ 	VMLINUX_SYMBOL(__proc_info_end) = .;
+ 
+ #define IDMAP_TEXT							\
+ 	ALIGN_FUNCTION();						\
+ 	VMLINUX_SYMBOL(__idmap_text_start) = .;				\
+-	*(.idmap.text)							\
++	KEEP(*(.idmap.text))						\
+ 	VMLINUX_SYMBOL(__idmap_text_end) = .;				\
+ 	. = ALIGN(32);							\
+ 	VMLINUX_SYMBOL(__hyp_idmap_text_start) = .;			\
+@@ -97,7 +97,7 @@ SECTIONS
+ 	.text : {			/* Real text segment		*/
+ 		_stext = .;		/* Text and read-only data	*/
+ 			__exception_text_start = .;
+-			*(.exception.text)
++			KEEP(*(.exception.text))
+ 			__exception_text_end = .;
+ 			IRQENTRY_TEXT
+ 			TEXT_TEXT
+@@ -122,7 +122,7 @@ SECTIONS
+ 	__ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {
+ 		__start___ex_table = .;
+ #ifdef CONFIG_MMU
+-		*(__ex_table)
++		KEEP(*(__ex_table))
+ #endif
+ 		__stop___ex_table = .;
+ 	}
+@@ -134,12 +134,12 @@ SECTIONS
+ 	. = ALIGN(8);
+ 	.ARM.unwind_idx : {
+ 		__start_unwind_idx = .;
+-		*(.ARM.exidx*)
++		KEEP(*(.ARM.exidx*))
+ 		__stop_unwind_idx = .;
+ 	}
+ 	.ARM.unwind_tab : {
+ 		__start_unwind_tab = .;
+-		*(.ARM.extab*)
++		KEEP(*(.ARM.extab*))
+ 		__stop_unwind_tab = .;
+ 	}
+ #endif
+@@ -158,14 +158,14 @@ SECTIONS
+ 	 */
+ 	__vectors_start = .;
+ 	.vectors 0 : AT(__vectors_start) {
+-		*(.vectors)
++		KEEP(*(.vectors))
+ 	}
+ 	. = __vectors_start + SIZEOF(.vectors);
+ 	__vectors_end = .;
+ 
+ 	__stubs_start = .;
+ 	.stubs 0x1000 : AT(__stubs_start) {
+-		*(.stubs)
++		KEEP(*(.stubs))
+ 	}
+ 	. = __stubs_start + SIZEOF(.stubs);
+ 	__stubs_end = .;
+@@ -179,24 +179,24 @@ SECTIONS
+ 	}
+ 	.init.arch.info : {
+ 		__arch_info_begin = .;
+-		*(.arch.info.init)
++		KEEP(*(.arch.info.init))
+ 		__arch_info_end = .;
+ 	}
+ 	.init.tagtable : {
+ 		__tagtable_begin = .;
+-		*(.taglist.init)
++		KEEP(*(.taglist.init))
+ 		__tagtable_end = .;
+ 	}
+ #ifdef CONFIG_SMP_ON_UP
+ 	.init.smpalt : {
+ 		__smpalt_begin = .;
+-		*(.alt.smp.init)
++		KEEP(*(.alt.smp.init))
+ 		__smpalt_end = .;
+ 	}
+ #endif
+ 	.init.pv_table : {
+ 		__pv_table_begin = .;
+-		*(.pv_table)
++		KEEP(*(.pv_table))
+ 		__pv_table_end = .;
+ 	}
+ 	.init.data : {
+--- a/arch/arm/boot/compressed/Makefile
++++ b/arch/arm/boot/compressed/Makefile
+@@ -123,6 +123,7 @@ ifeq ($(CONFIG_FUNCTION_TRACER),y)
+ ORIG_CFLAGS := $(KBUILD_CFLAGS)
+ KBUILD_CFLAGS = $(subst -pg, , $(ORIG_CFLAGS))
+ endif
++KBUILD_CFLAGS_KERNEL := $(patsubst -f%-sections,,$(KBUILD_CFLAGS_KERNEL))
+ 
+ ccflags-y := -fpic -mno-single-pic-base -fno-builtin -I$(obj)
+ asflags-y := -DZIMAGE
diff --git a/target/linux/generic/patches-3.10/221-module_exports.patch b/target/linux/generic/patches-3.10/221-module_exports.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/221-module_exports.patch
@@ -0,0 +1,88 @@
+--- a/include/asm-generic/vmlinux.lds.h
++++ b/include/asm-generic/vmlinux.lds.h
+@@ -52,6 +52,16 @@
+ #define LOAD_OFFSET 0
+ #endif
+ 
++#ifndef SYMTAB_KEEP
++#define SYMTAB_KEEP KEEP(*(SORT(___ksymtab+*)))
++#define SYMTAB_KEEP_GPL KEEP(*(SORT(___ksymtab_gpl+*)))
++#endif
++
++#ifndef SYMTAB_DISCARD
++#define SYMTAB_DISCARD
++#define SYMTAB_DISCARD_GPL
++#endif
++
+ #include <linux/export.h>
+ 
+ /* Align . to a 8 byte boundary equals to maximum function alignment. */
+@@ -298,14 +308,14 @@
+ 	/* Kernel symbol table: Normal symbols */			\
+ 	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
+ 		VMLINUX_SYMBOL(__start___ksymtab) = .;			\
+-		KEEP(*(SORT(___ksymtab+*)))				\
++		SYMTAB_KEEP						\
+ 		VMLINUX_SYMBOL(__stop___ksymtab) = .;			\
+ 	}								\
+ 									\
+ 	/* Kernel symbol table: GPL-only symbols */			\
+ 	__ksymtab_gpl     : AT(ADDR(__ksymtab_gpl) - LOAD_OFFSET) {	\
+ 		VMLINUX_SYMBOL(__start___ksymtab_gpl) = .;		\
+-		KEEP(*(SORT(___ksymtab_gpl+*)))				\
++		SYMTAB_KEEP_GPL						\
+ 		VMLINUX_SYMBOL(__stop___ksymtab_gpl) = .;		\
+ 	}								\
+ 									\
+@@ -367,7 +377,7 @@
+ 									\
+ 	/* Kernel symbol table: strings */				\
+         __ksymtab_strings : AT(ADDR(__ksymtab_strings) - LOAD_OFFSET) {	\
+-		*(__ksymtab_strings)					\
++		*(__ksymtab_strings+*)					\
+ 	}								\
+ 									\
+ 	/* __*init sections */						\
+@@ -704,6 +714,8 @@
+ 	EXIT_TEXT							\
+ 	EXIT_DATA							\
+ 	EXIT_CALL							\
++	SYMTAB_DISCARD							\
++	SYMTAB_DISCARD_GPL						\
+ 	*(.discard)							\
+ 	*(.discard.*)							\
+ 	}
+--- a/scripts/Makefile.build
++++ b/scripts/Makefile.build
+@@ -349,7 +349,7 @@ targets += $(extra-y) $(MAKECMDGOALS) $(
+ # Linker scripts preprocessor (.lds.S -> .lds)
+ # ---------------------------------------------------------------------------
+ quiet_cmd_cpp_lds_S = LDS     $@
+-      cmd_cpp_lds_S = $(CPP) $(cpp_flags) -P -C -U$(ARCH) \
++      cmd_cpp_lds_S = $(CPP) $(EXTRA_LDSFLAGS) $(cpp_flags) -P -C -U$(ARCH) \
+ 	                     -D__ASSEMBLY__ -DLINKER_SCRIPT -o $@ $<
+ 
+ $(obj)/%.lds: $(src)/%.lds.S FORCE
+--- a/include/linux/export.h
++++ b/include/linux/export.h
+@@ -52,12 +52,19 @@ extern struct module __this_module;
+ #define __CRC_SYMBOL(sym, sec)
+ #endif
+ 
++#ifdef MODULE
++#define __EXPORT_SUFFIX(sym)
++#else
++#define __EXPORT_SUFFIX(sym) "+" #sym
++#endif
++
+ /* For every exported symbol, place a struct in the __ksymtab section */
+ #define __EXPORT_SYMBOL(sym, sec)				\
+ 	extern typeof(sym) sym;					\
+ 	__CRC_SYMBOL(sym, sec)					\
+ 	static const char __kstrtab_##sym[]			\
+-	__attribute__((section("__ksymtab_strings"), aligned(1))) \
++	__attribute__((section("__ksymtab_strings"		\
++	  __EXPORT_SUFFIX(sym)), aligned(1)))			\
+ 	= VMLINUX_SYMBOL_STR(sym);				\
+ 	static const struct kernel_symbol __ksymtab_##sym	\
+ 	__used							\
diff --git a/target/linux/generic/patches-3.10/230-openwrt_lzma_options.patch b/target/linux/generic/patches-3.10/230-openwrt_lzma_options.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/230-openwrt_lzma_options.patch
@@ -0,0 +1,54 @@
+--- a/scripts/Makefile.lib
++++ b/scripts/Makefile.lib
+@@ -303,7 +303,7 @@ cmd_bzip2 = (cat $(filter-out FORCE,$^)
+ 
+ quiet_cmd_lzma = LZMA    $@
+ cmd_lzma = (cat $(filter-out FORCE,$^) | \
+-	lzma -9 && $(call size_append, $(filter-out FORCE,$^))) > $@ || \
++	lzma e -d20 -lc1 -lp2 -pb2 -eos -si -so && $(call size_append, $(filter-out FORCE,$^))) > $@ || \
+ 	(rm -f $@ ; false)
+ 
+ quiet_cmd_lzo = LZO     $@
+--- a/scripts/gen_initramfs_list.sh
++++ b/scripts/gen_initramfs_list.sh
+@@ -226,7 +226,7 @@ cpio_list=
+ output="/dev/stdout"
+ output_file=""
+ is_cpio_compressed=
+-compr="gzip -n -9 -f"
++compr="gzip -n -9 -f -"
+ 
+ arg="$1"
+ case "$arg" in
+@@ -240,9 +240,9 @@ case "$arg" in
+ 		output_file="$1"
+ 		cpio_list="$(mktemp ${TMPDIR:-/tmp}/cpiolist.XXXXXX)"
+ 		output=${cpio_list}
+-		echo "$output_file" | grep -q "\.gz$" && compr="gzip -n -9 -f"
+-		echo "$output_file" | grep -q "\.bz2$" && compr="bzip2 -9 -f"
+-		echo "$output_file" | grep -q "\.lzma$" && compr="lzma -9 -f"
++		echo "$output_file" | grep -q "\.gz$" && compr="gzip -n -9 -f -"
++		echo "$output_file" | grep -q "\.bz2$" && compr="bzip2 -9 -f -"
++		echo "$output_file" | grep -q "\.lzma$" && compr="lzma e -d20 -lc1 -lp2 -pb2 -eos -si -so"
+ 		echo "$output_file" | grep -q "\.xz$" && \
+ 				compr="xz --check=crc32 --lzma2=dict=1MiB"
+ 		echo "$output_file" | grep -q "\.lzo$" && compr="lzop -9 -f"
+@@ -303,7 +303,7 @@ if [ ! -z ${output_file} ]; then
+ 	if [ "${is_cpio_compressed}" = "compressed" ]; then
+ 		cat ${cpio_tfile} > ${output_file}
+ 	else
+-		(cat ${cpio_tfile} | ${compr}  - > ${output_file}) \
++		(cat ${cpio_tfile} | ${compr} > ${output_file}) \
+ 		|| (rm -f ${output_file} ; false)
+ 	fi
+ 	[ -z ${cpio_file} ] && rm ${cpio_tfile}
+--- a/lib/decompress.c
++++ b/lib/decompress.c
+@@ -43,6 +43,7 @@ static const struct compress_format comp
+ 	{ {037, 0236}, "gzip", gunzip },
+ 	{ {0x42, 0x5a}, "bzip2", bunzip2 },
+ 	{ {0x5d, 0x00}, "lzma", unlzma },
++	{ {0x6d, 0x00}, "lzma-openwrt", unlzma },
+ 	{ {0xfd, 0x37}, "xz", unxz },
+ 	{ {0x89, 0x4c}, "lzo", unlzo },
+ 	{ {0, 0}, NULL, NULL }
diff --git a/target/linux/generic/patches-3.10/250-netfilter_depends.patch b/target/linux/generic/patches-3.10/250-netfilter_depends.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/250-netfilter_depends.patch
@@ -0,0 +1,18 @@
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -195,7 +195,6 @@ config NF_CONNTRACK_FTP
+ 
+ config NF_CONNTRACK_H323
+ 	tristate "H.323 protocol support"
+-	depends on (IPV6 || IPV6=n)
+ 	depends on NETFILTER_ADVANCED
+ 	help
+ 	  H.323 is a VoIP signalling protocol from ITU-T. As one of the most
+@@ -758,7 +757,6 @@ config NETFILTER_XT_TARGET_SECMARK
+ 
+ config NETFILTER_XT_TARGET_TCPMSS
+ 	tristate '"TCPMSS" target support'
+-	depends on (IPV6 || IPV6=n)
+ 	default m if NETFILTER_ADVANCED=n
+ 	---help---
+ 	  This option adds a `TCPMSS' target, which allows you to alter the
diff --git a/target/linux/generic/patches-3.10/251-sound_kconfig.patch b/target/linux/generic/patches-3.10/251-sound_kconfig.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/251-sound_kconfig.patch
@@ -0,0 +1,18 @@
+--- a/sound/core/Kconfig
++++ b/sound/core/Kconfig
+@@ -7,13 +7,13 @@ config SND_PCM
+ 	select SND_TIMER
+ 
+ config SND_HWDEP
+-	tristate
++	tristate "Sound hardware support"
+ 
+ config SND_RAWMIDI
+ 	tristate
+ 
+ config SND_COMPRESS_OFFLOAD
+-	tristate
++	tristate "Compression offloading support"
+ 
+ # To be effective this also requires INPUT - users should say:
+ #    select SND_JACK if INPUT=y || INPUT=SND
diff --git a/target/linux/generic/patches-3.10/252-mv_cesa_depends.patch b/target/linux/generic/patches-3.10/252-mv_cesa_depends.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/252-mv_cesa_depends.patch
@@ -0,0 +1,10 @@
+--- a/drivers/crypto/Kconfig
++++ b/drivers/crypto/Kconfig
+@@ -164,6 +164,7 @@ config CRYPTO_DEV_MV_CESA
+ 	depends on PLAT_ORION
+ 	select CRYPTO_ALGAPI
+ 	select CRYPTO_AES
++	select CRYPTO_HASH2
+ 	select CRYPTO_BLKCIPHER2
+ 	select CRYPTO_HASH
+ 	help
diff --git a/target/linux/generic/patches-3.10/253-ssb_b43_default_on.patch b/target/linux/generic/patches-3.10/253-ssb_b43_default_on.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/253-ssb_b43_default_on.patch
@@ -0,0 +1,29 @@
+--- a/drivers/ssb/Kconfig
++++ b/drivers/ssb/Kconfig
+@@ -29,6 +29,7 @@ config SSB_SPROM
+ config SSB_BLOCKIO
+ 	bool
+ 	depends on SSB
++	default y
+ 
+ config SSB_PCIHOST_POSSIBLE
+ 	bool
+@@ -49,7 +50,7 @@ config SSB_PCIHOST
+ config SSB_B43_PCI_BRIDGE
+ 	bool
+ 	depends on SSB_PCIHOST
+-	default n
++	default y
+ 
+ config SSB_PCMCIAHOST_POSSIBLE
+ 	bool
+--- a/drivers/bcma/Kconfig
++++ b/drivers/bcma/Kconfig
+@@ -17,6 +17,7 @@ config BCMA
+ config BCMA_BLOCKIO
+ 	bool
+ 	depends on BCMA
++	default y
+ 
+ config BCMA_HOST_PCI_POSSIBLE
+ 	bool
diff --git a/target/linux/generic/patches-3.10/254-textsearch_kconfig_hacks.patch b/target/linux/generic/patches-3.10/254-textsearch_kconfig_hacks.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/254-textsearch_kconfig_hacks.patch
@@ -0,0 +1,23 @@
+--- a/lib/Kconfig
++++ b/lib/Kconfig
+@@ -280,16 +280,16 @@ config BCH_CONST_T
+ # Textsearch support is select'ed if needed
+ #
+ config TEXTSEARCH
+-	boolean
++	boolean	"Textsearch support"
+ 
+ config TEXTSEARCH_KMP
+-	tristate
++	tristate "Textsearch KMP"
+ 
+ config TEXTSEARCH_BM
+-	tristate
++	tristate "Textsearch BM"
+ 
+ config TEXTSEARCH_FSM
+-	tristate
++	tristate "Textsearch FSM"
+ 
+ config BTREE
+ 	boolean
diff --git a/target/linux/generic/patches-3.10/255-lib80211_kconfig_hacks.patch b/target/linux/generic/patches-3.10/255-lib80211_kconfig_hacks.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/255-lib80211_kconfig_hacks.patch
@@ -0,0 +1,19 @@
+--- a/net/wireless/Kconfig
++++ b/net/wireless/Kconfig
+@@ -149,13 +149,13 @@ config LIB80211
+ 	  Drivers should select this themselves if needed.
+ 
+ config LIB80211_CRYPT_WEP
+-	tristate
++	tristate "LIB80211_CRYPT_WEP"
+ 
+ config LIB80211_CRYPT_CCMP
+-	tristate
++	tristate "LIB80211_CRYPT_CCMP"
+ 
+ config LIB80211_CRYPT_TKIP
+-	tristate
++	tristate "LIB80211_CRYPT_TKIP"
+ 
+ config LIB80211_DEBUG
+ 	bool "lib80211 debugging messages"
diff --git a/target/linux/generic/patches-3.10/256-crypto_add_kconfig_prompts.patch b/target/linux/generic/patches-3.10/256-crypto_add_kconfig_prompts.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/256-crypto_add_kconfig_prompts.patch
@@ -0,0 +1,47 @@
+--- a/crypto/Kconfig
++++ b/crypto/Kconfig
+@@ -31,7 +31,7 @@ config CRYPTO_FIPS
+ 	  this is.
+ 
+ config CRYPTO_ALGAPI
+-	tristate
++	tristate "ALGAPI"
+ 	select CRYPTO_ALGAPI2
+ 	help
+ 	  This option provides the API for cryptographic algorithms.
+@@ -40,7 +40,7 @@ config CRYPTO_ALGAPI2
+ 	tristate
+ 
+ config CRYPTO_AEAD
+-	tristate
++	tristate "AEAD"
+ 	select CRYPTO_AEAD2
+ 	select CRYPTO_ALGAPI
+ 
+@@ -49,7 +49,7 @@ config CRYPTO_AEAD2
+ 	select CRYPTO_ALGAPI2
+ 
+ config CRYPTO_BLKCIPHER
+-	tristate
++	tristate "BLKCIPHER"
+ 	select CRYPTO_BLKCIPHER2
+ 	select CRYPTO_ALGAPI
+ 
+@@ -60,7 +60,7 @@ config CRYPTO_BLKCIPHER2
+ 	select CRYPTO_WORKQUEUE
+ 
+ config CRYPTO_HASH
+-	tristate
++	tristate "HASH"
+ 	select CRYPTO_HASH2
+ 	select CRYPTO_ALGAPI
+ 
+@@ -69,7 +69,7 @@ config CRYPTO_HASH2
+ 	select CRYPTO_ALGAPI2
+ 
+ config CRYPTO_RNG
+-	tristate
++	tristate "RNG"
+ 	select CRYPTO_RNG2
+ 	select CRYPTO_ALGAPI
+ 
diff --git a/target/linux/generic/patches-3.10/257-wireless_ext_kconfig_hack.patch b/target/linux/generic/patches-3.10/257-wireless_ext_kconfig_hack.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/257-wireless_ext_kconfig_hack.patch
@@ -0,0 +1,22 @@
+--- a/net/wireless/Kconfig
++++ b/net/wireless/Kconfig
+@@ -1,5 +1,5 @@
+ config WIRELESS_EXT
+-	bool
++	bool "Wireless extensions"
+ 
+ config WEXT_CORE
+ 	def_bool y
+@@ -11,10 +11,10 @@ config WEXT_PROC
+ 	depends on WEXT_CORE
+ 
+ config WEXT_SPY
+-	bool
++	bool "WEXT_SPY"
+ 
+ config WEXT_PRIV
+-	bool
++	bool "WEXT_PRIV"
+ 
+ config CFG80211
+ 	tristate "cfg80211 - wireless configuration API"
diff --git a/target/linux/generic/patches-3.10/258-netfilter_netlink_kconfig_hack.patch b/target/linux/generic/patches-3.10/258-netfilter_netlink_kconfig_hack.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/258-netfilter_netlink_kconfig_hack.patch
@@ -0,0 +1,11 @@
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -2,7 +2,7 @@ menu "Core Netfilter Configuration"
+ 	depends on NET && INET && NETFILTER
+ 
+ config NETFILTER_NETLINK
+-	tristate
++	tristate "Netfilter NFNETLINK interface"
+ 
+ config NETFILTER_NETLINK_ACCT
+ tristate "Netfilter NFACCT over NFNETLINK interface"
diff --git a/target/linux/generic/patches-3.10/259-regmap_dynamic.patch b/target/linux/generic/patches-3.10/259-regmap_dynamic.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/259-regmap_dynamic.patch
@@ -0,0 +1,72 @@
+--- a/drivers/base/regmap/Kconfig
++++ b/drivers/base/regmap/Kconfig
+@@ -3,20 +3,24 @@
+ # subsystems should select the appropriate symbols.
+ 
+ config REGMAP
+-	default y if (REGMAP_I2C || REGMAP_SPI || REGMAP_MMIO || REGMAP_IRQ)
+ 	select LZO_COMPRESS
+ 	select LZO_DECOMPRESS
+ 	select IRQ_DOMAIN if REGMAP_IRQ
+-	bool
++	tristate "Regmap"
+ 
+ config REGMAP_I2C
+-	tristate
++	select REGMAP
++	tristate "Regmap I2C"
+ 
+ config REGMAP_SPI
+-	tristate
++	select REGMAP
++	depends on SPI_MASTER
++	tristate "Regmap SPI"
+ 
+ config REGMAP_MMIO
++	select REGMAP
+ 	tristate
+ 
+ config REGMAP_IRQ
++	select REGMAP
+ 	bool
+--- a/include/linux/regmap.h
++++ b/include/linux/regmap.h
+@@ -47,7 +47,7 @@ struct reg_default {
+ 	unsigned int def;
+ };
+ 
+-#ifdef CONFIG_REGMAP
++#if IS_ENABLED(CONFIG_REGMAP)
+ 
+ enum regmap_endian {
+ 	/* Unspecified -> 0 -> Backwards compatible default */
+--- a/drivers/base/regmap/Makefile
++++ b/drivers/base/regmap/Makefile
+@@ -1,6 +1,8 @@
+-obj-$(CONFIG_REGMAP) += regmap.o regcache.o
+-obj-$(CONFIG_REGMAP) += regcache-rbtree.o regcache-lzo.o regcache-flat.o
+-obj-$(CONFIG_DEBUG_FS) += regmap-debugfs.o
++regmap-core-objs = regmap.o regcache.o regcache-rbtree.o regcache-lzo.o regcache-flat.o
++ifdef CONFIG_DEBUG_FS
++regmap-core-objs += regmap-debugfs.o
++endif
++obj-$(CONFIG_REGMAP) += regmap-core.o
+ obj-$(CONFIG_REGMAP_I2C) += regmap-i2c.o
+ obj-$(CONFIG_REGMAP_SPI) += regmap-spi.o
+ obj-$(CONFIG_REGMAP_MMIO) += regmap-mmio.o
+--- a/drivers/base/regmap/regmap.c
++++ b/drivers/base/regmap/regmap.c
+@@ -13,6 +13,7 @@
+ #include <linux/device.h>
+ #include <linux/slab.h>
+ #include <linux/export.h>
++#include <linux/module.h>
+ #include <linux/mutex.h>
+ #include <linux/err.h>
+ #include <linux/rbtree.h>
+@@ -1815,3 +1816,5 @@ static int __init regmap_initcall(void)
+ 	return 0;
+ }
+ postcore_initcall(regmap_initcall);
++
++MODULE_LICENSE("GPL");
diff --git a/target/linux/generic/patches-3.10/260-crypto_test_dependencies.patch b/target/linux/generic/patches-3.10/260-crypto_test_dependencies.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/260-crypto_test_dependencies.patch
@@ -0,0 +1,37 @@
+--- a/crypto/Kconfig
++++ b/crypto/Kconfig
+@@ -95,10 +95,10 @@ config CRYPTO_MANAGER
+ 
+ config CRYPTO_MANAGER2
+ 	def_tristate CRYPTO_MANAGER || (CRYPTO_MANAGER!=n && CRYPTO_ALGAPI=y)
+-	select CRYPTO_AEAD2
+-	select CRYPTO_HASH2
+-	select CRYPTO_BLKCIPHER2
+-	select CRYPTO_PCOMP2
++	select CRYPTO_AEAD2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_HASH2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_BLKCIPHER2 if !CRYPTO_MANAGER_DISABLE_TESTS
++	select CRYPTO_PCOMP2 if !CRYPTO_MANAGER_DISABLE_TESTS
+ 
+ config CRYPTO_USER
+ 	tristate "Userspace cryptographic algorithm configuration"
+--- a/crypto/algboss.c
++++ b/crypto/algboss.c
+@@ -248,6 +248,9 @@ static int cryptomgr_schedule_test(struc
+ 	type = alg->cra_flags;
+ 
+ 	/* This piece of crap needs to disappear into per-type test hooks. */
++#ifdef CONFIG_CRYPTO_MANAGER_DISABLE_TESTS
++	type |= CRYPTO_ALG_TESTED;
++#else
+ 	if ((!((type ^ CRYPTO_ALG_TYPE_BLKCIPHER) &
+ 	       CRYPTO_ALG_TYPE_BLKCIPHER_MASK) && !(type & CRYPTO_ALG_GENIV) &&
+ 	     ((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==
+@@ -256,6 +259,7 @@ static int cryptomgr_schedule_test(struc
+ 	    (!((type ^ CRYPTO_ALG_TYPE_AEAD) & CRYPTO_ALG_TYPE_MASK) &&
+ 	     alg->cra_type == &crypto_nivaead_type && alg->cra_aead.ivsize))
+ 		type |= CRYPTO_ALG_TESTED;
++#endif
+ 
+ 	param->type = type;
+ 
diff --git a/target/linux/generic/patches-3.10/261-move_bcm963xx_tag.patch b/target/linux/generic/patches-3.10/261-move_bcm963xx_tag.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/261-move_bcm963xx_tag.patch
@@ -0,0 +1,219 @@
+--- a/arch/mips/include/asm/mach-bcm63xx/bcm963xx_tag.h
++++ /dev/null
+@@ -1,96 +0,0 @@
+-#ifndef __BCM963XX_TAG_H
+-#define __BCM963XX_TAG_H
+-
+-#define TAGVER_LEN		4	/* Length of Tag Version */
+-#define TAGLAYOUT_LEN		4	/* Length of FlashLayoutVer */
+-#define SIG1_LEN		20	/* Company Signature 1 Length */
+-#define SIG2_LEN		14	/* Company Signature 2 Length */
+-#define BOARDID_LEN		16	/* Length of BoardId */
+-#define ENDIANFLAG_LEN		2	/* Endian Flag Length */
+-#define CHIPID_LEN		6	/* Chip Id Length */
+-#define IMAGE_LEN		10	/* Length of Length Field */
+-#define ADDRESS_LEN		12	/* Length of Address field */
+-#define DUALFLAG_LEN		2	/* Dual Image flag Length */
+-#define INACTIVEFLAG_LEN	2	/* Inactie Flag Length */
+-#define RSASIG_LEN		20	/* Length of RSA Signature in tag */
+-#define TAGINFO1_LEN		30	/* Length of vendor information field1 in tag */
+-#define FLASHLAYOUTVER_LEN	4	/* Length of Flash Layout Version String tag */
+-#define TAGINFO2_LEN		16	/* Length of vendor information field2 in tag */
+-#define ALTTAGINFO_LEN		54	/* Alternate length for vendor information; Pirelli */
+-
+-#define NUM_PIRELLI		2
+-#define IMAGETAG_CRC_START	0xFFFFFFFF
+-
+-#define PIRELLI_BOARDS { \
+-	"AGPF-S0", \
+-	"DWV-S0", \
+-}
+-
+-/*
+- * The broadcom firmware assumes the rootfs starts the image,
+- * therefore uses the rootfs start (flash_image_address)
+- * to determine where to flash the image.  Since we have the kernel first
+- * we have to give it the kernel address, but the crc uses the length
+- * associated with this address (root_length), which is added to the kernel
+- * length (kernel_length) to determine the length of image to flash and thus
+- * needs to be rootfs + deadcode (jffs2 EOF marker)
+-*/
+-
+-struct bcm_tag {
+-	/* 0-3: Version of the image tag */
+-	char tag_version[TAGVER_LEN];
+-	/* 4-23: Company Line 1 */
+-	char sig_1[SIG1_LEN];
+-	/*  24-37: Company Line 2 */
+-	char sig_2[SIG2_LEN];
+-	/* 38-43: Chip this image is for */
+-	char chip_id[CHIPID_LEN];
+-	/* 44-59: Board name */
+-	char board_id[BOARDID_LEN];
+-	/* 60-61: Map endianness -- 1 BE 0 LE */
+-	char big_endian[ENDIANFLAG_LEN];
+-	/* 62-71: Total length of image */
+-	char total_length[IMAGE_LEN];
+-	/* 72-83: Address in memory of CFE */
+-	char cfe__address[ADDRESS_LEN];
+-	/* 84-93: Size of CFE */
+-	char cfe_length[IMAGE_LEN];
+-	/* 94-105: Address in memory of image start
+-	 * (kernel for OpenWRT, rootfs for stock firmware)
+-	 */
+-	char flash_image_start[ADDRESS_LEN];
+-	/* 106-115: Size of rootfs */
+-	char root_length[IMAGE_LEN];
+-	/* 116-127: Address in memory of kernel */
+-	char kernel_address[ADDRESS_LEN];
+-	/* 128-137: Size of kernel */
+-	char kernel_length[IMAGE_LEN];
+-	/* 138-139: Unused at the moment */
+-	char dual_image[DUALFLAG_LEN];
+-	/* 140-141: Unused at the moment */
+-	char inactive_flag[INACTIVEFLAG_LEN];
+-	/* 142-161: RSA Signature (not used; some vendors may use this) */
+-	char rsa_signature[RSASIG_LEN];
+-	/* 162-191: Compilation and related information (not used in OpenWrt) */
+-	char information1[TAGINFO1_LEN];
+-	/* 192-195: Version flash layout */
+-	char flash_layout_ver[FLASHLAYOUTVER_LEN];
+-	/* 196-199: kernel+rootfs CRC32 */
+-	__u32 fskernel_crc;
+-	/* 200-215: Unused except on Alice Gate where is is information */
+-	char information2[TAGINFO2_LEN];
+-	/* 216-219: CRC32 of image less imagetag (kernel for Alice Gate) */
+-	__u32 image_crc;
+-	/* 220-223: CRC32 of rootfs partition */
+-	__u32 rootfs_crc;
+-	/* 224-227: CRC32 of kernel partition */
+-	__u32 kernel_crc;
+-	/* 228-235: Unused at present */
+-	char reserved1[8];
+-	/* 236-239: CRC32 of header excluding last 20 bytes */
+-	__u32 header_crc;
+-	/* 240-255: Unused at present */
+-	char reserved2[16];
+-};
+-
+-#endif /* __BCM63XX_TAG_H */
+--- a/drivers/mtd/bcm63xxpart.c
++++ b/drivers/mtd/bcm63xxpart.c
+@@ -32,7 +32,7 @@
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/partitions.h>
+ 
+-#include <asm/mach-bcm63xx/bcm963xx_tag.h>
++#include <linux/bcm963xx_tag.h>
+ #include <asm/mach-bcm63xx/board_bcm963xx.h>
+ 
+ #define BCM63XX_EXTENDED_SIZE	0xBFC00000	/* Extended flash address */
+--- a/include/uapi/linux/Kbuild
++++ b/include/uapi/linux/Kbuild
+@@ -67,6 +67,7 @@ header-y += binfmts.h
+ header-y += blkpg.h
+ header-y += blktrace_api.h
+ header-y += bpqether.h
++header-y += bcm963xx_tag.h
+ header-y += bsg.h
+ header-y += btrfs.h
+ header-y += can.h
+--- /dev/null
++++ b/include/uapi/linux/bcm963xx_tag.h
+@@ -0,0 +1,96 @@
++#ifndef __BCM963XX_TAG_H
++#define __BCM963XX_TAG_H
++
++#define TAGVER_LEN		4	/* Length of Tag Version */
++#define TAGLAYOUT_LEN		4	/* Length of FlashLayoutVer */
++#define SIG1_LEN		20	/* Company Signature 1 Length */
++#define SIG2_LEN		14	/* Company Signature 2 Length */
++#define BOARDID_LEN		16	/* Length of BoardId */
++#define ENDIANFLAG_LEN		2	/* Endian Flag Length */
++#define CHIPID_LEN		6	/* Chip Id Length */
++#define IMAGE_LEN		10	/* Length of Length Field */
++#define ADDRESS_LEN		12	/* Length of Address field */
++#define DUALFLAG_LEN		2	/* Dual Image flag Length */
++#define INACTIVEFLAG_LEN	2	/* Inactie Flag Length */
++#define RSASIG_LEN		20	/* Length of RSA Signature in tag */
++#define TAGINFO1_LEN		30	/* Length of vendor information field1 in tag */
++#define FLASHLAYOUTVER_LEN	4	/* Length of Flash Layout Version String tag */
++#define TAGINFO2_LEN		16	/* Length of vendor information field2 in tag */
++#define ALTTAGINFO_LEN		54	/* Alternate length for vendor information; Pirelli */
++
++#define NUM_PIRELLI		2
++#define IMAGETAG_CRC_START	0xFFFFFFFF
++
++#define PIRELLI_BOARDS { \
++	"AGPF-S0", \
++	"DWV-S0", \
++}
++
++/*
++ * The broadcom firmware assumes the rootfs starts the image,
++ * therefore uses the rootfs start (flash_image_address)
++ * to determine where to flash the image.  Since we have the kernel first
++ * we have to give it the kernel address, but the crc uses the length
++ * associated with this address (root_length), which is added to the kernel
++ * length (kernel_length) to determine the length of image to flash and thus
++ * needs to be rootfs + deadcode (jffs2 EOF marker)
++*/
++
++struct bcm_tag {
++	/* 0-3: Version of the image tag */
++	char tag_version[TAGVER_LEN];
++	/* 4-23: Company Line 1 */
++	char sig_1[SIG1_LEN];
++	/*  24-37: Company Line 2 */
++	char sig_2[SIG2_LEN];
++	/* 38-43: Chip this image is for */
++	char chip_id[CHIPID_LEN];
++	/* 44-59: Board name */
++	char board_id[BOARDID_LEN];
++	/* 60-61: Map endianness -- 1 BE 0 LE */
++	char big_endian[ENDIANFLAG_LEN];
++	/* 62-71: Total length of image */
++	char total_length[IMAGE_LEN];
++	/* 72-83: Address in memory of CFE */
++	char cfe__address[ADDRESS_LEN];
++	/* 84-93: Size of CFE */
++	char cfe_length[IMAGE_LEN];
++	/* 94-105: Address in memory of image start
++	 * (kernel for OpenWRT, rootfs for stock firmware)
++	 */
++	char flash_image_start[ADDRESS_LEN];
++	/* 106-115: Size of rootfs */
++	char root_length[IMAGE_LEN];
++	/* 116-127: Address in memory of kernel */
++	char kernel_address[ADDRESS_LEN];
++	/* 128-137: Size of kernel */
++	char kernel_length[IMAGE_LEN];
++	/* 138-139: Unused at the moment */
++	char dual_image[DUALFLAG_LEN];
++	/* 140-141: Unused at the moment */
++	char inactive_flag[INACTIVEFLAG_LEN];
++	/* 142-161: RSA Signature (not used; some vendors may use this) */
++	char rsa_signature[RSASIG_LEN];
++	/* 162-191: Compilation and related information (not used in OpenWrt) */
++	char information1[TAGINFO1_LEN];
++	/* 192-195: Version flash layout */
++	char flash_layout_ver[FLASHLAYOUTVER_LEN];
++	/* 196-199: kernel+rootfs CRC32 */
++	__u32 fskernel_crc;
++	/* 200-215: Unused except on Alice Gate where is is information */
++	char information2[TAGINFO2_LEN];
++	/* 216-219: CRC32 of image less imagetag (kernel for Alice Gate) */
++	__u32 image_crc;
++	/* 220-223: CRC32 of rootfs partition */
++	__u32 rootfs_crc;
++	/* 224-227: CRC32 of kernel partition */
++	__u32 kernel_crc;
++	/* 228-235: Unused at present */
++	char reserved1[8];
++	/* 236-239: CRC32 of header excluding last 20 bytes */
++	__u32 header_crc;
++	/* 240-255: Unused at present */
++	char reserved2[16];
++};
++
++#endif /* __BCM63XX_TAG_H */
diff --git a/target/linux/generic/patches-3.10/262-compressor_kconfig_hack.patch b/target/linux/generic/patches-3.10/262-compressor_kconfig_hack.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/262-compressor_kconfig_hack.patch
@@ -0,0 +1,23 @@
+--- a/lib/Kconfig
++++ b/lib/Kconfig
+@@ -178,16 +178,16 @@ config AUDIT_GENERIC
+ # compression support is select'ed if needed
+ #
+ config ZLIB_INFLATE
+-	tristate
++	tristate "ZLIB inflate support"
+ 
+ config ZLIB_DEFLATE
+-	tristate
++	tristate "ZLIB deflate support"
+ 
+ config LZO_COMPRESS
+-	tristate
++	tristate "LZO compress support"
+ 
+ config LZO_DECOMPRESS
+-	tristate
++	tristate "LZO decompress support"
+ 
+ source "lib/xz/Kconfig"
+ 
diff --git a/target/linux/generic/patches-3.10/300-mips_expose_boot_raw.patch b/target/linux/generic/patches-3.10/300-mips_expose_boot_raw.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/300-mips_expose_boot_raw.patch
@@ -0,0 +1,39 @@
+From: Mark Miller <mark@mirell.org>
+
+This exposes the CONFIG_BOOT_RAW symbol in Kconfig. This is needed on
+certain Broadcom chipsets running CFE in order to load the kernel.
+
+Signed-off-by: Mark Miller <mark@mirell.org>
+Acked-by: Rob Landley <rob@landley.net>
+---
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -896,9 +896,6 @@ config FW_ARC
+ config ARCH_MAY_HAVE_PC_FDC
+ 	bool
+ 
+-config BOOT_RAW
+-	bool
+-
+ config CEVT_BCM1480
+ 	bool
+ 
+@@ -2396,6 +2393,18 @@ config USE_OF
+ 	select OF_EARLY_FLATTREE
+ 	select IRQ_DOMAIN
+ 
++config BOOT_RAW
++	bool "Enable the kernel to be executed from the load address"
++	default n
++	help
++	 Allow the kernel to be executed from the load address for
++	 bootloaders which cannot read the ELF format. This places
++	 a jump to start_kernel at the load address.
++
++	 If unsure, say N.
++
++
++
+ endmenu
+ 
+ config LOCKDEP_SUPPORT
diff --git a/target/linux/generic/patches-3.10/301-mips_image_cmdline_hack.patch b/target/linux/generic/patches-3.10/301-mips_image_cmdline_hack.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/301-mips_image_cmdline_hack.patch
@@ -0,0 +1,28 @@
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -993,6 +993,10 @@ config SYNC_R4K
+ config MIPS_MACHINE
+ 	def_bool n
+ 
++config IMAGE_CMDLINE_HACK
++	bool "OpenWrt specific image command line hack"
++	default n
++
+ config NO_IOPORT
+ 	def_bool n
+ 
+--- a/arch/mips/kernel/head.S
++++ b/arch/mips/kernel/head.S
+@@ -140,6 +140,12 @@ FEXPORT(__kernel_entry)
+ 	j	kernel_entry
+ #endif
+ 
++#ifdef CONFIG_IMAGE_CMDLINE_HACK
++	.ascii	"CMDLINE:"
++EXPORT(__image_cmdline)
++	.fill	0x400
++#endif /* CONFIG_IMAGE_CMDLINE_HACK */
++
+ 	__REF
+ 
+ NESTED(kernel_entry, 16, sp)			# kernel entry point
diff --git a/target/linux/generic/patches-3.10/302-mips_no_branch_likely.patch b/target/linux/generic/patches-3.10/302-mips_no_branch_likely.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/302-mips_no_branch_likely.patch
@@ -0,0 +1,11 @@
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -87,7 +87,7 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
+ # machines may also.  Since BFD is incredibly buggy with respect to
+ # crossformat linking we rely on the elf2ecoff tool for format conversion.
+ #
+-cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
++cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
+ cflags-y			+= -msoft-float
+ LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib --gc-sections
+ KBUILD_AFLAGS_MODULE		+= -mlong-calls
diff --git a/target/linux/generic/patches-3.10/304-mips_disable_fpu.patch b/target/linux/generic/patches-3.10/304-mips_disable_fpu.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/304-mips_disable_fpu.patch
@@ -0,0 +1,160 @@
+MIPS: allow disabling the kernel FPU emulator
+
+This patch allows turning off the in-kernel Algorithmics
+FPU emulator support, which allows one to save a couple of
+precious blocks on an embedded system.
+
+Signed-off-by: Florian Fainelli <florian@openwrt.org>
+--
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -981,6 +981,17 @@ config I8259
+ config MIPS_BONITO64
+ 	bool
+ 
++config MIPS_FPU_EMU
++	bool "Enable FPU emulation"
++	default y
++	help
++	   This option allows building a kernel with or without the Algorithmics
++	   FPU emulator enabled. Turning off this option results in a kernel which
++	   does not catch floating operations exceptions. Make sure that your toolchain
++	   is configured to enable software floating point emulation in that case.
++
++	   If unsure say Y here.
++
+ config MIPS_MSC
+ 	bool
+ 
+--- a/arch/mips/math-emu/Makefile
++++ b/arch/mips/math-emu/Makefile
+@@ -2,10 +2,12 @@
+ # Makefile for the Linux/MIPS kernel FPU emulation.
+ #
+ 
+-obj-y	:= cp1emu.o ieee754m.o ieee754d.o ieee754dp.o ieee754sp.o ieee754.o \
++obj-y	:= kernel_linkage.o
++
++obj-$(CONFIG_MIPS_FPU_EMU)	+= ieee754m.o ieee754d.o ieee754dp.o ieee754sp.o ieee754.o \
+ 	   ieee754xcpt.o dp_frexp.o dp_modf.o dp_div.o dp_mul.o dp_sub.o \
+ 	   dp_add.o dp_fsp.o dp_cmp.o dp_logb.o dp_scalb.o dp_simple.o \
+ 	   dp_tint.o dp_fint.o dp_tlong.o dp_flong.o sp_frexp.o sp_modf.o \
+ 	   sp_div.o sp_mul.o sp_sub.o sp_add.o sp_fdp.o sp_cmp.o sp_logb.o \
+ 	   sp_scalb.o sp_simple.o sp_tint.o sp_fint.o sp_tlong.o sp_flong.o \
+-	   dp_sqrt.o sp_sqrt.o kernel_linkage.o dsemul.o
++	   dp_sqrt.o sp_sqrt.o dsemul.o cp1emu.o
+--- a/arch/mips/math-emu/kernel_linkage.c
++++ b/arch/mips/math-emu/kernel_linkage.c
+@@ -29,6 +29,7 @@
+ 
+ #define SIGNALLING_NAN 0x7ff800007ff80000LL
+ 
++#ifdef CONFIG_MIPS_FPU_EMU
+ void fpu_emulator_init_fpu(void)
+ {
+ 	static int first = 1;
+@@ -113,3 +114,36 @@ int fpu_emulator_restore_context32(struc
+ 	return err;
+ }
+ #endif
++
++#else
++
++void fpu_emulator_init_fpu(void)
++{
++	printk(KERN_INFO "FPU emulator disabled, make sure your toolchain"
++		"was compiled with software floating point support (soft-float)\n");
++	return;
++}
++
++int fpu_emulator_save_context(struct sigcontext __user *sc)
++{
++	return 0;
++}
++
++int fpu_emulator_restore_context(struct sigcontext __user *sc)
++{
++	return 0;
++}
++
++#ifdef CONFIG_64BIT
++int fpu_emulator_save_context32(struct sigcontext32 __user *sc)
++{
++	return 0;
++}
++
++int fpu_emulator_restore_context32(struct sigcontext32 __user *sc)
++{
++	return 0;
++}
++#endif /* CONFIG_64BIT */
++
++#endif /* CONFIG_MIPS_FPU_EMU */
+--- a/arch/mips/include/asm/fpu_emulator.h
++++ b/arch/mips/include/asm/fpu_emulator.h
+@@ -27,6 +27,8 @@
+ #include <asm/inst.h>
+ #include <asm/local.h>
+ 
++#ifdef CONFIG_MIPS_FPU_EMU
++
+ #ifdef CONFIG_DEBUG_FS
+ 
+ struct mips_fpu_emulator_stats {
+@@ -60,6 +62,38 @@ extern int fpu_emulator_cop1Handler(stru
+ int process_fpemu_return(int sig, void __user *fault_addr);
+ int mm_isBranchInstr(struct pt_regs *regs, struct mm_decoded_insn dec_insn,
+ 		     unsigned long *contpc);
++#else
++static inline int mips_dsemul(struct pt_regs *regs, mips_instruction ir,
++			      unsigned long cpc)
++{
++	return 0;
++}
++
++static inline int do_dsemulret(struct pt_regs *xcp)
++{
++	return 0;
++}
++
++static inline int fpu_emulator_cop1Handler(struct pt_regs *xcp,
++					   struct mips_fpu_struct *ctx,
++					   int has_fpu,
++					   void *__user *fault_addr)
++{
++	return 0;
++}
++
++static inline int process_fpemu_return(int sig, void __user *fault_addr)
++{
++	return -EINVAL;
++}
++
++static inline int mm_isBranchInstr(struct pt_regs *regs,
++				   struct mm_decoded_insn dec_insn,
++				   unsigned long *contpc)
++{
++	return 0;
++}
++#endif /* CONFIG_MIPS_FPU_EMU */
+ 
+ /*
+  * Instruction inserted following the badinst to further tag the sequence
+--- a/arch/mips/kernel/traps.c
++++ b/arch/mips/kernel/traps.c
+@@ -684,6 +684,7 @@ asmlinkage void do_ov(struct pt_regs *re
+ 	force_sig_info(SIGFPE, &info, current);
+ }
+ 
++#ifdef CONFIG_MIPS_FPU_EMU
+ int process_fpemu_return(int sig, void __user *fault_addr)
+ {
+ 	if (sig == SIGSEGV || sig == SIGBUS) {
+@@ -707,6 +708,7 @@ int process_fpemu_return(int sig, void _
+ 		return 0;
+ 	}
+ }
++#endif /* CONFIG_MIPS_FPU_EMU */
+ 
+ /*
+  * XXX Delayed fp exceptions when doing a lazy ctx switch XXX
diff --git a/target/linux/generic/patches-3.10/305-mips_module_reloc.patch b/target/linux/generic/patches-3.10/305-mips_module_reloc.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/305-mips_module_reloc.patch
@@ -0,0 +1,352 @@
+--- a/arch/mips/Makefile
++++ b/arch/mips/Makefile
+@@ -90,8 +90,13 @@ all-$(CONFIG_SYS_SUPPORTS_ZBOOT)+= vmlin
+ cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe -mno-branch-likely
+ cflags-y			+= -msoft-float
+ LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib --gc-sections
++ifdef CONFIG_64BIT
+ KBUILD_AFLAGS_MODULE		+= -mlong-calls
+ KBUILD_CFLAGS_MODULE		+= -mlong-calls
++else
++KBUILD_AFLAGS_MODULE		+= -mno-long-calls
++KBUILD_CFLAGS_MODULE		+= -mno-long-calls
++endif
+ 
+ ifndef CONFIG_FUNCTION_TRACER
+ KBUILD_CFLAGS_KERNEL		+= -ffunction-sections -fdata-sections
+--- a/arch/mips/include/asm/module.h
++++ b/arch/mips/include/asm/module.h
+@@ -11,6 +11,11 @@ struct mod_arch_specific {
+ 	const struct exception_table_entry *dbe_start;
+ 	const struct exception_table_entry *dbe_end;
+ 	struct mips_hi16 *r_mips_hi16_list;
++
++	void *phys_plt_tbl;
++	void *virt_plt_tbl;
++	unsigned int phys_plt_offset;
++	unsigned int virt_plt_offset;
+ };
+ 
+ typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
+--- a/arch/mips/kernel/module.c
++++ b/arch/mips/kernel/module.c
+@@ -42,14 +42,222 @@ struct mips_hi16 {
+ static LIST_HEAD(dbe_list);
+ static DEFINE_SPINLOCK(dbe_lock);
+ 
+-#ifdef MODULE_START
++/*
++ * Get the potential max trampolines size required of the init and
++ * non-init sections. Only used if we cannot find enough contiguous
++ * physically mapped memory to put the module into.
++ */
++static unsigned int
++get_plt_size(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
++             const char *secstrings, unsigned int symindex, bool is_init)
++{
++	unsigned long ret = 0;
++	unsigned int i, j;
++	Elf_Sym *syms;
++
++	/* Everything marked ALLOC (this includes the exported symbols) */
++	for (i = 1; i < hdr->e_shnum; ++i) {
++		unsigned int info = sechdrs[i].sh_info;
++
++		if (sechdrs[i].sh_type != SHT_REL
++		    && sechdrs[i].sh_type != SHT_RELA)
++			continue;
++
++		/* Not a valid relocation section? */
++		if (info >= hdr->e_shnum)
++			continue;
++
++		/* Don't bother with non-allocated sections */
++		if (!(sechdrs[info].sh_flags & SHF_ALLOC))
++			continue;
++
++		/* If it's called *.init*, and we're not init, we're
++                   not interested */
++		if ((strstr(secstrings + sechdrs[i].sh_name, ".init") != 0)
++		    != is_init)
++			continue;
++
++		syms = (Elf_Sym *) sechdrs[symindex].sh_addr;
++		if (sechdrs[i].sh_type == SHT_REL) {
++			Elf_Mips_Rel *rel = (void *) sechdrs[i].sh_addr;
++			unsigned int size = sechdrs[i].sh_size / sizeof(*rel);
++
++			for (j = 0; j < size; ++j) {
++				Elf_Sym *sym;
++
++				if (ELF_MIPS_R_TYPE(rel[j]) != R_MIPS_26)
++					continue;
++
++				sym = syms + ELF_MIPS_R_SYM(rel[j]);
++				if (!is_init && sym->st_shndx != SHN_UNDEF)
++					continue;
++
++				ret += 4 * sizeof(int);
++			}
++		} else {
++			Elf_Mips_Rela *rela = (void *) sechdrs[i].sh_addr;
++			unsigned int size = sechdrs[i].sh_size / sizeof(*rela);
++
++			for (j = 0; j < size; ++j) {
++				Elf_Sym *sym;
++
++				if (ELF_MIPS_R_TYPE(rela[j]) != R_MIPS_26)
++					continue;
++
++				sym = syms + ELF_MIPS_R_SYM(rela[j]);
++				if (!is_init && sym->st_shndx != SHN_UNDEF)
++					continue;
++
++				ret += 4 * sizeof(int);
++			}
++		}
++	}
++
++	return ret;
++}
++
++#ifndef MODULE_START
++static void *alloc_phys(unsigned long size)
++{
++	unsigned order;
++	struct page *page;
++	struct page *p;
++
++	size = PAGE_ALIGN(size);
++	order = get_order(size);
++
++	page = alloc_pages(GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN |
++			__GFP_THISNODE, order);
++	if (!page)
++		return NULL;
++
++	split_page(page, order);
++
++	for (p = page + (size >> PAGE_SHIFT); p < page + (1 << order); ++p)
++		__free_page(p);
++
++	return page_address(page);
++}
++#endif
++
++static void free_phys(void *ptr, unsigned long size)
++{
++	struct page *page;
++	struct page *end;
++
++	page = virt_to_page(ptr);
++	end = page + (PAGE_ALIGN(size) >> PAGE_SHIFT);
++
++	for (; page < end; ++page)
++		__free_page(page);
++}
++
++
+ void *module_alloc(unsigned long size)
+ {
++#ifdef MODULE_START
+ 	return __vmalloc_node_range(size, 1, MODULE_START, MODULE_END,
+ 				GFP_KERNEL, PAGE_KERNEL, -1,
+ 				__builtin_return_address(0));
++#else
++	void *ptr;
++
++	if (size == 0)
++		return NULL;
++
++	ptr = alloc_phys(size);
++
++	/* If we failed to allocate physically contiguous memory,
++	 * fall back to regular vmalloc. The module loader code will
++	 * create jump tables to handle long jumps */
++	if (!ptr)
++		return vmalloc(size);
++
++	return ptr;
++#endif
+ }
++
++static inline bool is_phys_addr(void *ptr)
++{
++#ifdef CONFIG_64BIT
++	return (KSEGX((unsigned long)ptr) == CKSEG0);
++#else
++	return (KSEGX(ptr) == KSEG0);
+ #endif
++}
++
++/* Free memory returned from module_alloc */
++void module_free(struct module *mod, void *module_region)
++{
++	if (is_phys_addr(module_region)) {
++		if (mod->module_init == module_region)
++			free_phys(module_region, mod->init_size);
++		else if (mod->module_core == module_region)
++			free_phys(module_region, mod->core_size);
++		else
++			BUG();
++	} else {
++		vfree(module_region);
++	}
++}
++
++static void *__module_alloc(int size, bool phys)
++{
++	void *ptr;
++
++	if (phys)
++		ptr = kmalloc(size, GFP_KERNEL);
++	else
++		ptr = vmalloc(size);
++	return ptr;
++}
++
++static void __module_free(void *ptr)
++{
++	if (is_phys_addr(ptr))
++		kfree(ptr);
++	else
++		vfree(ptr);
++}
++
++int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
++			      char *secstrings, struct module *mod)
++{
++	unsigned int symindex = 0;
++	unsigned int core_size, init_size;
++	int i;
++
++	mod->arch.phys_plt_offset = 0;
++	mod->arch.virt_plt_offset = 0;
++	mod->arch.phys_plt_tbl = NULL;
++	mod->arch.virt_plt_tbl = NULL;
++
++	if (IS_ENABLED(CONFIG_64BIT))
++		return 0;
++
++	for (i = 1; i < hdr->e_shnum; i++)
++		if (sechdrs[i].sh_type == SHT_SYMTAB)
++			symindex = i;
++
++	core_size = get_plt_size(hdr, sechdrs, secstrings, symindex, false);
++	init_size = get_plt_size(hdr, sechdrs, secstrings, symindex, true);
++
++	if ((core_size + init_size) == 0)
++		return 0;
++
++	mod->arch.phys_plt_tbl = __module_alloc(core_size + init_size, 1);
++	if (!mod->arch.phys_plt_tbl)
++		return -ENOMEM;
++
++	mod->arch.virt_plt_tbl = __module_alloc(core_size + init_size, 0);
++	if (!mod->arch.virt_plt_tbl) {
++		__module_free(mod->arch.phys_plt_tbl);
++		mod->arch.phys_plt_tbl = NULL;
++		return -ENOMEM;
++	}
++
++	return 0;
++}
+ 
+ int apply_r_mips_none(struct module *me, u32 *location, Elf_Addr v)
+ {
+@@ -63,8 +271,39 @@ static int apply_r_mips_32_rel(struct mo
+ 	return 0;
+ }
+ 
++static Elf_Addr add_plt_entry_to(unsigned *plt_offset,
++				 void *start, Elf_Addr v)
++{
++	unsigned *tramp = start + *plt_offset;
++	*plt_offset += 4 * sizeof(int);
++
++	/* adjust carry for addiu */
++	if (v & 0x00008000)
++		v += 0x10000;
++
++	tramp[0] = 0x3c190000 | (v >> 16);      /* lui t9, hi16 */
++	tramp[1] = 0x27390000 | (v & 0xffff);   /* addiu t9, t9, lo16 */
++	tramp[2] = 0x03200008;                  /* jr t9 */
++	tramp[3] = 0x00000000;                  /* nop */
++
++	return (Elf_Addr) tramp;
++}
++
++static Elf_Addr add_plt_entry(struct module *me, void *location, Elf_Addr v)
++{
++	if (is_phys_addr(location))
++		return add_plt_entry_to(&me->arch.phys_plt_offset,
++				me->arch.phys_plt_tbl, v);
++	else
++		return add_plt_entry_to(&me->arch.virt_plt_offset,
++				me->arch.virt_plt_tbl, v);
++
++}
++
+ static int apply_r_mips_26_rel(struct module *me, u32 *location, Elf_Addr v)
+ {
++	u32 ofs = *location & 0x03ffffff;
++
+ 	if (v % 4) {
+ 		pr_err("module %s: dangerous R_MIPS_26 REL relocation\n",
+ 		       me->name);
+@@ -72,14 +311,17 @@ static int apply_r_mips_26_rel(struct mo
+ 	}
+ 
+ 	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
+-		printk(KERN_ERR
+-		       "module %s: relocation overflow\n",
+-		       me->name);
+-		return -ENOEXEC;
++		v = add_plt_entry(me, location, v + (ofs << 2));
++		if (!v) {
++			printk(KERN_ERR
++				"module %s: relocation overflow\n", me->name);
++			return -ENOEXEC;
++		}
++		ofs = 0;
+ 	}
+ 
+ 	*location = (*location & ~0x03ffffff) |
+-		    ((*location + (v >> 2)) & 0x03ffffff);
++		    ((ofs + (v >> 2)) & 0x03ffffff);
+ 
+ 	return 0;
+ }
+@@ -286,11 +528,32 @@ int module_finalize(const Elf_Ehdr *hdr,
+ 		list_add(&me->arch.dbe_list, &dbe_list);
+ 		spin_unlock_irq(&dbe_lock);
+ 	}
++
++	/* Get rid of the fixup trampoline if we're running the module
++	 * from physically mapped address space */
++	if (me->arch.phys_plt_offset == 0) {
++		__module_free(me->arch.phys_plt_tbl);
++		me->arch.phys_plt_tbl = NULL;
++	}
++	if (me->arch.virt_plt_offset == 0) {
++		__module_free(me->arch.virt_plt_tbl);
++		me->arch.virt_plt_tbl = NULL;
++	}
++
+ 	return 0;
+ }
+ 
+ void module_arch_cleanup(struct module *mod)
+ {
++	if (mod->arch.phys_plt_tbl) {
++		__module_free(mod->arch.phys_plt_tbl);
++		mod->arch.phys_plt_tbl = NULL;
++	}
++	if (mod->arch.virt_plt_tbl) {
++		__module_free(mod->arch.virt_plt_tbl);
++		mod->arch.virt_plt_tbl = NULL;
++	}
++
+ 	spin_lock_irq(&dbe_lock);
+ 	list_del(&mod->arch.dbe_list);
+ 	spin_unlock_irq(&dbe_lock);
diff --git a/target/linux/generic/patches-3.10/306-mips_mem_functions_performance.patch b/target/linux/generic/patches-3.10/306-mips_mem_functions_performance.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/306-mips_mem_functions_performance.patch
@@ -0,0 +1,83 @@
+--- a/arch/mips/include/asm/string.h
++++ b/arch/mips/include/asm/string.h
+@@ -133,11 +133,44 @@ strncmp(__const__ char *__cs, __const__
+ 
+ #define __HAVE_ARCH_MEMSET
+ extern void *memset(void *__s, int __c, size_t __count);
++#define memset(__s, __c, len)					\
++({								\
++	size_t __len = (len);					\
++	void *__ret;						\
++	if (__builtin_constant_p(len) && __len >= 64)		\
++		__ret = memset((__s), (__c), __len);		\
++	else							\
++		__ret = __builtin_memset((__s), (__c), __len);	\
++	__ret;							\
++})
+ 
+ #define __HAVE_ARCH_MEMCPY
+ extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
++#define memcpy(dst, src, len)					\
++({								\
++	size_t __len = (len);					\
++	void *__ret;						\
++	if (__builtin_constant_p(len) && __len >= 64)		\
++		__ret = memcpy((dst), (src), __len);		\
++	else							\
++		__ret = __builtin_memcpy((dst), (src), __len);	\
++	__ret;							\
++})
+ 
+ #define __HAVE_ARCH_MEMMOVE
+ extern void *memmove(void *__dest, __const__ void *__src, size_t __n);
++#define memmove(dst, src, len)					\
++({								\
++	size_t __len = (len);					\
++	void *__ret;						\
++	if (__builtin_constant_p(len) && __len >= 64)		\
++		__ret = memmove((dst), (src), __len);		\
++	else							\
++		__ret = __builtin_memmove((dst), (src), __len);	\
++	__ret;							\
++})
++
++#define __HAVE_ARCH_MEMCMP
++#define memcmp(src1, src2, len) __builtin_memcmp((src1), (src2), (len))
+ 
+ #endif /* _ASM_STRING_H */
+--- a/arch/mips/lib/Makefile
++++ b/arch/mips/lib/Makefile
+@@ -4,7 +4,7 @@
+ 
+ lib-y	+= bitops.o csum_partial.o delay.o memcpy.o memset.o \
+ 	   mips-atomic.o strlen_user.o strncpy_user.o \
+-	   strnlen_user.o uncached.o
++	   strnlen_user.o uncached.o memcmp.o
+ 
+ obj-y			+= iomap.o
+ obj-$(CONFIG_PCI)	+= iomap-pci.o
+--- /dev/null
++++ b/arch/mips/lib/memcmp.c
+@@ -0,0 +1,22 @@
++/*
++ *  copied from linux/lib/string.c
++ *
++ *  Copyright (C) 1991, 1992  Linus Torvalds
++ */
++
++#include <linux/module.h>
++#include <linux/string.h>
++
++#undef memcmp
++int memcmp(const void *cs, const void *ct, size_t count)
++{
++	const unsigned char *su1, *su2;
++	int res = 0;
++
++	for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
++		if ((res = *su1 - *su2) != 0)
++			break;
++	return res;
++}
++EXPORT_SYMBOL(memcmp);
++
diff --git a/target/linux/generic/patches-3.10/309-mips_fuse_workaround.patch b/target/linux/generic/patches-3.10/309-mips_fuse_workaround.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/309-mips_fuse_workaround.patch
@@ -0,0 +1,32 @@
+--- a/arch/mips/mm/cache.c
++++ b/arch/mips/mm/cache.c
+@@ -39,6 +39,7 @@ void (*__flush_kernel_vmap_range)(unsign
+ void (*__invalidate_kernel_vmap_range)(unsigned long vaddr, int size);
+ 
+ EXPORT_SYMBOL_GPL(__flush_kernel_vmap_range);
++EXPORT_SYMBOL(__flush_cache_all);
+ 
+ /* MIPS specific cache operations */
+ void (*flush_cache_sigtramp)(unsigned long addr);
+--- a/fs/fuse/dev.c
++++ b/fs/fuse/dev.c
+@@ -20,6 +20,9 @@
+ #include <linux/swap.h>
+ #include <linux/splice.h>
+ #include <linux/aio.h>
++#ifdef CONFIG_MIPS
++#include <asm/cacheflush.h>
++#endif
+ 
+ MODULE_ALIAS_MISCDEV(FUSE_MINOR);
+ MODULE_ALIAS("devname:fuse");
+@@ -759,6 +762,9 @@ static int fuse_copy_fill(struct fuse_co
+ static int fuse_copy_do(struct fuse_copy_state *cs, void **val, unsigned *size)
+ {
+ 	unsigned ncpy = min(*size, cs->len);
++#ifdef CONFIG_MIPS
++	__flush_cache_all();
++#endif
+ 	if (val) {
+ 		if (cs->write)
+ 			memcpy(cs->buf, *val, ncpy);
diff --git a/target/linux/generic/patches-3.10/310-arm_module_unresolved_weak_sym.patch b/target/linux/generic/patches-3.10/310-arm_module_unresolved_weak_sym.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/310-arm_module_unresolved_weak_sym.patch
@@ -0,0 +1,13 @@
+--- a/arch/arm/kernel/module.c
++++ b/arch/arm/kernel/module.c
+@@ -81,6 +81,10 @@ apply_relocate(Elf32_Shdr *sechdrs, cons
+ 			return -ENOEXEC;
+ 		}
+ 
++		if ((IS_ERR_VALUE(sym->st_value) || !sym->st_value) &&
++		    ELF_ST_BIND(sym->st_info) == STB_WEAK)
++			continue;
++
+ 		loc = dstsec->sh_addr + rel->r_offset;
+ 
+ 		switch (ELF32_R_TYPE(rel->r_info)) {
diff --git a/target/linux/generic/patches-3.10/320-ppc4xx_optimization.patch b/target/linux/generic/patches-3.10/320-ppc4xx_optimization.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/320-ppc4xx_optimization.patch
@@ -0,0 +1,35 @@
+Upstream doesn't optimize the kernel and bootwrappers for ppc44x because
+they still want to support gcc 3.3 -- well, we don't.
+
+Index: kernel_tree/arch/powerpc/Makefile
+===================================================================
+--- kernel_tree.orig/arch/powerpc/Makefile
++++ kernel_tree/arch/powerpc/Makefile
+@@ -139,7 +139,8 @@ ifeq ($(CONFIG_FUNCTION_TRACER),y)
+ KBUILD_CFLAGS		+= -mno-sched-epilog
+ endif
+ 
+-cpu-as-$(CONFIG_4xx)		+= -Wa,-m405
++cpu-as-$(CONFIG_40x)		+= -Wa,-m405
++cpu-as-$(CONFIG_44x)		+= -Wa,-m440
+ cpu-as-$(CONFIG_ALTIVEC)	+= -Wa,-maltivec
+ cpu-as-$(CONFIG_E500)		+= -Wa,-me500
+ cpu-as-$(CONFIG_E200)		+= -Wa,-me200
+Index: kernel_tree/arch/powerpc/boot/Makefile
+===================================================================
+--- kernel_tree.orig/arch/powerpc/boot/Makefile
++++ kernel_tree/arch/powerpc/boot/Makefile
+@@ -38,10 +38,10 @@ BOOTCFLAGS	+= -I$(obj) -I$(srctree)/$(ob
+ DTC_FLAGS	?= -p 1024
+ 
+ $(obj)/4xx.o: BOOTCFLAGS += -mcpu=405
+-$(obj)/ebony.o: BOOTCFLAGS += -mcpu=405
++$(obj)/ebony.o: BOOTCFLAGS += -mcpu=440
+ $(obj)/cuboot-hotfoot.o: BOOTCFLAGS += -mcpu=405
+-$(obj)/cuboot-taishan.o: BOOTCFLAGS += -mcpu=405
+-$(obj)/cuboot-katmai.o: BOOTCFLAGS += -mcpu=405
++$(obj)/cuboot-taishan.o: BOOTCFLAGS += -mcpu=440
++$(obj)/cuboot-katmai.o: BOOTCFLAGS += -mcpu=440
+ $(obj)/cuboot-acadia.o: BOOTCFLAGS += -mcpu=405
+ $(obj)/treeboot-walnut.o: BOOTCFLAGS += -mcpu=405
+ $(obj)/treeboot-iss4xx.o: BOOTCFLAGS += -mcpu=405
diff --git a/target/linux/generic/patches-3.10/321-powerpc_crtsavres_prereq.patch b/target/linux/generic/patches-3.10/321-powerpc_crtsavres_prereq.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/321-powerpc_crtsavres_prereq.patch
@@ -0,0 +1,10 @@
+--- a/arch/powerpc/Makefile
++++ b/arch/powerpc/Makefile
+@@ -104,7 +104,6 @@ CPP		= $(CC) -E $(KBUILD_CFLAGS)
+ 
+ CHECKFLAGS	+= -m$(CONFIG_WORD_SIZE) -D__powerpc__ -D__powerpc$(CONFIG_WORD_SIZE)__
+ 
+-KBUILD_LDFLAGS_MODULE += arch/powerpc/lib/crtsavres.o
+ 
+ # No AltiVec or VSX instructions when building kernel
+ KBUILD_CFLAGS += $(call cc-option,-mno-altivec)
diff --git a/target/linux/generic/patches-3.10/322-ppc4xx-crypto-compile-fix.patch b/target/linux/generic/patches-3.10/322-ppc4xx-crypto-compile-fix.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/322-ppc4xx-crypto-compile-fix.patch
@@ -0,0 +1,10 @@
+--- a/drivers/crypto/amcc/crypto4xx_core.c
++++ b/drivers/crypto/amcc/crypto4xx_core.c
+@@ -19,6 +19,7 @@
+  */
+ 
+ #include <linux/kernel.h>
++#include <linux/module.h>
+ #include <linux/interrupt.h>
+ #include <linux/spinlock_types.h>
+ #include <linux/random.h>
diff --git a/target/linux/generic/patches-3.10/400-mtd-add-rootfs-split-support.patch b/target/linux/generic/patches-3.10/400-mtd-add-rootfs-split-support.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/400-mtd-add-rootfs-split-support.patch
@@ -0,0 +1,299 @@
+Index: kernel_tree/drivers/mtd/Kconfig
+===================================================================
+--- kernel_tree.orig/drivers/mtd/Kconfig
++++ kernel_tree/drivers/mtd/Kconfig
+@@ -12,6 +12,32 @@ menuconfig MTD
+ 
+ if MTD
+ 
++menu "OpenWrt specific MTD options"
++
++config MTD_ROOTFS_ROOT_DEV
++	bool "Automatically set 'rootfs' partition to be root filesystem"
++	default y
++
++config MTD_ROOTFS_SPLIT
++	bool "Automatically split 'rootfs' partition for squashfs"
++	default y
++
++config MTD_SPLIT_FIRMWARE
++	bool "Automatically split firmware partition for kernel+rootfs"
++	default y
++
++config MTD_SPLIT_FIRMWARE_NAME
++	string "Firmware partition name"
++	depends on MTD_SPLIT_FIRMWARE
++	default "firmware"
++
++config MTD_UIMAGE_SPLIT
++	bool "Enable split support for firmware partitions containing a uImage"
++	depends on MTD_SPLIT_FIRMWARE
++	default y
++
++endmenu
++
+ config MTD_TESTS
+ 	tristate "MTD tests support (DANGEROUS)"
+ 	depends on m
+Index: kernel_tree/drivers/mtd/mtdpart.c
+===================================================================
+--- kernel_tree.orig/drivers/mtd/mtdpart.c
++++ kernel_tree/drivers/mtd/mtdpart.c
+@@ -29,6 +29,8 @@
+ #include <linux/kmod.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/partitions.h>
++#include <linux/root_dev.h>
++#include <linux/magic.h>
+ #include <linux/err.h>
+ 
+ #include "mtdcore.h"
+@@ -45,13 +47,14 @@ struct mtd_part {
+ 	struct list_head list;
+ };
+ 
++static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part);
++
+ /*
+  * Given a pointer to the MTD object in the mtd_part structure, we can retrieve
+  * the pointer to that structure with this macro.
+  */
+ #define PART(x)  ((struct mtd_part *)(x))
+ 
+-
+ /*
+  * MTD methods which simply translate the effective address and pass through
+  * to the _real_ device.
+@@ -533,8 +536,10 @@ out_register:
+ 	return slave;
+ }
+ 
+-int mtd_add_partition(struct mtd_info *master, char *name,
+-		      long long offset, long long length)
++
++static int
++__mtd_add_partition(struct mtd_info *master, char *name,
++		    long long offset, long long length, bool dup_check)
+ {
+ 	struct mtd_partition part;
+ 	struct mtd_part *p, *new;
+@@ -566,21 +571,24 @@ int mtd_add_partition(struct mtd_info *m
+ 	end = offset + length;
+ 
+ 	mutex_lock(&mtd_partitions_mutex);
+-	list_for_each_entry(p, &mtd_partitions, list)
+-		if (p->master == master) {
+-			if ((start >= p->offset) &&
+-			    (start < (p->offset + p->mtd.size)))
+-				goto err_inv;
+-
+-			if ((end >= p->offset) &&
+-			    (end < (p->offset + p->mtd.size)))
+-				goto err_inv;
+-		}
++	if (dup_check) {
++		list_for_each_entry(p, &mtd_partitions, list)
++			if (p->master == master) {
++				if ((start >= p->offset) &&
++				    (start < (p->offset + p->mtd.size)))
++					goto err_inv;
++
++				if ((end >= p->offset) &&
++				    (end < (p->offset + p->mtd.size)))
++					goto err_inv;
++			}
++	}
+ 
+ 	list_add(&new->list, &mtd_partitions);
+ 	mutex_unlock(&mtd_partitions_mutex);
+ 
+ 	add_mtd_device(&new->mtd);
++	mtd_partition_split(master, new);
+ 
+ 	return ret;
+ err_inv:
+@@ -590,6 +598,12 @@ err_inv:
+ }
+ EXPORT_SYMBOL_GPL(mtd_add_partition);
+ 
++int mtd_add_partition(struct mtd_info *master, char *name,
++		      long long offset, long long length)
++{
++	return __mtd_add_partition(master, name, offset, length, true);
++}
++
+ int mtd_del_partition(struct mtd_info *master, int partno)
+ {
+ 	struct mtd_part *slave, *next;
+@@ -613,6 +627,151 @@ int mtd_del_partition(struct mtd_info *m
+ }
+ EXPORT_SYMBOL_GPL(mtd_del_partition);
+ 
++static inline unsigned long
++mtd_pad_erasesize(struct mtd_info *mtd, int offset, int len)
++{
++	unsigned long mask = mtd->erasesize - 1;
++
++	len += offset & mask;
++	len = (len + mask) & ~mask;
++	len -= offset & mask;
++	return len;
++}
++
++#define ROOTFS_SPLIT_NAME "rootfs_data"
++
++struct squashfs_super_block {
++	__le32 s_magic;
++	__le32 pad0[9];
++	__le64 bytes_used;
++};
++
++
++static int split_squashfs(struct mtd_info *master, int offset, int *split_offset)
++{
++	struct squashfs_super_block sb;
++	int len, ret;
++
++	ret = mtd_read(master, offset, sizeof(sb), &len, (void *) &sb);
++	if (ret || (len != sizeof(sb))) {
++		printk(KERN_ALERT "split_squashfs: error occured while reading "
++			"from \"%s\"\n", master->name);
++		return -EINVAL;
++	}
++
++	if (SQUASHFS_MAGIC != le32_to_cpu(sb.s_magic) ) {
++		printk(KERN_ALERT "split_squashfs: no squashfs found in \"%s\"\n",
++			master->name);
++		*split_offset = 0;
++		return 0;
++	}
++
++	if (le64_to_cpu((sb.bytes_used)) <= 0) {
++		printk(KERN_ALERT "split_squashfs: squashfs is empty in \"%s\"\n",
++			master->name);
++		*split_offset = 0;
++		return 0;
++	}
++
++	len = (u32) le64_to_cpu(sb.bytes_used);
++	len = mtd_pad_erasesize(master, offset, len);
++	*split_offset = offset + len;
++
++	return 0;
++}
++
++static void split_rootfs_data(struct mtd_info *master, struct mtd_part *part)
++{
++	unsigned int split_offset = 0;
++	unsigned int split_size;
++	int ret;
++
++	ret = split_squashfs(master, part->offset, &split_offset);
++	if (ret)
++		return;
++
++	if (split_offset <= 0)
++		return;
++
++	split_size = part->mtd.size - (split_offset - part->offset);
++	printk(KERN_INFO "mtd: partition \"%s\" created automatically, ofs=0x%x, len=0x%x\n",
++		ROOTFS_SPLIT_NAME, split_offset, split_size);
++
++	__mtd_add_partition(master, ROOTFS_SPLIT_NAME, split_offset,
++			    split_size, false);
++}
++
++#define UBOOT_MAGIC	0x27051956
++
++static void split_uimage(struct mtd_info *master, struct mtd_part *part)
++{
++	struct {
++		__be32 magic;
++		__be32 pad[2];
++		__be32 size;
++	} hdr;
++	size_t len;
++
++	if (mtd_read(master, part->offset, sizeof(hdr), &len, (void *) &hdr))
++		return;
++
++	if (len != sizeof(hdr) || hdr.magic != cpu_to_be32(UBOOT_MAGIC))
++		return;
++
++	len = be32_to_cpu(hdr.size) + 0x40;
++	len = mtd_pad_erasesize(master, part->offset, len);
++	if (len + master->erasesize > part->mtd.size)
++		return;
++
++	__mtd_add_partition(master, "rootfs", part->offset + len,
++			    part->mtd.size - len, false);
++}
++
++#ifdef CONFIG_MTD_SPLIT_FIRMWARE_NAME
++#define SPLIT_FIRMWARE_NAME	CONFIG_MTD_SPLIT_FIRMWARE_NAME
++#else
++#define SPLIT_FIRMWARE_NAME	"unused"
++#endif
++
++static void split_firmware(struct mtd_info *master, struct mtd_part *part)
++{
++	if (config_enabled(CONFIG_MTD_UIMAGE_SPLIT))
++		split_uimage(master, part);
++}
++
++void __weak arch_split_mtd_part(struct mtd_info *master, const char *name,
++                                int offset, int size)
++{
++}
++
++static void mtd_partition_split(struct mtd_info *master, struct mtd_part *part)
++{
++	static int rootfs_found = 0;
++
++	if (rootfs_found)
++		return;
++
++	if (!strcmp(part->mtd.name, "rootfs")) {
++		rootfs_found = 1;
++
++		if (config_enabled(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
++		    ROOT_DEV == 0) {
++			printk(KERN_NOTICE "mtd: partition \"rootfs\" "
++				"set to be root filesystem\n");
++			ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, part->mtd.index);
++		}
++
++		if (config_enabled(CONFIG_MTD_ROOTFS_SPLIT))
++			split_rootfs_data(master, part);
++	}
++
++	if (!strcmp(part->mtd.name, SPLIT_FIRMWARE_NAME) &&
++	    config_enabled(CONFIG_MTD_SPLIT_FIRMWARE))
++		split_firmware(master, part);
++
++	arch_split_mtd_part(master, part->mtd.name, part->offset,
++			    part->mtd.size);
++}
+ /*
+  * This function, given a master MTD object and a partition table, creates
+  * and registers slave MTD objects which are bound to the master according to
+@@ -644,6 +803,7 @@ int add_mtd_partitions(struct mtd_info *
+ 		mutex_unlock(&mtd_partitions_mutex);
+ 
+ 		add_mtd_device(&slave->mtd);
++		mtd_partition_split(master, slave);
+ 
+ 		cur_offset = slave->offset + slave->mtd.size;
+ 	}
+Index: kernel_tree/include/linux/mtd/partitions.h
+===================================================================
+--- kernel_tree.orig/include/linux/mtd/partitions.h
++++ kernel_tree/include/linux/mtd/partitions.h
+@@ -84,5 +84,7 @@ int mtd_add_partition(struct mtd_info *m
+ 		      long long offset, long long length);
+ int mtd_del_partition(struct mtd_info *master, int partno);
+ uint64_t mtd_get_device_size(const struct mtd_info *mtd);
++extern void __weak arch_split_mtd_part(struct mtd_info *master,
++				       const char *name, int offset, int size);
+ 
+ #endif
diff --git a/target/linux/generic/patches-3.10/410-mtd-move-forward-declaration-of-struct-mtd_info.patch b/target/linux/generic/patches-3.10/410-mtd-move-forward-declaration-of-struct-mtd_info.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/410-mtd-move-forward-declaration-of-struct-mtd_info.patch
@@ -0,0 +1,18 @@
+--- a/include/linux/mtd/partitions.h
++++ b/include/linux/mtd/partitions.h
+@@ -35,6 +35,7 @@
+  * Note: writeable partitions require their size and offset be
+  * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
+  */
++struct mtd_info;
+ 
+ struct mtd_partition {
+ 	char *name;			/* identifier string */
+@@ -50,7 +51,6 @@ struct mtd_partition {
+ #define MTDPART_SIZ_FULL	(0)
+ 
+ 
+-struct mtd_info;
+ struct device_node;
+ 
+ /**
diff --git a/target/linux/generic/patches-3.10/411-mtd-partial_eraseblock_write.patch b/target/linux/generic/patches-3.10/411-mtd-partial_eraseblock_write.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/411-mtd-partial_eraseblock_write.patch
@@ -0,0 +1,145 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -35,6 +35,8 @@
+ 
+ #include "mtdcore.h"
+ 
++#define MTD_ERASE_PARTIAL	0x8000 /* partition only covers parts of an erase block */
++
+ /* Our partition linked list */
+ static LIST_HEAD(mtd_partitions);
+ static DEFINE_MUTEX(mtd_partitions_mutex);
+@@ -231,13 +233,60 @@ static int part_erase(struct mtd_info *m
+ 	struct mtd_part *part = PART(mtd);
+ 	int ret;
+ 
++
++	instr->partial_start = false;
++	if (mtd->flags & MTD_ERASE_PARTIAL) {
++		size_t readlen = 0;
++		u64 mtd_ofs;
++
++		instr->erase_buf = kmalloc(part->master->erasesize, GFP_ATOMIC);
++		if (!instr->erase_buf)
++			return -ENOMEM;
++
++		mtd_ofs = part->offset + instr->addr;
++		instr->erase_buf_ofs = do_div(mtd_ofs, part->master->erasesize);
++
++		if (instr->erase_buf_ofs > 0) {
++			instr->addr -= instr->erase_buf_ofs;
++			ret = mtd_read(part->master,
++				instr->addr + part->offset,
++				part->master->erasesize,
++				&readlen, instr->erase_buf);
++
++			instr->partial_start = true;
++		} else {
++			mtd_ofs = part->offset + part->mtd.size;
++			instr->erase_buf_ofs = part->master->erasesize -
++				do_div(mtd_ofs, part->master->erasesize);
++
++			if (instr->erase_buf_ofs > 0) {
++				instr->len += instr->erase_buf_ofs;
++				ret = mtd_read(part->master,
++					part->offset + instr->addr +
++					instr->len - part->master->erasesize,
++					part->master->erasesize, &readlen,
++					instr->erase_buf);
++			} else {
++				ret = 0;
++			}
++		}
++		if (ret < 0) {
++			kfree(instr->erase_buf);
++			return ret;
++		}
++
++	}
++
+ 	instr->addr += part->offset;
+ 	ret = part->master->_erase(part->master, instr);
+ 	if (ret) {
+ 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
+ 			instr->fail_addr -= part->offset;
+ 		instr->addr -= part->offset;
++		if (mtd->flags & MTD_ERASE_PARTIAL)
++			kfree(instr->erase_buf);
+ 	}
++
+ 	return ret;
+ }
+ 
+@@ -245,7 +294,25 @@ void mtd_erase_callback(struct erase_inf
+ {
+ 	if (instr->mtd->_erase == part_erase) {
+ 		struct mtd_part *part = PART(instr->mtd);
++		size_t wrlen = 0;
+ 
++		if (instr->mtd->flags & MTD_ERASE_PARTIAL) {
++			if (instr->partial_start) {
++				part->master->_write(part->master,
++					instr->addr, instr->erase_buf_ofs,
++					&wrlen, instr->erase_buf);
++				instr->addr += instr->erase_buf_ofs;
++			} else {
++				instr->len -= instr->erase_buf_ofs;
++				part->master->_write(part->master,
++					instr->addr + instr->len,
++					instr->erase_buf_ofs, &wrlen,
++					instr->erase_buf +
++					part->master->erasesize -
++					instr->erase_buf_ofs);
++			}
++			kfree(instr->erase_buf);
++		}
+ 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
+ 			instr->fail_addr -= part->offset;
+ 		instr->addr -= part->offset;
+@@ -505,18 +572,24 @@ static struct mtd_part *allocate_partiti
+ 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
+ 	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
+ 		/* Doesn't start on a boundary of major erase size */
+-		/* FIXME: Let it be writable if it is on a boundary of
+-		 * _minor_ erase size though */
+-		slave->mtd.flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
+-			part->name);
++		slave->mtd.flags |= MTD_ERASE_PARTIAL;
++		if (((u32) slave->mtd.size) > master->erasesize)
++			slave->mtd.flags &= ~MTD_WRITEABLE;
++		else
++			slave->mtd.erasesize = slave->mtd.size;
+ 	}
+ 	if ((slave->mtd.flags & MTD_WRITEABLE) &&
+-	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
+-		slave->mtd.flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
+-			part->name);
++	    mtd_mod_by_eb(slave->offset + slave->mtd.size, &slave->mtd)) {
++		slave->mtd.flags |= MTD_ERASE_PARTIAL;
++
++		if ((u32) slave->mtd.size > master->erasesize)
++			slave->mtd.flags &= ~MTD_WRITEABLE;
++		else
++			slave->mtd.erasesize = slave->mtd.size;
+ 	}
++	if ((slave->mtd.flags & (MTD_ERASE_PARTIAL|MTD_WRITEABLE)) == MTD_ERASE_PARTIAL)
++		printk(KERN_WARNING"mtd: partition \"%s\" must either start or end on erase block boundary or be smaller than an erase block -- forcing read-only\n",
++				part->name);
+ 
+ 	slave->mtd.ecclayout = master->ecclayout;
+ 	slave->mtd.ecc_strength = master->ecc_strength;
+--- a/include/linux/mtd/mtd.h
++++ b/include/linux/mtd/mtd.h
+@@ -58,6 +58,10 @@ struct erase_info {
+ 	u_long priv;
+ 	u_char state;
+ 	struct erase_info *next;
++
++	u8 *erase_buf;
++	u32 erase_buf_ofs;
++	bool partial_start;
+ };
+ 
+ struct mtd_erase_region_info {
diff --git a/target/linux/generic/patches-3.10/412-mtd-partial_eraseblock_unlock.patch b/target/linux/generic/patches-3.10/412-mtd-partial_eraseblock_unlock.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/412-mtd-partial_eraseblock_unlock.patch
@@ -0,0 +1,18 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -331,7 +331,14 @@ static int part_lock(struct mtd_info *mt
+ static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+ {
+ 	struct mtd_part *part = PART(mtd);
+-	return part->master->_unlock(part->master, ofs + part->offset, len);
++
++	ofs += part->offset;
++	if (mtd->flags & MTD_ERASE_PARTIAL) {
++		/* round up len to next erasesize and round down offset to prev block */
++		len = (mtd_div_by_eb(len, part->master) + 1) * part->master->erasesize;
++		ofs &= ~(part->master->erasesize - 1);
++	}
++	return part->master->_unlock(part->master, ofs, len);
+ }
+ 
+ static int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
diff --git a/target/linux/generic/patches-3.10/420-mtd-redboot_space.patch b/target/linux/generic/patches-3.10/420-mtd-redboot_space.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/420-mtd-redboot_space.patch
@@ -0,0 +1,30 @@
+--- a/drivers/mtd/redboot.c
++++ b/drivers/mtd/redboot.c
+@@ -265,14 +265,21 @@ static int parse_redboot_partitions(stru
+ #endif
+ 		names += strlen(names)+1;
+ 
+-#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
+ 		if(fl->next && fl->img->flash_base + fl->img->size + master->erasesize <= fl->next->img->flash_base) {
+-			i++;
+-			parts[i].offset = parts[i-1].size + parts[i-1].offset;
+-			parts[i].size = fl->next->img->flash_base - parts[i].offset;
+-			parts[i].name = nullname;
+-		}
++			if (!strcmp(parts[i].name, "rootfs")) {
++				parts[i].size = fl->next->img->flash_base;
++				parts[i].size &= ~(master->erasesize - 1);
++				parts[i].size -= parts[i].offset;
++#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED
++				nrparts--;
++			} else {
++				i++;
++				parts[i].offset = parts[i-1].size + parts[i-1].offset;
++				parts[i].size = fl->next->img->flash_base - parts[i].offset;
++				parts[i].name = nullname;
+ #endif
++			}
++		}
+ 		tmp_fl = fl;
+ 		fl = fl->next;
+ 		kfree(tmp_fl);
diff --git a/target/linux/generic/patches-3.10/430-mtd-add-myloader-partition-parser.patch b/target/linux/generic/patches-3.10/430-mtd-add-myloader-partition-parser.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/430-mtd-add-myloader-partition-parser.patch
@@ -0,0 +1,35 @@
+--- a/drivers/mtd/Kconfig
++++ b/drivers/mtd/Kconfig
+@@ -181,6 +181,22 @@ config MTD_BCM47XX_PARTS
+ 	  This provides partitions parser for devices based on BCM47xx
+ 	  boards.
+ 
++config MTD_MYLOADER_PARTS
++	tristate "MyLoader partition parsing"
++	depends on ADM5120 || ATHEROS_AR231X || ATHEROS_AR71XX || ATH79
++	---help---
++	  MyLoader is a bootloader which allows the user to define partitions
++	  in flash devices, by putting a table in the second erase block
++	  on the device, similar to a partition table. This table gives the 
++	  offsets and lengths of the user defined partitions.
++
++	  If you need code which can detect and parse these tables, and
++	  register MTD 'partitions' corresponding to each image detected,
++	  enable this option.
++
++	  You will still need the parsing functions to be called by the driver
++	  for your particular device. It won't happen automatically.
++
+ comment "User Modules And Translation Layers"
+ 
+ config MTD_BLKDEVS
+--- a/drivers/mtd/Makefile
++++ b/drivers/mtd/Makefile
+@@ -13,6 +13,7 @@ obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
+ obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
+ obj-$(CONFIG_MTD_BCM63XX_PARTS)	+= bcm63xxpart.o
+ obj-$(CONFIG_MTD_BCM47XX_PARTS)	+= bcm47xxpart.o
++obj-$(CONFIG_MTD_MYLOADER_PARTS) += myloader.o
+ 
+ # 'Users' - code which presents functionality to userspace.
+ obj-$(CONFIG_MTD_BLKDEVS)	+= mtd_blkdevs.o
diff --git a/target/linux/generic/patches-3.10/440-block2mtd_init.patch b/target/linux/generic/patches-3.10/440-block2mtd_init.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/440-block2mtd_init.patch
@@ -0,0 +1,116 @@
+--- a/drivers/mtd/devices/block2mtd.c
++++ b/drivers/mtd/devices/block2mtd.c
+@@ -14,6 +14,7 @@
+ #include <linux/list.h>
+ #include <linux/init.h>
+ #include <linux/mtd/mtd.h>
++#include <linux/mtd/partitions.h>
+ #include <linux/mutex.h>
+ #include <linux/mount.h>
+ #include <linux/slab.h>
+@@ -210,11 +211,12 @@ static void block2mtd_free_device(struct
+ 
+ 
+ /* FIXME: ensure that mtd->size % erase_size == 0 */
+-static struct block2mtd_dev *add_device(char *devname, int erase_size)
++static struct block2mtd_dev *add_device(char *devname, int erase_size, const char *mtdname)
+ {
+ 	const fmode_t mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;
+ 	struct block_device *bdev;
+ 	struct block2mtd_dev *dev;
++	struct mtd_partition *part;
+ 	char *name;
+ 
+ 	if (!devname)
+@@ -253,13 +255,16 @@ static struct block2mtd_dev *add_device(
+ 
+ 	/* Setup the MTD structure */
+ 	/* make the name contain the block device in */
+-	name = kasprintf(GFP_KERNEL, "block2mtd: %s", devname);
++	if (!mtdname)
++		mtdname = devname;
++	name = kmalloc(strlen(mtdname) + 1, GFP_KERNEL);
+ 	if (!name)
+ 		goto devinit_err;
+ 
++	strcpy(name, mtdname);
+ 	dev->mtd.name = name;
+ 
+-	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;
++	dev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK & ~(erase_size - 1);
+ 	dev->mtd.erasesize = erase_size;
+ 	dev->mtd.writesize = 1;
+ 	dev->mtd.writebufsize = PAGE_SIZE;
+@@ -272,14 +277,17 @@ static struct block2mtd_dev *add_device(
+ 	dev->mtd.priv = dev;
+ 	dev->mtd.owner = THIS_MODULE;
+ 
+-	if (mtd_device_register(&dev->mtd, NULL, 0)) {
++	part = kzalloc(sizeof(struct mtd_partition), GFP_KERNEL);
++	part->name = name;
++	part->offset = 0;
++	part->size = dev->mtd.size;
++	if (mtd_device_register(&dev->mtd, part, 1)) {
+ 		/* Device didn't get added, so free the entry */
+ 		goto devinit_err;
+ 	}
+ 	list_add(&dev->list, &blkmtd_device_list);
+ 	INFO("mtd%d: [%s] erase_size = %dKiB [%d]", dev->mtd.index,
+-			dev->mtd.name + strlen("block2mtd: "),
+-			dev->mtd.erasesize >> 10, dev->mtd.erasesize);
++			mtdname, dev->mtd.erasesize >> 10, dev->mtd.erasesize);
+ 	return dev;
+ 
+ devinit_err:
+@@ -352,9 +360,9 @@ static char block2mtd_paramline[80 + 12]
+ 
+ static int block2mtd_setup2(const char *val)
+ {
+-	char buf[80 + 12]; /* 80 for device, 12 for erase size */
++	char buf[80 + 12 + 80]; /* 80 for device, 12 for erase size, 80 for name */
+ 	char *str = buf;
+-	char *token[2];
++	char *token[3];
+ 	char *name;
+ 	size_t erase_size = PAGE_SIZE;
+ 	int i, ret;
+@@ -365,7 +373,7 @@ static int block2mtd_setup2(const char *
+ 	strcpy(str, val);
+ 	kill_final_newline(str);
+ 
+-	for (i = 0; i < 2; i++)
++	for (i = 0; i < 3; i++)
+ 		token[i] = strsep(&str, ",");
+ 
+ 	if (str)
+@@ -384,8 +392,10 @@ static int block2mtd_setup2(const char *
+ 			parse_err("illegal erase size");
+ 		}
+ 	}
++	if (token[2] && (strlen(token[2]) + 1 > 80))
++		parse_err("mtd device name too long");
+ 
+-	add_device(name, erase_size);
++	add_device(name, erase_size, token[2]);
+ 
+ 	return 0;
+ }
+@@ -419,7 +429,7 @@ static int block2mtd_setup(const char *v
+ 
+ 
+ module_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);
+-MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>]\"");
++MODULE_PARM_DESC(block2mtd, "Device to use. \"block2mtd=<dev>[,<erasesize>[,<name>]]\"");
+ 
+ static int __init block2mtd_init(void)
+ {
+--- a/block/partition-generic.c
++++ b/block/partition-generic.c
+@@ -548,6 +548,7 @@ int invalidate_partitions(struct gendisk
+ 
+ 	return 0;
+ }
++EXPORT_SYMBOL(rescan_partitions);
+ 
+ unsigned char *read_dev_sector(struct block_device *bdev, sector_t n, Sector *p)
+ {
diff --git a/target/linux/generic/patches-3.10/441-block2mtd_probe.patch b/target/linux/generic/patches-3.10/441-block2mtd_probe.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/441-block2mtd_probe.patch
@@ -0,0 +1,10 @@
+--- a/drivers/mtd/devices/block2mtd.c
++++ b/drivers/mtd/devices/block2mtd.c
+@@ -234,6 +234,7 @@ static struct block2mtd_dev *add_device(
+ 		/* We might not have rootfs mounted at this point. Try
+ 		   to resolve the device name by other means. */
+ 
++		wait_for_device_probe();
+ 		dev_t devt = name_to_dev_t(devname);
+ 		if (devt)
+ 			bdev = blkdev_get_by_dev(devt, mode, dev);
diff --git a/target/linux/generic/patches-3.10/450-mtd-nand-allow-to-use-platform-specific-chip-fixup.patch b/target/linux/generic/patches-3.10/450-mtd-nand-allow-to-use-platform-specific-chip-fixup.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/450-mtd-nand-allow-to-use-platform-specific-chip-fixup.patch
@@ -0,0 +1,37 @@
+---
+ drivers/mtd/nand/plat_nand.c |   13 ++++++++++++-
+ include/linux/mtd/nand.h     |    1 +
+ 2 files changed, 13 insertions(+), 1 deletion(-)
+
+--- a/include/linux/mtd/nand.h
++++ b/include/linux/mtd/nand.h
+@@ -655,6 +655,7 @@ struct platform_nand_chip {
+ 	unsigned int options;
+ 	unsigned int bbt_options;
+ 	const char **part_probe_types;
++	int (*chip_fixup)(struct mtd_info *mtd);
+ };
+ 
+ /* Keep gcc happy */
+--- a/drivers/mtd/nand/plat_nand.c
++++ b/drivers/mtd/nand/plat_nand.c
+@@ -103,7 +103,18 @@ static int plat_nand_probe(struct platfo
+ 	}
+ 
+ 	/* Scan to find existence of the device */
+-	if (nand_scan(&data->mtd, pdata->chip.nr_chips)) {
++	if (nand_scan_ident(&data->mtd, pdata->chip.nr_chips, NULL)) {
++		err = -ENXIO;
++		goto out;
++	}
++
++	if (pdata->chip.chip_fixup) {
++		err = pdata->chip.chip_fixup(&data->mtd);
++		if (err)
++			goto out;
++	}
++
++	if (nand_scan_tail(&data->mtd)) {
+ 		err = -ENXIO;
+ 		goto out;
+ 	}
diff --git a/target/linux/generic/patches-3.10/451-mtd-nand-fix-return-code-of-nand_correct_data-function.patch b/target/linux/generic/patches-3.10/451-mtd-nand-fix-return-code-of-nand_correct_data-function.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/451-mtd-nand-fix-return-code-of-nand_correct_data-function.patch
@@ -0,0 +1,11 @@
+--- a/drivers/mtd/nand/nand_ecc.c
++++ b/drivers/mtd/nand/nand_ecc.c
+@@ -507,7 +507,7 @@ int __nand_correct_data(unsigned char *b
+ 		return 1;	/* error in ECC data; no action needed */
+ 
+ 	pr_err("%s: uncorrectable ECC error", __func__);
+-	return -1;
++	return -EBADMSG;
+ }
+ EXPORT_SYMBOL(__nand_correct_data);
+ 
diff --git a/target/linux/generic/patches-3.10/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch b/target/linux/generic/patches-3.10/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch
@@ -0,0 +1,11 @@
+--- a/drivers/mtd/chips/cfi_cmdset_0002.c
++++ b/drivers/mtd/chips/cfi_cmdset_0002.c
+@@ -780,7 +780,7 @@ static int get_chip(struct map_info *map
+ 		return 0;
+ 
+ 	case FL_ERASING:
+-		if (!cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
++		if (1 /* no suspend */ || !cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||
+ 		    !(mode == FL_READY || mode == FL_POINT ||
+ 		    (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))
+ 			goto sleep;
diff --git a/target/linux/generic/patches-3.10/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch b/target/linux/generic/patches-3.10/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch
@@ -0,0 +1,18 @@
+From: George Kashperko <george@znau.edu.ua>
+
+Issue map read after Write Buffer Load command to ensure chip is ready
+to receive data.
+Signed-off-by: George Kashperko <george@znau.edu.ua>
+---
+ drivers/mtd/chips/cfi_cmdset_0002.c |    1 +
+ 1 file changed, 1 insertion(+)
+--- a/drivers/mtd/chips/cfi_cmdset_0002.c
++++ b/drivers/mtd/chips/cfi_cmdset_0002.c
+@@ -1498,6 +1498,7 @@ static int __xipram do_write_buffer(stru
+ 
+ 	/* Write Buffer Load */
+ 	map_write(map, CMD(0x25), cmd_adr);
++	(void) map_read(map, cmd_adr);
+ 
+ 	chip->state = FL_WRITING_TO_BUFFER;
+ 
diff --git a/target/linux/generic/patches-3.10/470-mtd-m25p80-add-pm25-flash-support.patch b/target/linux/generic/patches-3.10/470-mtd-m25p80-add-pm25-flash-support.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/470-mtd-m25p80-add-pm25-flash-support.patch
@@ -0,0 +1,78 @@
+From dbca80cf6b3c0d0f130cdfb4b1f19f2092f62174 Mon Sep 17 00:00:00 2001
+From: Michel Stempin <michel.stempin@wanadoo.fr>
+Date: Sun, 18 Aug 2013 00:50:26 +0200
+Subject: [PATCH v2] mtd: m25p80: add support for PMC SPI flash
+
+This patch adds support for PMC (now Chingis, part of ISSI) Pm25LV512 (512
+kBbit), Pm25LV010 (1 Mbit) and Pm25LQ032 (32 Mbit) SPI flash.
+
+Two generations of PMC SPI flash chips are addressed:
+
+1) Pm25LV512 and Pm25LV010 - These have 4KB sectors and 32KB blocks. The 4KB
+sector erase uses a non-standard opcode (0xd7). They do not support JEDEC RDID
+(0x9f), and so they can only be detected by matching their name string with
+pre-configured platform data. Because of the cascaded acquisitions, the
+datasheet is no longer available on the current manufacturer's website,
+although it is still commonly used in some recent wireless routers [1]. Only
+public datasheet available seems to be on GeoCities [2].
+
+2) Pm25LQ032 - A newer generation flash, with 4KB sectors and 32KB blocks. It
+uses the standard erase and JEDEC read-ID opcodes. Manufacturer's datasheet is
+available [3].
+
+[1] https://forum.openwrt.org/viewtopic.php?pid=186360#p186360
+[2] http://www.geocities.jp/scottle556/pdf/Pm25LV512-010.pdf
+[3] http://www.chingistek.com/img/Product_Files/Pm25LQ032C%20datasheet%20v1.6.1.pdf
+
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+Signed-off-by: Michel Stempin <michel.stempin@wanadoo.fr>
+CC: Brian Norris <computersforpeace@gmail.com>
+CC: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
+---
+
+Changes in v2:
+ - style and documentation improvements
+
+ drivers/mtd/devices/m25p80.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/mtd/devices/m25p80.c
++++ b/drivers/mtd/devices/m25p80.c
+@@ -45,6 +45,7 @@
+ #define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
+ #define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
+ #define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
++#define	OPCODE_BE_4K_PMC	0xd7	/* Erase 4KiB block on PMC chips*/
+ #define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
+ #define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
+ 
+@@ -682,6 +683,7 @@ struct flash_info {
+ #define	SECT_4K		0x01		/* OPCODE_BE_4K works uniformly */
+ #define	M25P_NO_ERASE	0x02		/* No erase command needed */
+ #define	SST_WRITE	0x04		/* use SST byte programming */
++#define	SECT_4K_PMC	0x08		/* OPCODE_BE_4K_PMC works uniformly */
+ };
+ 
+ #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
+@@ -765,6 +767,11 @@ static const struct spi_device_id m25p_i
+ 	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024, 256, 0) },
+ 	{ "n25q256a", INFO(0x20ba19, 0, 64 * 1024, 512, SECT_4K) },
+ 
++	/* PMC -- pm25x "blocks" are 32K, sectors are 4K */
++	{ "pm25lv512", INFO(0, 0, 32 * 1024, 2, SECT_4K_PMC) },
++	{ "pm25lv010", INFO(0, 0, 32 * 1024, 4, SECT_4K_PMC) },
++	{ "pm25lq032", INFO(0x7F9D46, 0, 64 * 1024,  64, SECT_4K) },
++
+ 	/* Spansion -- single (large) sector size only, at least
+ 	 * for the chips listed here (without boot sectors).
+ 	 */
+@@ -1017,6 +1024,9 @@ static int m25p_probe(struct spi_device
+ 	if (info->flags & SECT_4K) {
+ 		flash->erase_opcode = OPCODE_BE_4K;
+ 		flash->mtd.erasesize = 4096;
++	} else if (info->flags & SECT_4K_PMC) {
++		flash->erase_opcode = OPCODE_BE_4K_PMC;
++		flash->mtd.erasesize = 4096;
+ 	} else {
+ 		flash->erase_opcode = OPCODE_SE;
+ 		flash->mtd.erasesize = info->sector_size;
diff --git a/target/linux/generic/patches-3.10/471-mtd-m25p80-allow-to-disable-small-sector-erase.patch b/target/linux/generic/patches-3.10/471-mtd-m25p80-allow-to-disable-small-sector-erase.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/471-mtd-m25p80-allow-to-disable-small-sector-erase.patch
@@ -0,0 +1,41 @@
+--- a/drivers/mtd/devices/Kconfig
++++ b/drivers/mtd/devices/Kconfig
+@@ -109,6 +109,14 @@ config MTD_SPEAR_SMI
+ 	help
+ 	  This enable SNOR support on SPEAR platforms using SMI controller
+ 
++config M25PXX_PREFER_SMALL_SECTOR_ERASE
++	bool "Prefer small sector erase"
++	depends on MTD_M25P80
++	default y
++	help
++	  This option enables use of the small erase sectors if that is
++	  supported by the flash chip.
++
+ config MTD_SST25L
+ 	tristate "Support SST25L (non JEDEC) SPI Flash chips"
+ 	depends on SPI_MASTER
+--- a/drivers/mtd/devices/m25p80.c
++++ b/drivers/mtd/devices/m25p80.c
+@@ -76,6 +76,12 @@
+ 
+ #define JEDEC_MFR(_jedec_id)	((_jedec_id) >> 16)
+ 
++#ifdef CONFIG_M25PXX_PREFER_SMALL_SECTOR_ERASE
++#define PREFER_SMALL_SECTOR_ERASE 1
++#else
++#define PREFER_SMALL_SECTOR_ERASE 0
++#endif
++
+ /****************************************************************************/
+ 
+ struct m25p {
+@@ -1021,7 +1027,7 @@ static int m25p_probe(struct spi_device
+ 		flash->mtd._write = m25p80_write;
+ 
+ 	/* prefer "small sector" erase if possible */
+-	if (info->flags & SECT_4K) {
++	if (PREFER_SMALL_SECTOR_ERASE && (info->flags & SECT_4K)) {
+ 		flash->erase_opcode = OPCODE_BE_4K;
+ 		flash->mtd.erasesize = 4096;
+ 	} else if (info->flags & SECT_4K_PMC) {
diff --git a/target/linux/generic/patches-3.10/500-yaffs-Kbuild-integration.patch b/target/linux/generic/patches-3.10/500-yaffs-Kbuild-integration.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/500-yaffs-Kbuild-integration.patch
@@ -0,0 +1,18 @@
+--- a/fs/Kconfig
++++ b/fs/Kconfig
+@@ -39,6 +39,7 @@ source "fs/gfs2/Kconfig"
+ source "fs/ocfs2/Kconfig"
+ source "fs/btrfs/Kconfig"
+ source "fs/nilfs2/Kconfig"
++source "fs/yaffs2/Kconfig"
+ 
+ endif # BLOCK
+ 
+--- a/fs/Makefile
++++ b/fs/Makefile
+@@ -127,3 +127,5 @@ obj-y				+= exofs/ # Multiple modules
+ obj-$(CONFIG_CEPH_FS)		+= ceph/
+ obj-$(CONFIG_PSTORE)		+= pstore/
+ obj-$(CONFIG_EFIVAR_FS)		+= efivarfs/
++obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
++
diff --git a/target/linux/generic/patches-3.10/501-yaffs-Fix-directory-unlinking-in-yaffs1-mode.patch b/target/linux/generic/patches-3.10/501-yaffs-Fix-directory-unlinking-in-yaffs1-mode.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/501-yaffs-Fix-directory-unlinking-in-yaffs1-mode.patch
@@ -0,0 +1,31 @@
+From 2505e8b0a13d3d5c5bbeaaae4eb889864f44c9df Mon Sep 17 00:00:00 2001
+From: Charles Manning <cdhmanning@gmail.com>
+Date: Thu, 3 Feb 2011 05:55:30 +1300
+Subject: [PATCH] yaffs: Fix directory unlinking in yaffs1 mode
+
+commit 964b3425a71890e6701c830e38b04d8557c04f49 upstream.
+
+Treat both yaffs2 and yaffs1 paths the same.
+
+Signed-off-by: Charles Manning <cdhmanning@gmail.com>
+---
+ yaffs_guts.c |    8 +-------
+ 1 file changed, 1 insertion(+), 7 deletions(-)
+
+--- a/fs/yaffs2/yaffs_guts.c
++++ b/fs/yaffs2/yaffs_guts.c
+@@ -1708,13 +1708,7 @@ static int yaffs_change_obj_name(yaffs_o
+ 		YBUG();
+ 	}
+ 
+-	/* TODO: Do we need this different handling for YAFFS2 and YAFFS1?? */
+-	if (obj->my_dev->param.is_yaffs2)
+-		unlinkOp = (new_dir == obj->my_dev->unlinked_dir);
+-	else
+-		unlinkOp = (new_dir == obj->my_dev->unlinked_dir
+-			    && obj->variant_type == YAFFS_OBJECT_TYPE_FILE);
+-
++	unlinkOp = (new_dir == obj->my_dev->unlinked_dir);
+ 	deleteOp = (new_dir == obj->my_dev->del_dir);
+ 
+ 	existingTarget = yaffs_find_by_name(new_dir, new_name);
diff --git a/target/linux/generic/patches-3.10/502-yaffs-Switch-from-semaphores-to-mutexes.patch b/target/linux/generic/patches-3.10/502-yaffs-Switch-from-semaphores-to-mutexes.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/502-yaffs-Switch-from-semaphores-to-mutexes.patch
@@ -0,0 +1,138 @@
+From c0c289363e84c53b5872f7c0c5069045096dca07 Mon Sep 17 00:00:00 2001
+From: Charles Manning <cdhmanning@gmail.com>
+Date: Wed, 3 Nov 2010 16:01:12 +1300
+Subject: [PATCH] yaffs: Switch from semaphores to mutexes
+
+commit 73c54aa8c1de3f61a4c211cd47431293a6092f18 upstream.
+
+Mutex is faster and init_MUTEX has been deprecated, so we'll just switch
+to mutexes.
+
+Signed-off-by: Charles Manning <cdhmanning@gmail.com>
+---
+ yaffs_linux.h     |    2 +-
+ yaffs_vfs.c       |   24 ++++++++++++------------
+ yaffs_vfs_multi.c |   26 +++++++++++++-------------
+ 3 files changed, 26 insertions(+), 26 deletions(-)
+
+--- a/fs/yaffs2/yaffs_linux.h
++++ b/fs/yaffs2/yaffs_linux.h
+@@ -25,7 +25,7 @@ struct yaffs_LinuxContext {
+ 	struct super_block * superBlock;
+ 	struct task_struct *bgThread; /* Background thread for this device */
+ 	int bgRunning;
+-        struct semaphore grossLock;     /* Gross locking semaphore */
++	struct mutex grossLock;	/* Gross locking mutex*/
+ 	__u8 *spareBuffer;      /* For mtdif2 use. Don't know the size of the buffer
+ 				 * at compile time so we have to allocate it.
+ 				 */
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -515,14 +515,14 @@ static unsigned yaffs_gc_control_callbac
+ static void yaffs_gross_lock(yaffs_dev_t *dev)
+ {
+ 	T(YAFFS_TRACE_LOCK, (TSTR("yaffs locking %p\n"), current));
+-	down(&(yaffs_dev_to_lc(dev)->grossLock));
++	mutex_lock(&(yaffs_dev_to_lc(dev)->grossLock));
+ 	T(YAFFS_TRACE_LOCK, (TSTR("yaffs locked %p\n"), current));
+ }
+ 
+ static void yaffs_gross_unlock(yaffs_dev_t *dev)
+ {
+ 	T(YAFFS_TRACE_LOCK, (TSTR("yaffs unlocking %p\n"), current));
+-	up(&(yaffs_dev_to_lc(dev)->grossLock));
++	mutex_unlock(&(yaffs_dev_to_lc(dev)->grossLock));
+ }
+ 
+ #ifdef YAFFS_COMPILE_EXPORTFS
+@@ -2542,7 +2542,7 @@ static void yaffs_read_inode(struct inod
+ #endif
+ 
+ static YLIST_HEAD(yaffs_context_list);
+-struct semaphore yaffs_context_lock;
++struct mutex yaffs_context_lock;
+ 
+ static void yaffs_put_super(struct super_block *sb)
+ {
+@@ -2568,9 +2568,9 @@ static void yaffs_put_super(struct super
+ 
+ 	yaffs_gross_unlock(dev);
+ 
+-	down(&yaffs_context_lock);
++	mutex_lock(&yaffs_context_lock);
+ 	ylist_del_init(&(yaffs_dev_to_lc(dev)->contextList));
+-	up(&yaffs_context_lock);
++	mutex_unlock(&yaffs_context_lock);
+ 
+ 	if (yaffs_dev_to_lc(dev)->spareBuffer) {
+ 		YFREE(yaffs_dev_to_lc(dev)->spareBuffer);
+@@ -3016,7 +3016,7 @@ static struct super_block *yaffs_interna
+ 	param->skip_checkpt_rd = options.skip_checkpoint_read;
+ 	param->skip_checkpt_wr = options.skip_checkpoint_write;
+ 
+-	down(&yaffs_context_lock);
++	mutex_lock(&yaffs_context_lock);
+ 	/* Get a mount id */
+ 	found = 0;
+ 	for(mount_id=0; ! found; mount_id++){
+@@ -3030,13 +3030,13 @@ static struct super_block *yaffs_interna
+ 	context->mount_id = mount_id;
+ 
+ 	ylist_add_tail(&(yaffs_dev_to_lc(dev)->contextList), &yaffs_context_list);
+-	up(&yaffs_context_lock);
++	mutex_unlock(&yaffs_context_lock);
+ 
+         /* Directory search handling...*/
+         YINIT_LIST_HEAD(&(yaffs_dev_to_lc(dev)->searchContexts));
+         param->remove_obj_fn = yaffs_remove_obj_callback;
+ 
+-	init_MUTEX(&(yaffs_dev_to_lc(dev)->grossLock));
++	mutex_init(&(yaffs_dev_to_lc(dev)->grossLock));
+ 
+ 	yaffs_gross_lock(dev);
+ 
+@@ -3268,7 +3268,7 @@ static int yaffs_proc_read(char *page,
+ 	else {
+ 		step-=2;
+ 		
+-		down(&yaffs_context_lock);
++		mutex_lock(&yaffs_context_lock);
+ 
+ 		/* Locate and print the Nth entry.  Order N-squared but N is small. */
+ 		ylist_for_each(item, &yaffs_context_list) {
+@@ -3287,7 +3287,7 @@ static int yaffs_proc_read(char *page,
+ 			
+ 			break;
+ 		}
+-		up(&yaffs_context_lock);
++		mutex_unlock(&yaffs_context_lock);
+ 	}
+ 
+ 	return buf - page < count ? buf - page : count;
+@@ -3301,7 +3301,7 @@ static int yaffs_stats_proc_read(char *p
+ 	char *buf = page;
+ 	int n = 0;
+ 
+-	down(&yaffs_context_lock);
++	mutex_lock(&yaffs_context_lock);
+ 
+ 	/* Locate and print the Nth entry.  Order N-squared but N is small. */
+ 	ylist_for_each(item, &yaffs_context_list) {
+@@ -3317,7 +3317,7 @@ static int yaffs_stats_proc_read(char *p
+ 				dev->bg_gcs, dev->oldest_dirty_gc_count,
+ 				dev->n_obj, dev->n_tnodes);
+ 	}
+-	up(&yaffs_context_lock);
++	mutex_unlock(&yaffs_context_lock);
+ 
+ 
+ 	return buf - page < count ? buf - page : count;
+@@ -3494,7 +3494,7 @@ static int __init init_yaffs_fs(void)
+ 
+ 
+ 
+-	init_MUTEX(&yaffs_context_lock);
++	mutex_init(&yaffs_context_lock);
+ 
+ 	/* Install the proc_fs entries */
+ 	my_proc_entry = create_proc_entry("yaffs",
diff --git a/target/linux/generic/patches-3.10/503-yaffs-Replace-yaffs_dir_llseek-with-Linux-generic-ll.patch b/target/linux/generic/patches-3.10/503-yaffs-Replace-yaffs_dir_llseek-with-Linux-generic-ll.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/503-yaffs-Replace-yaffs_dir_llseek-with-Linux-generic-ll.patch
@@ -0,0 +1,72 @@
+From cd6657c4bde20886b0805ea9f2cbac7ec25ac2e5 Mon Sep 17 00:00:00 2001
+From: Charles Manning <cdhmanning@gmail.com>
+Date: Tue, 30 Nov 2010 16:01:28 +1300
+Subject: [PATCH 1/2] yaffs: Replace yaffs_dir_llseek with Linux generic
+ llseek
+
+commit ed8188fb7659cfb65b5adbe154d143190ade0324 upstream.
+
+There was not much point in having the yaffs version as it is
+functionally equivalent to the kernel one.
+
+This also gets rid of using BKL in yaffs2.
+
+Signed-off-by: Charles Manning <cdhmanning@gmail.com>
+---
+ yaffs_vfs.c       |   30 +-----------------------------
+ yaffs_vfs_multi.c |   30 +-----------------------------
+ 2 files changed, 2 insertions(+), 58 deletions(-)
+
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -342,8 +342,6 @@ static int yaffs_follow_link(struct dent
+ 
+ static void yaffs_touch_super(yaffs_dev_t *dev);
+ 
+-static loff_t yaffs_dir_llseek(struct file *file, loff_t offset, int origin);
+-
+ static int yaffs_vfs_setattr(struct inode *, struct iattr *);
+ 
+ 
+@@ -460,7 +458,7 @@ static const struct file_operations yaff
+ 	.read = generic_read_dir,
+ 	.readdir = yaffs_readdir,
+ 	.fsync = yaffs_sync_object,
+-	.llseek = yaffs_dir_llseek,
++	.llseek = generic_file_llseek,
+ };
+ 
+ static const struct super_operations yaffs_super_ops = {
+@@ -1534,32 +1532,6 @@ static void yaffs_release_space(struct f
+ }
+ 
+ 
+-static loff_t yaffs_dir_llseek(struct file *file, loff_t offset, int origin)
+-{
+-	long long retval;
+-
+-	lock_kernel();
+-
+-	switch (origin){
+-	case 2:
+-		offset += i_size_read(file->f_path.dentry->d_inode);
+-		break;
+-	case 1:
+-		offset += file->f_pos;
+-	}
+-	retval = -EINVAL;
+-
+-	if (offset >= 0){
+-		if (offset != file->f_pos)
+-			file->f_pos = offset;
+-
+-		retval = offset;
+-	}
+-	unlock_kernel();
+-	return retval;
+-}
+-
+-
+ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+ {
+ 	yaffs_obj_t *obj;
diff --git a/target/linux/generic/patches-3.10/504-yaffs-Mods-for-Linux-3.0-and-fix-a-typo.patch b/target/linux/generic/patches-3.10/504-yaffs-Mods-for-Linux-3.0-and-fix-a-typo.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/504-yaffs-Mods-for-Linux-3.0-and-fix-a-typo.patch
@@ -0,0 +1,110 @@
+From e1537a700c2e750c5eacc5ad93f30821f1e94424 Mon Sep 17 00:00:00 2001
+From: Charles Manning <cdhmanning@gmail.com>
+Date: Mon, 15 Aug 2011 11:40:30 +1200
+Subject: [PATCH 2/2] Mods for Linux 3.0 and fix a typo
+
+commit a7b5dcf904ba6f7890e4b77ce1f56388b855d0f6 upstream.
+
+Roll in NCB's patch and some other changes for Linux 3.0.
+Also fix a dumb type retired_writes->retried_writes
+
+Signed-off-by: Charles Manning <cdhmanning@gmail.com>
+---
+ patch-ker.sh      |    2 +-
+ yaffs_vfs_glue.c |   42 ++++++++++++++++++++++++++++++++++--------
+ 2 files changed, 35 insertions(+), 9 deletions(-)
+
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -72,7 +72,9 @@
+ #include <linux/init.h>
+ #include <linux/fs.h>
+ #include <linux/proc_fs.h>
++#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39))
+ #include <linux/smp_lock.h>
++#endif
+ #include <linux/pagemap.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/interrupt.h>
+@@ -236,7 +238,9 @@ static int yaffs_file_flush(struct file
+ static int yaffs_file_flush(struct file *file);
+ #endif
+ 
+-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
++static int yaffs_sync_object(struct file *file, loff_t start, loff_t end, int datasync);
++#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+ static int yaffs_sync_object(struct file *file, int datasync);
+ #else
+ static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+@@ -1864,7 +1868,9 @@ static int yaffs_symlink(struct inode *d
+ 	return -ENOMEM;
+ }
+ 
+-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
++static int yaffs_sync_object(struct file *file, loff_t start, loff_t end, int datasync)
++#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+ static int yaffs_sync_object(struct file *file, int datasync)
+ #else
+ static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+@@ -3067,7 +3073,13 @@ static int yaffs_internal_read_super_mtd
+ 	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+ }
+ 
+-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
++static struct dentry *yaffs_mount(struct file_system_type *fs_type, int flags,
++        const char *dev_name, void *data)
++{
++    return mount_bdev(fs_type, flags, dev_name, data, yaffs_internal_read_super_mtd);
++}
++#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ static int yaffs_read_super(struct file_system_type *fs,
+ 			    int flags, const char *dev_name,
+ 			    void *data, struct vfsmount *mnt)
+@@ -3090,8 +3102,12 @@ static struct super_block *yaffs_read_su
+ static struct file_system_type yaffs_fs_type = {
+ 	.owner = THIS_MODULE,
+ 	.name = "yaffs",
+-	.get_sb = yaffs_read_super,
+-	.kill_sb = kill_block_super,
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
++        .mount = yaffs_mount,
++#else
++        .get_sb = yaffs_read_super,
++#endif
++     	.kill_sb = kill_block_super,
+ 	.fs_flags = FS_REQUIRES_DEV,
+ };
+ #else
+@@ -3115,7 +3131,13 @@ static int yaffs2_internal_read_super_mt
+ 	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+ }
+ 
+-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
++static struct dentry *yaffs2_mount(struct file_system_type *fs_type, int flags,
++        const char *dev_name, void *data)
++{
++        return mount_bdev(fs_type, flags, dev_name, data, yaffs2_internal_read_super_mtd);
++}
++#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ static int yaffs2_read_super(struct file_system_type *fs,
+ 			int flags, const char *dev_name, void *data,
+ 			struct vfsmount *mnt)
+@@ -3137,8 +3159,12 @@ static struct super_block *yaffs2_read_s
+ static struct file_system_type yaffs2_fs_type = {
+ 	.owner = THIS_MODULE,
+ 	.name = "yaffs2",
+-	.get_sb = yaffs2_read_super,
+-	.kill_sb = kill_block_super,
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
++        .mount = yaffs2_mount,
++#else
++        .get_sb = yaffs2_read_super,
++#endif
++     	.kill_sb = kill_block_super,
+ 	.fs_flags = FS_REQUIRES_DEV,
+ };
+ #else
diff --git a/target/linux/generic/patches-3.10/505-yaffs-3.2-use-MTD_OPS_AUTO_OOB.patch b/target/linux/generic/patches-3.10/505-yaffs-3.2-use-MTD_OPS_AUTO_OOB.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/505-yaffs-3.2-use-MTD_OPS_AUTO_OOB.patch
@@ -0,0 +1,54 @@
+--- a/fs/yaffs2/yaffs_mtdif1.c
++++ b/fs/yaffs2/yaffs_mtdif1.c
+@@ -127,7 +127,7 @@ int nandmtd1_WriteChunkWithTagsToNAND(ya
+ #endif
+ 
+ 	memset(&ops, 0, sizeof(ops));
+-	ops.mode = MTD_OOB_AUTO;
++	ops.mode = MTD_OPS_AUTO_OOB;
+ 	ops.len = (data) ? chunkBytes : 0;
+ 	ops.ooblen = YTAG1_SIZE;
+ 	ops.datbuf = (__u8 *)data;
+@@ -179,7 +179,7 @@ int nandmtd1_ReadChunkWithTagsFromNAND(y
+ 	int deleted;
+ 
+ 	memset(&ops, 0, sizeof(ops));
+-	ops.mode = MTD_OOB_AUTO;
++	ops.mode = MTD_OPS_AUTO_OOB;
+ 	ops.len = (data) ? chunkBytes : 0;
+ 	ops.ooblen = YTAG1_SIZE;
+ 	ops.datbuf = data;
+--- a/fs/yaffs2/yaffs_mtdif2.c
++++ b/fs/yaffs2/yaffs_mtdif2.c
+@@ -71,7 +71,7 @@ int nandmtd2_WriteChunkWithTagsToNAND(ya
+ 		yaffs_PackTags2(&pt, tags, !dev->param.no_tags_ecc);
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+-	ops.mode = MTD_OOB_AUTO;
++	ops.mode = MTD_OPS_AUTO_OOB;
+ 	ops.ooblen = (dev->param.inband_tags) ? 0 : packed_tags_size;
+ 	ops.len = dev->param.total_bytes_per_chunk;
+ 	ops.ooboffs = 0;
+@@ -136,7 +136,7 @@ int nandmtd2_ReadChunkWithTagsFromNAND(y
+ 		retval = mtd->read(mtd, addr, dev->param.total_bytes_per_chunk,
+ 				&dummy, data);
+ 	else if (tags) {
+-		ops.mode = MTD_OOB_AUTO;
++		ops.mode = MTD_OPS_AUTO_OOB;
+ 		ops.ooblen = packed_tags_size;
+ 		ops.len = data ? dev->data_bytes_per_chunk : packed_tags_size;
+ 		ops.ooboffs = 0;
+--- a/fs/yaffs2/yaffs_mtdif.h
++++ b/fs/yaffs2/yaffs_mtdif.h
+@@ -24,4 +24,11 @@ extern struct nand_oobinfo yaffs_noeccin
+ #endif
+ int nandmtd_EraseBlockInNAND(yaffs_dev_t *dev, int blockNumber);
+ int nandmtd_InitialiseNAND(yaffs_dev_t *dev);
++
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
++#include <mtd/mtd-abi.h>
++#else
++#define MTD_OPS_AUTO_OOB 	MTD_OOB_AUTO
++#endif
++
+ #endif
diff --git a/target/linux/generic/patches-3.10/506-yaffs-3.2-dont-use-i_nlink-directly.patch b/target/linux/generic/patches-3.10/506-yaffs-3.2-dont-use-i_nlink-directly.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/506-yaffs-3.2-dont-use-i_nlink-directly.patch
@@ -0,0 +1,78 @@
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -220,6 +220,29 @@ static struct inode *yaffs_iget(struct s
+ #define yaffs_SuperToDevice(sb)	((yaffs_dev_t *)sb->u.generic_sbp)
+ #endif
+ 
++#if (LINUX_VERSION_CODE > KERNEL_VERSION(3, 2, 0))
++static inline void yaffs_set_nlink(struct inode *inode, unsigned int nlink)
++{
++	set_nlink(inode, nlink);
++}
++
++static inline void yaffs_dec_link_count(struct inode *inode)
++{
++	inode_dec_link_count(inode);
++}
++#else
++static inline void yaffs_set_nlink(struct inode *inode, unsigned int nlink)
++{
++	inode->i_nlink = nlink;
++}
++
++static inline void yaffs_dec_link_count(struct inode *inode)
++{
++	inode->i_nlink--;
++	mark_inode_dirty(inode)
++}
++#endif
++
+ 
+ #define update_dir_time(dir) do {\
+ 			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+@@ -1362,7 +1385,7 @@ static void yaffs_fill_inode_from_obj(st
+ 		inode->i_size = yaffs_get_obj_length(obj);
+ 		inode->i_blocks = (inode->i_size + 511) >> 9;
+ 
+-		inode->i_nlink = yaffs_get_obj_link_count(obj);
++		yaffs_set_nlink(inode, yaffs_get_obj_link_count(obj));
+ 
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_fill_inode mode %x uid %d gid %d size %d count %d\n"),
+@@ -1784,10 +1807,9 @@ static int yaffs_unlink(struct inode *di
+ 	retVal = yaffs_unlinker(obj, dentry->d_name.name);
+ 
+ 	if (retVal == YAFFS_OK) {
+-		dentry->d_inode->i_nlink--;
++		yaffs_dec_link_count(dentry->d_inode);
+ 		dir->i_version++;
+ 		yaffs_gross_unlock(dev);
+-		mark_inode_dirty(dentry->d_inode);
+ 		update_dir_time(dir);
+ 		return 0;
+ 	}
+@@ -1818,7 +1840,8 @@ static int yaffs_link(struct dentry *old
+ 			obj);
+ 
+ 	if (link) {
+-		old_dentry->d_inode->i_nlink = yaffs_get_obj_link_count(obj);
++		yaffs_set_nlink(old_dentry->d_inode,
++				yaffs_get_obj_link_count(obj));
+ 		d_instantiate(dentry, old_dentry->d_inode);
+ 		atomic_inc(&old_dentry->d_inode->i_count);
+ 		T(YAFFS_TRACE_OS,
+@@ -1937,11 +1960,9 @@ static int yaffs_rename(struct inode *ol
+ 	yaffs_gross_unlock(dev);
+ 
+ 	if (retVal == YAFFS_OK) {
+-		if (target) {
+-			new_dentry->d_inode->i_nlink--;
+-			mark_inode_dirty(new_dentry->d_inode);
+-		}
+-		
++		if (target)
++			yaffs_dec_link_count(new_dentry->d_inode);
++
+ 		update_dir_time(old_dir);
+ 		if(old_dir != new_dir)
+ 			update_dir_time(new_dir);
diff --git a/target/linux/generic/patches-3.10/507-yaffs-3.3_fix.patch b/target/linux/generic/patches-3.10/507-yaffs-3.3_fix.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/507-yaffs-3.3_fix.patch
@@ -0,0 +1,71 @@
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -273,8 +273,13 @@ static int yaffs_sync_object(struct file
+ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
++static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
++			struct nameidata *n);
++#else
+ static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+ 			struct nameidata *n);
++#endif
+ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+ 					struct nameidata *n);
+ #else
+@@ -286,9 +291,17 @@ static int yaffs_link(struct dentry *old
+ static int yaffs_unlink(struct inode *dir, struct dentry *dentry);
+ static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+ 			const char *symname);
++
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
++static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode);
++#else
+ static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
++#endif
+ 
+-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
++static int yaffs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,
++			dev_t dev);
++#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+ 			dev_t dev);
+ #else
+@@ -1679,7 +1692,10 @@ out:
+ #define YCRED(x) (x->cred)
+ #endif
+ 
+-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
++static int yaffs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,
++			dev_t rdev)
++#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+ 			dev_t rdev)
+ #else
+@@ -1769,7 +1785,11 @@ static int yaffs_mknod(struct inode *dir
+ 	return error;
+ }
+ 
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
++static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
++#else
+ static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
++#endif
+ {
+ 	int retVal;
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_mkdir\n")));
+@@ -1777,7 +1797,10 @@ static int yaffs_mkdir(struct inode *dir
+ 	return retVal;
+ }
+ 
+-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
++static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
++			struct nameidata *n)
++#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+ 			struct nameidata *n)
+ #else
diff --git a/target/linux/generic/patches-3.10/508-yaffs-3.3-use-mtd_-helpers.patch b/target/linux/generic/patches-3.10/508-yaffs-3.3-use-mtd_-helpers.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/508-yaffs-3.3-use-mtd_-helpers.patch
@@ -0,0 +1,160 @@
+--- a/fs/yaffs2/yaffs_mtdif1.c
++++ b/fs/yaffs2/yaffs_mtdif1.c
+@@ -133,7 +133,7 @@ int nandmtd1_WriteChunkWithTagsToNAND(ya
+ 	ops.datbuf = (__u8 *)data;
+ 	ops.oobbuf = (__u8 *)&pt1;
+ 
+-	retval = mtd->write_oob(mtd, addr, &ops);
++	retval = mtd_write_oob(mtd, addr, &ops);
+ 	if (retval) {
+ 		T(YAFFS_TRACE_MTD,
+ 			(TSTR("write_oob failed, chunk %d, mtd error %d"TENDSTR),
+@@ -194,7 +194,7 @@ int nandmtd1_ReadChunkWithTagsFromNAND(y
+ 	/* Read page and oob using MTD.
+ 	 * Check status and determine ECC result.
+ 	 */
+-	retval = mtd->read_oob(mtd, addr, &ops);
++	retval = mtd_read_oob(mtd, addr, &ops);
+ 	if (retval) {
+ 		T(YAFFS_TRACE_MTD,
+ 			(TSTR("read_oob failed, chunk %d, mtd error %d"TENDSTR),
+@@ -218,7 +218,7 @@ int nandmtd1_ReadChunkWithTagsFromNAND(y
+ 		/* fall into... */
+ 	default:
+ 		rettags(etags, YAFFS_ECC_RESULT_UNFIXED, 0);
+-		etags->block_bad = (mtd->block_isbad)(mtd, addr);
++		etags->block_bad = mtd_block_isbad(mtd, addr);
+ 		return YAFFS_FAIL;
+ 	}
+ 
+@@ -286,7 +286,7 @@ int nandmtd1_MarkNANDBlockBad(struct yaf
+ 
+ 	T(YAFFS_TRACE_BAD_BLOCKS,(TSTR("marking block %d bad"TENDSTR), block_no));
+ 
+-	retval = mtd->block_markbad(mtd, (loff_t)blocksize * block_no);
++	retval = mtd_block_markbad(mtd, (loff_t)blocksize * block_no);
+ 	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+ }
+ 
+@@ -336,7 +336,7 @@ int nandmtd1_QueryNANDBlock(struct yaffs
+ 		return YAFFS_FAIL;
+ 
+ 	retval = nandmtd1_ReadChunkWithTagsFromNAND(dev, chunkNo, NULL, &etags);
+-	etags.block_bad = (mtd->block_isbad)(mtd, addr);
++	etags.block_bad = mtd_block_isbad(mtd, addr);
+ 	if (etags.block_bad) {
+ 		T(YAFFS_TRACE_BAD_BLOCKS,
+ 			(TSTR("block %d is marked bad"TENDSTR), block_no));
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -2607,8 +2607,8 @@ static void yaffs_MTDPutSuper(struct sup
+ {
+ 	struct mtd_info *mtd = yaffs_dev_to_mtd(yaffs_SuperToDevice(sb));
+ 
+-	if (mtd->sync)
+-		mtd->sync(mtd);
++	if (mtd)
++		mtd_sync(mtd);
+ 
+ 	put_mtd_device(mtd);
+ }
+--- a/fs/yaffs2/yaffs_mtdif2.c
++++ b/fs/yaffs2/yaffs_mtdif2.c
+@@ -77,7 +77,7 @@ int nandmtd2_WriteChunkWithTagsToNAND(ya
+ 	ops.ooboffs = 0;
+ 	ops.datbuf = (__u8 *)data;
+ 	ops.oobbuf = (dev->param.inband_tags) ? NULL : packed_tags_ptr;
+-	retval = mtd->write_oob(mtd, addr, &ops);
++	retval = mtd_write_oob(mtd, addr, &ops);
+ 
+ #else
+ 	if (!dev->param.inband_tags) {
+@@ -133,7 +133,7 @@ int nandmtd2_ReadChunkWithTagsFromNAND(y
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+ 	if (dev->param.inband_tags || (data && !tags))
+-		retval = mtd->read(mtd, addr, dev->param.total_bytes_per_chunk,
++		retval = mtd_read(mtd, addr, dev->param.total_bytes_per_chunk,
+ 				&dummy, data);
+ 	else if (tags) {
+ 		ops.mode = MTD_OPS_AUTO_OOB;
+@@ -142,7 +142,7 @@ int nandmtd2_ReadChunkWithTagsFromNAND(y
+ 		ops.ooboffs = 0;
+ 		ops.datbuf = data;
+ 		ops.oobbuf = yaffs_dev_to_lc(dev)->spareBuffer;
+-		retval = mtd->read_oob(mtd, addr, &ops);
++		retval = mtd_read_oob(mtd, addr, &ops);
+ 	}
+ #else
+ 	if (!dev->param.inband_tags && data && tags) {
+@@ -201,7 +201,7 @@ int nandmtd2_MarkNANDBlockBad(struct yaf
+ 	  (TSTR("nandmtd2_MarkNANDBlockBad %d" TENDSTR), block_no));
+ 
+ 	retval =
+-	    mtd->block_markbad(mtd,
++	    mtd_block_markbad(mtd,
+ 			       block_no * dev->param.chunks_per_block *
+ 			       dev->param.total_bytes_per_chunk);
+ 
+@@ -221,7 +221,7 @@ int nandmtd2_QueryNANDBlock(struct yaffs
+ 	T(YAFFS_TRACE_MTD,
+ 	  (TSTR("nandmtd2_QueryNANDBlock %d" TENDSTR), block_no));
+ 	retval =
+-	    mtd->block_isbad(mtd,
++	    mtd_block_isbad(mtd,
+ 			     block_no * dev->param.chunks_per_block *
+ 			     dev->param.total_bytes_per_chunk);
+ 
+--- a/fs/yaffs2/yaffs_mtdif.h
++++ b/fs/yaffs2/yaffs_mtdif.h
+@@ -31,4 +31,39 @@ int nandmtd_InitialiseNAND(yaffs_dev_t *
+ #define MTD_OPS_AUTO_OOB 	MTD_OOB_AUTO
+ #endif
+ 
++#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0))
++static inline int mtd_erase(struct mdt_info *mtd, struct erase_info *ei)
++{
++	return mtd->erase(mtd, ei);
++}
++
++static inline int mtd_block_markbad(struct mtd_info *mtd, loff_t ofs)
++{
++	return mtd->block_mark_bad(mtd, ofs);
++}
++
++static inline int mtd_block_isbad(struct mtd_info *mtd, loff_t ofs)
++{
++	return mtd->block_is_bad(mtd, ofs);
++}
++
++static inline int mtd_read_oob(struct mtd_info *mtd, loff_t from,
++			       struct mtd_oob_ops *ops)
++{
++	return mtd->read_oob(mtd, from, ops);
++}
++
++static inline int mtd_write_oob(struct mtd_info *mtd, loff_t to,
++				struct mtd_oob_ops *ops)
++{
++	return mtd->write_oob(mtd, to, ops);
++}
++
++static inline void mtd_sync(struct mtd_info *mtd)
++{
++	if (mtd->sync)
++		mtd->sync(mtd);
++}
++#endif
++
+ #endif
+--- a/fs/yaffs2/yaffs_mtdif.c
++++ b/fs/yaffs2/yaffs_mtdif.c
+@@ -41,7 +41,7 @@ int nandmtd_EraseBlockInNAND(yaffs_dev_t
+ 	ei.callback = NULL;
+ 	ei.priv = (u_long) dev;
+ 
+-	retval = mtd->erase(mtd, &ei);
++	retval = mtd_erase(mtd, &ei);
+ 
+ 	if (retval == 0)
+ 		return YAFFS_OK;
diff --git a/target/linux/generic/patches-3.10/509-yaffs-3.4-add-underscore-to-mtd-internal-names.patch b/target/linux/generic/patches-3.10/509-yaffs-3.4-add-underscore-to-mtd-internal-names.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/509-yaffs-3.4-add-underscore-to-mtd-internal-names.patch
@@ -0,0 +1,72 @@
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -2793,6 +2793,15 @@ static struct super_block *yaffs_interna
+ 		return NULL;
+ 	}
+ 
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
++	T(YAFFS_TRACE_OS, (TSTR(" erase %p\n"), mtd->_erase));
++	T(YAFFS_TRACE_OS, (TSTR(" read %p\n"), mtd->_read));
++	T(YAFFS_TRACE_OS, (TSTR(" write %p\n"), mtd->_write));
++	T(YAFFS_TRACE_OS, (TSTR(" readoob %p\n"), mtd->_read_oob));
++	T(YAFFS_TRACE_OS, (TSTR(" writeoob %p\n"), mtd->_write_oob));
++	T(YAFFS_TRACE_OS, (TSTR(" block_isbad %p\n"), mtd->_block_isbad));
++	T(YAFFS_TRACE_OS, (TSTR(" block_markbad %p\n"), mtd->_block_markbad));
++#else
+ 	T(YAFFS_TRACE_OS, (TSTR(" erase %p\n"), mtd->erase));
+ 	T(YAFFS_TRACE_OS, (TSTR(" read %p\n"), mtd->read));
+ 	T(YAFFS_TRACE_OS, (TSTR(" write %p\n"), mtd->write));
+@@ -2800,6 +2809,7 @@ static struct super_block *yaffs_interna
+ 	T(YAFFS_TRACE_OS, (TSTR(" writeoob %p\n"), mtd->write_oob));
+ 	T(YAFFS_TRACE_OS, (TSTR(" block_isbad %p\n"), mtd->block_isbad));
+ 	T(YAFFS_TRACE_OS, (TSTR(" block_markbad %p\n"), mtd->block_markbad));
++#endif
+ 	T(YAFFS_TRACE_OS, (TSTR(" %s %d\n"), WRITE_SIZE_STR, WRITE_SIZE(mtd)));
+ 	T(YAFFS_TRACE_OS, (TSTR(" oobsize %d\n"), mtd->oobsize));
+ 	T(YAFFS_TRACE_OS, (TSTR(" erasesize %d\n"), mtd->erasesize));
+@@ -2828,6 +2838,15 @@ static struct super_block *yaffs_interna
+ 
+ 	if (yaffs_version == 2) {
+ 		/* Check for version 2 style functions */
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
++		if (!mtd->_erase ||
++		    !mtd->_block_isbad ||
++		    !mtd->_block_markbad ||
++		    !mtd->_read ||
++		    !mtd->_write ||
++		    !mtd->_read_oob ||
++		    !mtd->_write_oob) {
++#else
+ 		if (!mtd->erase ||
+ 		    !mtd->block_isbad ||
+ 		    !mtd->block_markbad ||
+@@ -2839,6 +2858,7 @@ static struct super_block *yaffs_interna
+ 		    !mtd->write_ecc ||
+ 		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+ #endif
++#endif
+ 			T(YAFFS_TRACE_ALWAYS,
+ 			  (TSTR("yaffs: MTD device does not support required "
+ 			   "functions\n")));
+@@ -2855,6 +2875,13 @@ static struct super_block *yaffs_interna
+ 		}
+ 	} else {
+ 		/* Check for V1 style functions */
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
++		if (!mtd->_erase ||
++		    !mtd->_read ||
++		    !mtd->_write ||
++		    !mtd->_read_oob ||
++		    !mtd->_write_oob) {
++#else
+ 		if (!mtd->erase ||
+ 		    !mtd->read ||
+ 		    !mtd->write ||
+@@ -2864,6 +2891,7 @@ static struct super_block *yaffs_interna
+ 		    !mtd->write_ecc ||
+ 		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+ #endif
++#endif
+ 			T(YAFFS_TRACE_ALWAYS,
+ 			  (TSTR("yaffs: MTD device does not support required "
+ 			   "functions\n")));
diff --git a/target/linux/generic/patches-3.10/510-yaffs-3.4-use-d_make_root.patch b/target/linux/generic/patches-3.10/510-yaffs-3.4-use-d_make_root.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/510-yaffs-3.4-use-d_make_root.patch
@@ -0,0 +1,14 @@
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -3119,7 +3119,11 @@ static struct super_block *yaffs_interna
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_read_super: got root inode\n")));
+ 
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
++	root = d_make_root(inode);
++#else
+ 	root = d_alloc_root(inode);
++#endif
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_read_super: d_alloc_root done\n")));
+ 
diff --git a/target/linux/generic/patches-3.10/511-yaffs-3.5-use-clear_inode.patch b/target/linux/generic/patches-3.10/511-yaffs-3.5-use-clear_inode.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/511-yaffs-3.5-use-clear_inode.patch
@@ -0,0 +1,15 @@
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -924,7 +924,11 @@ static void yaffs_evict_inode( struct in
+ 	if (!inode->i_nlink && !is_bad_inode(inode))
+ 		deleteme = 1;
+ 	truncate_inode_pages(&inode->i_data,0);
+-	end_writeback(inode);
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
++	clear_inode(inode);
++#else
++ 	end_writeback(inode);
++#endif
+ 
+ 	if(deleteme && obj){
+ 		dev = obj->my_dev;
diff --git a/target/linux/generic/patches-3.10/512-yaffs-3.5-convert-to-use-kuid_t-kgid_t.patch b/target/linux/generic/patches-3.10/512-yaffs-3.5-convert-to-use-kuid_t-kgid_t.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/512-yaffs-3.5-convert-to-use-kuid_t-kgid_t.patch
@@ -0,0 +1,570 @@
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -243,11 +243,10 @@ static inline void yaffs_dec_link_count(
+ }
+ #endif
+ 
+-
+ #define update_dir_time(dir) do {\
+ 			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+ 		} while(0)
+-		
++
+ static void yaffs_put_super(struct super_block *sb);
+ 
+ static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+@@ -397,6 +396,33 @@ static struct address_space_operations y
+ #endif
+ };
+ 
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0))
++#define YCRED_FSUID()	from_kuid(&init_user_ns, current_fsuid())
++#define YCRED_FSGID()	from_kgid(&init_user_ns, current_fsgid())
++#else
++#define YCRED_FSUID()	YCRED(current)->fsuid
++#define YCRED_FSGID()	YCRED(current)->fsgid
++
++static inline uid_t i_uid_read(const struct inode *inode)
++{
++	return inode->i_uid;
++}
++
++static inline gid_t i_gid_read(const struct inode *inode)
++{
++	return inode->i_gid;
++}
++
++static inline void i_uid_write(struct inode *inode, uid_t uid)
++{
++	inode->i_uid = uid;
++}
++
++static inline void i_gid_write(struct inode *inode, gid_t gid)
++{
++	inode->i_gid = gid;
++}
++#endif
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+ static const struct file_operations yaffs_file_operations = {
+@@ -549,7 +575,7 @@ static unsigned yaffs_gc_control_callbac
+ {
+ 	return yaffs_gc_control;
+ }
+-                	                                                                                          	
++
+ static void yaffs_gross_lock(yaffs_dev_t *dev)
+ {
+ 	T(YAFFS_TRACE_LOCK, (TSTR("yaffs locking %p\n"), current));
+@@ -1379,8 +1405,8 @@ static void yaffs_fill_inode_from_obj(st
+ 
+ 		inode->i_ino = obj->obj_id;
+ 		inode->i_mode = obj->yst_mode;
+-		inode->i_uid = obj->yst_uid;
+-		inode->i_gid = obj->yst_gid;
++		i_uid_write(inode, obj->yst_uid);
++		i_gid_write(inode, obj->yst_gid);
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+ 		inode->i_blksize = inode->i_sb->s_blocksize;
+ #endif
+@@ -1406,7 +1432,7 @@ static void yaffs_fill_inode_from_obj(st
+ 
+ 		T(YAFFS_TRACE_OS,
+ 			(TSTR("yaffs_fill_inode mode %x uid %d gid %d size %d count %d\n"),
+-			inode->i_mode, inode->i_uid, inode->i_gid,
++			inode->i_mode, i_uid_read(inode), i_gid_read(inode),
+ 			(int)inode->i_size, atomic_read(&inode->i_count)));
+ 
+ 		switch (obj->yst_mode & S_IFMT) {
+@@ -1715,8 +1741,8 @@ static int yaffs_mknod(struct inode *dir
+ 	yaffs_obj_t *parent = yaffs_InodeToObject(dir);
+ 
+ 	int error = -ENOSPC;
+-	uid_t uid = YCRED(current)->fsuid;
+-	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
++	uid_t uid = YCRED_FSUID();
++	gid_t gid = (dir->i_mode & S_ISGID) ? i_gid_read(dir) : YCRED_FSGID();
+ 
+ 	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+ 		mode |= S_ISGID;
+@@ -1892,8 +1918,8 @@ static int yaffs_symlink(struct inode *d
+ {
+ 	yaffs_obj_t *obj;
+ 	yaffs_dev_t *dev;
+-	uid_t uid = YCRED(current)->fsuid;
+-	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
++	uid_t uid = YCRED_FSUID();
++	gid_t gid = (dir->i_mode & S_ISGID) ? i_gid_read(dir) : YCRED_FSGID();
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_symlink\n")));
+ 
+@@ -2009,7 +2035,7 @@ static int yaffs_setattr(struct dentry *
+ 		(TSTR("yaffs_setattr of object %d\n"),
+ 		yaffs_InodeToObject(inode)->obj_id));
+ 
+-	/* Fail if a requested resize >= 2GB */		
++	/* Fail if a requested resize >= 2GB */
+ 	if (attr->ia_valid & ATTR_SIZE &&
+ 		(attr->ia_size >> 31))
+ 		error = -EINVAL;
+@@ -2240,7 +2266,7 @@ static void yaffs_flush_inodes(struct su
+ {
+ 	struct inode *iptr;
+ 	yaffs_obj_t *obj;
+-	
++
+ 	list_for_each_entry(iptr,&sb->s_inodes, i_sb_list){
+ 		obj = yaffs_InodeToObject(iptr);
+ 		if(obj){
+@@ -2254,10 +2280,10 @@ static void yaffs_flush_inodes(struct su
+ 
+ static void yaffs_flush_super(struct super_block *sb, int do_checkpoint)
+ {
+-	yaffs_dev_t *dev = yaffs_SuperToDevice(sb);	
++	yaffs_dev_t *dev = yaffs_SuperToDevice(sb);
+ 	if(!dev)
+ 		return;
+-	
++
+ 	yaffs_flush_inodes(sb);
+ 	yaffs_update_dirty_dirs(dev);
+ 	yaffs_flush_whole_cache(dev);
+@@ -2325,7 +2351,7 @@ static int yaffs_do_sync_fs(struct super
+  * yaffs_bg_start() launches the background thread.
+  * yaffs_bg_stop() cleans up the background thread.
+  *
+- * NB: 
++ * NB:
+  * The thread should only run after the yaffs is initialised
+  * The thread should be stopped before yaffs is unmounted.
+  * The thread should not do any writing while the fs is in read only.
+@@ -2924,7 +2950,7 @@ static struct super_block *yaffs_interna
+ 
+ 	dev = kmalloc(sizeof(yaffs_dev_t), GFP_KERNEL);
+ 	context = kmalloc(sizeof(struct yaffs_LinuxContext),GFP_KERNEL);
+-	
++
+ 	if(!dev || !context ){
+ 		if(dev)
+ 			kfree(dev);
+@@ -2957,7 +2983,7 @@ static struct super_block *yaffs_interna
+ #else
+ 	sb->u.generic_sbp = dev;
+ #endif
+-	
++
+ 	dev->driver_context = mtd;
+ 	param->name = mtd->name;
+ 
+@@ -3057,7 +3083,7 @@ static struct super_block *yaffs_interna
+ 	param->gc_control = yaffs_gc_control_callback;
+ 
+ 	yaffs_dev_to_lc(dev)->superBlock= sb;
+-	
++
+ 
+ #ifndef CONFIG_YAFFS_DOES_ECC
+ 	param->use_nand_ecc = 1;
+@@ -3099,10 +3125,10 @@ static struct super_block *yaffs_interna
+ 	T(YAFFS_TRACE_OS,
+ 	  (TSTR("yaffs_read_super: guts initialised %s\n"),
+ 	   (err == YAFFS_OK) ? "OK" : "FAILED"));
+-	   
++
+ 	if(err == YAFFS_OK)
+ 		yaffs_bg_start(dev);
+-		
++
+ 	if(!context->bgThread)
+ 		param->defered_dir_update = 0;
+ 
+@@ -3345,7 +3371,7 @@ static int yaffs_proc_read(char *page,
+ 		buf += sprintf(buf,"\n");
+ 	else {
+ 		step-=2;
+-		
++
+ 		mutex_lock(&yaffs_context_lock);
+ 
+ 		/* Locate and print the Nth entry.  Order N-squared but N is small. */
+@@ -3362,7 +3388,7 @@ static int yaffs_proc_read(char *page,
+ 				buf = yaffs_dump_dev_part0(buf, dev);
+ 			} else
+ 				buf = yaffs_dump_dev_part1(buf, dev);
+-			
++
+ 			break;
+ 		}
+ 		mutex_unlock(&yaffs_context_lock);
+@@ -3389,7 +3415,7 @@ static int yaffs_stats_proc_read(char *p
+ 		int erasedChunks;
+ 
+ 		erasedChunks = dev->n_erased_blocks * dev->param.chunks_per_block;
+-		
++
+ 		buf += sprintf(buf,"%d, %d, %d, %u, %u, %u, %u\n",
+ 				n, dev->n_free_chunks, erasedChunks,
+ 				dev->bg_gcs, dev->oldest_dirty_gc_count,
+--- a/fs/yaffs2/yaffs_guts.c
++++ b/fs/yaffs2/yaffs_guts.c
+@@ -370,7 +370,7 @@ static int yaffs_verify_chunk_written(ya
+ 	yaffs_ext_tags tempTags;
+ 	__u8 *buffer = yaffs_get_temp_buffer(dev,__LINE__);
+ 	int result;
+-	
++
+ 	result = yaffs_rd_chunk_tags_nand(dev,nand_chunk,buffer,&tempTags);
+ 	if(memcmp(buffer,data,dev->data_bytes_per_chunk) ||
+ 		tempTags.obj_id != tags->obj_id ||
+@@ -424,7 +424,7 @@ static int yaffs_write_new_chunk(struct
+ 		 * lot of checks that are most likely not needed.
+ 		 *
+ 		 * Mods to the above
+-		 * If an erase check fails or the write fails we skip the 
++		 * If an erase check fails or the write fails we skip the
+ 		 * rest of the block.
+ 		 */
+ 
+@@ -486,7 +486,7 @@ static int yaffs_write_new_chunk(struct
+ }
+ 
+ 
+- 
++
+ /*
+  * Block retiring for handling a broken block.
+  */
+@@ -496,7 +496,7 @@ static void yaffs_retire_block(yaffs_dev
+ 	yaffs_block_info_t *bi = yaffs_get_block_info(dev, flash_block);
+ 
+ 	yaffs2_checkpt_invalidate(dev);
+-	
++
+ 	yaffs2_clear_oldest_dirty_seq(dev,bi);
+ 
+ 	if (yaffs_mark_bad(dev, flash_block) != YAFFS_OK) {
+@@ -899,7 +899,7 @@ static int yaffs_find_chunk_in_group(yaf
+ 	for (j = 0; theChunk && j < dev->chunk_grp_size; j++) {
+ 		if (yaffs_check_chunk_bit(dev, theChunk / dev->param.chunks_per_block,
+ 				theChunk % dev->param.chunks_per_block)) {
+-			
++
+ 			if(dev->chunk_grp_size == 1)
+ 				return theChunk;
+ 			else {
+@@ -1802,7 +1802,7 @@ int yaffs_rename_obj(yaffs_obj_t *old_di
+ 		yaffs_update_parent(old_dir);
+ 		if(new_dir != old_dir)
+ 			yaffs_update_parent(new_dir);
+-		
++
+ 		return result;
+ 	}
+ 	return YAFFS_FAIL;
+@@ -2125,7 +2125,7 @@ static int yaffs_gc_block(yaffs_dev_t *d
+ 
+ 	if(bi->block_state == YAFFS_BLOCK_STATE_FULL)
+ 		bi->block_state = YAFFS_BLOCK_STATE_COLLECTING;
+-	
++
+ 	bi->has_shrink_hdr = 0;	/* clear the flag so that the block can erase */
+ 
+ 	dev->gc_disable = 1;
+@@ -2207,7 +2207,7 @@ static int yaffs_gc_block(yaffs_dev_t *d
+ 					 * No need to copy this, just forget about it and
+ 					 * fix up the object.
+ 					 */
+-					 
++
+ 					/* Free chunks already includes softdeleted chunks.
+ 					 * How ever this chunk is going to soon be really deleted
+ 					 * which will increment free chunks.
+@@ -2752,7 +2752,7 @@ int yaffs_put_chunk_in_file(yaffs_obj_t
+ 					NULL);
+ 	if (!tn)
+ 		return YAFFS_FAIL;
+-	
++
+ 	if(!nand_chunk)
+ 		/* Dummy insert, bail now */
+ 		return YAFFS_OK;
+@@ -2881,7 +2881,7 @@ void yaffs_chunk_del(yaffs_dev_t *dev, i
+ 			 chunk_id));
+ 
+ 	bi = yaffs_get_block_info(dev, block);
+-	
++
+ 	yaffs2_update_oldest_dirty_seq(dev, block, bi);
+ 
+ 	T(YAFFS_TRACE_DELETION,
+@@ -2966,8 +2966,8 @@ static int yaffs_wr_data_obj(yaffs_obj_t
+ 		(TSTR("Writing %d bytes to chunk!!!!!!!!!" TENDSTR), n_bytes));
+ 		YBUG();
+ 	}
+-	
+-		
++
++
+ 	newChunkId =
+ 	    yaffs_write_new_chunk(dev, buffer, &newTags,
+ 					      useReserve);
+@@ -3795,14 +3795,14 @@ int yaffs_resize_file(yaffs_obj_t *in, l
+ 
+ 	if (new_size == oldFileSize)
+ 		return YAFFS_OK;
+-		
++
+ 	if(new_size > oldFileSize){
+ 		yaffs2_handle_hole(in,new_size);
+ 		in->variant.file_variant.file_size = new_size;
+ 	} else {
+-		/* new_size < oldFileSize */ 
++		/* new_size < oldFileSize */
+ 		yaffs_resize_file_down(in, new_size);
+-	} 
++	}
+ 
+ 	/* Write a new object header to reflect the resize.
+ 	 * show we've shrunk the file, if need be
+@@ -4231,7 +4231,7 @@ static void yaffs_strip_deleted_objs(yaf
+  * This fixes the problem where directories might have inadvertently been deleted
+  * leaving the object "hanging" without being rooted in the directory tree.
+  */
+- 
++
+ static int yaffs_has_null_parent(yaffs_dev_t *dev, yaffs_obj_t *obj)
+ {
+ 	return (obj == dev->del_dir ||
+@@ -4262,7 +4262,7 @@ static void yaffs_fix_hanging_objs(yaffs
+ 			if (lh) {
+ 				obj = ylist_entry(lh, yaffs_obj_t, hash_link);
+ 				parent= obj->parent;
+-				
++
+ 				if(yaffs_has_null_parent(dev,obj)){
+ 					/* These directories are not hanging */
+ 					hanging = 0;
+@@ -4311,7 +4311,7 @@ static void yaffs_del_dir_contents(yaffs
+ 
+ 	if(dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+ 		YBUG();
+-	
++
+ 	ylist_for_each_safe(lh, n, &dir->variant.dir_variant.children) {
+ 		if (lh) {
+ 			obj = ylist_entry(lh, yaffs_obj_t, siblings);
+@@ -4325,10 +4325,10 @@ static void yaffs_del_dir_contents(yaffs
+ 			/* Need to use UnlinkObject since Delete would not handle
+ 			 * hardlinked objects correctly.
+ 			 */
+-			yaffs_unlink_obj(obj); 
++			yaffs_unlink_obj(obj);
+ 		}
+ 	}
+-			
++
+ }
+ 
+ static void yaffs_empty_l_n_f(yaffs_dev_t *dev)
+@@ -4410,7 +4410,7 @@ static void yaffs_check_obj_details_load
+  * If the directory updating is defered then yaffs_update_dirty_dirs must be
+  * called periodically.
+  */
+- 
++
+ static void yaffs_update_parent(yaffs_obj_t *obj)
+ {
+ 	yaffs_dev_t *dev;
+@@ -4422,8 +4422,8 @@ static void yaffs_update_parent(yaffs_ob
+ 	obj->dirty = 1;
+ 	obj->yst_mtime = obj->yst_ctime = Y_CURRENT_TIME;
+ 	if(dev->param.defered_dir_update){
+-		struct ylist_head *link = &obj->variant.dir_variant.dirty; 
+-	
++		struct ylist_head *link = &obj->variant.dir_variant.dirty;
++
+ 		if(ylist_empty(link)){
+ 			ylist_add(link,&dev->dirty_dirs);
+ 			T(YAFFS_TRACE_BACKGROUND, (TSTR("Added object %d to dirty directories" TENDSTR),obj->obj_id));
+@@ -4446,7 +4446,7 @@ void yaffs_update_dirty_dirs(yaffs_dev_t
+ 	while(!ylist_empty(&dev->dirty_dirs)){
+ 		link = dev->dirty_dirs.next;
+ 		ylist_del_init(link);
+-		
++
+ 		dS=ylist_entry(link,yaffs_dir_s,dirty);
+ 		oV = ylist_entry(dS,yaffs_obj_variant,dir_variant);
+ 		obj = ylist_entry(oV,yaffs_obj_t,variant);
+@@ -4474,7 +4474,7 @@ static void yaffs_remove_obj_from_dir(ya
+ 
+ 	ylist_del_init(&obj->siblings);
+ 	obj->parent = NULL;
+-	
++
+ 	yaffs_verify_dir(parent);
+ }
+ 
+@@ -4645,7 +4645,7 @@ yaffs_obj_t *yaffs_get_equivalent_obj(ya
+  * system to share files.
+  *
+  * These automatic unicode are stored slightly differently...
+- *  - If the name can fit in the ASCII character space then they are saved as 
++ *  - If the name can fit in the ASCII character space then they are saved as
+  *    ascii names as per above.
+  *  - If the name needs Unicode then the name is saved in Unicode
+  *    starting at oh->name[1].
+@@ -4686,7 +4686,7 @@ static void yaffs_load_name_from_oh(yaff
+ 				asciiOhName++;
+ 				n--;
+ 			}
+-		} else 
++		} else
+ 			yaffs_strncpy(name,ohName+1, bufferSize -1);
+ 	} else
+ #endif
+@@ -4705,7 +4705,7 @@ static void yaffs_load_oh_from_name(yaff
+ 
+ 		isAscii = 1;
+ 		w = name;
+-	
++
+ 		/* Figure out if the name will fit in ascii character set */
+ 		while(isAscii && *w){
+ 			if((*w) & 0xff00)
+@@ -4729,7 +4729,7 @@ static void yaffs_load_oh_from_name(yaff
+ 			yaffs_strncpy(ohName+1,name, YAFFS_MAX_NAME_LENGTH -2);
+ 		}
+ 	}
+-	else 
++	else
+ #endif
+ 		yaffs_strncpy(ohName,name, YAFFS_MAX_NAME_LENGTH - 1);
+ 
+@@ -4738,12 +4738,12 @@ static void yaffs_load_oh_from_name(yaff
+ int yaffs_get_obj_name(yaffs_obj_t * obj, YCHAR * name, int buffer_size)
+ {
+ 	memset(name, 0, buffer_size * sizeof(YCHAR));
+-	
++
+ 	yaffs_check_obj_details_loaded(obj);
+ 
+ 	if (obj->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
+ 		yaffs_strncpy(name, YAFFS_LOSTNFOUND_NAME, buffer_size - 1);
+-	} 
++	}
+ #ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+ 	else if (obj->short_name[0]) {
+ 		yaffs_strcpy(name, obj->short_name);
+@@ -4861,9 +4861,9 @@ int yaffs_set_attribs(yaffs_obj_t *obj,
+ 	if (valid & ATTR_MODE)
+ 		obj->yst_mode = attr->ia_mode;
+ 	if (valid & ATTR_UID)
+-		obj->yst_uid = attr->ia_uid;
++		obj->yst_uid = ia_uid_read(attr);
+ 	if (valid & ATTR_GID)
+-		obj->yst_gid = attr->ia_gid;
++		obj->yst_gid = ia_gid_read(attr);
+ 
+ 	if (valid & ATTR_ATIME)
+ 		obj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);
+@@ -4886,9 +4886,9 @@ int yaffs_get_attribs(yaffs_obj_t *obj,
+ 
+ 	attr->ia_mode = obj->yst_mode;
+ 	valid |= ATTR_MODE;
+-	attr->ia_uid = obj->yst_uid;
++	ia_uid_write(attr, obj->yst_uid);
+ 	valid |= ATTR_UID;
+-	attr->ia_gid = obj->yst_gid;
++	ia_gid_write(attr, obj->yst_gid);
+ 	valid |= ATTR_GID;
+ 
+ 	Y_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;
+--- a/fs/yaffs2/yportenv.h
++++ b/fs/yaffs2/yportenv.h
+@@ -170,7 +170,7 @@
+ #define O_RDWR		02
+ #endif
+ 
+-#ifndef O_CREAT		
++#ifndef O_CREAT
+ #define O_CREAT 	0100
+ #endif
+ 
+@@ -218,7 +218,7 @@
+ #define EACCES	13
+ #endif
+ 
+-#ifndef EXDEV	
++#ifndef EXDEV
+ #define EXDEV	18
+ #endif
+ 
+@@ -281,7 +281,7 @@
+ #define S_IFREG		0100000
+ #endif
+ 
+-#ifndef S_IREAD 
++#ifndef S_IREAD
+ #define S_IREAD		0000400
+ #endif
+ 
+--- a/fs/yaffs2/devextras.h
++++ b/fs/yaffs2/devextras.h
+@@ -87,6 +87,8 @@ struct iattr {
+ 	unsigned int ia_attr_flags;
+ };
+ 
++/* TODO: add ia_* functions */
++
+ #endif
+ 
+ #else
+@@ -95,7 +97,48 @@ struct iattr {
+ #include <linux/fs.h>
+ #include <linux/stat.h>
+ 
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0))
++static inline uid_t ia_uid_read(const struct iattr *iattr)
++{
++	return from_kuid(&init_user_ns, iattr->ia_uid);
++}
++
++static inline gid_t ia_gid_read(const struct iattr *iattr)
++{
++	return from_kgid(&init_user_ns, iattr->ia_gid);
++}
++
++static inline void ia_uid_write(struct iattr *iattr, uid_t uid)
++{
++	iattr->ia_uid = make_kuid(&init_user_ns, uid);
++}
++
++static inline void ia_gid_write(struct iattr *iattr, gid_t gid)
++{
++	iattr->ia_gid = make_kgid(&init_user_ns, gid);
++}
++#else
++static inline uid_t ia_uid_read(const struct iattr *iattr)
++{
++	return iattr->ia_uid;
++}
++
++static inline gid_t ia_gid_read(const struct iattr *inode)
++{
++	return iattr->ia_gid;
++}
++
++static inline void ia_uid_write(struct iattr *iattr, uid_t uid)
++{
++	iattr->ia_uid = uid;
++}
++
++static inline void ia_gid_write(struct iattr *iattr, gid_t gid)
++{
++	iattr->ia_gid = gid;
++}
+ #endif
+ 
++#endif
+ 
+ #endif
diff --git a/target/linux/generic/patches-3.10/513-yaffs-3.6-fix-dir_inode-ops.patch b/target/linux/generic/patches-3.10/513-yaffs-3.6-fix-dir_inode-ops.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/513-yaffs-3.6-fix-dir_inode-ops.patch
@@ -0,0 +1,60 @@
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -271,20 +271,29 @@ static int yaffs_sync_object(struct file
+ 
+ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);
+ 
+-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
++static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
++			bool excl);
++#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
+ static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+ 			struct nameidata *n);
+-#else
++#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+ 			struct nameidata *n);
++#else
++static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);
+ #endif
++
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
++static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
++					unsigned int flags);
++#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+ 					struct nameidata *n);
+ #else
+-static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);
+ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry);
+ #endif
++
+ static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+ 			struct dentry *dentry);
+ static int yaffs_unlink(struct inode *dir, struct dentry *dentry);
+@@ -837,7 +846,10 @@ struct inode *yaffs_get_inode(struct sup
+ /*
+  * Lookup is used to find objects in the fs
+  */
+-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
++static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
++				   unsigned int flags)
++#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+ 
+ static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+ 				struct nameidata *n)
+@@ -1827,7 +1839,10 @@ static int yaffs_mkdir(struct inode *dir
+ 	return retVal;
+ }
+ 
+-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
++static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
++			bool excl)
++#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
+ static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+ 			struct nameidata *n)
+ #elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
diff --git a/target/linux/generic/patches-3.10/514-yaffs-3.6-use-delayed-work-instead-of-write_super.patch b/target/linux/generic/patches-3.10/514-yaffs-3.6-use-delayed-work-instead-of-write_super.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/514-yaffs-3.6-use-delayed-work-instead-of-write_super.patch
@@ -0,0 +1,180 @@
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -393,6 +393,84 @@ static void yaffs_touch_super(yaffs_dev_
+ static int yaffs_vfs_setattr(struct inode *, struct iattr *);
+ 
+ 
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
++
++#define yaffs_super_to_dev(sb)    ((struct yaffs_dev_s *)sb->s_fs_info)
++
++static inline struct yaffs_LinuxContext *
++yaffs_sb_to_ylc(struct super_block *sb)
++{
++	struct yaffs_dev_s *ydev;
++	struct yaffs_LinuxContext *ylc;
++
++	ydev = yaffs_super_to_dev(sb);
++	ylc = yaffs_dev_to_lc(ydev);
++	return ylc;
++}
++
++static inline struct super_block *yaffs_work_to_sb(struct work_struct *work)
++{
++	struct delayed_work *dwork;
++	struct yaffs_LinuxContext *ylc;
++
++	dwork = container_of(work, struct delayed_work, work);
++	ylc = container_of(dwork, struct yaffs_LinuxContext, sb_sync_dwork);
++	return ylc->superBlock;
++}
++
++static void yaffs_sb_sync_dwork_func(struct work_struct *work)
++{
++	struct super_block *sb = yaffs_work_to_sb(work);
++
++	yaffs_write_super(sb);
++}
++
++static void yaffs_init_sb_sync_dwork(struct yaffs_LinuxContext *ylc)
++{
++	INIT_DELAYED_WORK(&ylc->sb_sync_dwork, yaffs_sb_sync_dwork_func);
++}
++
++static void yaffs_cancel_sb_sync_dwork(struct super_block *sb)
++{
++	struct yaffs_LinuxContext *ylc = yaffs_sb_to_ylc(sb);
++
++	cancel_delayed_work_sync(&ylc->sb_sync_dwork);
++}
++
++static inline bool yaffs_sb_is_dirty(struct super_block *sb)
++{
++	struct yaffs_LinuxContext *ylc = yaffs_sb_to_ylc(sb);
++
++	return !!ylc->sb_dirty;
++}
++
++static inline void yaffs_sb_set_dirty(struct super_block *sb, int dirty)
++{
++	struct yaffs_LinuxContext *ylc = yaffs_sb_to_ylc(sb);
++
++	if (ylc->sb_dirty == dirty)
++		return;
++
++	ylc->sb_dirty = dirty;
++	if (dirty)
++		queue_delayed_work(system_long_wq, &ylc->sb_sync_dwork,
++				   msecs_to_jiffies(5000));
++}
++#else
++static inline bool yaffs_sb_is_dirty(struct super_block *sb)
++{
++	return !!sb->s_dirt;
++}
++
++static inline void yaffs_sb_set_dirty(struct super_block *sb, int dirty)
++{
++	sb->s_dirt = dirty;
++}
++
++static inline void yaffs_init_sb_sync_dwork(struct yaffs_LinuxContext *ylc) {}
++static inline void yaffs_cancel_sb_sync_dwork(struct super_block *sb) {}
++#endif /* >= 3.6.0 */
++
+ static struct address_space_operations yaffs_file_address_operations = {
+ 	.readpage = yaffs_readpage,
+ 	.writepage = yaffs_writepage,
+@@ -553,7 +631,9 @@ static const struct super_operations yaf
+ 	.clear_inode = yaffs_clear_inode,
+ #endif
+ 	.sync_fs = yaffs_sync_fs,
++#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+ 	.write_super = yaffs_write_super,
++#endif
+ };
+ 
+ 
+@@ -2340,7 +2420,7 @@ static int yaffs_do_sync_fs(struct super
+ 	T(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+ 		(TSTR("yaffs_do_sync_fs: gc-urgency %d %s %s%s\n"),
+ 		gc_urgent,
+-		sb->s_dirt ? "dirty" : "clean",
++		yaffs_sb_is_dirty(sb) ? "dirty" : "clean",
+ 		request_checkpoint ? "checkpoint requested" : "no checkpoint",
+ 		oneshot_checkpoint ? " one-shot" : "" ));
+ 
+@@ -2349,9 +2429,9 @@ static int yaffs_do_sync_fs(struct super
+ 			oneshot_checkpoint) &&
+ 			!dev->is_checkpointed;
+ 
+-	if (sb->s_dirt || do_checkpoint) {
++	if (yaffs_sb_is_dirty(sb) || do_checkpoint) {
+ 		yaffs_flush_super(sb, !dev->is_checkpointed && do_checkpoint);
+-		sb->s_dirt = 0;
++		yaffs_sb_set_dirty(sb, 0);
+ 		if(oneshot_checkpoint)
+ 			yaffs_auto_checkpoint &= ~4;
+ 	}
+@@ -2627,6 +2707,8 @@ static void yaffs_put_super(struct super
+ 
+ 	yaffs_flush_super(sb,1);
+ 
++	yaffs_cancel_sb_sync_dwork(sb);
++
+ 	if (yaffs_dev_to_lc(dev)->putSuperFunc)
+ 		yaffs_dev_to_lc(dev)->putSuperFunc(sb);
+ 
+@@ -2665,7 +2747,7 @@ static void yaffs_touch_super(yaffs_dev_
+ 
+ 	T(YAFFS_TRACE_OS, (TSTR("yaffs_touch_super() sb = %p\n"), sb));
+ 	if (sb)
+-		sb->s_dirt = 1;
++		yaffs_sb_set_dirty(sb, 1);
+ }
+ 
+ typedef struct {
+@@ -2991,6 +3073,8 @@ static struct super_block *yaffs_interna
+ 	context->dev = dev;
+ 	context->superBlock = sb;
+ 
++	yaffs_init_sb_sync_dwork(context);
++
+ 	dev->read_only = read_only;
+ 
+ #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+@@ -3177,7 +3261,7 @@ static struct super_block *yaffs_interna
+ 		return NULL;
+ 	}
+ 	sb->s_root = root;
+-	sb->s_dirt = !dev->is_checkpointed;
++	yaffs_sb_set_dirty(sb, !dev->is_checkpointed);
+ 	T(YAFFS_TRACE_ALWAYS,
+ 		(TSTR("yaffs_read_super: is_checkpointed %d\n"),
+ 		dev->is_checkpointed));
+--- a/fs/yaffs2/yaffs_linux.h
++++ b/fs/yaffs2/yaffs_linux.h
+@@ -34,6 +34,11 @@ struct yaffs_LinuxContext {
+ 
+ 	struct task_struct *readdirProcess;
+ 	unsigned mount_id;
++
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
++	struct delayed_work sb_sync_dwork;	/* superblock write-out work */
++	int sb_dirty;				/* superblock is dirty */
++#endif
+ };
+ 
+ #define yaffs_dev_to_lc(dev) ((struct yaffs_LinuxContext *)((dev)->os_context))
+--- a/fs/yaffs2/yportenv.h
++++ b/fs/yaffs2/yportenv.h
+@@ -49,6 +49,9 @@
+ #include <linux/slab.h>
+ #include <linux/vmalloc.h>
+ #include <linux/xattr.h>
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
++#include <linux/workqueue.h>
++#endif
+ 
+ #define YCHAR char
+ #define YUCHAR unsigned char
diff --git a/target/linux/generic/patches-3.10/515-yaffs-3.10-disable-proc-entry.patch b/target/linux/generic/patches-3.10/515-yaffs-3.10-disable-proc-entry.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/515-yaffs-3.10-disable-proc-entry.patch
@@ -0,0 +1,45 @@
+--- a/fs/yaffs2/yaffs_vfs_glue.c
++++ b/fs/yaffs2/yaffs_vfs_glue.c
+@@ -3385,6 +3385,7 @@ static DECLARE_FSTYPE(yaffs2_fs_type, "y
+ 
+ #endif				/* CONFIG_YAFFS_YAFFS2 */
+ 
++#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
+ static struct proc_dir_entry *my_proc_entry;
+ static struct proc_dir_entry *debug_proc_entry;
+ 
+@@ -3668,6 +3669,7 @@ static int yaffs_proc_write(struct file
+ {
+         return yaffs_proc_write_trace_options(file, buf, count, data);
+ }
++#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0)) */
+ 
+ /* Stuff to handle installation of file systems */
+ struct file_system_to_install {
+@@ -3699,6 +3701,7 @@ static int __init init_yaffs_fs(void)
+ 
+ 	mutex_init(&yaffs_context_lock);
+ 
++#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
+ 	/* Install the proc_fs entries */
+ 	my_proc_entry = create_proc_entry("yaffs",
+ 					       S_IRUGO | S_IFREG,
+@@ -3721,6 +3724,7 @@ static int __init init_yaffs_fs(void)
+ 		debug_proc_entry->data = NULL;
+ 	} else
+ 		return -ENOMEM;
++#endif
+ 
+ 	/* Now add the file system entries */
+ 
+@@ -3757,8 +3761,10 @@ static void __exit exit_yaffs_fs(void)
+ 	T(YAFFS_TRACE_ALWAYS,
+ 		(TSTR("yaffs built " __DATE__ " " __TIME__ " removing. \n")));
+ 
++#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
+ 	remove_proc_entry("yaffs", YPROC_ROOT);
+ 	remove_proc_entry("yaffs_stats", YPROC_ROOT);
++#endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0)) */
+ 
+ 	fsinst = fs_to_install;
+ 
diff --git a/target/linux/generic/patches-3.10/520-squashfs_update_xz_comp_opts.patch b/target/linux/generic/patches-3.10/520-squashfs_update_xz_comp_opts.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/520-squashfs_update_xz_comp_opts.patch
@@ -0,0 +1,25 @@
+From f31b7c0efa255dd17a5f584022a319387f09b0d8 Mon Sep 17 00:00:00 2001
+From: Jonas Gorski <jonas.gorski@gmail.com>
+Date: Tue, 12 Apr 2011 19:55:41 +0200
+Subject: [PATCH] squashfs: update xz compressor options struct.
+
+Update the xz compressor options struct to match the squashfs userspace
+one.
+---
+ fs/squashfs/xz_wrapper.c |    4 +++-
+ 1 files changed, 3 insertions(+), 1 deletions(-)
+
+--- a/fs/squashfs/xz_wrapper.c
++++ b/fs/squashfs/xz_wrapper.c
+@@ -39,8 +39,10 @@ struct squashfs_xz {
+ };
+ 
+ struct comp_opts {
+-	__le32 dictionary_size;
+ 	__le32 flags;
++	__le16 bit_opts;
++	__le16 fb;
++	__le32 dictionary_size;
+ };
+ 
+ static void *squashfs_xz_init(struct squashfs_sb_info *msblk, void *buff,
diff --git a/target/linux/generic/patches-3.10/530-jffs2_make_lzma_available.patch b/target/linux/generic/patches-3.10/530-jffs2_make_lzma_available.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/530-jffs2_make_lzma_available.patch
@@ -0,0 +1,5180 @@
+Index: kernel_tree/fs/jffs2/Kconfig
+===================================================================
+--- kernel_tree.orig/fs/jffs2/Kconfig
++++ kernel_tree/fs/jffs2/Kconfig
+@@ -139,6 +139,15 @@ config JFFS2_LZO
+ 	  This feature was added in July, 2007. Say 'N' if you need
+ 	  compatibility with older bootloaders or kernels.
+ 
++config JFFS2_LZMA
++	bool "JFFS2 LZMA compression support" if JFFS2_COMPRESSION_OPTIONS
++	select LZMA_COMPRESS
++	select LZMA_DECOMPRESS
++	depends on JFFS2_FS
++	default n
++	help
++	  JFFS2 wrapper to the LZMA C SDK
++
+ config JFFS2_RTIME
+ 	bool "JFFS2 RTIME compression support" if JFFS2_COMPRESSION_OPTIONS
+ 	depends on JFFS2_FS
+Index: kernel_tree/fs/jffs2/Makefile
+===================================================================
+--- kernel_tree.orig/fs/jffs2/Makefile
++++ kernel_tree/fs/jffs2/Makefile
+@@ -18,4 +18,7 @@ jffs2-$(CONFIG_JFFS2_RUBIN)	+= compr_rub
+ jffs2-$(CONFIG_JFFS2_RTIME)	+= compr_rtime.o
+ jffs2-$(CONFIG_JFFS2_ZLIB)	+= compr_zlib.o
+ jffs2-$(CONFIG_JFFS2_LZO)	+= compr_lzo.o
++jffs2-$(CONFIG_JFFS2_LZMA)      += compr_lzma.o
+ jffs2-$(CONFIG_JFFS2_SUMMARY)   += summary.o
++
++CFLAGS_compr_lzma.o += -Iinclude/linux -Ilib/lzma
+Index: kernel_tree/fs/jffs2/compr.c
+===================================================================
+--- kernel_tree.orig/fs/jffs2/compr.c
++++ kernel_tree/fs/jffs2/compr.c
+@@ -378,6 +378,9 @@ int __init jffs2_compressors_init(void)
+ #ifdef CONFIG_JFFS2_LZO
+ 	jffs2_lzo_init();
+ #endif
++#ifdef CONFIG_JFFS2_LZMA
++        jffs2_lzma_init();
++#endif
+ /* Setting default compression mode */
+ #ifdef CONFIG_JFFS2_CMODE_NONE
+ 	jffs2_compression_mode = JFFS2_COMPR_MODE_NONE;
+@@ -401,6 +404,9 @@ int __init jffs2_compressors_init(void)
+ int jffs2_compressors_exit(void)
+ {
+ /* Unregistering compressors */
++#ifdef CONFIG_JFFS2_LZMA
++        jffs2_lzma_exit();
++#endif
+ #ifdef CONFIG_JFFS2_LZO
+ 	jffs2_lzo_exit();
+ #endif
+Index: kernel_tree/fs/jffs2/compr.h
+===================================================================
+--- kernel_tree.orig/fs/jffs2/compr.h
++++ kernel_tree/fs/jffs2/compr.h
+@@ -29,9 +29,9 @@
+ #define JFFS2_DYNRUBIN_PRIORITY  20
+ #define JFFS2_LZARI_PRIORITY     30
+ #define JFFS2_RTIME_PRIORITY     50
+-#define JFFS2_ZLIB_PRIORITY      60
+-#define JFFS2_LZO_PRIORITY       80
+-
++#define JFFS2_LZMA_PRIORITY      70
++#define JFFS2_ZLIB_PRIORITY      80
++#define JFFS2_LZO_PRIORITY       90
+ 
+ #define JFFS2_RUBINMIPS_DISABLED /* RUBINs will be used only */
+ #define JFFS2_DYNRUBIN_DISABLED  /*	   for decompression */
+@@ -101,5 +101,9 @@ void jffs2_zlib_exit(void);
+ int jffs2_lzo_init(void);
+ void jffs2_lzo_exit(void);
+ #endif
++#ifdef CONFIG_JFFS2_LZMA
++int jffs2_lzma_init(void);
++void jffs2_lzma_exit(void);
++#endif
+ 
+ #endif /* __JFFS2_COMPR_H__ */
+Index: kernel_tree/fs/jffs2/compr_lzma.c
+===================================================================
+--- /dev/null
++++ kernel_tree/fs/jffs2/compr_lzma.c
+@@ -0,0 +1,128 @@
++/*
++ * JFFS2 -- Journalling Flash File System, Version 2.
++ *
++ * For licensing information, see the file 'LICENCE' in this directory.
++ *
++ * JFFS2 wrapper to the LZMA C SDK
++ *
++ */
++
++#include <linux/lzma.h>
++#include "compr.h"
++
++#ifdef __KERNEL__
++	static DEFINE_MUTEX(deflate_mutex);
++#endif
++
++CLzmaEncHandle *p;
++Byte propsEncoded[LZMA_PROPS_SIZE];
++SizeT propsSize = sizeof(propsEncoded);
++
++STATIC void lzma_free_workspace(void)
++{
++	LzmaEnc_Destroy(p, &lzma_alloc, &lzma_alloc);
++}
++
++STATIC int INIT lzma_alloc_workspace(CLzmaEncProps *props)
++{
++	if ((p = (CLzmaEncHandle *)LzmaEnc_Create(&lzma_alloc)) == NULL)
++	{
++		PRINT_ERROR("Failed to allocate lzma deflate workspace\n");
++		return -ENOMEM;
++	}
++
++	if (LzmaEnc_SetProps(p, props) != SZ_OK)
++	{
++		lzma_free_workspace();
++		return -1;
++	}
++	
++	if (LzmaEnc_WriteProperties(p, propsEncoded, &propsSize) != SZ_OK)
++	{
++		lzma_free_workspace();
++		return -1;
++	}
++
++        return 0;
++}
++
++STATIC int jffs2_lzma_compress(unsigned char *data_in, unsigned char *cpage_out,
++			      uint32_t *sourcelen, uint32_t *dstlen)
++{
++	SizeT compress_size = (SizeT)(*dstlen);
++	int ret;
++
++	#ifdef __KERNEL__
++		mutex_lock(&deflate_mutex);
++	#endif
++
++	ret = LzmaEnc_MemEncode(p, cpage_out, &compress_size, data_in, *sourcelen,
++		0, NULL, &lzma_alloc, &lzma_alloc);
++
++	#ifdef __KERNEL__
++		mutex_unlock(&deflate_mutex);
++	#endif
++
++	if (ret != SZ_OK)
++		return -1;
++
++	*dstlen = (uint32_t)compress_size;
++
++	return 0;
++}
++
++STATIC int jffs2_lzma_decompress(unsigned char *data_in, unsigned char *cpage_out,
++				 uint32_t srclen, uint32_t destlen)
++{
++	int ret;
++	SizeT dl = (SizeT)destlen;
++	SizeT sl = (SizeT)srclen;
++	ELzmaStatus status;
++	
++	ret = LzmaDecode(cpage_out, &dl, data_in, &sl, propsEncoded,
++		propsSize, LZMA_FINISH_ANY, &status, &lzma_alloc);
++
++	if (ret != SZ_OK || status == LZMA_STATUS_NOT_FINISHED || dl != (SizeT)destlen)
++		return -1;
++
++	return 0;
++}
++
++static struct jffs2_compressor jffs2_lzma_comp = {
++	.priority = JFFS2_LZMA_PRIORITY,
++	.name = "lzma",
++	.compr = JFFS2_COMPR_LZMA,
++	.compress = &jffs2_lzma_compress,
++	.decompress = &jffs2_lzma_decompress,
++	.disabled = 0,
++};
++
++int INIT jffs2_lzma_init(void)
++{
++        int ret;
++	CLzmaEncProps props;
++	LzmaEncProps_Init(&props);
++
++        props.dictSize = LZMA_BEST_DICT(0x2000);
++        props.level = LZMA_BEST_LEVEL;
++        props.lc = LZMA_BEST_LC;
++        props.lp = LZMA_BEST_LP;
++        props.pb = LZMA_BEST_PB;
++        props.fb = LZMA_BEST_FB;
++
++	ret = lzma_alloc_workspace(&props);
++        if (ret < 0)
++                return ret;
++
++	ret = jffs2_register_compressor(&jffs2_lzma_comp);
++	if (ret)
++		lzma_free_workspace();
++	
++        return ret;
++}
++
++void jffs2_lzma_exit(void)
++{
++	jffs2_unregister_compressor(&jffs2_lzma_comp);
++	lzma_free_workspace();
++}
+Index: kernel_tree/fs/jffs2/super.c
+===================================================================
+--- kernel_tree.orig/fs/jffs2/super.c
++++ kernel_tree/fs/jffs2/super.c
+@@ -374,14 +374,41 @@ static int __init init_jffs2_fs(void)
+ 	BUILD_BUG_ON(sizeof(struct jffs2_raw_inode) != 68);
+ 	BUILD_BUG_ON(sizeof(struct jffs2_raw_summary) != 32);
+ 
+-	pr_info("version 2.2."
++	pr_info("version 2.2"
+ #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
+ 	       " (NAND)"
+ #endif
+ #ifdef CONFIG_JFFS2_SUMMARY
+-	       " (SUMMARY) "
++	       " (SUMMARY)"
+ #endif
+-	       "  2001-2006 Red Hat, Inc.\n");
++#ifdef CONFIG_JFFS2_ZLIB
++	       " (ZLIB)"
++#endif
++#ifdef CONFIG_JFFS2_LZO
++	       " (LZO)"
++#endif
++#ifdef CONFIG_JFFS2_LZMA
++	       " (LZMA)"
++#endif
++#ifdef CONFIG_JFFS2_RTIME
++	       " (RTIME)"
++#endif
++#ifdef CONFIG_JFFS2_RUBIN
++	       " (RUBIN)"
++#endif
++#ifdef  CONFIG_JFFS2_CMODE_NONE
++	       " (CMODE_NONE)"
++#endif
++#ifdef CONFIG_JFFS2_CMODE_PRIORITY
++	       " (CMODE_PRIORITY)"
++#endif
++#ifdef CONFIG_JFFS2_CMODE_SIZE
++	       " (CMODE_SIZE)"
++#endif
++#ifdef CONFIG_JFFS2_CMODE_FAVOURLZO
++	       " (CMODE_FAVOURLZO)"
++#endif
++	       " (c) 2001-2006 Red Hat, Inc.\n");
+ 
+ 	jffs2_inode_cachep = kmem_cache_create("jffs2_i",
+ 					     sizeof(struct jffs2_inode_info),
+Index: kernel_tree/include/uapi/linux/jffs2.h
+===================================================================
+--- kernel_tree.orig/include/uapi/linux/jffs2.h
++++ kernel_tree/include/uapi/linux/jffs2.h
+@@ -46,6 +46,7 @@
+ #define JFFS2_COMPR_DYNRUBIN	0x05
+ #define JFFS2_COMPR_ZLIB	0x06
+ #define JFFS2_COMPR_LZO		0x07
++#define JFFS2_COMPR_LZMA	0x08
+ /* Compatibility flags. */
+ #define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
+ #define JFFS2_NODE_ACCURATE 0x2000
+Index: kernel_tree/include/linux/lzma.h
+===================================================================
+--- /dev/null
++++ kernel_tree/include/linux/lzma.h
+@@ -0,0 +1,62 @@
++#ifndef __LZMA_H__
++#define __LZMA_H__
++
++#ifdef __KERNEL__
++	#include <linux/kernel.h>
++	#include <linux/sched.h>
++	#include <linux/slab.h>
++	#include <linux/vmalloc.h>
++	#include <linux/init.h>
++	#define LZMA_MALLOC vmalloc
++	#define LZMA_FREE vfree
++	#define PRINT_ERROR(msg) printk(KERN_WARNING #msg)
++	#define INIT __init
++	#define STATIC static
++#else
++	#include <stdint.h>
++	#include <stdlib.h>
++	#include <stdio.h>
++	#include <unistd.h>
++	#include <string.h>
++	#include <asm/types.h>
++	#include <errno.h>
++	#include <linux/jffs2.h>
++	#ifndef PAGE_SIZE
++		extern int page_size;
++		#define PAGE_SIZE page_size
++	#endif
++	#define LZMA_MALLOC malloc
++	#define LZMA_FREE free
++	#define PRINT_ERROR(msg) fprintf(stderr, msg)
++	#define INIT
++	#define STATIC
++#endif
++
++#include "lzma/LzmaDec.h"
++#include "lzma/LzmaEnc.h"
++
++#define LZMA_BEST_LEVEL (9)
++#define LZMA_BEST_LC    (0)
++#define LZMA_BEST_LP    (0)
++#define LZMA_BEST_PB    (0)
++#define LZMA_BEST_FB  (273)
++
++#define LZMA_BEST_DICT(n) (((int)((n) / 2)) * 2)
++
++static void *p_lzma_malloc(void *p, size_t size)
++{
++        if (size == 0)
++                return NULL;
++
++        return LZMA_MALLOC(size);
++}
++
++static void p_lzma_free(void *p, void *address)
++{
++        if (address != NULL)
++                LZMA_FREE(address);
++}
++
++static ISzAlloc lzma_alloc = {p_lzma_malloc, p_lzma_free};
++
++#endif
+Index: kernel_tree/include/linux/lzma/LzFind.h
+===================================================================
+--- /dev/null
++++ kernel_tree/include/linux/lzma/LzFind.h
+@@ -0,0 +1,115 @@
++/* LzFind.h -- Match finder for LZ algorithms
++2009-04-22 : Igor Pavlov : Public domain */
++
++#ifndef __LZ_FIND_H
++#define __LZ_FIND_H
++
++#include "Types.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++typedef UInt32 CLzRef;
++
++typedef struct _CMatchFinder
++{
++  Byte *buffer;
++  UInt32 pos;
++  UInt32 posLimit;
++  UInt32 streamPos;
++  UInt32 lenLimit;
++
++  UInt32 cyclicBufferPos;
++  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
++
++  UInt32 matchMaxLen;
++  CLzRef *hash;
++  CLzRef *son;
++  UInt32 hashMask;
++  UInt32 cutValue;
++
++  Byte *bufferBase;
++  ISeqInStream *stream;
++  int streamEndWasReached;
++
++  UInt32 blockSize;
++  UInt32 keepSizeBefore;
++  UInt32 keepSizeAfter;
++
++  UInt32 numHashBytes;
++  int directInput;
++  size_t directInputRem;
++  int btMode;
++  int bigHash;
++  UInt32 historySize;
++  UInt32 fixedHashSize;
++  UInt32 hashSizeSum;
++  UInt32 numSons;
++  SRes result;
++  UInt32 crc[256];
++} CMatchFinder;
++
++#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
++#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])
++
++#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
++
++int MatchFinder_NeedMove(CMatchFinder *p);
++Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
++void MatchFinder_MoveBlock(CMatchFinder *p);
++void MatchFinder_ReadIfRequired(CMatchFinder *p);
++
++void MatchFinder_Construct(CMatchFinder *p);
++
++/* Conditions:
++     historySize <= 3 GB
++     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
++*/
++int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
++    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
++    ISzAlloc *alloc);
++void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
++void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
++void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
++
++UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
++    UInt32 *distances, UInt32 maxLen);
++
++/*
++Conditions:
++  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
++  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
++*/
++
++typedef void (*Mf_Init_Func)(void *object);
++typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
++typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
++typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
++typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
++typedef void (*Mf_Skip_Func)(void *object, UInt32);
++
++typedef struct _IMatchFinder
++{
++  Mf_Init_Func Init;
++  Mf_GetIndexByte_Func GetIndexByte;
++  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
++  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
++  Mf_GetMatches_Func GetMatches;
++  Mf_Skip_Func Skip;
++} IMatchFinder;
++
++void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
++
++void MatchFinder_Init(CMatchFinder *p);
++UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
++UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
++void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
++void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif
+Index: kernel_tree/include/linux/lzma/LzHash.h
+===================================================================
+--- /dev/null
++++ kernel_tree/include/linux/lzma/LzHash.h
+@@ -0,0 +1,54 @@
++/* LzHash.h -- HASH functions for LZ algorithms
++2009-02-07 : Igor Pavlov : Public domain */
++
++#ifndef __LZ_HASH_H
++#define __LZ_HASH_H
++
++#define kHash2Size (1 << 10)
++#define kHash3Size (1 << 16)
++#define kHash4Size (1 << 20)
++
++#define kFix3HashSize (kHash2Size)
++#define kFix4HashSize (kHash2Size + kHash3Size)
++#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
++
++#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);
++
++#define HASH3_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
++
++#define HASH4_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
++  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
++
++#define HASH5_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
++  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
++  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
++  hash4Value &= (kHash4Size - 1); }
++
++/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
++#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
++
++
++#define MT_HASH2_CALC \
++  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
++
++#define MT_HASH3_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
++
++#define MT_HASH4_CALC { \
++  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
++  hash2Value = temp & (kHash2Size - 1); \
++  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
++  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
++
++#endif
+Index: kernel_tree/include/linux/lzma/LzmaDec.h
+===================================================================
+--- /dev/null
++++ kernel_tree/include/linux/lzma/LzmaDec.h
+@@ -0,0 +1,231 @@
++/* LzmaDec.h -- LZMA Decoder
++2009-02-07 : Igor Pavlov : Public domain */
++
++#ifndef __LZMA_DEC_H
++#define __LZMA_DEC_H
++
++#include "Types.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++/* #define _LZMA_PROB32 */
++/* _LZMA_PROB32 can increase the speed on some CPUs,
++   but memory usage for CLzmaDec::probs will be doubled in that case */
++
++#ifdef _LZMA_PROB32
++#define CLzmaProb UInt32
++#else
++#define CLzmaProb UInt16
++#endif
++
++
++/* ---------- LZMA Properties ---------- */
++
++#define LZMA_PROPS_SIZE 5
++
++typedef struct _CLzmaProps
++{
++  unsigned lc, lp, pb;
++  UInt32 dicSize;
++} CLzmaProps;
++
++/* LzmaProps_Decode - decodes properties
++Returns:
++  SZ_OK
++  SZ_ERROR_UNSUPPORTED - Unsupported properties
++*/
++
++SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
++
++
++/* ---------- LZMA Decoder state ---------- */
++
++/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
++   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */
++
++#define LZMA_REQUIRED_INPUT_MAX 20
++
++typedef struct
++{
++  CLzmaProps prop;
++  CLzmaProb *probs;
++  Byte *dic;
++  const Byte *buf;
++  UInt32 range, code;
++  SizeT dicPos;
++  SizeT dicBufSize;
++  UInt32 processedPos;
++  UInt32 checkDicSize;
++  unsigned state;
++  UInt32 reps[4];
++  unsigned remainLen;
++  int needFlush;
++  int needInitState;
++  UInt32 numProbs;
++  unsigned tempBufSize;
++  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
++} CLzmaDec;
++
++#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
++
++void LzmaDec_Init(CLzmaDec *p);
++
++/* There are two types of LZMA streams:
++     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
++     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
++
++typedef enum
++{
++  LZMA_FINISH_ANY,   /* finish at any point */
++  LZMA_FINISH_END    /* block must be finished at the end */
++} ELzmaFinishMode;
++
++/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
++
++   You must use LZMA_FINISH_END, when you know that current output buffer
++   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
++
++   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
++   and output value of destLen will be less than output buffer size limit.
++   You can check status result also.
++
++   You can use multiple checks to test data integrity after full decompression:
++     1) Check Result and "status" variable.
++     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
++     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
++        You must use correct finish mode in that case. */
++
++typedef enum
++{
++  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
++  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
++  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
++  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
++  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
++} ELzmaStatus;
++
++/* ELzmaStatus is used only as output value for function call */
++
++
++/* ---------- Interfaces ---------- */
++
++/* There are 3 levels of interfaces:
++     1) Dictionary Interface
++     2) Buffer Interface
++     3) One Call Interface
++   You can select any of these interfaces, but don't mix functions from different
++   groups for same object. */
++
++
++/* There are two variants to allocate state for Dictionary Interface:
++     1) LzmaDec_Allocate / LzmaDec_Free
++     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
++   You can use variant 2, if you set dictionary buffer manually.
++   For Buffer Interface you must always use variant 1.
++
++LzmaDec_Allocate* can return:
++  SZ_OK
++  SZ_ERROR_MEM         - Memory allocation error
++  SZ_ERROR_UNSUPPORTED - Unsupported properties
++*/
++   
++SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
++void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
++
++SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
++void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
++
++/* ---------- Dictionary Interface ---------- */
++
++/* You can use it, if you want to eliminate the overhead for data copying from
++   dictionary to some other external buffer.
++   You must work with CLzmaDec variables directly in this interface.
++
++   STEPS:
++     LzmaDec_Constr()
++     LzmaDec_Allocate()
++     for (each new stream)
++     {
++       LzmaDec_Init()
++       while (it needs more decompression)
++       {
++         LzmaDec_DecodeToDic()
++         use data from CLzmaDec::dic and update CLzmaDec::dicPos
++       }
++     }
++     LzmaDec_Free()
++*/
++
++/* LzmaDec_DecodeToDic
++   
++   The decoding to internal dictionary buffer (CLzmaDec::dic).
++   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
++
++finishMode:
++  It has meaning only if the decoding reaches output limit (dicLimit).
++  LZMA_FINISH_ANY - Decode just dicLimit bytes.
++  LZMA_FINISH_END - Stream must be finished after dicLimit.
++
++Returns:
++  SZ_OK
++    status:
++      LZMA_STATUS_FINISHED_WITH_MARK
++      LZMA_STATUS_NOT_FINISHED
++      LZMA_STATUS_NEEDS_MORE_INPUT
++      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
++  SZ_ERROR_DATA - Data error
++*/
++
++SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
++    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
++
++
++/* ---------- Buffer Interface ---------- */
++
++/* It's zlib-like interface.
++   See LzmaDec_DecodeToDic description for information about STEPS and return results,
++   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
++   to work with CLzmaDec variables manually.
++
++finishMode:
++  It has meaning only if the decoding reaches output limit (*destLen).
++  LZMA_FINISH_ANY - Decode just destLen bytes.
++  LZMA_FINISH_END - Stream must be finished after (*destLen).
++*/
++
++SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
++    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
++
++
++/* ---------- One Call Interface ---------- */
++
++/* LzmaDecode
++
++finishMode:
++  It has meaning only if the decoding reaches output limit (*destLen).
++  LZMA_FINISH_ANY - Decode just destLen bytes.
++  LZMA_FINISH_END - Stream must be finished after (*destLen).
++
++Returns:
++  SZ_OK
++    status:
++      LZMA_STATUS_FINISHED_WITH_MARK
++      LZMA_STATUS_NOT_FINISHED
++      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
++  SZ_ERROR_DATA - Data error
++  SZ_ERROR_MEM  - Memory allocation error
++  SZ_ERROR_UNSUPPORTED - Unsupported properties
++  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
++*/
++
++SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
++    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
++    ELzmaStatus *status, ISzAlloc *alloc);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif
+Index: kernel_tree/include/linux/lzma/LzmaEnc.h
+===================================================================
+--- /dev/null
++++ kernel_tree/include/linux/lzma/LzmaEnc.h
+@@ -0,0 +1,80 @@
++/*  LzmaEnc.h -- LZMA Encoder
++2009-02-07 : Igor Pavlov : Public domain */
++
++#ifndef __LZMA_ENC_H
++#define __LZMA_ENC_H
++
++#include "Types.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++#define LZMA_PROPS_SIZE 5
++
++typedef struct _CLzmaEncProps
++{
++  int level;       /*  0 <= level <= 9 */
++  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
++                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
++                       default = (1 << 24) */
++  int lc;          /* 0 <= lc <= 8, default = 3 */
++  int lp;          /* 0 <= lp <= 4, default = 0 */
++  int pb;          /* 0 <= pb <= 4, default = 2 */
++  int algo;        /* 0 - fast, 1 - normal, default = 1 */
++  int fb;          /* 5 <= fb <= 273, default = 32 */
++  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
++  int numHashBytes; /* 2, 3 or 4, default = 4 */
++  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
++  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
++  int numThreads;  /* 1 or 2, default = 2 */
++} CLzmaEncProps;
++
++void LzmaEncProps_Init(CLzmaEncProps *p);
++void LzmaEncProps_Normalize(CLzmaEncProps *p);
++UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
++
++
++/* ---------- CLzmaEncHandle Interface ---------- */
++
++/* LzmaEnc_* functions can return the following exit codes:
++Returns:
++  SZ_OK           - OK
++  SZ_ERROR_MEM    - Memory allocation error
++  SZ_ERROR_PARAM  - Incorrect paramater in props
++  SZ_ERROR_WRITE  - Write callback error.
++  SZ_ERROR_PROGRESS - some break from progress callback
++  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
++*/
++
++typedef void * CLzmaEncHandle;
++
++CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
++void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
++SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
++SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
++SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
++SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
++
++/* ---------- One Call Interface ---------- */
++
++/* LzmaEncode
++Return code:
++  SZ_OK               - OK
++  SZ_ERROR_MEM        - Memory allocation error
++  SZ_ERROR_PARAM      - Incorrect paramater
++  SZ_ERROR_OUTPUT_EOF - output buffer overflow
++  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
++*/
++
++SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif
+Index: kernel_tree/include/linux/lzma/Types.h
+===================================================================
+--- /dev/null
++++ kernel_tree/include/linux/lzma/Types.h
+@@ -0,0 +1,226 @@
++/* Types.h -- Basic types
++2009-11-23 : Igor Pavlov : Public domain */
++
++#ifndef __7Z_TYPES_H
++#define __7Z_TYPES_H
++
++#include <stddef.h>
++
++#ifdef _WIN32
++#include <windows.h>
++#endif
++
++#ifndef EXTERN_C_BEGIN
++#ifdef __cplusplus
++#define EXTERN_C_BEGIN extern "C" {
++#define EXTERN_C_END }
++#else
++#define EXTERN_C_BEGIN
++#define EXTERN_C_END
++#endif
++#endif
++
++EXTERN_C_BEGIN
++
++#define SZ_OK 0
++
++#define SZ_ERROR_DATA 1
++#define SZ_ERROR_MEM 2
++#define SZ_ERROR_CRC 3
++#define SZ_ERROR_UNSUPPORTED 4
++#define SZ_ERROR_PARAM 5
++#define SZ_ERROR_INPUT_EOF 6
++#define SZ_ERROR_OUTPUT_EOF 7
++#define SZ_ERROR_READ 8
++#define SZ_ERROR_WRITE 9
++#define SZ_ERROR_PROGRESS 10
++#define SZ_ERROR_FAIL 11
++#define SZ_ERROR_THREAD 12
++
++#define SZ_ERROR_ARCHIVE 16
++#define SZ_ERROR_NO_ARCHIVE 17
++
++typedef int SRes;
++
++#ifdef _WIN32
++typedef DWORD WRes;
++#else
++typedef int WRes;
++#endif
++
++#ifndef RINOK
++#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
++#endif
++
++typedef unsigned char Byte;
++typedef short Int16;
++typedef unsigned short UInt16;
++
++#ifdef _LZMA_UINT32_IS_ULONG
++typedef long Int32;
++typedef unsigned long UInt32;
++#else
++typedef int Int32;
++typedef unsigned int UInt32;
++#endif
++
++#ifdef _SZ_NO_INT_64
++
++/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
++   NOTES: Some code will work incorrectly in that case! */
++
++typedef long Int64;
++typedef unsigned long UInt64;
++
++#else
++
++#if defined(_MSC_VER) || defined(__BORLANDC__)
++typedef __int64 Int64;
++typedef unsigned __int64 UInt64;
++#else
++typedef long long int Int64;
++typedef unsigned long long int UInt64;
++#endif
++
++#endif
++
++#ifdef _LZMA_NO_SYSTEM_SIZE_T
++typedef UInt32 SizeT;
++#else
++typedef size_t SizeT;
++#endif
++
++typedef int Bool;
++#define True 1
++#define False 0
++
++
++#ifdef _WIN32
++#define MY_STD_CALL __stdcall
++#else
++#define MY_STD_CALL
++#endif
++
++#ifdef _MSC_VER
++
++#if _MSC_VER >= 1300
++#define MY_NO_INLINE __declspec(noinline)
++#else
++#define MY_NO_INLINE
++#endif
++
++#define MY_CDECL __cdecl
++#define MY_FAST_CALL __fastcall
++
++#else
++
++#define MY_CDECL
++#define MY_FAST_CALL
++
++#endif
++
++
++/* The following interfaces use first parameter as pointer to structure */
++
++typedef struct
++{
++  SRes (*Read)(void *p, void *buf, size_t *size);
++    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
++       (output(*size) < input(*size)) is allowed */
++} ISeqInStream;
++
++/* it can return SZ_ERROR_INPUT_EOF */
++SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
++SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
++SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
++
++typedef struct
++{
++  size_t (*Write)(void *p, const void *buf, size_t size);
++    /* Returns: result - the number of actually written bytes.
++       (result < size) means error */
++} ISeqOutStream;
++
++typedef enum
++{
++  SZ_SEEK_SET = 0,
++  SZ_SEEK_CUR = 1,
++  SZ_SEEK_END = 2
++} ESzSeek;
++
++typedef struct
++{
++  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
++  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
++} ISeekInStream;
++
++typedef struct
++{
++  SRes (*Look)(void *p, void **buf, size_t *size);
++    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
++       (output(*size) > input(*size)) is not allowed
++       (output(*size) < input(*size)) is allowed */
++  SRes (*Skip)(void *p, size_t offset);
++    /* offset must be <= output(*size) of Look */
++
++  SRes (*Read)(void *p, void *buf, size_t *size);
++    /* reads directly (without buffer). It's same as ISeqInStream::Read */
++  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
++} ILookInStream;
++
++SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
++SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);
++
++/* reads via ILookInStream::Read */
++SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
++SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);
++
++#define LookToRead_BUF_SIZE (1 << 14)
++
++typedef struct
++{
++  ILookInStream s;
++  ISeekInStream *realStream;
++  size_t pos;
++  size_t size;
++  Byte buf[LookToRead_BUF_SIZE];
++} CLookToRead;
++
++void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
++void LookToRead_Init(CLookToRead *p);
++
++typedef struct
++{
++  ISeqInStream s;
++  ILookInStream *realStream;
++} CSecToLook;
++
++void SecToLook_CreateVTable(CSecToLook *p);
++
++typedef struct
++{
++  ISeqInStream s;
++  ILookInStream *realStream;
++} CSecToRead;
++
++void SecToRead_CreateVTable(CSecToRead *p);
++
++typedef struct
++{
++  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
++    /* Returns: result. (result != SZ_OK) means break.
++       Value (UInt64)(Int64)-1 for size means unknown value. */
++} ICompressProgress;
++
++typedef struct
++{
++  void *(*Alloc)(void *p, size_t size);
++  void (*Free)(void *p, void *address); /* address can be 0 */
++} ISzAlloc;
++
++#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
++#define IAlloc_Free(p, a) (p)->Free((p), a)
++
++EXTERN_C_END
++
++#endif
+Index: kernel_tree/lib/Kconfig
+===================================================================
+--- kernel_tree.orig/lib/Kconfig
++++ kernel_tree/lib/Kconfig
+@@ -191,6 +191,12 @@ config LZO_DECOMPRESS
+ 
+ source "lib/xz/Kconfig"
+ 
++config LZMA_COMPRESS
++    tristate
++
++config LZMA_DECOMPRESS
++    tristate
++
+ #
+ # These all provide a common interface (hence the apparent duplication with
+ # ZLIB_INFLATE; DECOMPRESS_GZIP is just a wrapper.)
+Index: kernel_tree/lib/Makefile
+===================================================================
+--- kernel_tree.orig/lib/Makefile
++++ kernel_tree/lib/Makefile
+@@ -2,6 +2,16 @@
+ # Makefile for some libs needed in the kernel.
+ #
+ 
++ifdef CONFIG_JFFS2_ZLIB
++	CONFIG_ZLIB_INFLATE:=y
++	CONFIG_ZLIB_DEFLATE:=y
++endif
++
++ifdef CONFIG_JFFS2_LZMA
++	CONFIG_LZMA_DECOMPRESS:=y
++	CONFIG_LZMA_COMPRESS:=y
++endif
++
+ ifdef CONFIG_FUNCTION_TRACER
+ ORIG_CFLAGS := $(KBUILD_CFLAGS)
+ KBUILD_CFLAGS = $(subst -pg,,$(ORIG_CFLAGS))
+@@ -78,6 +88,8 @@ obj-$(CONFIG_LZO_COMPRESS) += lzo/
+ obj-$(CONFIG_LZO_DECOMPRESS) += lzo/
+ obj-$(CONFIG_XZ_DEC) += xz/
+ obj-$(CONFIG_RAID6_PQ) += raid6/
++obj-$(CONFIG_LZMA_COMPRESS) += lzma/
++obj-$(CONFIG_LZMA_DECOMPRESS) += lzma/
+ 
+ lib-$(CONFIG_DECOMPRESS_GZIP) += decompress_inflate.o
+ lib-$(CONFIG_DECOMPRESS_BZIP2) += decompress_bunzip2.o
+Index: kernel_tree/lib/lzma/LzFind.c
+===================================================================
+--- /dev/null
++++ kernel_tree/lib/lzma/LzFind.c
+@@ -0,0 +1,761 @@
++/* LzFind.c -- Match finder for LZ algorithms
++2009-04-22 : Igor Pavlov : Public domain */
++
++#include <string.h>
++
++#include "LzFind.h"
++#include "LzHash.h"
++
++#define kEmptyHashValue 0
++#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
++#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
++#define kNormalizeMask (~(kNormalizeStepMin - 1))
++#define kMaxHistorySize ((UInt32)3 << 30)
++
++#define kStartMaxLen 3
++
++static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
++{
++  if (!p->directInput)
++  {
++    alloc->Free(alloc, p->bufferBase);
++    p->bufferBase = 0;
++  }
++}
++
++/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */
++
++static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
++{
++  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
++  if (p->directInput)
++  {
++    p->blockSize = blockSize;
++    return 1;
++  }
++  if (p->bufferBase == 0 || p->blockSize != blockSize)
++  {
++    LzInWindow_Free(p, alloc);
++    p->blockSize = blockSize;
++    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
++  }
++  return (p->bufferBase != 0);
++}
++
++Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
++Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
++
++UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
++
++void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
++{
++  p->posLimit -= subValue;
++  p->pos -= subValue;
++  p->streamPos -= subValue;
++}
++
++static void MatchFinder_ReadBlock(CMatchFinder *p)
++{
++  if (p->streamEndWasReached || p->result != SZ_OK)
++    return;
++  if (p->directInput)
++  {
++    UInt32 curSize = 0xFFFFFFFF - p->streamPos;
++    if (curSize > p->directInputRem)
++      curSize = (UInt32)p->directInputRem;
++    p->directInputRem -= curSize;
++    p->streamPos += curSize;
++    if (p->directInputRem == 0)
++      p->streamEndWasReached = 1;
++    return;
++  }
++  for (;;)
++  {
++    Byte *dest = p->buffer + (p->streamPos - p->pos);
++    size_t size = (p->bufferBase + p->blockSize - dest);
++    if (size == 0)
++      return;
++    p->result = p->stream->Read(p->stream, dest, &size);
++    if (p->result != SZ_OK)
++      return;
++    if (size == 0)
++    {
++      p->streamEndWasReached = 1;
++      return;
++    }
++    p->streamPos += (UInt32)size;
++    if (p->streamPos - p->pos > p->keepSizeAfter)
++      return;
++  }
++}
++
++void MatchFinder_MoveBlock(CMatchFinder *p)
++{
++  memmove(p->bufferBase,
++    p->buffer - p->keepSizeBefore,
++    (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
++  p->buffer = p->bufferBase + p->keepSizeBefore;
++}
++
++int MatchFinder_NeedMove(CMatchFinder *p)
++{
++  if (p->directInput)
++    return 0;
++  /* if (p->streamEndWasReached) return 0; */
++  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
++}
++
++void MatchFinder_ReadIfRequired(CMatchFinder *p)
++{
++  if (p->streamEndWasReached)
++    return;
++  if (p->keepSizeAfter >= p->streamPos - p->pos)
++    MatchFinder_ReadBlock(p);
++}
++
++static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
++{
++  if (MatchFinder_NeedMove(p))
++    MatchFinder_MoveBlock(p);
++  MatchFinder_ReadBlock(p);
++}
++
++static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
++{
++  p->cutValue = 32;
++  p->btMode = 1;
++  p->numHashBytes = 4;
++  p->bigHash = 0;
++}
++
++#define kCrcPoly 0xEDB88320
++
++void MatchFinder_Construct(CMatchFinder *p)
++{
++  UInt32 i;
++  p->bufferBase = 0;
++  p->directInput = 0;
++  p->hash = 0;
++  MatchFinder_SetDefaultSettings(p);
++
++  for (i = 0; i < 256; i++)
++  {
++    UInt32 r = i;
++    int j;
++    for (j = 0; j < 8; j++)
++      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
++    p->crc[i] = r;
++  }
++}
++
++static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->hash);
++  p->hash = 0;
++}
++
++void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
++{
++  MatchFinder_FreeThisClassMemory(p, alloc);
++  LzInWindow_Free(p, alloc);
++}
++
++static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
++{
++  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
++  if (sizeInBytes / sizeof(CLzRef) != num)
++    return 0;
++  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
++}
++
++int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
++    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
++    ISzAlloc *alloc)
++{
++  UInt32 sizeReserv;
++  if (historySize > kMaxHistorySize)
++  {
++    MatchFinder_Free(p, alloc);
++    return 0;
++  }
++  sizeReserv = historySize >> 1;
++  if (historySize > ((UInt32)2 << 30))
++    sizeReserv = historySize >> 2;
++  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);
++
++  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
++  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
++  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
++  if (LzInWindow_Create(p, sizeReserv, alloc))
++  {
++    UInt32 newCyclicBufferSize = historySize + 1;
++    UInt32 hs;
++    p->matchMaxLen = matchMaxLen;
++    {
++      p->fixedHashSize = 0;
++      if (p->numHashBytes == 2)
++        hs = (1 << 16) - 1;
++      else
++      {
++        hs = historySize - 1;
++        hs |= (hs >> 1);
++        hs |= (hs >> 2);
++        hs |= (hs >> 4);
++        hs |= (hs >> 8);
++        hs >>= 1;
++        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
++        if (hs > (1 << 24))
++        {
++          if (p->numHashBytes == 3)
++            hs = (1 << 24) - 1;
++          else
++            hs >>= 1;
++        }
++      }
++      p->hashMask = hs;
++      hs++;
++      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
++      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
++      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
++      hs += p->fixedHashSize;
++    }
++
++    {
++      UInt32 prevSize = p->hashSizeSum + p->numSons;
++      UInt32 newSize;
++      p->historySize = historySize;
++      p->hashSizeSum = hs;
++      p->cyclicBufferSize = newCyclicBufferSize;
++      p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
++      newSize = p->hashSizeSum + p->numSons;
++      if (p->hash != 0 && prevSize == newSize)
++        return 1;
++      MatchFinder_FreeThisClassMemory(p, alloc);
++      p->hash = AllocRefs(newSize, alloc);
++      if (p->hash != 0)
++      {
++        p->son = p->hash + p->hashSizeSum;
++        return 1;
++      }
++    }
++  }
++  MatchFinder_Free(p, alloc);
++  return 0;
++}
++
++static void MatchFinder_SetLimits(CMatchFinder *p)
++{
++  UInt32 limit = kMaxValForNormalize - p->pos;
++  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
++  if (limit2 < limit)
++    limit = limit2;
++  limit2 = p->streamPos - p->pos;
++  if (limit2 <= p->keepSizeAfter)
++  {
++    if (limit2 > 0)
++      limit2 = 1;
++  }
++  else
++    limit2 -= p->keepSizeAfter;
++  if (limit2 < limit)
++    limit = limit2;
++  {
++    UInt32 lenLimit = p->streamPos - p->pos;
++    if (lenLimit > p->matchMaxLen)
++      lenLimit = p->matchMaxLen;
++    p->lenLimit = lenLimit;
++  }
++  p->posLimit = p->pos + limit;
++}
++
++void MatchFinder_Init(CMatchFinder *p)
++{
++  UInt32 i;
++  for (i = 0; i < p->hashSizeSum; i++)
++    p->hash[i] = kEmptyHashValue;
++  p->cyclicBufferPos = 0;
++  p->buffer = p->bufferBase;
++  p->pos = p->streamPos = p->cyclicBufferSize;
++  p->result = SZ_OK;
++  p->streamEndWasReached = 0;
++  MatchFinder_ReadBlock(p);
++  MatchFinder_SetLimits(p);
++}
++
++static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
++{
++  return (p->pos - p->historySize - 1) & kNormalizeMask;
++}
++
++void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
++{
++  UInt32 i;
++  for (i = 0; i < numItems; i++)
++  {
++    UInt32 value = items[i];
++    if (value <= subValue)
++      value = kEmptyHashValue;
++    else
++      value -= subValue;
++    items[i] = value;
++  }
++}
++
++static void MatchFinder_Normalize(CMatchFinder *p)
++{
++  UInt32 subValue = MatchFinder_GetSubValue(p);
++  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
++  MatchFinder_ReduceOffsets(p, subValue);
++}
++
++static void MatchFinder_CheckLimits(CMatchFinder *p)
++{
++  if (p->pos == kMaxValForNormalize)
++    MatchFinder_Normalize(p);
++  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
++    MatchFinder_CheckAndMoveAndRead(p);
++  if (p->cyclicBufferPos == p->cyclicBufferSize)
++    p->cyclicBufferPos = 0;
++  MatchFinder_SetLimits(p);
++}
++
++static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
++    UInt32 *distances, UInt32 maxLen)
++{
++  son[_cyclicBufferPos] = curMatch;
++  for (;;)
++  {
++    UInt32 delta = pos - curMatch;
++    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
++      return distances;
++    {
++      const Byte *pb = cur - delta;
++      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
++      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
++      {
++        UInt32 len = 0;
++        while (++len != lenLimit)
++          if (pb[len] != cur[len])
++            break;
++        if (maxLen < len)
++        {
++          *distances++ = maxLen = len;
++          *distances++ = delta - 1;
++          if (len == lenLimit)
++            return distances;
++        }
++      }
++    }
++  }
++}
++
++UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
++    UInt32 *distances, UInt32 maxLen)
++{
++  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
++  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
++  UInt32 len0 = 0, len1 = 0;
++  for (;;)
++  {
++    UInt32 delta = pos - curMatch;
++    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
++    {
++      *ptr0 = *ptr1 = kEmptyHashValue;
++      return distances;
++    }
++    {
++      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
++      const Byte *pb = cur - delta;
++      UInt32 len = (len0 < len1 ? len0 : len1);
++      if (pb[len] == cur[len])
++      {
++        if (++len != lenLimit && pb[len] == cur[len])
++          while (++len != lenLimit)
++            if (pb[len] != cur[len])
++              break;
++        if (maxLen < len)
++        {
++          *distances++ = maxLen = len;
++          *distances++ = delta - 1;
++          if (len == lenLimit)
++          {
++            *ptr1 = pair[0];
++            *ptr0 = pair[1];
++            return distances;
++          }
++        }
++      }
++      if (pb[len] < cur[len])
++      {
++        *ptr1 = curMatch;
++        ptr1 = pair + 1;
++        curMatch = *ptr1;
++        len1 = len;
++      }
++      else
++      {
++        *ptr0 = curMatch;
++        ptr0 = pair;
++        curMatch = *ptr0;
++        len0 = len;
++      }
++    }
++  }
++}
++
++static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
++{
++  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
++  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
++  UInt32 len0 = 0, len1 = 0;
++  for (;;)
++  {
++    UInt32 delta = pos - curMatch;
++    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
++    {
++      *ptr0 = *ptr1 = kEmptyHashValue;
++      return;
++    }
++    {
++      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
++      const Byte *pb = cur - delta;
++      UInt32 len = (len0 < len1 ? len0 : len1);
++      if (pb[len] == cur[len])
++      {
++        while (++len != lenLimit)
++          if (pb[len] != cur[len])
++            break;
++        {
++          if (len == lenLimit)
++          {
++            *ptr1 = pair[0];
++            *ptr0 = pair[1];
++            return;
++          }
++        }
++      }
++      if (pb[len] < cur[len])
++      {
++        *ptr1 = curMatch;
++        ptr1 = pair + 1;
++        curMatch = *ptr1;
++        len1 = len;
++      }
++      else
++      {
++        *ptr0 = curMatch;
++        ptr0 = pair;
++        curMatch = *ptr0;
++        len0 = len;
++      }
++    }
++  }
++}
++
++#define MOVE_POS \
++  ++p->cyclicBufferPos; \
++  p->buffer++; \
++  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
++
++#define MOVE_POS_RET MOVE_POS return offset;
++
++static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
++
++#define GET_MATCHES_HEADER2(minLen, ret_op) \
++  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
++  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
++  cur = p->buffer;
++
++#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
++#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
++
++#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue
++
++#define GET_MATCHES_FOOTER(offset, maxLen) \
++  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
++  distances + offset, maxLen) - distances); MOVE_POS_RET;
++
++#define SKIP_FOOTER \
++  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
++
++static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(2)
++  HASH2_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = 0;
++  GET_MATCHES_FOOTER(offset, 1)
++}
++
++UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(3)
++  HASH_ZIP_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = 0;
++  GET_MATCHES_FOOTER(offset, 2)
++}
++
++static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 hash2Value, delta2, maxLen, offset;
++  GET_MATCHES_HEADER(3)
++
++  HASH3_CALC;
++
++  delta2 = p->pos - p->hash[hash2Value];
++  curMatch = p->hash[kFix3HashSize + hashValue];
++  
++  p->hash[hash2Value] =
++  p->hash[kFix3HashSize + hashValue] = p->pos;
++
++
++  maxLen = 2;
++  offset = 0;
++  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
++  {
++    for (; maxLen != lenLimit; maxLen++)
++      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
++        break;
++    distances[0] = maxLen;
++    distances[1] = delta2 - 1;
++    offset = 2;
++    if (maxLen == lenLimit)
++    {
++      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
++      MOVE_POS_RET;
++    }
++  }
++  GET_MATCHES_FOOTER(offset, maxLen)
++}
++
++static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
++  GET_MATCHES_HEADER(4)
++
++  HASH4_CALC;
++
++  delta2 = p->pos - p->hash[                hash2Value];
++  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
++  curMatch = p->hash[kFix4HashSize + hashValue];
++  
++  p->hash[                hash2Value] =
++  p->hash[kFix3HashSize + hash3Value] =
++  p->hash[kFix4HashSize + hashValue] = p->pos;
++
++  maxLen = 1;
++  offset = 0;
++  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
++  {
++    distances[0] = maxLen = 2;
++    distances[1] = delta2 - 1;
++    offset = 2;
++  }
++  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
++  {
++    maxLen = 3;
++    distances[offset + 1] = delta3 - 1;
++    offset += 2;
++    delta2 = delta3;
++  }
++  if (offset != 0)
++  {
++    for (; maxLen != lenLimit; maxLen++)
++      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
++        break;
++    distances[offset - 2] = maxLen;
++    if (maxLen == lenLimit)
++    {
++      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
++      MOVE_POS_RET;
++    }
++  }
++  if (maxLen < 3)
++    maxLen = 3;
++  GET_MATCHES_FOOTER(offset, maxLen)
++}
++
++static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
++  GET_MATCHES_HEADER(4)
++
++  HASH4_CALC;
++
++  delta2 = p->pos - p->hash[                hash2Value];
++  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
++  curMatch = p->hash[kFix4HashSize + hashValue];
++
++  p->hash[                hash2Value] =
++  p->hash[kFix3HashSize + hash3Value] =
++  p->hash[kFix4HashSize + hashValue] = p->pos;
++
++  maxLen = 1;
++  offset = 0;
++  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
++  {
++    distances[0] = maxLen = 2;
++    distances[1] = delta2 - 1;
++    offset = 2;
++  }
++  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
++  {
++    maxLen = 3;
++    distances[offset + 1] = delta3 - 1;
++    offset += 2;
++    delta2 = delta3;
++  }
++  if (offset != 0)
++  {
++    for (; maxLen != lenLimit; maxLen++)
++      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
++        break;
++    distances[offset - 2] = maxLen;
++    if (maxLen == lenLimit)
++    {
++      p->son[p->cyclicBufferPos] = curMatch;
++      MOVE_POS_RET;
++    }
++  }
++  if (maxLen < 3)
++    maxLen = 3;
++  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
++    distances + offset, maxLen) - (distances));
++  MOVE_POS_RET
++}
++
++UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(3)
++  HASH_ZIP_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
++    distances, 2) - (distances));
++  MOVE_POS_RET
++}
++
++static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(2)
++    HASH2_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(3)
++    HASH_ZIP_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    UInt32 hash2Value;
++    SKIP_HEADER(3)
++    HASH3_CALC;
++    curMatch = p->hash[kFix3HashSize + hashValue];
++    p->hash[hash2Value] =
++    p->hash[kFix3HashSize + hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    UInt32 hash2Value, hash3Value;
++    SKIP_HEADER(4)
++    HASH4_CALC;
++    curMatch = p->hash[kFix4HashSize + hashValue];
++    p->hash[                hash2Value] =
++    p->hash[kFix3HashSize + hash3Value] = p->pos;
++    p->hash[kFix4HashSize + hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    UInt32 hash2Value, hash3Value;
++    SKIP_HEADER(4)
++    HASH4_CALC;
++    curMatch = p->hash[kFix4HashSize + hashValue];
++    p->hash[                hash2Value] =
++    p->hash[kFix3HashSize + hash3Value] =
++    p->hash[kFix4HashSize + hashValue] = p->pos;
++    p->son[p->cyclicBufferPos] = curMatch;
++    MOVE_POS
++  }
++  while (--num != 0);
++}
++
++void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(3)
++    HASH_ZIP_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    p->son[p->cyclicBufferPos] = curMatch;
++    MOVE_POS
++  }
++  while (--num != 0);
++}
++
++void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
++{
++  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
++  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
++  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
++  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
++  if (!p->btMode)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
++  }
++  else if (p->numHashBytes == 2)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
++  }
++  else if (p->numHashBytes == 3)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
++  }
++  else
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
++  }
++}
+Index: kernel_tree/lib/lzma/LzmaDec.c
+===================================================================
+--- /dev/null
++++ kernel_tree/lib/lzma/LzmaDec.c
+@@ -0,0 +1,999 @@
++/* LzmaDec.c -- LZMA Decoder
++2009-09-20 : Igor Pavlov : Public domain */
++
++#include "LzmaDec.h"
++
++#include <string.h>
++
++#define kNumTopBits 24
++#define kTopValue ((UInt32)1 << kNumTopBits)
++
++#define kNumBitModelTotalBits 11
++#define kBitModelTotal (1 << kNumBitModelTotalBits)
++#define kNumMoveBits 5
++
++#define RC_INIT_SIZE 5
++
++#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }
++
++#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
++#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
++#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
++#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
++  { UPDATE_0(p); i = (i + i); A0; } else \
++  { UPDATE_1(p); i = (i + i) + 1; A1; }
++#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
++
++#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
++#define TREE_DECODE(probs, limit, i) \
++  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }
++
++/* #define _LZMA_SIZE_OPT */
++
++#ifdef _LZMA_SIZE_OPT
++#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
++#else
++#define TREE_6_DECODE(probs, i) \
++  { i = 1; \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  TREE_GET_BIT(probs, i); \
++  i -= 0x40; }
++#endif
++
++#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }
++
++#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
++#define UPDATE_0_CHECK range = bound;
++#define UPDATE_1_CHECK range -= bound; code -= bound;
++#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
++  { UPDATE_0_CHECK; i = (i + i); A0; } else \
++  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
++#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
++#define TREE_DECODE_CHECK(probs, limit, i) \
++  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }
++
++
++#define kNumPosBitsMax 4
++#define kNumPosStatesMax (1 << kNumPosBitsMax)
++
++#define kLenNumLowBits 3
++#define kLenNumLowSymbols (1 << kLenNumLowBits)
++#define kLenNumMidBits 3
++#define kLenNumMidSymbols (1 << kLenNumMidBits)
++#define kLenNumHighBits 8
++#define kLenNumHighSymbols (1 << kLenNumHighBits)
++
++#define LenChoice 0
++#define LenChoice2 (LenChoice + 1)
++#define LenLow (LenChoice2 + 1)
++#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
++#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
++#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
++
++
++#define kNumStates 12
++#define kNumLitStates 7
++
++#define kStartPosModelIndex 4
++#define kEndPosModelIndex 14
++#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
++
++#define kNumPosSlotBits 6
++#define kNumLenToPosStates 4
++
++#define kNumAlignBits 4
++#define kAlignTableSize (1 << kNumAlignBits)
++
++#define kMatchMinLen 2
++#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
++
++#define IsMatch 0
++#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
++#define IsRepG0 (IsRep + kNumStates)
++#define IsRepG1 (IsRepG0 + kNumStates)
++#define IsRepG2 (IsRepG1 + kNumStates)
++#define IsRep0Long (IsRepG2 + kNumStates)
++#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
++#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
++#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
++#define LenCoder (Align + kAlignTableSize)
++#define RepLenCoder (LenCoder + kNumLenProbs)
++#define Literal (RepLenCoder + kNumLenProbs)
++
++#define LZMA_BASE_SIZE 1846
++#define LZMA_LIT_SIZE 768
++
++#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
++
++#if Literal != LZMA_BASE_SIZE
++StopCompilingDueBUG
++#endif
++
++#define LZMA_DIC_MIN (1 << 12)
++
++/* First LZMA-symbol is always decoded.
++And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
++Out:
++  Result:
++    SZ_OK - OK
++    SZ_ERROR_DATA - Error
++  p->remainLen:
++    < kMatchSpecLenStart : normal remain
++    = kMatchSpecLenStart : finished
++    = kMatchSpecLenStart + 1 : Flush marker
++    = kMatchSpecLenStart + 2 : State Init Marker
++*/
++
++static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
++{
++  CLzmaProb *probs = p->probs;
++
++  unsigned state = p->state;
++  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
++  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
++  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
++  unsigned lc = p->prop.lc;
++
++  Byte *dic = p->dic;
++  SizeT dicBufSize = p->dicBufSize;
++  SizeT dicPos = p->dicPos;
++  
++  UInt32 processedPos = p->processedPos;
++  UInt32 checkDicSize = p->checkDicSize;
++  unsigned len = 0;
++
++  const Byte *buf = p->buf;
++  UInt32 range = p->range;
++  UInt32 code = p->code;
++
++  do
++  {
++    CLzmaProb *prob;
++    UInt32 bound;
++    unsigned ttt;
++    unsigned posState = processedPos & pbMask;
++
++    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
++    IF_BIT_0(prob)
++    {
++      unsigned symbol;
++      UPDATE_0(prob);
++      prob = probs + Literal;
++      if (checkDicSize != 0 || processedPos != 0)
++        prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
++        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));
++
++      if (state < kNumLitStates)
++      {
++        state -= (state < 4) ? state : 3;
++        symbol = 1;
++        do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);
++      }
++      else
++      {
++        unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
++        unsigned offs = 0x100;
++        state -= (state < 10) ? 3 : 6;
++        symbol = 1;
++        do
++        {
++          unsigned bit;
++          CLzmaProb *probLit;
++          matchByte <<= 1;
++          bit = (matchByte & offs);
++          probLit = prob + offs + bit + symbol;
++          GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
++        }
++        while (symbol < 0x100);
++      }
++      dic[dicPos++] = (Byte)symbol;
++      processedPos++;
++      continue;
++    }
++    else
++    {
++      UPDATE_1(prob);
++      prob = probs + IsRep + state;
++      IF_BIT_0(prob)
++      {
++        UPDATE_0(prob);
++        state += kNumStates;
++        prob = probs + LenCoder;
++      }
++      else
++      {
++        UPDATE_1(prob);
++        if (checkDicSize == 0 && processedPos == 0)
++          return SZ_ERROR_DATA;
++        prob = probs + IsRepG0 + state;
++        IF_BIT_0(prob)
++        {
++          UPDATE_0(prob);
++          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
++          IF_BIT_0(prob)
++          {
++            UPDATE_0(prob);
++            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
++            dicPos++;
++            processedPos++;
++            state = state < kNumLitStates ? 9 : 11;
++            continue;
++          }
++          UPDATE_1(prob);
++        }
++        else
++        {
++          UInt32 distance;
++          UPDATE_1(prob);
++          prob = probs + IsRepG1 + state;
++          IF_BIT_0(prob)
++          {
++            UPDATE_0(prob);
++            distance = rep1;
++          }
++          else
++          {
++            UPDATE_1(prob);
++            prob = probs + IsRepG2 + state;
++            IF_BIT_0(prob)
++            {
++              UPDATE_0(prob);
++              distance = rep2;
++            }
++            else
++            {
++              UPDATE_1(prob);
++              distance = rep3;
++              rep3 = rep2;
++            }
++            rep2 = rep1;
++          }
++          rep1 = rep0;
++          rep0 = distance;
++        }
++        state = state < kNumLitStates ? 8 : 11;
++        prob = probs + RepLenCoder;
++      }
++      {
++        unsigned limit, offset;
++        CLzmaProb *probLen = prob + LenChoice;
++        IF_BIT_0(probLen)
++        {
++          UPDATE_0(probLen);
++          probLen = prob + LenLow + (posState << kLenNumLowBits);
++          offset = 0;
++          limit = (1 << kLenNumLowBits);
++        }
++        else
++        {
++          UPDATE_1(probLen);
++          probLen = prob + LenChoice2;
++          IF_BIT_0(probLen)
++          {
++            UPDATE_0(probLen);
++            probLen = prob + LenMid + (posState << kLenNumMidBits);
++            offset = kLenNumLowSymbols;
++            limit = (1 << kLenNumMidBits);
++          }
++          else
++          {
++            UPDATE_1(probLen);
++            probLen = prob + LenHigh;
++            offset = kLenNumLowSymbols + kLenNumMidSymbols;
++            limit = (1 << kLenNumHighBits);
++          }
++        }
++        TREE_DECODE(probLen, limit, len);
++        len += offset;
++      }
++
++      if (state >= kNumStates)
++      {
++        UInt32 distance;
++        prob = probs + PosSlot +
++            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
++        TREE_6_DECODE(prob, distance);
++        if (distance >= kStartPosModelIndex)
++        {
++          unsigned posSlot = (unsigned)distance;
++          int numDirectBits = (int)(((distance >> 1) - 1));
++          distance = (2 | (distance & 1));
++          if (posSlot < kEndPosModelIndex)
++          {
++            distance <<= numDirectBits;
++            prob = probs + SpecPos + distance - posSlot - 1;
++            {
++              UInt32 mask = 1;
++              unsigned i = 1;
++              do
++              {
++                GET_BIT2(prob + i, i, ; , distance |= mask);
++                mask <<= 1;
++              }
++              while (--numDirectBits != 0);
++            }
++          }
++          else
++          {
++            numDirectBits -= kNumAlignBits;
++            do
++            {
++              NORMALIZE
++              range >>= 1;
++              
++              {
++                UInt32 t;
++                code -= range;
++                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
++                distance = (distance << 1) + (t + 1);
++                code += range & t;
++              }
++              /*
++              distance <<= 1;
++              if (code >= range)
++              {
++                code -= range;
++                distance |= 1;
++              }
++              */
++            }
++            while (--numDirectBits != 0);
++            prob = probs + Align;
++            distance <<= kNumAlignBits;
++            {
++              unsigned i = 1;
++              GET_BIT2(prob + i, i, ; , distance |= 1);
++              GET_BIT2(prob + i, i, ; , distance |= 2);
++              GET_BIT2(prob + i, i, ; , distance |= 4);
++              GET_BIT2(prob + i, i, ; , distance |= 8);
++            }
++            if (distance == (UInt32)0xFFFFFFFF)
++            {
++              len += kMatchSpecLenStart;
++              state -= kNumStates;
++              break;
++            }
++          }
++        }
++        rep3 = rep2;
++        rep2 = rep1;
++        rep1 = rep0;
++        rep0 = distance + 1;
++        if (checkDicSize == 0)
++        {
++          if (distance >= processedPos)
++            return SZ_ERROR_DATA;
++        }
++        else if (distance >= checkDicSize)
++          return SZ_ERROR_DATA;
++        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
++      }
++
++      len += kMatchMinLen;
++
++      if (limit == dicPos)
++        return SZ_ERROR_DATA;
++      {
++        SizeT rem = limit - dicPos;
++        unsigned curLen = ((rem < len) ? (unsigned)rem : len);
++        SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);
++
++        processedPos += curLen;
++
++        len -= curLen;
++        if (pos + curLen <= dicBufSize)
++        {
++          Byte *dest = dic + dicPos;
++          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
++          const Byte *lim = dest + curLen;
++          dicPos += curLen;
++          do
++            *(dest) = (Byte)*(dest + src);
++          while (++dest != lim);
++        }
++        else
++        {
++          do
++          {
++            dic[dicPos++] = dic[pos];
++            if (++pos == dicBufSize)
++              pos = 0;
++          }
++          while (--curLen != 0);
++        }
++      }
++    }
++  }
++  while (dicPos < limit && buf < bufLimit);
++  NORMALIZE;
++  p->buf = buf;
++  p->range = range;
++  p->code = code;
++  p->remainLen = len;
++  p->dicPos = dicPos;
++  p->processedPos = processedPos;
++  p->reps[0] = rep0;
++  p->reps[1] = rep1;
++  p->reps[2] = rep2;
++  p->reps[3] = rep3;
++  p->state = state;
++
++  return SZ_OK;
++}
++
++static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
++{
++  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
++  {
++    Byte *dic = p->dic;
++    SizeT dicPos = p->dicPos;
++    SizeT dicBufSize = p->dicBufSize;
++    unsigned len = p->remainLen;
++    UInt32 rep0 = p->reps[0];
++    if (limit - dicPos < len)
++      len = (unsigned)(limit - dicPos);
++
++    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
++      p->checkDicSize = p->prop.dicSize;
++
++    p->processedPos += len;
++    p->remainLen -= len;
++    while (len-- != 0)
++    {
++      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
++      dicPos++;
++    }
++    p->dicPos = dicPos;
++  }
++}
++
++static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
++{
++  do
++  {
++    SizeT limit2 = limit;
++    if (p->checkDicSize == 0)
++    {
++      UInt32 rem = p->prop.dicSize - p->processedPos;
++      if (limit - p->dicPos > rem)
++        limit2 = p->dicPos + rem;
++    }
++    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
++    if (p->processedPos >= p->prop.dicSize)
++      p->checkDicSize = p->prop.dicSize;
++    LzmaDec_WriteRem(p, limit);
++  }
++  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);
++
++  if (p->remainLen > kMatchSpecLenStart)
++  {
++    p->remainLen = kMatchSpecLenStart;
++  }
++  return 0;
++}
++
++typedef enum
++{
++  DUMMY_ERROR, /* unexpected end of input stream */
++  DUMMY_LIT,
++  DUMMY_MATCH,
++  DUMMY_REP
++} ELzmaDummy;
++
++static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
++{
++  UInt32 range = p->range;
++  UInt32 code = p->code;
++  const Byte *bufLimit = buf + inSize;
++  CLzmaProb *probs = p->probs;
++  unsigned state = p->state;
++  ELzmaDummy res;
++
++  {
++    CLzmaProb *prob;
++    UInt32 bound;
++    unsigned ttt;
++    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);
++
++    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
++    IF_BIT_0_CHECK(prob)
++    {
++      UPDATE_0_CHECK
++
++      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
++
++      prob = probs + Literal;
++      if (p->checkDicSize != 0 || p->processedPos != 0)
++        prob += (LZMA_LIT_SIZE *
++          ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
++          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));
++
++      if (state < kNumLitStates)
++      {
++        unsigned symbol = 1;
++        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
++      }
++      else
++      {
++        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
++            ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
++        unsigned offs = 0x100;
++        unsigned symbol = 1;
++        do
++        {
++          unsigned bit;
++          CLzmaProb *probLit;
++          matchByte <<= 1;
++          bit = (matchByte & offs);
++          probLit = prob + offs + bit + symbol;
++          GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
++        }
++        while (symbol < 0x100);
++      }
++      res = DUMMY_LIT;
++    }
++    else
++    {
++      unsigned len;
++      UPDATE_1_CHECK;
++
++      prob = probs + IsRep + state;
++      IF_BIT_0_CHECK(prob)
++      {
++        UPDATE_0_CHECK;
++        state = 0;
++        prob = probs + LenCoder;
++        res = DUMMY_MATCH;
++      }
++      else
++      {
++        UPDATE_1_CHECK;
++        res = DUMMY_REP;
++        prob = probs + IsRepG0 + state;
++        IF_BIT_0_CHECK(prob)
++        {
++          UPDATE_0_CHECK;
++          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
++          IF_BIT_0_CHECK(prob)
++          {
++            UPDATE_0_CHECK;
++            NORMALIZE_CHECK;
++            return DUMMY_REP;
++          }
++          else
++          {
++            UPDATE_1_CHECK;
++          }
++        }
++        else
++        {
++          UPDATE_1_CHECK;
++          prob = probs + IsRepG1 + state;
++          IF_BIT_0_CHECK(prob)
++          {
++            UPDATE_0_CHECK;
++          }
++          else
++          {
++            UPDATE_1_CHECK;
++            prob = probs + IsRepG2 + state;
++            IF_BIT_0_CHECK(prob)
++            {
++              UPDATE_0_CHECK;
++            }
++            else
++            {
++              UPDATE_1_CHECK;
++            }
++          }
++        }
++        state = kNumStates;
++        prob = probs + RepLenCoder;
++      }
++      {
++        unsigned limit, offset;
++        CLzmaProb *probLen = prob + LenChoice;
++        IF_BIT_0_CHECK(probLen)
++        {
++          UPDATE_0_CHECK;
++          probLen = prob + LenLow + (posState << kLenNumLowBits);
++          offset = 0;
++          limit = 1 << kLenNumLowBits;
++        }
++        else
++        {
++          UPDATE_1_CHECK;
++          probLen = prob + LenChoice2;
++          IF_BIT_0_CHECK(probLen)
++          {
++            UPDATE_0_CHECK;
++            probLen = prob + LenMid + (posState << kLenNumMidBits);
++            offset = kLenNumLowSymbols;
++            limit = 1 << kLenNumMidBits;
++          }
++          else
++          {
++            UPDATE_1_CHECK;
++            probLen = prob + LenHigh;
++            offset = kLenNumLowSymbols + kLenNumMidSymbols;
++            limit = 1 << kLenNumHighBits;
++          }
++        }
++        TREE_DECODE_CHECK(probLen, limit, len);
++        len += offset;
++      }
++
++      if (state < 4)
++      {
++        unsigned posSlot;
++        prob = probs + PosSlot +
++            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
++            kNumPosSlotBits);
++        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
++        if (posSlot >= kStartPosModelIndex)
++        {
++          int numDirectBits = ((posSlot >> 1) - 1);
++
++          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
++
++          if (posSlot < kEndPosModelIndex)
++          {
++            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
++          }
++          else
++          {
++            numDirectBits -= kNumAlignBits;
++            do
++            {
++              NORMALIZE_CHECK
++              range >>= 1;
++              code -= range & (((code - range) >> 31) - 1);
++              /* if (code >= range) code -= range; */
++            }
++            while (--numDirectBits != 0);
++            prob = probs + Align;
++            numDirectBits = kNumAlignBits;
++          }
++          {
++            unsigned i = 1;
++            do
++            {
++              GET_BIT_CHECK(prob + i, i);
++            }
++            while (--numDirectBits != 0);
++          }
++        }
++      }
++    }
++  }
++  NORMALIZE_CHECK;
++  return res;
++}
++
++
++static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
++{
++  p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
++  p->range = 0xFFFFFFFF;
++  p->needFlush = 0;
++}
++
++void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
++{
++  p->needFlush = 1;
++  p->remainLen = 0;
++  p->tempBufSize = 0;
++
++  if (initDic)
++  {
++    p->processedPos = 0;
++    p->checkDicSize = 0;
++    p->needInitState = 1;
++  }
++  if (initState)
++    p->needInitState = 1;
++}
++
++void LzmaDec_Init(CLzmaDec *p)
++{
++  p->dicPos = 0;
++  LzmaDec_InitDicAndState(p, True, True);
++}
++
++static void LzmaDec_InitStateReal(CLzmaDec *p)
++{
++  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
++  UInt32 i;
++  CLzmaProb *probs = p->probs;
++  for (i = 0; i < numProbs; i++)
++    probs[i] = kBitModelTotal >> 1;
++  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
++  p->state = 0;
++  p->needInitState = 0;
++}
++
++SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
++    ELzmaFinishMode finishMode, ELzmaStatus *status)
++{
++  SizeT inSize = *srcLen;
++  (*srcLen) = 0;
++  LzmaDec_WriteRem(p, dicLimit);
++  
++  *status = LZMA_STATUS_NOT_SPECIFIED;
++
++  while (p->remainLen != kMatchSpecLenStart)
++  {
++      int checkEndMarkNow;
++
++      if (p->needFlush != 0)
++      {
++        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
++          p->tempBuf[p->tempBufSize++] = *src++;
++        if (p->tempBufSize < RC_INIT_SIZE)
++        {
++          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
++          return SZ_OK;
++        }
++        if (p->tempBuf[0] != 0)
++          return SZ_ERROR_DATA;
++
++        LzmaDec_InitRc(p, p->tempBuf);
++        p->tempBufSize = 0;
++      }
++
++      checkEndMarkNow = 0;
++      if (p->dicPos >= dicLimit)
++      {
++        if (p->remainLen == 0 && p->code == 0)
++        {
++          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
++          return SZ_OK;
++        }
++        if (finishMode == LZMA_FINISH_ANY)
++        {
++          *status = LZMA_STATUS_NOT_FINISHED;
++          return SZ_OK;
++        }
++        if (p->remainLen != 0)
++        {
++          *status = LZMA_STATUS_NOT_FINISHED;
++          return SZ_ERROR_DATA;
++        }
++        checkEndMarkNow = 1;
++      }
++
++      if (p->needInitState)
++        LzmaDec_InitStateReal(p);
++  
++      if (p->tempBufSize == 0)
++      {
++        SizeT processed;
++        const Byte *bufLimit;
++        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
++        {
++          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
++          if (dummyRes == DUMMY_ERROR)
++          {
++            memcpy(p->tempBuf, src, inSize);
++            p->tempBufSize = (unsigned)inSize;
++            (*srcLen) += inSize;
++            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
++            return SZ_OK;
++          }
++          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
++          {
++            *status = LZMA_STATUS_NOT_FINISHED;
++            return SZ_ERROR_DATA;
++          }
++          bufLimit = src;
++        }
++        else
++          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
++        p->buf = src;
++        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
++          return SZ_ERROR_DATA;
++        processed = (SizeT)(p->buf - src);
++        (*srcLen) += processed;
++        src += processed;
++        inSize -= processed;
++      }
++      else
++      {
++        unsigned rem = p->tempBufSize, lookAhead = 0;
++        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
++          p->tempBuf[rem++] = src[lookAhead++];
++        p->tempBufSize = rem;
++        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
++        {
++          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
++          if (dummyRes == DUMMY_ERROR)
++          {
++            (*srcLen) += lookAhead;
++            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
++            return SZ_OK;
++          }
++          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
++          {
++            *status = LZMA_STATUS_NOT_FINISHED;
++            return SZ_ERROR_DATA;
++          }
++        }
++        p->buf = p->tempBuf;
++        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
++          return SZ_ERROR_DATA;
++        lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
++        (*srcLen) += lookAhead;
++        src += lookAhead;
++        inSize -= lookAhead;
++        p->tempBufSize = 0;
++      }
++  }
++  if (p->code == 0)
++    *status = LZMA_STATUS_FINISHED_WITH_MARK;
++  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
++}
++
++SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
++{
++  SizeT outSize = *destLen;
++  SizeT inSize = *srcLen;
++  *srcLen = *destLen = 0;
++  for (;;)
++  {
++    SizeT inSizeCur = inSize, outSizeCur, dicPos;
++    ELzmaFinishMode curFinishMode;
++    SRes res;
++    if (p->dicPos == p->dicBufSize)
++      p->dicPos = 0;
++    dicPos = p->dicPos;
++    if (outSize > p->dicBufSize - dicPos)
++    {
++      outSizeCur = p->dicBufSize;
++      curFinishMode = LZMA_FINISH_ANY;
++    }
++    else
++    {
++      outSizeCur = dicPos + outSize;
++      curFinishMode = finishMode;
++    }
++
++    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
++    src += inSizeCur;
++    inSize -= inSizeCur;
++    *srcLen += inSizeCur;
++    outSizeCur = p->dicPos - dicPos;
++    memcpy(dest, p->dic + dicPos, outSizeCur);
++    dest += outSizeCur;
++    outSize -= outSizeCur;
++    *destLen += outSizeCur;
++    if (res != 0)
++      return res;
++    if (outSizeCur == 0 || outSize == 0)
++      return SZ_OK;
++  }
++}
++
++void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->probs);
++  p->probs = 0;
++}
++
++static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->dic);
++  p->dic = 0;
++}
++
++void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
++{
++  LzmaDec_FreeProbs(p, alloc);
++  LzmaDec_FreeDict(p, alloc);
++}
++
++SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
++{
++  UInt32 dicSize;
++  Byte d;
++  
++  if (size < LZMA_PROPS_SIZE)
++    return SZ_ERROR_UNSUPPORTED;
++  else
++    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);
++ 
++  if (dicSize < LZMA_DIC_MIN)
++    dicSize = LZMA_DIC_MIN;
++  p->dicSize = dicSize;
++
++  d = data[0];
++  if (d >= (9 * 5 * 5))
++    return SZ_ERROR_UNSUPPORTED;
++
++  p->lc = d % 9;
++  d /= 9;
++  p->pb = d / 5;
++  p->lp = d % 5;
++
++  return SZ_OK;
++}
++
++static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
++{
++  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
++  if (p->probs == 0 || numProbs != p->numProbs)
++  {
++    LzmaDec_FreeProbs(p, alloc);
++    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
++    p->numProbs = numProbs;
++    if (p->probs == 0)
++      return SZ_ERROR_MEM;
++  }
++  return SZ_OK;
++}
++
++SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
++{
++  CLzmaProps propNew;
++  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
++  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
++  p->prop = propNew;
++  return SZ_OK;
++}
++
++SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
++{
++  CLzmaProps propNew;
++  SizeT dicBufSize;
++  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
++  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
++  dicBufSize = propNew.dicSize;
++  if (p->dic == 0 || dicBufSize != p->dicBufSize)
++  {
++    LzmaDec_FreeDict(p, alloc);
++    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
++    if (p->dic == 0)
++    {
++      LzmaDec_FreeProbs(p, alloc);
++      return SZ_ERROR_MEM;
++    }
++  }
++  p->dicBufSize = dicBufSize;
++  p->prop = propNew;
++  return SZ_OK;
++}
++
++SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
++    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
++    ELzmaStatus *status, ISzAlloc *alloc)
++{
++  CLzmaDec p;
++  SRes res;
++  SizeT inSize = *srcLen;
++  SizeT outSize = *destLen;
++  *srcLen = *destLen = 0;
++  if (inSize < RC_INIT_SIZE)
++    return SZ_ERROR_INPUT_EOF;
++
++  LzmaDec_Construct(&p);
++  res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
++  if (res != 0)
++    return res;
++  p.dic = dest;
++  p.dicBufSize = outSize;
++
++  LzmaDec_Init(&p);
++  
++  *srcLen = inSize;
++  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
++
++  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
++    res = SZ_ERROR_INPUT_EOF;
++
++  (*destLen) = p.dicPos;
++  LzmaDec_FreeProbs(&p, alloc);
++  return res;
++}
+Index: kernel_tree/lib/lzma/LzmaEnc.c
+===================================================================
+--- /dev/null
++++ kernel_tree/lib/lzma/LzmaEnc.c
+@@ -0,0 +1,2271 @@
++/* LzmaEnc.c -- LZMA Encoder
++2009-11-24 : Igor Pavlov : Public domain */
++
++#include <string.h>
++
++/* #define SHOW_STAT */
++/* #define SHOW_STAT2 */
++
++#if defined(SHOW_STAT) || defined(SHOW_STAT2)
++#include <stdio.h>
++#endif
++
++#include "LzmaEnc.h"
++
++/* disable MT */
++#define _7ZIP_ST
++
++#include "LzFind.h"
++#ifndef _7ZIP_ST
++#include "LzFindMt.h"
++#endif
++
++#ifdef SHOW_STAT
++static int ttt = 0;
++#endif
++
++#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)
++
++#define kBlockSize (9 << 10)
++#define kUnpackBlockSize (1 << 18)
++#define kMatchArraySize (1 << 21)
++#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
++
++#define kNumMaxDirectBits (31)
++
++#define kNumTopBits 24
++#define kTopValue ((UInt32)1 << kNumTopBits)
++
++#define kNumBitModelTotalBits 11
++#define kBitModelTotal (1 << kNumBitModelTotalBits)
++#define kNumMoveBits 5
++#define kProbInitValue (kBitModelTotal >> 1)
++
++#define kNumMoveReducingBits 4
++#define kNumBitPriceShiftBits 4
++#define kBitPrice (1 << kNumBitPriceShiftBits)
++
++void LzmaEncProps_Init(CLzmaEncProps *p)
++{
++  p->level = 5;
++  p->dictSize = p->mc = 0;
++  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
++  p->writeEndMark = 0;
++}
++
++void LzmaEncProps_Normalize(CLzmaEncProps *p)
++{
++  int level = p->level;
++  if (level < 0) level = 5;
++  p->level = level;
++  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
++  if (p->lc < 0) p->lc = 3;
++  if (p->lp < 0) p->lp = 0;
++  if (p->pb < 0) p->pb = 2;
++  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
++  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
++  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
++  if (p->numHashBytes < 0) p->numHashBytes = 4;
++  if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
++  if (p->numThreads < 0)
++    p->numThreads =
++      #ifndef _7ZIP_ST
++      ((p->btMode && p->algo) ? 2 : 1);
++      #else
++      1;
++      #endif
++}
++
++UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
++{
++  CLzmaEncProps props = *props2;
++  LzmaEncProps_Normalize(&props);
++  return props.dictSize;
++}
++
++/* #define LZMA_LOG_BSR */
++/* Define it for Intel's CPU */
++
++
++#ifdef LZMA_LOG_BSR
++
++#define kDicLogSizeMaxCompress 30
++
++#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
++
++UInt32 GetPosSlot1(UInt32 pos)
++{
++  UInt32 res;
++  BSR2_RET(pos, res);
++  return res;
++}
++#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
++#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }
++
++#else
++
++#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
++#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
++
++void LzmaEnc_FastPosInit(Byte *g_FastPos)
++{
++  int c = 2, slotFast;
++  g_FastPos[0] = 0;
++  g_FastPos[1] = 1;
++  
++  for (slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)
++  {
++    UInt32 k = (1 << ((slotFast >> 1) - 1));
++    UInt32 j;
++    for (j = 0; j < k; j++, c++)
++      g_FastPos[c] = (Byte)slotFast;
++  }
++}
++
++#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
++  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
++  res = p->g_FastPos[pos >> i] + (i * 2); }
++/*
++#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
++  p->g_FastPos[pos >> 6] + 12 : \
++  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
++*/
++
++#define GetPosSlot1(pos) p->g_FastPos[pos]
++#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
++#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }
++
++#endif
++
++
++#define LZMA_NUM_REPS 4
++
++typedef unsigned CState;
++
++typedef struct
++{
++  UInt32 price;
++
++  CState state;
++  int prev1IsChar;
++  int prev2;
++
++  UInt32 posPrev2;
++  UInt32 backPrev2;
++
++  UInt32 posPrev;
++  UInt32 backPrev;
++  UInt32 backs[LZMA_NUM_REPS];
++} COptimal;
++
++#define kNumOpts (1 << 12)
++
++#define kNumLenToPosStates 4
++#define kNumPosSlotBits 6
++#define kDicLogSizeMin 0
++#define kDicLogSizeMax 32
++#define kDistTableSizeMax (kDicLogSizeMax * 2)
++
++
++#define kNumAlignBits 4
++#define kAlignTableSize (1 << kNumAlignBits)
++#define kAlignMask (kAlignTableSize - 1)
++
++#define kStartPosModelIndex 4
++#define kEndPosModelIndex 14
++#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
++
++#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
++
++#ifdef _LZMA_PROB32
++#define CLzmaProb UInt32
++#else
++#define CLzmaProb UInt16
++#endif
++
++#define LZMA_PB_MAX 4
++#define LZMA_LC_MAX 8
++#define LZMA_LP_MAX 4
++
++#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)
++
++
++#define kLenNumLowBits 3
++#define kLenNumLowSymbols (1 << kLenNumLowBits)
++#define kLenNumMidBits 3
++#define kLenNumMidSymbols (1 << kLenNumMidBits)
++#define kLenNumHighBits 8
++#define kLenNumHighSymbols (1 << kLenNumHighBits)
++
++#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
++
++#define LZMA_MATCH_LEN_MIN 2
++#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
++
++#define kNumStates 12
++
++typedef struct
++{
++  CLzmaProb choice;
++  CLzmaProb choice2;
++  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
++  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
++  CLzmaProb high[kLenNumHighSymbols];
++} CLenEnc;
++
++typedef struct
++{
++  CLenEnc p;
++  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
++  UInt32 tableSize;
++  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
++} CLenPriceEnc;
++
++typedef struct
++{
++  UInt32 range;
++  Byte cache;
++  UInt64 low;
++  UInt64 cacheSize;
++  Byte *buf;
++  Byte *bufLim;
++  Byte *bufBase;
++  ISeqOutStream *outStream;
++  UInt64 processed;
++  SRes res;
++} CRangeEnc;
++
++typedef struct
++{
++  CLzmaProb *litProbs;
++
++  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
++  CLzmaProb isRep[kNumStates];
++  CLzmaProb isRepG0[kNumStates];
++  CLzmaProb isRepG1[kNumStates];
++  CLzmaProb isRepG2[kNumStates];
++  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
++
++  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
++  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
++  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
++  
++  CLenPriceEnc lenEnc;
++  CLenPriceEnc repLenEnc;
++
++  UInt32 reps[LZMA_NUM_REPS];
++  UInt32 state;
++} CSaveState;
++
++typedef struct
++{
++  IMatchFinder matchFinder;
++  void *matchFinderObj;
++
++  #ifndef _7ZIP_ST
++  Bool mtMode;
++  CMatchFinderMt matchFinderMt;
++  #endif
++
++  CMatchFinder matchFinderBase;
++
++  #ifndef _7ZIP_ST
++  Byte pad[128];
++  #endif
++  
++  UInt32 optimumEndIndex;
++  UInt32 optimumCurrentIndex;
++
++  UInt32 longestMatchLength;
++  UInt32 numPairs;
++  UInt32 numAvail;
++  COptimal opt[kNumOpts];
++  
++  #ifndef LZMA_LOG_BSR
++  Byte g_FastPos[1 << kNumLogBits];
++  #endif
++
++  UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
++  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
++  UInt32 numFastBytes;
++  UInt32 additionalOffset;
++  UInt32 reps[LZMA_NUM_REPS];
++  UInt32 state;
++
++  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
++  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
++  UInt32 alignPrices[kAlignTableSize];
++  UInt32 alignPriceCount;
++
++  UInt32 distTableSize;
++
++  unsigned lc, lp, pb;
++  unsigned lpMask, pbMask;
++
++  CLzmaProb *litProbs;
++
++  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
++  CLzmaProb isRep[kNumStates];
++  CLzmaProb isRepG0[kNumStates];
++  CLzmaProb isRepG1[kNumStates];
++  CLzmaProb isRepG2[kNumStates];
++  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
++
++  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
++  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
++  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
++  
++  CLenPriceEnc lenEnc;
++  CLenPriceEnc repLenEnc;
++
++  unsigned lclp;
++
++  Bool fastMode;
++  
++  CRangeEnc rc;
++
++  Bool writeEndMark;
++  UInt64 nowPos64;
++  UInt32 matchPriceCount;
++  Bool finished;
++  Bool multiThread;
++
++  SRes result;
++  UInt32 dictSize;
++  UInt32 matchFinderCycles;
++
++  int needInit;
++
++  CSaveState saveState;
++} CLzmaEnc;
++
++void LzmaEnc_SaveState(CLzmaEncHandle pp)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  CSaveState *dest = &p->saveState;
++  int i;
++  dest->lenEnc = p->lenEnc;
++  dest->repLenEnc = p->repLenEnc;
++  dest->state = p->state;
++
++  for (i = 0; i < kNumStates; i++)
++  {
++    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
++    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
++  }
++  for (i = 0; i < kNumLenToPosStates; i++)
++    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
++  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
++  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
++  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
++  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
++  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
++  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
++  memcpy(dest->reps, p->reps, sizeof(p->reps));
++  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
++}
++
++void LzmaEnc_RestoreState(CLzmaEncHandle pp)
++{
++  CLzmaEnc *dest = (CLzmaEnc *)pp;
++  const CSaveState *p = &dest->saveState;
++  int i;
++  dest->lenEnc = p->lenEnc;
++  dest->repLenEnc = p->repLenEnc;
++  dest->state = p->state;
++
++  for (i = 0; i < kNumStates; i++)
++  {
++    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
++    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
++  }
++  for (i = 0; i < kNumLenToPosStates; i++)
++    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
++  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
++  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
++  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
++  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
++  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
++  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
++  memcpy(dest->reps, p->reps, sizeof(p->reps));
++  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
++}
++
++SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  CLzmaEncProps props = *props2;
++  LzmaEncProps_Normalize(&props);
++
++  if (props.lc > LZMA_LC_MAX || props.lp > LZMA_LP_MAX || props.pb > LZMA_PB_MAX ||
++      props.dictSize > (1 << kDicLogSizeMaxCompress) || props.dictSize > (1 << 30))
++    return SZ_ERROR_PARAM;
++  p->dictSize = props.dictSize;
++  p->matchFinderCycles = props.mc;
++  {
++    unsigned fb = props.fb;
++    if (fb < 5)
++      fb = 5;
++    if (fb > LZMA_MATCH_LEN_MAX)
++      fb = LZMA_MATCH_LEN_MAX;
++    p->numFastBytes = fb;
++  }
++  p->lc = props.lc;
++  p->lp = props.lp;
++  p->pb = props.pb;
++  p->fastMode = (props.algo == 0);
++  p->matchFinderBase.btMode = props.btMode;
++  {
++    UInt32 numHashBytes = 4;
++    if (props.btMode)
++    {
++      if (props.numHashBytes < 2)
++        numHashBytes = 2;
++      else if (props.numHashBytes < 4)
++        numHashBytes = props.numHashBytes;
++    }
++    p->matchFinderBase.numHashBytes = numHashBytes;
++  }
++
++  p->matchFinderBase.cutValue = props.mc;
++
++  p->writeEndMark = props.writeEndMark;
++
++  #ifndef _7ZIP_ST
++  /*
++  if (newMultiThread != _multiThread)
++  {
++    ReleaseMatchFinder();
++    _multiThread = newMultiThread;
++  }
++  */
++  p->multiThread = (props.numThreads > 1);
++  #endif
++
++  return SZ_OK;
++}
++
++static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
++static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
++static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
++static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
++
++#define IsCharState(s) ((s) < 7)
++
++#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
++
++#define kInfinityPrice (1 << 30)
++
++static void RangeEnc_Construct(CRangeEnc *p)
++{
++  p->outStream = 0;
++  p->bufBase = 0;
++}
++
++#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)
++
++#define RC_BUF_SIZE (1 << 16)
++static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
++{
++  if (p->bufBase == 0)
++  {
++    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
++    if (p->bufBase == 0)
++      return 0;
++    p->bufLim = p->bufBase + RC_BUF_SIZE;
++  }
++  return 1;
++}
++
++static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->bufBase);
++  p->bufBase = 0;
++}
++
++static void RangeEnc_Init(CRangeEnc *p)
++{
++  /* Stream.Init(); */
++  p->low = 0;
++  p->range = 0xFFFFFFFF;
++  p->cacheSize = 1;
++  p->cache = 0;
++
++  p->buf = p->bufBase;
++
++  p->processed = 0;
++  p->res = SZ_OK;
++}
++
++static void RangeEnc_FlushStream(CRangeEnc *p)
++{
++  size_t num;
++  if (p->res != SZ_OK)
++    return;
++  num = p->buf - p->bufBase;
++  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
++    p->res = SZ_ERROR_WRITE;
++  p->processed += num;
++  p->buf = p->bufBase;
++}
++
++static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
++{
++  if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
++  {
++    Byte temp = p->cache;
++    do
++    {
++      Byte *buf = p->buf;
++      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
++      p->buf = buf;
++      if (buf == p->bufLim)
++        RangeEnc_FlushStream(p);
++      temp = 0xFF;
++    }
++    while (--p->cacheSize != 0);
++    p->cache = (Byte)((UInt32)p->low >> 24);
++  }
++  p->cacheSize++;
++  p->low = (UInt32)p->low << 8;
++}
++
++static void RangeEnc_FlushData(CRangeEnc *p)
++{
++  int i;
++  for (i = 0; i < 5; i++)
++    RangeEnc_ShiftLow(p);
++}
++
++static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
++{
++  do
++  {
++    p->range >>= 1;
++    p->low += p->range & (0 - ((value >> --numBits) & 1));
++    if (p->range < kTopValue)
++    {
++      p->range <<= 8;
++      RangeEnc_ShiftLow(p);
++    }
++  }
++  while (numBits != 0);
++}
++
++static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
++{
++  UInt32 ttt = *prob;
++  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
++  if (symbol == 0)
++  {
++    p->range = newBound;
++    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
++  }
++  else
++  {
++    p->low += newBound;
++    p->range -= newBound;
++    ttt -= ttt >> kNumMoveBits;
++  }
++  *prob = (CLzmaProb)ttt;
++  if (p->range < kTopValue)
++  {
++    p->range <<= 8;
++    RangeEnc_ShiftLow(p);
++  }
++}
++
++static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
++{
++  symbol |= 0x100;
++  do
++  {
++    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
++    symbol <<= 1;
++  }
++  while (symbol < 0x10000);
++}
++
++static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
++{
++  UInt32 offs = 0x100;
++  symbol |= 0x100;
++  do
++  {
++    matchByte <<= 1;
++    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
++    symbol <<= 1;
++    offs &= ~(matchByte ^ symbol);
++  }
++  while (symbol < 0x10000);
++}
++
++void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
++{
++  UInt32 i;
++  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
++  {
++    const int kCyclesBits = kNumBitPriceShiftBits;
++    UInt32 w = i;
++    UInt32 bitCount = 0;
++    int j;
++    for (j = 0; j < kCyclesBits; j++)
++    {
++      w = w * w;
++      bitCount <<= 1;
++      while (w >= ((UInt32)1 << 16))
++      {
++        w >>= 1;
++        bitCount++;
++      }
++    }
++    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
++  }
++}
++
++
++#define GET_PRICE(prob, symbol) \
++  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
++
++#define GET_PRICEa(prob, symbol) \
++  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
++
++#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
++#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
++
++#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
++#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
++
++static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  symbol |= 0x100;
++  do
++  {
++    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
++    symbol <<= 1;
++  }
++  while (symbol < 0x10000);
++  return price;
++}
++
++static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  UInt32 offs = 0x100;
++  symbol |= 0x100;
++  do
++  {
++    matchByte <<= 1;
++    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
++    symbol <<= 1;
++    offs &= ~(matchByte ^ symbol);
++  }
++  while (symbol < 0x10000);
++  return price;
++}
++
++
++static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
++{
++  UInt32 m = 1;
++  int i;
++  for (i = numBitLevels; i != 0;)
++  {
++    UInt32 bit;
++    i--;
++    bit = (symbol >> i) & 1;
++    RangeEnc_EncodeBit(rc, probs + m, bit);
++    m = (m << 1) | bit;
++  }
++}
++
++static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
++{
++  UInt32 m = 1;
++  int i;
++  for (i = 0; i < numBitLevels; i++)
++  {
++    UInt32 bit = symbol & 1;
++    RangeEnc_EncodeBit(rc, probs + m, bit);
++    m = (m << 1) | bit;
++    symbol >>= 1;
++  }
++}
++
++static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  symbol |= (1 << numBitLevels);
++  while (symbol != 1)
++  {
++    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
++    symbol >>= 1;
++  }
++  return price;
++}
++
++static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
++{
++  UInt32 price = 0;
++  UInt32 m = 1;
++  int i;
++  for (i = numBitLevels; i != 0; i--)
++  {
++    UInt32 bit = symbol & 1;
++    symbol >>= 1;
++    price += GET_PRICEa(probs[m], bit);
++    m = (m << 1) | bit;
++  }
++  return price;
++}
++
++
++static void LenEnc_Init(CLenEnc *p)
++{
++  unsigned i;
++  p->choice = p->choice2 = kProbInitValue;
++  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
++    p->low[i] = kProbInitValue;
++  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
++    p->mid[i] = kProbInitValue;
++  for (i = 0; i < kLenNumHighSymbols; i++)
++    p->high[i] = kProbInitValue;
++}
++
++static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
++{
++  if (symbol < kLenNumLowSymbols)
++  {
++    RangeEnc_EncodeBit(rc, &p->choice, 0);
++    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
++  }
++  else
++  {
++    RangeEnc_EncodeBit(rc, &p->choice, 1);
++    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
++    {
++      RangeEnc_EncodeBit(rc, &p->choice2, 0);
++      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
++    }
++    else
++    {
++      RangeEnc_EncodeBit(rc, &p->choice2, 1);
++      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
++    }
++  }
++}
++
++static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
++{
++  UInt32 a0 = GET_PRICE_0a(p->choice);
++  UInt32 a1 = GET_PRICE_1a(p->choice);
++  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
++  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
++  UInt32 i = 0;
++  for (i = 0; i < kLenNumLowSymbols; i++)
++  {
++    if (i >= numSymbols)
++      return;
++    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
++  }
++  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
++  {
++    if (i >= numSymbols)
++      return;
++    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
++  }
++  for (; i < numSymbols; i++)
++    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
++}
++
++static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
++{
++  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
++  p->counters[posState] = p->tableSize;
++}
++
++static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
++{
++  UInt32 posState;
++  for (posState = 0; posState < numPosStates; posState++)
++    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
++}
++
++static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
++{
++  LenEnc_Encode(&p->p, rc, symbol, posState);
++  if (updatePrice)
++    if (--p->counters[posState] == 0)
++      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
++}
++
++
++
++
++static void MovePos(CLzmaEnc *p, UInt32 num)
++{
++  #ifdef SHOW_STAT
++  ttt += num;
++  printf("\n MovePos %d", num);
++  #endif
++  if (num != 0)
++  {
++    p->additionalOffset += num;
++    p->matchFinder.Skip(p->matchFinderObj, num);
++  }
++}
++
++static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
++{
++  UInt32 lenRes = 0, numPairs;
++  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
++  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
++  #ifdef SHOW_STAT
++  printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
++  ttt++;
++  {
++    UInt32 i;
++    for (i = 0; i < numPairs; i += 2)
++      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
++  }
++  #endif
++  if (numPairs > 0)
++  {
++    lenRes = p->matches[numPairs - 2];
++    if (lenRes == p->numFastBytes)
++    {
++      const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++      UInt32 distance = p->matches[numPairs - 1] + 1;
++      UInt32 numAvail = p->numAvail;
++      if (numAvail > LZMA_MATCH_LEN_MAX)
++        numAvail = LZMA_MATCH_LEN_MAX;
++      {
++        const Byte *pby2 = pby - distance;
++        for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
++      }
++    }
++  }
++  p->additionalOffset++;
++  *numDistancePairsRes = numPairs;
++  return lenRes;
++}
++
++
++#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
++#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
++#define IsShortRep(p) ((p)->backPrev == 0)
++
++static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
++{
++  return
++    GET_PRICE_0(p->isRepG0[state]) +
++    GET_PRICE_0(p->isRep0Long[state][posState]);
++}
++
++static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
++{
++  UInt32 price;
++  if (repIndex == 0)
++  {
++    price = GET_PRICE_0(p->isRepG0[state]);
++    price += GET_PRICE_1(p->isRep0Long[state][posState]);
++  }
++  else
++  {
++    price = GET_PRICE_1(p->isRepG0[state]);
++    if (repIndex == 1)
++      price += GET_PRICE_0(p->isRepG1[state]);
++    else
++    {
++      price += GET_PRICE_1(p->isRepG1[state]);
++      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
++    }
++  }
++  return price;
++}
++
++static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
++{
++  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
++    GetPureRepPrice(p, repIndex, state, posState);
++}
++
++static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
++{
++  UInt32 posMem = p->opt[cur].posPrev;
++  UInt32 backMem = p->opt[cur].backPrev;
++  p->optimumEndIndex = cur;
++  do
++  {
++    if (p->opt[cur].prev1IsChar)
++    {
++      MakeAsChar(&p->opt[posMem])
++      p->opt[posMem].posPrev = posMem - 1;
++      if (p->opt[cur].prev2)
++      {
++        p->opt[posMem - 1].prev1IsChar = False;
++        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
++        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
++      }
++    }
++    {
++      UInt32 posPrev = posMem;
++      UInt32 backCur = backMem;
++      
++      backMem = p->opt[posPrev].backPrev;
++      posMem = p->opt[posPrev].posPrev;
++      
++      p->opt[posPrev].backPrev = backCur;
++      p->opt[posPrev].posPrev = cur;
++      cur = posPrev;
++    }
++  }
++  while (cur != 0);
++  *backRes = p->opt[0].backPrev;
++  p->optimumCurrentIndex  = p->opt[0].posPrev;
++  return p->optimumCurrentIndex;
++}
++
++#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)
++
++static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
++{
++  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
++  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
++  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
++  UInt32 *matches;
++  const Byte *data;
++  Byte curByte, matchByte;
++  if (p->optimumEndIndex != p->optimumCurrentIndex)
++  {
++    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
++    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
++    *backRes = opt->backPrev;
++    p->optimumCurrentIndex = opt->posPrev;
++    return lenRes;
++  }
++  p->optimumCurrentIndex = p->optimumEndIndex = 0;
++  
++  if (p->additionalOffset == 0)
++    mainLen = ReadMatchDistances(p, &numPairs);
++  else
++  {
++    mainLen = p->longestMatchLength;
++    numPairs = p->numPairs;
++  }
++
++  numAvail = p->numAvail;
++  if (numAvail < 2)
++  {
++    *backRes = (UInt32)(-1);
++    return 1;
++  }
++  if (numAvail > LZMA_MATCH_LEN_MAX)
++    numAvail = LZMA_MATCH_LEN_MAX;
++
++  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++  repMaxIndex = 0;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 lenTest;
++    const Byte *data2;
++    reps[i] = p->reps[i];
++    data2 = data - (reps[i] + 1);
++    if (data[0] != data2[0] || data[1] != data2[1])
++    {
++      repLens[i] = 0;
++      continue;
++    }
++    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
++    repLens[i] = lenTest;
++    if (lenTest > repLens[repMaxIndex])
++      repMaxIndex = i;
++  }
++  if (repLens[repMaxIndex] >= p->numFastBytes)
++  {
++    UInt32 lenRes;
++    *backRes = repMaxIndex;
++    lenRes = repLens[repMaxIndex];
++    MovePos(p, lenRes - 1);
++    return lenRes;
++  }
++
++  matches = p->matches;
++  if (mainLen >= p->numFastBytes)
++  {
++    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
++    MovePos(p, mainLen - 1);
++    return mainLen;
++  }
++  curByte = *data;
++  matchByte = *(data - (reps[0] + 1));
++
++  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
++  {
++    *backRes = (UInt32)-1;
++    return 1;
++  }
++
++  p->opt[0].state = (CState)p->state;
++
++  posState = (position & p->pbMask);
++
++  {
++    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
++    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
++        (!IsCharState(p->state) ?
++          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
++          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
++  }
++
++  MakeAsChar(&p->opt[1]);
++
++  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
++  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
++
++  if (matchByte == curByte)
++  {
++    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
++    if (shortRepPrice < p->opt[1].price)
++    {
++      p->opt[1].price = shortRepPrice;
++      MakeAsShortRep(&p->opt[1]);
++    }
++  }
++  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
++
++  if (lenEnd < 2)
++  {
++    *backRes = p->opt[1].backPrev;
++    return 1;
++  }
++
++  p->opt[1].posPrev = 0;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++    p->opt[0].backs[i] = reps[i];
++
++  len = lenEnd;
++  do
++    p->opt[len--].price = kInfinityPrice;
++  while (len >= 2);
++
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 repLen = repLens[i];
++    UInt32 price;
++    if (repLen < 2)
++      continue;
++    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
++    do
++    {
++      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
++      COptimal *opt = &p->opt[repLen];
++      if (curAndLenPrice < opt->price)
++      {
++        opt->price = curAndLenPrice;
++        opt->posPrev = 0;
++        opt->backPrev = i;
++        opt->prev1IsChar = False;
++      }
++    }
++    while (--repLen >= 2);
++  }
++
++  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
++
++  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
++  if (len <= mainLen)
++  {
++    UInt32 offs = 0;
++    while (len > matches[offs])
++      offs += 2;
++    for (; ; len++)
++    {
++      COptimal *opt;
++      UInt32 distance = matches[offs + 1];
++
++      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
++      UInt32 lenToPosState = GetLenToPosState(len);
++      if (distance < kNumFullDistances)
++        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
++      else
++      {
++        UInt32 slot;
++        GetPosSlot2(distance, slot);
++        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
++      }
++      opt = &p->opt[len];
++      if (curAndLenPrice < opt->price)
++      {
++        opt->price = curAndLenPrice;
++        opt->posPrev = 0;
++        opt->backPrev = distance + LZMA_NUM_REPS;
++        opt->prev1IsChar = False;
++      }
++      if (len == matches[offs])
++      {
++        offs += 2;
++        if (offs == numPairs)
++          break;
++      }
++    }
++  }
++
++  cur = 0;
++
++    #ifdef SHOW_STAT2
++    if (position >= 0)
++    {
++      unsigned i;
++      printf("\n pos = %4X", position);
++      for (i = cur; i <= lenEnd; i++)
++      printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
++    }
++    #endif
++
++  for (;;)
++  {
++    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
++    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
++    Bool nextIsChar;
++    Byte curByte, matchByte;
++    const Byte *data;
++    COptimal *curOpt;
++    COptimal *nextOpt;
++
++    cur++;
++    if (cur == lenEnd)
++      return Backward(p, backRes, cur);
++
++    newLen = ReadMatchDistances(p, &numPairs);
++    if (newLen >= p->numFastBytes)
++    {
++      p->numPairs = numPairs;
++      p->longestMatchLength = newLen;
++      return Backward(p, backRes, cur);
++    }
++    position++;
++    curOpt = &p->opt[cur];
++    posPrev = curOpt->posPrev;
++    if (curOpt->prev1IsChar)
++    {
++      posPrev--;
++      if (curOpt->prev2)
++      {
++        state = p->opt[curOpt->posPrev2].state;
++        if (curOpt->backPrev2 < LZMA_NUM_REPS)
++          state = kRepNextStates[state];
++        else
++          state = kMatchNextStates[state];
++      }
++      else
++        state = p->opt[posPrev].state;
++      state = kLiteralNextStates[state];
++    }
++    else
++      state = p->opt[posPrev].state;
++    if (posPrev == cur - 1)
++    {
++      if (IsShortRep(curOpt))
++        state = kShortRepNextStates[state];
++      else
++        state = kLiteralNextStates[state];
++    }
++    else
++    {
++      UInt32 pos;
++      const COptimal *prevOpt;
++      if (curOpt->prev1IsChar && curOpt->prev2)
++      {
++        posPrev = curOpt->posPrev2;
++        pos = curOpt->backPrev2;
++        state = kRepNextStates[state];
++      }
++      else
++      {
++        pos = curOpt->backPrev;
++        if (pos < LZMA_NUM_REPS)
++          state = kRepNextStates[state];
++        else
++          state = kMatchNextStates[state];
++      }
++      prevOpt = &p->opt[posPrev];
++      if (pos < LZMA_NUM_REPS)
++      {
++        UInt32 i;
++        reps[0] = prevOpt->backs[pos];
++        for (i = 1; i <= pos; i++)
++          reps[i] = prevOpt->backs[i - 1];
++        for (; i < LZMA_NUM_REPS; i++)
++          reps[i] = prevOpt->backs[i];
++      }
++      else
++      {
++        UInt32 i;
++        reps[0] = (pos - LZMA_NUM_REPS);
++        for (i = 1; i < LZMA_NUM_REPS; i++)
++          reps[i] = prevOpt->backs[i - 1];
++      }
++    }
++    curOpt->state = (CState)state;
++
++    curOpt->backs[0] = reps[0];
++    curOpt->backs[1] = reps[1];
++    curOpt->backs[2] = reps[2];
++    curOpt->backs[3] = reps[3];
++
++    curPrice = curOpt->price;
++    nextIsChar = False;
++    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++    curByte = *data;
++    matchByte = *(data - (reps[0] + 1));
++
++    posState = (position & p->pbMask);
++
++    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
++    {
++      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
++      curAnd1Price +=
++        (!IsCharState(state) ?
++          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
++          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
++    }
++
++    nextOpt = &p->opt[cur + 1];
++
++    if (curAnd1Price < nextOpt->price)
++    {
++      nextOpt->price = curAnd1Price;
++      nextOpt->posPrev = cur;
++      MakeAsChar(nextOpt);
++      nextIsChar = True;
++    }
++
++    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
++    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
++    
++    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
++    {
++      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
++      if (shortRepPrice <= nextOpt->price)
++      {
++        nextOpt->price = shortRepPrice;
++        nextOpt->posPrev = cur;
++        MakeAsShortRep(nextOpt);
++        nextIsChar = True;
++      }
++    }
++    numAvailFull = p->numAvail;
++    {
++      UInt32 temp = kNumOpts - 1 - cur;
++      if (temp < numAvailFull)
++        numAvailFull = temp;
++    }
++
++    if (numAvailFull < 2)
++      continue;
++    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
++
++    if (!nextIsChar && matchByte != curByte) /* speed optimization */
++    {
++      /* try Literal + rep0 */
++      UInt32 temp;
++      UInt32 lenTest2;
++      const Byte *data2 = data - (reps[0] + 1);
++      UInt32 limit = p->numFastBytes + 1;
++      if (limit > numAvailFull)
++        limit = numAvailFull;
++
++      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
++      lenTest2 = temp - 1;
++      if (lenTest2 >= 2)
++      {
++        UInt32 state2 = kLiteralNextStates[state];
++        UInt32 posStateNext = (position + 1) & p->pbMask;
++        UInt32 nextRepMatchPrice = curAnd1Price +
++            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
++            GET_PRICE_1(p->isRep[state2]);
++        /* for (; lenTest2 >= 2; lenTest2--) */
++        {
++          UInt32 curAndLenPrice;
++          COptimal *opt;
++          UInt32 offset = cur + 1 + lenTest2;
++          while (lenEnd < offset)
++            p->opt[++lenEnd].price = kInfinityPrice;
++          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
++          opt = &p->opt[offset];
++          if (curAndLenPrice < opt->price)
++          {
++            opt->price = curAndLenPrice;
++            opt->posPrev = cur + 1;
++            opt->backPrev = 0;
++            opt->prev1IsChar = True;
++            opt->prev2 = False;
++          }
++        }
++      }
++    }
++    
++    startLen = 2; /* speed optimization */
++    {
++    UInt32 repIndex;
++    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
++    {
++      UInt32 lenTest;
++      UInt32 lenTestTemp;
++      UInt32 price;
++      const Byte *data2 = data - (reps[repIndex] + 1);
++      if (data[0] != data2[0] || data[1] != data2[1])
++        continue;
++      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
++      while (lenEnd < cur + lenTest)
++        p->opt[++lenEnd].price = kInfinityPrice;
++      lenTestTemp = lenTest;
++      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
++      do
++      {
++        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
++        COptimal *opt = &p->opt[cur + lenTest];
++        if (curAndLenPrice < opt->price)
++        {
++          opt->price = curAndLenPrice;
++          opt->posPrev = cur;
++          opt->backPrev = repIndex;
++          opt->prev1IsChar = False;
++        }
++      }
++      while (--lenTest >= 2);
++      lenTest = lenTestTemp;
++      
++      if (repIndex == 0)
++        startLen = lenTest + 1;
++        
++      /* if (_maxMode) */
++        {
++          UInt32 lenTest2 = lenTest + 1;
++          UInt32 limit = lenTest2 + p->numFastBytes;
++          UInt32 nextRepMatchPrice;
++          if (limit > numAvailFull)
++            limit = numAvailFull;
++          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
++          lenTest2 -= lenTest + 1;
++          if (lenTest2 >= 2)
++          {
++            UInt32 state2 = kRepNextStates[state];
++            UInt32 posStateNext = (position + lenTest) & p->pbMask;
++            UInt32 curAndLenCharPrice =
++                price + p->repLenEnc.prices[posState][lenTest - 2] +
++                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
++                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
++                    data[lenTest], data2[lenTest], p->ProbPrices);
++            state2 = kLiteralNextStates[state2];
++            posStateNext = (position + lenTest + 1) & p->pbMask;
++            nextRepMatchPrice = curAndLenCharPrice +
++                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
++                GET_PRICE_1(p->isRep[state2]);
++            
++            /* for (; lenTest2 >= 2; lenTest2--) */
++            {
++              UInt32 curAndLenPrice;
++              COptimal *opt;
++              UInt32 offset = cur + lenTest + 1 + lenTest2;
++              while (lenEnd < offset)
++                p->opt[++lenEnd].price = kInfinityPrice;
++              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
++              opt = &p->opt[offset];
++              if (curAndLenPrice < opt->price)
++              {
++                opt->price = curAndLenPrice;
++                opt->posPrev = cur + lenTest + 1;
++                opt->backPrev = 0;
++                opt->prev1IsChar = True;
++                opt->prev2 = True;
++                opt->posPrev2 = cur;
++                opt->backPrev2 = repIndex;
++              }
++            }
++          }
++        }
++    }
++    }
++    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
++    if (newLen > numAvail)
++    {
++      newLen = numAvail;
++      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
++      matches[numPairs] = newLen;
++      numPairs += 2;
++    }
++    if (newLen >= startLen)
++    {
++      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
++      UInt32 offs, curBack, posSlot;
++      UInt32 lenTest;
++      while (lenEnd < cur + newLen)
++        p->opt[++lenEnd].price = kInfinityPrice;
++
++      offs = 0;
++      while (startLen > matches[offs])
++        offs += 2;
++      curBack = matches[offs + 1];
++      GetPosSlot2(curBack, posSlot);
++      for (lenTest = /*2*/ startLen; ; lenTest++)
++      {
++        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
++        UInt32 lenToPosState = GetLenToPosState(lenTest);
++        COptimal *opt;
++        if (curBack < kNumFullDistances)
++          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
++        else
++          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
++        
++        opt = &p->opt[cur + lenTest];
++        if (curAndLenPrice < opt->price)
++        {
++          opt->price = curAndLenPrice;
++          opt->posPrev = cur;
++          opt->backPrev = curBack + LZMA_NUM_REPS;
++          opt->prev1IsChar = False;
++        }
++
++        if (/*_maxMode && */lenTest == matches[offs])
++        {
++          /* Try Match + Literal + Rep0 */
++          const Byte *data2 = data - (curBack + 1);
++          UInt32 lenTest2 = lenTest + 1;
++          UInt32 limit = lenTest2 + p->numFastBytes;
++          UInt32 nextRepMatchPrice;
++          if (limit > numAvailFull)
++            limit = numAvailFull;
++          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
++          lenTest2 -= lenTest + 1;
++          if (lenTest2 >= 2)
++          {
++            UInt32 state2 = kMatchNextStates[state];
++            UInt32 posStateNext = (position + lenTest) & p->pbMask;
++            UInt32 curAndLenCharPrice = curAndLenPrice +
++                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
++                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
++                    data[lenTest], data2[lenTest], p->ProbPrices);
++            state2 = kLiteralNextStates[state2];
++            posStateNext = (posStateNext + 1) & p->pbMask;
++            nextRepMatchPrice = curAndLenCharPrice +
++                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
++                GET_PRICE_1(p->isRep[state2]);
++            
++            /* for (; lenTest2 >= 2; lenTest2--) */
++            {
++              UInt32 offset = cur + lenTest + 1 + lenTest2;
++              UInt32 curAndLenPrice;
++              COptimal *opt;
++              while (lenEnd < offset)
++                p->opt[++lenEnd].price = kInfinityPrice;
++              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
++              opt = &p->opt[offset];
++              if (curAndLenPrice < opt->price)
++              {
++                opt->price = curAndLenPrice;
++                opt->posPrev = cur + lenTest + 1;
++                opt->backPrev = 0;
++                opt->prev1IsChar = True;
++                opt->prev2 = True;
++                opt->posPrev2 = cur;
++                opt->backPrev2 = curBack + LZMA_NUM_REPS;
++              }
++            }
++          }
++          offs += 2;
++          if (offs == numPairs)
++            break;
++          curBack = matches[offs + 1];
++          if (curBack >= kNumFullDistances)
++            GetPosSlot2(curBack, posSlot);
++        }
++      }
++    }
++  }
++}
++
++#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))
++
++static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
++{
++  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
++  const Byte *data;
++  const UInt32 *matches;
++
++  if (p->additionalOffset == 0)
++    mainLen = ReadMatchDistances(p, &numPairs);
++  else
++  {
++    mainLen = p->longestMatchLength;
++    numPairs = p->numPairs;
++  }
++
++  numAvail = p->numAvail;
++  *backRes = (UInt32)-1;
++  if (numAvail < 2)
++    return 1;
++  if (numAvail > LZMA_MATCH_LEN_MAX)
++    numAvail = LZMA_MATCH_LEN_MAX;
++  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++
++  repLen = repIndex = 0;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 len;
++    const Byte *data2 = data - (p->reps[i] + 1);
++    if (data[0] != data2[0] || data[1] != data2[1])
++      continue;
++    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
++    if (len >= p->numFastBytes)
++    {
++      *backRes = i;
++      MovePos(p, len - 1);
++      return len;
++    }
++    if (len > repLen)
++    {
++      repIndex = i;
++      repLen = len;
++    }
++  }
++
++  matches = p->matches;
++  if (mainLen >= p->numFastBytes)
++  {
++    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
++    MovePos(p, mainLen - 1);
++    return mainLen;
++  }
++
++  mainDist = 0; /* for GCC */
++  if (mainLen >= 2)
++  {
++    mainDist = matches[numPairs - 1];
++    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
++    {
++      if (!ChangePair(matches[numPairs - 3], mainDist))
++        break;
++      numPairs -= 2;
++      mainLen = matches[numPairs - 2];
++      mainDist = matches[numPairs - 1];
++    }
++    if (mainLen == 2 && mainDist >= 0x80)
++      mainLen = 1;
++  }
++
++  if (repLen >= 2 && (
++        (repLen + 1 >= mainLen) ||
++        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
++        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
++  {
++    *backRes = repIndex;
++    MovePos(p, repLen - 1);
++    return repLen;
++  }
++  
++  if (mainLen < 2 || numAvail <= 2)
++    return 1;
++
++  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
++  if (p->longestMatchLength >= 2)
++  {
++    UInt32 newDistance = matches[p->numPairs - 1];
++    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
++        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
++        (p->longestMatchLength > mainLen + 1) ||
++        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
++      return 1;
++  }
++  
++  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
++  for (i = 0; i < LZMA_NUM_REPS; i++)
++  {
++    UInt32 len, limit;
++    const Byte *data2 = data - (p->reps[i] + 1);
++    if (data[0] != data2[0] || data[1] != data2[1])
++      continue;
++    limit = mainLen - 1;
++    for (len = 2; len < limit && data[len] == data2[len]; len++);
++    if (len >= limit)
++      return 1;
++  }
++  *backRes = mainDist + LZMA_NUM_REPS;
++  MovePos(p, mainLen - 2);
++  return mainLen;
++}
++
++static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
++{
++  UInt32 len;
++  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
++  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
++  p->state = kMatchNextStates[p->state];
++  len = LZMA_MATCH_LEN_MIN;
++  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
++  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
++  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
++  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
++}
++
++static SRes CheckErrors(CLzmaEnc *p)
++{
++  if (p->result != SZ_OK)
++    return p->result;
++  if (p->rc.res != SZ_OK)
++    p->result = SZ_ERROR_WRITE;
++  if (p->matchFinderBase.result != SZ_OK)
++    p->result = SZ_ERROR_READ;
++  if (p->result != SZ_OK)
++    p->finished = True;
++  return p->result;
++}
++
++static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
++{
++  /* ReleaseMFStream(); */
++  p->finished = True;
++  if (p->writeEndMark)
++    WriteEndMarker(p, nowPos & p->pbMask);
++  RangeEnc_FlushData(&p->rc);
++  RangeEnc_FlushStream(&p->rc);
++  return CheckErrors(p);
++}
++
++static void FillAlignPrices(CLzmaEnc *p)
++{
++  UInt32 i;
++  for (i = 0; i < kAlignTableSize; i++)
++    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
++  p->alignPriceCount = 0;
++}
++
++static void FillDistancesPrices(CLzmaEnc *p)
++{
++  UInt32 tempPrices[kNumFullDistances];
++  UInt32 i, lenToPosState;
++  for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
++  {
++    UInt32 posSlot = GetPosSlot1(i);
++    UInt32 footerBits = ((posSlot >> 1) - 1);
++    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
++    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
++  }
++
++  for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
++  {
++    UInt32 posSlot;
++    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
++    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
++    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
++      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
++    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
++      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);
++
++    {
++      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
++      UInt32 i;
++      for (i = 0; i < kStartPosModelIndex; i++)
++        distancesPrices[i] = posSlotPrices[i];
++      for (; i < kNumFullDistances; i++)
++        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
++    }
++  }
++  p->matchPriceCount = 0;
++}
++
++void LzmaEnc_Construct(CLzmaEnc *p)
++{
++  RangeEnc_Construct(&p->rc);
++  MatchFinder_Construct(&p->matchFinderBase);
++  #ifndef _7ZIP_ST
++  MatchFinderMt_Construct(&p->matchFinderMt);
++  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
++  #endif
++
++  {
++    CLzmaEncProps props;
++    LzmaEncProps_Init(&props);
++    LzmaEnc_SetProps(p, &props);
++  }
++
++  #ifndef LZMA_LOG_BSR
++  LzmaEnc_FastPosInit(p->g_FastPos);
++  #endif
++
++  LzmaEnc_InitPriceTables(p->ProbPrices);
++  p->litProbs = 0;
++  p->saveState.litProbs = 0;
++}
++
++CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
++{
++  void *p;
++  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
++  if (p != 0)
++    LzmaEnc_Construct((CLzmaEnc *)p);
++  return p;
++}
++
++void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->litProbs);
++  alloc->Free(alloc, p->saveState.litProbs);
++  p->litProbs = 0;
++  p->saveState.litProbs = 0;
++}
++
++void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  #ifndef _7ZIP_ST
++  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
++  #endif
++  MatchFinder_Free(&p->matchFinderBase, allocBig);
++  LzmaEnc_FreeLits(p, alloc);
++  RangeEnc_Free(&p->rc, alloc);
++}
++
++void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
++  alloc->Free(alloc, p);
++}
++
++static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
++{
++  UInt32 nowPos32, startPos32;
++  if (p->needInit)
++  {
++    p->matchFinder.Init(p->matchFinderObj);
++    p->needInit = 0;
++  }
++
++  if (p->finished)
++    return p->result;
++  RINOK(CheckErrors(p));
++
++  nowPos32 = (UInt32)p->nowPos64;
++  startPos32 = nowPos32;
++
++  if (p->nowPos64 == 0)
++  {
++    UInt32 numPairs;
++    Byte curByte;
++    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
++      return Flush(p, nowPos32);
++    ReadMatchDistances(p, &numPairs);
++    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
++    p->state = kLiteralNextStates[p->state];
++    curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
++    LitEnc_Encode(&p->rc, p->litProbs, curByte);
++    p->additionalOffset--;
++    nowPos32++;
++  }
++
++  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
++  for (;;)
++  {
++    UInt32 pos, len, posState;
++
++    if (p->fastMode)
++      len = GetOptimumFast(p, &pos);
++    else
++      len = GetOptimum(p, nowPos32, &pos);
++
++    #ifdef SHOW_STAT2
++    printf("\n pos = %4X,   len = %d   pos = %d", nowPos32, len, pos);
++    #endif
++
++    posState = nowPos32 & p->pbMask;
++    if (len == 1 && pos == (UInt32)-1)
++    {
++      Byte curByte;
++      CLzmaProb *probs;
++      const Byte *data;
++
++      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
++      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
++      curByte = *data;
++      probs = LIT_PROBS(nowPos32, *(data - 1));
++      if (IsCharState(p->state))
++        LitEnc_Encode(&p->rc, probs, curByte);
++      else
++        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
++      p->state = kLiteralNextStates[p->state];
++    }
++    else
++    {
++      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
++      if (pos < LZMA_NUM_REPS)
++      {
++        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
++        if (pos == 0)
++        {
++          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
++          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
++        }
++        else
++        {
++          UInt32 distance = p->reps[pos];
++          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
++          if (pos == 1)
++            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
++          else
++          {
++            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
++            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
++            if (pos == 3)
++              p->reps[3] = p->reps[2];
++            p->reps[2] = p->reps[1];
++          }
++          p->reps[1] = p->reps[0];
++          p->reps[0] = distance;
++        }
++        if (len == 1)
++          p->state = kShortRepNextStates[p->state];
++        else
++        {
++          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
++          p->state = kRepNextStates[p->state];
++        }
++      }
++      else
++      {
++        UInt32 posSlot;
++        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
++        p->state = kMatchNextStates[p->state];
++        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
++        pos -= LZMA_NUM_REPS;
++        GetPosSlot(pos, posSlot);
++        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
++        
++        if (posSlot >= kStartPosModelIndex)
++        {
++          UInt32 footerBits = ((posSlot >> 1) - 1);
++          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
++          UInt32 posReduced = pos - base;
++
++          if (posSlot < kEndPosModelIndex)
++            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
++          else
++          {
++            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
++            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
++            p->alignPriceCount++;
++          }
++        }
++        p->reps[3] = p->reps[2];
++        p->reps[2] = p->reps[1];
++        p->reps[1] = p->reps[0];
++        p->reps[0] = pos;
++        p->matchPriceCount++;
++      }
++    }
++    p->additionalOffset -= len;
++    nowPos32 += len;
++    if (p->additionalOffset == 0)
++    {
++      UInt32 processed;
++      if (!p->fastMode)
++      {
++        if (p->matchPriceCount >= (1 << 7))
++          FillDistancesPrices(p);
++        if (p->alignPriceCount >= kAlignTableSize)
++          FillAlignPrices(p);
++      }
++      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
++        break;
++      processed = nowPos32 - startPos32;
++      if (useLimits)
++      {
++        if (processed + kNumOpts + 300 >= maxUnpackSize ||
++            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
++          break;
++      }
++      else if (processed >= (1 << 15))
++      {
++        p->nowPos64 += nowPos32 - startPos32;
++        return CheckErrors(p);
++      }
++    }
++  }
++  p->nowPos64 += nowPos32 - startPos32;
++  return Flush(p, nowPos32);
++}
++
++#define kBigHashDicLimit ((UInt32)1 << 24)
++
++static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  UInt32 beforeSize = kNumOpts;
++  Bool btMode;
++  if (!RangeEnc_Alloc(&p->rc, alloc))
++    return SZ_ERROR_MEM;
++  btMode = (p->matchFinderBase.btMode != 0);
++  #ifndef _7ZIP_ST
++  p->mtMode = (p->multiThread && !p->fastMode && btMode);
++  #endif
++
++  {
++    unsigned lclp = p->lc + p->lp;
++    if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
++    {
++      LzmaEnc_FreeLits(p, alloc);
++      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
++      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
++      if (p->litProbs == 0 || p->saveState.litProbs == 0)
++      {
++        LzmaEnc_FreeLits(p, alloc);
++        return SZ_ERROR_MEM;
++      }
++      p->lclp = lclp;
++    }
++  }
++
++  p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);
++
++  if (beforeSize + p->dictSize < keepWindowSize)
++    beforeSize = keepWindowSize - p->dictSize;
++
++  #ifndef _7ZIP_ST
++  if (p->mtMode)
++  {
++    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
++    p->matchFinderObj = &p->matchFinderMt;
++    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
++  }
++  else
++  #endif
++  {
++    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
++      return SZ_ERROR_MEM;
++    p->matchFinderObj = &p->matchFinderBase;
++    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
++  }
++  return SZ_OK;
++}
++
++void LzmaEnc_Init(CLzmaEnc *p)
++{
++  UInt32 i;
++  p->state = 0;
++  for (i = 0 ; i < LZMA_NUM_REPS; i++)
++    p->reps[i] = 0;
++
++  RangeEnc_Init(&p->rc);
++
++
++  for (i = 0; i < kNumStates; i++)
++  {
++    UInt32 j;
++    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
++    {
++      p->isMatch[i][j] = kProbInitValue;
++      p->isRep0Long[i][j] = kProbInitValue;
++    }
++    p->isRep[i] = kProbInitValue;
++    p->isRepG0[i] = kProbInitValue;
++    p->isRepG1[i] = kProbInitValue;
++    p->isRepG2[i] = kProbInitValue;
++  }
++
++  {
++    UInt32 num = 0x300 << (p->lp + p->lc);
++    for (i = 0; i < num; i++)
++      p->litProbs[i] = kProbInitValue;
++  }
++
++  {
++    for (i = 0; i < kNumLenToPosStates; i++)
++    {
++      CLzmaProb *probs = p->posSlotEncoder[i];
++      UInt32 j;
++      for (j = 0; j < (1 << kNumPosSlotBits); j++)
++        probs[j] = kProbInitValue;
++    }
++  }
++  {
++    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
++      p->posEncoders[i] = kProbInitValue;
++  }
++
++  LenEnc_Init(&p->lenEnc.p);
++  LenEnc_Init(&p->repLenEnc.p);
++
++  for (i = 0; i < (1 << kNumAlignBits); i++)
++    p->posAlignEncoder[i] = kProbInitValue;
++
++  p->optimumEndIndex = 0;
++  p->optimumCurrentIndex = 0;
++  p->additionalOffset = 0;
++
++  p->pbMask = (1 << p->pb) - 1;
++  p->lpMask = (1 << p->lp) - 1;
++}
++
++void LzmaEnc_InitPrices(CLzmaEnc *p)
++{
++  if (!p->fastMode)
++  {
++    FillDistancesPrices(p);
++    FillAlignPrices(p);
++  }
++
++  p->lenEnc.tableSize =
++  p->repLenEnc.tableSize =
++      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
++  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
++  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
++}
++
++static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  UInt32 i;
++  for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
++    if (p->dictSize <= ((UInt32)1 << i))
++      break;
++  p->distTableSize = i * 2;
++
++  p->finished = False;
++  p->result = SZ_OK;
++  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
++  LzmaEnc_Init(p);
++  LzmaEnc_InitPrices(p);
++  p->nowPos64 = 0;
++  return SZ_OK;
++}
++
++static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  p->matchFinderBase.stream = inStream;
++  p->needInit = 1;
++  p->rc.outStream = outStream;
++  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
++}
++
++SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
++    ISeqInStream *inStream, UInt32 keepWindowSize,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  p->matchFinderBase.stream = inStream;
++  p->needInit = 1;
++  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
++}
++
++static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
++{
++  p->matchFinderBase.directInput = 1;
++  p->matchFinderBase.bufferBase = (Byte *)src;
++  p->matchFinderBase.directInputRem = srcLen;
++}
++
++SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
++    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  LzmaEnc_SetInputBuf(p, src, srcLen);
++  p->needInit = 1;
++
++  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
++}
++
++void LzmaEnc_Finish(CLzmaEncHandle pp)
++{
++  #ifndef _7ZIP_ST
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  if (p->mtMode)
++    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
++  #else
++  pp = pp;
++  #endif
++}
++
++typedef struct
++{
++  ISeqOutStream funcTable;
++  Byte *data;
++  SizeT rem;
++  Bool overflow;
++} CSeqOutStreamBuf;
++
++static size_t MyWrite(void *pp, const void *data, size_t size)
++{
++  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
++  if (p->rem < size)
++  {
++    size = p->rem;
++    p->overflow = True;
++  }
++  memcpy(p->data, data, size);
++  p->rem -= size;
++  p->data += size;
++  return size;
++}
++
++
++UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
++{
++  const CLzmaEnc *p = (CLzmaEnc *)pp;
++  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
++}
++
++const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
++{
++  const CLzmaEnc *p = (CLzmaEnc *)pp;
++  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
++}
++
++SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
++    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  UInt64 nowPos64;
++  SRes res;
++  CSeqOutStreamBuf outStream;
++
++  outStream.funcTable.Write = MyWrite;
++  outStream.data = dest;
++  outStream.rem = *destLen;
++  outStream.overflow = False;
++
++  p->writeEndMark = False;
++  p->finished = False;
++  p->result = SZ_OK;
++
++  if (reInit)
++    LzmaEnc_Init(p);
++  LzmaEnc_InitPrices(p);
++  nowPos64 = p->nowPos64;
++  RangeEnc_Init(&p->rc);
++  p->rc.outStream = &outStream.funcTable;
++
++  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
++  
++  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
++  *destLen -= outStream.rem;
++  if (outStream.overflow)
++    return SZ_ERROR_OUTPUT_EOF;
++
++  return res;
++}
++
++static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
++{
++  SRes res = SZ_OK;
++
++  #ifndef _7ZIP_ST
++  Byte allocaDummy[0x300];
++  int i = 0;
++  for (i = 0; i < 16; i++)
++    allocaDummy[i] = (Byte)i;
++  #endif
++
++  for (;;)
++  {
++    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
++    if (res != SZ_OK || p->finished != 0)
++      break;
++    if (progress != 0)
++    {
++      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
++      if (res != SZ_OK)
++      {
++        res = SZ_ERROR_PROGRESS;
++        break;
++      }
++    }
++  }
++  LzmaEnc_Finish(p);
++  return res;
++}
++
++SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
++  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
++}
++
++SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  int i;
++  UInt32 dictSize = p->dictSize;
++  if (*size < LZMA_PROPS_SIZE)
++    return SZ_ERROR_PARAM;
++  *size = LZMA_PROPS_SIZE;
++  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);
++
++  for (i = 11; i <= 30; i++)
++  {
++    if (dictSize <= ((UInt32)2 << i))
++    {
++      dictSize = (2 << i);
++      break;
++    }
++    if (dictSize <= ((UInt32)3 << i))
++    {
++      dictSize = (3 << i);
++      break;
++    }
++  }
++
++  for (i = 0; i < 4; i++)
++    props[1 + i] = (Byte)(dictSize >> (8 * i));
++  return SZ_OK;
++}
++
++SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  SRes res;
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++
++  CSeqOutStreamBuf outStream;
++
++  LzmaEnc_SetInputBuf(p, src, srcLen);
++
++  outStream.funcTable.Write = MyWrite;
++  outStream.data = dest;
++  outStream.rem = *destLen;
++  outStream.overflow = False;
++
++  p->writeEndMark = writeEndMark;
++
++  p->rc.outStream = &outStream.funcTable;
++  res = LzmaEnc_MemPrepare(pp, src, srcLen, 0, alloc, allocBig);
++  if (res == SZ_OK)
++    res = LzmaEnc_Encode2(p, progress);
++
++  *destLen -= outStream.rem;
++  if (outStream.overflow)
++    return SZ_ERROR_OUTPUT_EOF;
++  return res;
++}
++
++SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
++  SRes res;
++  if (p == 0)
++    return SZ_ERROR_MEM;
++
++  res = LzmaEnc_SetProps(p, props);
++  if (res == SZ_OK)
++  {
++    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
++    if (res == SZ_OK)
++      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
++          writeEndMark, progress, alloc, allocBig);
++  }
++
++  LzmaEnc_Destroy(p, alloc, allocBig);
++  return res;
++}
+Index: kernel_tree/lib/lzma/Makefile
+===================================================================
+--- /dev/null
++++ kernel_tree/lib/lzma/Makefile
+@@ -0,0 +1,7 @@
++lzma_compress-objs := LzFind.o LzmaEnc.o
++lzma_decompress-objs := LzmaDec.o
++
++obj-$(CONFIG_LZMA_COMPRESS) += lzma_compress.o
++obj-$(CONFIG_LZMA_DECOMPRESS) += lzma_decompress.o
++
++EXTRA_CFLAGS += -Iinclude/linux -Iinclude/linux/lzma -include types.h
diff --git a/target/linux/generic/patches-3.10/531-debloat_lzma.patch b/target/linux/generic/patches-3.10/531-debloat_lzma.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/531-debloat_lzma.patch
@@ -0,0 +1,1024 @@
+--- a/include/linux/lzma/LzmaDec.h
++++ b/include/linux/lzma/LzmaDec.h
+@@ -31,14 +31,6 @@ typedef struct _CLzmaProps
+   UInt32 dicSize;
+ } CLzmaProps;
+ 
+-/* LzmaProps_Decode - decodes properties
+-Returns:
+-  SZ_OK
+-  SZ_ERROR_UNSUPPORTED - Unsupported properties
+-*/
+-
+-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
+-
+ 
+ /* ---------- LZMA Decoder state ---------- */
+ 
+@@ -70,8 +62,6 @@ typedef struct
+ 
+ #define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
+ 
+-void LzmaDec_Init(CLzmaDec *p);
+-
+ /* There are two types of LZMA streams:
+      0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
+      1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
+@@ -108,97 +98,6 @@ typedef enum
+ 
+ /* ELzmaStatus is used only as output value for function call */
+ 
+-
+-/* ---------- Interfaces ---------- */
+-
+-/* There are 3 levels of interfaces:
+-     1) Dictionary Interface
+-     2) Buffer Interface
+-     3) One Call Interface
+-   You can select any of these interfaces, but don't mix functions from different
+-   groups for same object. */
+-
+-
+-/* There are two variants to allocate state for Dictionary Interface:
+-     1) LzmaDec_Allocate / LzmaDec_Free
+-     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
+-   You can use variant 2, if you set dictionary buffer manually.
+-   For Buffer Interface you must always use variant 1.
+-
+-LzmaDec_Allocate* can return:
+-  SZ_OK
+-  SZ_ERROR_MEM         - Memory allocation error
+-  SZ_ERROR_UNSUPPORTED - Unsupported properties
+-*/
+-   
+-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
+-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
+-
+-SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
+-void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
+-
+-/* ---------- Dictionary Interface ---------- */
+-
+-/* You can use it, if you want to eliminate the overhead for data copying from
+-   dictionary to some other external buffer.
+-   You must work with CLzmaDec variables directly in this interface.
+-
+-   STEPS:
+-     LzmaDec_Constr()
+-     LzmaDec_Allocate()
+-     for (each new stream)
+-     {
+-       LzmaDec_Init()
+-       while (it needs more decompression)
+-       {
+-         LzmaDec_DecodeToDic()
+-         use data from CLzmaDec::dic and update CLzmaDec::dicPos
+-       }
+-     }
+-     LzmaDec_Free()
+-*/
+-
+-/* LzmaDec_DecodeToDic
+-   
+-   The decoding to internal dictionary buffer (CLzmaDec::dic).
+-   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
+-
+-finishMode:
+-  It has meaning only if the decoding reaches output limit (dicLimit).
+-  LZMA_FINISH_ANY - Decode just dicLimit bytes.
+-  LZMA_FINISH_END - Stream must be finished after dicLimit.
+-
+-Returns:
+-  SZ_OK
+-    status:
+-      LZMA_STATUS_FINISHED_WITH_MARK
+-      LZMA_STATUS_NOT_FINISHED
+-      LZMA_STATUS_NEEDS_MORE_INPUT
+-      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+-  SZ_ERROR_DATA - Data error
+-*/
+-
+-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
+-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+-
+-
+-/* ---------- Buffer Interface ---------- */
+-
+-/* It's zlib-like interface.
+-   See LzmaDec_DecodeToDic description for information about STEPS and return results,
+-   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
+-   to work with CLzmaDec variables manually.
+-
+-finishMode:
+-  It has meaning only if the decoding reaches output limit (*destLen).
+-  LZMA_FINISH_ANY - Decode just destLen bytes.
+-  LZMA_FINISH_END - Stream must be finished after (*destLen).
+-*/
+-
+-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
+-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+-
+-
+ /* ---------- One Call Interface ---------- */
+ 
+ /* LzmaDecode
+--- a/lib/lzma/LzmaDec.c
++++ b/lib/lzma/LzmaDec.c
+@@ -682,7 +682,7 @@ static void LzmaDec_InitRc(CLzmaDec *p,
+   p->needFlush = 0;
+ }
+ 
+-void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
++static void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
+ {
+   p->needFlush = 1;
+   p->remainLen = 0;
+@@ -698,7 +698,7 @@ void LzmaDec_InitDicAndState(CLzmaDec *p
+     p->needInitState = 1;
+ }
+ 
+-void LzmaDec_Init(CLzmaDec *p)
++static void LzmaDec_Init(CLzmaDec *p)
+ {
+   p->dicPos = 0;
+   LzmaDec_InitDicAndState(p, True, True);
+@@ -716,7 +716,7 @@ static void LzmaDec_InitStateReal(CLzmaD
+   p->needInitState = 0;
+ }
+ 
+-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
++static SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
+     ELzmaFinishMode finishMode, ELzmaStatus *status)
+ {
+   SizeT inSize = *srcLen;
+@@ -837,65 +837,13 @@ SRes LzmaDec_DecodeToDic(CLzmaDec *p, Si
+   return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
+ }
+ 
+-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+-{
+-  SizeT outSize = *destLen;
+-  SizeT inSize = *srcLen;
+-  *srcLen = *destLen = 0;
+-  for (;;)
+-  {
+-    SizeT inSizeCur = inSize, outSizeCur, dicPos;
+-    ELzmaFinishMode curFinishMode;
+-    SRes res;
+-    if (p->dicPos == p->dicBufSize)
+-      p->dicPos = 0;
+-    dicPos = p->dicPos;
+-    if (outSize > p->dicBufSize - dicPos)
+-    {
+-      outSizeCur = p->dicBufSize;
+-      curFinishMode = LZMA_FINISH_ANY;
+-    }
+-    else
+-    {
+-      outSizeCur = dicPos + outSize;
+-      curFinishMode = finishMode;
+-    }
+-
+-    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
+-    src += inSizeCur;
+-    inSize -= inSizeCur;
+-    *srcLen += inSizeCur;
+-    outSizeCur = p->dicPos - dicPos;
+-    memcpy(dest, p->dic + dicPos, outSizeCur);
+-    dest += outSizeCur;
+-    outSize -= outSizeCur;
+-    *destLen += outSizeCur;
+-    if (res != 0)
+-      return res;
+-    if (outSizeCur == 0 || outSize == 0)
+-      return SZ_OK;
+-  }
+-}
+-
+-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
++static void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
+ {
+   alloc->Free(alloc, p->probs);
+   p->probs = 0;
+ }
+ 
+-static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
+-{
+-  alloc->Free(alloc, p->dic);
+-  p->dic = 0;
+-}
+-
+-void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
+-{
+-  LzmaDec_FreeProbs(p, alloc);
+-  LzmaDec_FreeDict(p, alloc);
+-}
+-
+-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
++static SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
+ {
+   UInt32 dicSize;
+   Byte d;
+@@ -935,7 +883,7 @@ static SRes LzmaDec_AllocateProbs2(CLzma
+   return SZ_OK;
+ }
+ 
+-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
++static SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+ {
+   CLzmaProps propNew;
+   RINOK(LzmaProps_Decode(&propNew, props, propsSize));
+@@ -943,28 +891,6 @@ SRes LzmaDec_AllocateProbs(CLzmaDec *p,
+   p->prop = propNew;
+   return SZ_OK;
+ }
+-
+-SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+-{
+-  CLzmaProps propNew;
+-  SizeT dicBufSize;
+-  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
+-  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
+-  dicBufSize = propNew.dicSize;
+-  if (p->dic == 0 || dicBufSize != p->dicBufSize)
+-  {
+-    LzmaDec_FreeDict(p, alloc);
+-    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
+-    if (p->dic == 0)
+-    {
+-      LzmaDec_FreeProbs(p, alloc);
+-      return SZ_ERROR_MEM;
+-    }
+-  }
+-  p->dicBufSize = dicBufSize;
+-  p->prop = propNew;
+-  return SZ_OK;
+-}
+ 
+ SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+     const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+--- a/include/linux/lzma/LzmaEnc.h
++++ b/include/linux/lzma/LzmaEnc.h
+@@ -31,9 +31,6 @@ typedef struct _CLzmaEncProps
+ } CLzmaEncProps;
+ 
+ void LzmaEncProps_Init(CLzmaEncProps *p);
+-void LzmaEncProps_Normalize(CLzmaEncProps *p);
+-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
+-
+ 
+ /* ---------- CLzmaEncHandle Interface ---------- */
+ 
+@@ -53,26 +50,9 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
+ void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
+ SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
+ SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
+-SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
+-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+ SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+     int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+ 
+-/* ---------- One Call Interface ---------- */
+-
+-/* LzmaEncode
+-Return code:
+-  SZ_OK               - OK
+-  SZ_ERROR_MEM        - Memory allocation error
+-  SZ_ERROR_PARAM      - Incorrect paramater
+-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+-*/
+-
+-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+-
+ #ifdef __cplusplus
+ }
+ #endif
+--- a/lib/lzma/LzmaEnc.c
++++ b/lib/lzma/LzmaEnc.c
+@@ -53,7 +53,7 @@ void LzmaEncProps_Init(CLzmaEncProps *p)
+   p->writeEndMark = 0;
+ }
+ 
+-void LzmaEncProps_Normalize(CLzmaEncProps *p)
++static void LzmaEncProps_Normalize(CLzmaEncProps *p)
+ {
+   int level = p->level;
+   if (level < 0) level = 5;
+@@ -76,7 +76,7 @@ void LzmaEncProps_Normalize(CLzmaEncProp
+       #endif
+ }
+ 
+-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
++static UInt32 __maybe_unused LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
+ {
+   CLzmaEncProps props = *props2;
+   LzmaEncProps_Normalize(&props);
+@@ -93,7 +93,7 @@ UInt32 LzmaEncProps_GetDictSize(const CL
+ 
+ #define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
+ 
+-UInt32 GetPosSlot1(UInt32 pos)
++static UInt32 GetPosSlot1(UInt32 pos)
+ {
+   UInt32 res;
+   BSR2_RET(pos, res);
+@@ -107,7 +107,7 @@ UInt32 GetPosSlot1(UInt32 pos)
+ #define kNumLogBits (9 + (int)sizeof(size_t) / 2)
+ #define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
+ 
+-void LzmaEnc_FastPosInit(Byte *g_FastPos)
++static void LzmaEnc_FastPosInit(Byte *g_FastPos)
+ {
+   int c = 2, slotFast;
+   g_FastPos[0] = 0;
+@@ -339,58 +339,6 @@ typedef struct
+   CSaveState saveState;
+ } CLzmaEnc;
+ 
+-void LzmaEnc_SaveState(CLzmaEncHandle pp)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  CSaveState *dest = &p->saveState;
+-  int i;
+-  dest->lenEnc = p->lenEnc;
+-  dest->repLenEnc = p->repLenEnc;
+-  dest->state = p->state;
+-
+-  for (i = 0; i < kNumStates; i++)
+-  {
+-    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
+-    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
+-  }
+-  for (i = 0; i < kNumLenToPosStates; i++)
+-    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
+-  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
+-  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
+-  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
+-  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
+-  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
+-  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
+-  memcpy(dest->reps, p->reps, sizeof(p->reps));
+-  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
+-}
+-
+-void LzmaEnc_RestoreState(CLzmaEncHandle pp)
+-{
+-  CLzmaEnc *dest = (CLzmaEnc *)pp;
+-  const CSaveState *p = &dest->saveState;
+-  int i;
+-  dest->lenEnc = p->lenEnc;
+-  dest->repLenEnc = p->repLenEnc;
+-  dest->state = p->state;
+-
+-  for (i = 0; i < kNumStates; i++)
+-  {
+-    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
+-    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
+-  }
+-  for (i = 0; i < kNumLenToPosStates; i++)
+-    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
+-  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
+-  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
+-  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
+-  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
+-  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
+-  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
+-  memcpy(dest->reps, p->reps, sizeof(p->reps));
+-  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
+-}
+-
+ SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
+ {
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -600,7 +548,7 @@ static void LitEnc_EncodeMatched(CRangeE
+   while (symbol < 0x10000);
+ }
+ 
+-void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
++static void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
+ {
+   UInt32 i;
+   for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
+@@ -1676,7 +1624,7 @@ static void FillDistancesPrices(CLzmaEnc
+   p->matchPriceCount = 0;
+ }
+ 
+-void LzmaEnc_Construct(CLzmaEnc *p)
++static void LzmaEnc_Construct(CLzmaEnc *p)
+ {
+   RangeEnc_Construct(&p->rc);
+   MatchFinder_Construct(&p->matchFinderBase);
+@@ -1709,7 +1657,7 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
+   return p;
+ }
+ 
+-void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
++static void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
+ {
+   alloc->Free(alloc, p->litProbs);
+   alloc->Free(alloc, p->saveState.litProbs);
+@@ -1717,7 +1665,7 @@ void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAl
+   p->saveState.litProbs = 0;
+ }
+ 
+-void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
++static void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
+ {
+   #ifndef _7ZIP_ST
+   MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
+@@ -1947,7 +1895,7 @@ static SRes LzmaEnc_Alloc(CLzmaEnc *p, U
+   return SZ_OK;
+ }
+ 
+-void LzmaEnc_Init(CLzmaEnc *p)
++static void LzmaEnc_Init(CLzmaEnc *p)
+ {
+   UInt32 i;
+   p->state = 0;
+@@ -2005,7 +1953,7 @@ void LzmaEnc_Init(CLzmaEnc *p)
+   p->lpMask = (1 << p->lp) - 1;
+ }
+ 
+-void LzmaEnc_InitPrices(CLzmaEnc *p)
++static void LzmaEnc_InitPrices(CLzmaEnc *p)
+ {
+   if (!p->fastMode)
+   {
+@@ -2037,26 +1985,6 @@ static SRes LzmaEnc_AllocAndInit(CLzmaEn
+   return SZ_OK;
+ }
+ 
+-static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
+-    ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  p->matchFinderBase.stream = inStream;
+-  p->needInit = 1;
+-  p->rc.outStream = outStream;
+-  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
+-}
+-
+-SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
+-    ISeqInStream *inStream, UInt32 keepWindowSize,
+-    ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  p->matchFinderBase.stream = inStream;
+-  p->needInit = 1;
+-  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+-}
+-
+ static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
+ {
+   p->matchFinderBase.directInput = 1;
+@@ -2064,7 +1992,7 @@ static void LzmaEnc_SetInputBuf(CLzmaEnc
+   p->matchFinderBase.directInputRem = srcLen;
+ }
+ 
+-SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
++static SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
+     UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+ {
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -2074,7 +2002,7 @@ SRes LzmaEnc_MemPrepare(CLzmaEncHandle p
+   return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+ }
+ 
+-void LzmaEnc_Finish(CLzmaEncHandle pp)
++static void LzmaEnc_Finish(CLzmaEncHandle pp)
+ {
+   #ifndef _7ZIP_ST
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -2107,53 +2035,6 @@ static size_t MyWrite(void *pp, const vo
+   return size;
+ }
+ 
+-
+-UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
+-{
+-  const CLzmaEnc *p = (CLzmaEnc *)pp;
+-  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
+-}
+-
+-const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
+-{
+-  const CLzmaEnc *p = (CLzmaEnc *)pp;
+-  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
+-}
+-
+-SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
+-    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  UInt64 nowPos64;
+-  SRes res;
+-  CSeqOutStreamBuf outStream;
+-
+-  outStream.funcTable.Write = MyWrite;
+-  outStream.data = dest;
+-  outStream.rem = *destLen;
+-  outStream.overflow = False;
+-
+-  p->writeEndMark = False;
+-  p->finished = False;
+-  p->result = SZ_OK;
+-
+-  if (reInit)
+-    LzmaEnc_Init(p);
+-  LzmaEnc_InitPrices(p);
+-  nowPos64 = p->nowPos64;
+-  RangeEnc_Init(&p->rc);
+-  p->rc.outStream = &outStream.funcTable;
+-
+-  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
+-  
+-  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
+-  *destLen -= outStream.rem;
+-  if (outStream.overflow)
+-    return SZ_ERROR_OUTPUT_EOF;
+-
+-  return res;
+-}
+-
+ static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
+ {
+   SRes res = SZ_OK;
+@@ -2184,13 +2065,6 @@ static SRes LzmaEnc_Encode2(CLzmaEnc *p,
+   return res;
+ }
+ 
+-SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
+-    ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
+-  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
+-}
+-
+ SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
+ {
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -2247,25 +2121,3 @@ SRes LzmaEnc_MemEncode(CLzmaEncHandle pp
+     return SZ_ERROR_OUTPUT_EOF;
+   return res;
+ }
+-
+-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
+-  SRes res;
+-  if (p == 0)
+-    return SZ_ERROR_MEM;
+-
+-  res = LzmaEnc_SetProps(p, props);
+-  if (res == SZ_OK)
+-  {
+-    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
+-    if (res == SZ_OK)
+-      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
+-          writeEndMark, progress, alloc, allocBig);
+-  }
+-
+-  LzmaEnc_Destroy(p, alloc, allocBig);
+-  return res;
+-}
+--- a/include/linux/lzma/LzFind.h
++++ b/include/linux/lzma/LzFind.h
+@@ -55,11 +55,6 @@ typedef struct _CMatchFinder
+ 
+ #define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
+ 
+-int MatchFinder_NeedMove(CMatchFinder *p);
+-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
+-void MatchFinder_MoveBlock(CMatchFinder *p);
+-void MatchFinder_ReadIfRequired(CMatchFinder *p);
+-
+ void MatchFinder_Construct(CMatchFinder *p);
+ 
+ /* Conditions:
+@@ -70,12 +65,6 @@ int MatchFinder_Create(CMatchFinder *p,
+     UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
+     ISzAlloc *alloc);
+ void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
+-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
+-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
+-
+-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
+-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+-    UInt32 *distances, UInt32 maxLen);
+ 
+ /*
+ Conditions:
+@@ -102,12 +91,6 @@ typedef struct _IMatchFinder
+ 
+ void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
+ 
+-void MatchFinder_Init(CMatchFinder *p);
+-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+-
+ #ifdef __cplusplus
+ }
+ #endif
+--- a/lib/lzma/LzFind.c
++++ b/lib/lzma/LzFind.c
+@@ -14,9 +14,15 @@
+ 
+ #define kStartMaxLen 3
+ 
++#if 0
++#define DIRECT_INPUT	p->directInput
++#else
++#define DIRECT_INPUT	1
++#endif
++
+ static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
+ {
+-  if (!p->directInput)
++  if (!DIRECT_INPUT)
+   {
+     alloc->Free(alloc, p->bufferBase);
+     p->bufferBase = 0;
+@@ -28,7 +34,7 @@ static void LzInWindow_Free(CMatchFinder
+ static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
+ {
+   UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
+-  if (p->directInput)
++  if (DIRECT_INPUT)
+   {
+     p->blockSize = blockSize;
+     return 1;
+@@ -42,12 +48,12 @@ static int LzInWindow_Create(CMatchFinde
+   return (p->bufferBase != 0);
+ }
+ 
+-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
+-Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
++static Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
++static Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
+ 
+-UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
++static UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
+ 
+-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
++static void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
+ {
+   p->posLimit -= subValue;
+   p->pos -= subValue;
+@@ -58,7 +64,7 @@ static void MatchFinder_ReadBlock(CMatch
+ {
+   if (p->streamEndWasReached || p->result != SZ_OK)
+     return;
+-  if (p->directInput)
++  if (DIRECT_INPUT)
+   {
+     UInt32 curSize = 0xFFFFFFFF - p->streamPos;
+     if (curSize > p->directInputRem)
+@@ -89,7 +95,7 @@ static void MatchFinder_ReadBlock(CMatch
+   }
+ }
+ 
+-void MatchFinder_MoveBlock(CMatchFinder *p)
++static void MatchFinder_MoveBlock(CMatchFinder *p)
+ {
+   memmove(p->bufferBase,
+     p->buffer - p->keepSizeBefore,
+@@ -97,22 +103,14 @@ void MatchFinder_MoveBlock(CMatchFinder
+   p->buffer = p->bufferBase + p->keepSizeBefore;
+ }
+ 
+-int MatchFinder_NeedMove(CMatchFinder *p)
++static int MatchFinder_NeedMove(CMatchFinder *p)
+ {
+-  if (p->directInput)
++  if (DIRECT_INPUT)
+     return 0;
+   /* if (p->streamEndWasReached) return 0; */
+   return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
+ }
+ 
+-void MatchFinder_ReadIfRequired(CMatchFinder *p)
+-{
+-  if (p->streamEndWasReached)
+-    return;
+-  if (p->keepSizeAfter >= p->streamPos - p->pos)
+-    MatchFinder_ReadBlock(p);
+-}
+-
+ static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
+ {
+   if (MatchFinder_NeedMove(p))
+@@ -268,7 +266,7 @@ static void MatchFinder_SetLimits(CMatch
+   p->posLimit = p->pos + limit;
+ }
+ 
+-void MatchFinder_Init(CMatchFinder *p)
++static void MatchFinder_Init(CMatchFinder *p)
+ {
+   UInt32 i;
+   for (i = 0; i < p->hashSizeSum; i++)
+@@ -287,7 +285,7 @@ static UInt32 MatchFinder_GetSubValue(CM
+   return (p->pos - p->historySize - 1) & kNormalizeMask;
+ }
+ 
+-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
++static void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
+ {
+   UInt32 i;
+   for (i = 0; i < numItems; i++)
+@@ -319,38 +317,7 @@ static void MatchFinder_CheckLimits(CMat
+   MatchFinder_SetLimits(p);
+ }
+ 
+-static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+-    UInt32 *distances, UInt32 maxLen)
+-{
+-  son[_cyclicBufferPos] = curMatch;
+-  for (;;)
+-  {
+-    UInt32 delta = pos - curMatch;
+-    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+-      return distances;
+-    {
+-      const Byte *pb = cur - delta;
+-      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
+-      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
+-      {
+-        UInt32 len = 0;
+-        while (++len != lenLimit)
+-          if (pb[len] != cur[len])
+-            break;
+-        if (maxLen < len)
+-        {
+-          *distances++ = maxLen = len;
+-          *distances++ = delta - 1;
+-          if (len == lenLimit)
+-            return distances;
+-        }
+-      }
+-    }
+-  }
+-}
+-
+-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++static UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+     UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+     UInt32 *distances, UInt32 maxLen)
+ {
+@@ -460,10 +427,10 @@ static void SkipMatchesSpec(UInt32 lenLi
+   p->buffer++; \
+   if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
+ 
+-#define MOVE_POS_RET MOVE_POS return offset;
+-
+ static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
+ 
++#define MOVE_POS_RET MatchFinder_MovePos(p); return offset;
++
+ #define GET_MATCHES_HEADER2(minLen, ret_op) \
+   UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
+   lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
+@@ -479,62 +446,7 @@ static void MatchFinder_MovePos(CMatchFi
+   distances + offset, maxLen) - distances); MOVE_POS_RET;
+ 
+ #define SKIP_FOOTER \
+-  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
+-
+-static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 offset;
+-  GET_MATCHES_HEADER(2)
+-  HASH2_CALC;
+-  curMatch = p->hash[hashValue];
+-  p->hash[hashValue] = p->pos;
+-  offset = 0;
+-  GET_MATCHES_FOOTER(offset, 1)
+-}
+-
+-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 offset;
+-  GET_MATCHES_HEADER(3)
+-  HASH_ZIP_CALC;
+-  curMatch = p->hash[hashValue];
+-  p->hash[hashValue] = p->pos;
+-  offset = 0;
+-  GET_MATCHES_FOOTER(offset, 2)
+-}
+-
+-static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 hash2Value, delta2, maxLen, offset;
+-  GET_MATCHES_HEADER(3)
+-
+-  HASH3_CALC;
+-
+-  delta2 = p->pos - p->hash[hash2Value];
+-  curMatch = p->hash[kFix3HashSize + hashValue];
+-  
+-  p->hash[hash2Value] =
+-  p->hash[kFix3HashSize + hashValue] = p->pos;
+-
+-
+-  maxLen = 2;
+-  offset = 0;
+-  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+-  {
+-    for (; maxLen != lenLimit; maxLen++)
+-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+-        break;
+-    distances[0] = maxLen;
+-    distances[1] = delta2 - 1;
+-    offset = 2;
+-    if (maxLen == lenLimit)
+-    {
+-      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
+-      MOVE_POS_RET;
+-    }
+-  }
+-  GET_MATCHES_FOOTER(offset, maxLen)
+-}
++  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MatchFinder_MovePos(p);
+ 
+ static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+ {
+@@ -583,108 +495,6 @@ static UInt32 Bt4_MatchFinder_GetMatches
+   GET_MATCHES_FOOTER(offset, maxLen)
+ }
+ 
+-static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
+-  GET_MATCHES_HEADER(4)
+-
+-  HASH4_CALC;
+-
+-  delta2 = p->pos - p->hash[                hash2Value];
+-  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
+-  curMatch = p->hash[kFix4HashSize + hashValue];
+-
+-  p->hash[                hash2Value] =
+-  p->hash[kFix3HashSize + hash3Value] =
+-  p->hash[kFix4HashSize + hashValue] = p->pos;
+-
+-  maxLen = 1;
+-  offset = 0;
+-  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+-  {
+-    distances[0] = maxLen = 2;
+-    distances[1] = delta2 - 1;
+-    offset = 2;
+-  }
+-  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
+-  {
+-    maxLen = 3;
+-    distances[offset + 1] = delta3 - 1;
+-    offset += 2;
+-    delta2 = delta3;
+-  }
+-  if (offset != 0)
+-  {
+-    for (; maxLen != lenLimit; maxLen++)
+-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+-        break;
+-    distances[offset - 2] = maxLen;
+-    if (maxLen == lenLimit)
+-    {
+-      p->son[p->cyclicBufferPos] = curMatch;
+-      MOVE_POS_RET;
+-    }
+-  }
+-  if (maxLen < 3)
+-    maxLen = 3;
+-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+-    distances + offset, maxLen) - (distances));
+-  MOVE_POS_RET
+-}
+-
+-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 offset;
+-  GET_MATCHES_HEADER(3)
+-  HASH_ZIP_CALC;
+-  curMatch = p->hash[hashValue];
+-  p->hash[hashValue] = p->pos;
+-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+-    distances, 2) - (distances));
+-  MOVE_POS_RET
+-}
+-
+-static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    SKIP_HEADER(2)
+-    HASH2_CALC;
+-    curMatch = p->hash[hashValue];
+-    p->hash[hashValue] = p->pos;
+-    SKIP_FOOTER
+-  }
+-  while (--num != 0);
+-}
+-
+-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    SKIP_HEADER(3)
+-    HASH_ZIP_CALC;
+-    curMatch = p->hash[hashValue];
+-    p->hash[hashValue] = p->pos;
+-    SKIP_FOOTER
+-  }
+-  while (--num != 0);
+-}
+-
+-static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    UInt32 hash2Value;
+-    SKIP_HEADER(3)
+-    HASH3_CALC;
+-    curMatch = p->hash[kFix3HashSize + hashValue];
+-    p->hash[hash2Value] =
+-    p->hash[kFix3HashSize + hashValue] = p->pos;
+-    SKIP_FOOTER
+-  }
+-  while (--num != 0);
+-}
+-
+ static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+ {
+   do
+@@ -701,61 +511,12 @@ static void Bt4_MatchFinder_Skip(CMatchF
+   while (--num != 0);
+ }
+ 
+-static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    UInt32 hash2Value, hash3Value;
+-    SKIP_HEADER(4)
+-    HASH4_CALC;
+-    curMatch = p->hash[kFix4HashSize + hashValue];
+-    p->hash[                hash2Value] =
+-    p->hash[kFix3HashSize + hash3Value] =
+-    p->hash[kFix4HashSize + hashValue] = p->pos;
+-    p->son[p->cyclicBufferPos] = curMatch;
+-    MOVE_POS
+-  }
+-  while (--num != 0);
+-}
+-
+-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    SKIP_HEADER(3)
+-    HASH_ZIP_CALC;
+-    curMatch = p->hash[hashValue];
+-    p->hash[hashValue] = p->pos;
+-    p->son[p->cyclicBufferPos] = curMatch;
+-    MOVE_POS
+-  }
+-  while (--num != 0);
+-}
+-
+ void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
+ {
+   vTable->Init = (Mf_Init_Func)MatchFinder_Init;
+   vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
+   vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
+   vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
+-  if (!p->btMode)
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
+-  }
+-  else if (p->numHashBytes == 2)
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
+-  }
+-  else if (p->numHashBytes == 3)
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
+-  }
+-  else
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
+-  }
++  vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
++  vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
+ }
diff --git a/target/linux/generic/patches-3.10/532-jffs2_eofdetect.patch b/target/linux/generic/patches-3.10/532-jffs2_eofdetect.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/532-jffs2_eofdetect.patch
@@ -0,0 +1,57 @@
+Index: kernel_tree/fs/jffs2/build.c
+===================================================================
+--- kernel_tree.orig/fs/jffs2/build.c
++++ kernel_tree/fs/jffs2/build.c
+@@ -116,6 +116,16 @@ static int jffs2_build_filesystem(struct
+ 	dbg_fsbuild("scanned flash completely\n");
+ 	jffs2_dbg_dump_block_lists_nolock(c);
+ 
++	if (c->flags & (1 << 7)) {
++		printk("%s(): unlocking the mtd device... ", __func__);
++		mtd_unlock(c->mtd, 0, c->mtd->size);
++		printk("done.\n");
++
++		printk("%s(): erasing all blocks after the end marker... ", __func__);
++		jffs2_erase_pending_blocks(c, -1);
++		printk("done.\n");
++	}
++
+ 	dbg_fsbuild("pass 1 starting\n");
+ 	c->flags |= JFFS2_SB_FLAG_BUILDING;
+ 	/* Now scan the directory tree, increasing nlink according to every dirent found. */
+Index: kernel_tree/fs/jffs2/scan.c
+===================================================================
+--- kernel_tree.orig/fs/jffs2/scan.c
++++ kernel_tree/fs/jffs2/scan.c
+@@ -148,8 +148,11 @@ int jffs2_scan_medium(struct jffs2_sb_in
+ 		/* reset summary info for next eraseblock scan */
+ 		jffs2_sum_reset_collected(s);
+ 
+-		ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
+-						buf_size, s);
++		if (c->flags & (1 << 7))
++			ret = BLK_STATE_ALLFF;
++		else
++			ret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),
++							buf_size, s);
+ 
+ 		if (ret < 0)
+ 			goto out;
+@@ -561,6 +564,17 @@ full_scan:
+ 			return err;
+ 	}
+ 
++	if ((buf[0] == 0xde) &&
++		(buf[1] == 0xad) &&
++		(buf[2] == 0xc0) &&
++		(buf[3] == 0xde)) {
++		/* end of filesystem. erase everything after this point */
++		printk("%s(): End of filesystem marker found at 0x%x\n", __func__, jeb->offset);
++		c->flags |= (1 << 7);
++
++		return BLK_STATE_ALLFF;
++	}
++
+ 	/* We temporarily use 'ofs' as a pointer into the buffer/jeb */
+ 	ofs = 0;
+ 	max_ofs = EMPTY_SCAN_SIZE(c->sector_size);
diff --git a/target/linux/generic/patches-3.10/540-crypto-xz-decompression-support.patch b/target/linux/generic/patches-3.10/540-crypto-xz-decompression-support.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/540-crypto-xz-decompression-support.patch
@@ -0,0 +1,146 @@
+--- a/crypto/Kconfig
++++ b/crypto/Kconfig
+@@ -1361,6 +1361,13 @@ config CRYPTO_842
+ 	help
+ 	  This is the 842 algorithm.
+ 
++config CRYPTO_XZ
++	tristate "XZ compression algorithm"
++	select CRYPTO_ALGAPI
++	select XZ_DEC
++	help
++	  This is the XZ algorithm. Only decompression is supported for now.
++
+ comment "Random Number Generation"
+ 
+ config CRYPTO_ANSI_CPRNG
+--- a/crypto/Makefile
++++ b/crypto/Makefile
+@@ -85,6 +85,7 @@ obj-$(CONFIG_CRYPTO_CRC32C) += crc32c.o
+ obj-$(CONFIG_CRYPTO_CRC32) += crc32.o
+ obj-$(CONFIG_CRYPTO_AUTHENC) += authenc.o authencesn.o
+ obj-$(CONFIG_CRYPTO_LZO) += lzo.o
++obj-$(CONFIG_CRYPTO_XZ) += xz.o
+ obj-$(CONFIG_CRYPTO_842) += 842.o
+ obj-$(CONFIG_CRYPTO_RNG2) += rng.o
+ obj-$(CONFIG_CRYPTO_RNG2) += krng.o
+--- /dev/null
++++ b/crypto/xz.c
+@@ -0,0 +1,117 @@
++/*
++ * Cryptographic API.
++ *
++ * XZ decompression support.
++ *
++ * Copyright (c) 2012 Gabor Juhos <juhosg@openwrt.org>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 as published by
++ * the Free Software Foundation.
++ *
++ */
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/crypto.h>
++#include <linux/xz.h>
++#include <linux/interrupt.h>
++#include <linux/mm.h>
++#include <linux/net.h>
++
++struct xz_comp_ctx {
++	struct xz_dec	*decomp_state;
++	struct xz_buf	decomp_buf;
++};
++
++static int crypto_xz_decomp_init(struct xz_comp_ctx *ctx)
++{
++	ctx->decomp_state = xz_dec_init(XZ_SINGLE, 0);
++	if (!ctx->decomp_state)
++		return -ENOMEM;
++
++	return 0;
++}
++
++static void crypto_xz_decomp_exit(struct xz_comp_ctx *ctx)
++{
++	xz_dec_end(ctx->decomp_state);
++}
++
++static int crypto_xz_init(struct crypto_tfm *tfm)
++{
++	struct xz_comp_ctx *ctx = crypto_tfm_ctx(tfm);
++
++	return crypto_xz_decomp_init(ctx);
++}
++
++static void crypto_xz_exit(struct crypto_tfm *tfm)
++{
++	struct xz_comp_ctx *ctx = crypto_tfm_ctx(tfm);
++
++	crypto_xz_decomp_exit(ctx);
++}
++
++static int crypto_xz_compress(struct crypto_tfm *tfm, const u8 *src,
++			      unsigned int slen, u8 *dst, unsigned int *dlen)
++{
++	return -EOPNOTSUPP;
++}
++
++static int crypto_xz_decompress(struct crypto_tfm *tfm, const u8 *src,
++				unsigned int slen, u8 *dst, unsigned int *dlen)
++{
++	struct xz_comp_ctx *dctx = crypto_tfm_ctx(tfm);
++	struct xz_buf *xz_buf = &dctx->decomp_buf;
++	int ret;
++
++	memset(xz_buf, '\0', sizeof(struct xz_buf));
++
++	xz_buf->in = (u8 *) src;
++	xz_buf->in_pos = 0;
++	xz_buf->in_size = slen;
++	xz_buf->out = (u8 *) dst;
++	xz_buf->out_pos = 0;
++	xz_buf->out_size = *dlen;
++
++	ret = xz_dec_run(dctx->decomp_state, xz_buf);
++	if (ret != XZ_STREAM_END) {
++		ret = -EINVAL;
++		goto out;
++	}
++
++	*dlen = xz_buf->out_pos;
++	ret = 0;
++
++out:
++	return ret;
++}
++
++static struct crypto_alg crypto_xz_alg = {
++	.cra_name		= "xz",
++	.cra_flags		= CRYPTO_ALG_TYPE_COMPRESS,
++	.cra_ctxsize		= sizeof(struct xz_comp_ctx),
++	.cra_module		= THIS_MODULE,
++	.cra_list		= LIST_HEAD_INIT(crypto_xz_alg.cra_list),
++	.cra_init		= crypto_xz_init,
++	.cra_exit		= crypto_xz_exit,
++	.cra_u			= { .compress = {
++	.coa_compress 		= crypto_xz_compress,
++	.coa_decompress  	= crypto_xz_decompress } }
++};
++
++static int __init crypto_xz_mod_init(void)
++{
++	return crypto_register_alg(&crypto_xz_alg);
++}
++
++static void __exit crypto_xz_mod_exit(void)
++{
++	crypto_unregister_alg(&crypto_xz_alg);
++}
++
++module_init(crypto_xz_mod_init);
++module_exit(crypto_xz_mod_exit);
++
++MODULE_LICENSE("GPL v2");
++MODULE_DESCRIPTION("Crypto XZ decompression support");
++MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
diff --git a/target/linux/generic/patches-3.10/541-ubifs-xz-decompression-support.patch b/target/linux/generic/patches-3.10/541-ubifs-xz-decompression-support.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/541-ubifs-xz-decompression-support.patch
@@ -0,0 +1,92 @@
+--- a/fs/ubifs/Kconfig
++++ b/fs/ubifs/Kconfig
+@@ -5,8 +5,10 @@ config UBIFS_FS
+ 	select CRYPTO if UBIFS_FS_ADVANCED_COMPR
+ 	select CRYPTO if UBIFS_FS_LZO
+ 	select CRYPTO if UBIFS_FS_ZLIB
++	select CRYPTO if UBIFS_FS_XZ
+ 	select CRYPTO_LZO if UBIFS_FS_LZO
+ 	select CRYPTO_DEFLATE if UBIFS_FS_ZLIB
++	select CRYPTO_XZ if UBIFS_FS_XZ
+ 	depends on MTD_UBI
+ 	help
+ 	  UBIFS is a file system for flash devices which works on top of UBI.
+@@ -35,3 +37,12 @@ config UBIFS_FS_ZLIB
+ 	default y
+ 	help
+ 	  Zlib compresses better than LZO but it is slower. Say 'Y' if unsure.
++
++config UBIFS_FS_XZ
++	bool "XZ decompression support" if UBIFS_FS_ADVANCED_COMPR
++	depends on UBIFS_FS
++	default y
++	help
++	  XZ compresses better the ZLIB but it is slower..
++	  Say 'Y' if unsure.
++
+--- a/fs/ubifs/compress.c
++++ b/fs/ubifs/compress.c
+@@ -71,6 +71,24 @@ static struct ubifs_compressor zlib_comp
+ };
+ #endif
+ 
++#ifdef CONFIG_UBIFS_FS_XZ
++static DEFINE_MUTEX(xz_enc_mutex);
++static DEFINE_MUTEX(xz_dec_mutex);
++
++static struct ubifs_compressor xz_compr = {
++	.compr_type = UBIFS_COMPR_XZ,
++	.comp_mutex = &xz_enc_mutex,
++	.decomp_mutex = &xz_dec_mutex,
++	.name = "xz",
++	.capi_name = "xz",
++};
++#else
++static struct ubifs_compressor xz_compr = {
++	.compr_type = UBIFS_COMPR_XZ,
++	.name = "xz",
++};
++#endif
++
+ /* All UBIFS compressors */
+ struct ubifs_compressor *ubifs_compressors[UBIFS_COMPR_TYPES_CNT];
+ 
+@@ -232,9 +250,15 @@ int __init ubifs_compressors_init(void)
+ 	if (err)
+ 		goto out_lzo;
+ 
++	err = compr_init(&xz_compr);
++	if (err)
++		goto out_zlib;
++
+ 	ubifs_compressors[UBIFS_COMPR_NONE] = &none_compr;
+ 	return 0;
+ 
++out_zlib:
++	compr_exit(&zlib_compr);
+ out_lzo:
+ 	compr_exit(&lzo_compr);
+ 	return err;
+@@ -247,4 +271,5 @@ void ubifs_compressors_exit(void)
+ {
+ 	compr_exit(&lzo_compr);
+ 	compr_exit(&zlib_compr);
++	compr_exit(&xz_compr);
+ }
+--- a/fs/ubifs/ubifs-media.h
++++ b/fs/ubifs/ubifs-media.h
+@@ -332,12 +332,14 @@ enum {
+  * UBIFS_COMPR_NONE: no compression
+  * UBIFS_COMPR_LZO: LZO compression
+  * UBIFS_COMPR_ZLIB: ZLIB compression
++ * UBIFS_COMPR_XZ: XZ compression
+  * UBIFS_COMPR_TYPES_CNT: count of supported compression types
+  */
+ enum {
+ 	UBIFS_COMPR_NONE,
+ 	UBIFS_COMPR_LZO,
+ 	UBIFS_COMPR_ZLIB,
++	UBIFS_COMPR_XZ,
+ 	UBIFS_COMPR_TYPES_CNT,
+ };
+ 
diff --git a/target/linux/generic/patches-3.10/550-ubifs-symlink-xattr-support.patch b/target/linux/generic/patches-3.10/550-ubifs-symlink-xattr-support.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/550-ubifs-symlink-xattr-support.patch
@@ -0,0 +1,73 @@
+Index: kernel_tree/fs/ubifs/file.c
+===================================================================
+--- kernel_tree.orig/fs/ubifs/file.c
++++ kernel_tree/fs/ubifs/file.c
+@@ -1575,6 +1575,12 @@ const struct inode_operations ubifs_syml
+ 	.follow_link = ubifs_follow_link,
+ 	.setattr     = ubifs_setattr,
+ 	.getattr     = ubifs_getattr,
++#ifdef CONFIG_UBIFS_FS_XATTR
++	.setxattr    = ubifs_setxattr,
++	.getxattr    = ubifs_getxattr,
++	.listxattr   = ubifs_listxattr,
++	.removexattr = ubifs_removexattr,
++#endif
+ };
+ 
+ const struct file_operations ubifs_file_operations = {
+Index: kernel_tree/fs/ubifs/journal.c
+===================================================================
+--- kernel_tree.orig/fs/ubifs/journal.c
++++ kernel_tree/fs/ubifs/journal.c
+@@ -553,7 +553,8 @@ int ubifs_jnl_update(struct ubifs_info *
+ 
+ 	dbg_jnl("ino %lu, dent '%.*s', data len %d in dir ino %lu",
+ 		inode->i_ino, nm->len, nm->name, ui->data_len, dir->i_ino);
+-	ubifs_assert(dir_ui->data_len == 0);
++	if (!xent)
++		ubifs_assert(dir_ui->data_len == 0);
+ 	ubifs_assert(mutex_is_locked(&dir_ui->ui_mutex));
+ 
+ 	dlen = UBIFS_DENT_NODE_SZ + nm->len + 1;
+@@ -573,6 +574,13 @@ int ubifs_jnl_update(struct ubifs_info *
+ 	aligned_dlen = ALIGN(dlen, 8);
+ 	aligned_ilen = ALIGN(ilen, 8);
+ 	len = aligned_dlen + aligned_ilen + UBIFS_INO_NODE_SZ;
++	if (xent) {
++		/*
++		 * Make sure to account for dir_ui->data_len in
++		 * length calculation in case there is extended attribute.
++		 */
++		len += dir_ui->data_len;
++	}
+ 	dent = kmalloc(len, GFP_NOFS);
+ 	if (!dent)
+ 		return -ENOMEM;
+@@ -649,7 +657,8 @@ int ubifs_jnl_update(struct ubifs_info *
+ 
+ 	ino_key_init(c, &ino_key, dir->i_ino);
+ 	ino_offs += aligned_ilen;
+-	err = ubifs_tnc_add(c, &ino_key, lnum, ino_offs, UBIFS_INO_NODE_SZ);
++	err = ubifs_tnc_add(c, &ino_key, lnum, ino_offs,
++			    UBIFS_INO_NODE_SZ + dir_ui->data_len);
+ 	if (err)
+ 		goto out_ro;
+ 
+Index: kernel_tree/fs/ubifs/xattr.c
+===================================================================
+--- kernel_tree.orig/fs/ubifs/xattr.c
++++ kernel_tree/fs/ubifs/xattr.c
+@@ -209,12 +209,12 @@ static int change_xattr(struct ubifs_inf
+ 		goto out_free;
+ 	}
+ 	inode->i_size = ui->ui_size = size;
+-	ui->data_len = size;
+ 
+ 	mutex_lock(&host_ui->ui_mutex);
+ 	host->i_ctime = ubifs_current_time(host);
+ 	host_ui->xattr_size -= CALC_XATTR_BYTES(ui->data_len);
+ 	host_ui->xattr_size += CALC_XATTR_BYTES(size);
++	ui->data_len = size;
+ 
+ 	/*
+ 	 * It is important to write the host inode after the xattr inode
diff --git a/target/linux/generic/patches-3.10/551-ubifs-fix-default-compression-selection.patch b/target/linux/generic/patches-3.10/551-ubifs-fix-default-compression-selection.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/551-ubifs-fix-default-compression-selection.patch
@@ -0,0 +1,29 @@
+--- a/fs/ubifs/sb.c
++++ b/fs/ubifs/sb.c
+@@ -63,6 +63,17 @@
+ /* Default time granularity in nanoseconds */
+ #define DEFAULT_TIME_GRAN 1000000000
+ 
++static int get_default_compressor(void)
++{
++	if (ubifs_compr_present(UBIFS_COMPR_LZO))
++		return UBIFS_COMPR_LZO;
++
++	if (ubifs_compr_present(UBIFS_COMPR_ZLIB))
++		return UBIFS_COMPR_ZLIB;
++
++	return UBIFS_COMPR_NONE;
++}
++
+ /**
+  * create_default_filesystem - format empty UBI volume.
+  * @c: UBIFS file-system description object
+@@ -183,7 +194,7 @@ static int create_default_filesystem(str
+ 	if (c->mount_opts.override_compr)
+ 		sup->default_compr = cpu_to_le16(c->mount_opts.compr_type);
+ 	else
+-		sup->default_compr = cpu_to_le16(UBIFS_COMPR_LZO);
++		sup->default_compr = cpu_to_le16(get_default_compressor());
+ 
+ 	generate_random_uuid(sup->uuid);
+ 
diff --git a/target/linux/generic/patches-3.10/600-netfilter_layer7_2.22.patch b/target/linux/generic/patches-3.10/600-netfilter_layer7_2.22.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/600-netfilter_layer7_2.22.patch
@@ -0,0 +1,2141 @@
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -1203,6 +1203,27 @@ config NETFILTER_XT_MATCH_STATE
+ 
+ 	  To compile it as a module, choose M here.  If unsure, say N.
+ 
++config NETFILTER_XT_MATCH_LAYER7
++	tristate '"layer7" match support'
++	depends on NETFILTER_XTABLES
++	depends on EXPERIMENTAL && (IP_NF_CONNTRACK || NF_CONNTRACK)
++       depends on NETFILTER_ADVANCED
++	help
++	  Say Y if you want to be able to classify connections (and their
++	  packets) based on regular expression matching of their application
++	  layer data.   This is one way to classify applications such as
++	  peer-to-peer filesharing systems that do not always use the same
++	  port.
++
++	  To compile it as a module, choose M here.  If unsure, say N.
++
++config NETFILTER_XT_MATCH_LAYER7_DEBUG
++        bool 'Layer 7 debugging output'
++        depends on NETFILTER_XT_MATCH_LAYER7
++        help
++          Say Y to get lots of debugging output.
++
++
+ config NETFILTER_XT_MATCH_STATISTIC
+ 	tristate '"statistic" match support'
+ 	depends on NETFILTER_ADVANCED
+--- a/net/netfilter/Makefile
++++ b/net/netfilter/Makefile
+@@ -134,6 +134,7 @@ obj-$(CONFIG_NETFILTER_XT_MATCH_RECENT)
+ obj-$(CONFIG_NETFILTER_XT_MATCH_SCTP) += xt_sctp.o
+ obj-$(CONFIG_NETFILTER_XT_MATCH_SOCKET) += xt_socket.o
+ obj-$(CONFIG_NETFILTER_XT_MATCH_STATE) += xt_state.o
++obj-$(CONFIG_NETFILTER_XT_MATCH_LAYER7) += xt_layer7.o
+ obj-$(CONFIG_NETFILTER_XT_MATCH_STATISTIC) += xt_statistic.o
+ obj-$(CONFIG_NETFILTER_XT_MATCH_STRING) += xt_string.o
+ obj-$(CONFIG_NETFILTER_XT_MATCH_TCPMSS) += xt_tcpmss.o
+--- /dev/null
++++ b/net/netfilter/xt_layer7.c
+@@ -0,0 +1,666 @@
++/*
++  Kernel module to match application layer (OSI layer 7) data in connections.
++
++  http://l7-filter.sf.net
++
++  (C) 2003-2009 Matthew Strait and Ethan Sommer.
++
++  This program is free software; you can redistribute it and/or
++  modify it under the terms of the GNU General Public License
++  as published by the Free Software Foundation; either version
++  2 of the License, or (at your option) any later version.
++  http://www.gnu.org/licenses/gpl.txt
++
++  Based on ipt_string.c (C) 2000 Emmanuel Roger <winfield@freegates.be>,
++  xt_helper.c (C) 2002 Harald Welte and cls_layer7.c (C) 2003 Matthew Strait,
++  Ethan Sommer, Justin Levandoski.
++*/
++
++#include <linux/spinlock.h>
++#include <linux/version.h>
++#include <net/ip.h>
++#include <net/tcp.h>
++#include <linux/module.h>
++#include <linux/skbuff.h>
++#include <linux/netfilter.h>
++#include <net/netfilter/nf_conntrack.h>
++#include <net/netfilter/nf_conntrack_core.h>
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
++#include <net/netfilter/nf_conntrack_extend.h>
++#include <net/netfilter/nf_conntrack_acct.h>
++#endif
++#include <linux/netfilter/x_tables.h>
++#include <linux/netfilter/xt_layer7.h>
++#include <linux/ctype.h>
++#include <linux/proc_fs.h>
++
++#include "regexp/regexp.c"
++
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Matthew Strait <quadong@users.sf.net>, Ethan Sommer <sommere@users.sf.net>");
++MODULE_DESCRIPTION("iptables application layer match module");
++MODULE_ALIAS("ipt_layer7");
++MODULE_VERSION("2.21");
++
++static int maxdatalen = 2048; // this is the default
++module_param(maxdatalen, int, 0444);
++MODULE_PARM_DESC(maxdatalen, "maximum bytes of data looked at by l7-filter");
++#ifdef CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG
++	#define DPRINTK(format,args...) printk(format,##args)
++#else
++	#define DPRINTK(format,args...)
++#endif
++
++/* Number of packets whose data we look at.
++This can be modified through /proc/net/layer7_numpackets */
++static int num_packets = 10;
++
++static struct pattern_cache {
++	char * regex_string;
++	regexp * pattern;
++	struct pattern_cache * next;
++} * first_pattern_cache = NULL;
++
++DEFINE_SPINLOCK(l7_lock);
++
++static int total_acct_packets(struct nf_conn *ct)
++{
++#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 26)
++	BUG_ON(ct == NULL);
++	return (ct->counters[IP_CT_DIR_ORIGINAL].packets + ct->counters[IP_CT_DIR_REPLY].packets);
++#else
++	struct nf_conn_counter *acct;
++
++	BUG_ON(ct == NULL);
++	acct = nf_conn_acct_find(ct);
++	if (!acct)
++		return 0;
++	return (atomic64_read(&acct[IP_CT_DIR_ORIGINAL].packets) + atomic64_read(&acct[IP_CT_DIR_REPLY].packets));
++#endif
++}
++
++#ifdef CONFIG_IP_NF_MATCH_LAYER7_DEBUG
++/* Converts an unfriendly string into a friendly one by
++replacing unprintables with periods and all whitespace with " ". */
++static char * friendly_print(unsigned char * s)
++{
++	char * f = kmalloc(strlen(s) + 1, GFP_ATOMIC);
++	int i;
++
++	if(!f) {
++		if (net_ratelimit())
++			printk(KERN_ERR "layer7: out of memory in "
++					"friendly_print, bailing.\n");
++		return NULL;
++	}
++
++	for(i = 0; i < strlen(s); i++){
++		if(isprint(s[i]) && s[i] < 128)	f[i] = s[i];
++		else if(isspace(s[i]))		f[i] = ' ';
++		else 				f[i] = '.';
++	}
++	f[i] = '\0';
++	return f;
++}
++
++static char dec2hex(int i)
++{
++	switch (i) {
++		case 0 ... 9:
++			return (i + '0');
++			break;
++		case 10 ... 15:
++			return (i - 10 + 'a');
++			break;
++		default:
++			if (net_ratelimit())
++				printk("layer7: Problem in dec2hex\n");
++			return '\0';
++	}
++}
++
++static char * hex_print(unsigned char * s)
++{
++	char * g = kmalloc(strlen(s)*3 + 1, GFP_ATOMIC);
++	int i;
++
++	if(!g) {
++	       if (net_ratelimit())
++			printk(KERN_ERR "layer7: out of memory in hex_print, "
++					"bailing.\n");
++	       return NULL;
++	}
++
++	for(i = 0; i < strlen(s); i++) {
++		g[i*3    ] = dec2hex(s[i]/16);
++		g[i*3 + 1] = dec2hex(s[i]%16);
++		g[i*3 + 2] = ' ';
++	}
++	g[i*3] = '\0';
++
++	return g;
++}
++#endif // DEBUG
++
++/* Use instead of regcomp.  As we expect to be seeing the same regexps over and
++over again, it make sense to cache the results. */
++static regexp * compile_and_cache(const char * regex_string, 
++                                  const char * protocol)
++{
++	struct pattern_cache * node               = first_pattern_cache;
++	struct pattern_cache * last_pattern_cache = first_pattern_cache;
++	struct pattern_cache * tmp;
++	unsigned int len;
++
++	while (node != NULL) {
++		if (!strcmp(node->regex_string, regex_string))
++		return node->pattern;
++
++		last_pattern_cache = node;/* points at the last non-NULL node */
++		node = node->next;
++	}
++
++	/* If we reach the end of the list, then we have not yet cached
++	   the pattern for this regex. Let's do that now.
++	   Be paranoid about running out of memory to avoid list corruption. */
++	tmp = kmalloc(sizeof(struct pattern_cache), GFP_ATOMIC);
++
++	if(!tmp) {
++		if (net_ratelimit())
++			printk(KERN_ERR "layer7: out of memory in "
++					"compile_and_cache, bailing.\n");
++		return NULL;
++	}
++
++	tmp->regex_string  = kmalloc(strlen(regex_string) + 1, GFP_ATOMIC);
++	tmp->pattern       = kmalloc(sizeof(struct regexp),    GFP_ATOMIC);
++	tmp->next = NULL;
++
++	if(!tmp->regex_string || !tmp->pattern) {
++		if (net_ratelimit())
++			printk(KERN_ERR "layer7: out of memory in "
++					"compile_and_cache, bailing.\n");
++		kfree(tmp->regex_string);
++		kfree(tmp->pattern);
++		kfree(tmp);
++		return NULL;
++	}
++
++	/* Ok.  The new node is all ready now. */
++	node = tmp;
++
++	if(first_pattern_cache == NULL) /* list is empty */
++		first_pattern_cache = node; /* make node the beginning */
++	else
++		last_pattern_cache->next = node; /* attach node to the end */
++
++	/* copy the string and compile the regex */
++	len = strlen(regex_string);
++	DPRINTK("About to compile this: \"%s\"\n", regex_string);
++	node->pattern = regcomp((char *)regex_string, &len);
++	if ( !node->pattern ) {
++		if (net_ratelimit())
++			printk(KERN_ERR "layer7: Error compiling regexp "
++					"\"%s\" (%s)\n", 
++					regex_string, protocol);
++		/* pattern is now cached as NULL, so we won't try again. */
++	}
++
++	strcpy(node->regex_string, regex_string);
++	return node->pattern;
++}
++
++static int can_handle(const struct sk_buff *skb)
++{
++	if(!ip_hdr(skb)) /* not IP */
++		return 0;
++	if(ip_hdr(skb)->protocol != IPPROTO_TCP &&
++	   ip_hdr(skb)->protocol != IPPROTO_UDP &&
++	   ip_hdr(skb)->protocol != IPPROTO_ICMP)
++		return 0;
++	return 1;
++}
++
++/* Returns offset the into the skb->data that the application data starts */
++static int app_data_offset(const struct sk_buff *skb)
++{
++	/* In case we are ported somewhere (ebtables?) where ip_hdr(skb)
++	isn't set, this can be gotten from 4*(skb->data[0] & 0x0f) as well. */
++	int ip_hl = 4*ip_hdr(skb)->ihl;
++
++	if( ip_hdr(skb)->protocol == IPPROTO_TCP ) {
++		/* 12 == offset into TCP header for the header length field.
++		Can't get this with skb->h.th->doff because the tcphdr
++		struct doesn't get set when routing (this is confirmed to be
++		true in Netfilter as well as QoS.) */
++		int tcp_hl = 4*(skb->data[ip_hl + 12] >> 4);
++
++		return ip_hl + tcp_hl;
++	} else if( ip_hdr(skb)->protocol == IPPROTO_UDP  ) {
++		return ip_hl + 8; /* UDP header is always 8 bytes */
++	} else if( ip_hdr(skb)->protocol == IPPROTO_ICMP ) {
++		return ip_hl + 8; /* ICMP header is 8 bytes */
++	} else {
++		if (net_ratelimit())
++			printk(KERN_ERR "layer7: tried to handle unknown "
++					"protocol!\n");
++		return ip_hl + 8; /* something reasonable */
++	}
++}
++
++/* handles whether there's a match when we aren't appending data anymore */
++static int match_no_append(struct nf_conn * conntrack, 
++                           struct nf_conn * master_conntrack, 
++                           enum ip_conntrack_info ctinfo,
++                           enum ip_conntrack_info master_ctinfo,
++                           const struct xt_layer7_info * info)
++{
++	/* If we're in here, throw the app data away */
++	if(master_conntrack->layer7.app_data != NULL) {
++
++	#ifdef CONFIG_IP_NF_MATCH_LAYER7_DEBUG
++		if(!master_conntrack->layer7.app_proto) {
++			char * f = 
++			  friendly_print(master_conntrack->layer7.app_data);
++			char * g = 
++			  hex_print(master_conntrack->layer7.app_data);
++			DPRINTK("\nl7-filter gave up after %d bytes "
++				"(%d packets):\n%s\n",
++				strlen(f), total_acct_packets(master_conntrack), f);
++			kfree(f);
++			DPRINTK("In hex: %s\n", g);
++			kfree(g);
++		}
++	#endif
++
++		kfree(master_conntrack->layer7.app_data);
++		master_conntrack->layer7.app_data = NULL; /* don't free again */
++	}
++
++	if(master_conntrack->layer7.app_proto){
++		/* Here child connections set their .app_proto (for /proc) */
++		if(!conntrack->layer7.app_proto) {
++			conntrack->layer7.app_proto = 
++			  kmalloc(strlen(master_conntrack->layer7.app_proto)+1, 
++			    GFP_ATOMIC);
++			if(!conntrack->layer7.app_proto){
++				if (net_ratelimit())
++					printk(KERN_ERR "layer7: out of memory "
++							"in match_no_append, "
++							"bailing.\n");
++				return 1;
++			}
++			strcpy(conntrack->layer7.app_proto, 
++				master_conntrack->layer7.app_proto);
++		}
++
++		return (!strcmp(master_conntrack->layer7.app_proto, 
++				info->protocol));
++	}
++	else {
++		/* If not classified, set to "unknown" to distinguish from
++		connections that are still being tested. */
++		master_conntrack->layer7.app_proto = 
++			kmalloc(strlen("unknown")+1, GFP_ATOMIC);
++		if(!master_conntrack->layer7.app_proto){
++			if (net_ratelimit())
++				printk(KERN_ERR "layer7: out of memory in "
++						"match_no_append, bailing.\n");
++			return 1;
++		}
++		strcpy(master_conntrack->layer7.app_proto, "unknown");
++		return 0;
++	}
++}
++
++/* add the new app data to the conntrack.  Return number of bytes added. */
++static int add_data(struct nf_conn * master_conntrack,
++                    char * app_data, int appdatalen)
++{
++	int length = 0, i;
++	int oldlength = master_conntrack->layer7.app_data_len;
++
++	/* This is a fix for a race condition by Deti Fliegl. However, I'm not 
++	   clear on whether the race condition exists or whether this really 
++	   fixes it.  I might just be being dense... Anyway, if it's not really 
++	   a fix, all it does is waste a very small amount of time. */
++	if(!master_conntrack->layer7.app_data) return 0;
++
++	/* Strip nulls. Make everything lower case (our regex lib doesn't
++	do case insensitivity).  Add it to the end of the current data. */
++	for(i = 0; i < maxdatalen-oldlength-1 &&
++		   i < appdatalen; i++) {
++		if(app_data[i] != '\0') {
++			/* the kernel version of tolower mungs 'upper ascii' */
++			master_conntrack->layer7.app_data[length+oldlength] =
++				isascii(app_data[i])? 
++					tolower(app_data[i]) : app_data[i];
++			length++;
++		}
++	}
++
++	master_conntrack->layer7.app_data[length+oldlength] = '\0';
++	master_conntrack->layer7.app_data_len = length + oldlength;
++
++	return length;
++}
++
++/* taken from drivers/video/modedb.c */
++static int my_atoi(const char *s)
++{
++	int val = 0;
++
++	for (;; s++) {
++		switch (*s) {
++			case '0'...'9':
++			val = 10*val+(*s-'0');
++			break;
++		default:
++			return val;
++		}
++	}
++}
++
++/* write out num_packets to userland. */
++static int layer7_read_proc(char* page, char ** start, off_t off, int count,
++                            int* eof, void * data)
++{
++	if(num_packets > 99 && net_ratelimit())
++		printk(KERN_ERR "layer7: NOT REACHED. num_packets too big\n");
++
++	page[0] = num_packets/10 + '0';
++	page[1] = num_packets%10 + '0';
++	page[2] = '\n';
++	page[3] = '\0';
++
++	*eof=1;
++
++	return 3;
++}
++
++/* Read in num_packets from userland */
++static int layer7_write_proc(struct file* file, const char* buffer,
++                             unsigned long count, void *data)
++{
++	char * foo = kmalloc(count, GFP_ATOMIC);
++
++	if(!foo){
++		if (net_ratelimit())
++			printk(KERN_ERR "layer7: out of memory, bailing. "
++					"num_packets unchanged.\n");
++		return count;
++	}
++
++	if(copy_from_user(foo, buffer, count)) {
++		return -EFAULT;
++	}
++
++
++	num_packets = my_atoi(foo);
++	kfree (foo);
++
++	/* This has an arbitrary limit to make the math easier. I'm lazy.
++	But anyway, 99 is a LOT! If you want more, you're doing it wrong! */
++	if(num_packets > 99) {
++		printk(KERN_WARNING "layer7: num_packets can't be > 99.\n");
++		num_packets = 99;
++	} else if(num_packets < 1) {
++		printk(KERN_WARNING "layer7: num_packets can't be < 1.\n");
++		num_packets = 1;
++	}
++
++	return count;
++}
++
++static bool
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
++match(const struct sk_buff *skbin, const struct xt_match_param *par)
++#else
++match(const struct sk_buff *skbin,
++      const struct net_device *in,
++      const struct net_device *out,
++      const struct xt_match *match,
++      const void *matchinfo,
++      int offset,
++      unsigned int protoff,
++      bool *hotdrop)
++#endif
++{
++	/* sidestep const without getting a compiler warning... */
++	struct sk_buff * skb = (struct sk_buff *)skbin; 
++
++	const struct xt_layer7_info * info = 
++	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
++		par->matchinfo;
++	#else
++		matchinfo;
++	#endif
++
++	enum ip_conntrack_info master_ctinfo, ctinfo;
++	struct nf_conn *master_conntrack, *conntrack;
++	unsigned char * app_data;
++	unsigned int pattern_result, appdatalen;
++	regexp * comppattern;
++
++	/* Be paranoid/incompetent - lock the entire match function. */
++	spin_lock_bh(&l7_lock);
++
++	if(!can_handle(skb)){
++		DPRINTK("layer7: This is some protocol I can't handle.\n");
++		spin_unlock_bh(&l7_lock);
++		return info->invert;
++	}
++
++	/* Treat parent & all its children together as one connection, except
++	for the purpose of setting conntrack->layer7.app_proto in the actual
++	connection. This makes /proc/net/ip_conntrack more satisfying. */
++	if(!(conntrack = nf_ct_get(skb, &ctinfo)) ||
++	   !(master_conntrack=nf_ct_get(skb,&master_ctinfo))){
++		DPRINTK("layer7: couldn't get conntrack.\n");
++		spin_unlock_bh(&l7_lock);
++		return info->invert;
++	}
++
++	/* Try to get a master conntrack (and its master etc) for FTP, etc. */
++	while (master_ct(master_conntrack) != NULL)
++		master_conntrack = master_ct(master_conntrack);
++
++	/* if we've classified it or seen too many packets */
++	if(total_acct_packets(master_conntrack) > num_packets ||
++	   master_conntrack->layer7.app_proto) {
++
++		pattern_result = match_no_append(conntrack, master_conntrack, 
++						 ctinfo, master_ctinfo, info);
++
++		/* skb->cb[0] == seen. Don't do things twice if there are 
++		multiple l7 rules. I'm not sure that using cb for this purpose 
++		is correct, even though it says "put your private variables 
++		there". But it doesn't look like it is being used for anything
++		else in the skbs that make it here. */
++		skb->cb[0] = 1; /* marking it seen here's probably irrelevant */
++
++		spin_unlock_bh(&l7_lock);
++		return (pattern_result ^ info->invert);
++	}
++
++	if(skb_is_nonlinear(skb)){
++		if(skb_linearize(skb) != 0){
++			if (net_ratelimit())
++				printk(KERN_ERR "layer7: failed to linearize "
++						"packet, bailing.\n");
++			spin_unlock_bh(&l7_lock);
++			return info->invert;
++		}
++	}
++
++	/* now that the skb is linearized, it's safe to set these. */
++	app_data = skb->data + app_data_offset(skb);
++	appdatalen = skb_tail_pointer(skb) - app_data;
++
++	/* the return value gets checked later, when we're ready to use it */
++	comppattern = compile_and_cache(info->pattern, info->protocol);
++
++	/* On the first packet of a connection, allocate space for app data */
++	if(total_acct_packets(master_conntrack) == 1 && !skb->cb[0] && 
++	   !master_conntrack->layer7.app_data){
++		master_conntrack->layer7.app_data = 
++			kmalloc(maxdatalen, GFP_ATOMIC);
++		if(!master_conntrack->layer7.app_data){
++			if (net_ratelimit())
++				printk(KERN_ERR "layer7: out of memory in "
++						"match, bailing.\n");
++			spin_unlock_bh(&l7_lock);
++			return info->invert;
++		}
++
++		master_conntrack->layer7.app_data[0] = '\0';
++	}
++
++	/* Can be here, but unallocated, if numpackets is increased near
++	the beginning of a connection */
++	if(master_conntrack->layer7.app_data == NULL){
++		spin_unlock_bh(&l7_lock);
++		return info->invert; /* unmatched */
++	}
++
++	if(!skb->cb[0]){
++		int newbytes;
++		newbytes = add_data(master_conntrack, app_data, appdatalen);
++
++		if(newbytes == 0) { /* didn't add any data */
++			skb->cb[0] = 1;
++			/* Didn't match before, not going to match now */
++			spin_unlock_bh(&l7_lock);
++			return info->invert;
++		}
++	}
++
++	/* If looking for "unknown", then never match.  "Unknown" means that
++	we've given up; we're still trying with these packets. */
++	if(!strcmp(info->protocol, "unknown")) {
++		pattern_result = 0;
++	/* If looking for "unset", then always match. "Unset" means that we
++	haven't yet classified the connection. */
++	} else if(!strcmp(info->protocol, "unset")) {
++		pattern_result = 2;
++		DPRINTK("layer7: matched unset: not yet classified "
++			"(%d/%d packets)\n",
++                        total_acct_packets(master_conntrack), num_packets);
++	/* If the regexp failed to compile, don't bother running it */
++	} else if(comppattern && 
++		  regexec(comppattern, master_conntrack->layer7.app_data)){
++		DPRINTK("layer7: matched %s\n", info->protocol);
++		pattern_result = 1;
++	} else pattern_result = 0;
++
++	if(pattern_result == 1) {
++		master_conntrack->layer7.app_proto = 
++			kmalloc(strlen(info->protocol)+1, GFP_ATOMIC);
++		if(!master_conntrack->layer7.app_proto){
++			if (net_ratelimit())
++				printk(KERN_ERR "layer7: out of memory in "
++						"match, bailing.\n");
++			spin_unlock_bh(&l7_lock);
++			return (pattern_result ^ info->invert);
++		}
++		strcpy(master_conntrack->layer7.app_proto, info->protocol);
++	} else if(pattern_result > 1) { /* cleanup from "unset" */
++		pattern_result = 1;
++	}
++
++	/* mark the packet seen */
++	skb->cb[0] = 1;
++
++	spin_unlock_bh(&l7_lock);
++	return (pattern_result ^ info->invert);
++}
++
++// load nf_conntrack_ipv4
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
++static bool check(const struct xt_mtchk_param *par)
++{
++        if (nf_ct_l3proto_try_module_get(par->match->family) < 0) {
++                printk(KERN_WARNING "can't load conntrack support for "
++                                    "proto=%d\n", par->match->family);
++#else
++static bool check(const char *tablename, const void *inf,
++		 const struct xt_match *match, void *matchinfo,
++		 unsigned int hook_mask)
++{
++        if (nf_ct_l3proto_try_module_get(match->family) < 0) {
++                printk(KERN_WARNING "can't load conntrack support for "
++                                    "proto=%d\n", match->family);
++#endif
++                return 0;
++        }
++	return 1;
++}
++
++
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
++	static void destroy(const struct xt_mtdtor_param *par)
++	{
++		nf_ct_l3proto_module_put(par->match->family);
++	}
++#else
++	static void destroy(const struct xt_match *match, void *matchinfo)
++	{
++		nf_ct_l3proto_module_put(match->family);
++	}
++#endif
++
++static struct xt_match xt_layer7_match[] __read_mostly = {
++{
++	.name		= "layer7",
++	.family		= AF_INET,
++	.checkentry	= check,
++	.match		= match,
++	.destroy	= destroy,
++	.matchsize	= sizeof(struct xt_layer7_info),
++	.me		= THIS_MODULE
++}
++};
++
++static void layer7_cleanup_proc(void)
++{
++	remove_proc_entry("layer7_numpackets", init_net.proc_net);
++}
++
++/* register the proc file */
++static void layer7_init_proc(void)
++{
++	struct proc_dir_entry* entry;
++	entry = create_proc_entry("layer7_numpackets", 0644, init_net.proc_net);
++	entry->read_proc = layer7_read_proc;
++	entry->write_proc = layer7_write_proc;
++}
++
++static int __init xt_layer7_init(void)
++{
++	need_conntrack();
++
++	layer7_init_proc();
++	if(maxdatalen < 1) {
++		printk(KERN_WARNING "layer7: maxdatalen can't be < 1, "
++			"using 1\n");
++		maxdatalen = 1;
++	}
++	/* This is not a hard limit.  It's just here to prevent people from
++	bringing their slow machines to a grinding halt. */
++	else if(maxdatalen > 65536) {
++		printk(KERN_WARNING "layer7: maxdatalen can't be > 65536, "
++			"using 65536\n");
++		maxdatalen = 65536;
++	}
++	return xt_register_matches(xt_layer7_match,
++				   ARRAY_SIZE(xt_layer7_match));
++}
++
++static void __exit xt_layer7_fini(void)
++{
++	layer7_cleanup_proc();
++	xt_unregister_matches(xt_layer7_match, ARRAY_SIZE(xt_layer7_match));
++}
++
++module_init(xt_layer7_init);
++module_exit(xt_layer7_fini);
+--- /dev/null
++++ b/net/netfilter/regexp/regexp.c
+@@ -0,0 +1,1197 @@
++/*
++ * regcomp and regexec -- regsub and regerror are elsewhere
++ * @(#)regexp.c	1.3 of 18 April 87
++ *
++ *	Copyright (c) 1986 by University of Toronto.
++ *	Written by Henry Spencer.  Not derived from licensed software.
++ *
++ *	Permission is granted to anyone to use this software for any
++ *	purpose on any computer system, and to redistribute it freely,
++ *	subject to the following restrictions:
++ *
++ *	1. The author is not responsible for the consequences of use of
++ *		this software, no matter how awful, even if they arise
++ *		from defects in it.
++ *
++ *	2. The origin of this software must not be misrepresented, either
++ *		by explicit claim or by omission.
++ *
++ *	3. Altered versions must be plainly marked as such, and must not
++ *		be misrepresented as being the original software.
++ *
++ * Beware that some of this code is subtly aware of the way operator
++ * precedence is structured in regular expressions.  Serious changes in
++ * regular-expression syntax might require a total rethink.
++ *
++ * This code was modified by Ethan Sommer to work within the kernel
++ * (it now uses kmalloc etc..)
++ *
++ * Modified slightly by Matthew Strait to use more modern C.
++ */
++
++#include "regexp.h"
++#include "regmagic.h"
++
++/* added by ethan and matt.  Lets it work in both kernel and user space.
++(So iptables can use it, for instance.)  Yea, it goes both ways... */
++#if __KERNEL__
++  #define malloc(foo) kmalloc(foo,GFP_ATOMIC)
++#else
++  #define printk(format,args...) printf(format,##args)
++#endif
++
++void regerror(char * s)
++{
++        printk("<3>Regexp: %s\n", s);
++        /* NOTREACHED */
++}
++
++/*
++ * The "internal use only" fields in regexp.h are present to pass info from
++ * compile to execute that permits the execute phase to run lots faster on
++ * simple cases.  They are:
++ *
++ * regstart	char that must begin a match; '\0' if none obvious
++ * reganch	is the match anchored (at beginning-of-line only)?
++ * regmust	string (pointer into program) that match must include, or NULL
++ * regmlen	length of regmust string
++ *
++ * Regstart and reganch permit very fast decisions on suitable starting points
++ * for a match, cutting down the work a lot.  Regmust permits fast rejection
++ * of lines that cannot possibly match.  The regmust tests are costly enough
++ * that regcomp() supplies a regmust only if the r.e. contains something
++ * potentially expensive (at present, the only such thing detected is * or +
++ * at the start of the r.e., which can involve a lot of backup).  Regmlen is
++ * supplied because the test in regexec() needs it and regcomp() is computing
++ * it anyway.
++ */
++
++/*
++ * Structure for regexp "program".  This is essentially a linear encoding
++ * of a nondeterministic finite-state machine (aka syntax charts or
++ * "railroad normal form" in parsing technology).  Each node is an opcode
++ * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
++ * all nodes except BRANCH implement concatenation; a "next" pointer with
++ * a BRANCH on both ends of it is connecting two alternatives.  (Here we
++ * have one of the subtle syntax dependencies:  an individual BRANCH (as
++ * opposed to a collection of them) is never concatenated with anything
++ * because of operator precedence.)  The operand of some types of node is
++ * a literal string; for others, it is a node leading into a sub-FSM.  In
++ * particular, the operand of a BRANCH node is the first node of the branch.
++ * (NB this is *not* a tree structure:  the tail of the branch connects
++ * to the thing following the set of BRANCHes.)  The opcodes are:
++ */
++
++/* definition	number	opnd?	meaning */
++#define	END	0	/* no	End of program. */
++#define	BOL	1	/* no	Match "" at beginning of line. */
++#define	EOL	2	/* no	Match "" at end of line. */
++#define	ANY	3	/* no	Match any one character. */
++#define	ANYOF	4	/* str	Match any character in this string. */
++#define	ANYBUT	5	/* str	Match any character not in this string. */
++#define	BRANCH	6	/* node	Match this alternative, or the next... */
++#define	BACK	7	/* no	Match "", "next" ptr points backward. */
++#define	EXACTLY	8	/* str	Match this string. */
++#define	NOTHING	9	/* no	Match empty string. */
++#define	STAR	10	/* node	Match this (simple) thing 0 or more times. */
++#define	PLUS	11	/* node	Match this (simple) thing 1 or more times. */
++#define	OPEN	20	/* no	Mark this point in input as start of #n. */
++			/*	OPEN+1 is number 1, etc. */
++#define	CLOSE	30	/* no	Analogous to OPEN. */
++
++/*
++ * Opcode notes:
++ *
++ * BRANCH	The set of branches constituting a single choice are hooked
++ *		together with their "next" pointers, since precedence prevents
++ *		anything being concatenated to any individual branch.  The
++ *		"next" pointer of the last BRANCH in a choice points to the
++ *		thing following the whole choice.  This is also where the
++ *		final "next" pointer of each individual branch points; each
++ *		branch starts with the operand node of a BRANCH node.
++ *
++ * BACK		Normal "next" pointers all implicitly point forward; BACK
++ *		exists to make loop structures possible.
++ *
++ * STAR,PLUS	'?', and complex '*' and '+', are implemented as circular
++ *		BRANCH structures using BACK.  Simple cases (one character
++ *		per match) are implemented with STAR and PLUS for speed
++ *		and to minimize recursive plunges.
++ *
++ * OPEN,CLOSE	...are numbered at compile time.
++ */
++
++/*
++ * A node is one char of opcode followed by two chars of "next" pointer.
++ * "Next" pointers are stored as two 8-bit pieces, high order first.  The
++ * value is a positive offset from the opcode of the node containing it.
++ * An operand, if any, simply follows the node.  (Note that much of the
++ * code generation knows about this implicit relationship.)
++ *
++ * Using two bytes for the "next" pointer is vast overkill for most things,
++ * but allows patterns to get big without disasters.
++ */
++#define	OP(p)	(*(p))
++#define	NEXT(p)	(((*((p)+1)&0377)<<8) + (*((p)+2)&0377))
++#define	OPERAND(p)	((p) + 3)
++
++/*
++ * See regmagic.h for one further detail of program structure.
++ */
++
++
++/*
++ * Utility definitions.
++ */
++#ifndef CHARBITS
++#define	UCHARAT(p)	((int)*(unsigned char *)(p))
++#else
++#define	UCHARAT(p)	((int)*(p)&CHARBITS)
++#endif
++
++#define	FAIL(m)	{ regerror(m); return(NULL); }
++#define	ISMULT(c)	((c) == '*' || (c) == '+' || (c) == '?')
++#define	META	"^$.[()|?+*\\"
++
++/*
++ * Flags to be passed up and down.
++ */
++#define	HASWIDTH	01	/* Known never to match null string. */
++#define	SIMPLE		02	/* Simple enough to be STAR/PLUS operand. */
++#define	SPSTART		04	/* Starts with * or +. */
++#define	WORST		0	/* Worst case. */
++
++/*
++ * Global work variables for regcomp().
++ */
++struct match_globals {
++char *reginput;		/* String-input pointer. */
++char *regbol;		/* Beginning of input, for ^ check. */
++char **regstartp;	/* Pointer to startp array. */
++char **regendp;		/* Ditto for endp. */
++char *regparse;		/* Input-scan pointer. */
++int regnpar;		/* () count. */
++char regdummy;
++char *regcode;		/* Code-emit pointer; &regdummy = don't. */
++long regsize;		/* Code size. */
++};
++
++/*
++ * Forward declarations for regcomp()'s friends.
++ */
++#ifndef STATIC
++#define	STATIC	static
++#endif
++STATIC char *reg(struct match_globals *g, int paren,int *flagp);
++STATIC char *regbranch(struct match_globals *g, int *flagp);
++STATIC char *regpiece(struct match_globals *g, int *flagp);
++STATIC char *regatom(struct match_globals *g, int *flagp);
++STATIC char *regnode(struct match_globals *g, char op);
++STATIC char *regnext(struct match_globals *g, char *p);
++STATIC void regc(struct match_globals *g, char b);
++STATIC void reginsert(struct match_globals *g, char op, char *opnd);
++STATIC void regtail(struct match_globals *g, char *p, char *val);
++STATIC void regoptail(struct match_globals *g, char *p, char *val);
++
++
++__kernel_size_t my_strcspn(const char *s1,const char *s2)
++{
++        char *scan1;
++        char *scan2;
++        int count;
++
++        count = 0;
++        for (scan1 = (char *)s1; *scan1 != '\0'; scan1++) {
++                for (scan2 = (char *)s2; *scan2 != '\0';)       /* ++ moved down. */
++                        if (*scan1 == *scan2++)
++                                return(count);
++                count++;
++        }
++        return(count);
++}
++
++/*
++ - regcomp - compile a regular expression into internal code
++ *
++ * We can't allocate space until we know how big the compiled form will be,
++ * but we can't compile it (and thus know how big it is) until we've got a
++ * place to put the code.  So we cheat:  we compile it twice, once with code
++ * generation turned off and size counting turned on, and once "for real".
++ * This also means that we don't allocate space until we are sure that the
++ * thing really will compile successfully, and we never have to move the
++ * code and thus invalidate pointers into it.  (Note that it has to be in
++ * one piece because free() must be able to free it all.)
++ *
++ * Beware that the optimization-preparation code in here knows about some
++ * of the structure of the compiled regexp.
++ */
++regexp *
++regcomp(char *exp,int *patternsize)
++{
++	register regexp *r;
++	register char *scan;
++	register char *longest;
++	register int len;
++	int flags;
++	struct match_globals g;
++	
++	/* commented out by ethan
++	   extern char *malloc();
++	*/
++
++	if (exp == NULL)
++		FAIL("NULL argument");
++
++	/* First pass: determine size, legality. */
++	g.regparse = exp;
++	g.regnpar = 1;
++	g.regsize = 0L;
++	g.regcode = &g.regdummy;
++	regc(&g, MAGIC);
++	if (reg(&g, 0, &flags) == NULL)
++		return(NULL);
++
++	/* Small enough for pointer-storage convention? */
++	if (g.regsize >= 32767L)		/* Probably could be 65535L. */
++		FAIL("regexp too big");
++
++	/* Allocate space. */
++	*patternsize=sizeof(regexp) + (unsigned)g.regsize;
++	r = (regexp *)malloc(sizeof(regexp) + (unsigned)g.regsize);
++	if (r == NULL)
++		FAIL("out of space");
++
++	/* Second pass: emit code. */
++	g.regparse = exp;
++	g.regnpar = 1;
++	g.regcode = r->program;
++	regc(&g, MAGIC);
++	if (reg(&g, 0, &flags) == NULL)
++		return(NULL);
++
++	/* Dig out information for optimizations. */
++	r->regstart = '\0';	/* Worst-case defaults. */
++	r->reganch = 0;
++	r->regmust = NULL;
++	r->regmlen = 0;
++	scan = r->program+1;			/* First BRANCH. */
++	if (OP(regnext(&g, scan)) == END) {		/* Only one top-level choice. */
++		scan = OPERAND(scan);
++
++		/* Starting-point info. */
++		if (OP(scan) == EXACTLY)
++			r->regstart = *OPERAND(scan);
++		else if (OP(scan) == BOL)
++			r->reganch++;
++
++		/*
++		 * If there's something expensive in the r.e., find the
++		 * longest literal string that must appear and make it the
++		 * regmust.  Resolve ties in favor of later strings, since
++		 * the regstart check works with the beginning of the r.e.
++		 * and avoiding duplication strengthens checking.  Not a
++		 * strong reason, but sufficient in the absence of others.
++		 */
++		if (flags&SPSTART) {
++			longest = NULL;
++			len = 0;
++			for (; scan != NULL; scan = regnext(&g, scan))
++				if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= len) {
++					longest = OPERAND(scan);
++					len = strlen(OPERAND(scan));
++				}
++			r->regmust = longest;
++			r->regmlen = len;
++		}
++	}
++
++	return(r);
++}
++
++/*
++ - reg - regular expression, i.e. main body or parenthesized thing
++ *
++ * Caller must absorb opening parenthesis.
++ *
++ * Combining parenthesis handling with the base level of regular expression
++ * is a trifle forced, but the need to tie the tails of the branches to what
++ * follows makes it hard to avoid.
++ */
++static char *
++reg(struct match_globals *g, int paren, int *flagp /* Parenthesized? */ )
++{
++	register char *ret;
++	register char *br;
++	register char *ender;
++	register int parno = 0; /* 0 makes gcc happy */
++	int flags;
++
++	*flagp = HASWIDTH;	/* Tentatively. */
++
++	/* Make an OPEN node, if parenthesized. */
++	if (paren) {
++		if (g->regnpar >= NSUBEXP)
++			FAIL("too many ()");
++		parno = g->regnpar;
++		g->regnpar++;
++		ret = regnode(g, OPEN+parno);
++	} else
++		ret = NULL;
++
++	/* Pick up the branches, linking them together. */
++	br = regbranch(g, &flags);
++	if (br == NULL)
++		return(NULL);
++	if (ret != NULL)
++		regtail(g, ret, br);	/* OPEN -> first. */
++	else
++		ret = br;
++	if (!(flags&HASWIDTH))
++		*flagp &= ~HASWIDTH;
++	*flagp |= flags&SPSTART;
++	while (*g->regparse == '|') {
++		g->regparse++;
++		br = regbranch(g, &flags);
++		if (br == NULL)
++			return(NULL);
++		regtail(g, ret, br);	/* BRANCH -> BRANCH. */
++		if (!(flags&HASWIDTH))
++			*flagp &= ~HASWIDTH;
++		*flagp |= flags&SPSTART;
++	}
++
++	/* Make a closing node, and hook it on the end. */
++	ender = regnode(g, (paren) ? CLOSE+parno : END);	
++	regtail(g, ret, ender);
++
++	/* Hook the tails of the branches to the closing node. */
++	for (br = ret; br != NULL; br = regnext(g, br))
++		regoptail(g, br, ender);
++
++	/* Check for proper termination. */
++	if (paren && *g->regparse++ != ')') {
++		FAIL("unmatched ()");
++	} else if (!paren && *g->regparse != '\0') {
++		if (*g->regparse == ')') {
++			FAIL("unmatched ()");
++		} else
++			FAIL("junk on end");	/* "Can't happen". */
++		/* NOTREACHED */
++	}
++
++	return(ret);
++}
++
++/*
++ - regbranch - one alternative of an | operator
++ *
++ * Implements the concatenation operator.
++ */
++static char *
++regbranch(struct match_globals *g, int *flagp)
++{
++	register char *ret;
++	register char *chain;
++	register char *latest;
++	int flags;
++
++	*flagp = WORST;		/* Tentatively. */
++
++	ret = regnode(g, BRANCH);
++	chain = NULL;
++	while (*g->regparse != '\0' && *g->regparse != '|' && *g->regparse != ')') {
++		latest = regpiece(g, &flags);
++		if (latest == NULL)
++			return(NULL);
++		*flagp |= flags&HASWIDTH;
++		if (chain == NULL)	/* First piece. */
++			*flagp |= flags&SPSTART;
++		else
++			regtail(g, chain, latest);
++		chain = latest;
++	}
++	if (chain == NULL)	/* Loop ran zero times. */
++		(void) regnode(g, NOTHING);
++
++	return(ret);
++}
++
++/*
++ - regpiece - something followed by possible [*+?]
++ *
++ * Note that the branching code sequences used for ? and the general cases
++ * of * and + are somewhat optimized:  they use the same NOTHING node as
++ * both the endmarker for their branch list and the body of the last branch.
++ * It might seem that this node could be dispensed with entirely, but the
++ * endmarker role is not redundant.
++ */
++static char *
++regpiece(struct match_globals *g, int *flagp)
++{
++	register char *ret;
++	register char op;
++	register char *next;
++	int flags;
++
++	ret = regatom(g, &flags);
++	if (ret == NULL)
++		return(NULL);
++
++	op = *g->regparse;
++	if (!ISMULT(op)) {
++		*flagp = flags;
++		return(ret);
++	}
++
++	if (!(flags&HASWIDTH) && op != '?')
++		FAIL("*+ operand could be empty");
++	*flagp = (op != '+') ? (WORST|SPSTART) : (WORST|HASWIDTH);
++
++	if (op == '*' && (flags&SIMPLE))
++		reginsert(g, STAR, ret);
++	else if (op == '*') {
++		/* Emit x* as (x&|), where & means "self". */
++		reginsert(g, BRANCH, ret);			/* Either x */
++		regoptail(g, ret, regnode(g, BACK));		/* and loop */
++		regoptail(g, ret, ret);			/* back */
++		regtail(g, ret, regnode(g, BRANCH));		/* or */
++		regtail(g, ret, regnode(g, NOTHING));		/* null. */
++	} else if (op == '+' && (flags&SIMPLE))
++		reginsert(g, PLUS, ret);
++	else if (op == '+') {
++		/* Emit x+ as x(&|), where & means "self". */
++		next = regnode(g, BRANCH);			/* Either */
++		regtail(g, ret, next);
++		regtail(g, regnode(g, BACK), ret);		/* loop back */
++		regtail(g, next, regnode(g, BRANCH));		/* or */
++		regtail(g, ret, regnode(g, NOTHING));		/* null. */
++	} else if (op == '?') {
++		/* Emit x? as (x|) */
++		reginsert(g, BRANCH, ret);			/* Either x */
++		regtail(g, ret, regnode(g, BRANCH));		/* or */
++		next = regnode(g, NOTHING);		/* null. */
++		regtail(g, ret, next);
++		regoptail(g, ret, next);
++	}
++	g->regparse++;
++	if (ISMULT(*g->regparse))
++		FAIL("nested *?+");
++
++	return(ret);
++}
++
++/*
++ - regatom - the lowest level
++ *
++ * Optimization:  gobbles an entire sequence of ordinary characters so that
++ * it can turn them into a single node, which is smaller to store and
++ * faster to run.  Backslashed characters are exceptions, each becoming a
++ * separate node; the code is simpler that way and it's not worth fixing.
++ */
++static char *
++regatom(struct match_globals *g, int *flagp)
++{
++	register char *ret;
++	int flags;
++
++	*flagp = WORST;		/* Tentatively. */
++
++	switch (*g->regparse++) {
++	case '^':
++		ret = regnode(g, BOL);
++		break;
++	case '$':
++		ret = regnode(g, EOL);
++		break;
++	case '.':
++		ret = regnode(g, ANY);
++		*flagp |= HASWIDTH|SIMPLE;
++		break;
++	case '[': {
++			register int class;
++			register int classend;
++
++			if (*g->regparse == '^') {	/* Complement of range. */
++				ret = regnode(g, ANYBUT);
++				g->regparse++;
++			} else
++				ret = regnode(g, ANYOF);
++			if (*g->regparse == ']' || *g->regparse == '-')
++				regc(g, *g->regparse++);
++			while (*g->regparse != '\0' && *g->regparse != ']') {
++				if (*g->regparse == '-') {
++					g->regparse++;
++					if (*g->regparse == ']' || *g->regparse == '\0')
++						regc(g, '-');
++					else {
++						class = UCHARAT(g->regparse-2)+1;
++						classend = UCHARAT(g->regparse);
++						if (class > classend+1)
++							FAIL("invalid [] range");
++						for (; class <= classend; class++)
++							regc(g, class);
++						g->regparse++;
++					}
++				} else
++					regc(g, *g->regparse++);
++			}
++			regc(g, '\0');
++			if (*g->regparse != ']')
++				FAIL("unmatched []");
++			g->regparse++;
++			*flagp |= HASWIDTH|SIMPLE;
++		}
++		break;
++	case '(':
++		ret = reg(g, 1, &flags);
++		if (ret == NULL)
++			return(NULL);
++		*flagp |= flags&(HASWIDTH|SPSTART);
++		break;
++	case '\0':
++	case '|':
++	case ')':
++		FAIL("internal urp");	/* Supposed to be caught earlier. */
++		break;
++	case '?':
++	case '+':
++	case '*':
++		FAIL("?+* follows nothing");
++		break;
++	case '\\':
++		if (*g->regparse == '\0')
++			FAIL("trailing \\");
++		ret = regnode(g, EXACTLY);
++		regc(g, *g->regparse++);
++		regc(g, '\0');
++		*flagp |= HASWIDTH|SIMPLE;
++		break;
++	default: {
++			register int len;
++			register char ender;
++
++			g->regparse--;
++			len = my_strcspn((const char *)g->regparse, (const char *)META);
++			if (len <= 0)
++				FAIL("internal disaster");
++			ender = *(g->regparse+len);
++			if (len > 1 && ISMULT(ender))
++				len--;		/* Back off clear of ?+* operand. */
++			*flagp |= HASWIDTH;
++			if (len == 1)
++				*flagp |= SIMPLE;
++			ret = regnode(g, EXACTLY);
++			while (len > 0) {
++				regc(g, *g->regparse++);
++				len--;
++			}
++			regc(g, '\0');
++		}
++		break;
++	}
++
++	return(ret);
++}
++
++/*
++ - regnode - emit a node
++ */
++static char *			/* Location. */
++regnode(struct match_globals *g, char op)
++{
++	register char *ret;
++	register char *ptr;
++
++	ret = g->regcode;
++	if (ret == &g->regdummy) {
++		g->regsize += 3;
++		return(ret);
++	}
++
++	ptr = ret;
++	*ptr++ = op;
++	*ptr++ = '\0';		/* Null "next" pointer. */
++	*ptr++ = '\0';
++	g->regcode = ptr;
++
++	return(ret);
++}
++
++/*
++ - regc - emit (if appropriate) a byte of code
++ */
++static void
++regc(struct match_globals *g, char b)
++{
++	if (g->regcode != &g->regdummy)
++		*g->regcode++ = b;
++	else
++		g->regsize++;
++}
++
++/*
++ - reginsert - insert an operator in front of already-emitted operand
++ *
++ * Means relocating the operand.
++ */
++static void
++reginsert(struct match_globals *g, char op, char* opnd)
++{
++	register char *src;
++	register char *dst;
++	register char *place;
++
++	if (g->regcode == &g->regdummy) {
++		g->regsize += 3;
++		return;
++	}
++
++	src = g->regcode;
++	g->regcode += 3;
++	dst = g->regcode;
++	while (src > opnd)
++		*--dst = *--src;
++
++	place = opnd;		/* Op node, where operand used to be. */
++	*place++ = op;
++	*place++ = '\0';
++	*place++ = '\0';
++}
++
++/*
++ - regtail - set the next-pointer at the end of a node chain
++ */
++static void
++regtail(struct match_globals *g, char *p, char *val)
++{
++	register char *scan;
++	register char *temp;
++	register int offset;
++
++	if (p == &g->regdummy)
++		return;
++
++	/* Find last node. */
++	scan = p;
++	for (;;) {
++		temp = regnext(g, scan);
++		if (temp == NULL)
++			break;
++		scan = temp;
++	}
++
++	if (OP(scan) == BACK)
++		offset = scan - val;
++	else
++		offset = val - scan;
++	*(scan+1) = (offset>>8)&0377;
++	*(scan+2) = offset&0377;
++}
++
++/*
++ - regoptail - regtail on operand of first argument; nop if operandless
++ */
++static void
++regoptail(struct match_globals *g, char *p, char *val)
++{
++	/* "Operandless" and "op != BRANCH" are synonymous in practice. */
++	if (p == NULL || p == &g->regdummy || OP(p) != BRANCH)
++		return;
++	regtail(g, OPERAND(p), val);
++}
++
++/*
++ * regexec and friends
++ */
++
++
++/*
++ * Forwards.
++ */
++STATIC int regtry(struct match_globals *g, regexp *prog, char *string);
++STATIC int regmatch(struct match_globals *g, char *prog);
++STATIC int regrepeat(struct match_globals *g, char *p);
++
++#ifdef DEBUG
++int regnarrate = 0;
++void regdump();
++STATIC char *regprop(char *op);
++#endif
++
++/*
++ - regexec - match a regexp against a string
++ */
++int
++regexec(regexp *prog, char *string)
++{
++	register char *s;
++	struct match_globals g;
++
++	/* Be paranoid... */
++	if (prog == NULL || string == NULL) {
++		printk("<3>Regexp: NULL parameter\n");
++		return(0);
++	}
++
++	/* Check validity of program. */
++	if (UCHARAT(prog->program) != MAGIC) {
++		printk("<3>Regexp: corrupted program\n");
++		return(0);
++	}
++
++	/* If there is a "must appear" string, look for it. */
++	if (prog->regmust != NULL) {
++		s = string;
++		while ((s = strchr(s, prog->regmust[0])) != NULL) {
++			if (strncmp(s, prog->regmust, prog->regmlen) == 0)
++				break;	/* Found it. */
++			s++;
++		}
++		if (s == NULL)	/* Not present. */
++			return(0);
++	}
++
++	/* Mark beginning of line for ^ . */
++	g.regbol = string;
++
++	/* Simplest case:  anchored match need be tried only once. */
++	if (prog->reganch)
++		return(regtry(&g, prog, string));
++
++	/* Messy cases:  unanchored match. */
++	s = string;
++	if (prog->regstart != '\0')
++		/* We know what char it must start with. */
++		while ((s = strchr(s, prog->regstart)) != NULL) {
++			if (regtry(&g, prog, s))
++				return(1);
++			s++;
++		}
++	else
++		/* We don't -- general case. */
++		do {
++			if (regtry(&g, prog, s))
++				return(1);
++		} while (*s++ != '\0');
++
++	/* Failure. */
++	return(0);
++}
++
++/*
++ - regtry - try match at specific point
++ */
++static int			/* 0 failure, 1 success */
++regtry(struct match_globals *g, regexp *prog, char *string)
++{
++	register int i;
++	register char **sp;
++	register char **ep;
++
++	g->reginput = string;
++	g->regstartp = prog->startp;
++	g->regendp = prog->endp;
++
++	sp = prog->startp;
++	ep = prog->endp;
++	for (i = NSUBEXP; i > 0; i--) {
++		*sp++ = NULL;
++		*ep++ = NULL;
++	}
++	if (regmatch(g, prog->program + 1)) {
++		prog->startp[0] = string;
++		prog->endp[0] = g->reginput;
++		return(1);
++	} else
++		return(0);
++}
++
++/*
++ - regmatch - main matching routine
++ *
++ * Conceptually the strategy is simple:  check to see whether the current
++ * node matches, call self recursively to see whether the rest matches,
++ * and then act accordingly.  In practice we make some effort to avoid
++ * recursion, in particular by going through "ordinary" nodes (that don't
++ * need to know whether the rest of the match failed) by a loop instead of
++ * by recursion.
++ */
++static int			/* 0 failure, 1 success */
++regmatch(struct match_globals *g, char *prog)
++{
++	register char *scan = prog; /* Current node. */
++	char *next;		    /* Next node. */
++
++#ifdef DEBUG
++	if (scan != NULL && regnarrate)
++		fprintf(stderr, "%s(\n", regprop(scan));
++#endif
++	while (scan != NULL) {
++#ifdef DEBUG
++		if (regnarrate)
++			fprintf(stderr, "%s...\n", regprop(scan));
++#endif
++		next = regnext(g, scan);
++
++		switch (OP(scan)) {
++		case BOL:
++			if (g->reginput != g->regbol)
++				return(0);
++			break;
++		case EOL:
++			if (*g->reginput != '\0')
++				return(0);
++			break;
++		case ANY:
++			if (*g->reginput == '\0')
++				return(0);
++			g->reginput++;
++			break;
++		case EXACTLY: {
++				register int len;
++				register char *opnd;
++
++				opnd = OPERAND(scan);
++				/* Inline the first character, for speed. */
++				if (*opnd != *g->reginput)
++					return(0);
++				len = strlen(opnd);
++				if (len > 1 && strncmp(opnd, g->reginput, len) != 0)
++					return(0);
++				g->reginput += len;
++			}
++			break;
++		case ANYOF:
++			if (*g->reginput == '\0' || strchr(OPERAND(scan), *g->reginput) == NULL)
++				return(0);
++			g->reginput++;
++			break;
++		case ANYBUT:
++			if (*g->reginput == '\0' || strchr(OPERAND(scan), *g->reginput) != NULL)
++				return(0);
++			g->reginput++;
++			break;
++		case NOTHING:
++		case BACK:
++			break;
++		case OPEN+1:
++		case OPEN+2:
++		case OPEN+3:
++		case OPEN+4:
++		case OPEN+5:
++		case OPEN+6:
++		case OPEN+7:
++		case OPEN+8:
++		case OPEN+9: {
++				register int no;
++				register char *save;
++
++				no = OP(scan) - OPEN;
++				save = g->reginput;
++
++				if (regmatch(g, next)) {
++					/*
++					 * Don't set startp if some later
++					 * invocation of the same parentheses
++					 * already has.
++					 */
++					if (g->regstartp[no] == NULL)
++						g->regstartp[no] = save;
++					return(1);
++				} else
++					return(0);
++			}
++			break;
++		case CLOSE+1:
++		case CLOSE+2:
++		case CLOSE+3:
++		case CLOSE+4:
++		case CLOSE+5:
++		case CLOSE+6:
++		case CLOSE+7:
++		case CLOSE+8:
++		case CLOSE+9:
++			{
++				register int no;
++				register char *save;
++
++				no = OP(scan) - CLOSE;
++				save = g->reginput;
++
++				if (regmatch(g, next)) {
++					/*
++					 * Don't set endp if some later
++					 * invocation of the same parentheses
++					 * already has.
++					 */
++					if (g->regendp[no] == NULL)
++						g->regendp[no] = save;
++					return(1);
++				} else
++					return(0);
++			}
++			break;
++		case BRANCH: {
++				register char *save;
++
++				if (OP(next) != BRANCH)		/* No choice. */
++					next = OPERAND(scan);	/* Avoid recursion. */
++				else {
++					do {
++						save = g->reginput;
++						if (regmatch(g, OPERAND(scan)))
++							return(1);
++						g->reginput = save;
++						scan = regnext(g, scan);
++					} while (scan != NULL && OP(scan) == BRANCH);
++					return(0);
++					/* NOTREACHED */
++				}
++			}
++			break;
++		case STAR:
++		case PLUS: {
++				register char nextch;
++				register int no;
++				register char *save;
++				register int min;
++
++				/*
++				 * Lookahead to avoid useless match attempts
++				 * when we know what character comes next.
++				 */
++				nextch = '\0';
++				if (OP(next) == EXACTLY)
++					nextch = *OPERAND(next);
++				min = (OP(scan) == STAR) ? 0 : 1;
++				save = g->reginput;
++				no = regrepeat(g, OPERAND(scan));
++				while (no >= min) {
++					/* If it could work, try it. */
++					if (nextch == '\0' || *g->reginput == nextch)
++						if (regmatch(g, next))
++							return(1);
++					/* Couldn't or didn't -- back up. */
++					no--;
++					g->reginput = save + no;
++				}
++				return(0);
++			}
++			break;
++		case END:
++			return(1);	/* Success! */
++			break;
++		default:
++			printk("<3>Regexp: memory corruption\n");
++			return(0);
++			break;
++		}
++
++		scan = next;
++	}
++
++	/*
++	 * We get here only if there's trouble -- normally "case END" is
++	 * the terminating point.
++	 */
++	printk("<3>Regexp: corrupted pointers\n");
++	return(0);
++}
++
++/*
++ - regrepeat - repeatedly match something simple, report how many
++ */
++static int
++regrepeat(struct match_globals *g, char *p)
++{
++	register int count = 0;
++	register char *scan;
++	register char *opnd;
++
++	scan = g->reginput;
++	opnd = OPERAND(p);
++	switch (OP(p)) {
++	case ANY:
++		count = strlen(scan);
++		scan += count;
++		break;
++	case EXACTLY:
++		while (*opnd == *scan) {
++			count++;
++			scan++;
++		}
++		break;
++	case ANYOF:
++		while (*scan != '\0' && strchr(opnd, *scan) != NULL) {
++			count++;
++			scan++;
++		}
++		break;
++	case ANYBUT:
++		while (*scan != '\0' && strchr(opnd, *scan) == NULL) {
++			count++;
++			scan++;
++		}
++		break;
++	default:		/* Oh dear.  Called inappropriately. */
++		printk("<3>Regexp: internal foulup\n");
++		count = 0;	/* Best compromise. */
++		break;
++	}
++	g->reginput = scan;
++
++	return(count);
++}
++
++/*
++ - regnext - dig the "next" pointer out of a node
++ */
++static char*
++regnext(struct match_globals *g, char *p)
++{
++	register int offset;
++
++	if (p == &g->regdummy)
++		return(NULL);
++
++	offset = NEXT(p);
++	if (offset == 0)
++		return(NULL);
++
++	if (OP(p) == BACK)
++		return(p-offset);
++	else
++		return(p+offset);
++}
++
++#ifdef DEBUG
++
++STATIC char *regprop();
++
++/*
++ - regdump - dump a regexp onto stdout in vaguely comprehensible form
++ */
++void
++regdump(regexp *r)
++{
++	register char *s;
++	register char op = EXACTLY;	/* Arbitrary non-END op. */
++	register char *next;
++	/* extern char *strchr(); */
++
++
++	s = r->program + 1;
++	while (op != END) {	/* While that wasn't END last time... */
++		op = OP(s);
++		printf("%2d%s", s-r->program, regprop(s));	/* Where, what. */
++		next = regnext(s);
++		if (next == NULL)		/* Next ptr. */
++			printf("(0)");
++		else
++			printf("(%d)", (s-r->program)+(next-s));
++		s += 3;
++		if (op == ANYOF || op == ANYBUT || op == EXACTLY) {
++			/* Literal string, where present. */
++			while (*s != '\0') {
++				putchar(*s);
++				s++;
++			}
++			s++;
++		}
++		putchar('\n');
++	}
++
++	/* Header fields of interest. */
++	if (r->regstart != '\0')
++		printf("start `%c' ", r->regstart);
++	if (r->reganch)
++		printf("anchored ");
++	if (r->regmust != NULL)
++		printf("must have \"%s\"", r->regmust);
++	printf("\n");
++}
++
++/*
++ - regprop - printable representation of opcode
++ */
++static char *
++regprop(char *op)
++{
++#define BUFLEN 50
++	register char *p;
++	static char buf[BUFLEN];
++
++	strcpy(buf, ":");
++
++	switch (OP(op)) {
++	case BOL:
++		p = "BOL";
++		break;
++	case EOL:
++		p = "EOL";
++		break;
++	case ANY:
++		p = "ANY";
++		break;
++	case ANYOF:
++		p = "ANYOF";
++		break;
++	case ANYBUT:
++		p = "ANYBUT";
++		break;
++	case BRANCH:
++		p = "BRANCH";
++		break;
++	case EXACTLY:
++		p = "EXACTLY";
++		break;
++	case NOTHING:
++		p = "NOTHING";
++		break;
++	case BACK:
++		p = "BACK";
++		break;
++	case END:
++		p = "END";
++		break;
++	case OPEN+1:
++	case OPEN+2:
++	case OPEN+3:
++	case OPEN+4:
++	case OPEN+5:
++	case OPEN+6:
++	case OPEN+7:
++	case OPEN+8:
++	case OPEN+9:
++		snprintf(buf+strlen(buf),BUFLEN-strlen(buf), "OPEN%d", OP(op)-OPEN);
++		p = NULL;
++		break;
++	case CLOSE+1:
++	case CLOSE+2:
++	case CLOSE+3:
++	case CLOSE+4:
++	case CLOSE+5:
++	case CLOSE+6:
++	case CLOSE+7:
++	case CLOSE+8:
++	case CLOSE+9:
++		snprintf(buf+strlen(buf),BUFLEN-strlen(buf), "CLOSE%d", OP(op)-CLOSE);
++		p = NULL;
++		break;
++	case STAR:
++		p = "STAR";
++		break;
++	case PLUS:
++		p = "PLUS";
++		break;
++	default:
++		printk("<3>Regexp: corrupted opcode\n");
++		break;
++	}
++	if (p != NULL)
++		strncat(buf, p, BUFLEN-strlen(buf));
++	return(buf);
++}
++#endif
++
++
+--- /dev/null
++++ b/net/netfilter/regexp/regexp.h
+@@ -0,0 +1,41 @@
++/*
++ * Definitions etc. for regexp(3) routines.
++ *
++ * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
++ * not the System V one.
++ */
++
++#ifndef REGEXP_H
++#define REGEXP_H
++
++
++/*
++http://www.opensource.apple.com/darwinsource/10.3/expect-1/expect/expect.h ,
++which contains a version of this library, says:
++
++ *
++ * NSUBEXP must be at least 10, and no greater than 117 or the parser
++ * will not work properly.
++ *
++
++However, it looks rather like this library is limited to 10.  If you think
++otherwise, let us know.
++*/
++
++#define NSUBEXP  10
++typedef struct regexp {
++	char *startp[NSUBEXP];
++	char *endp[NSUBEXP];
++	char regstart;		/* Internal use only. */
++	char reganch;		/* Internal use only. */
++	char *regmust;		/* Internal use only. */
++	int regmlen;		/* Internal use only. */
++	char program[1];	/* Unwarranted chumminess with compiler. */
++} regexp;
++
++regexp * regcomp(char *exp, int *patternsize);
++int regexec(regexp *prog, char *string);
++void regsub(regexp *prog, char *source, char *dest);
++void regerror(char *s);
++
++#endif
+--- /dev/null
++++ b/net/netfilter/regexp/regmagic.h
+@@ -0,0 +1,5 @@
++/*
++ * The first byte of the regexp internal "program" is actually this magic
++ * number; the start node begins in the second byte.
++ */
++#define	MAGIC	0234
+--- /dev/null
++++ b/net/netfilter/regexp/regsub.c
+@@ -0,0 +1,95 @@
++/*
++ * regsub
++ * @(#)regsub.c	1.3 of 2 April 86
++ *
++ *	Copyright (c) 1986 by University of Toronto.
++ *	Written by Henry Spencer.  Not derived from licensed software.
++ *
++ *	Permission is granted to anyone to use this software for any
++ *	purpose on any computer system, and to redistribute it freely,
++ *	subject to the following restrictions:
++ *
++ *	1. The author is not responsible for the consequences of use of
++ *		this software, no matter how awful, even if they arise
++ *		from defects in it.
++ *
++ *	2. The origin of this software must not be misrepresented, either
++ *		by explicit claim or by omission.
++ *
++ *	3. Altered versions must be plainly marked as such, and must not
++ *		be misrepresented as being the original software.
++ *
++ *
++ * This code was modified by Ethan Sommer to work within the kernel
++ * (it now uses kmalloc etc..)
++ *
++ */
++#include "regexp.h"
++#include "regmagic.h"
++#include <linux/string.h>
++
++
++#ifndef CHARBITS
++#define	UCHARAT(p)	((int)*(unsigned char *)(p))
++#else
++#define	UCHARAT(p)	((int)*(p)&CHARBITS)
++#endif
++
++#if 0
++//void regerror(char * s)
++//{
++//        printk("regexp(3): %s", s);
++//        /* NOTREACHED */
++//}
++#endif
++
++/*
++ - regsub - perform substitutions after a regexp match
++ */
++void
++regsub(regexp * prog, char * source, char * dest)
++{
++	register char *src;
++	register char *dst;
++	register char c;
++	register int no;
++	register int len;
++	
++	/* Not necessary and gcc doesn't like it -MLS */
++	/*extern char *strncpy();*/
++
++	if (prog == NULL || source == NULL || dest == NULL) {
++		regerror("NULL parm to regsub");
++		return;
++	}
++	if (UCHARAT(prog->program) != MAGIC) {
++		regerror("damaged regexp fed to regsub");
++		return;
++	}
++
++	src = source;
++	dst = dest;
++	while ((c = *src++) != '\0') {
++		if (c == '&')
++			no = 0;
++		else if (c == '\\' && '0' <= *src && *src <= '9')
++			no = *src++ - '0';
++		else
++			no = -1;
++
++		if (no < 0) {	/* Ordinary character. */
++			if (c == '\\' && (*src == '\\' || *src == '&'))
++				c = *src++;
++			*dst++ = c;
++		} else if (prog->startp[no] != NULL && prog->endp[no] != NULL) {
++			len = prog->endp[no] - prog->startp[no];
++			(void) strncpy(dst, prog->startp[no], len);
++			dst += len;
++			if (len != 0 && *(dst-1) == '\0') {	/* strncpy hit NUL. */
++				regerror("damaged match string");
++				return;
++			}
++		}
++	}
++	*dst++ = '\0';
++}
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -224,6 +224,13 @@ destroy_conntrack(struct nf_conntrack *n
+ 	 * too. */
+ 	nf_ct_remove_expectations(ct);
+ 
++#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
++	if(ct->layer7.app_proto)
++		kfree(ct->layer7.app_proto);
++	if(ct->layer7.app_data)
++		kfree(ct->layer7.app_data);
++#endif
++
+ 	/* We overload first tuple to link into unconfirmed or dying list.*/
+ 	BUG_ON(hlist_nulls_unhashed(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode));
+ 	hlist_nulls_del_rcu(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode);
+--- a/net/netfilter/nf_conntrack_standalone.c
++++ b/net/netfilter/nf_conntrack_standalone.c
+@@ -240,6 +240,12 @@ static int ct_seq_show(struct seq_file *
+ 	if (ct_show_delta_time(s, ct))
+ 		goto release;
+ 
++#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
++	if(ct->layer7.app_proto &&
++           seq_printf(s, "l7proto=%s ", ct->layer7.app_proto))
++		return -ENOSPC;
++#endif
++
+ 	if (seq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use)))
+ 		goto release;
+ 
+--- a/include/net/netfilter/nf_conntrack.h
++++ b/include/net/netfilter/nf_conntrack.h
+@@ -105,6 +105,22 @@ struct nf_conn {
+ 	struct net *ct_net;
+ #endif
+ 
++#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || \
++    defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
++	struct {
++		/*
++		 * e.g. "http". NULL before decision. "unknown" after decision
++		 * if no match.
++		 */
++		char *app_proto;
++		/*
++		 * application layer data so far. NULL after match decision.
++		 */
++		char *app_data;
++		unsigned int app_data_len;
++	} layer7;
++#endif
++
+ 	/* Storage reserved for other modules, must be the last member */
+ 	union nf_conntrack_proto proto;
+ };
+--- /dev/null
++++ b/include/linux/netfilter/xt_layer7.h
+@@ -0,0 +1,13 @@
++#ifndef _XT_LAYER7_H
++#define _XT_LAYER7_H
++
++#define MAX_PATTERN_LEN 8192
++#define MAX_PROTOCOL_LEN 256
++
++struct xt_layer7_info {
++    char protocol[MAX_PROTOCOL_LEN];
++    char pattern[MAX_PATTERN_LEN];
++    u_int8_t invert;
++};
++
++#endif /* _XT_LAYER7_H */
+--- a/include/uapi/linux/netfilter/Kbuild
++++ b/include/uapi/linux/netfilter/Kbuild
+@@ -53,6 +53,7 @@ header-y += xt_hashlimit.h
+ header-y += xt_helper.h
+ header-y += xt_iprange.h
+ header-y += xt_ipvs.h
++header-y += xt_layer7.h
+ header-y += xt_length.h
+ header-y += xt_limit.h
+ header-y += xt_mac.h
diff --git a/target/linux/generic/patches-3.10/601-netfilter_layer7_pktmatch.patch b/target/linux/generic/patches-3.10/601-netfilter_layer7_pktmatch.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/601-netfilter_layer7_pktmatch.patch
@@ -0,0 +1,108 @@
+--- a/include/linux/netfilter/xt_layer7.h
++++ b/include/linux/netfilter/xt_layer7.h
+@@ -8,6 +8,7 @@ struct xt_layer7_info {
+     char protocol[MAX_PROTOCOL_LEN];
+     char pattern[MAX_PATTERN_LEN];
+     u_int8_t invert;
++    u_int8_t pkt;
+ };
+ 
+ #endif /* _XT_LAYER7_H */
+--- a/net/netfilter/xt_layer7.c
++++ b/net/netfilter/xt_layer7.c
+@@ -314,33 +314,35 @@ static int match_no_append(struct nf_con
+ }
+ 
+ /* add the new app data to the conntrack.  Return number of bytes added. */
+-static int add_data(struct nf_conn * master_conntrack,
+-                    char * app_data, int appdatalen)
++static int add_datastr(char *target, int offset, char *app_data, int len)
+ {
+ 	int length = 0, i;
+-	int oldlength = master_conntrack->layer7.app_data_len;
+-
+-	/* This is a fix for a race condition by Deti Fliegl. However, I'm not 
+-	   clear on whether the race condition exists or whether this really 
+-	   fixes it.  I might just be being dense... Anyway, if it's not really 
+-	   a fix, all it does is waste a very small amount of time. */
+-	if(!master_conntrack->layer7.app_data) return 0;
++	if (!target) return 0;
+ 
+ 	/* Strip nulls. Make everything lower case (our regex lib doesn't
+ 	do case insensitivity).  Add it to the end of the current data. */
+-	for(i = 0; i < maxdatalen-oldlength-1 &&
+-		   i < appdatalen; i++) {
++ 	for(i = 0; i < maxdatalen-offset-1 && i < len; i++) {
+ 		if(app_data[i] != '\0') {
+ 			/* the kernel version of tolower mungs 'upper ascii' */
+-			master_conntrack->layer7.app_data[length+oldlength] =
++			target[length+offset] =
+ 				isascii(app_data[i])? 
+ 					tolower(app_data[i]) : app_data[i];
+ 			length++;
+ 		}
+ 	}
++	target[length+offset] = '\0';
++
++	return length;
++}
++
++/* add the new app data to the conntrack.  Return number of bytes added. */
++static int add_data(struct nf_conn * master_conntrack,
++                    char * app_data, int appdatalen)
++{
++	int length;
+ 
+-	master_conntrack->layer7.app_data[length+oldlength] = '\0';
+-	master_conntrack->layer7.app_data_len = length + oldlength;
++	length = add_datastr(master_conntrack->layer7.app_data, master_conntrack->layer7.app_data_len, app_data, appdatalen);
++	master_conntrack->layer7.app_data_len += length;
+ 
+ 	return length;
+ }
+@@ -438,7 +440,7 @@ match(const struct sk_buff *skbin,
+ 
+ 	enum ip_conntrack_info master_ctinfo, ctinfo;
+ 	struct nf_conn *master_conntrack, *conntrack;
+-	unsigned char * app_data;
++	unsigned char *app_data, *tmp_data;
+ 	unsigned int pattern_result, appdatalen;
+ 	regexp * comppattern;
+ 
+@@ -466,8 +468,8 @@ match(const struct sk_buff *skbin,
+ 		master_conntrack = master_ct(master_conntrack);
+ 
+ 	/* if we've classified it or seen too many packets */
+-	if(total_acct_packets(master_conntrack) > num_packets ||
+-	   master_conntrack->layer7.app_proto) {
++	if(!info->pkt && (total_acct_packets(master_conntrack) > num_packets ||
++	   master_conntrack->layer7.app_proto)) {
+ 
+ 		pattern_result = match_no_append(conntrack, master_conntrack, 
+ 						 ctinfo, master_ctinfo, info);
+@@ -500,6 +502,25 @@ match(const struct sk_buff *skbin,
+ 	/* the return value gets checked later, when we're ready to use it */
+ 	comppattern = compile_and_cache(info->pattern, info->protocol);
+ 
++	if (info->pkt) {
++		tmp_data = kmalloc(maxdatalen, GFP_ATOMIC);
++		if(!tmp_data){
++			if (net_ratelimit())
++				printk(KERN_ERR "layer7: out of memory in match, bailing.\n");
++			return info->invert;
++		}
++
++		tmp_data[0] = '\0';
++		add_datastr(tmp_data, 0, app_data, appdatalen);
++		pattern_result = ((comppattern && regexec(comppattern, tmp_data)) ? 1 : 0);
++
++		kfree(tmp_data);
++		tmp_data = NULL;
++		spin_unlock_bh(&l7_lock);
++
++		return (pattern_result ^ info->invert);
++	}
++
+ 	/* On the first packet of a connection, allocate space for app data */
+ 	if(total_acct_packets(master_conntrack) == 1 && !skb->cb[0] && 
+ 	   !master_conntrack->layer7.app_data){
diff --git a/target/linux/generic/patches-3.10/602-netfilter_layer7_match.patch b/target/linux/generic/patches-3.10/602-netfilter_layer7_match.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/602-netfilter_layer7_match.patch
@@ -0,0 +1,51 @@
+--- a/net/netfilter/xt_layer7.c
++++ b/net/netfilter/xt_layer7.c
+@@ -415,7 +415,9 @@ static int layer7_write_proc(struct file
+ }
+ 
+ static bool
+-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
++match(const struct sk_buff *skbin, struct xt_action_param *par)
++#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+ match(const struct sk_buff *skbin, const struct xt_match_param *par)
+ #else
+ match(const struct sk_buff *skbin,
+@@ -597,14 +599,19 @@ match(const struct sk_buff *skbin,
+ }
+ 
+ // load nf_conntrack_ipv4
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
++static int
++#else
++static bool
++#endif
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+-static bool check(const struct xt_mtchk_param *par)
++check(const struct xt_mtchk_param *par)
+ {
+         if (nf_ct_l3proto_try_module_get(par->match->family) < 0) {
+                 printk(KERN_WARNING "can't load conntrack support for "
+                                     "proto=%d\n", par->match->family);
+ #else
+-static bool check(const char *tablename, const void *inf,
++check(const char *tablename, const void *inf,
+ 		 const struct xt_match *match, void *matchinfo,
+ 		 unsigned int hook_mask)
+ {
+@@ -612,9 +619,15 @@ static bool check(const char *tablename,
+                 printk(KERN_WARNING "can't load conntrack support for "
+                                     "proto=%d\n", match->family);
+ #endif
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
++		return -EINVAL;
++	}
++	return 0;
++#else
+                 return 0;
+         }
+ 	return 1;
++#endif
+ }
+ 
+ 
diff --git a/target/linux/generic/patches-3.10/603-netfilter_layer7_2.6.36_fix.patch b/target/linux/generic/patches-3.10/603-netfilter_layer7_2.6.36_fix.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/603-netfilter_layer7_2.6.36_fix.patch
@@ -0,0 +1,61 @@
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -1009,6 +1009,27 @@ config NETFILTER_XT_MATCH_IPVS
+ 
+ 	  If unsure, say N.
+ 
++config NETFILTER_XT_MATCH_LAYER7
++	tristate '"layer7" match support'
++	depends on EXPERIMENTAL
++	depends on NETFILTER_XTABLES
++	depends on NETFILTER_ADVANCED
++	depends on NF_CONNTRACK
++	help
++	  Say Y if you want to be able to classify connections (and their
++	  packets) based on regular expression matching of their application
++	  layer data.   This is one way to classify applications such as
++	  peer-to-peer filesharing systems that do not always use the same
++	  port.
++
++	  To compile it as a module, choose M here.  If unsure, say N.
++
++config NETFILTER_XT_MATCH_LAYER7_DEBUG
++	bool 'Layer 7 debugging output'
++	depends on NETFILTER_XT_MATCH_LAYER7
++	help
++	  Say Y to get lots of debugging output.
++
+ config NETFILTER_XT_MATCH_LENGTH
+ 	tristate '"length" match support'
+ 	depends on NETFILTER_ADVANCED
+@@ -1203,26 +1224,11 @@ config NETFILTER_XT_MATCH_STATE
+ 
+ 	  To compile it as a module, choose M here.  If unsure, say N.
+ 
+-config NETFILTER_XT_MATCH_LAYER7
+-	tristate '"layer7" match support'
+-	depends on NETFILTER_XTABLES
+-	depends on EXPERIMENTAL && (IP_NF_CONNTRACK || NF_CONNTRACK)
+-       depends on NETFILTER_ADVANCED
+-	help
+-	  Say Y if you want to be able to classify connections (and their
+-	  packets) based on regular expression matching of their application
+-	  layer data.   This is one way to classify applications such as
+-	  peer-to-peer filesharing systems that do not always use the same
+-	  port.
+-
+-	  To compile it as a module, choose M here.  If unsure, say N.
+-
+ config NETFILTER_XT_MATCH_LAYER7_DEBUG
+-        bool 'Layer 7 debugging output'
+-        depends on NETFILTER_XT_MATCH_LAYER7
+-        help
+-          Say Y to get lots of debugging output.
+-
++	bool 'Layer 7 debugging output'
++	depends on NETFILTER_XT_MATCH_LAYER7
++	help
++	  Say Y to get lots of debugging output.
+ 
+ config NETFILTER_XT_MATCH_STATISTIC
+ 	tristate '"statistic" match support'
diff --git a/target/linux/generic/patches-3.10/604-netfilter_conntrack_flush.patch b/target/linux/generic/patches-3.10/604-netfilter_conntrack_flush.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/604-netfilter_conntrack_flush.patch
@@ -0,0 +1,46 @@
+--- a/net/netfilter/nf_conntrack_standalone.c
++++ b/net/netfilter/nf_conntrack_standalone.c
+@@ -268,10 +268,34 @@ static int ct_open(struct inode *inode,
+ 			sizeof(struct ct_iter_state));
+ }
+ 
++static int kill_all(struct nf_conn *i, void *data)
++{
++    return 1;
++}
++
++static ssize_t ct_file_write(struct file *file, const char __user *buf,
++			     size_t count, loff_t *ppos)
++{
++	struct seq_file *seq = file->private_data;
++	struct net *net = seq_file_net(seq);
++
++	if (count) {
++		char c;
++
++		if (get_user(c, buf))
++			return -EFAULT;
++
++		if (c == 'f')
++			nf_ct_iterate_cleanup(net, kill_all, NULL);
++	}
++	return count;
++}
++
+ static const struct file_operations ct_file_ops = {
+ 	.owner   = THIS_MODULE,
+ 	.open    = ct_open,
+ 	.read    = seq_read,
++	.write	 = ct_file_write,
+ 	.llseek  = seq_lseek,
+ 	.release = seq_release_net,
+ };
+@@ -373,7 +397,7 @@ static int nf_conntrack_standalone_init_
+ {
+ 	struct proc_dir_entry *pde;
+ 
+-	pde = proc_create("nf_conntrack", 0440, net->proc_net, &ct_file_ops);
++	pde = proc_create("nf_conntrack", 0660, net->proc_net, &ct_file_ops);
+ 	if (!pde)
+ 		goto out_nf_conntrack;
+ 
diff --git a/target/linux/generic/patches-3.10/610-netfilter_match_bypass_default_checks.patch b/target/linux/generic/patches-3.10/610-netfilter_match_bypass_default_checks.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/610-netfilter_match_bypass_default_checks.patch
@@ -0,0 +1,93 @@
+--- a/include/uapi/linux/netfilter_ipv4/ip_tables.h
++++ b/include/uapi/linux/netfilter_ipv4/ip_tables.h
+@@ -87,6 +87,7 @@ struct ipt_ip {
+ #define IPT_F_FRAG		0x01	/* Set if rule is a fragment rule */
+ #define IPT_F_GOTO		0x02	/* Set if jump is a goto */
+ #define IPT_F_MASK		0x03	/* All possible flag bits mask. */
++#define IPT_F_NO_DEF_MATCH	0x80	/* Internal: no default match rules present */
+ 
+ /* Values for "inv" field in struct ipt_ip. */
+ #define IPT_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
+--- a/net/ipv4/netfilter/ip_tables.c
++++ b/net/ipv4/netfilter/ip_tables.c
+@@ -82,6 +82,9 @@ ip_packet_match(const struct iphdr *ip,
+ 
+ #define FWINV(bool, invflg) ((bool) ^ !!(ipinfo->invflags & (invflg)))
+ 
++	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
++		return true;
++
+ 	if (FWINV((ip->saddr&ipinfo->smsk.s_addr) != ipinfo->src.s_addr,
+ 		  IPT_INV_SRCIP) ||
+ 	    FWINV((ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,
+@@ -135,6 +138,29 @@ ip_packet_match(const struct iphdr *ip,
+ 	return true;
+ }
+ 
++static void
++ip_checkdefault(struct ipt_ip *ip)
++{
++	static const char iface_mask[IFNAMSIZ] = {};
++
++	if (ip->invflags || ip->flags & IPT_F_FRAG)
++		return;
++
++	if (memcmp(ip->iniface_mask, iface_mask, IFNAMSIZ) != 0)
++		return;
++
++	if (memcmp(ip->outiface_mask, iface_mask, IFNAMSIZ) != 0)
++		return;
++
++	if (ip->smsk.s_addr || ip->dmsk.s_addr)
++		return;
++
++	if (ip->proto)
++		return;
++
++	ip->flags |= IPT_F_NO_DEF_MATCH;
++}
++
+ static bool
+ ip_checkentry(const struct ipt_ip *ip)
+ {
+@@ -560,7 +586,7 @@ static void cleanup_match(struct xt_entr
+ }
+ 
+ static int
+-check_entry(const struct ipt_entry *e, const char *name)
++check_entry(struct ipt_entry *e, const char *name)
+ {
+ 	const struct xt_entry_target *t;
+ 
+@@ -569,6 +595,8 @@ check_entry(const struct ipt_entry *e, c
+ 		return -EINVAL;
+ 	}
+ 
++	ip_checkdefault(&e->ip);
++
+ 	if (e->target_offset + sizeof(struct xt_entry_target) >
+ 	    e->next_offset)
+ 		return -EINVAL;
+@@ -930,6 +958,7 @@ copy_entries_to_user(unsigned int total_
+ 	const struct xt_table_info *private = table->private;
+ 	int ret = 0;
+ 	const void *loc_cpu_entry;
++	u8 flags;
+ 
+ 	counters = alloc_counters(table);
+ 	if (IS_ERR(counters))
+@@ -960,6 +989,14 @@ copy_entries_to_user(unsigned int total_
+ 			ret = -EFAULT;
+ 			goto free_counters;
+ 		}
++
++		flags = e->ip.flags & IPT_F_MASK;
++		if (copy_to_user(userptr + off
++				 + offsetof(struct ipt_entry, ip.flags),
++				 &flags, sizeof(flags)) != 0) {
++			ret = -EFAULT;
++			goto free_counters;
++		}
+ 
+ 		for (i = sizeof(struct ipt_entry);
+ 		     i < e->target_offset;
diff --git a/target/linux/generic/patches-3.10/611-netfilter_match_bypass_default_table.patch b/target/linux/generic/patches-3.10/611-netfilter_match_bypass_default_table.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/611-netfilter_match_bypass_default_table.patch
@@ -0,0 +1,81 @@
+--- a/net/ipv4/netfilter/ip_tables.c
++++ b/net/ipv4/netfilter/ip_tables.c
+@@ -310,6 +310,33 @@ struct ipt_entry *ipt_next_entry(const s
+ 	return (void *)entry + entry->next_offset;
+ }
+ 
++static bool
++ipt_handle_default_rule(struct ipt_entry *e, unsigned int *verdict)
++{
++	struct xt_entry_target *t;
++	struct xt_standard_target *st;
++
++	if (e->target_offset != sizeof(struct ipt_entry))
++		return false;
++
++	if (!(e->ip.flags & IPT_F_NO_DEF_MATCH))
++		return false;
++
++	t = ipt_get_target(e);
++	if (t->u.kernel.target->target)
++		return false;
++
++	st = (struct xt_standard_target *) t;
++	if (st->verdict == XT_RETURN)
++		return false;
++
++	if (st->verdict >= 0)
++		return false;
++
++	*verdict = (unsigned)(-st->verdict) - 1;
++	return true;
++}
++
+ /* Returns one of the generic firewall policies, like NF_ACCEPT. */
+ unsigned int
+ ipt_do_table(struct sk_buff *skb,
+@@ -334,6 +361,25 @@ ipt_do_table(struct sk_buff *skb,
+ 	ip = ip_hdr(skb);
+ 	indev = in ? in->name : nulldevname;
+ 	outdev = out ? out->name : nulldevname;
++
++	IP_NF_ASSERT(table->valid_hooks & (1 << hook));
++	local_bh_disable();
++	addend = xt_write_recseq_begin();
++	private = table->private;
++	cpu        = smp_processor_id();
++	table_base = private->entries[cpu];
++	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];
++	stackptr   = per_cpu_ptr(private->stackptr, cpu);
++	origptr    = *stackptr;
++
++	e = get_entry(table_base, private->hook_entry[hook]);
++	if (ipt_handle_default_rule(e, &verdict)) {
++		ADD_COUNTER(e->counters, skb->len, 1);
++		xt_write_recseq_end(addend);
++		local_bh_enable();
++		return verdict;
++	}
++
+ 	/* We handle fragments by dealing with the first fragment as
+ 	 * if it was a normal packet.  All other fragments are treated
+ 	 * normally, except that they will NEVER match rules that ask
+@@ -348,18 +394,6 @@ ipt_do_table(struct sk_buff *skb,
+ 	acpar.family  = NFPROTO_IPV4;
+ 	acpar.hooknum = hook;
+ 
+-	IP_NF_ASSERT(table->valid_hooks & (1 << hook));
+-	local_bh_disable();
+-	addend = xt_write_recseq_begin();
+-	private = table->private;
+-	cpu        = smp_processor_id();
+-	table_base = private->entries[cpu];
+-	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];
+-	stackptr   = per_cpu_ptr(private->stackptr, cpu);
+-	origptr    = *stackptr;
+-
+-	e = get_entry(table_base, private->hook_entry[hook]);
+-
+ 	pr_debug("Entering %s(hook %u); sp at %u (UF %p)\n",
+ 		 table->name, hook, origptr,
+ 		 get_entry(table_base, private->underflow[hook]));
diff --git a/target/linux/generic/patches-3.10/612-netfilter_match_reduce_memory_access.patch b/target/linux/generic/patches-3.10/612-netfilter_match_reduce_memory_access.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/612-netfilter_match_reduce_memory_access.patch
@@ -0,0 +1,16 @@
+--- a/net/ipv4/netfilter/ip_tables.c
++++ b/net/ipv4/netfilter/ip_tables.c
+@@ -85,9 +85,11 @@ ip_packet_match(const struct iphdr *ip,
+ 	if (ipinfo->flags & IPT_F_NO_DEF_MATCH)
+ 		return true;
+ 
+-	if (FWINV((ip->saddr&ipinfo->smsk.s_addr) != ipinfo->src.s_addr,
++	if (FWINV(ipinfo->smsk.s_addr &&
++		  (ip->saddr&ipinfo->smsk.s_addr) != ipinfo->src.s_addr,
+ 		  IPT_INV_SRCIP) ||
+-	    FWINV((ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,
++	    FWINV(ipinfo->dmsk.s_addr &&
++		  (ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,
+ 		  IPT_INV_DSTIP)) {
+ 		dprintf("Source or dest mismatch.\n");
+ 
diff --git a/target/linux/generic/patches-3.10/613-netfilter_optional_tcp_window_check.patch b/target/linux/generic/patches-3.10/613-netfilter_optional_tcp_window_check.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/613-netfilter_optional_tcp_window_check.patch
@@ -0,0 +1,38 @@
+Index: kernel_tree/net/netfilter/nf_conntrack_proto_tcp.c
+===================================================================
+--- kernel_tree.orig/net/netfilter/nf_conntrack_proto_tcp.c
++++ kernel_tree/net/netfilter/nf_conntrack_proto_tcp.c
+@@ -31,6 +31,9 @@
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+ 
++/* Do not check the TCP window for incoming packets  */
++static int nf_ct_tcp_no_window_check __read_mostly = 1;
++
+ /* "Be conservative in what you do,
+     be liberal in what you accept from others."
+     If it's non-zero, we mark only out of window RST segments as INVALID. */
+@@ -528,6 +531,9 @@ static bool tcp_in_window(const struct n
+ 	s16 receiver_offset;
+ 	bool res;
+ 
++	if (nf_ct_tcp_no_window_check)
++		return true;
++
+ 	/*
+ 	 * Get the required data from the packet.
+ 	 */
+@@ -1446,6 +1452,13 @@ static struct ctl_table tcp_sysctl_table
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
++	{
++		.procname       = "nf_conntrack_tcp_no_window_check",
++		.data           = &nf_ct_tcp_no_window_check,
++		.maxlen         = sizeof(unsigned int),
++		.mode           = 0644,
++		.proc_handler   = proc_dointvec,
++	},
+ 	{ }
+ };
+ 
diff --git a/target/linux/generic/patches-3.10/620-sched_esfq.patch b/target/linux/generic/patches-3.10/620-sched_esfq.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/620-sched_esfq.patch
@@ -0,0 +1,791 @@
+--- a/include/uapi/linux/pkt_sched.h
++++ b/include/uapi/linux/pkt_sched.h
+@@ -222,6 +222,33 @@ struct tc_sfq_xstats {
+ 	__s32		allot;
+ };
+ 
++/* ESFQ section */
++
++enum
++{
++        /* traditional */
++	TCA_SFQ_HASH_CLASSIC,
++	TCA_SFQ_HASH_DST,
++	TCA_SFQ_HASH_SRC,
++	TCA_SFQ_HASH_FWMARK,
++	/* conntrack */
++	TCA_SFQ_HASH_CTORIGDST,
++	TCA_SFQ_HASH_CTORIGSRC,
++	TCA_SFQ_HASH_CTREPLDST,
++	TCA_SFQ_HASH_CTREPLSRC,
++	TCA_SFQ_HASH_CTNATCHG,
++};
++
++struct tc_esfq_qopt
++{
++	unsigned	quantum;	/* Bytes per round allocated to flow */
++	int		perturb_period;	/* Period of hash perturbation */
++	__u32		limit;		/* Maximal packets in queue */
++	unsigned	divisor;	/* Hash divisor  */
++	unsigned	flows;		/* Maximal number of flows  */
++	unsigned	hash_kind;	/* Hash function to use for flow identification */
++};
++
+ /* RED section */
+ 
+ enum {
+--- a/net/sched/Kconfig
++++ b/net/sched/Kconfig
+@@ -148,6 +148,37 @@ config NET_SCH_SFQ
+ 	  To compile this code as a module, choose M here: the
+ 	  module will be called sch_sfq.
+ 
++config NET_SCH_ESFQ
++	tristate "Enhanced Stochastic Fairness Queueing (ESFQ)"
++	---help---
++	  Say Y here if you want to use the Enhanced Stochastic Fairness
++	  Queueing (ESFQ) packet scheduling algorithm for some of your network
++	  devices or as a leaf discipline for a classful qdisc such as HTB or
++	  CBQ (see the top of <file:net/sched/sch_esfq.c> for details and
++	  references to the SFQ algorithm).
++
++	  This is an enchanced SFQ version which allows you to control some
++	  hardcoded values in the SFQ scheduler.
++
++	  ESFQ also adds control of the hash function used to identify packet
++	  flows. The original SFQ discipline hashes by connection; ESFQ add
++	  several other hashing methods, such as by src IP or by dst IP, which
++	  can be more fair to users in some networking situations.
++
++	  To compile this code as a module, choose M here: the
++	  module will be called sch_esfq.
++
++config NET_SCH_ESFQ_NFCT
++	bool "Connection Tracking Hash Types"
++	depends on NET_SCH_ESFQ && NF_CONNTRACK
++	---help---
++	  Say Y here to enable support for hashing based on netfilter connection
++	  tracking information. This is useful for a router that is also using
++	  NAT to connect privately-addressed hosts to the Internet. If you want
++	  to provide fair distribution of upstream bandwidth, ESFQ must use
++	  connection tracking information, since all outgoing packets will share
++	  the same source address.
++
+ config NET_SCH_TEQL
+ 	tristate "True Link Equalizer (TEQL)"
+ 	---help---
+--- a/net/sched/Makefile
++++ b/net/sched/Makefile
+@@ -26,6 +26,7 @@ obj-$(CONFIG_NET_SCH_INGRESS)	+= sch_ing
+ obj-$(CONFIG_NET_SCH_DSMARK)	+= sch_dsmark.o
+ obj-$(CONFIG_NET_SCH_SFB)	+= sch_sfb.o
+ obj-$(CONFIG_NET_SCH_SFQ)	+= sch_sfq.o
++obj-$(CONFIG_NET_SCH_ESFQ)	+= sch_esfq.o
+ obj-$(CONFIG_NET_SCH_TBF)	+= sch_tbf.o
+ obj-$(CONFIG_NET_SCH_TEQL)	+= sch_teql.o
+ obj-$(CONFIG_NET_SCH_PRIO)	+= sch_prio.o
+--- /dev/null
++++ b/net/sched/sch_esfq.c
+@@ -0,0 +1,702 @@
++/*
++ * net/sched/sch_esfq.c	Extended Stochastic Fairness Queueing discipline.
++ *
++ *		This program is free software; you can redistribute it and/or
++ *		modify it under the terms of the GNU General Public License
++ *		as published by the Free Software Foundation; either version
++ *		2 of the License, or (at your option) any later version.
++ *
++ * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
++ *
++ * Changes:	Alexander Atanasov, <alex@ssi.bg>
++ *		Added dynamic depth,limit,divisor,hash_kind options.
++ *		Added dst and src hashes.
++ *
++ * 		Alexander Clouter, <alex@digriz.org.uk>
++ *		Ported ESFQ to Linux 2.6.
++ *
++ * 		Corey Hickey, <bugfood-c@fatooh.org>
++ *		Maintenance of the Linux 2.6 port.
++ *		Added fwmark hash (thanks to Robert Kurjata).
++ *		Added usage of jhash.
++ *		Added conntrack support.
++ *		Added ctnatchg hash (thanks to Ben Pfountz).
++ */
++
++#include <linux/module.h>
++#include <asm/uaccess.h>
++#include <linux/bitops.h>
++#include <linux/types.h>
++#include <linux/kernel.h>
++#include <linux/jiffies.h>
++#include <linux/string.h>
++#include <linux/mm.h>
++#include <linux/socket.h>
++#include <linux/sockios.h>
++#include <linux/in.h>
++#include <linux/errno.h>
++#include <linux/interrupt.h>
++#include <linux/if_ether.h>
++#include <linux/inet.h>
++#include <linux/netdevice.h>
++#include <linux/etherdevice.h>
++#include <linux/notifier.h>
++#include <linux/init.h>
++#include <net/ip.h>
++#include <net/netlink.h>
++#include <linux/ipv6.h>
++#include <net/route.h>
++#include <linux/skbuff.h>
++#include <net/sock.h>
++#include <net/pkt_sched.h>
++#include <linux/jhash.h>
++#ifdef CONFIG_NET_SCH_ESFQ_NFCT
++#include <net/netfilter/nf_conntrack.h>
++#endif
++
++/*	Stochastic Fairness Queuing algorithm.
++	For more comments look at sch_sfq.c.
++	The difference is that you can change limit, depth,
++	hash table size and choose alternate hash types.
++
++	classic:	same as in sch_sfq.c
++	dst:		destination IP address
++	src:		source IP address
++	fwmark:		netfilter mark value
++	ctorigdst:	original destination IP address
++	ctorigsrc:	original source IP address
++	ctrepldst:	reply destination IP address
++	ctreplsrc:	reply source IP
++
++*/
++
++#define ESFQ_HEAD 0
++#define ESFQ_TAIL 1
++
++/* This type should contain at least SFQ_DEPTH*2 values */
++typedef unsigned int esfq_index;
++
++struct esfq_head
++{
++	esfq_index	next;
++	esfq_index	prev;
++};
++
++struct esfq_sched_data
++{
++/* Parameters */
++	int		perturb_period;
++	unsigned	quantum;	/* Allotment per round: MUST BE >= MTU */
++	int		limit;
++	unsigned	depth;
++	unsigned	hash_divisor;
++	unsigned	hash_kind;
++/* Variables */
++	struct timer_list perturb_timer;
++	int		perturbation;
++	esfq_index	tail;		/* Index of current slot in round */
++	esfq_index	max_depth;	/* Maximal depth */
++
++	esfq_index	*ht;			/* Hash table */
++	esfq_index	*next;			/* Active slots link */
++	short		*allot;			/* Current allotment per slot */
++	unsigned short	*hash;			/* Hash value indexed by slots */
++	struct sk_buff_head	*qs;		/* Slot queue */
++	struct esfq_head	*dep;		/* Linked list of slots, indexed by depth */
++};
++
++/* This contains the info we will hash. */
++struct esfq_packet_info
++{
++	u32	proto;		/* protocol or port */
++	u32	src;		/* source from packet header */
++	u32	dst;		/* destination from packet header */
++	u32	ctorigsrc;	/* original source from conntrack */
++	u32	ctorigdst;	/* original destination from conntrack */
++	u32	ctreplsrc;	/* reply source from conntrack */
++	u32	ctrepldst;	/* reply destination from conntrack */
++	u32	mark;		/* netfilter mark (fwmark) */
++};
++
++static __inline__ unsigned esfq_jhash_1word(struct esfq_sched_data *q,u32 a)
++{
++	return jhash_1word(a, q->perturbation) & (q->hash_divisor-1);
++}
++
++static __inline__ unsigned esfq_jhash_2words(struct esfq_sched_data *q, u32 a, u32 b)
++{
++	return jhash_2words(a, b, q->perturbation) & (q->hash_divisor-1);
++}
++
++static __inline__ unsigned esfq_jhash_3words(struct esfq_sched_data *q, u32 a, u32 b, u32 c)
++{
++	return jhash_3words(a, b, c, q->perturbation) & (q->hash_divisor-1);
++}
++
++static unsigned esfq_hash(struct esfq_sched_data *q, struct sk_buff *skb)
++{
++	struct esfq_packet_info info;
++#ifdef CONFIG_NET_SCH_ESFQ_NFCT
++	enum ip_conntrack_info ctinfo;
++	struct nf_conn *ct = nf_ct_get(skb, &ctinfo);
++#endif
++
++	switch (skb->protocol) {
++	case __constant_htons(ETH_P_IP):
++	{
++		struct iphdr *iph = ip_hdr(skb);
++		info.dst = iph->daddr;
++		info.src = iph->saddr;
++		if (!(iph->frag_off&htons(IP_MF|IP_OFFSET)) &&
++		    (iph->protocol == IPPROTO_TCP ||
++		     iph->protocol == IPPROTO_UDP ||
++		     iph->protocol == IPPROTO_SCTP ||
++		     iph->protocol == IPPROTO_DCCP ||
++		     iph->protocol == IPPROTO_ESP))
++			info.proto = *(((u32*)iph) + iph->ihl);
++		else
++			info.proto = iph->protocol;
++		break;
++	}
++	case __constant_htons(ETH_P_IPV6):
++	{
++		struct ipv6hdr *iph = ipv6_hdr(skb);
++		/* Hash ipv6 addresses into a u32. This isn't ideal,
++		 * but the code is simple. */
++		info.dst = jhash2(iph->daddr.s6_addr32, 4, q->perturbation);
++		info.src = jhash2(iph->saddr.s6_addr32, 4, q->perturbation);
++		if (iph->nexthdr == IPPROTO_TCP ||
++		    iph->nexthdr == IPPROTO_UDP ||
++		    iph->nexthdr == IPPROTO_SCTP ||
++		    iph->nexthdr == IPPROTO_DCCP ||
++		    iph->nexthdr == IPPROTO_ESP)
++			info.proto = *(u32*)&iph[1];
++		else
++			info.proto = iph->nexthdr;
++		break;
++	}
++	default:
++		info.dst   = (u32)(unsigned long)skb_dst(skb);
++		info.src   = (u32)(unsigned long)skb->sk;
++		info.proto = skb->protocol;
++	}
++
++	info.mark = skb->mark;
++
++#ifdef CONFIG_NET_SCH_ESFQ_NFCT
++	/* defaults if there is no conntrack info */
++	info.ctorigsrc = info.src;
++	info.ctorigdst = info.dst;
++	info.ctreplsrc = info.dst;
++	info.ctrepldst = info.src;
++	/* collect conntrack info */
++	if (ct && ct != &nf_conntrack_untracked) {
++		if (skb->protocol == __constant_htons(ETH_P_IP)) {
++			info.ctorigsrc = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
++			info.ctorigdst = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip;
++			info.ctreplsrc = ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip;
++			info.ctrepldst = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
++		}
++		else if (skb->protocol == __constant_htons(ETH_P_IPV6)) {
++			/* Again, hash ipv6 addresses into a single u32. */
++			info.ctorigsrc = jhash2(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip6, 4, q->perturbation);
++			info.ctorigdst = jhash2(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip6, 4, q->perturbation);
++			info.ctreplsrc = jhash2(ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip6, 4, q->perturbation);
++			info.ctrepldst = jhash2(ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip6, 4, q->perturbation);
++		}
++
++	}
++#endif
++
++	switch(q->hash_kind) {
++	case TCA_SFQ_HASH_CLASSIC:
++		return esfq_jhash_3words(q, info.dst, info.src, info.proto);
++	case TCA_SFQ_HASH_DST:
++		return esfq_jhash_1word(q, info.dst);
++	case TCA_SFQ_HASH_SRC:
++		return esfq_jhash_1word(q, info.src);
++	case TCA_SFQ_HASH_FWMARK:
++		return esfq_jhash_1word(q, info.mark);
++#ifdef CONFIG_NET_SCH_ESFQ_NFCT
++	case TCA_SFQ_HASH_CTORIGDST:
++		return esfq_jhash_1word(q, info.ctorigdst);
++	case TCA_SFQ_HASH_CTORIGSRC:
++		return esfq_jhash_1word(q, info.ctorigsrc);
++	case TCA_SFQ_HASH_CTREPLDST:
++		return esfq_jhash_1word(q, info.ctrepldst);
++	case TCA_SFQ_HASH_CTREPLSRC:
++		return esfq_jhash_1word(q, info.ctreplsrc);
++	case TCA_SFQ_HASH_CTNATCHG:
++	{
++		if (info.ctorigdst == info.ctreplsrc)
++			return esfq_jhash_1word(q, info.ctorigsrc);
++		return esfq_jhash_1word(q, info.ctreplsrc);
++	}
++#endif
++	default:
++		if (net_ratelimit())
++			printk(KERN_WARNING "ESFQ: Unknown hash method. Falling back to classic.\n");
++	}
++	return esfq_jhash_3words(q, info.dst, info.src, info.proto);
++}
++
++static inline void esfq_link(struct esfq_sched_data *q, esfq_index x)
++{
++	esfq_index p, n;
++	int d = q->qs[x].qlen + q->depth;
++
++	p = d;
++	n = q->dep[d].next;
++	q->dep[x].next = n;
++	q->dep[x].prev = p;
++	q->dep[p].next = q->dep[n].prev = x;
++}
++
++static inline void esfq_dec(struct esfq_sched_data *q, esfq_index x)
++{
++	esfq_index p, n;
++
++	n = q->dep[x].next;
++	p = q->dep[x].prev;
++	q->dep[p].next = n;
++	q->dep[n].prev = p;
++
++	if (n == p && q->max_depth == q->qs[x].qlen + 1)
++		q->max_depth--;
++
++	esfq_link(q, x);
++}
++
++static inline void esfq_inc(struct esfq_sched_data *q, esfq_index x)
++{
++	esfq_index p, n;
++	int d;
++
++	n = q->dep[x].next;
++	p = q->dep[x].prev;
++	q->dep[p].next = n;
++	q->dep[n].prev = p;
++	d = q->qs[x].qlen;
++	if (q->max_depth < d)
++		q->max_depth = d;
++
++	esfq_link(q, x);
++}
++
++static unsigned int esfq_drop(struct Qdisc *sch)
++{
++	struct esfq_sched_data *q = qdisc_priv(sch);
++	esfq_index d = q->max_depth;
++	struct sk_buff *skb;
++	unsigned int len;
++
++	/* Queue is full! Find the longest slot and
++	   drop a packet from it */
++
++	if (d > 1) {
++		esfq_index x = q->dep[d+q->depth].next;
++		skb = q->qs[x].prev;
++		len = skb->len;
++		__skb_unlink(skb, &q->qs[x]);
++		kfree_skb(skb);
++		esfq_dec(q, x);
++		sch->q.qlen--;
++		sch->qstats.drops++;
++		sch->qstats.backlog -= len;
++		return len;
++	}
++
++	if (d == 1) {
++		/* It is difficult to believe, but ALL THE SLOTS HAVE LENGTH 1. */
++		d = q->next[q->tail];
++		q->next[q->tail] = q->next[d];
++		q->allot[q->next[d]] += q->quantum;
++		skb = q->qs[d].prev;
++		len = skb->len;
++		__skb_unlink(skb, &q->qs[d]);
++		kfree_skb(skb);
++		esfq_dec(q, d);
++		sch->q.qlen--;
++		q->ht[q->hash[d]] = q->depth;
++		sch->qstats.drops++;
++		sch->qstats.backlog -= len;
++		return len;
++	}
++
++	return 0;
++}
++
++static void esfq_q_enqueue(struct sk_buff *skb, struct esfq_sched_data *q, unsigned int end)
++{
++	unsigned hash = esfq_hash(q, skb);
++	unsigned depth = q->depth;
++	esfq_index x;
++
++	x = q->ht[hash];
++	if (x == depth) {
++		q->ht[hash] = x = q->dep[depth].next;
++		q->hash[x] = hash;
++	}
++
++	if (end == ESFQ_TAIL)
++		__skb_queue_tail(&q->qs[x], skb);
++	else
++		__skb_queue_head(&q->qs[x], skb);
++
++	esfq_inc(q, x);
++	if (q->qs[x].qlen == 1) {		/* The flow is new */
++		if (q->tail == depth) {	/* It is the first flow */
++			q->tail = x;
++			q->next[x] = x;
++			q->allot[x] = q->quantum;
++		} else {
++			q->next[x] = q->next[q->tail];
++			q->next[q->tail] = x;
++			q->tail = x;
++		}
++	}
++}
++
++static int esfq_enqueue(struct sk_buff *skb, struct Qdisc* sch)
++{
++	struct esfq_sched_data *q = qdisc_priv(sch);
++	esfq_q_enqueue(skb, q, ESFQ_TAIL);
++	sch->qstats.backlog += skb->len;
++	if (++sch->q.qlen < q->limit-1) {
++		sch->bstats.bytes += skb->len;
++		sch->bstats.packets++;
++		return 0;
++	}
++
++	sch->qstats.drops++;
++	esfq_drop(sch);
++	return NET_XMIT_CN;
++}
++
++static struct sk_buff *esfq_peek(struct Qdisc* sch)
++{
++	struct esfq_sched_data *q = qdisc_priv(sch);
++	esfq_index a;
++
++	/* No active slots */
++	if (q->tail == q->depth)
++		return NULL;
++
++	a = q->next[q->tail];
++	return skb_peek(&q->qs[a]);
++}
++
++static struct sk_buff *esfq_q_dequeue(struct esfq_sched_data *q)
++{
++	struct sk_buff *skb;
++	unsigned depth = q->depth;
++	esfq_index a, old_a;
++
++	/* No active slots */
++	if (q->tail == depth)
++		return NULL;
++
++	a = old_a = q->next[q->tail];
++
++	/* Grab packet */
++	skb = __skb_dequeue(&q->qs[a]);
++	esfq_dec(q, a);
++
++	/* Is the slot empty? */
++	if (q->qs[a].qlen == 0) {
++		q->ht[q->hash[a]] = depth;
++		a = q->next[a];
++		if (a == old_a) {
++			q->tail = depth;
++			return skb;
++		}
++		q->next[q->tail] = a;
++		q->allot[a] += q->quantum;
++	} else if ((q->allot[a] -= skb->len) <= 0) {
++		q->tail = a;
++		a = q->next[a];
++		q->allot[a] += q->quantum;
++	}
++
++	return skb;
++}
++
++static struct sk_buff *esfq_dequeue(struct Qdisc* sch)
++{
++	struct esfq_sched_data *q = qdisc_priv(sch);
++	struct sk_buff *skb;
++
++	skb = esfq_q_dequeue(q);
++	if (skb == NULL)
++		return NULL;
++	sch->q.qlen--;
++	sch->qstats.backlog -= skb->len;
++	return skb;
++}
++
++static void esfq_q_destroy(struct esfq_sched_data *q)
++{
++	del_timer(&q->perturb_timer);
++	if(q->ht)
++		kfree(q->ht);
++	if(q->dep)
++		kfree(q->dep);
++	if(q->next)
++		kfree(q->next);
++	if(q->allot)
++		kfree(q->allot);
++	if(q->hash)
++		kfree(q->hash);
++	if(q->qs)
++		kfree(q->qs);
++}
++
++static void esfq_destroy(struct Qdisc *sch)
++{
++	struct esfq_sched_data *q = qdisc_priv(sch);
++	esfq_q_destroy(q);
++}
++
++
++static void esfq_reset(struct Qdisc* sch)
++{
++	struct sk_buff *skb;
++
++	while ((skb = esfq_dequeue(sch)) != NULL)
++		kfree_skb(skb);
++}
++
++static void esfq_perturbation(unsigned long arg)
++{
++	struct Qdisc *sch = (struct Qdisc*)arg;
++	struct esfq_sched_data *q = qdisc_priv(sch);
++
++	q->perturbation = net_random()&0x1F;
++
++	if (q->perturb_period) {
++		q->perturb_timer.expires = jiffies + q->perturb_period;
++		add_timer(&q->perturb_timer);
++	}
++}
++
++static unsigned int esfq_check_hash(unsigned int kind)
++{
++	switch (kind) {
++	case TCA_SFQ_HASH_CTORIGDST:
++	case TCA_SFQ_HASH_CTORIGSRC:
++	case TCA_SFQ_HASH_CTREPLDST:
++	case TCA_SFQ_HASH_CTREPLSRC:
++	case TCA_SFQ_HASH_CTNATCHG:
++#ifndef CONFIG_NET_SCH_ESFQ_NFCT
++	{
++		if (net_ratelimit())
++			printk(KERN_WARNING "ESFQ: Conntrack hash types disabled in kernel config. Falling back to classic.\n");
++		return TCA_SFQ_HASH_CLASSIC;
++	}
++#endif
++	case TCA_SFQ_HASH_CLASSIC:
++	case TCA_SFQ_HASH_DST:
++	case TCA_SFQ_HASH_SRC:
++	case TCA_SFQ_HASH_FWMARK:
++		return kind;
++	default:
++	{
++		if (net_ratelimit())
++			printk(KERN_WARNING "ESFQ: Unknown hash type. Falling back to classic.\n");
++		return TCA_SFQ_HASH_CLASSIC;
++	}
++	}
++}
++
++static int esfq_q_init(struct esfq_sched_data *q, struct nlattr *opt)
++{
++	struct tc_esfq_qopt *ctl = nla_data(opt);
++	esfq_index p = ~0U/2;
++	int i;
++
++	if (opt && opt->nla_len < nla_attr_size(sizeof(*ctl)))
++		return -EINVAL;
++
++	q->perturbation = 0;
++	q->hash_kind = TCA_SFQ_HASH_CLASSIC;
++	q->max_depth = 0;
++	if (opt == NULL) {
++		q->perturb_period = 0;
++		q->hash_divisor = 1024;
++		q->tail = q->limit = q->depth = 128;
++
++	} else {
++		struct tc_esfq_qopt *ctl = nla_data(opt);
++		if (ctl->quantum)
++			q->quantum = ctl->quantum;
++		q->perturb_period = ctl->perturb_period*HZ;
++		q->hash_divisor = ctl->divisor ? : 1024;
++		q->tail = q->limit = q->depth = ctl->flows ? : 128;
++
++		if ( q->depth > p - 1 )
++			return -EINVAL;
++
++		if (ctl->limit)
++			q->limit = min_t(u32, ctl->limit, q->depth);
++
++		if (ctl->hash_kind) {
++			q->hash_kind = esfq_check_hash(ctl->hash_kind);
++		}
++	}
++
++	q->ht = kmalloc(q->hash_divisor*sizeof(esfq_index), GFP_KERNEL);
++	if (!q->ht)
++		goto err_case;
++	q->dep = kmalloc((1+q->depth*2)*sizeof(struct esfq_head), GFP_KERNEL);
++	if (!q->dep)
++		goto err_case;
++	q->next = kmalloc(q->depth*sizeof(esfq_index), GFP_KERNEL);
++	if (!q->next)
++		goto err_case;
++	q->allot = kmalloc(q->depth*sizeof(short), GFP_KERNEL);
++	if (!q->allot)
++		goto err_case;
++	q->hash = kmalloc(q->depth*sizeof(unsigned short), GFP_KERNEL);
++	if (!q->hash)
++		goto err_case;
++	q->qs = kmalloc(q->depth*sizeof(struct sk_buff_head), GFP_KERNEL);
++	if (!q->qs)
++		goto err_case;
++
++	for (i=0; i< q->hash_divisor; i++)
++		q->ht[i] = q->depth;
++	for (i=0; i<q->depth; i++) {
++		skb_queue_head_init(&q->qs[i]);
++		q->dep[i+q->depth].next = i+q->depth;
++		q->dep[i+q->depth].prev = i+q->depth;
++	}
++
++	for (i=0; i<q->depth; i++)
++		esfq_link(q, i);
++	return 0;
++err_case:
++	esfq_q_destroy(q);
++	return -ENOBUFS;
++}
++
++static int esfq_init(struct Qdisc *sch, struct nlattr *opt)
++{
++	struct esfq_sched_data *q = qdisc_priv(sch);
++	int err;
++
++	q->quantum = psched_mtu(qdisc_dev(sch)); /* default */
++	if ((err = esfq_q_init(q, opt)))
++		return err;
++
++	init_timer(&q->perturb_timer);
++	q->perturb_timer.data = (unsigned long)sch;
++	q->perturb_timer.function = esfq_perturbation;
++	if (q->perturb_period) {
++		q->perturb_timer.expires = jiffies + q->perturb_period;
++		add_timer(&q->perturb_timer);
++	}
++
++	return 0;
++}
++
++static int esfq_change(struct Qdisc *sch, struct nlattr *opt)
++{
++	struct esfq_sched_data *q = qdisc_priv(sch);
++	struct esfq_sched_data new;
++	struct sk_buff *skb;
++	int err;
++
++	/* set up new queue */
++	memset(&new, 0, sizeof(struct esfq_sched_data));
++	new.quantum = psched_mtu(qdisc_dev(sch)); /* default */
++	if ((err = esfq_q_init(&new, opt)))
++		return err;
++
++	/* copy all packets from the old queue to the new queue */
++	sch_tree_lock(sch);
++	while ((skb = esfq_q_dequeue(q)) != NULL)
++		esfq_q_enqueue(skb, &new, ESFQ_TAIL);
++
++	/* clean up the old queue */
++	esfq_q_destroy(q);
++
++	/* copy elements of the new queue into the old queue */
++	q->perturb_period = new.perturb_period;
++	q->quantum        = new.quantum;
++	q->limit          = new.limit;
++	q->depth          = new.depth;
++	q->hash_divisor   = new.hash_divisor;
++	q->hash_kind      = new.hash_kind;
++	q->tail           = new.tail;
++	q->max_depth      = new.max_depth;
++	q->ht    = new.ht;
++	q->dep   = new.dep;
++	q->next  = new.next;
++	q->allot = new.allot;
++	q->hash  = new.hash;
++	q->qs    = new.qs;
++
++	/* finish up */
++	if (q->perturb_period) {
++		q->perturb_timer.expires = jiffies + q->perturb_period;
++		add_timer(&q->perturb_timer);
++	} else {
++		q->perturbation = 0;
++	}
++	sch_tree_unlock(sch);
++	return 0;
++}
++
++static int esfq_dump(struct Qdisc *sch, struct sk_buff *skb)
++{
++	struct esfq_sched_data *q = qdisc_priv(sch);
++	unsigned char *b = skb_tail_pointer(skb);
++	struct tc_esfq_qopt opt;
++
++	opt.quantum = q->quantum;
++	opt.perturb_period = q->perturb_period/HZ;
++
++	opt.limit = q->limit;
++	opt.divisor = q->hash_divisor;
++	opt.flows = q->depth;
++	opt.hash_kind = q->hash_kind;
++
++	if (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))
++		goto nla_put_failure;
++
++	return skb->len;
++
++nla_put_failure:
++	nlmsg_trim(skb, b);
++	return -1;
++}
++
++static struct Qdisc_ops esfq_qdisc_ops =
++{
++	.next		=	NULL,
++	.cl_ops		=	NULL,
++	.id		=	"esfq",
++	.priv_size	=	sizeof(struct esfq_sched_data),
++	.enqueue	=	esfq_enqueue,
++	.dequeue	=	esfq_dequeue,
++	.peek		=	esfq_peek,
++	.drop		=	esfq_drop,
++	.init		=	esfq_init,
++	.reset		=	esfq_reset,
++	.destroy	=	esfq_destroy,
++	.change		=	esfq_change,
++	.dump		=	esfq_dump,
++	.owner		=	THIS_MODULE,
++};
++
++static int __init esfq_module_init(void)
++{
++	return register_qdisc(&esfq_qdisc_ops);
++}
++static void __exit esfq_module_exit(void)
++{
++	unregister_qdisc(&esfq_qdisc_ops);
++}
++module_init(esfq_module_init)
++module_exit(esfq_module_exit)
++MODULE_LICENSE("GPL");
diff --git a/target/linux/generic/patches-3.10/621-sched_act_connmark.patch b/target/linux/generic/patches-3.10/621-sched_act_connmark.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/621-sched_act_connmark.patch
@@ -0,0 +1,183 @@
+--- /dev/null
++++ b/net/sched/act_connmark.c
+@@ -0,0 +1,148 @@
++/*
++ * Copyright (c) 2011 Felix Fietkau <nbd@openwrt.org>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms and conditions of the GNU General Public License,
++ * version 2, as published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++ * more details.
++ *
++ * You should have received a copy of the GNU General Public License along with
++ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
++ * Place - Suite 330, Boston, MA 02111-1307 USA.
++ */
++
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/skbuff.h>
++#include <linux/rtnetlink.h>
++#include <linux/pkt_cls.h>
++#include <linux/ip.h>
++#include <linux/ipv6.h>
++#include <net/netlink.h>
++#include <net/pkt_sched.h>
++#include <net/act_api.h>
++
++#include <net/netfilter/nf_conntrack.h>
++#include <net/netfilter/nf_conntrack_core.h>
++
++#define TCA_ACT_CONNMARK	20
++
++#define CONNMARK_TAB_MASK     3
++static struct tcf_common *tcf_connmark_ht[CONNMARK_TAB_MASK + 1];
++static u32 connmark_idx_gen;
++static DEFINE_RWLOCK(connmark_lock);
++
++static struct tcf_hashinfo connmark_hash_info = {
++	.htab	=	tcf_connmark_ht,
++	.hmask	=	CONNMARK_TAB_MASK,
++	.lock	=	&connmark_lock,
++};
++
++static int tcf_connmark(struct sk_buff *skb, const struct tc_action *a,
++		       struct tcf_result *res)
++{
++	struct nf_conn *c;
++	enum ip_conntrack_info ctinfo;
++	int proto;
++	int r;
++
++	if (skb->protocol == htons(ETH_P_IP)) {
++		if (skb->len < sizeof(struct iphdr))
++			goto out;
++		proto = PF_INET;
++	} else if (skb->protocol == htons(ETH_P_IPV6)) {
++		if (skb->len < sizeof(struct ipv6hdr))
++			goto out;
++		proto = PF_INET6;
++	} else
++		goto out;
++
++	r = nf_conntrack_in(dev_net(skb->dev), proto, NF_INET_PRE_ROUTING, skb);
++	if (r != NF_ACCEPT)
++		goto out;
++
++	c = nf_ct_get(skb, &ctinfo);
++	if (!c)
++		goto out;
++
++	skb->mark = c->mark;
++	nf_conntrack_put(skb->nfct);
++	skb->nfct = NULL;
++
++out:
++	return TC_ACT_PIPE;
++}
++
++static int tcf_connmark_init(struct net *net, struct nlattr *nla,
++			     struct nlattr *est, struct tc_action *a,
++			     int ovr, int bind)
++{
++	struct tcf_common *pc;
++	int ret = 0;
++
++	pc = tcf_hash_check(0, a, bind, &connmark_hash_info);
++	if (!pc) {
++		pc = tcf_hash_create(0, est, a, sizeof(*pc), bind,
++				     &connmark_idx_gen, &connmark_hash_info);
++		if (IS_ERR(pc))
++		    return PTR_ERR(pc);
++
++		tcf_hash_insert(pc, &connmark_hash_info);
++		ret = ACT_P_CREATED;
++	} else {
++		if (!ovr) {
++			tcf_hash_release(pc, bind, &connmark_hash_info);
++			return -EEXIST;
++		}
++	}
++
++	return ret;
++}
++
++static inline int tcf_connmark_cleanup(struct tc_action *a, int bind)
++{
++	if (a->priv)
++		return tcf_hash_release(a->priv, bind, &connmark_hash_info);
++	return 0;
++}
++
++static inline int tcf_connmark_dump(struct sk_buff *skb, struct tc_action *a,
++				int bind, int ref)
++{
++	return skb->len;
++}
++
++static struct tc_action_ops act_connmark_ops = {
++	.kind		=	"connmark",
++	.hinfo		=	&connmark_hash_info,
++	.type		=	TCA_ACT_CONNMARK,
++	.capab		=	TCA_CAP_NONE,
++	.owner		=	THIS_MODULE,
++	.act		=	tcf_connmark,
++	.dump		=	tcf_connmark_dump,
++	.cleanup	=	tcf_connmark_cleanup,
++	.init		=	tcf_connmark_init,
++	.walk		=	tcf_generic_walker,
++};
++
++MODULE_AUTHOR("Felix Fietkau <nbd@openwrt.org>");
++MODULE_DESCRIPTION("Connection tracking mark restoring");
++MODULE_LICENSE("GPL");
++
++static int __init connmark_init_module(void)
++{
++	return tcf_register_action(&act_connmark_ops);
++}
++
++static void __exit connmark_cleanup_module(void)
++{
++	tcf_unregister_action(&act_connmark_ops);
++}
++
++module_init(connmark_init_module);
++module_exit(connmark_cleanup_module);
+--- a/net/sched/Kconfig
++++ b/net/sched/Kconfig
+@@ -670,6 +670,19 @@ config NET_ACT_CSUM
+ 	  To compile this code as a module, choose M here: the
+ 	  module will be called act_csum.
+ 
++config NET_ACT_CONNMARK
++        tristate "Connection Tracking Marking"
++        depends on NET_CLS_ACT
++        depends on NF_CONNTRACK
++	 depends on NF_CONNTRACK_MARK
++        ---help---
++	  Say Y here to restore the connmark from a scheduler action
++
++	  If unsure, say N.
++
++	  To compile this code as a module, choose M here: the
++	  module will be called act_connmark.
++
+ config NET_CLS_IND
+ 	bool "Incoming device classification"
+ 	depends on NET_CLS_U32 || NET_CLS_FW
+--- a/net/sched/Makefile
++++ b/net/sched/Makefile
+@@ -16,6 +16,7 @@ obj-$(CONFIG_NET_ACT_PEDIT)	+= act_pedit
+ obj-$(CONFIG_NET_ACT_SIMP)	+= act_simple.o
+ obj-$(CONFIG_NET_ACT_SKBEDIT)	+= act_skbedit.o
+ obj-$(CONFIG_NET_ACT_CSUM)	+= act_csum.o
++obj-$(CONFIG_NET_ACT_CONNMARK)	+= act_connmark.o
+ obj-$(CONFIG_NET_SCH_FIFO)	+= sch_fifo.o
+ obj-$(CONFIG_NET_SCH_CBQ)	+= sch_cbq.o
+ obj-$(CONFIG_NET_SCH_HTB)	+= sch_htb.o
diff --git a/target/linux/generic/patches-3.10/630-packet_socket_type.patch b/target/linux/generic/patches-3.10/630-packet_socket_type.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/630-packet_socket_type.patch
@@ -0,0 +1,140 @@
+This patch allows the user to specify desired packet types (outgoing,
+broadcast, unicast, etc.) on packet sockets via setsockopt.
+This can reduce the load in situations where only a limited number
+of packet types are necessary
+
+Signed-off-by: Felix Fietkau <nbd@openwrt.org>
+
+Index: kernel_tree/include/uapi/linux/if_packet.h
+===================================================================
+--- kernel_tree.orig/include/uapi/linux/if_packet.h
++++ kernel_tree/include/uapi/linux/if_packet.h
+@@ -29,6 +29,8 @@ struct sockaddr_ll {
+ /* These ones are invisible by user level */
+ #define PACKET_LOOPBACK		5		/* MC/BRD frame looped back */
+ #define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
++#define PACKET_MASK_ANY		0xffffffff	/* mask for packet type bits */
++
+ 
+ /* Packet socket options */
+ 
+@@ -51,6 +53,7 @@ struct sockaddr_ll {
+ #define PACKET_TIMESTAMP		17
+ #define PACKET_FANOUT			18
+ #define PACKET_TX_HAS_OFF		19
++#define PACKET_RECV_TYPE		20
+ 
+ #define PACKET_FANOUT_HASH		0
+ #define PACKET_FANOUT_LB		1
+Index: kernel_tree/net/packet/af_packet.c
+===================================================================
+--- kernel_tree.orig/net/packet/af_packet.c
++++ kernel_tree/net/packet/af_packet.c
+@@ -1390,6 +1390,7 @@ static int packet_rcv_spkt(struct sk_buf
+ {
+ 	struct sock *sk;
+ 	struct sockaddr_pkt *spkt;
++	struct packet_sock *po;
+ 
+ 	/*
+ 	 *	When we registered the protocol we saved the socket in the data
+@@ -1397,6 +1398,7 @@ static int packet_rcv_spkt(struct sk_buf
+ 	 */
+ 
+ 	sk = pt->af_packet_priv;
++	po = pkt_sk(sk);
+ 
+ 	/*
+ 	 *	Yank back the headers [hope the device set this
+@@ -1409,7 +1411,7 @@ static int packet_rcv_spkt(struct sk_buf
+ 	 *	so that this procedure is noop.
+ 	 */
+ 
+-	if (skb->pkt_type == PACKET_LOOPBACK)
++	if (!(po->pkt_type & (1 << skb->pkt_type)))
+ 		goto out;
+ 
+ 	if (!net_eq(dev_net(dev), sock_net(sk)))
+@@ -1616,12 +1618,12 @@ static int packet_rcv(struct sk_buff *sk
+ 	int skb_len = skb->len;
+ 	unsigned int snaplen, res;
+ 
+-	if (skb->pkt_type == PACKET_LOOPBACK)
+-		goto drop;
+-
+ 	sk = pt->af_packet_priv;
+ 	po = pkt_sk(sk);
+ 
++	if (!(po->pkt_type & (1 << skb->pkt_type)))
++		goto drop;
++
+ 	if (!net_eq(dev_net(dev), sock_net(sk)))
+ 		goto drop;
+ 
+@@ -1734,12 +1736,12 @@ static int tpacket_rcv(struct sk_buff *s
+ 	struct timespec ts;
+ 	__u32 ts_status;
+ 
+-	if (skb->pkt_type == PACKET_LOOPBACK)
+-		goto drop;
+-
+ 	sk = pt->af_packet_priv;
+ 	po = pkt_sk(sk);
+ 
++	if (!(po->pkt_type & (1 << skb->pkt_type)))
++		goto drop;
++
+ 	if (!net_eq(dev_net(dev), sock_net(sk)))
+ 		goto drop;
+ 
+@@ -2640,6 +2642,7 @@ static int packet_create(struct net *net
+ 	spin_lock_init(&po->bind_lock);
+ 	mutex_init(&po->pg_vec_lock);
+ 	po->prot_hook.func = packet_rcv;
++	po->pkt_type = PACKET_MASK_ANY & ~(1 << PACKET_LOOPBACK);
+ 
+ 	if (sock->type == SOCK_PACKET)
+ 		po->prot_hook.func = packet_rcv_spkt;
+@@ -3250,6 +3253,16 @@ packet_setsockopt(struct socket *sock, i
+ 		po->tp_tx_has_off = !!val;
+ 		return 0;
+ 	}
++        case PACKET_RECV_TYPE:
++        {
++                unsigned int val;
++                if (optlen != sizeof(val))
++                        return -EINVAL;
++                if (copy_from_user(&val, optval, sizeof(val)))
++                        return -EFAULT;
++                po->pkt_type = val & ~PACKET_LOOPBACK;
++                return 0;
++        }
+ 	default:
+ 		return -ENOPROTOOPT;
+ 	}
+@@ -3301,6 +3314,13 @@ static int packet_getsockopt(struct sock
+ 	case PACKET_VNET_HDR:
+ 		val = po->has_vnet_hdr;
+ 		break;
++	case PACKET_RECV_TYPE:
++		if (len > sizeof(unsigned int))
++			len = sizeof(unsigned int);
++		val = po->pkt_type;
++
++		data = &val;
++		break;
+ 	case PACKET_VERSION:
+ 		val = po->tp_version;
+ 		break;
+Index: kernel_tree/net/packet/internal.h
+===================================================================
+--- kernel_tree.orig/net/packet/internal.h
++++ kernel_tree/net/packet/internal.h
+@@ -116,6 +116,7 @@ struct packet_sock {
+ 	unsigned int		tp_tstamp;
+ 	struct net_device __rcu	*cached_dev;
+ 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
++	unsigned int		pkt_type;
+ };
+ 
+ static struct packet_sock *pkt_sk(struct sock *sk)
diff --git a/target/linux/generic/patches-3.10/640-bridge_no_eap_forward.patch b/target/linux/generic/patches-3.10/640-bridge_no_eap_forward.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/640-bridge_no_eap_forward.patch
@@ -0,0 +1,15 @@
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -94,7 +94,11 @@ int br_handle_frame_finish(struct sk_buf
+ 
+ 	dst = NULL;
+ 
+-	if (is_broadcast_ether_addr(dest))
++	if (skb->protocol == htons(ETH_P_PAE)) {
++		skb2 = skb;
++		/* Do not forward 802.1x/EAP frames */
++		skb = NULL;
++	} else if (is_broadcast_ether_addr(dest))
+ 		skb2 = skb;
+ 	else if (is_multicast_ether_addr(dest)) {
+ 		mdst = br_mdb_get(br, skb, vid);
diff --git a/target/linux/generic/patches-3.10/641-bridge_always_accept_eap.patch b/target/linux/generic/patches-3.10/641-bridge_always_accept_eap.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/641-bridge_always_accept_eap.patch
@@ -0,0 +1,11 @@
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -81,7 +81,7 @@ int br_handle_frame_finish(struct sk_buf
+ 	    br_multicast_rcv(br, p, skb))
+ 		goto drop;
+ 
+-	if (p->state == BR_STATE_LEARNING)
++	if ((p->state == BR_STATE_LEARNING) && skb->protocol != htons(ETH_P_PAE))
+ 		goto drop;
+ 
+ 	BR_INPUT_SKB_CB(skb)->brdev = br->dev;
diff --git a/target/linux/generic/patches-3.10/642-bridge_port_isolate.patch b/target/linux/generic/patches-3.10/642-bridge_port_isolate.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/642-bridge_port_isolate.patch
@@ -0,0 +1,104 @@
+--- a/net/bridge/br_private.h
++++ b/net/bridge/br_private.h
+@@ -157,6 +157,7 @@ struct net_bridge_port
+ #define BR_ROOT_BLOCK		0x00000004
+ #define BR_MULTICAST_FAST_LEAVE	0x00000008
+ #define BR_ADMIN_COST		0x00000010
++#define BR_ISOLATE_MODE		0x00000020
+ 
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	u32				multicast_startup_queries_sent;
+--- a/net/bridge/br_sysfs_if.c
++++ b/net/bridge/br_sysfs_if.c
+@@ -159,6 +159,22 @@ BRPORT_ATTR_FLAG(hairpin_mode, BR_HAIRPI
+ BRPORT_ATTR_FLAG(bpdu_guard, BR_BPDU_GUARD);
+ BRPORT_ATTR_FLAG(root_block, BR_ROOT_BLOCK);
+ 
++static ssize_t show_isolate_mode(struct net_bridge_port *p, char *buf)
++{
++	int isolate_mode = (p->flags & BR_ISOLATE_MODE) ? 1 : 0;
++	return sprintf(buf, "%d\n", isolate_mode);
++}
++static ssize_t store_isolate_mode(struct net_bridge_port *p, unsigned long v)
++{
++	if (v)
++		p->flags |= BR_ISOLATE_MODE;
++	else
++		p->flags &= ~BR_ISOLATE_MODE;
++	return 0;
++}
++static BRPORT_ATTR(isolate_mode, S_IRUGO | S_IWUSR,
++		   show_isolate_mode, store_isolate_mode);
++
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
+ {
+@@ -199,6 +215,7 @@ static const struct brport_attribute *br
+ 	&brport_attr_multicast_router,
+ 	&brport_attr_multicast_fast_leave,
+ #endif
++	&brport_attr_isolate_mode,
+ 	NULL
+ };
+ 
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -114,8 +114,8 @@ int br_handle_frame_finish(struct sk_buf
+ 			skb2 = skb;
+ 
+ 		br->dev->stats.multicast++;
+-	} else if ((dst = __br_fdb_get(br, dest, vid)) &&
+-			dst->is_local) {
++	} else if ((p->flags & BR_ISOLATE_MODE) ||
++		   ((dst = __br_fdb_get(br, dest, vid)) && dst->is_local)) {
+ 		skb2 = skb;
+ 		/* Do not forward the packet since it's local. */
+ 		skb = NULL;
+--- a/net/bridge/br_forward.c
++++ b/net/bridge/br_forward.c
+@@ -119,7 +119,7 @@ void br_deliver(const struct net_bridge_
+ /* called with rcu_read_lock */
+ void br_forward(const struct net_bridge_port *to, struct sk_buff *skb, struct sk_buff *skb0)
+ {
+-	if (should_deliver(to, skb)) {
++	if (should_deliver(to, skb) && !(to->flags & BR_ISOLATE_MODE)) {
+ 		if (skb0)
+ 			deliver_clone(to, skb, __br_forward);
+ 		else
+@@ -174,7 +174,8 @@ out:
+ static void br_flood(struct net_bridge *br, struct sk_buff *skb,
+ 		     struct sk_buff *skb0,
+ 		     void (*__packet_hook)(const struct net_bridge_port *p,
+-					   struct sk_buff *skb))
++					   struct sk_buff *skb),
++		     bool forward)
+ {
+ 	struct net_bridge_port *p;
+ 	struct net_bridge_port *prev;
+@@ -182,6 +183,9 @@ static void br_flood(struct net_bridge *
+ 	prev = NULL;
+ 
+ 	list_for_each_entry_rcu(p, &br->port_list, list) {
++		if (forward && (p->flags & BR_ISOLATE_MODE))
++			continue;
++
+ 		prev = maybe_deliver(prev, p, skb, __packet_hook);
+ 		if (IS_ERR(prev))
+ 			goto out;
+@@ -205,14 +209,14 @@ out:
+ /* called with rcu_read_lock */
+ void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb)
+ {
+-	br_flood(br, skb, NULL, __br_deliver);
++	br_flood(br, skb, NULL, __br_deliver, false);
+ }
+ 
+ /* called under bridge lock */
+ void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
+ 		      struct sk_buff *skb2)
+ {
+-	br_flood(br, skb, skb2, __br_forward);
++	br_flood(br, skb, skb2, __br_forward, true);
+ }
+ 
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
diff --git a/target/linux/generic/patches-3.10/643-bridge_remove_ipv6_dependency.patch b/target/linux/generic/patches-3.10/643-bridge_remove_ipv6_dependency.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/643-bridge_remove_ipv6_dependency.patch
@@ -0,0 +1,117 @@
+Index: kernel_tree/include/net/addrconf.h
+===================================================================
+--- kernel_tree.orig/include/net/addrconf.h
++++ kernel_tree/include/net/addrconf.h
+@@ -103,6 +103,12 @@ extern void			addrconf_join_solict(struc
+ extern void			addrconf_leave_solict(struct inet6_dev *idev,
+ 					const struct in6_addr *addr);
+ 
++extern int			(*ipv6_dev_get_saddr_hook)(struct net *net,
++						const struct net_device *dev,
++						const struct in6_addr *daddr,
++						unsigned int prefs,
++						struct in6_addr *saddr);
++
+ static inline unsigned long addrconf_timeout_fixup(u32 timeout,
+ 						   unsigned int unit)
+ {
+Index: kernel_tree/net/bridge/Kconfig
+===================================================================
+--- kernel_tree.orig/net/bridge/Kconfig
++++ kernel_tree/net/bridge/Kconfig
+@@ -6,7 +6,6 @@ config BRIDGE
+ 	tristate "802.1d Ethernet Bridging"
+ 	select LLC
+ 	select STP
+-	depends on IPV6 || IPV6=n
+ 	---help---
+ 	  If you say Y here, then your Linux box will be able to act as an
+ 	  Ethernet bridge, which means that the different Ethernet segments it
+Index: kernel_tree/net/ipv6/Makefile
+===================================================================
+--- kernel_tree.orig/net/ipv6/Makefile
++++ kernel_tree/net/ipv6/Makefile
+@@ -44,3 +44,4 @@ obj-y += addrconf_core.o exthdrs_core.o
+ obj-$(CONFIG_INET) += output_core.o protocol.o $(ipv6-offload)
+ 
+ obj-$(subst m,y,$(CONFIG_IPV6)) += inet6_hashtables.o
++obj-$(subst m,y,$(CONFIG_IPV6)) += inet6_stubs.o
+Index: kernel_tree/net/ipv6/addrconf.c
+===================================================================
+--- kernel_tree.orig/net/ipv6/addrconf.c
++++ kernel_tree/net/ipv6/addrconf.c
+@@ -1322,7 +1322,7 @@ out:
+ 	return ret;
+ }
+ 
+-int ipv6_dev_get_saddr(struct net *net, const struct net_device *dst_dev,
++static int __ipv6_dev_get_saddr(struct net *net, const struct net_device *dst_dev,
+ 		       const struct in6_addr *daddr, unsigned int prefs,
+ 		       struct in6_addr *saddr)
+ {
+@@ -1447,7 +1447,6 @@ try_nextdev:
+ 	in6_ifa_put(hiscore->ifa);
+ 	return 0;
+ }
+-EXPORT_SYMBOL(ipv6_dev_get_saddr);
+ 
+ int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,
+ 		      unsigned char banned_flags)
+@@ -5183,6 +5182,9 @@ int __init addrconf_init(void)
+ 
+ 	ipv6_addr_label_rtnl_register();
+ 
++	BUG_ON(ipv6_dev_get_saddr_hook != NULL);
++	rcu_assign_pointer(ipv6_dev_get_saddr_hook, __ipv6_dev_get_saddr);
++
+ 	return 0;
+ errout:
+ 	rtnl_af_unregister(&inet6_ops);
+@@ -5201,6 +5203,9 @@ void addrconf_cleanup(void)
+ 	struct net_device *dev;
+ 	int i;
+ 
++	rcu_assign_pointer(ipv6_dev_get_saddr_hook, NULL);
++	synchronize_rcu();
++
+ 	unregister_netdevice_notifier(&ipv6_dev_notf);
+ 	unregister_pernet_subsys(&addrconf_ops);
+ 	ipv6_addr_label_cleanup();
+Index: kernel_tree/net/ipv6/inet6_stubs.c
+===================================================================
+--- /dev/null
++++ kernel_tree/net/ipv6/inet6_stubs.c
+@@ -0,0 +1,33 @@
++/*
++ *      This program is free software; you can redistribute it and/or
++ *      modify it under the terms of the GNU General Public License
++ *      as published by the Free Software Foundation; either version
++ *      2 of the License, or (at your option) any later version.
++ */
++#include <linux/export.h>
++#include <net/ipv6.h>
++
++int (*ipv6_dev_get_saddr_hook)(struct net *net, const struct net_device *dev,
++			const struct in6_addr *daddr, unsigned int prefs,
++			struct in6_addr *saddr);
++
++EXPORT_SYMBOL(ipv6_dev_get_saddr_hook);
++
++int ipv6_dev_get_saddr(struct net *net, const struct net_device *dst_dev,
++			const struct in6_addr *daddr, unsigned int prefs,
++			struct in6_addr *saddr)
++{
++	int ret = -EADDRNOTAVAIL;
++	typeof(ipv6_dev_get_saddr_hook) dev_get_saddr;
++
++	rcu_read_lock();
++	dev_get_saddr = rcu_dereference(ipv6_dev_get_saddr_hook);
++
++	if (dev_get_saddr)
++		ret = dev_get_saddr(net, dst_dev, daddr, prefs, saddr);
++
++	rcu_read_unlock();
++	return ret;
++}
++EXPORT_SYMBOL(ipv6_dev_get_saddr);
++
diff --git a/target/linux/generic/patches-3.10/644-bridge_optimize_netfilter_hooks.patch b/target/linux/generic/patches-3.10/644-bridge_optimize_netfilter_hooks.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/644-bridge_optimize_netfilter_hooks.patch
@@ -0,0 +1,169 @@
+Index: kernel_tree/net/bridge/br_forward.c
+===================================================================
+--- kernel_tree.orig/net/bridge/br_forward.c
++++ kernel_tree/net/bridge/br_forward.c
+@@ -57,7 +57,7 @@ int br_dev_queue_push_xmit(struct sk_buf
+ 
+ int br_forward_finish(struct sk_buff *skb)
+ {
+-	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING, skb, NULL, skb->dev,
++	return BR_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING, skb, NULL, skb->dev,
+ 		       br_dev_queue_push_xmit);
+ 
+ }
+@@ -80,7 +80,7 @@ static void __br_deliver(const struct ne
+ 		return;
+ 	}
+ 
+-	NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,
++	BR_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,
+ 		br_forward_finish);
+ }
+ 
+@@ -101,7 +101,7 @@ static void __br_forward(const struct ne
+ 	skb->dev = to->dev;
+ 	skb_forward_csum(skb);
+ 
+-	NF_HOOK(NFPROTO_BRIDGE, NF_BR_FORWARD, skb, indev, skb->dev,
++	BR_HOOK(NFPROTO_BRIDGE, NF_BR_FORWARD, skb, indev, skb->dev,
+ 		br_forward_finish);
+ }
+ 
+Index: kernel_tree/net/bridge/br_input.c
+===================================================================
+--- kernel_tree.orig/net/bridge/br_input.c
++++ kernel_tree/net/bridge/br_input.c
+@@ -52,7 +52,7 @@ static int br_pass_frame_up(struct sk_bu
+ 	indev = skb->dev;
+ 	skb->dev = brdev;
+ 
+-	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, skb, indev, NULL,
++	return BR_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, skb, indev, NULL,
+ 		       netif_receive_skb);
+ }
+ 
+@@ -209,7 +209,7 @@ rx_handler_result_t br_handle_frame(stru
+ 		}
+ 
+ 		/* Deliver packet to local host only */
+-		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, skb, skb->dev,
++		if (BR_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, skb, skb->dev,
+ 			    NULL, br_handle_local_finish)) {
+ 			return RX_HANDLER_CONSUMED; /* consumed by filter */
+ 		} else {
+@@ -224,7 +224,7 @@ forward:
+ 		if (ether_addr_equal(p->br->dev->dev_addr, dest))
+ 			skb->pkt_type = PACKET_HOST;
+ 
+-		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,
++		if (BR_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,
+ 			br_handle_local_finish))
+ 			break;
+ 
+@@ -246,7 +246,7 @@ forward:
+ 		if (ether_addr_equal(p->br->dev->dev_addr, dest))
+ 			skb->pkt_type = PACKET_HOST;
+ 
+-		NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,
++		BR_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,
+ 			br_handle_frame_finish);
+ 		break;
+ 	default:
+Index: kernel_tree/net/bridge/br_multicast.c
+===================================================================
+--- kernel_tree.orig/net/bridge/br_multicast.c
++++ kernel_tree/net/bridge/br_multicast.c
+@@ -783,7 +783,7 @@ static void __br_multicast_send_query(st
+ 	if (port) {
+ 		__skb_push(skb, sizeof(struct ethhdr));
+ 		skb->dev = port->dev;
+-		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,
++		BR_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,
+ 			dev_queue_xmit);
+ 	} else
+ 		netif_rx(skb);
+Index: kernel_tree/net/bridge/br_netfilter.c
+===================================================================
+--- kernel_tree.orig/net/bridge/br_netfilter.c
++++ kernel_tree/net/bridge/br_netfilter.c
+@@ -73,6 +73,15 @@ static int brnf_pass_vlan_indev __read_m
+ #define IS_ARP(skb) \
+ 	(!vlan_tx_tag_present(skb) && skb->protocol == htons(ETH_P_ARP))
+ 
++int brnf_call_ebtables __read_mostly = 0;
++EXPORT_SYMBOL_GPL(brnf_call_ebtables);
++
++bool br_netfilter_run_hooks(void)
++{
++	return brnf_call_iptables | brnf_call_ip6tables | brnf_call_arptables |
++	       brnf_call_ebtables;
++}
++
+ static inline __be16 vlan_proto(const struct sk_buff *skb)
+ {
+ 	if (vlan_tx_tag_present(skb))
+Index: kernel_tree/net/bridge/br_private.h
+===================================================================
+--- kernel_tree.orig/net/bridge/br_private.h
++++ kernel_tree/net/bridge/br_private.h
+@@ -706,15 +706,29 @@ static inline u16 br_get_pvid(const stru
+ 
+ /* br_netfilter.c */
+ #ifdef CONFIG_BRIDGE_NETFILTER
++extern int brnf_call_ebtables;
+ extern int br_netfilter_init(void);
+ extern void br_netfilter_fini(void);
+ extern void br_netfilter_rtable_init(struct net_bridge *);
++extern bool br_netfilter_run_hooks(void);
+ #else
+ #define br_netfilter_init()	(0)
+ #define br_netfilter_fini()	do { } while(0)
+ #define br_netfilter_rtable_init(x)
++#define br_netfilter_run_hooks()	false
+ #endif
+ 
++static inline int
++BR_HOOK(uint8_t pf, unsigned int hook, struct sk_buff *skb,
++	struct net_device *in, struct net_device *out,
++	int (*okfn)(struct sk_buff *))
++{
++	if (!br_netfilter_run_hooks())
++		return okfn(skb);
++
++	return NF_HOOK(pf, hook, skb, in, out, okfn);
++}
++
+ /* br_stp.c */
+ extern void br_log_state(const struct net_bridge_port *p);
+ extern struct net_bridge_port *br_get_port(struct net_bridge *br,
+Index: kernel_tree/net/bridge/br_stp_bpdu.c
+===================================================================
+--- kernel_tree.orig/net/bridge/br_stp_bpdu.c
++++ kernel_tree/net/bridge/br_stp_bpdu.c
+@@ -54,7 +54,7 @@ static void br_send_bpdu(struct net_brid
+ 
+ 	skb_reset_mac_header(skb);
+ 
+-	NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,
++	BR_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,
+ 		dev_queue_xmit);
+ }
+ 
+Index: kernel_tree/net/bridge/netfilter/ebtables.c
+===================================================================
+--- kernel_tree.orig/net/bridge/netfilter/ebtables.c
++++ kernel_tree/net/bridge/netfilter/ebtables.c
+@@ -2406,11 +2406,13 @@ static int __init ebtables_init(void)
+ 	}
+ 
+ 	printk(KERN_INFO "Ebtables v2.0 registered\n");
++	brnf_call_ebtables = 1;
+ 	return 0;
+ }
+ 
+ static void __exit ebtables_fini(void)
+ {
++	brnf_call_ebtables = 0;
+ 	nf_unregister_sockopt(&ebt_sockopts);
+ 	xt_unregister_target(&ebt_standard_target);
+ 	printk(KERN_INFO "Ebtables v2.0 unregistered\n");
diff --git a/target/linux/generic/patches-3.10/650-pppoe_header_pad.patch b/target/linux/generic/patches-3.10/650-pppoe_header_pad.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/650-pppoe_header_pad.patch
@@ -0,0 +1,20 @@
+--- a/drivers/net/ppp/pppoe.c
++++ b/drivers/net/ppp/pppoe.c
+@@ -850,7 +850,7 @@ static int pppoe_sendmsg(struct kiocb *i
+ 		goto end;
+ 
+ 
+-	skb = sock_wmalloc(sk, total_len + dev->hard_header_len + 32,
++	skb = sock_wmalloc(sk, total_len + dev->hard_header_len + 32 + NET_SKB_PAD,
+ 			   0, GFP_KERNEL);
+ 	if (!skb) {
+ 		error = -ENOMEM;
+@@ -858,7 +858,7 @@ static int pppoe_sendmsg(struct kiocb *i
+ 	}
+ 
+ 	/* Reserve space for headers. */
+-	skb_reserve(skb, dev->hard_header_len);
++	skb_reserve(skb, dev->hard_header_len + NET_SKB_PAD);
+ 	skb_reset_network_header(skb);
+ 
+ 	skb->dev = dev;
diff --git a/target/linux/generic/patches-3.10/651-wireless_mesh_header.patch b/target/linux/generic/patches-3.10/651-wireless_mesh_header.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/651-wireless_mesh_header.patch
@@ -0,0 +1,11 @@
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -139,7 +139,7 @@ static inline bool dev_xmit_complete(int
+  */
+ 
+ #if defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25)
+-# if defined(CONFIG_MAC80211_MESH)
++# if 1 || defined(CONFIG_MAC80211_MESH)
+ #  define LL_MAX_HEADER 128
+ # else
+ #  define LL_MAX_HEADER 96
diff --git a/target/linux/generic/patches-3.10/652-atm_header_changes.patch b/target/linux/generic/patches-3.10/652-atm_header_changes.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/652-atm_header_changes.patch
@@ -0,0 +1,12 @@
+--- a/include/uapi/linux/atm.h
++++ b/include/uapi/linux/atm.h
+@@ -139,6 +139,9 @@ struct atm_trafprm {
+ 	int		min_pcr;	/* minimum PCR in cells per second */
+ 	int		max_cdv;	/* maximum CDV in microseconds */
+ 	int		max_sdu;	/* maximum SDU in bytes */
++	int		scr;		/* sustained rate in cells per second */
++	int		mbs;		/* maximum burst size (MBS) in cells */
++	int		cdv;		/* Cell delay varition */
+         /* extra params for ABR */
+         unsigned int 	icr;         	/* Initial Cell Rate (24-bit) */
+         unsigned int	tbe;		/* Transient Buffer Exposure (24-bit) */ 
diff --git a/target/linux/generic/patches-3.10/653-disable_netlink_trim.patch b/target/linux/generic/patches-3.10/653-disable_netlink_trim.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/653-disable_netlink_trim.patch
@@ -0,0 +1,32 @@
+Index: kernel_tree/net/netlink/af_netlink.c
+===================================================================
+--- kernel_tree.orig/net/netlink/af_netlink.c
++++ kernel_tree/net/netlink/af_netlink.c
+@@ -1565,27 +1565,7 @@ void netlink_detachskb(struct sock *sk,
+ 
+ static struct sk_buff *netlink_trim(struct sk_buff *skb, gfp_t allocation)
+ {
+-	int delta;
+-
+ 	WARN_ON(skb->sk != NULL);
+-	if (netlink_skb_is_mmaped(skb))
+-		return skb;
+-
+-	delta = skb->end - skb->tail;
+-	if (delta * 2 < skb->truesize)
+-		return skb;
+-
+-	if (skb_shared(skb)) {
+-		struct sk_buff *nskb = skb_clone(skb, allocation);
+-		if (!nskb)
+-			return skb;
+-		consume_skb(skb);
+-		skb = nskb;
+-	}
+-
+-	if (!pskb_expand_head(skb, 0, -delta, allocation))
+-		skb->truesize -= delta;
+-
+ 	return skb;
+ }
+ 
diff --git a/target/linux/generic/patches-3.10/655-increase_skb_pad.patch b/target/linux/generic/patches-3.10/655-increase_skb_pad.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/655-increase_skb_pad.patch
@@ -0,0 +1,13 @@
+Index: kernel_tree/include/linux/skbuff.h
+===================================================================
+--- kernel_tree.orig/include/linux/skbuff.h
++++ kernel_tree/include/linux/skbuff.h
+@@ -1849,7 +1849,7 @@ static inline int pskb_network_may_pull(
+  * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)
+  */
+ #ifndef NET_SKB_PAD
+-#define NET_SKB_PAD	max(32, L1_CACHE_BYTES)
++#define NET_SKB_PAD	max(64, L1_CACHE_BYTES)
+ #endif
+ 
+ extern int ___pskb_trim(struct sk_buff *skb, unsigned int len);
diff --git a/target/linux/generic/patches-3.10/656-skb_reduce_truesize-helper.patch b/target/linux/generic/patches-3.10/656-skb_reduce_truesize-helper.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/656-skb_reduce_truesize-helper.patch
@@ -0,0 +1,43 @@
+From 4593a806e31119c5bd3faa00c7210ad862d515af Mon Sep 17 00:00:00 2001
+From: Dave Taht <dave.taht@bufferbloat.net>
+Date: Mon, 31 Dec 2012 10:02:21 -0800
+Subject: [PATCH 3/7] skb_reduce_truesize: helper function for shrinking skbs
+ whenever needed
+
+On embedded devices in particular, large queues of small packets from the rx
+path with a large truesize can exist. Reducing their size can reduce
+memory pressure. skb_reduce_truesize is a helper function for doing this,
+when needed.
+---
+ include/linux/skbuff.h |   18 ++++++++++++++++++
+ 1 file changed, 18 insertions(+)
+
+Index: kernel_tree/include/linux/skbuff.h
+===================================================================
+--- kernel_tree.orig/include/linux/skbuff.h
++++ kernel_tree/include/linux/skbuff.h
+@@ -1894,6 +1894,24 @@ static inline void pskb_trim_unique(stru
+ 	BUG_ON(err);
+ }
+ 
++/*
++ * Caller wants to reduce memory needs before queueing skb
++ * The (expensive) copy should not be be done in fast path.
++ */
++static inline struct sk_buff *skb_reduce_truesize(struct sk_buff *skb)
++{
++	if (skb->truesize > 2 * SKB_TRUESIZE(skb->len)) {
++		struct sk_buff *nskb;
++		nskb = skb_copy_expand(skb, skb_headroom(skb), 0,
++			GFP_ATOMIC | __GFP_NOWARN);
++		if (nskb) {
++			__kfree_skb(skb);
++			skb = nskb;
++		}
++	}
++	return skb;
++}
++
+ /**
+  *	skb_orphan - orphan a buffer
+  *	@skb: buffer to orphan
diff --git a/target/linux/generic/patches-3.10/657-qdisc_reduce_truesize.patch b/target/linux/generic/patches-3.10/657-qdisc_reduce_truesize.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/657-qdisc_reduce_truesize.patch
@@ -0,0 +1,63 @@
+From bc9fec2f87d57bdbff30d296605e24504513f65c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Dave=20T=C3=A4ht?= <dave.taht@bufferbloat.net>
+Date: Mon, 17 Sep 2012 19:20:22 -0700
+Subject: [PATCH 4/7] net: add skb_reduce_truesize support to common qdiscs
+
+Reduce skb size under load when queues begin to fill on the
+commont qdiscs.
+---
+ net/sched/sch_codel.c    |    2 ++
+ net/sched/sch_fifo.c     |   12 ++++++++----
+ net/sched/sch_fq_codel.c |    2 ++
+ 3 files changed, 12 insertions(+), 4 deletions(-)
+
+--- a/net/sched/sch_codel.c
++++ b/net/sched/sch_codel.c
+@@ -96,6 +96,8 @@ static int codel_qdisc_enqueue(struct sk
+ 	struct codel_sched_data *q;
+ 
+ 	if (likely(qdisc_qlen(sch) < sch->limit)) {
++		if(qdisc_qlen(sch) > 128)
++			skb = skb_reduce_truesize(skb);
+ 		codel_set_enqueue_time(skb);
+ 		return qdisc_enqueue_tail(skb, sch);
+ 	}
+--- a/net/sched/sch_fifo.c
++++ b/net/sched/sch_fifo.c
+@@ -29,17 +29,21 @@ static int bfifo_enqueue(struct sk_buff
+ 
+ static int pfifo_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+ {
+-	if (likely(skb_queue_len(&sch->q) < sch->limit))
++	if (likely(skb_queue_len(&sch->q) < sch->limit)) {
++		if (skb_queue_len(&sch->q) > 128)
++			skb = skb_reduce_truesize(skb);
+ 		return qdisc_enqueue_tail(skb, sch);
+-
++	}
+ 	return qdisc_reshape_fail(skb, sch);
+ }
+ 
+ static int pfifo_tail_enqueue(struct sk_buff *skb, struct Qdisc *sch)
+ {
+-	if (likely(skb_queue_len(&sch->q) < sch->limit))
++	if (likely(skb_queue_len(&sch->q) < sch->limit)) {
++		if (skb_queue_len(&sch->q) > 128)
++			skb = skb_reduce_truesize(skb);
+ 		return qdisc_enqueue_tail(skb, sch);
+-
++	}
+ 	/* queue full, remove one skb to fulfill the limit */
+ 	__qdisc_queue_drop_head(sch, &sch->q);
+ 	sch->qstats.drops++;
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -182,6 +182,8 @@ static int fq_codel_enqueue(struct sk_bu
+ 		return ret;
+ 	}
+ 	idx--;
++	if (sch->q.qlen > 128)
++		skb = skb_reduce_truesize(skb);
+ 
+ 	codel_set_enqueue_time(skb);
+ 	flow = &q->flows[idx];
diff --git a/target/linux/generic/patches-3.10/660-fq_codel_defaults.patch b/target/linux/generic/patches-3.10/660-fq_codel_defaults.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/660-fq_codel_defaults.patch
@@ -0,0 +1,14 @@
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -389,9 +389,9 @@ static int fq_codel_init(struct Qdisc *s
+ 	struct fq_codel_sched_data *q = qdisc_priv(sch);
+ 	int i;
+ 
+-	sch->limit = 10*1024;
++	sch->limit = 1024;
+ 	q->flows_cnt = 1024;
+-	q->quantum = psched_mtu(qdisc_dev(sch));
++	q->quantum = 300;
+ 	q->perturbation = net_random();
+ 	INIT_LIST_HEAD(&q->new_flows);
+ 	INIT_LIST_HEAD(&q->old_flows);
diff --git a/target/linux/generic/patches-3.10/661-fq_codel_keep_dropped_stats.patch b/target/linux/generic/patches-3.10/661-fq_codel_keep_dropped_stats.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/661-fq_codel_keep_dropped_stats.patch
@@ -0,0 +1,10 @@
+--- a/net/sched/sch_fq_codel.c
++++ b/net/sched/sch_fq_codel.c
+@@ -195,7 +195,6 @@ static int fq_codel_enqueue(struct sk_bu
+ 		list_add_tail(&flow->flowchain, &q->new_flows);
+ 		q->new_flow_count++;
+ 		flow->deficit = q->quantum;
+-		flow->dropped = 0;
+ 	}
+ 	if (++sch->q.qlen <= sch->limit)
+ 		return NET_XMIT_SUCCESS;
diff --git a/target/linux/generic/patches-3.10/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch b/target/linux/generic/patches-3.10/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
@@ -0,0 +1,232 @@
+--- a/include/net/netns/ipv6.h
++++ b/include/net/netns/ipv6.h
+@@ -55,6 +55,7 @@ struct netns_ipv6 {
+ 	unsigned long		 ip6_rt_last_gc;
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
+ 	struct rt6_info         *ip6_prohibit_entry;
++	struct rt6_info		*ip6_failed_policy_entry;
+ 	struct rt6_info         *ip6_blk_hole_entry;
+ 	struct fib6_table       *fib6_local_tbl;
+ 	struct fib_rules_ops    *fib6_rules_ops;
+--- a/include/uapi/linux/fib_rules.h
++++ b/include/uapi/linux/fib_rules.h
+@@ -64,6 +64,10 @@ enum {
+ 	FR_ACT_BLACKHOLE,	/* Drop without notification */
+ 	FR_ACT_UNREACHABLE,	/* Drop with ENETUNREACH */
+ 	FR_ACT_PROHIBIT,	/* Drop with EACCES */
++	FR_ACT_RES9,
++	FR_ACT_RES10,
++	FR_ACT_RES11,
++	FR_ACT_FAILED_POLICY,	/* Drop with EPERM */
+ 	__FR_ACT_MAX,
+ };
+ 
+--- a/include/uapi/linux/rtnetlink.h
++++ b/include/uapi/linux/rtnetlink.h
+@@ -203,6 +203,7 @@ enum {
+ 	RTN_THROW,		/* Not in this table		*/
+ 	RTN_NAT,		/* Translate this address	*/
+ 	RTN_XRESOLVE,		/* Use external resolver	*/
++	RTN_FAILED_POLICY,	/* Failed ingress/egress policy */
+ 	__RTN_MAX
+ };
+ 
+--- a/net/ipv4/fib_rules.c
++++ b/net/ipv4/fib_rules.c
+@@ -88,6 +88,10 @@ static int fib4_rule_action(struct fib_r
+ 		err = -EACCES;
+ 		goto errout;
+ 
++	case FR_ACT_FAILED_POLICY:
++		err = -EPERM;
++		goto errout;
++
+ 	case FR_ACT_BLACKHOLE:
+ 	default:
+ 		err = -EINVAL;
+--- a/net/ipv4/fib_semantics.c
++++ b/net/ipv4/fib_semantics.c
+@@ -138,6 +138,10 @@ const struct fib_prop fib_props[RTN_MAX
+ 		.error	= -EINVAL,
+ 		.scope	= RT_SCOPE_NOWHERE,
+ 	},
++	[RTN_FAILED_POLICY] = {
++		.error	= -EPERM,
++		.scope	= RT_SCOPE_UNIVERSE,
++	},
+ };
+ 
+ static void rt_fibinfo_free(struct rtable __rcu **rtp)
+--- a/net/ipv4/fib_trie.c
++++ b/net/ipv4/fib_trie.c
+@@ -2331,6 +2331,7 @@ static const char *const rtn_type_names[
+ 	[RTN_THROW] = "THROW",
+ 	[RTN_NAT] = "NAT",
+ 	[RTN_XRESOLVE] = "XRESOLVE",
++	[RTN_FAILED_POLICY] = "FAILED_POLICY",
+ };
+ 
+ static inline const char *rtn_type(char *buf, size_t len, unsigned int t)
+--- a/net/ipv4/ipmr.c
++++ b/net/ipv4/ipmr.c
+@@ -184,6 +184,7 @@ static int ipmr_rule_action(struct fib_r
+ 	case FR_ACT_UNREACHABLE:
+ 		return -ENETUNREACH;
+ 	case FR_ACT_PROHIBIT:
++	case FR_ACT_FAILED_POLICY:
+ 		return -EACCES;
+ 	case FR_ACT_BLACKHOLE:
+ 	default:
+--- a/net/ipv6/fib6_rules.c
++++ b/net/ipv6/fib6_rules.c
+@@ -69,6 +69,9 @@ static int fib6_rule_action(struct fib_r
+ 	case FR_ACT_PROHIBIT:
+ 		rt = net->ipv6.ip6_prohibit_entry;
+ 		goto discard_pkt;
++	case FR_ACT_FAILED_POLICY:
++		rt = net->ipv6.ip6_failed_policy_entry;
++		goto discard_pkt;
+ 	}
+ 
+ 	table = fib6_get_table(net, rule->table);
+--- a/net/ipv6/ip6mr.c
++++ b/net/ipv6/ip6mr.c
+@@ -169,6 +169,8 @@ static int ip6mr_rule_action(struct fib_
+ 		return -ENETUNREACH;
+ 	case FR_ACT_PROHIBIT:
+ 		return -EACCES;
++	case FR_ACT_FAILED_POLICY:
++		return -EPERM;
+ 	case FR_ACT_BLACKHOLE:
+ 	default:
+ 		return -EINVAL;
+--- a/net/ipv6/route.c
++++ b/net/ipv6/route.c
+@@ -250,6 +250,24 @@ static const struct rt6_info ip6_prohibi
+ 	.rt6i_ref	= ATOMIC_INIT(1),
+ };
+ 
++static int ip6_pkt_failed_policy(struct sk_buff *skb);
++static int ip6_pkt_failed_policy_out(struct sk_buff *skb);
++
++static const struct rt6_info ip6_failed_policy_entry_template = {
++	.dst = {
++		.__refcnt	= ATOMIC_INIT(1),
++		.__use		= 1,
++		.obsolete	= DST_OBSOLETE_FORCE_CHK,
++		.error		= -EPERM,
++		.input		= ip6_pkt_failed_policy,
++		.output		= ip6_pkt_failed_policy_out,
++	},
++	.rt6i_flags	= (RTF_REJECT | RTF_NONEXTHOP),
++	.rt6i_protocol	= RTPROT_KERNEL,
++	.rt6i_metric	= ~(u32) 0,
++	.rt6i_ref	= ATOMIC_INIT(1),
++};
++
+ static const struct rt6_info ip6_blk_hole_entry_template = {
+ 	.dst = {
+ 		.__refcnt	= ATOMIC_INIT(1),
+@@ -1505,6 +1523,9 @@ int ip6_route_add(struct fib6_config *cf
+ 			rt->dst.output = ip6_pkt_prohibit_out;
+ 			rt->dst.input = ip6_pkt_prohibit;
+ 			break;
++		case RTN_FAILED_POLICY:
++			rt->dst.error = -EPERM;
++			break;
+ 		case RTN_THROW:
+ 		default:
+ 			rt->dst.error = (cfg->fc_type == RTN_THROW) ? -EAGAIN
+@@ -2084,6 +2105,18 @@ static int ip6_pkt_prohibit_out(struct s
+ 	return ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_OUTNOROUTES);
+ }
+ 
++static int ip6_pkt_failed_policy(struct sk_buff *skb)
++{
++	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_INNOROUTES);
++}
++
++static int ip6_pkt_failed_policy_out(struct sk_buff *skb)
++{
++	skb->dev = skb_dst(skb)->dev;
++	return ip6_pkt_drop(skb, ICMPV6_POLICY_FAIL, IPSTATS_MIB_OUTNOROUTES);
++}
++
++
+ /*
+  *	Allocate a dst for local (unicast / anycast) address.
+  */
+@@ -2286,7 +2319,8 @@ static int rtm_to_fib6_config(struct sk_
+ 	if (rtm->rtm_type == RTN_UNREACHABLE ||
+ 	    rtm->rtm_type == RTN_BLACKHOLE ||
+ 	    rtm->rtm_type == RTN_PROHIBIT ||
+-	    rtm->rtm_type == RTN_THROW)
++	    rtm->rtm_type == RTN_THROW ||
++	    rtm->rtm_type == RTN_FAILED_POLICY)
+ 		cfg->fc_flags |= RTF_REJECT;
+ 
+ 	if (rtm->rtm_type == RTN_LOCAL)
+@@ -2488,6 +2522,9 @@ static int rt6_fill_node(struct net *net
+ 		case -EACCES:
+ 			rtm->rtm_type = RTN_PROHIBIT;
+ 			break;
++		case -EPERM:
++			rtm->rtm_type = RTN_FAILED_POLICY;
++			break;
+ 		case -EAGAIN:
+ 			rtm->rtm_type = RTN_THROW;
+ 			break;
+@@ -2738,6 +2775,8 @@ static int ip6_route_dev_notify(struct n
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
+ 		net->ipv6.ip6_prohibit_entry->dst.dev = dev;
+ 		net->ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(dev);
++		net->ipv6.ip6_failed_policy_entry->dst.dev = dev;
++		net->ipv6.ip6_failed_policy_entry->rt6i_idev = in6_dev_get(dev);
+ 		net->ipv6.ip6_blk_hole_entry->dst.dev = dev;
+ 		net->ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(dev);
+ #endif
+@@ -2998,6 +3037,17 @@ static int __net_init ip6_route_net_init
+ 	net->ipv6.ip6_blk_hole_entry->dst.ops = &net->ipv6.ip6_dst_ops;
+ 	dst_init_metrics(&net->ipv6.ip6_blk_hole_entry->dst,
+ 			 ip6_template_metrics, true);
++
++	net->ipv6.ip6_failed_policy_entry =
++		kmemdup(&ip6_failed_policy_entry_template,
++			sizeof(*net->ipv6.ip6_failed_policy_entry), GFP_KERNEL);
++	if (!net->ipv6.ip6_failed_policy_entry)
++		goto out_ip6_blk_hole_entry;
++	net->ipv6.ip6_failed_policy_entry->dst.path =
++		(struct dst_entry *)net->ipv6.ip6_failed_policy_entry;
++	net->ipv6.ip6_failed_policy_entry->dst.ops = &net->ipv6.ip6_dst_ops;
++	dst_init_metrics(&net->ipv6.ip6_failed_policy_entry->dst,
++			 ip6_template_metrics, true);
+ #endif
+ 
+ 	net->ipv6.sysctl.flush_delay = 0;
+@@ -3016,6 +3066,8 @@ out:
+ 	return ret;
+ 
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
++out_ip6_blk_hole_entry:
++	kfree(net->ipv6.ip6_blk_hole_entry);
+ out_ip6_prohibit_entry:
+ 	kfree(net->ipv6.ip6_prohibit_entry);
+ out_ip6_null_entry:
+@@ -3033,6 +3085,7 @@ static void __net_exit ip6_route_net_exi
+ #ifdef CONFIG_IPV6_MULTIPLE_TABLES
+ 	kfree(net->ipv6.ip6_prohibit_entry);
+ 	kfree(net->ipv6.ip6_blk_hole_entry);
++	kfree(net->ipv6.ip6_failed_policy_entry);
+ #endif
+ 	dst_entries_destroy(&net->ipv6.ip6_dst_ops);
+ }
+@@ -3129,6 +3182,9 @@ int __init ip6_route_init(void)
+ 	init_net.ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
+ 	init_net.ipv6.ip6_blk_hole_entry->dst.dev = init_net.loopback_dev;
+ 	init_net.ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
++	init_net.ipv6.ip6_failed_policy_entry->dst.dev = init_net.loopback_dev;
++	init_net.ipv6.ip6_failed_policy_entry->rt6i_idev =
++		in6_dev_get(init_net.loopback_dev);
+   #endif
+ 	ret = fib6_init();
+ 	if (ret)
diff --git a/target/linux/generic/patches-3.10/700-swconfig.patch b/target/linux/generic/patches-3.10/700-swconfig.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/700-swconfig.patch
@@ -0,0 +1,39 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -12,6 +12,16 @@ menuconfig PHYLIB
+ 
+ if PHYLIB
+ 
++config SWCONFIG
++	tristate "Switch configuration API"
++	---help---
++	  Switch configuration API using netlink. This allows
++	  you to configure the VLAN features of certain switches.
++
++config SWCONFIG_LEDS
++	bool "Switch LED trigger support"
++	depends on (SWCONFIG && LEDS_TRIGGERS)
++
+ comment "MII PHY device drivers"
+ 
+ config AT803X_PHY
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -3,6 +3,7 @@
+ libphy-objs			:= phy.o phy_device.o mdio_bus.o
+ 
+ obj-$(CONFIG_PHYLIB)		+= libphy.o
++obj-$(CONFIG_SWCONFIG)		+= swconfig.o
+ obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
+ obj-$(CONFIG_DAVICOM_PHY)	+= davicom.o
+ obj-$(CONFIG_CICADA_PHY)	+= cicada.o
+--- a/include/uapi/linux/Kbuild
++++ b/include/uapi/linux/Kbuild
+@@ -361,6 +361,7 @@ header-y += stddef.h
+ header-y += string.h
+ header-y += suspend_ioctls.h
+ header-y += swab.h
++header-y += switch.h
+ header-y += synclink.h
+ header-y += sysctl.h
+ header-y += sysinfo.h
diff --git a/target/linux/generic/patches-3.10/701-phy_extension.patch b/target/linux/generic/patches-3.10/701-phy_extension.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/701-phy_extension.patch
@@ -0,0 +1,63 @@
+--- a/drivers/net/phy/phy.c
++++ b/drivers/net/phy/phy.c
+@@ -301,6 +301,50 @@ int phy_ethtool_gset(struct phy_device *
+ }
+ EXPORT_SYMBOL(phy_ethtool_gset);
+ 
++int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr)
++{
++	u32 cmd;
++	int tmp;
++	struct ethtool_cmd ecmd = { ETHTOOL_GSET };
++	struct ethtool_value edata = { ETHTOOL_GLINK };
++
++	if (get_user(cmd, (u32 *) useraddr))
++		return -EFAULT;
++
++	switch (cmd) {
++	case ETHTOOL_GSET:
++		phy_ethtool_gset(phydev, &ecmd);
++		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
++			return -EFAULT;
++		return 0;
++
++	case ETHTOOL_SSET:
++		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
++			return -EFAULT;
++		return phy_ethtool_sset(phydev, &ecmd);
++
++	case ETHTOOL_NWAY_RST:
++		/* if autoneg is off, it's an error */
++		tmp = phy_read(phydev, MII_BMCR);
++		if (tmp & BMCR_ANENABLE) {
++			tmp |= (BMCR_ANRESTART);
++			phy_write(phydev, MII_BMCR, tmp);
++			return 0;
++		}
++		return -EINVAL;
++
++	case ETHTOOL_GLINK:
++		edata.data = (phy_read(phydev,
++				MII_BMSR) & BMSR_LSTATUS) ? 1 : 0;
++		if (copy_to_user(useraddr, &edata, sizeof(edata)))
++			return -EFAULT;
++		return 0;
++	}
++
++	return -EOPNOTSUPP;
++}
++EXPORT_SYMBOL(phy_ethtool_ioctl);
++
+ /**
+  * phy_mii_ioctl - generic PHY MII ioctl interface
+  * @phydev: the phy_device struct
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -550,6 +550,7 @@ void phy_start_machine(struct phy_device
+ void phy_stop_machine(struct phy_device *phydev);
+ int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
+ int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
++int phy_ethtool_ioctl(struct phy_device *phydev, void *useraddr);
+ int phy_mii_ioctl(struct phy_device *phydev,
+ 		struct ifreq *ifr, int cmd);
+ int phy_start_interrupts(struct phy_device *phydev);
diff --git a/target/linux/generic/patches-3.10/702-phy_add_aneg_done_function.patch b/target/linux/generic/patches-3.10/702-phy_add_aneg_done_function.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/702-phy_add_aneg_done_function.patch
@@ -0,0 +1,45 @@
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -408,9 +408,18 @@ struct phy_driver {
+ 	 */
+ 	int (*config_aneg)(struct phy_device *phydev);
+ 
++	/* Determine if autonegotiation is done */
++	int (*aneg_done)(struct phy_device *phydev);
++
+ 	/* Determines the negotiated speed and duplex */
+ 	int (*read_status)(struct phy_device *phydev);
+ 
++	/* 
++	 * Update the value in phydev->link to reflect the 
++	 * current link value
++	 */
++	int (*update_link)(struct phy_device *phydev);
++
+ 	/* Clears any pending interrupts */
+ 	int (*ack_interrupt)(struct phy_device *phydev);
+ 
+--- a/drivers/net/phy/phy_device.c
++++ b/drivers/net/phy/phy_device.c
+@@ -795,6 +795,9 @@ int genphy_update_link(struct phy_device
+ {
+ 	int status;
+ 
++	if (phydev->drv->update_link)
++		return phydev->drv->update_link(phydev);
++
+ 	/* Do a fake read */
+ 	status = phy_read(phydev, MII_BMSR);
+ 
+--- a/drivers/net/phy/phy.c
++++ b/drivers/net/phy/phy.c
+@@ -108,6 +108,9 @@ static inline int phy_aneg_done(struct p
+ {
+ 	int retval;
+ 
++	if (phydev->drv->aneg_done)
++		return phydev->drv->aneg_done(phydev);
++
+ 	retval = phy_read(phydev, MII_BMSR);
+ 
+ 	return (retval < 0) ? retval : (retval & BMSR_ANEGCOMPLETE);
diff --git a/target/linux/generic/patches-3.10/703-phy-add-detach-callback-to-struct-phy_driver.patch b/target/linux/generic/patches-3.10/703-phy-add-detach-callback-to-struct-phy_driver.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/703-phy-add-detach-callback-to-struct-phy_driver.patch
@@ -0,0 +1,27 @@
+--- a/drivers/net/phy/phy_device.c
++++ b/drivers/net/phy/phy_device.c
+@@ -612,6 +612,9 @@ EXPORT_SYMBOL(phy_attach);
+  */
+ void phy_detach(struct phy_device *phydev)
+ {
++	if (phydev->drv && phydev->drv->detach)
++		phydev->drv->detach(phydev);
++
+ 	phydev->attached_dev->phydev = NULL;
+ 	phydev->attached_dev = NULL;
+ 
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -432,6 +432,12 @@ struct phy_driver {
+ 	 */
+ 	int (*did_interrupt)(struct phy_device *phydev);
+ 
++	/*
++	 * Called before an ethernet device is detached
++	 * from the PHY.
++	 */
++	void (*detach)(struct phy_device *phydev);
++
+ 	/* Clears up any memory if needed */
+ 	void (*remove)(struct phy_device *phydev);
+ 
diff --git a/target/linux/generic/patches-3.10/710-phy-add-mdio_register_board_info.patch b/target/linux/generic/patches-3.10/710-phy-add-mdio_register_board_info.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/710-phy-add-mdio_register_board_info.patch
@@ -0,0 +1,191 @@
+--- a/drivers/net/phy/mdio_bus.c
++++ b/drivers/net/phy/mdio_bus.c
+@@ -41,6 +41,8 @@
+ #include <asm/irq.h>
+ #include <asm/uaccess.h>
+ 
++#include "mdio-boardinfo.h"
++
+ /**
+  * mdiobus_alloc_size - allocate a mii_bus structure
+  * @size: extra amount of memory to allocate for private storage.
+@@ -229,15 +231,33 @@ void mdiobus_free(struct mii_bus *bus)
+ }
+ EXPORT_SYMBOL(mdiobus_free);
+ 
++static void mdiobus_setup_phydev_from_boardinfo(struct mii_bus *bus,
++						struct phy_device *phydev,
++						struct mdio_board_info *bi)
++{
++	if (strcmp(bus->id, bi->bus_id) ||
++	    bi->phy_addr != phydev->addr)
++	    return;
++
++	phydev->dev.platform_data = (void *) bi->platform_data;
++}
++
+ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)
+ {
+ 	struct phy_device *phydev;
++	struct mdio_board_entry *be;
+ 	int err;
+ 
+ 	phydev = get_phy_device(bus, addr, false);
+ 	if (IS_ERR(phydev) || phydev == NULL)
+ 		return phydev;
+ 
++	mutex_lock(&__mdio_board_lock);
++	list_for_each_entry(be, &__mdio_board_list, list)
++		mdiobus_setup_phydev_from_boardinfo(bus, phydev,
++						    &be->board_info);
++	mutex_unlock(&__mdio_board_lock);
++
+ 	err = phy_device_register(phydev);
+ 	if (err) {
+ 		phy_device_free(phydev);
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -591,4 +591,22 @@ int __init mdio_bus_init(void);
+ void mdio_bus_exit(void);
+ 
+ extern struct bus_type mdio_bus_type;
++
++struct mdio_board_info {
++	const char	*bus_id;
++	int		phy_addr;
++
++	const void	*platform_data;
++};
++
++#ifdef CONFIG_MDIO_BOARDINFO
++int mdiobus_register_board_info(const struct mdio_board_info *info, unsigned n);
++#else
++static inline int
++mdiobus_register_board_info(const struct mdio_board_info *info, unsigned n)
++{
++	return 0;
++}
++#endif
++
+ #endif /* __PHY_H */
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -12,6 +12,10 @@ menuconfig PHYLIB
+ 
+ if PHYLIB
+ 
++config MDIO_BOARDINFO
++	bool
++	default y
++
+ config SWCONFIG
+ 	tristate "Switch configuration API"
+ 	---help---
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -2,6 +2,8 @@
+ 
+ libphy-objs			:= phy.o phy_device.o mdio_bus.o
+ 
++obj-$(CONFIG_MDIO_BOARDINFO)	+= mdio-boardinfo.o
++
+ obj-$(CONFIG_PHYLIB)		+= libphy.o
+ obj-$(CONFIG_SWCONFIG)		+= swconfig.o
+ obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
+--- /dev/null
++++ b/drivers/net/phy/mdio-boardinfo.c
+@@ -0,0 +1,58 @@
++/*
++ * mdio-boardinfo.c - collect pre-declarations of PHY devices
++ *
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ *
++ */
++
++#include <linux/kernel.h>
++#include <linux/phy.h>
++#include <linux/slab.h>
++#include <linux/export.h>
++#include <linux/mutex.h>
++#include <linux/phy.h>
++
++#include "mdio-boardinfo.h"
++
++/*
++ * These symbols are exported ONLY FOR the mdio_bus component.
++ * No other users will be supported.
++ */
++
++LIST_HEAD(__mdio_board_list);
++EXPORT_SYMBOL_GPL(__mdio_board_list);
++
++DEFINE_MUTEX(__mdio_board_lock);
++EXPORT_SYMBOL_GPL(__mdio_board_lock);
++
++/**
++ * mdio_register_board_info - register PHY devices for a given board
++ * @info: array of chip descriptors
++ * @n: how many descriptors are provided
++ * Context: can sleep
++ *
++ * The board info passed can safely be __initdata ... but be careful of
++ * any embedded pointers (platform_data, etc), they're copied as-is.
++ */
++int __init
++mdiobus_register_board_info(struct mdio_board_info const *info, unsigned n)
++{
++	struct mdio_board_entry *be;
++	int i;
++
++	be = kzalloc(n * sizeof(*be), GFP_KERNEL);
++	if (!be)
++		return -ENOMEM;
++
++	for (i = 0; i < n; i++, be++, info++) {
++		memcpy(&be->board_info, info, sizeof(*info));
++		mutex_lock(&__mdio_board_lock);
++		list_add_tail(&be->list, &__mdio_board_list);
++		mutex_unlock(&__mdio_board_lock);
++	}
++
++	return 0;
++}
+--- /dev/null
++++ b/drivers/net/phy/mdio-boardinfo.h
+@@ -0,0 +1,22 @@
++/*
++ * mdio-boardinfo.h - boardinfo interface internal to the mdio_bus component
++ *
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ *
++ */
++
++#include <linux/mutex.h>
++
++struct mdio_board_entry {
++	struct list_head	list;
++	struct mdio_board_info	board_info;
++};
++
++/* __mdio_board_lock protects __mdio_board_list
++ * only mdio_bus components are allowed to use these symbols.
++ */
++extern struct mutex __mdio_board_lock;
++extern struct list_head __mdio_board_list;
+--- a/drivers/net/Makefile
++++ b/drivers/net/Makefile
+@@ -15,7 +15,7 @@ obj-$(CONFIG_MII) += mii.o
+ obj-$(CONFIG_MDIO) += mdio.o
+ obj-$(CONFIG_NET) += Space.o loopback.o
+ obj-$(CONFIG_NETCONSOLE) += netconsole.o
+-obj-$(CONFIG_PHYLIB) += phy/
++obj-y += phy/
+ obj-$(CONFIG_RIONET) += rionet.o
+ obj-$(CONFIG_NET_TEAM) += team/
+ obj-$(CONFIG_TUN) += tun.o
diff --git a/target/linux/generic/patches-3.10/720-phy_adm6996.patch b/target/linux/generic/patches-3.10/720-phy_adm6996.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/720-phy_adm6996.patch
@@ -0,0 +1,26 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -120,6 +120,13 @@ config MICREL_PHY
+ 	---help---
+ 	  Supports the KSZ9021, VSC8201, KS8001 PHYs.
+ 
++config ADM6996_PHY
++	tristate "Driver for ADM6996 switches"
++	select SWCONFIG
++	---help---
++	  Currently supports the ADM6996FC and ADM6996M switches.
++	  Support for FC is very limited.
++
+ config FIXED_PHY
+ 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB=y
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -17,6 +17,7 @@ obj-$(CONFIG_BROADCOM_PHY)	+= broadcom.o
+ obj-$(CONFIG_BCM63XX_PHY)	+= bcm63xx.o
+ obj-$(CONFIG_BCM87XX_PHY)	+= bcm87xx.o
+ obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
++obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
diff --git a/target/linux/generic/patches-3.10/721-phy_packets.patch b/target/linux/generic/patches-3.10/721-phy_packets.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/721-phy_packets.patch
@@ -0,0 +1,189 @@
+Index: kernel_tree/include/linux/netdevice.h
+===================================================================
+--- kernel_tree.orig/include/linux/netdevice.h
++++ kernel_tree/include/linux/netdevice.h
+@@ -1109,6 +1109,11 @@ struct net_device {
+ 	const struct net_device_ops *netdev_ops;
+ 	const struct ethtool_ops *ethtool_ops;
+ 
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	void (*eth_mangle_rx)(struct net_device *dev, struct sk_buff *skb);
++	struct sk_buff *(*eth_mangle_tx)(struct net_device *dev, struct sk_buff *skb);
++#endif
++
+ 	/* Hardware header description */
+ 	const struct header_ops *header_ops;
+ 
+@@ -1172,6 +1177,9 @@ struct net_device {
+ 	void			*ax25_ptr;	/* AX.25 specific data */
+ 	struct wireless_dev	*ieee80211_ptr;	/* IEEE 802.11 specific data,
+ 						   assign before registering */
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	void			*phy_ptr; /* PHY device specific data */
++#endif
+ 
+ /*
+  * Cache lines mostly used on receive path (including eth_type_trans())
+Index: kernel_tree/include/uapi/linux/if.h
+===================================================================
+--- kernel_tree.orig/include/uapi/linux/if.h
++++ kernel_tree/include/uapi/linux/if.h
+@@ -83,6 +83,7 @@
+ #define IFF_SUPP_NOFCS	0x80000		/* device supports sending custom FCS */
+ #define IFF_LIVE_ADDR_CHANGE 0x100000	/* device supports hardware address
+ 					 * change when it's running */
++#define IFF_NO_IP_ALIGN	0x200000	/* do not ip-align allocated rx pkts */
+ 
+ 
+ #define IF_GET_IFACE	0x0001		/* for querying only */
+Index: kernel_tree/include/linux/skbuff.h
+===================================================================
+--- kernel_tree.orig/include/linux/skbuff.h
++++ kernel_tree/include/linux/skbuff.h
+@@ -1879,6 +1879,10 @@ static inline int pskb_trim(struct sk_bu
+ 	return (len < skb->len) ? __pskb_trim(skb, len) : 0;
+ }
+ 
++extern struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
++		unsigned int length, gfp_t gfp);
++
++
+ /**
+  *	pskb_trim_unique - remove end from a paged unique (not cloned) buffer
+  *	@skb: buffer to alter
+@@ -2003,16 +2007,6 @@ static inline struct sk_buff *dev_alloc_
+ }
+ 
+ 
+-static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
+-		unsigned int length, gfp_t gfp)
+-{
+-	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
+-
+-	if (NET_IP_ALIGN && skb)
+-		skb_reserve(skb, NET_IP_ALIGN);
+-	return skb;
+-}
+-
+ static inline struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
+ 		unsigned int length)
+ {
+Index: kernel_tree/net/Kconfig
+===================================================================
+--- kernel_tree.orig/net/Kconfig
++++ kernel_tree/net/Kconfig
+@@ -23,6 +23,12 @@ menuconfig NET
+ 
+ if NET
+ 
++config ETHERNET_PACKET_MANGLE
++	bool
++	help
++	  This option can be selected by phy drivers that need to mangle
++	  packets going in or out of an ethernet device.
++
+ config WANT_COMPAT_NETLINK_MESSAGES
+ 	bool
+ 	help
+Index: kernel_tree/net/core/dev.c
+===================================================================
+--- kernel_tree.orig/net/core/dev.c
++++ kernel_tree/net/core/dev.c
+@@ -2581,9 +2581,19 @@ int dev_hard_start_xmit(struct sk_buff *
+ 		if (!list_empty(&ptype_all))
+ 			dev_queue_xmit_nit(skb, dev);
+ 
+-		skb_len = skb->len;
+-		rc = ops->ndo_start_xmit(skb, dev);
+-		trace_net_dev_xmit(skb, rc, dev, skb_len);
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++		if (!dev->eth_mangle_tx ||
++		    (skb = dev->eth_mangle_tx(dev, skb)) != NULL)
++#else
++		if (1)
++#endif
++		{
++			skb_len = skb->len;
++			rc = ops->ndo_start_xmit(skb, dev);
++			trace_net_dev_xmit(skb, rc, dev, skb_len);
++		} else {
++			rc = NETDEV_TX_OK;
++		}
+ 		if (rc == NETDEV_TX_OK)
+ 			txq_trans_update(txq);
+ 		return rc;
+@@ -2599,9 +2609,19 @@ gso:
+ 		if (!list_empty(&ptype_all))
+ 			dev_queue_xmit_nit(nskb, dev);
+ 
+-		skb_len = nskb->len;
+-		rc = ops->ndo_start_xmit(nskb, dev);
+-		trace_net_dev_xmit(nskb, rc, dev, skb_len);
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++		if (!dev->eth_mangle_tx ||
++		    (nskb = dev->eth_mangle_tx(dev, nskb)) != NULL)
++#else
++		if (1)
++#endif
++		{
++			skb_len = nskb->len;
++			rc = ops->ndo_start_xmit(nskb, dev);
++			trace_net_dev_xmit(nskb, rc, dev, skb_len);
++		} else {
++			rc = NETDEV_TX_OK;
++		}
+ 		if (unlikely(rc != NETDEV_TX_OK)) {
+ 			if (rc & ~NETDEV_TX_MASK)
+ 				goto out_kfree_gso_skb;
+Index: kernel_tree/net/core/skbuff.c
+===================================================================
+--- kernel_tree.orig/net/core/skbuff.c
++++ kernel_tree/net/core/skbuff.c
+@@ -62,6 +62,7 @@
+ #include <linux/scatterlist.h>
+ #include <linux/errqueue.h>
+ #include <linux/prefetch.h>
++#include <linux/if.h>
+ 
+ #include <net/protocol.h>
+ #include <net/dst.h>
+@@ -443,6 +444,22 @@ struct sk_buff *__netdev_alloc_skb(struc
+ }
+ EXPORT_SYMBOL(__netdev_alloc_skb);
+ 
++struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
++		unsigned int length, gfp_t gfp)
++{
++	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
++
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	if (dev && (dev->priv_flags & IFF_NO_IP_ALIGN))
++		return skb;
++#endif
++
++	if (NET_IP_ALIGN && skb)
++		skb_reserve(skb, NET_IP_ALIGN);
++	return skb;
++}
++EXPORT_SYMBOL(__netdev_alloc_skb_ip_align);
++
+ void skb_add_rx_frag(struct sk_buff *skb, int i, struct page *page, int off,
+ 		     int size, unsigned int truesize)
+ {
+Index: kernel_tree/net/ethernet/eth.c
+===================================================================
+--- kernel_tree.orig/net/ethernet/eth.c
++++ kernel_tree/net/ethernet/eth.c
+@@ -159,6 +159,12 @@ __be16 eth_type_trans(struct sk_buff *sk
+ 	struct ethhdr *eth;
+ 
+ 	skb->dev = dev;
++
++#ifdef CONFIG_ETHERNET_PACKET_MANGLE
++	if (dev->eth_mangle_rx)
++		dev->eth_mangle_rx(dev, skb);
++#endif
++
+ 	skb_reset_mac_header(skb);
+ 	skb_pull_inline(skb, ETH_HLEN);
+ 	eth = eth_hdr(skb);
diff --git a/target/linux/generic/patches-3.10/722-phy_mvswitch.patch b/target/linux/generic/patches-3.10/722-phy_mvswitch.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/722-phy_mvswitch.patch
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -127,6 +127,10 @@ config ADM6996_PHY
+ 	  Currently supports the ADM6996FC and ADM6996M switches.
+ 	  Support for FC is very limited.
+ 
++config MVSWITCH_PHY
++	tristate "Driver for Marvell 88E6060 switches"
++	select ETHERNET_PACKET_MANGLE
++
+ config FIXED_PHY
+ 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB=y
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -18,6 +18,7 @@ obj-$(CONFIG_BCM63XX_PHY)	+= bcm63xx.o
+ obj-$(CONFIG_BCM87XX_PHY)	+= bcm87xx.o
+ obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
+ obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
++obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
diff --git a/target/linux/generic/patches-3.10/723-phy_ip175c.patch b/target/linux/generic/patches-3.10/723-phy_ip175c.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/723-phy_ip175c.patch
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -131,6 +131,10 @@ config MVSWITCH_PHY
+ 	tristate "Driver for Marvell 88E6060 switches"
+ 	select ETHERNET_PACKET_MANGLE
+ 
++config IP17XX_PHY
++	tristate "Driver for IC+ IP17xx switches"
++	select SWCONFIG
++
+ config FIXED_PHY
+ 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB=y
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -19,6 +19,7 @@ obj-$(CONFIG_BCM87XX_PHY)	+= bcm87xx.o
+ obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
+ obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
+ obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
++obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
diff --git a/target/linux/generic/patches-3.10/724-phy_ar8216.patch b/target/linux/generic/patches-3.10/724-phy_ar8216.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/724-phy_ar8216.patch
@@ -0,0 +1,24 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -135,6 +135,11 @@ config IP17XX_PHY
+ 	tristate "Driver for IC+ IP17xx switches"
+ 	select SWCONFIG
+ 
++config AR8216_PHY
++	tristate "Driver for Atheros AR8216 switches"
++	select ETHERNET_PACKET_MANGLE
++	select SWCONFIG
++
+ config FIXED_PHY
+ 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB=y
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -21,6 +21,7 @@ obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
+ obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
+ obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
++obj-$(CONFIG_AR8216_PHY)	+= ar8216.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
diff --git a/target/linux/generic/patches-3.10/725-phy_rtl8306.patch b/target/linux/generic/patches-3.10/725-phy_rtl8306.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/725-phy_rtl8306.patch
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -140,6 +140,10 @@ config AR8216_PHY
+ 	select ETHERNET_PACKET_MANGLE
+ 	select SWCONFIG
+ 
++config RTL8306_PHY
++	tristate "Driver for Realtek RTL8306S switches"
++	select SWCONFIG
++
+ config FIXED_PHY
+ 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB=y
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -22,6 +22,7 @@ obj-$(CONFIG_MVSWITCH_PHY)	+= mvswitch.o
+ obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+ obj-$(CONFIG_AR8216_PHY)	+= ar8216.o
++obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
diff --git a/target/linux/generic/patches-3.10/726-phy_rtl8366.patch b/target/linux/generic/patches-3.10/726-phy_rtl8366.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/726-phy_rtl8366.patch
@@ -0,0 +1,45 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -214,6 +214,30 @@ config MDIO_BUS_MUX_MMIOREG
+ 
+ 	  Currently, only 8-bit registers are supported.
+ 
++config RTL8366_SMI
++	tristate "Driver for the RTL8366 SMI interface"
++	depends on GPIOLIB
++	---help---
++	  This module implements the SMI interface protocol which is used
++	  by some RTL8366 ethernet switch devices via the generic GPIO API.
++
++if RTL8366_SMI
++
++config RTL8366_SMI_DEBUG_FS
++	bool "RTL8366 SMI interface debugfs support"
++        depends on DEBUG_FS
++        default n
++
++config RTL8366S_PHY
++	tristate "Driver for the Realtek RTL8366S switch"
++	select SWCONFIG
++
++config RTL8366RB_PHY
++	tristate "Driver for the Realtek RTL8366RB switch"
++	select SWCONFIG
++
++endif # RTL8366_SMI
++
+ endif # PHYLIB
+ 
+ config MICREL_KS8995MA
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -23,6 +23,9 @@ obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
+ obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
+ obj-$(CONFIG_AR8216_PHY)	+= ar8216.o
+ obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
++obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi.o
++obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
++obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
diff --git a/target/linux/generic/patches-3.10/727-phy-rtl8367.patch b/target/linux/generic/patches-3.10/727-phy-rtl8367.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/727-phy-rtl8367.patch
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -236,6 +236,10 @@ config RTL8366RB_PHY
+ 	tristate "Driver for the Realtek RTL8366RB switch"
+ 	select SWCONFIG
+ 
++config RTL8367_PHY
++	tristate "Driver for the Realtek RTL8367R/M switches"
++	select SWCONFIG
++
+ endif # RTL8366_SMI
+ 
+ endif # PHYLIB
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -26,6 +26,7 @@ obj-$(CONFIG_RTL8306_PHY)	+= rtl8306.o
+ obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi.o
+ obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
+ obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
++obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
diff --git a/target/linux/generic/patches-3.10/728-phy-micrel.patch b/target/linux/generic/patches-3.10/728-phy-micrel.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/728-phy-micrel.patch
@@ -0,0 +1,24 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -144,6 +144,11 @@ config RTL8306_PHY
+ 	tristate "Driver for Realtek RTL8306S switches"
+ 	select SWCONFIG
+ 
++config MICREL_PHY
++	tristate "Drivers for Micrel/Kendin PHYs"
++	---help---
++	  Currently has a driver for the KSZ8041
++
+ config FIXED_PHY
+ 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
+ 	depends on PHYLIB=y
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -28,6 +28,7 @@ obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
+ obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
+ obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
++obj-$(CONFIG_MICREL_PHY)	+= micrel.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
+ obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
diff --git a/target/linux/generic/patches-3.10/729-phy-rtl8367b.patch b/target/linux/generic/patches-3.10/729-phy-rtl8367b.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/729-phy-rtl8367b.patch
@@ -0,0 +1,23 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -245,6 +245,10 @@ config RTL8367_PHY
+ 	tristate "Driver for the Realtek RTL8367R/M switches"
+ 	select SWCONFIG
+ 
++config RTL8367B_PHY
++	tristate "Driver fot the Realtek RTL8367R-VB switch"
++	select SWCONFIG
++
+ endif # RTL8366_SMI
+ 
+ endif # PHYLIB
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -27,6 +27,7 @@ obj-$(CONFIG_RTL8366_SMI)	+= rtl8366_smi
+ obj-$(CONFIG_RTL8366S_PHY)	+= rtl8366s.o
+ obj-$(CONFIG_RTL8366RB_PHY)	+= rtl8366rb.o
+ obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
++obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_MICREL_PHY)	+= micrel.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
diff --git a/target/linux/generic/patches-3.10/729-phy-tantos.patch b/target/linux/generic/patches-3.10/729-phy-tantos.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/729-phy-tantos.patch
@@ -0,0 +1,21 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -256,3 +256,8 @@ endif # PHYLIB
+ config MICREL_KS8995MA
+ 	tristate "Micrel KS8995MA 5-ports 10/100 managed Ethernet switch"
+ 	depends on SPI
++
++config PSB6970_PHY
++	tristate "Lantiq XWAY Tantos (PSB6970) Ethernet switch"
++	select SWCONFIG
++	select ETHERNET_PACKET_MANGLE
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -30,6 +30,7 @@ obj-$(CONFIG_RTL8367_PHY)	+= rtl8367.o
+ obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_MICREL_PHY)	+= micrel.o
++obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
+ obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
diff --git a/target/linux/generic/patches-3.10/730-phy_b53.patch b/target/linux/generic/patches-3.10/730-phy_b53.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/730-phy_b53.patch
@@ -0,0 +1,21 @@
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -251,6 +251,8 @@ config RTL8367B_PHY
+ 
+ endif # RTL8366_SMI
+ 
++source "drivers/net/phy/b53/Kconfig"
++
+ endif # PHYLIB
+ 
+ config MICREL_KS8995MA
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -31,6 +31,7 @@ obj-$(CONFIG_RTL8367B_PHY)	+= rtl8367b.o
+ obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
+ obj-$(CONFIG_MICREL_PHY)	+= micrel.o
+ obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
++obj-$(CONFIG_B53)		+= b53/
+ obj-$(CONFIG_FIXED_PHY)		+= fixed.o
+ obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
+ obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
diff --git a/target/linux/generic/patches-3.10/750-hostap_txpower.patch b/target/linux/generic/patches-3.10/750-hostap_txpower.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/750-hostap_txpower.patch
@@ -0,0 +1,154 @@
+--- a/drivers/net/wireless/hostap/hostap_ap.c
++++ b/drivers/net/wireless/hostap/hostap_ap.c
+@@ -2403,13 +2403,13 @@ int prism2_ap_get_sta_qual(local_info_t
+ 		addr[count].sa_family = ARPHRD_ETHER;
+ 		memcpy(addr[count].sa_data, sta->addr, ETH_ALEN);
+ 		if (sta->last_rx_silence == 0)
+-			qual[count].qual = sta->last_rx_signal < 27 ?
+-				0 : (sta->last_rx_signal - 27) * 92 / 127;
++                        qual[count].qual = (sta->last_rx_signal - 156) == 0 ?
++                                0 : (sta->last_rx_signal - 156) * 92 / 64;
+ 		else
+-			qual[count].qual = sta->last_rx_signal -
+-				sta->last_rx_silence - 35;
+-		qual[count].level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);
+-		qual[count].noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);
++                        qual[count].qual = (sta->last_rx_signal -
++                                sta->last_rx_silence) * 92 / 64;
++                qual[count].level = sta->last_rx_signal;
++                qual[count].noise = sta->last_rx_silence;
+ 		qual[count].updated = sta->last_rx_updated;
+ 
+ 		sta->last_rx_updated = IW_QUAL_DBM;
+@@ -2475,13 +2475,13 @@ int prism2_ap_translate_scan(struct net_
+ 		memset(&iwe, 0, sizeof(iwe));
+ 		iwe.cmd = IWEVQUAL;
+ 		if (sta->last_rx_silence == 0)
+-			iwe.u.qual.qual = sta->last_rx_signal < 27 ?
+-				0 : (sta->last_rx_signal - 27) * 92 / 127;
++	                iwe.u.qual.qual = (sta->last_rx_signal -156) == 0 ?
++	                        0 : (sta->last_rx_signal - 156) * 92 / 64;
+ 		else
+-			iwe.u.qual.qual = sta->last_rx_signal -
+-				sta->last_rx_silence - 35;
+-		iwe.u.qual.level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);
+-		iwe.u.qual.noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);
++                        iwe.u.qual.qual = (sta->last_rx_signal -
++                                sta->last_rx_silence) * 92 / 64;
++                iwe.u.qual.level = sta->last_rx_signal;
++                iwe.u.qual.noise = sta->last_rx_silence;
+ 		iwe.u.qual.updated = sta->last_rx_updated;
+ 		iwe.len = IW_EV_QUAL_LEN;
+ 		current_ev = iwe_stream_add_event(info, current_ev, end_buf,
+--- a/drivers/net/wireless/hostap/hostap_config.h
++++ b/drivers/net/wireless/hostap/hostap_config.h
+@@ -45,4 +45,9 @@
+  */
+ /* #define PRISM2_NO_STATION_MODES */
+ 
++/* Enable TX power Setting functions
++ * (min att = -128 , max att =  127)
++ */
++#define RAW_TXPOWER_SETTING
++
+ #endif /* HOSTAP_CONFIG_H */
+--- a/drivers/net/wireless/hostap/hostap.h
++++ b/drivers/net/wireless/hostap/hostap.h
+@@ -90,6 +90,7 @@ extern const struct iw_handler_def hosta
+ extern const struct ethtool_ops prism2_ethtool_ops;
+ 
+ int hostap_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
++int hostap_restore_power(struct net_device *dev);
+ 
+ 
+ #endif /* HOSTAP_H */
+--- a/drivers/net/wireless/hostap/hostap_hw.c
++++ b/drivers/net/wireless/hostap/hostap_hw.c
+@@ -928,6 +928,7 @@ static int hfa384x_set_rid(struct net_de
+ 			prism2_hw_reset(dev);
+ 	}
+ 
++	hostap_restore_power(dev);
+ 	return res;
+ }
+ 
+--- a/drivers/net/wireless/hostap/hostap_info.c
++++ b/drivers/net/wireless/hostap/hostap_info.c
+@@ -435,6 +435,11 @@ static void handle_info_queue_linkstatus
+ 	}
+ 
+ 	/* Get BSSID if we have a valid AP address */
++
++	if ( val == HFA384X_LINKSTATUS_CONNECTED ||
++	     val == HFA384X_LINKSTATUS_DISCONNECTED )
++			hostap_restore_power(local->dev);
++
+ 	if (connected) {
+ 		netif_carrier_on(local->dev);
+ 		netif_carrier_on(local->ddev);
+--- a/drivers/net/wireless/hostap/hostap_ioctl.c
++++ b/drivers/net/wireless/hostap/hostap_ioctl.c
+@@ -1479,23 +1479,20 @@ static int prism2_txpower_hfa386x_to_dBm
+ 		val = 255;
+ 
+ 	tmp = val;
+-	tmp >>= 2;
+ 
+-	return -12 - tmp;
++	return tmp;
+ }
+ 
+ static u16 prism2_txpower_dBm_to_hfa386x(int val)
+ {
+ 	signed char tmp;
+ 
+-	if (val > 20)
+-		return 128;
+-	else if (val < -43)
++	if (val > 127)
+ 		return 127;
++	else if (val < -128)
++		return 128;
+ 
+ 	tmp = val;
+-	tmp = -12 - tmp;
+-	tmp <<= 2;
+ 
+ 	return (unsigned char) tmp;
+ }
+@@ -4052,3 +4049,35 @@ int hostap_ioctl(struct net_device *dev,
+ 
+ 	return ret;
+ }
++
++/* BUG FIX: Restore power setting value when lost due to F/W bug */
++
++int hostap_restore_power(struct net_device *dev)
++{
++        struct hostap_interface *iface = netdev_priv(dev);
++       local_info_t *local = iface->local;
++
++       u16 val;
++       int ret = 0;
++
++       if (local->txpower_type == PRISM2_TXPOWER_OFF) {
++                       val = 0xff; /* use all standby and sleep modes */
++                       ret = local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,
++                                              HFA386X_CR_A_D_TEST_MODES2,
++                                              &val, NULL);
++       }
++
++#ifdef RAW_TXPOWER_SETTING
++       if (local->txpower_type == PRISM2_TXPOWER_FIXED) {
++               val = HFA384X_TEST_CFG_BIT_ALC;
++               local->func->cmd(dev, HFA384X_CMDCODE_TEST |
++                                (HFA384X_TEST_CFG_BITS << 8), 0, &val, NULL);
++               val = prism2_txpower_dBm_to_hfa386x(local->txpower);
++               ret = (local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,
++                            HFA386X_CR_MANUAL_TX_POWER, &val, NULL));
++       }
++#endif /* RAW_TXPOWER_SETTING */
++       return (ret ? -EOPNOTSUPP : 0);
++}
++
++EXPORT_SYMBOL(hostap_restore_power);
diff --git a/target/linux/generic/patches-3.10/810-pci_disable_common_quirks.patch b/target/linux/generic/patches-3.10/810-pci_disable_common_quirks.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/810-pci_disable_common_quirks.patch
@@ -0,0 +1,55 @@
+Index: kernel_tree/drivers/pci/Kconfig
+===================================================================
+--- kernel_tree.orig/drivers/pci/Kconfig
++++ kernel_tree/drivers/pci/Kconfig
+@@ -63,6 +63,12 @@ config XEN_PCIDEV_FRONTEND
+           The PCI device frontend driver allows the kernel to import arbitrary
+           PCI devices from a PCI backend to support PCI driver domains.
+ 
++config PCI_DISABLE_COMMON_QUIRKS
++	bool "PCI disable common quirks"
++	depends on PCI
++	help
++	  If you don't know what to do here, say N.
++
+ config HT_IRQ
+ 	bool "Interrupts on hypertransport devices"
+ 	default y
+Index: kernel_tree/drivers/pci/quirks.c
+===================================================================
+--- kernel_tree.orig/drivers/pci/quirks.c
++++ kernel_tree/drivers/pci/quirks.c
+@@ -45,6 +45,7 @@ static void quirk_mmio_always_on(struct
+ DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_ANY_ID, PCI_ANY_ID,
+ 				PCI_CLASS_BRIDGE_HOST, 8, quirk_mmio_always_on);
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
+ /* The Mellanox Tavor device gives false positive parity errors
+  * Mark this device with a broken_parity_status, to allow
+  * PCI scanning code to "skip" this now blacklisted device.
+@@ -2889,6 +2890,7 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65f9, quirk_intel_mc_errata);
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65fa, quirk_intel_mc_errata);
+ 
++#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
+ 
+ static ktime_t fixup_debug_start(struct pci_dev *dev,
+ 				 void (*fn)(struct pci_dev *dev))
+@@ -2920,6 +2922,8 @@ static void fixup_debug_report(struct pc
+ 	}
+ }
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
++
+ /*
+  * Some BIOS implementations leave the Intel GPU interrupts enabled,
+  * even though no one is handling them (f.e. i915 driver is never loaded).
+@@ -2955,6 +2959,8 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x010a, disable_igfx_irq);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0152, disable_igfx_irq);
+ 
++#endif /* !CONFIG_PCI_DISABLE_COMMON_QUIRKS */
++
+ /*
+  * Some devices may pass our check in pci_intx_mask_supported if
+  * PCI_COMMAND_INTX_DISABLE works though they actually do not properly
diff --git a/target/linux/generic/patches-3.10/811-pci_disable_usb_common_quirks.patch b/target/linux/generic/patches-3.10/811-pci_disable_usb_common_quirks.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/811-pci_disable_usb_common_quirks.patch
@@ -0,0 +1,80 @@
+
+--- a/drivers/usb/host/pci-quirks.c
++++ b/drivers/usb/host/pci-quirks.c
+@@ -79,6 +79,8 @@
+ #define USB_INTEL_USB3_PSSEN   0xD8
+ #define USB_INTEL_USB3PRM      0xDC
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
++
+ static struct amd_chipset_info {
+ 	struct pci_dev	*nb_dev;
+ 	struct pci_dev	*smbus_dev;
+@@ -353,6 +355,10 @@ void usb_amd_dev_put(void)
+ }
+ EXPORT_SYMBOL_GPL(usb_amd_dev_put);
+ 
++#endif /* CONFIG_PCI_DISABLE_COMMON_QUIRKS */
++
++#if IS_ENABLED(CONFIG_USB_UHCI_HCD)
++
+ /*
+  * Make sure the controller is completely inactive, unable to
+  * generate interrupts or do DMA.
+@@ -432,8 +438,17 @@ reset_needed:
+ 	uhci_reset_hc(pdev, base);
+ 	return 1;
+ }
++#else
++int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base)
++{
++	return 0;
++}
++
++#endif
+ EXPORT_SYMBOL_GPL(uhci_check_and_reset_hc);
+ 
++#ifndef CONFIG_PCI_DISABLE_COMMON_QUIRKS
++
+ static inline int io_type_enabled(struct pci_dev *pdev, unsigned int mask)
+ {
+ 	u16 cmd;
+@@ -974,3 +989,4 @@ static void quirk_usb_early_handoff(stru
+ }
+ DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_ANY_ID, PCI_ANY_ID,
+ 			PCI_CLASS_SERIAL_USB, 8, quirk_usb_early_handoff);
++#endif
+--- a/drivers/usb/host/pci-quirks.h
++++ b/drivers/usb/host/pci-quirks.h
+@@ -4,18 +4,26 @@
+ #ifdef CONFIG_PCI
+ void uhci_reset_hc(struct pci_dev *pdev, unsigned long base);
+ int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base);
++bool usb_is_intel_switchable_xhci(struct pci_dev *pdev);
++void usb_enable_xhci_ports(struct pci_dev *xhci_pdev);
++void usb_disable_xhci_ports(struct pci_dev *xhci_pdev);
++#else
++static inline void usb_disable_xhci_ports(struct pci_dev *xhci_pdev) {}
++#endif  /* CONFIG_PCI */
++
++#if defined(CONFIG_PCI) && !defined(CONFIG_PCI_DISABLE_COMMON_QUIRKS)
+ int usb_amd_find_chipset_info(void);
+ void usb_amd_dev_put(void);
+ void usb_amd_quirk_pll_disable(void);
+ void usb_amd_quirk_pll_enable(void);
+-bool usb_is_intel_switchable_xhci(struct pci_dev *pdev);
+-void usb_enable_xhci_ports(struct pci_dev *xhci_pdev);
+-void usb_disable_xhci_ports(struct pci_dev *xhci_pdev);
+ #else
++static inline int usb_amd_find_chipset_info(void)
++{
++	return 0;
++}
+ static inline void usb_amd_quirk_pll_disable(void) {}
+ static inline void usb_amd_quirk_pll_enable(void) {}
+ static inline void usb_amd_dev_put(void) {}
+-static inline void usb_disable_xhci_ports(struct pci_dev *xhci_pdev) {}
+-#endif  /* CONFIG_PCI */
++#endif
+ 
+ #endif  /*  __LINUX_USB_PCI_QUIRKS_H  */
diff --git a/target/linux/generic/patches-3.10/820-usb_add_usb_find_device_by_name.patch b/target/linux/generic/patches-3.10/820-usb_add_usb_find_device_by_name.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/820-usb_add_usb_find_device_by_name.patch
@@ -0,0 +1,88 @@
+Index: kernel_tree/drivers/usb/core/usb.c
+===================================================================
+--- kernel_tree.orig/drivers/usb/core/usb.c
++++ kernel_tree/drivers/usb/core/usb.c
+@@ -645,6 +645,71 @@ int __usb_get_extra_descriptor(char *buf
+ }
+ EXPORT_SYMBOL_GPL(__usb_get_extra_descriptor);
+ 
++static struct usb_device *match_device_name(struct usb_device *dev,
++					    const char *name)
++{
++	struct usb_device *ret_dev = NULL;
++	struct usb_device *childdev = NULL;
++	int child;
++
++	dev_dbg(&dev->dev, "check for name %s ...\n", name);
++
++	/* see if this device matches */
++	if (strcmp(dev_name(&dev->dev), name) == 0 ) {
++		dev_dbg(&dev->dev, "matched this device!\n");
++		ret_dev = usb_get_dev(dev);
++		goto exit;
++	}
++	/* look through all of the children of this device */
++	usb_hub_for_each_child(dev, child, childdev) {
++		if (childdev) {
++			usb_lock_device(childdev);
++			ret_dev = match_device_name(childdev, name);
++			usb_unlock_device(childdev);
++			if (ret_dev)
++				goto exit;
++		}
++	}
++exit:
++	return ret_dev;
++}
++
++/**
++ * usb_find_device_by_name - find a specific usb device in the system
++ * @name: the name of the device to find
++ *
++ * Returns a pointer to a struct usb_device if such a specified usb
++ * device is present in the system currently.  The usage count of the
++ * device will be incremented if a device is found.  Make sure to call
++ * usb_put_dev() when the caller is finished with the device.
++ *
++ * If a device with the specified bus id is not found, NULL is returned.
++ */
++struct usb_device *usb_find_device_by_name(const char *name)
++{
++	struct list_head *buslist;
++	struct usb_bus *bus;
++	struct usb_device *dev = NULL;
++
++	mutex_lock(&usb_bus_list_lock);
++	for (buslist = usb_bus_list.next;
++	     buslist != &usb_bus_list;
++	     buslist = buslist->next) {
++		bus = container_of(buslist, struct usb_bus, bus_list);
++		if (!bus->root_hub)
++			continue;
++		usb_lock_device(bus->root_hub);
++		dev = match_device_name(bus->root_hub, name);
++		usb_unlock_device(bus->root_hub);
++		if (dev)
++			goto exit;
++	}
++exit:
++	mutex_unlock(&usb_bus_list_lock);
++	return dev;
++}
++EXPORT_SYMBOL_GPL(usb_find_device_by_name);
++
+ /**
+  * usb_alloc_coherent - allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP
+  * @dev: device the buffer will be used with
+Index: kernel_tree/include/linux/usb.h
+===================================================================
+--- kernel_tree.orig/include/linux/usb.h
++++ kernel_tree/include/linux/usb.h
+@@ -701,6 +701,7 @@ static inline bool usb_device_supports_l
+ 	return udev->bos->ss_cap->bmAttributes & USB_LTM_SUPPORT;
+ }
+ 
++extern struct usb_device *usb_find_device_by_name(const char *name);
+ 
+ /*-------------------------------------------------------------------------*/
+ 
diff --git a/target/linux/generic/patches-3.10/830-ledtrig_morse.patch b/target/linux/generic/patches-3.10/830-ledtrig_morse.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/830-ledtrig_morse.patch
@@ -0,0 +1,28 @@
+--- a/drivers/leds/trigger/Kconfig
++++ b/drivers/leds/trigger/Kconfig
+@@ -108,4 +108,8 @@ config LEDS_TRIGGER_CAMERA
+ 	  This enables direct flash/torch on/off by the driver, kernel space.
+ 	  If unsure, say Y.
+ 
++config LEDS_TRIGGER_MORSE
++	tristate "LED Morse Trigger"
++	depends on LEDS_TRIGGERS
++
+ endif # LEDS_TRIGGERS
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -59,3 +59,4 @@ obj-$(CONFIG_LEDS_DAC124S085)		+= leds-d
+ 
+ # LED Triggers
+ obj-$(CONFIG_LEDS_TRIGGERS)		+= trigger/
++obj-$(CONFIG_LEDS_TRIGGER_MORSE)	+= ledtrig-morse.o
+--- a/drivers/leds/ledtrig-morse.c
++++ b/drivers/leds/ledtrig-morse.c
+@@ -26,7 +26,6 @@
+ #include <linux/list.h>
+ #include <linux/spinlock.h>
+ #include <linux/device.h>
+-#include <linux/sysdev.h>
+ #include <linux/timer.h>
+ #include <linux/ctype.h>
+ #include <linux/leds.h>
diff --git a/target/linux/generic/patches-3.10/831-ledtrig_netdev.patch b/target/linux/generic/patches-3.10/831-ledtrig_netdev.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/831-ledtrig_netdev.patch
@@ -0,0 +1,51 @@
+--- a/drivers/leds/trigger/Kconfig
++++ b/drivers/leds/trigger/Kconfig
+@@ -112,4 +112,11 @@ config LEDS_TRIGGER_MORSE
+ 	tristate "LED Morse Trigger"
+ 	depends on LEDS_TRIGGERS
+ 
++config LEDS_TRIGGER_NETDEV
++	tristate "LED Netdev Trigger"
++	depends on NET && LEDS_TRIGGERS
++	help
++	  This allows LEDs to be controlled by network device activity.
++	  If unsure, say Y.
++
+ endif # LEDS_TRIGGERS
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -60,3 +60,4 @@ obj-$(CONFIG_LEDS_DAC124S085)		+= leds-d
+ # LED Triggers
+ obj-$(CONFIG_LEDS_TRIGGERS)		+= trigger/
+ obj-$(CONFIG_LEDS_TRIGGER_MORSE)	+= ledtrig-morse.o
++obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= ledtrig-netdev.o
+--- a/drivers/leds/ledtrig-netdev.c
++++ b/drivers/leds/ledtrig-netdev.c
+@@ -22,7 +22,6 @@
+ #include <linux/list.h>
+ #include <linux/spinlock.h>
+ #include <linux/device.h>
+-#include <linux/sysdev.h>
+ #include <linux/netdevice.h>
+ #include <linux/timer.h>
+ #include <linux/ctype.h>
+@@ -307,8 +306,9 @@ done:
+ static void netdev_trig_timer(unsigned long arg)
+ {
+ 	struct led_netdev_data *trigger_data = (struct led_netdev_data *)arg;
+-	const struct net_device_stats *dev_stats;
++	struct rtnl_link_stats64 *dev_stats;
+ 	unsigned new_activity;
++	struct rtnl_link_stats64 temp;
+ 
+ 	write_lock(&trigger_data->lock);
+ 
+@@ -318,7 +318,7 @@ static void netdev_trig_timer(unsigned l
+ 		goto no_restart;
+ 	}
+ 
+-	dev_stats = dev_get_stats(trigger_data->net_dev);
++	dev_stats = dev_get_stats(trigger_data->net_dev, &temp);
+ 	new_activity =
+ 		((trigger_data->mode & MODE_TX) ? dev_stats->tx_packets : 0) +
+ 		((trigger_data->mode & MODE_RX) ? dev_stats->rx_packets : 0);
diff --git a/target/linux/generic/patches-3.10/832-ledtrig_usbdev.patch b/target/linux/generic/patches-3.10/832-ledtrig_usbdev.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/832-ledtrig_usbdev.patch
@@ -0,0 +1,31 @@
+--- a/drivers/leds/trigger/Kconfig
++++ b/drivers/leds/trigger/Kconfig
+@@ -119,4 +119,11 @@ config LEDS_TRIGGER_NETDEV
+ 	  This allows LEDs to be controlled by network device activity.
+ 	  If unsure, say Y.
+ 
++config LEDS_TRIGGER_USBDEV
++	tristate "LED USB device Trigger"
++	depends on USB && LEDS_TRIGGERS
++	help
++	  This allows LEDs to be controlled by the presence/activity of
++	  an USB device. If unsure, say N.
++
+ endif # LEDS_TRIGGERS
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -61,3 +61,4 @@ obj-$(CONFIG_LEDS_DAC124S085)		+= leds-d
+ obj-$(CONFIG_LEDS_TRIGGERS)		+= trigger/
+ obj-$(CONFIG_LEDS_TRIGGER_MORSE)	+= ledtrig-morse.o
+ obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= ledtrig-netdev.o
++obj-$(CONFIG_LEDS_TRIGGER_USBDEV)	+= ledtrig-usbdev.o
+--- a/drivers/leds/ledtrig-usbdev.c
++++ b/drivers/leds/ledtrig-usbdev.c
+@@ -24,7 +24,6 @@
+ #include <linux/list.h>
+ #include <linux/spinlock.h>
+ #include <linux/device.h>
+-#include <linux/sysdev.h>
+ #include <linux/timer.h>
+ #include <linux/ctype.h>
+ #include <linux/slab.h>
diff --git a/target/linux/generic/patches-3.10/840-rtc7301.patch b/target/linux/generic/patches-3.10/840-rtc7301.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/840-rtc7301.patch
@@ -0,0 +1,250 @@
+--- a/drivers/rtc/Kconfig
++++ b/drivers/rtc/Kconfig
+@@ -841,6 +841,15 @@ config RTC_DRV_NUC900
+ 	  If you say yes here you get support for the RTC subsystem of the
+ 	  NUC910/NUC920 used in embedded systems.
+ 
++config RTC_DRV_RTC7301
++	tristate "Epson RTC-7301 SF/DG"
++	help
++	  If you say Y here you will get support for the
++	  Epson RTC-7301 SF/DG RTC chips.
++
++	  This driver can also be built as a module. If so, the module
++	  will be called rtc-7301.
++
+ comment "on-CPU RTC drivers"
+ 
+ config RTC_DRV_DAVINCI
+--- a/drivers/rtc/Makefile
++++ b/drivers/rtc/Makefile
+@@ -100,6 +100,7 @@ obj-$(CONFIG_RTC_DRV_RP5C01)	+= rtc-rp5c
+ obj-$(CONFIG_RTC_DRV_RS5C313)	+= rtc-rs5c313.o
+ obj-$(CONFIG_RTC_DRV_RS5C348)	+= rtc-rs5c348.o
+ obj-$(CONFIG_RTC_DRV_RS5C372)	+= rtc-rs5c372.o
++obj-$(CONFIG_RTC_DRV_RTC7301)	+= rtc-rtc7301.o
+ obj-$(CONFIG_RTC_DRV_RV3029C2)	+= rtc-rv3029c2.o
+ obj-$(CONFIG_RTC_DRV_RX4581)	+= rtc-rx4581.o
+ obj-$(CONFIG_RTC_DRV_RX8025)	+= rtc-rx8025.o
+--- /dev/null
++++ b/drivers/rtc/rtc-rtc7301.c
+@@ -0,0 +1,219 @@
++/*
++ * Driver for Epson RTC-7301SF/DG
++ *
++ * Copyright (C) 2009 Jose Vasconcellos
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/module.h>
++#include <linux/rtc.h>
++#include <linux/platform_device.h>
++#include <linux/io.h>
++#include <linux/delay.h>
++#include <linux/bcd.h>
++
++#define RTC_NAME "rtc7301"
++#define RTC_VERSION "0.1"
++
++/* Epson RTC-7301 register addresses */
++#define RTC7301_SEC		0x00
++#define RTC7301_SEC10		0x01
++#define RTC7301_MIN		0x02
++#define RTC7301_MIN10		0x03
++#define RTC7301_HOUR		0x04
++#define RTC7301_HOUR10		0x05
++#define RTC7301_WEEKDAY		0x06
++#define RTC7301_DAY		0x07
++#define RTC7301_DAY10		0x08
++#define RTC7301_MON		0x09
++#define RTC7301_MON10		0x0A
++#define RTC7301_YEAR		0x0B
++#define RTC7301_YEAR10		0x0C
++#define RTC7301_YEAR100		0x0D
++#define RTC7301_YEAR1000	0x0E
++#define RTC7301_CTRLREG		0x0F
++
++static uint8_t __iomem *rtc7301_base;
++
++#define read_reg(offset) (readb(rtc7301_base + offset) & 0xf)
++#define write_reg(offset, data) writeb(data, rtc7301_base + (offset))
++
++#define rtc7301_isbusy() (read_reg(RTC7301_CTRLREG) & 1)
++
++static void rtc7301_init_settings(void)
++{
++	int i;
++
++	write_reg(RTC7301_CTRLREG, 2);
++	write_reg(RTC7301_YEAR1000, 2);
++	udelay(122);
++
++	/* bank 1 */
++	write_reg(RTC7301_CTRLREG, 6);
++	for (i=0; i<15; i++)
++		write_reg(i, 0);
++
++	/* bank 2 */
++	write_reg(RTC7301_CTRLREG, 14);
++	for (i=0; i<15; i++)
++		write_reg(i, 0);
++	write_reg(RTC7301_CTRLREG, 0);
++}
++
++static int rtc7301_get_datetime(struct device *dev, struct rtc_time *dt)
++{
++	int cnt;
++	uint8_t buf[16];
++
++	cnt = 0;
++	while (rtc7301_isbusy()) {
++		udelay(244);
++		if (cnt++ > 100) {
++			dev_err(dev, "%s: timeout error %x\n", __func__, rtc7301_base[RTC7301_CTRLREG]);
++			return -EIO;
++		}
++	}
++
++	for (cnt=0; cnt<16; cnt++)
++		buf[cnt] = read_reg(cnt);
++
++	if (buf[RTC7301_SEC10] & 8) {
++		dev_err(dev, "%s: RTC not set\n", __func__);
++		return -EINVAL;
++	}
++
++	memset(dt, 0, sizeof(*dt));
++
++	dt->tm_sec =  buf[RTC7301_SEC] + buf[RTC7301_SEC10]*10;
++	dt->tm_min =  buf[RTC7301_MIN] + buf[RTC7301_MIN10]*10;
++	dt->tm_hour = buf[RTC7301_HOUR] + buf[RTC7301_HOUR10]*10;
++
++	dt->tm_mday = buf[RTC7301_DAY] + buf[RTC7301_DAY10]*10;
++	dt->tm_mon =  buf[RTC7301_MON] + buf[RTC7301_MON10]*10 - 1;
++	dt->tm_year = buf[RTC7301_YEAR] + buf[RTC7301_YEAR10]*10 +
++		      buf[RTC7301_YEAR100]*100 +
++		      ((buf[RTC7301_YEAR1000] & 3)*1000) - 1900;
++
++	/* the rtc device may contain illegal values on power up
++	 * according to the data sheet. make sure they are valid.
++	 */
++
++	return rtc_valid_tm(dt);
++}
++
++static int rtc7301_set_datetime(struct device *dev, struct rtc_time *dt)
++{
++	int data;
++
++	data = dt->tm_year + 1900;
++	if (data >= 2100 || data < 1900)
++		return -EINVAL;
++
++	write_reg(RTC7301_CTRLREG, 2);
++       	udelay(122);
++
++	data = bin2bcd(dt->tm_sec);
++	write_reg(RTC7301_SEC, data);
++	write_reg(RTC7301_SEC10, (data >> 4));
++
++	data = bin2bcd(dt->tm_min);
++	write_reg(RTC7301_MIN, data );
++	write_reg(RTC7301_MIN10, (data >> 4));
++
++	data = bin2bcd(dt->tm_hour);
++	write_reg(RTC7301_HOUR, data);
++	write_reg(RTC7301_HOUR10, (data >> 4));
++
++	data = bin2bcd(dt->tm_mday);
++	write_reg(RTC7301_DAY, data);
++	write_reg(RTC7301_DAY10, (data>> 4));
++
++	data = bin2bcd(dt->tm_mon + 1);
++	write_reg(RTC7301_MON, data);
++	write_reg(RTC7301_MON10, (data >> 4));
++
++	data = bin2bcd(dt->tm_year % 100);
++	write_reg(RTC7301_YEAR, data);
++	write_reg(RTC7301_YEAR10, (data >> 4));
++	data = bin2bcd((1900 + dt->tm_year) / 100);
++	write_reg(RTC7301_YEAR100, data);
++
++	data = bin2bcd(dt->tm_wday);
++	write_reg(RTC7301_WEEKDAY, data);
++
++	write_reg(RTC7301_CTRLREG, 0);
++
++	return 0;
++}
++
++static const struct rtc_class_ops rtc7301_rtc_ops = {
++	.read_time	= rtc7301_get_datetime,
++	.set_time	= rtc7301_set_datetime,
++};
++
++static int rtc7301_probe(struct platform_device *pdev)
++{
++	struct rtc_device *rtc;
++	struct resource *res;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res)
++		return -ENOENT;
++
++	rtc7301_base = ioremap_nocache(res->start, 0x1000 /*res->end - res->start + 1*/);
++	if (!rtc7301_base)
++		return -EINVAL;
++
++	rtc = rtc_device_register(RTC_NAME, &pdev->dev,
++				&rtc7301_rtc_ops, THIS_MODULE);
++	if (IS_ERR(rtc)) {
++		iounmap(rtc7301_base);
++		return PTR_ERR(rtc);
++	}
++
++	platform_set_drvdata(pdev, rtc);
++
++	rtc7301_init_settings();
++	return 0;
++}
++
++static int rtc7301_remove(struct platform_device *pdev)
++{
++	struct rtc_device *rtc = platform_get_drvdata(pdev);
++
++	if (rtc)
++		rtc_device_unregister(rtc);
++	if (rtc7301_base)
++		iounmap(rtc7301_base);
++	return 0;
++}
++
++static struct platform_driver rtc7301_driver = {
++	.driver = {
++		.name	= RTC_NAME,
++		.owner	= THIS_MODULE,
++	},
++	.probe	= rtc7301_probe,
++	.remove = rtc7301_remove,
++};
++
++static __init int rtc7301_init(void)
++{
++	return platform_driver_register(&rtc7301_driver);
++}
++module_init(rtc7301_init);
++
++static __exit void rtc7301_exit(void)
++{
++	platform_driver_unregister(&rtc7301_driver);
++}
++module_exit(rtc7301_exit);
++
++MODULE_DESCRIPTION("Epson 7301 RTC driver");
++MODULE_AUTHOR("Jose Vasconcellos <jvasco@verizon.net>");
++MODULE_LICENSE("GPL");
++MODULE_ALIAS("platform:" RTC_NAME);
++MODULE_VERSION(RTC_VERSION);
diff --git a/target/linux/generic/patches-3.10/841-rtc_pt7c4338.patch b/target/linux/generic/patches-3.10/841-rtc_pt7c4338.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/841-rtc_pt7c4338.patch
@@ -0,0 +1,247 @@
+--- a/drivers/rtc/Kconfig
++++ b/drivers/rtc/Kconfig
+@@ -488,6 +488,15 @@ config RTC_DRV_RV3029C2
+ 	  This driver can also be built as a module. If so, the module
+ 	  will be called rtc-rv3029c2.
+ 
++config RTC_DRV_PT7C4338
++	tristate "Pericom Technology Inc. PT7C4338 RTC"
++	help
++	  If you say yes here you get support for the Pericom Technology
++	  Inc. PT7C4338 RTC chip.
++
++	  This driver can also be built as a module. If so, the module
++	  will be called rtc-pt7c4338.
++
+ endif # I2C
+ 
+ comment "SPI RTC drivers"
+--- a/drivers/rtc/Makefile
++++ b/drivers/rtc/Makefile
+@@ -92,6 +92,7 @@ obj-$(CONFIG_RTC_DRV_PL030)	+= rtc-pl030
+ obj-$(CONFIG_RTC_DRV_PL031)	+= rtc-pl031.o
+ obj-$(CONFIG_RTC_DRV_PM8XXX)	+= rtc-pm8xxx.o
+ obj-$(CONFIG_RTC_DRV_PS3)	+= rtc-ps3.o
++obj-$(CONFIG_RTC_DRV_PT7C4338)	+= rtc-pt7c4338.o
+ obj-$(CONFIG_RTC_DRV_PUV3)	+= rtc-puv3.o
+ obj-$(CONFIG_RTC_DRV_PXA)	+= rtc-pxa.o
+ obj-$(CONFIG_RTC_DRV_R9701)	+= rtc-r9701.o
+--- /dev/null
++++ b/drivers/rtc/rtc-pt7c4338.c
+@@ -0,0 +1,216 @@
++/*
++ * Copyright 2010 Freescale Semiconductor, Inc.
++ *
++ * Author:	Priyanka Jain <Priyanka.Jain@freescale.com>
++ *
++ * See file CREDITS for list of people who contributed to this
++ * project.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of
++ * the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
++ * MA 02111-1307 USA
++ */
++
++/*
++ * This file provides Date & Time support (no alarms) for PT7C4338 chip.
++ *
++ * This file is based on drivers/rtc/rtc-ds1307.c
++ *
++ * PT7C4338 chip is manufactured by Pericom Technology Inc.
++ * It is a serial real-time clock which provides
++ * 1)Low-power clock/calendar.
++ * 2)Programmable square-wave output.
++ * It has 56 bytes of nonvolatile RAM.
++ */
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/slab.h>
++#include <linux/i2c.h>
++#include <linux/rtc.h>
++#include <linux/bcd.h>
++
++/* RTC register addresses */
++#define PT7C4338_REG_SECONDS          0x00
++#define PT7C4338_REG_MINUTES          0x01
++#define PT7C4338_REG_HOURS            0x02
++#define PT7C4338_REG_AMPM             0x02
++#define PT7C4338_REG_DAY              0x03
++#define PT7C4338_REG_DATE             0x04
++#define PT7C4338_REG_MONTH            0x05
++#define PT7C4338_REG_YEAR             0x06
++#define PT7C4338_REG_CTRL_STAT        0x07
++
++/* RTC second register address bit */
++#define PT7C4338_SEC_BIT_CH           0x80	/*Clock Halt (in Register 0)*/
++
++/* RTC control and status register bits */
++#define PT7C4338_CTRL_STAT_BIT_RS0    0x1	/*Rate select 0*/
++#define PT7C4338_CTRL_STAT_BIT_RS1    0x2	/*Rate select 1*/
++#define PT7C4338_CTRL_STAT_BIT_SQWE   0x10	/*Square Wave Enable*/
++#define PT7C4338_CTRL_STAT_BIT_OSF    0x20	/*Oscillator Stop Flag*/
++#define PT7C4338_CTRL_STAT_BIT_OUT    0x80	/*Output Level Control*/
++
++static const struct i2c_device_id pt7c4338_id[] = {
++	{ "pt7c4338", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, pt7c4338_id);
++
++struct pt7c4338{
++	struct i2c_client *client;
++	struct rtc_device *rtc;
++};
++
++static int pt7c4338_read_time(struct device *dev, struct rtc_time *time)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	int ret;
++	u8 buf[7];
++	u8 year, month, day, hour, minute, second;
++	u8 week, twelve_hr, am_pm;
++
++	ret = i2c_smbus_read_i2c_block_data(client,
++			PT7C4338_REG_SECONDS, 7, buf);
++	if (ret < 0)
++		return ret;
++	if (ret < 7)
++		return -EIO;
++
++	second = buf[0];
++	minute = buf[1];
++	hour = buf[2];
++	week = buf[3];
++	day = buf[4];
++	month = buf[5];
++	year = buf[6];
++
++	/* Extract additional information for AM/PM */
++	twelve_hr = hour & 0x40;
++	am_pm = hour & 0x20;
++
++	/* Write to rtc_time structure */
++	time->tm_sec = bcd2bin(second & 0x7f);
++	time->tm_min = bcd2bin(minute & 0x7f);
++	if (twelve_hr) {
++		/* Convert to 24 hr */
++		if (am_pm)
++			time->tm_hour = bcd2bin(hour & 0x10) + 12;
++		else
++			time->tm_hour = bcd2bin(hour & 0xBF);
++	} else {
++		time->tm_hour = bcd2bin(hour);
++	}
++
++	time->tm_wday = bcd2bin(week & 0x07) - 1;
++	time->tm_mday = bcd2bin(day & 0x3f);
++	time->tm_mon = bcd2bin(month & 0x1F) - 1;
++	/* assume 20YY not 19YY */
++	time->tm_year = bcd2bin(year) + 100;
++
++	return 0;
++}
++
++static int pt7c4338_set_time(struct device *dev, struct rtc_time *time)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	u8 buf[7];
++
++	/* Extract time from rtc_time and load into pt7c4338*/
++	buf[0] = bin2bcd(time->tm_sec);
++	buf[1] = bin2bcd(time->tm_min);
++	buf[2] = bin2bcd(time->tm_hour);
++	buf[3] = bin2bcd(time->tm_wday + 1); /* Day of the week */
++	buf[4] = bin2bcd(time->tm_mday); /* Date */
++	buf[5] = bin2bcd(time->tm_mon + 1);
++
++	/* assume 20YY not 19YY */
++	if (time->tm_year >= 100)
++		buf[6] = bin2bcd(time->tm_year - 100);
++	else
++		buf[6] = bin2bcd(time->tm_year);
++
++	return i2c_smbus_write_i2c_block_data(client,
++					PT7C4338_REG_SECONDS, 7, buf);
++}
++
++static const struct rtc_class_ops pt7c4338_rtc_ops = {
++	.read_time = pt7c4338_read_time,
++	.set_time = pt7c4338_set_time,
++};
++
++static int pt7c4338_probe(struct i2c_client *client,
++		const struct i2c_device_id *id)
++{
++	struct pt7c4338 *pt7c4338;
++	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
++	int ret;
++
++	pt7c4338 = kzalloc(sizeof(struct pt7c4338), GFP_KERNEL);
++	if (!pt7c4338)
++		return -ENOMEM;
++
++	pt7c4338->client = client;
++	i2c_set_clientdata(client, pt7c4338);
++	pt7c4338->rtc = rtc_device_register(client->name, &client->dev,
++					&pt7c4338_rtc_ops, THIS_MODULE);
++	if (IS_ERR(pt7c4338->rtc)) {
++		ret = PTR_ERR(pt7c4338->rtc);
++		dev_err(&client->dev, "unable to register the class device\n");
++		goto out_free;
++	}
++
++	return 0;
++out_free:
++	i2c_set_clientdata(client, NULL);
++	kfree(pt7c4338);
++	return ret;
++}
++
++static int pt7c4338_remove(struct i2c_client *client)
++{
++	struct pt7c4338 *pt7c4338 = i2c_get_clientdata(client);
++
++	rtc_device_unregister(pt7c4338->rtc);
++	i2c_set_clientdata(client, NULL);
++	kfree(pt7c4338);
++	return 0;
++}
++
++static struct i2c_driver pt7c4338_driver = {
++	.driver = {
++		.name = "rtc-pt7c4338",
++		.owner = THIS_MODULE,
++	},
++	.probe = pt7c4338_probe,
++	.remove = pt7c4338_remove,
++	.id_table = pt7c4338_id,
++};
++
++static int __init pt7c4338_init(void)
++{
++	return i2c_add_driver(&pt7c4338_driver);
++}
++
++static void __exit pt7c4338_exit(void)
++{
++	i2c_del_driver(&pt7c4338_driver);
++}
++
++module_init(pt7c4338_init);
++module_exit(pt7c4338_exit);
++
++MODULE_AUTHOR("Priyanka Jain <Priyanka.Jain@freescale.com>");
++MODULE_DESCRIPTION("pericom Technology Inc. PT7C4338 RTC Driver");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/generic/patches-3.10/850-hwmon-add-tmp103.patch b/target/linux/generic/patches-3.10/850-hwmon-add-tmp103.patch
--- a/target/linux/generic/patches-3.10/850-hwmon-add-tmp103.patch
+++ b/target/linux/generic/patches-3.10/850-hwmon-add-tmp103.patch
@@ -2,15 +2,16 @@ add driver for Texas Instruments TMP103 
 
 Signed-off-by: Thomas Langer <thomas.langer@lantiq.com>
 
-diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
---- a/drivers/hwmon/Kconfig
-+++ b/drivers/hwmon/Kconfig
+Index: kernel_tree/drivers/hwmon/Kconfig
+===================================================================
+--- kernel_tree.orig/drivers/hwmon/Kconfig
++++ kernel_tree/drivers/hwmon/Kconfig
 @@ -1,3 +1,4 @@
 +
  #
  # Hardware monitoring chip drivers configuration
  #
-@@ -1275,6 +1276,16 @@ config SENSORS_TMP102
+@@ -1266,6 +1267,16 @@ config SENSORS_TMP102
  	  This driver can also be built as a module.  If so, the module
  	  will be called tmp102.
  
@@ -27,9 +28,10 @@ diff --git a/drivers/hwmon/Kconfig b/dri
  config SENSORS_TMP401
  	tristate "Texas Instruments TMP401 and compatibles"
  	depends on I2C
-diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
---- a/drivers/hwmon/Makefile
-+++ b/drivers/hwmon/Makefile
+Index: kernel_tree/drivers/hwmon/Makefile
+===================================================================
+--- kernel_tree.orig/drivers/hwmon/Makefile
++++ kernel_tree/drivers/hwmon/Makefile
 @@ -127,6 +127,7 @@ obj-$(CONFIG_SENSORS_SMSC47M192)+= smsc4
  obj-$(CONFIG_SENSORS_AMC6821)	+= amc6821.o
  obj-$(CONFIG_SENSORS_THMC50)	+= thmc50.o
@@ -38,10 +40,10 @@ diff --git a/drivers/hwmon/Makefile b/dr
  obj-$(CONFIG_SENSORS_TMP401)	+= tmp401.o
  obj-$(CONFIG_SENSORS_TMP421)	+= tmp421.o
  obj-$(CONFIG_SENSORS_TWL4030_MADC)+= twl4030-madc-hwmon.o
-diff --git a/drivers/hwmon/tmp103.c b/drivers/hwmon/tmp103.c
-new file mode 100644
+Index: kernel_tree/drivers/hwmon/tmp103.c
+===================================================================
 --- /dev/null
-+++ b/drivers/hwmon/tmp103.c
++++ kernel_tree/drivers/hwmon/tmp103.c
 @@ -0,0 +1,293 @@
 +/* Texas Instruments TMP103 SMBus temperature sensor driver
 + *
diff --git a/target/linux/generic/patches-3.10/861-04_spi_gpio_implement_spi_delay.patch b/target/linux/generic/patches-3.10/861-04_spi_gpio_implement_spi_delay.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/861-04_spi_gpio_implement_spi_delay.patch
@@ -0,0 +1,58 @@
+Implement the SPI-GPIO delay function for busses that need speed limitation.
+
+--mb
+
+
+
+--- a/drivers/spi/spi-gpio.c
++++ b/drivers/spi/spi-gpio.c
+@@ -22,6 +22,7 @@
+ #include <linux/init.h>
+ #include <linux/platform_device.h>
+ #include <linux/gpio.h>
++#include <linux/delay.h>
+ #include <linux/of_device.h>
+ #include <linux/of_gpio.h>
+ 
+@@ -73,6 +74,7 @@ struct spi_gpio {
+  *		#define	SPI_MOSI_GPIO	120
+  *		#define	SPI_SCK_GPIO	121
+  *		#define	SPI_N_CHIPSEL	4
++ *		#undef NEED_SPIDELAY
+  *		#include "spi-gpio.c"
+  */
+ 
+@@ -80,6 +82,7 @@ struct spi_gpio {
+ #define DRIVER_NAME	"spi_gpio"
+ 
+ #define GENERIC_BITBANG	/* vs tight inlines */
++#define NEED_SPIDELAY	1
+ 
+ /* all functions referencing these symbols must define pdata */
+ #define SPI_MISO_GPIO	((pdata)->miso)
+@@ -130,12 +133,20 @@ static inline int getmiso(const struct s
+ #undef pdata
+ 
+ /*
+- * NOTE:  this clocks "as fast as we can".  It "should" be a function of the
+- * requested device clock.  Software overhead means we usually have trouble
+- * reaching even one Mbit/sec (except when we can inline bitops), so for now
+- * we'll just assume we never need additional per-bit slowdowns.
++ * NOTE:  to clock "as fast as we can", set spi_device.max_speed_hz
++ * and spi_transfer.speed_hz to 0.
++ * Otherwise this is a function of the requested device clock.
++ * Software overhead means we usually have trouble
++ * reaching even one Mbit/sec (except when we can inline bitops). So on small
++ * embedded devices with fast SPI slaves you usually don't need a delay.
+  */
+-#define spidelay(nsecs)	do {} while (0)
++static inline void spidelay(unsigned nsecs)
++{
++#ifdef NEED_SPIDELAY
++	if (unlikely(nsecs))
++		ndelay(nsecs);
++#endif /* NEED_SPIDELAY */
++}
+ 
+ #include "spi-bitbang-txrx.h"
+ 
diff --git a/target/linux/generic/patches-3.10/862-gpio_spi_driver.patch b/target/linux/generic/patches-3.10/862-gpio_spi_driver.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/862-gpio_spi_driver.patch
@@ -0,0 +1,373 @@
+THIS CODE IS DEPRECATED.
+
+Please use the new mainline SPI-GPIO driver, as of 2.6.29.
+
+--mb
+
+
+
+---
+ drivers/spi/Kconfig              |    9 +
+ drivers/spi/Makefile             |    1 
+ drivers/spi/spi_gpio_old.c       |  251 +++++++++++++++++++++++++++++++++++++++
+ include/linux/spi/spi_gpio_old.h |   73 +++++++++++
+ 4 files changed, 334 insertions(+)
+
+--- /dev/null
++++ b/include/linux/spi/spi_gpio_old.h
+@@ -0,0 +1,73 @@
++/*
++ * spi_gpio interface to platform code
++ *
++ * Copyright (c) 2008 Piotr Skamruk
++ * Copyright (c) 2008 Michael Buesch
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++#ifndef _LINUX_SPI_SPI_GPIO
++#define _LINUX_SPI_SPI_GPIO
++
++#include <linux/types.h>
++#include <linux/spi/spi.h>
++
++
++/**
++ * struct spi_gpio_platform_data - Data definitions for a SPI-GPIO device.
++ *
++ * This structure holds information about a GPIO-based SPI device.
++ *
++ * @pin_clk: The GPIO pin number of the CLOCK pin.
++ *
++ * @pin_miso: The GPIO pin number of the MISO pin.
++ *
++ * @pin_mosi: The GPIO pin number of the MOSI pin.
++ *
++ * @pin_cs: The GPIO pin number of the CHIPSELECT pin.
++ *
++ * @cs_activelow: If true, the chip is selected when the CS line is low.
++ *
++ * @no_spi_delay: If true, no delay is done in the lowlevel bitbanging.
++ *                Note that doing no delay is not standards compliant,
++ *                but it might be needed to speed up transfers on some
++ *                slow embedded machines.
++ *
++ * @boardinfo_setup: This callback is called after the
++ *                   SPI master device was registered, but before the
++ *                   device is registered.
++ * @boardinfo_setup_data: Data argument passed to boardinfo_setup().
++ */
++struct spi_gpio_platform_data {
++	unsigned int pin_clk;
++	unsigned int pin_miso;
++	unsigned int pin_mosi;
++	unsigned int pin_cs;
++	bool cs_activelow;
++	bool no_spi_delay;
++	int (*boardinfo_setup)(struct spi_board_info *bi,
++			       struct spi_master *master,
++			       void *data);
++	void *boardinfo_setup_data;
++};
++
++/**
++ * SPI_GPIO_PLATDEV_NAME - The platform device name string.
++ *
++ * The name string that has to be used for platform_device_alloc
++ * when allocating a spi-gpio device.
++ */
++#define SPI_GPIO_PLATDEV_NAME	"spi-gpio"
++
++/**
++ * spi_gpio_next_id - Get another platform device ID number.
++ *
++ * This returns the next platform device ID number that has to be used
++ * for platform_device_alloc. The ID is opaque and should not be used for
++ * anything else.
++ */
++int spi_gpio_next_id(void);
++
++#endif /* _LINUX_SPI_SPI_GPIO */
+--- /dev/null
++++ b/drivers/spi/spi_gpio_old.c
+@@ -0,0 +1,251 @@
++/*
++ * Bitbanging SPI bus driver using GPIO API
++ *
++ * Copyright (c) 2008 Piotr Skamruk
++ * Copyright (c) 2008 Michael Buesch
++ *
++ * based on spi_s3c2410_gpio.c
++ *   Copyright (c) 2006 Ben Dooks
++ *   Copyright (c) 2006 Simtec Electronics
++ * and on i2c-gpio.c
++ *   Copyright (C) 2007 Atmel Corporation
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++#include <linux/spinlock.h>
++#include <linux/workqueue.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/spi/spi.h>
++#include <linux/spi/spi_bitbang.h>
++#include <linux/spi/spi_gpio_old.h>
++#include <linux/gpio.h>
++#include <asm/atomic.h>
++
++
++struct spi_gpio {
++	struct spi_bitbang bitbang;
++	struct spi_gpio_platform_data *info;
++	struct platform_device *pdev;
++	struct spi_board_info bi;
++};
++
++
++static inline struct spi_gpio *spidev_to_sg(struct spi_device *dev)
++{
++	return dev->controller_data;
++}
++
++static inline void setsck(struct spi_device *dev, int val)
++{
++	struct spi_gpio *sp = spidev_to_sg(dev);
++	gpio_set_value(sp->info->pin_clk, val ? 1 : 0);
++}
++
++static inline void setmosi(struct spi_device *dev, int val)
++{
++	struct spi_gpio *sp = spidev_to_sg(dev);
++	gpio_set_value(sp->info->pin_mosi, val ? 1 : 0);
++}
++
++static inline u32 getmiso(struct spi_device *dev)
++{
++	struct spi_gpio *sp = spidev_to_sg(dev);
++	return gpio_get_value(sp->info->pin_miso) ? 1 : 0;
++}
++
++static inline void do_spidelay(struct spi_device *dev, unsigned nsecs)
++{
++	struct spi_gpio *sp = spidev_to_sg(dev);
++
++	if (!sp->info->no_spi_delay)
++		ndelay(nsecs);
++}
++
++#define spidelay(nsecs) do {					\
++	/* Steal the spi_device pointer from our caller.	\
++	 * The bitbang-API should probably get fixed here... */	\
++	do_spidelay(spi, nsecs);				\
++  } while (0)
++
++#define EXPAND_BITBANG_TXRX
++#include "spi-bitbang-txrx.h"
++
++static u32 spi_gpio_txrx_mode0(struct spi_device *spi,
++			       unsigned nsecs, u32 word, u8 bits)
++{
++	return bitbang_txrx_be_cpha0(spi, nsecs, 0, 0, word, bits);
++}
++
++static u32 spi_gpio_txrx_mode1(struct spi_device *spi,
++			       unsigned nsecs, u32 word, u8 bits)
++{
++	return bitbang_txrx_be_cpha1(spi, nsecs, 0, 0, word, bits);
++}
++
++static u32 spi_gpio_txrx_mode2(struct spi_device *spi,
++			       unsigned nsecs, u32 word, u8 bits)
++{
++	return bitbang_txrx_be_cpha0(spi, nsecs, 1, 0, word, bits);
++}
++
++static u32 spi_gpio_txrx_mode3(struct spi_device *spi,
++			       unsigned nsecs, u32 word, u8 bits)
++{
++	return bitbang_txrx_be_cpha1(spi, nsecs, 1, 0, word, bits);
++}
++
++static void spi_gpio_chipselect(struct spi_device *dev, int on)
++{
++	struct spi_gpio *sp = spidev_to_sg(dev);
++
++	if (sp->info->cs_activelow)
++		on = !on;
++	gpio_set_value(sp->info->pin_cs, on ? 1 : 0);
++}
++
++static int spi_gpio_probe(struct platform_device *pdev)
++{
++	struct spi_master *master;
++	struct spi_gpio_platform_data *pdata;
++	struct spi_gpio *sp;
++	struct spi_device *spidev;
++	int err;
++
++	pdata = pdev->dev.platform_data;
++	if (!pdata)
++		return -ENXIO;
++
++	err = -ENOMEM;
++	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_gpio));
++	if (!master)
++		goto err_alloc_master;
++
++	sp = spi_master_get_devdata(master);
++	platform_set_drvdata(pdev, sp);
++	sp->info = pdata;
++
++	err = gpio_request(pdata->pin_clk, "spi_clock");
++	if (err)
++		goto err_request_clk;
++	err = gpio_request(pdata->pin_mosi, "spi_mosi");
++	if (err)
++		goto err_request_mosi;
++	err = gpio_request(pdata->pin_miso, "spi_miso");
++	if (err)
++		goto err_request_miso;
++	err = gpio_request(pdata->pin_cs, "spi_cs");
++	if (err)
++		goto err_request_cs;
++
++	sp->bitbang.master = spi_master_get(master);
++	sp->bitbang.master->bus_num = -1;
++	sp->bitbang.master->num_chipselect = 1;
++	sp->bitbang.chipselect = spi_gpio_chipselect;
++	sp->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_mode0;
++	sp->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_mode1;
++	sp->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_mode2;
++	sp->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_txrx_mode3;
++
++	gpio_direction_output(pdata->pin_clk, 0);
++	gpio_direction_output(pdata->pin_mosi, 0);
++	gpio_direction_output(pdata->pin_cs,
++			      pdata->cs_activelow ? 1 : 0);
++	gpio_direction_input(pdata->pin_miso);
++
++	err = spi_bitbang_start(&sp->bitbang);
++	if (err)
++		goto err_no_bitbang;
++	err = pdata->boardinfo_setup(&sp->bi, master,
++				     pdata->boardinfo_setup_data);
++	if (err)
++		goto err_bi_setup;
++	sp->bi.controller_data = sp;
++	spidev = spi_new_device(master, &sp->bi);
++	if (!spidev)
++		goto err_new_dev;
++
++	return 0;
++
++err_new_dev:
++err_bi_setup:
++	spi_bitbang_stop(&sp->bitbang);
++err_no_bitbang:
++	spi_master_put(sp->bitbang.master);
++	gpio_free(pdata->pin_cs);
++err_request_cs:
++	gpio_free(pdata->pin_miso);
++err_request_miso:
++	gpio_free(pdata->pin_mosi);
++err_request_mosi:
++	gpio_free(pdata->pin_clk);
++err_request_clk:
++	kfree(master);
++
++err_alloc_master:
++	return err;
++}
++
++static int spi_gpio_remove(struct platform_device *pdev)
++{
++	struct spi_gpio *sp;
++	struct spi_gpio_platform_data *pdata;
++
++	pdata = pdev->dev.platform_data;
++	sp = platform_get_drvdata(pdev);
++
++	gpio_free(pdata->pin_clk);
++	gpio_free(pdata->pin_mosi);
++	gpio_free(pdata->pin_miso);
++	gpio_free(pdata->pin_cs);
++	spi_bitbang_stop(&sp->bitbang);
++	spi_master_put(sp->bitbang.master);
++
++	return 0;
++}
++
++static struct platform_driver spi_gpio_driver = {
++	.driver		= {
++		.name	= SPI_GPIO_PLATDEV_NAME,
++		.owner	= THIS_MODULE,
++	},
++	.probe		= spi_gpio_probe,
++	.remove		= spi_gpio_remove,
++};
++
++int spi_gpio_next_id(void)
++{
++	static atomic_t counter = ATOMIC_INIT(-1);
++
++	return atomic_inc_return(&counter);
++}
++EXPORT_SYMBOL(spi_gpio_next_id);
++
++static int __init spi_gpio_init(void)
++{
++	int err;
++
++	err = platform_driver_register(&spi_gpio_driver);
++	if (err)
++		printk(KERN_ERR "spi-gpio: register failed: %d\n", err);
++
++	return err;
++}
++module_init(spi_gpio_init);
++
++static void __exit spi_gpio_exit(void)
++{
++	platform_driver_unregister(&spi_gpio_driver);
++}
++module_exit(spi_gpio_exit);
++
++MODULE_AUTHOR("Piot Skamruk <piotr.skamruk at gmail.com>");
++MODULE_AUTHOR("Michael Buesch");
++MODULE_DESCRIPTION("Platform independent GPIO bitbanging SPI driver");
++MODULE_LICENSE("GPL v2");
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -189,6 +189,15 @@ config SPI_GPIO
+ 	  GPIO operations, you should be able to leverage that for better
+ 	  speed with a custom version of this driver; see the source code.
+ 
++config SPI_GPIO_OLD
++	tristate "Old GPIO API based bitbanging SPI controller (DEPRECATED)"
++	depends on SPI_MASTER && GPIOLIB
++	select SPI_BITBANG
++	help
++	  This code is deprecated. Please use the new mainline SPI-GPIO driver.
++
++	  If unsure, say N.
++
+ config SPI_IMX
+ 	tristate "Freescale i.MX SPI controllers"
+ 	depends on ARCH_MXC
+--- a/drivers/spi/Makefile
++++ b/drivers/spi/Makefile
+@@ -34,6 +34,7 @@ obj-$(CONFIG_SPI_FSL_LIB)		+= spi-fsl-li
+ obj-$(CONFIG_SPI_FSL_ESPI)		+= spi-fsl-espi.o
+ obj-$(CONFIG_SPI_FSL_SPI)		+= spi-fsl-spi.o
+ obj-$(CONFIG_SPI_GPIO)			+= spi-gpio.o
++obj-$(CONFIG_SPI_GPIO_OLD)		+= spi_gpio_old.o
+ obj-$(CONFIG_SPI_IMX)			+= spi-imx.o
+ obj-$(CONFIG_SPI_LM70_LLP)		+= spi-lm70llp.o
+ obj-$(CONFIG_SPI_MPC512x_PSC)		+= spi-mpc512x-psc.o
diff --git a/target/linux/generic/patches-3.10/863-gpiommc.patch b/target/linux/generic/patches-3.10/863-gpiommc.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/863-gpiommc.patch
@@ -0,0 +1,844 @@
+--- /dev/null
++++ b/drivers/mmc/host/gpiommc.c
+@@ -0,0 +1,609 @@
++/*
++ * Driver an MMC/SD card on a bitbanging GPIO SPI bus.
++ * This module hooks up the mmc_spi and spi_gpio modules and also
++ * provides a configfs interface.
++ *
++ * Copyright 2008 Michael Buesch <mb@bu3sch.de>
++ *
++ * Licensed under the GNU/GPL. See COPYING for details.
++ */
++
++#include <linux/module.h>
++#include <linux/mmc/gpiommc.h>
++#include <linux/platform_device.h>
++#include <linux/list.h>
++#include <linux/mutex.h>
++#include <linux/spi/spi_gpio_old.h>
++#include <linux/configfs.h>
++#include <linux/gpio.h>
++#include <asm/atomic.h>
++
++
++#define PFX				"gpio-mmc: "
++
++
++struct gpiommc_device {
++	struct platform_device *pdev;
++	struct platform_device *spi_pdev;
++	struct spi_board_info boardinfo;
++};
++
++
++MODULE_DESCRIPTION("GPIO based MMC driver");
++MODULE_AUTHOR("Michael Buesch");
++MODULE_LICENSE("GPL");
++
++
++static int gpiommc_boardinfo_setup(struct spi_board_info *bi,
++				   struct spi_master *master,
++				   void *data)
++{
++	struct gpiommc_device *d = data;
++	struct gpiommc_platform_data *pdata = d->pdev->dev.platform_data;
++
++	/* Bind the SPI master to the MMC-SPI host driver. */
++	strlcpy(bi->modalias, "mmc_spi", sizeof(bi->modalias));
++
++	bi->max_speed_hz = pdata->max_bus_speed;
++	bi->bus_num = master->bus_num;
++	bi->mode = pdata->mode;
++
++	return 0;
++}
++
++static int gpiommc_probe(struct platform_device *pdev)
++{
++	struct gpiommc_platform_data *mmc_pdata = pdev->dev.platform_data;
++	struct spi_gpio_platform_data spi_pdata;
++	struct gpiommc_device *d;
++	int err;
++
++	err = -ENXIO;
++	if (!mmc_pdata)
++		goto error;
++
++#ifdef CONFIG_MMC_SPI_MODULE
++	err = request_module("mmc_spi");
++	if (err) {
++		printk(KERN_WARNING PFX
++		       "Failed to request mmc_spi module.\n");
++	}
++#endif /* CONFIG_MMC_SPI_MODULE */
++
++	/* Allocate the GPIO-MMC device */
++	err = -ENOMEM;
++	d = kzalloc(sizeof(*d), GFP_KERNEL);
++	if (!d)
++		goto error;
++	d->pdev = pdev;
++
++	/* Create the SPI-GPIO device */
++	d->spi_pdev = platform_device_alloc(SPI_GPIO_PLATDEV_NAME,
++					    spi_gpio_next_id());
++	if (!d->spi_pdev)
++		goto err_free_d;
++
++	memset(&spi_pdata, 0, sizeof(spi_pdata));
++	spi_pdata.pin_clk = mmc_pdata->pins.gpio_clk;
++	spi_pdata.pin_miso = mmc_pdata->pins.gpio_do;
++	spi_pdata.pin_mosi = mmc_pdata->pins.gpio_di;
++	spi_pdata.pin_cs = mmc_pdata->pins.gpio_cs;
++	spi_pdata.cs_activelow = mmc_pdata->pins.cs_activelow;
++	spi_pdata.no_spi_delay = mmc_pdata->no_spi_delay;
++	spi_pdata.boardinfo_setup = gpiommc_boardinfo_setup;
++	spi_pdata.boardinfo_setup_data = d;
++
++	err = platform_device_add_data(d->spi_pdev, &spi_pdata,
++				       sizeof(spi_pdata));
++	if (err)
++		goto err_free_pdev;
++	err = platform_device_add(d->spi_pdev);
++	if (err)
++		goto err_free_pdata;
++	platform_set_drvdata(pdev, d);
++
++	printk(KERN_INFO PFX "MMC-Card \"%s\" "
++	       "attached to GPIO pins di=%u, do=%u, clk=%u, cs=%u\n",
++	       mmc_pdata->name, mmc_pdata->pins.gpio_di,
++	       mmc_pdata->pins.gpio_do,
++	       mmc_pdata->pins.gpio_clk,
++	       mmc_pdata->pins.gpio_cs);
++
++	return 0;
++
++err_free_pdata:
++	kfree(d->spi_pdev->dev.platform_data);
++	d->spi_pdev->dev.platform_data = NULL;
++err_free_pdev:
++	platform_device_put(d->spi_pdev);
++err_free_d:
++	kfree(d);
++error:
++	return err;
++}
++
++static int gpiommc_remove(struct platform_device *pdev)
++{
++	struct gpiommc_device *d = platform_get_drvdata(pdev);
++	struct gpiommc_platform_data *pdata = d->pdev->dev.platform_data;
++
++	platform_device_unregister(d->spi_pdev);
++	printk(KERN_INFO PFX "GPIO based MMC-Card \"%s\" removed\n",
++	       pdata->name);
++	platform_device_put(d->spi_pdev);
++
++	return 0;
++}
++
++#ifdef CONFIG_GPIOMMC_CONFIGFS
++
++/* A device that was created through configfs */
++struct gpiommc_configfs_device {
++	struct config_item item;
++	/* The platform device, after registration. */
++	struct platform_device *pdev;
++	/* The configuration */
++	struct gpiommc_platform_data pdata;
++};
++
++#define GPIO_INVALID	-1
++
++static inline bool gpiommc_is_registered(struct gpiommc_configfs_device *dev)
++{
++	return (dev->pdev != NULL);
++}
++
++static inline struct gpiommc_configfs_device *ci_to_gpiommc(struct config_item *item)
++{
++	return item ? container_of(item, struct gpiommc_configfs_device, item) : NULL;
++}
++
++static struct configfs_attribute gpiommc_attr_DI = {
++	.ca_owner = THIS_MODULE,
++	.ca_name = "gpio_data_in",
++	.ca_mode = S_IRUGO | S_IWUSR,
++};
++
++static struct configfs_attribute gpiommc_attr_DO = {
++	.ca_owner = THIS_MODULE,
++	.ca_name = "gpio_data_out",
++	.ca_mode = S_IRUGO | S_IWUSR,
++};
++
++static struct configfs_attribute gpiommc_attr_CLK = {
++	.ca_owner = THIS_MODULE,
++	.ca_name = "gpio_clock",
++	.ca_mode = S_IRUGO | S_IWUSR,
++};
++
++static struct configfs_attribute gpiommc_attr_CS = {
++	.ca_owner = THIS_MODULE,
++	.ca_name = "gpio_chipselect",
++	.ca_mode = S_IRUGO | S_IWUSR,
++};
++
++static struct configfs_attribute gpiommc_attr_CS_activelow = {
++	.ca_owner = THIS_MODULE,
++	.ca_name = "gpio_chipselect_activelow",
++	.ca_mode = S_IRUGO | S_IWUSR,
++};
++
++static struct configfs_attribute gpiommc_attr_spimode = {
++	.ca_owner = THIS_MODULE,
++	.ca_name = "spi_mode",
++	.ca_mode = S_IRUGO | S_IWUSR,
++};
++
++static struct configfs_attribute gpiommc_attr_spidelay = {
++	.ca_owner = THIS_MODULE,
++	.ca_name = "spi_delay",
++	.ca_mode = S_IRUGO | S_IWUSR,
++};
++
++static struct configfs_attribute gpiommc_attr_max_bus_speed = {
++	.ca_owner = THIS_MODULE,
++	.ca_name = "max_bus_speed",
++	.ca_mode = S_IRUGO | S_IWUSR,
++};
++
++static struct configfs_attribute gpiommc_attr_register = {
++	.ca_owner = THIS_MODULE,
++	.ca_name = "register",
++	.ca_mode = S_IRUGO | S_IWUSR,
++};
++
++static struct configfs_attribute *gpiommc_config_attrs[] = {
++	&gpiommc_attr_DI,
++	&gpiommc_attr_DO,
++	&gpiommc_attr_CLK,
++	&gpiommc_attr_CS,
++	&gpiommc_attr_CS_activelow,
++	&gpiommc_attr_spimode,
++	&gpiommc_attr_spidelay,
++	&gpiommc_attr_max_bus_speed,
++	&gpiommc_attr_register,
++	NULL,
++};
++
++static ssize_t gpiommc_config_attr_show(struct config_item *item,
++					struct configfs_attribute *attr,
++					char *page)
++{
++	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
++	ssize_t count = 0;
++	unsigned int gpio;
++	int err = 0;
++
++	if (attr == &gpiommc_attr_DI) {
++		gpio = dev->pdata.pins.gpio_di;
++		if (gpio == GPIO_INVALID)
++			count = snprintf(page, PAGE_SIZE, "not configured\n");
++		else
++			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
++		goto out;
++	}
++	if (attr == &gpiommc_attr_DO) {
++		gpio = dev->pdata.pins.gpio_do;
++		if (gpio == GPIO_INVALID)
++			count = snprintf(page, PAGE_SIZE, "not configured\n");
++		else
++			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
++		goto out;
++	}
++	if (attr == &gpiommc_attr_CLK) {
++		gpio = dev->pdata.pins.gpio_clk;
++		if (gpio == GPIO_INVALID)
++			count = snprintf(page, PAGE_SIZE, "not configured\n");
++		else
++			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
++		goto out;
++	}
++	if (attr == &gpiommc_attr_CS) {
++		gpio = dev->pdata.pins.gpio_cs;
++		if (gpio == GPIO_INVALID)
++			count = snprintf(page, PAGE_SIZE, "not configured\n");
++		else
++			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
++		goto out;
++	}
++	if (attr == &gpiommc_attr_CS_activelow) {
++		count = snprintf(page, PAGE_SIZE, "%u\n",
++				 dev->pdata.pins.cs_activelow);
++		goto out;
++	}
++	if (attr == &gpiommc_attr_spimode) {
++		count = snprintf(page, PAGE_SIZE, "%u\n",
++				 dev->pdata.mode);
++		goto out;
++	}
++	if (attr == &gpiommc_attr_spidelay) {
++		count = snprintf(page, PAGE_SIZE, "%u\n",
++				 !dev->pdata.no_spi_delay);
++		goto out;
++	}
++	if (attr == &gpiommc_attr_max_bus_speed) {
++		count = snprintf(page, PAGE_SIZE, "%u\n",
++				 dev->pdata.max_bus_speed);
++		goto out;
++	}
++	if (attr == &gpiommc_attr_register) {
++		count = snprintf(page, PAGE_SIZE, "%u\n",
++				 gpiommc_is_registered(dev));
++		goto out;
++	}
++	WARN_ON(1);
++	err = -ENOSYS;
++out:
++	return err ? err : count;
++}
++
++static int gpiommc_do_register(struct gpiommc_configfs_device *dev,
++			       const char *name)
++{
++	int err;
++
++	if (gpiommc_is_registered(dev))
++		return 0;
++
++	if (!gpio_is_valid(dev->pdata.pins.gpio_di) ||
++	    !gpio_is_valid(dev->pdata.pins.gpio_do) ||
++	    !gpio_is_valid(dev->pdata.pins.gpio_clk) ||
++	    !gpio_is_valid(dev->pdata.pins.gpio_cs)) {
++		printk(KERN_ERR PFX
++		       "configfs: Invalid GPIO pin number(s)\n");
++		return -EINVAL;
++	}
++
++	strlcpy(dev->pdata.name, name,
++		sizeof(dev->pdata.name));
++
++	dev->pdev = platform_device_alloc(GPIOMMC_PLATDEV_NAME,
++					  gpiommc_next_id());
++	if (!dev->pdev)
++		return -ENOMEM;
++	err = platform_device_add_data(dev->pdev, &dev->pdata,
++				       sizeof(dev->pdata));
++	if (err) {
++		platform_device_put(dev->pdev);
++		return err;
++	}
++	err = platform_device_add(dev->pdev);
++	if (err) {
++		platform_device_put(dev->pdev);
++		return err;
++	}
++
++	return 0;
++}
++
++static void gpiommc_do_unregister(struct gpiommc_configfs_device *dev)
++{
++	if (!gpiommc_is_registered(dev))
++		return;
++
++	platform_device_unregister(dev->pdev);
++	dev->pdev = NULL;
++}
++
++static ssize_t gpiommc_config_attr_store(struct config_item *item,
++					 struct configfs_attribute *attr,
++					 const char *page, size_t count)
++{
++	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
++	int err = -EINVAL;
++	unsigned long data;
++
++	if (attr == &gpiommc_attr_register) {
++		err = kstrtoul(page, 10, &data);
++		if (err)
++			goto out;
++		err = -EINVAL;
++		if (data == 1)
++			err = gpiommc_do_register(dev, item->ci_name);
++		if (data == 0) {
++			gpiommc_do_unregister(dev);
++			err = 0;
++		}
++		goto out;
++	}
++
++	if (gpiommc_is_registered(dev)) {
++		/* The rest of the config parameters can only be set
++		 * as long as the device is not registered, yet. */
++		err = -EBUSY;
++		goto out;
++	}
++
++	if (attr == &gpiommc_attr_DI) {
++		err = kstrtoul(page, 10, &data);
++		if (err)
++			goto out;
++		err = -EINVAL;
++		if (!gpio_is_valid(data))
++			goto out;
++		dev->pdata.pins.gpio_di = data;
++		err = 0;
++		goto out;
++	}
++	if (attr == &gpiommc_attr_DO) {
++		err = kstrtoul(page, 10, &data);
++		if (err)
++			goto out;
++		err = -EINVAL;
++		if (!gpio_is_valid(data))
++			goto out;
++		dev->pdata.pins.gpio_do = data;
++		err = 0;
++		goto out;
++	}
++	if (attr == &gpiommc_attr_CLK) {
++		err = kstrtoul(page, 10, &data);
++		if (err)
++			goto out;
++		err = -EINVAL;
++		if (!gpio_is_valid(data))
++			goto out;
++		dev->pdata.pins.gpio_clk = data;
++		err = 0;
++		goto out;
++	}
++	if (attr == &gpiommc_attr_CS) {
++		err = kstrtoul(page, 10, &data);
++		if (err)
++			goto out;
++		err = -EINVAL;
++		if (!gpio_is_valid(data))
++			goto out;
++		dev->pdata.pins.gpio_cs = data;
++		err = 0;
++		goto out;
++	}
++	if (attr == &gpiommc_attr_CS_activelow) {
++		err = kstrtoul(page, 10, &data);
++		if (err)
++			goto out;
++		err = -EINVAL;
++		if (data != 0 && data != 1)
++			goto out;
++		dev->pdata.pins.cs_activelow = data;
++		err = 0;
++		goto out;
++	}
++	if (attr == &gpiommc_attr_spimode) {
++		err = kstrtoul(page, 10, &data);
++		if (err)
++			goto out;
++		err = -EINVAL;
++		switch (data) {
++		case 0:
++			dev->pdata.mode = SPI_MODE_0;
++			break;
++		case 1:
++			dev->pdata.mode = SPI_MODE_1;
++			break;
++		case 2:
++			dev->pdata.mode = SPI_MODE_2;
++			break;
++		case 3:
++			dev->pdata.mode = SPI_MODE_3;
++			break;
++		default:
++			goto out;
++		}
++		err = 0;
++		goto out;
++	}
++	if (attr == &gpiommc_attr_spidelay) {
++		err = kstrtoul(page, 10, &data);
++		if (err)
++			goto out;
++		err = -EINVAL;
++		if (data != 0 && data != 1)
++			goto out;
++		dev->pdata.no_spi_delay = !data;
++		err = 0;
++		goto out;
++	}
++	if (attr == &gpiommc_attr_max_bus_speed) {
++		err = kstrtoul(page, 10, &data);
++		if (err)
++			goto out;
++		err = -EINVAL;
++		if (data > UINT_MAX)
++			goto out;
++		dev->pdata.max_bus_speed = data;
++		err = 0;
++		goto out;
++	}
++	WARN_ON(1);
++	err = -ENOSYS;
++out:
++	return err ? err : count;
++}
++
++static void gpiommc_config_item_release(struct config_item *item)
++{
++	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
++
++	kfree(dev);
++}
++
++static struct configfs_item_operations gpiommc_config_item_ops = {
++	.release		= gpiommc_config_item_release,
++	.show_attribute		= gpiommc_config_attr_show,
++	.store_attribute	= gpiommc_config_attr_store,
++};
++
++static struct config_item_type gpiommc_dev_ci_type = {
++	.ct_item_ops	= &gpiommc_config_item_ops,
++	.ct_attrs	= gpiommc_config_attrs,
++	.ct_owner	= THIS_MODULE,
++};
++
++static struct config_item *gpiommc_make_item(struct config_group *group,
++					     const char *name)
++{
++	struct gpiommc_configfs_device *dev;
++
++	if (strlen(name) > GPIOMMC_MAX_NAMELEN) {
++		printk(KERN_ERR PFX "configfs: device name too long\n");
++		return NULL;
++	}
++
++	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
++	if (!dev)
++		return NULL;
++
++	config_item_init_type_name(&dev->item, name,
++				   &gpiommc_dev_ci_type);
++
++	/* Assign default configuration */
++	dev->pdata.pins.gpio_di = GPIO_INVALID;
++	dev->pdata.pins.gpio_do = GPIO_INVALID;
++	dev->pdata.pins.gpio_clk = GPIO_INVALID;
++	dev->pdata.pins.gpio_cs = GPIO_INVALID;
++	dev->pdata.pins.cs_activelow = 1;
++	dev->pdata.mode = SPI_MODE_0;
++	dev->pdata.no_spi_delay = 0;
++	dev->pdata.max_bus_speed = 5000000; /* 5 MHz */
++
++	return &(dev->item);
++}
++
++static void gpiommc_drop_item(struct config_group *group,
++			      struct config_item *item)
++{
++	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
++
++	gpiommc_do_unregister(dev);
++	kfree(dev);
++}
++
++static struct configfs_group_operations gpiommc_ct_group_ops = {
++	.make_item	= gpiommc_make_item,
++	.drop_item	= gpiommc_drop_item,
++};
++
++static struct config_item_type gpiommc_ci_type = {
++	.ct_group_ops	= &gpiommc_ct_group_ops,
++	.ct_owner	= THIS_MODULE,
++};
++
++static struct configfs_subsystem gpiommc_subsys = {
++	.su_group = {
++		.cg_item = {
++			.ci_namebuf = GPIOMMC_PLATDEV_NAME,
++			.ci_type = &gpiommc_ci_type,
++		},
++	},
++	.su_mutex = __MUTEX_INITIALIZER(gpiommc_subsys.su_mutex),
++};
++
++#endif /* CONFIG_GPIOMMC_CONFIGFS */
++
++static struct platform_driver gpiommc_plat_driver = {
++	.probe	= gpiommc_probe,
++	.remove	= gpiommc_remove,
++	.driver	= {
++		.name	= GPIOMMC_PLATDEV_NAME,
++		.owner	= THIS_MODULE,
++	},
++};
++
++int gpiommc_next_id(void)
++{
++	static atomic_t counter = ATOMIC_INIT(-1);
++
++	return atomic_inc_return(&counter);
++}
++EXPORT_SYMBOL(gpiommc_next_id);
++
++static int __init gpiommc_modinit(void)
++{
++	int err;
++
++	err = platform_driver_register(&gpiommc_plat_driver);
++	if (err)
++		return err;
++
++#ifdef CONFIG_GPIOMMC_CONFIGFS
++	config_group_init(&gpiommc_subsys.su_group);
++	err = configfs_register_subsystem(&gpiommc_subsys);
++	if (err) {
++		platform_driver_unregister(&gpiommc_plat_driver);
++		return err;
++	}
++#endif /* CONFIG_GPIOMMC_CONFIGFS */
++
++	return 0;
++}
++module_init(gpiommc_modinit);
++
++static void __exit gpiommc_modexit(void)
++{
++#ifdef CONFIG_GPIOMMC_CONFIGFS
++	configfs_unregister_subsystem(&gpiommc_subsys);
++#endif
++	platform_driver_unregister(&gpiommc_plat_driver);
++}
++module_exit(gpiommc_modexit);
+--- a/drivers/mmc/host/Kconfig
++++ b/drivers/mmc/host/Kconfig
+@@ -474,6 +474,31 @@ config MMC_SDHI
+ 	  This provides support for the SDHI SD/SDIO controller found in
+ 	  SuperH and ARM SH-Mobile SoCs
+ 
++config GPIOMMC
++	tristate "MMC/SD over GPIO-based SPI"
++	depends on MMC && MMC_SPI && SPI_GPIO_OLD
++	help
++	  This driver hooks up the mmc_spi and spi_gpio modules so that
++	  MMC/SD cards can be used on a GPIO based bus by bitbanging
++	  the SPI protocol in software.
++
++	  This driver provides a configfs interface to dynamically create
++	  and destroy GPIO-based MMC/SD card devices. It also provides
++	  a platform device interface API.
++	  See Documentation/gpiommc.txt for details.
++
++	  The module will be called gpiommc.
++
++	  If unsure, say N.
++
++config GPIOMMC_CONFIGFS
++	bool
++	depends on GPIOMMC && CONFIGFS_FS
++	default y
++	help
++	  This option automatically enables configfs support for gpiommc
++	  if configfs is available.
++
+ config MMC_CB710
+ 	tristate "ENE CB710 MMC/SD Interface support"
+ 	depends on PCI && GENERIC_HARDIRQS
+--- a/drivers/mmc/host/Makefile
++++ b/drivers/mmc/host/Makefile
+@@ -38,6 +38,7 @@ tmio_mmc_core-$(subst m,y,$(CONFIG_MMC_S
+ obj-$(CONFIG_MMC_SDHI)		+= sh_mobile_sdhi.o
+ obj-$(CONFIG_MMC_CB710)		+= cb710-mmc.o
+ obj-$(CONFIG_MMC_VIA_SDMMC)	+= via-sdmmc.o
++obj-$(CONFIG_GPIOMMC)		+= gpiommc.o
+ obj-$(CONFIG_SDH_BFIN)		+= bfin_sdh.o
+ obj-$(CONFIG_MMC_DW)		+= dw_mmc.o
+ obj-$(CONFIG_MMC_DW_PLTFM)	+= dw_mmc-pltfm.o
+--- /dev/null
++++ b/include/linux/mmc/gpiommc.h
+@@ -0,0 +1,71 @@
++/*
++ * Device driver for MMC/SD cards driven over a GPIO bus.
++ *
++ * Copyright (c) 2008 Michael Buesch
++ *
++ * Licensed under the GNU/GPL version 2.
++ */
++#ifndef LINUX_GPIOMMC_H_
++#define LINUX_GPIOMMC_H_
++
++#include <linux/types.h>
++
++
++#define GPIOMMC_MAX_NAMELEN		15
++#define GPIOMMC_MAX_NAMELEN_STR		__stringify(GPIOMMC_MAX_NAMELEN)
++
++/**
++ * struct gpiommc_pins - Hardware pin assignments
++ *
++ * @gpio_di: The GPIO number of the DATA IN pin
++ * @gpio_do: The GPIO number of the DATA OUT pin
++ * @gpio_clk: The GPIO number of the CLOCK pin
++ * @gpio_cs: The GPIO number of the CHIPSELECT pin
++ * @cs_activelow: If true, the chip is considered selected if @gpio_cs is low.
++ */
++struct gpiommc_pins {
++	unsigned int gpio_di;
++	unsigned int gpio_do;
++	unsigned int gpio_clk;
++	unsigned int gpio_cs;
++	bool cs_activelow;
++};
++
++/**
++ * struct gpiommc_platform_data - Platform data for a MMC-over-SPI-GPIO device.
++ *
++ * @name: The unique name string of the device.
++ * @pins: The hardware pin assignments.
++ * @mode: The hardware mode. This is either SPI_MODE_0,
++ *        SPI_MODE_1, SPI_MODE_2 or SPI_MODE_3. See the SPI documentation.
++ * @no_spi_delay: Do not use delays in the lowlevel SPI bitbanging code.
++ *                This is not standards compliant, but may be required for some
++ *                embedded machines to gain reasonable speed.
++ * @max_bus_speed: The maximum speed of the SPI bus, in Hertz.
++ */
++struct gpiommc_platform_data {
++	char name[GPIOMMC_MAX_NAMELEN + 1];
++	struct gpiommc_pins pins;
++	u8 mode;
++	bool no_spi_delay;
++	unsigned int max_bus_speed;
++};
++
++/**
++ * GPIOMMC_PLATDEV_NAME - The platform device name string.
++ *
++ * The name string that has to be used for platform_device_alloc
++ * when allocating a gpiommc device.
++ */
++#define GPIOMMC_PLATDEV_NAME	"gpiommc"
++
++/**
++ * gpiommc_next_id - Get another platform device ID number.
++ *
++ * This returns the next platform device ID number that has to be used
++ * for platform_device_alloc. The ID is opaque and should not be used for
++ * anything else.
++ */
++int gpiommc_next_id(void);
++
++#endif /* LINUX_GPIOMMC_H_ */
+--- /dev/null
++++ b/Documentation/gpiommc.txt
+@@ -0,0 +1,97 @@
++GPIOMMC - Driver for an MMC/SD card on a bitbanging GPIO SPI bus
++================================================================
++
++The gpiommc module hooks up the mmc_spi and spi_gpio modules for running an
++MMC or SD card on GPIO pins.
++
++Two interfaces for registering a new MMC/SD card device are provided:
++A static platform-device based mechanism and a dynamic configfs based interface.
++
++
++Registering devices via platform-device
++=======================================
++
++The platform-device interface is used for registering MMC/SD devices that are
++part of the hardware platform. This is most useful only for embedded machines
++with MMC/SD devices statically connected to the platform GPIO bus.
++
++The data structures are declared in <linux/mmc/gpiommc.h>.
++
++To register a new device, define an instance of struct gpiommc_platform_data.
++This structure holds any information about how the device is hooked up to the
++GPIO pins and what hardware modes the device supports. See the docbook-style
++documentation in the header file for more information on the struct fields.
++
++Then allocate a new instance of a platform device by doing:
++
++	pdev = platform_device_alloc(GPIOMMC_PLATDEV_NAME, gpiommc_next_id());
++
++This will allocate the platform device data structures and hook it up to the
++gpiommc driver.
++Then add the gpiommc_platform_data to the platform device.
++
++	err = platform_device_add_data(pdev, pdata, sizeof(struct gpiommc_platform_data));
++
++You may free the local instance of struct gpiommc_platform_data now. (So the
++struct may be allocated on the stack, too).
++Now simply register the platform device.
++
++	err = platform_device_add(pdev);
++
++Done. The gpiommc probe routine will be invoked now and you should see a kernel
++log message for the added device.
++
++
++Registering devices via configfs
++================================
++
++MMC/SD cards connected via GPIO often are a pretty dynamic thing, as for example
++selfmade hacks for soldering an MMC/SD card to standard GPIO pins on embedded
++hardware are a common situation.
++So we provide a dynamic interface to conveniently handle adding and removing
++devices from userspace, without the need to recompile the kernel.
++
++The "gpiommc" subdirectory at the configfs mountpoint is used for handling
++the dynamic configuration.
++
++To create a new device, it must first be allocated with mkdir.
++The following command will allocate a device named "my_mmc":
++	mkdir /config/gpiommc/my_mmc
++
++There are several configuration files available in the new
++/config/gpiommc/my_mmc/ directory:
++
++gpio_data_in			= The SPI data-IN GPIO pin number.
++gpio_data_out			= The SPI data-OUT GPIO pin number.
++gpio_clock			= The SPI Clock GPIO pin number.
++gpio_chipselect			= The SPI Chipselect GPIO pin number.
++gpio_chipselect_activelow	= Boolean. If 0, Chipselect is active-HIGH.
++				  If 1, Chipselect is active-LOW.
++spi_mode			= The SPI data mode. Can be 0-3.
++spi_delay			= Enable all delays in the lowlevel bitbanging.
++max_bus_speed			= The maximum SPI bus speed. In Hertz.
++
++register			= Not a configuration parameter.
++				  Used to register the configured card
++				  with the kernel.
++
++The device must first get configured and then registered by writing "1" to
++the "register" file.
++The configuration parameters "gpio_data_in", "gpio_data_out", "gpio_clock"
++and "gpio_chipselect" are essential and _must_ be configured before writing
++"1" to the "register" file. The registration will fail, otherwise.
++
++The default values for the other parameters are:
++gpio_chipselect_activelow	= 1		(CS active-LOW)
++spi_mode			= 0		(SPI_MODE_0)
++spi_delay			= 1		(enabled)
++max_bus_speed			= 5000000	(5 Mhz)
++
++Configuration values can not be changed after registration. To unregister
++the device, write a "0" to the "register" file. The configuration can be
++changed again after unregistering.
++
++To completely remove the device, simply rmdir the directory
++(/config/gpiommc/my_mmc in this example).
++There's no need to first unregister the device before removing it. That will
++be done automatically.
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -3670,6 +3670,11 @@ L:	linuxppc-dev@lists.ozlabs.org
+ S:	Odd Fixes
+ F:	drivers/tty/hvc/
+ 
++GPIOMMC DRIVER
++P:	Michael Buesch
++M:	mb@bu3sch.de
++S:	Maintained
++
+ HARDWARE MONITORING
+ M:	Jean Delvare <khali@linux-fr.org>
+ M:	Guenter Roeck <linux@roeck-us.net>
diff --git a/target/linux/generic/patches-3.10/864-gpiommc_configfs_locking.patch b/target/linux/generic/patches-3.10/864-gpiommc_configfs_locking.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/864-gpiommc_configfs_locking.patch
@@ -0,0 +1,58 @@
+The gpiommc configfs context structure needs locking, as configfs
+does not lock access between files.
+
+--- a/drivers/mmc/host/gpiommc.c
++++ b/drivers/mmc/host/gpiommc.c
+@@ -144,6 +144,8 @@ struct gpiommc_configfs_device {
+ 	struct platform_device *pdev;
+ 	/* The configuration */
+ 	struct gpiommc_platform_data pdata;
++	/* Mutex to protect this structure */
++	struct mutex mutex;
+ };
+ 
+ #define GPIO_INVALID	-1
+@@ -234,6 +236,8 @@ static ssize_t gpiommc_config_attr_show(
+ 	unsigned int gpio;
+ 	int err = 0;
+ 
++	mutex_lock(&dev->mutex);
++
+ 	if (attr == &gpiommc_attr_DI) {
+ 		gpio = dev->pdata.pins.gpio_di;
+ 		if (gpio == GPIO_INVALID)
+@@ -294,6 +298,8 @@ static ssize_t gpiommc_config_attr_show(
+ 	WARN_ON(1);
+ 	err = -ENOSYS;
+ out:
++	mutex_unlock(&dev->mutex);
++
+ 	return err ? err : count;
+ }
+ 
+@@ -353,6 +359,8 @@ static ssize_t gpiommc_config_attr_store
+ 	int err = -EINVAL;
+ 	unsigned long data;
+ 
++	mutex_lock(&dev->mutex);
++
+ 	if (attr == &gpiommc_attr_register) {
+ 		err = kstrtoul(page, 10, &data);
+ 		if (err)
+@@ -478,6 +486,8 @@ static ssize_t gpiommc_config_attr_store
+ 	WARN_ON(1);
+ 	err = -ENOSYS;
+ out:
++	mutex_unlock(&dev->mutex);
++
+ 	return err ? err : count;
+ }
+ 
+@@ -514,6 +524,7 @@ static struct config_item *gpiommc_make_
+ 	if (!dev)
+ 		return NULL;
+ 
++	mutex_init(&dev->mutex);
+ 	config_item_init_type_name(&dev->item, name,
+ 				   &gpiommc_dev_ci_type);
+ 
diff --git a/target/linux/generic/patches-3.10/870-hifn795x_byteswap.patch b/target/linux/generic/patches-3.10/870-hifn795x_byteswap.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/870-hifn795x_byteswap.patch
@@ -0,0 +1,17 @@
+--- a/drivers/crypto/hifn_795x.c
++++ b/drivers/crypto/hifn_795x.c
+@@ -682,12 +682,12 @@ static inline u32 hifn_read_1(struct hif
+ 
+ static inline void hifn_write_0(struct hifn_device *dev, u32 reg, u32 val)
+ {
+-	writel((__force u32)cpu_to_le32(val), dev->bar[0] + reg);
++	writel(val, dev->bar[0] + reg);
+ }
+ 
+ static inline void hifn_write_1(struct hifn_device *dev, u32 reg, u32 val)
+ {
+-	writel((__force u32)cpu_to_le32(val), dev->bar[1] + reg);
++	writel(val, dev->bar[1] + reg);
+ }
+ 
+ static void hifn_wait_puc(struct hifn_device *dev)
diff --git a/target/linux/generic/patches-3.10/880-gateworks_system_controller.patch b/target/linux/generic/patches-3.10/880-gateworks_system_controller.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/880-gateworks_system_controller.patch
@@ -0,0 +1,345 @@
+Index: kernel_tree/drivers/hwmon/Kconfig
+===================================================================
+--- kernel_tree.orig/drivers/hwmon/Kconfig
++++ kernel_tree/drivers/hwmon/Kconfig
+@@ -478,6 +478,15 @@ config SENSORS_GL520SM
+ 	  This driver can also be built as a module.  If so, the module
+ 	  will be called gl520sm.
+ 
++config SENSORS_GSC
++	tristate "Gateworks System Controller"
++	depends on I2C
++	help
++	  If you say yes here you get support for the Gateworks System Controller.
++
++	  This driver can also be built as a module. If so, the module
++	  will be called gsc.
++
+ config SENSORS_GPIO_FAN
+ 	tristate "GPIO fan"
+ 	depends on GPIOLIB
+Index: kernel_tree/drivers/hwmon/Makefile
+===================================================================
+--- kernel_tree.orig/drivers/hwmon/Makefile
++++ kernel_tree/drivers/hwmon/Makefile
+@@ -141,6 +141,7 @@ obj-$(CONFIG_SENSORS_W83L785TS)	+= w83l7
+ obj-$(CONFIG_SENSORS_W83L786NG)	+= w83l786ng.o
+ obj-$(CONFIG_SENSORS_WM831X)	+= wm831x-hwmon.o
+ obj-$(CONFIG_SENSORS_WM8350)	+= wm8350-hwmon.o
++obj-$(CONFIG_SENSORS_GSC)	+= gsc.o
+ 
+ obj-$(CONFIG_PMBUS)		+= pmbus/
+ 
+Index: kernel_tree/drivers/hwmon/gsc.c
+===================================================================
+--- /dev/null
++++ kernel_tree/drivers/hwmon/gsc.c
+@@ -0,0 +1,308 @@
++/*
++ * A hwmon driver for the Gateworks System Controller 
++ * Copyright (C) 2009 Gateworks Corporation
++ *
++ * Author: Chris Lang <clang@gateworks.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License,
++ * as published by the Free Software Foundation - version 2.
++ */
++
++#include <linux/module.h>
++#include <linux/i2c.h>
++#include <linux/hwmon.h>
++#include <linux/hwmon-sysfs.h>
++#include <linux/err.h>
++#include <linux/slab.h>
++
++#define DRV_VERSION "0.2"
++
++enum chips { gsp };
++
++/* AD7418 registers */
++#define GSP_REG_TEMP_IN		0x00
++#define GSP_REG_VIN		0x02
++#define GSP_REG_3P3		0x05
++#define GSP_REG_BAT		0x08
++#define GSP_REG_5P0		0x0b
++#define GSP_REG_CORE		0x0e
++#define GSP_REG_CPU1		0x11
++#define GSP_REG_CPU2		0x14
++#define GSP_REG_DRAM		0x17
++#define GSP_REG_EXT_BAT		0x1a
++#define GSP_REG_IO1		0x1d
++#define GSP_REG_IO2 		0x20
++#define GSP_REG_PCIE		0x23
++#define GSP_REG_CURRENT		0x26
++#define GSP_FAN_0		0x2C
++#define GSP_FAN_1		0x2E
++#define GSP_FAN_2		0x30
++#define GSP_FAN_3		0x32
++#define GSP_FAN_4		0x34
++#define GSP_FAN_5		0x36
++
++struct gsp_sensor_info {
++	const char* name;
++	int reg;
++};
++
++static const struct gsp_sensor_info gsp_sensors[] = {
++	{"temp", GSP_REG_TEMP_IN},
++	{"vin", GSP_REG_VIN},
++	{"3p3", GSP_REG_3P3},
++	{"bat", GSP_REG_BAT},
++	{"5p0", GSP_REG_5P0},
++	{"core", GSP_REG_CORE},
++	{"cpu1", GSP_REG_CPU1},
++	{"cpu2", GSP_REG_CPU2},
++	{"dram", GSP_REG_DRAM},
++	{"ext_bat", GSP_REG_EXT_BAT},
++	{"io1", GSP_REG_IO1},
++	{"io2", GSP_REG_IO2},
++	{"pci2", GSP_REG_PCIE},
++	{"current", GSP_REG_CURRENT},
++	{"fan_point0", GSP_FAN_0},
++	{"fan_point1", GSP_FAN_1},
++	{"fan_point2", GSP_FAN_2},
++	{"fan_point3", GSP_FAN_3},
++	{"fan_point4", GSP_FAN_4},
++	{"fan_point5", GSP_FAN_5},
++};
++
++struct gsp_data {
++	struct device		*hwmon_dev;
++	struct attribute_group	attrs;
++	enum chips		type;
++};
++
++static int gsp_probe(struct i2c_client *client,
++			const struct i2c_device_id *id);
++static int gsp_remove(struct i2c_client *client);
++
++static const struct i2c_device_id gsp_id[] = {
++	{ "gsp", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, gsp_id);
++
++static struct i2c_driver gsp_driver = {
++	.driver = {
++		.name	= "gsp",
++	},
++	.probe		= gsp_probe,
++	.remove		= gsp_remove,
++	.id_table	= gsp_id,
++};
++
++/* All registers are word-sized, except for the configuration registers.
++ * AD7418 uses a high-byte first convention. Do NOT use those functions to
++ * access the configuration registers CONF and CONF2, as they are byte-sized.
++ */
++static inline int gsp_read(struct i2c_client *client, u8 reg)
++{
++	unsigned int adc = 0;
++	if (reg == GSP_REG_TEMP_IN || reg > GSP_REG_CURRENT)
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		return adc;
++	}
++	else
++	{
++		adc |= i2c_smbus_read_byte_data(client, reg);
++		adc |= i2c_smbus_read_byte_data(client, reg + 1) << 8;
++		adc |= i2c_smbus_read_byte_data(client, reg + 2) << 16;
++		return adc;
++	}
++}
++
++static inline int gsp_write(struct i2c_client *client, u8 reg, u16 value)
++{
++	i2c_smbus_write_byte_data(client, reg, value & 0xff);
++	i2c_smbus_write_byte_data(client, reg + 1, ((value >> 8) & 0xff));
++	return 1;
++}
++
++static ssize_t show_adc(struct device *dev, struct device_attribute *devattr,
++			char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	return sprintf(buf, "%d\n", gsp_read(client, gsp_sensors[attr->index].reg));
++}
++
++static ssize_t show_label(struct device *dev,
++			struct device_attribute *devattr, char *buf)
++{
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++
++	return sprintf(buf, "%s\n", gsp_sensors[attr->index].name);
++}
++
++static ssize_t store_fan(struct device *dev,
++			struct device_attribute *devattr, const char *buf, size_t count)
++{
++	u16 val;
++	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
++	struct i2c_client *client = to_i2c_client(dev);
++	val = simple_strtoul(buf, NULL, 10);
++	gsp_write(client, gsp_sensors[attr->index].reg, val);
++	return count;
++}
++
++static SENSOR_DEVICE_ATTR(temp0_input, S_IRUGO, show_adc, NULL, 0);
++static SENSOR_DEVICE_ATTR(temp0_label, S_IRUGO, show_label, NULL, 0);
++
++static SENSOR_DEVICE_ATTR(in0_input, S_IRUGO, show_adc, NULL, 1);
++static SENSOR_DEVICE_ATTR(in0_label, S_IRUGO, show_label, NULL, 1);
++static SENSOR_DEVICE_ATTR(in1_input, S_IRUGO, show_adc, NULL, 2);
++static SENSOR_DEVICE_ATTR(in1_label, S_IRUGO, show_label, NULL, 2);
++static SENSOR_DEVICE_ATTR(in2_input, S_IRUGO, show_adc, NULL, 3);
++static SENSOR_DEVICE_ATTR(in2_label, S_IRUGO, show_label, NULL, 3);
++static SENSOR_DEVICE_ATTR(in3_input, S_IRUGO, show_adc, NULL, 4);
++static SENSOR_DEVICE_ATTR(in3_label, S_IRUGO, show_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(in4_input, S_IRUGO, show_adc, NULL, 5);
++static SENSOR_DEVICE_ATTR(in4_label, S_IRUGO, show_label, NULL, 5);
++static SENSOR_DEVICE_ATTR(in5_input, S_IRUGO, show_adc, NULL, 6);
++static SENSOR_DEVICE_ATTR(in5_label, S_IRUGO, show_label, NULL, 6);
++static SENSOR_DEVICE_ATTR(in6_input, S_IRUGO, show_adc, NULL, 7);
++static SENSOR_DEVICE_ATTR(in6_label, S_IRUGO, show_label, NULL, 7);
++static SENSOR_DEVICE_ATTR(in7_input, S_IRUGO, show_adc, NULL, 8);
++static SENSOR_DEVICE_ATTR(in7_label, S_IRUGO, show_label, NULL, 8);
++static SENSOR_DEVICE_ATTR(in8_input, S_IRUGO, show_adc, NULL, 9);
++static SENSOR_DEVICE_ATTR(in8_label, S_IRUGO, show_label, NULL, 9);
++static SENSOR_DEVICE_ATTR(in9_input, S_IRUGO, show_adc, NULL, 10);
++static SENSOR_DEVICE_ATTR(in9_label, S_IRUGO, show_label, NULL, 10);
++static SENSOR_DEVICE_ATTR(in10_input, S_IRUGO, show_adc, NULL, 11);
++static SENSOR_DEVICE_ATTR(in10_label, S_IRUGO, show_label, NULL, 11);
++static SENSOR_DEVICE_ATTR(in11_input, S_IRUGO, show_adc, NULL, 12);
++static SENSOR_DEVICE_ATTR(in11_label, S_IRUGO, show_label, NULL, 12);
++static SENSOR_DEVICE_ATTR(in12_input, S_IRUGO, show_adc, NULL, 13);
++static SENSOR_DEVICE_ATTR(in12_label, S_IRUGO, show_label, NULL, 13);
++
++static SENSOR_DEVICE_ATTR(fan0_point0, S_IRUGO | S_IWUSR, show_adc, store_fan, 14);
++static SENSOR_DEVICE_ATTR(fan0_point1, S_IRUGO | S_IWUSR, show_adc, store_fan, 15);
++static SENSOR_DEVICE_ATTR(fan0_point2, S_IRUGO | S_IWUSR, show_adc, store_fan, 16);
++static SENSOR_DEVICE_ATTR(fan0_point3, S_IRUGO | S_IWUSR, show_adc, store_fan, 17);
++static SENSOR_DEVICE_ATTR(fan0_point4, S_IRUGO | S_IWUSR, show_adc, store_fan, 18);
++static SENSOR_DEVICE_ATTR(fan0_point5, S_IRUGO | S_IWUSR, show_adc, store_fan, 19);
++
++static struct attribute *gsp_attributes[] = {
++	&sensor_dev_attr_temp0_input.dev_attr.attr,
++	&sensor_dev_attr_in0_input.dev_attr.attr,
++	&sensor_dev_attr_in1_input.dev_attr.attr,
++	&sensor_dev_attr_in2_input.dev_attr.attr,
++	&sensor_dev_attr_in3_input.dev_attr.attr,
++	&sensor_dev_attr_in4_input.dev_attr.attr,
++	&sensor_dev_attr_in5_input.dev_attr.attr,
++	&sensor_dev_attr_in6_input.dev_attr.attr,
++	&sensor_dev_attr_in7_input.dev_attr.attr,
++	&sensor_dev_attr_in8_input.dev_attr.attr,
++	&sensor_dev_attr_in9_input.dev_attr.attr,
++	&sensor_dev_attr_in10_input.dev_attr.attr,
++	&sensor_dev_attr_in11_input.dev_attr.attr,
++	&sensor_dev_attr_in12_input.dev_attr.attr,
++
++	&sensor_dev_attr_temp0_label.dev_attr.attr,
++	&sensor_dev_attr_in0_label.dev_attr.attr,
++	&sensor_dev_attr_in1_label.dev_attr.attr,
++	&sensor_dev_attr_in2_label.dev_attr.attr,
++	&sensor_dev_attr_in3_label.dev_attr.attr,
++	&sensor_dev_attr_in4_label.dev_attr.attr,
++	&sensor_dev_attr_in5_label.dev_attr.attr,
++	&sensor_dev_attr_in6_label.dev_attr.attr,
++	&sensor_dev_attr_in7_label.dev_attr.attr,
++	&sensor_dev_attr_in8_label.dev_attr.attr,
++	&sensor_dev_attr_in9_label.dev_attr.attr,
++	&sensor_dev_attr_in10_label.dev_attr.attr,
++	&sensor_dev_attr_in11_label.dev_attr.attr,
++	&sensor_dev_attr_in12_label.dev_attr.attr,
++
++	&sensor_dev_attr_fan0_point0.dev_attr.attr,
++	&sensor_dev_attr_fan0_point1.dev_attr.attr,
++	&sensor_dev_attr_fan0_point2.dev_attr.attr,
++	&sensor_dev_attr_fan0_point3.dev_attr.attr,
++	&sensor_dev_attr_fan0_point4.dev_attr.attr,
++	&sensor_dev_attr_fan0_point5.dev_attr.attr,
++	NULL
++};
++
++
++static int gsp_probe(struct i2c_client *client,
++			 const struct i2c_device_id *id)
++{
++	struct i2c_adapter *adapter = client->adapter;
++	struct gsp_data *data;
++	int err;
++
++	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |
++					I2C_FUNC_SMBUS_WORD_DATA)) {
++		err = -EOPNOTSUPP;
++		goto exit;
++	}
++
++	if (!(data = kzalloc(sizeof(struct gsp_data), GFP_KERNEL))) {
++		err = -ENOMEM;
++		goto exit;
++	}
++
++	i2c_set_clientdata(client, data);
++
++	data->type = id->driver_data;
++
++	switch (data->type) {
++	case 0:
++		data->attrs.attrs = gsp_attributes;
++		break;
++	}
++
++	dev_info(&client->dev, "%s chip found\n", client->name);
++
++	/* Register sysfs hooks */
++	if ((err = sysfs_create_group(&client->dev.kobj, &data->attrs)))
++		goto exit_free;
++
++	data->hwmon_dev = hwmon_device_register(&client->dev);
++	if (IS_ERR(data->hwmon_dev)) {
++		err = PTR_ERR(data->hwmon_dev);
++		goto exit_remove;
++	}
++
++	return 0;
++
++exit_remove:
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++exit_free:
++	kfree(data);
++exit:
++	return err;
++}
++
++static int gsp_remove(struct i2c_client *client)
++{
++	struct gsp_data *data = i2c_get_clientdata(client);
++	hwmon_device_unregister(data->hwmon_dev);
++	sysfs_remove_group(&client->dev.kobj, &data->attrs);
++	kfree(data);
++	return 0;
++}
++
++static int __init gsp_init(void)
++{
++	return i2c_add_driver(&gsp_driver);
++}
++
++static void __exit gsp_exit(void)
++{
++	i2c_del_driver(&gsp_driver);
++}
++
++module_init(gsp_init);
++module_exit(gsp_exit);
++
++MODULE_AUTHOR("Chris Lang <clang@gateworks.com>");
++MODULE_DESCRIPTION("GSC HWMON driver");
++MODULE_LICENSE("GPL");
++MODULE_VERSION(DRV_VERSION);
++
diff --git a/target/linux/generic/patches-3.10/890-8250_optional_sysrq.patch b/target/linux/generic/patches-3.10/890-8250_optional_sysrq.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/890-8250_optional_sysrq.patch
@@ -0,0 +1,24 @@
+--- a/drivers/tty/serial/8250/8250_core.c
++++ b/drivers/tty/serial/8250/8250_core.c
+@@ -16,7 +16,7 @@
+  *  membase is an 'ioremapped' cookie.
+  */
+ 
+-#if defined(CONFIG_SERIAL_8250_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
++#if defined(CONFIG_SERIAL_8250_SYSRQ) && defined(CONFIG_MAGIC_SYSRQ)
+ #define SUPPORT_SYSRQ
+ #endif
+ 
+--- a/drivers/tty/serial/8250/Kconfig
++++ b/drivers/tty/serial/8250/Kconfig
+@@ -91,6 +91,10 @@ config SERIAL_8250_CONSOLE
+ 
+ 	  If unsure, say N.
+ 
++config SERIAL_8250_SYSRQ
++	bool "Magic sysrq support on 8250/16550 devices"
++	depends on SERIAL_8250_CONSOLE
++
+ config FIX_EARLYCON_MEM
+ 	bool
+ 	depends on X86
diff --git a/target/linux/generic/patches-3.10/900-slab_maxsize.patch b/target/linux/generic/patches-3.10/900-slab_maxsize.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/900-slab_maxsize.patch
@@ -0,0 +1,13 @@
+--- a/include/linux/slab.h
++++ b/include/linux/slab.h
+@@ -189,8 +189,8 @@ struct kmem_cache {
+  * to do various tricks to work around compiler limitations in order to
+  * ensure proper constant folding.
+  */
+-#define KMALLOC_SHIFT_HIGH	((MAX_ORDER + PAGE_SHIFT - 1) <= 25 ? \
+-				(MAX_ORDER + PAGE_SHIFT - 1) : 25)
++#define KMALLOC_SHIFT_HIGH	((MAX_ORDER + PAGE_SHIFT - 1) <= 17 ? \
++				(MAX_ORDER + PAGE_SHIFT - 1) : 17)
+ #define KMALLOC_SHIFT_MAX	KMALLOC_SHIFT_HIGH
+ #ifndef KMALLOC_SHIFT_LOW
+ #define KMALLOC_SHIFT_LOW	5
diff --git a/target/linux/generic/patches-3.10/901-debloat_sock_diag.patch b/target/linux/generic/patches-3.10/901-debloat_sock_diag.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/901-debloat_sock_diag.patch
@@ -0,0 +1,45 @@
+--- a/net/Kconfig
++++ b/net/Kconfig
+@@ -87,6 +87,9 @@ source "net/netlabel/Kconfig"
+ 
+ endif # if INET
+ 
++config SOCK_DIAG
++	bool
++
+ config NETWORK_SECMARK
+ 	bool "Security Marking"
+ 	help
+--- a/net/core/Makefile
++++ b/net/core/Makefile
+@@ -9,8 +9,9 @@ obj-$(CONFIG_SYSCTL) += sysctl_net_core.
+ 
+ obj-y		     += dev.o ethtool.o dev_addr_lists.o dst.o netevent.o \
+ 			neighbour.o rtnetlink.o utils.o link_watch.o filter.o \
+-			sock_diag.o dev_ioctl.o
++			dev_ioctl.o
+ 
++obj-$(CONFIG_SOCK_DIAG) += sock_diag.o
+ obj-$(CONFIG_XFRM) += flow.o
+ obj-y += net-sysfs.o
+ obj-$(CONFIG_PROC_FS) += net-procfs.o
+--- a/net/ipv4/Kconfig
++++ b/net/ipv4/Kconfig
+@@ -411,6 +411,7 @@ config INET_LRO
+ 
+ config INET_DIAG
+ 	tristate "INET: socket monitoring interface"
++	select SOCK_DIAG
+ 	default y
+ 	---help---
+ 	  Support for INET (TCP, DCCP, etc) socket monitoring interface used by
+--- a/net/unix/Kconfig
++++ b/net/unix/Kconfig
+@@ -22,6 +22,7 @@ config UNIX
+ config UNIX_DIAG
+ 	tristate "UNIX: socket monitoring interface"
+ 	depends on UNIX
++	select SOCK_DIAG
+ 	default n
+ 	---help---
+ 	  Support for UNIX socket monitoring interface used by the ss tool.
diff --git a/target/linux/generic/patches-3.10/902-debloat_proc.patch b/target/linux/generic/patches-3.10/902-debloat_proc.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/902-debloat_proc.patch
@@ -0,0 +1,376 @@
+Index: kernel_tree/fs/locks.c
+===================================================================
+--- kernel_tree.orig/fs/locks.c
++++ kernel_tree/fs/locks.c
+@@ -2275,6 +2275,8 @@ static const struct file_operations proc
+ 
+ static int __init proc_locks_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++        return 0;
+ 	proc_create("locks", 0, NULL, &proc_locks_operations);
+ 	return 0;
+ }
+Index: kernel_tree/fs/proc/Kconfig
+===================================================================
+--- kernel_tree.orig/fs/proc/Kconfig
++++ kernel_tree/fs/proc/Kconfig
+@@ -67,3 +67,7 @@ config PROC_PAGE_MONITOR
+ 	  /proc/pid/smaps, /proc/pid/clear_refs, /proc/pid/pagemap,
+ 	  /proc/kpagecount, and /proc/kpageflags. Disabling these
+           interfaces will reduce the size of the kernel by approximately 4kb.
++config PROC_STRIPPED
++       default n
++       depends on EXPERT
++       bool "Strip non-essential /proc functionality to reduce code size"
+Index: kernel_tree/fs/proc/consoles.c
+===================================================================
+--- kernel_tree.orig/fs/proc/consoles.c
++++ kernel_tree/fs/proc/consoles.c
+@@ -108,6 +108,9 @@ static const struct file_operations proc
+ 
+ static int __init proc_consoles_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++        return 0;
++
+ 	proc_create("consoles", 0, NULL, &proc_consoles_operations);
+ 	return 0;
+ }
+Index: kernel_tree/fs/proc/proc_tty.c
+===================================================================
+--- kernel_tree.orig/fs/proc/proc_tty.c
++++ kernel_tree/fs/proc/proc_tty.c
+@@ -143,6 +143,9 @@ static const struct file_operations proc
+ void proc_tty_register_driver(struct tty_driver *driver)
+ {
+ 	struct proc_dir_entry *ent;
++
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++        	return;
+ 		
+ 	if (!driver->driver_name || driver->proc_entry ||
+ 	    !driver->ops->proc_fops)
+@@ -160,6 +163,9 @@ void proc_tty_unregister_driver(struct t
+ {
+ 	struct proc_dir_entry *ent;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++        return;
++
+ 	ent = driver->proc_entry;
+ 	if (!ent)
+ 		return;
+Index: kernel_tree/ipc/msg.c
+===================================================================
+--- kernel_tree.orig/ipc/msg.c
++++ kernel_tree/ipc/msg.c
+@@ -134,6 +134,9 @@ void __init msg_init(void)
+ 	printk(KERN_INFO "msgmni has been set to %d\n",
+ 		init_ipc_ns.msg_ctlmni);
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	ipc_init_proc_interface("sysvipc/msg",
+ 				"       key      msqid perms      cbytes       qnum lspid lrpid   uid   gid  cuid  cgid      stime      rtime      ctime\n",
+ 				IPC_MSG_IDS, sysvipc_msg_proc_show);
+Index: kernel_tree/ipc/sem.c
+===================================================================
+--- kernel_tree.orig/ipc/sem.c
++++ kernel_tree/ipc/sem.c
+@@ -191,6 +191,8 @@ void sem_exit_ns(struct ipc_namespace *n
+ void __init sem_init (void)
+ {
+ 	sem_init_ns(&init_ipc_ns);
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
+ 	ipc_init_proc_interface("sysvipc/sem",
+ 				"       key      semid perms      nsems   uid   gid  cuid  cgid      otime      ctime\n",
+ 				IPC_SEM_IDS, sysvipc_sem_proc_show);
+Index: kernel_tree/ipc/shm.c
+===================================================================
+--- kernel_tree.orig/ipc/shm.c
++++ kernel_tree/ipc/shm.c
+@@ -118,6 +118,8 @@ pure_initcall(ipc_ns_init);
+ 
+ void __init shm_init (void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
+ 	ipc_init_proc_interface("sysvipc/shm",
+ #if BITS_PER_LONG <= 32
+ 				"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\n",
+Index: kernel_tree/ipc/util.c
+===================================================================
+--- kernel_tree.orig/ipc/util.c
++++ kernel_tree/ipc/util.c
+@@ -173,6 +173,9 @@ void __init ipc_init_proc_interface(cons
+ 	struct proc_dir_entry *pde;
+ 	struct ipc_proc_iface *iface;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	iface = kmalloc(sizeof(*iface), GFP_KERNEL);
+ 	if (!iface)
+ 		return;
+Index: kernel_tree/kernel/exec_domain.c
+===================================================================
+--- kernel_tree.orig/kernel/exec_domain.c
++++ kernel_tree/kernel/exec_domain.c
+@@ -173,6 +173,9 @@ static const struct file_operations exec
+ 
+ static int __init proc_execdomains_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	proc_create("execdomains", 0, NULL, &execdomains_proc_fops);
+ 	return 0;
+ }
+Index: kernel_tree/kernel/irq/proc.c
+===================================================================
+--- kernel_tree.orig/kernel/irq/proc.c
++++ kernel_tree/kernel/irq/proc.c
+@@ -313,6 +313,9 @@ void register_irq_proc(unsigned int irq,
+ 	static DEFINE_MUTEX(register_lock);
+ 	char name [MAX_NAMELEN];
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
++		return;
++
+ 	if (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))
+ 		return;
+ 
+@@ -361,6 +364,9 @@ out_unlock:
+ void unregister_irq_proc(unsigned int irq, struct irq_desc *desc)
+ {
+ 	char name [MAX_NAMELEN];
++	
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
++		return;
+ 
+ 	if (!root_irq_dir || !desc->dir)
+ 		return;
+@@ -397,6 +403,9 @@ void init_irq_proc(void)
+ 	unsigned int irq;
+ 	struct irq_desc *desc;
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED) && !IS_ENABLED(CONFIG_SMP))
++		return;
++
+ 	/* create /proc/irq */
+ 	root_irq_dir = proc_mkdir("irq", NULL);
+ 	if (!root_irq_dir)
+Index: kernel_tree/kernel/time/timer_list.c
+===================================================================
+--- kernel_tree.orig/kernel/time/timer_list.c
++++ kernel_tree/kernel/time/timer_list.c
+@@ -361,6 +361,8 @@ static const struct file_operations time
+ static int __init init_timer_list_procfs(void)
+ {
+ 	struct proc_dir_entry *pe;
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
+ 
+ 	pe = proc_create("timer_list", 0444, NULL, &timer_list_fops);
+ 	if (!pe)
+Index: kernel_tree/mm/vmalloc.c
+===================================================================
+--- kernel_tree.orig/mm/vmalloc.c
++++ kernel_tree/mm/vmalloc.c
+@@ -2692,6 +2692,10 @@ static const struct file_operations proc
+ 
+ static int __init proc_vmalloc_init(void)
+ {
++
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	proc_create("vmallocinfo", S_IRUSR, NULL, &proc_vmalloc_operations);
+ 	return 0;
+ }
+Index: kernel_tree/mm/vmstat.c
+===================================================================
+--- kernel_tree.orig/mm/vmstat.c
++++ kernel_tree/mm/vmstat.c
+@@ -1242,10 +1242,12 @@ static int __init setup_vmstat(void)
+ 		start_cpu_timer(cpu);
+ #endif
+ #ifdef CONFIG_PROC_FS
+-	proc_create("buddyinfo", S_IRUGO, NULL, &fragmentation_file_operations);
+-	proc_create("pagetypeinfo", S_IRUGO, NULL, &pagetypeinfo_file_ops);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
++		proc_create("buddyinfo", S_IRUGO, NULL, &fragmentation_file_operations);
++		proc_create("pagetypeinfo", S_IRUGO, NULL, &pagetypeinfo_file_ops);
++		proc_create("zoneinfo", S_IRUGO, NULL, &proc_zoneinfo_file_operations);
++	}
+ 	proc_create("vmstat", S_IRUGO, NULL, &proc_vmstat_file_operations);
+-	proc_create("zoneinfo", S_IRUGO, NULL, &proc_zoneinfo_file_operations);
+ #endif
+ 	return 0;
+ }
+Index: kernel_tree/net/8021q/vlanproc.c
+===================================================================
+--- kernel_tree.orig/net/8021q/vlanproc.c
++++ kernel_tree/net/8021q/vlanproc.c
+@@ -127,6 +127,12 @@ void vlan_proc_cleanup(struct net *net)
+ {
+ 	struct vlan_net *vn = net_generic(net, vlan_net_id);
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return;
++
+ 	if (vn->proc_vlan_conf)
+ 		remove_proc_entry(name_conf, vn->proc_vlan_dir);
+ 
+@@ -146,6 +152,12 @@ int __net_init vlan_proc_init(struct net
+ {
+ 	struct vlan_net *vn = net_generic(net, vlan_net_id);
+ 
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	vn->proc_vlan_dir = proc_net_mkdir(net, name_root, net->proc_net);
+ 	if (!vn->proc_vlan_dir)
+ 		goto err;
+Index: kernel_tree/net/core/net-procfs.c
+===================================================================
+--- kernel_tree.orig/net/core/net-procfs.c
++++ kernel_tree/net/core/net-procfs.c
+@@ -306,10 +306,12 @@ static int __net_init dev_proc_net_init(
+ 
+ 	if (!proc_create("dev", S_IRUGO, net->proc_net, &dev_seq_fops))
+ 		goto out;
+-	if (!proc_create("softnet_stat", S_IRUGO, net->proc_net,
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++		!proc_create("softnet_stat", S_IRUGO, net->proc_net,
+ 			 &softnet_seq_fops))
+ 		goto out_dev;
+-	if (!proc_create("ptype", S_IRUGO, net->proc_net, &ptype_seq_fops))
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++		!proc_create("ptype", S_IRUGO, net->proc_net, &ptype_seq_fops))
+ 		goto out_softnet;
+ 
+ 	if (wext_proc_init(net))
+@@ -318,9 +320,11 @@ static int __net_init dev_proc_net_init(
+ out:
+ 	return rc;
+ out_ptype:
+-	remove_proc_entry("ptype", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("ptype", net->proc_net);
+ out_softnet:
+-	remove_proc_entry("softnet_stat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("softnet_stat", net->proc_net);
+ out_dev:
+ 	remove_proc_entry("dev", net->proc_net);
+ 	goto out;
+@@ -330,8 +334,10 @@ static void __net_exit dev_proc_net_exit
+ {
+ 	wext_proc_exit(net);
+ 
+-	remove_proc_entry("ptype", net->proc_net);
+-	remove_proc_entry("softnet_stat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
++		remove_proc_entry("ptype", net->proc_net);
++		remove_proc_entry("softnet_stat", net->proc_net);
++	}
+ 	remove_proc_entry("dev", net->proc_net);
+ }
+ 
+Index: kernel_tree/net/core/sock.c
+===================================================================
+--- kernel_tree.orig/net/core/sock.c
++++ kernel_tree/net/core/sock.c
+@@ -2889,6 +2889,9 @@ static __net_initdata struct pernet_oper
+ 
+ static int __init proto_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	return register_pernet_subsys(&proto_net_ops);
+ }
+ 
+Index: kernel_tree/net/ipv4/fib_trie.c
+===================================================================
+--- kernel_tree.orig/net/ipv4/fib_trie.c
++++ kernel_tree/net/ipv4/fib_trie.c
+@@ -2587,10 +2587,12 @@ static const struct file_operations fib_
+ 
+ int __net_init fib_proc_init(struct net *net)
+ {
+-	if (!proc_create("fib_trie", S_IRUGO, net->proc_net, &fib_trie_fops))
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++		!proc_create("fib_trie", S_IRUGO, net->proc_net, &fib_trie_fops))
+ 		goto out1;
+ 
+-	if (!proc_create("fib_triestat", S_IRUGO, net->proc_net,
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED) &&
++		!proc_create("fib_triestat", S_IRUGO, net->proc_net,
+ 			 &fib_triestat_fops))
+ 		goto out2;
+ 
+@@ -2600,17 +2602,21 @@ int __net_init fib_proc_init(struct net
+ 	return 0;
+ 
+ out3:
+-	remove_proc_entry("fib_triestat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("fib_triestat", net->proc_net);
+ out2:
+-	remove_proc_entry("fib_trie", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED))
++		remove_proc_entry("fib_trie", net->proc_net);
+ out1:
+ 	return -ENOMEM;
+ }
+ 
+ void __net_exit fib_proc_exit(struct net *net)
+ {
+-	remove_proc_entry("fib_trie", net->proc_net);
+-	remove_proc_entry("fib_triestat", net->proc_net);
++	if (!IS_ENABLED(CONFIG_PROC_STRIPPED)) {
++		remove_proc_entry("fib_trie", net->proc_net);
++		remove_proc_entry("fib_triestat", net->proc_net);
++	}
+ 	remove_proc_entry("route", net->proc_net);
+ }
+ 
+Index: kernel_tree/net/ipv4/proc.c
+===================================================================
+--- kernel_tree.orig/net/ipv4/proc.c
++++ kernel_tree/net/ipv4/proc.c
+@@ -510,6 +510,9 @@ static __net_initdata struct pernet_oper
+ 
+ int __init ip_misc_proc_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	return register_pernet_subsys(&ip_proc_ops);
+ }
+ 
+Index: kernel_tree/net/ipv4/route.c
+===================================================================
+--- kernel_tree.orig/net/ipv4/route.c
++++ kernel_tree/net/ipv4/route.c
+@@ -424,6 +424,9 @@ static struct pernet_operations ip_rt_pr
+ 
+ static int __init ip_rt_proc_init(void)
+ {
++	if (IS_ENABLED(CONFIG_PROC_STRIPPED))
++		return 0;
++
+ 	return register_pernet_subsys(&ip_rt_proc_ops);
+ }
+ 
diff --git a/target/linux/generic/patches-3.10/903-debloat_direct_io.patch b/target/linux/generic/patches-3.10/903-debloat_direct_io.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/903-debloat_direct_io.patch
@@ -0,0 +1,94 @@
+Index: kernel_tree/fs/Kconfig
+===================================================================
+--- kernel_tree.orig/fs/Kconfig
++++ kernel_tree/fs/Kconfig
+@@ -62,6 +62,11 @@ config FILE_LOCKING
+           for filesystems like NFS and for the flock() system
+           call. Disabling this option saves about 11k.
+ 
++config DIRECT_IO
++	bool "Enable O_DIRECT support" if EXPERT
++	depends on BLOCK
++	default y
++
+ source "fs/notify/Kconfig"
+ 
+ source "fs/quota/Kconfig"
+Index: kernel_tree/fs/Makefile
+===================================================================
+--- kernel_tree.orig/fs/Makefile
++++ kernel_tree/fs/Makefile
+@@ -14,7 +14,8 @@ obj-y :=	open.o read_write.o file_table.
+ 		stack.o fs_struct.o statfs.o
+ 
+ ifeq ($(CONFIG_BLOCK),y)
+-obj-y +=	buffer.o bio.o block_dev.o direct-io.o mpage.o ioprio.o
++obj-y +=	buffer.o bio.o block_dev.o mpage.o ioprio.o
++obj-$(CONFIG_DIRECT_IO) += direct-io.o
+ else
+ obj-y +=	no-block.o
+ endif
+Index: kernel_tree/include/linux/fs.h
+===================================================================
+--- kernel_tree.orig/include/linux/fs.h
++++ kernel_tree/include/linux/fs.h
+@@ -2457,12 +2457,26 @@ enum {
+ 	DIO_SKIP_HOLES	= 0x02,
+ };
+ 
++#ifdef CONFIG_DIRECT_IO
+ void dio_end_io(struct bio *bio, int error);
+ 
+ ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
+ 	struct block_device *bdev, const struct iovec *iov, loff_t offset,
+ 	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
+ 	dio_submit_t submit_io,	int flags);
++#else
++static inline void dio_end_io(struct bio *bio, int error)
++{
++}
++static inline ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
++	struct block_device *bdev, const struct iovec *iov, loff_t offset,
++	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
++	dio_submit_t submit_io,	int flags)
++{
++	return -EOPNOTSUPP;
++}
++#endif
++
+ 
+ static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
+ 		struct inode *inode, const struct iovec *iov, loff_t offset,
+Index: kernel_tree/fs/fcntl.c
+===================================================================
+--- kernel_tree.orig/fs/fcntl.c
++++ kernel_tree/fs/fcntl.c
+@@ -51,8 +51,10 @@ static int setfl(int fd, struct file * f
+ 		   arg |= O_NONBLOCK;
+ 
+ 	if (arg & O_DIRECT) {
++#ifdef CONFIG_DIRECT_IO
+ 		if (!filp->f_mapping || !filp->f_mapping->a_ops ||
+ 			!filp->f_mapping->a_ops->direct_IO)
++#endif
+ 				return -EINVAL;
+ 	}
+ 
+Index: kernel_tree/fs/open.c
+===================================================================
+--- kernel_tree.orig/fs/open.c
++++ kernel_tree/fs/open.c
+@@ -641,9 +641,12 @@ int open_check_o_direct(struct file *f)
+ {
+ 	/* NB: we're sure to have correct a_ops only after f_op->open */
+ 	if (f->f_flags & O_DIRECT) {
++#ifdef CONFIG_DIRECT_IO
+ 		if (!f->f_mapping->a_ops ||
+ 		    ((!f->f_mapping->a_ops->direct_IO) &&
+-		    (!f->f_mapping->a_ops->get_xip_mem))) {
++		    (!f->f_mapping->a_ops->get_xip_mem)))
++#endif
++		{
+ 			return -EINVAL;
+ 		}
+ 	}
diff --git a/target/linux/generic/patches-3.10/910-kobject_uevent.patch b/target/linux/generic/patches-3.10/910-kobject_uevent.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/910-kobject_uevent.patch
@@ -0,0 +1,21 @@
+--- a/lib/kobject_uevent.c
++++ b/lib/kobject_uevent.c
+@@ -51,6 +51,18 @@ static const char *kobject_actions[] = {
+ 	[KOBJ_OFFLINE] =	"offline",
+ };
+ 
++u64 uevent_next_seqnum(void)
++{
++	u64 seq;
++
++	mutex_lock(&uevent_sock_mutex);
++	seq = ++uevent_seqnum;
++	mutex_unlock(&uevent_sock_mutex);
++
++	return seq;
++}
++EXPORT_SYMBOL_GPL(uevent_next_seqnum);
++
+ /**
+  * kobject_action_type - translate action string to numeric type
+  *
diff --git a/target/linux/generic/patches-3.10/911-kobject_add_broadcast_uevent.patch b/target/linux/generic/patches-3.10/911-kobject_add_broadcast_uevent.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/911-kobject_add_broadcast_uevent.patch
@@ -0,0 +1,65 @@
+--- a/include/linux/kobject.h
++++ b/include/linux/kobject.h
+@@ -31,6 +31,8 @@
+ #define UEVENT_NUM_ENVP			32	/* number of env pointers */
+ #define UEVENT_BUFFER_SIZE		2048	/* buffer for the variables */
+ 
++struct sk_buff;
++
+ /* path to the userspace helper executed on an event */
+ extern char uevent_helper[];
+ 
+@@ -213,4 +215,7 @@ int add_uevent_var(struct kobj_uevent_en
+ int kobject_action_type(const char *buf, size_t count,
+ 			enum kobject_action *type);
+ 
++int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
++		     gfp_t allocation);
++
+ #endif /* _KOBJECT_H_ */
+--- a/lib/kobject_uevent.c
++++ b/lib/kobject_uevent.c
+@@ -382,6 +382,43 @@ int add_uevent_var(struct kobj_uevent_en
+ EXPORT_SYMBOL_GPL(add_uevent_var);
+ 
+ #if defined(CONFIG_NET)
++int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
++		     gfp_t allocation)
++{
++	struct uevent_sock *ue_sk;
++	int err = 0;
++
++	/* send netlink message */
++	mutex_lock(&uevent_sock_mutex);
++	list_for_each_entry(ue_sk, &uevent_sock_list, list) {
++		struct sock *uevent_sock = ue_sk->sk;
++		struct sk_buff *skb2;
++
++		skb2 = skb_clone(skb, allocation);
++		if (!skb2)
++			break;
++
++		err = netlink_broadcast(uevent_sock, skb2, pid, group,
++					allocation);
++		if (err)
++			break;
++	}
++	mutex_unlock(&uevent_sock_mutex);
++
++	kfree_skb(skb);
++	return err;
++}
++#else
++int broadcast_uevent(struct sk_buff *skb, __u32 pid, __u32 group,
++		     gfp_t allocation)
++{
++	kfree_skb(skb);
++	return 0;
++}
++#endif
++EXPORT_SYMBOL_GPL(broadcast_uevent);
++
++#if defined(CONFIG_NET)
+ static int uevent_net_init(struct net *net)
+ {
+ 	struct uevent_sock *ue_sk;
diff --git a/target/linux/generic/patches-3.10/921-use_preinit_as_init.patch b/target/linux/generic/patches-3.10/921-use_preinit_as_init.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/921-use_preinit_as_init.patch
@@ -0,0 +1,14 @@
+Index: kernel_tree/init/main.c
+===================================================================
+--- kernel_tree.orig/init/main.c
++++ kernel_tree/init/main.c
+@@ -844,7 +844,8 @@ static int __ref kernel_init(void *unuse
+ 		pr_err("Failed to execute %s.  Attempting defaults...\n",
+ 			execute_command);
+ 	}
+-	if (!run_init_process("/sbin/init") ||
++	if (!run_init_process("/etc/preinit") ||
++	    !run_init_process("/sbin/init") ||
+ 	    !run_init_process("/etc/init") ||
+ 	    !run_init_process("/bin/init") ||
+ 	    !run_init_process("/bin/sh"))
diff --git a/target/linux/generic/patches-3.10/922-always-create-console-node-in-initramfs.patch b/target/linux/generic/patches-3.10/922-always-create-console-node-in-initramfs.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/922-always-create-console-node-in-initramfs.patch
@@ -0,0 +1,30 @@
+--- a/scripts/gen_initramfs_list.sh
++++ b/scripts/gen_initramfs_list.sh
+@@ -59,6 +59,18 @@ default_initramfs() {
+ 	EOF
+ }
+ 
++list_openwrt_initramfs() {
++	:
++}
++
++openwrt_initramfs() {
++	# make sure that /dev/console exists
++	cat <<-EOF >> ${output}
++		dir /dev 0755 0 0
++		nod /dev/console 0600 0 0 c 5 1
++	EOF
++}
++
+ filetype() {
+ 	local argv1="$1"
+ 
+@@ -177,6 +189,8 @@ dir_filelist() {
+ 	if [  "$(echo "${dirlist}" | wc -l)" -gt 1 ]; then
+ 		${dep_list}print_mtime "$1"
+ 
++		${dep_list}openwrt_initramfs
++
+ 		echo "${dirlist}" | \
+ 		while read x; do
+ 			${dep_list}parse ${x}
diff --git a/target/linux/generic/patches-3.10/930-crashlog.patch b/target/linux/generic/patches-3.10/930-crashlog.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/930-crashlog.patch
@@ -0,0 +1,276 @@
+--- /dev/null
++++ b/include/linux/crashlog.h
+@@ -0,0 +1,17 @@
++#ifndef __CRASHLOG_H
++#define __CRASHLOG_H
++
++#ifdef CONFIG_CRASHLOG
++void crashlog_init_bootmem(struct bootmem_data *bdata);
++void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size);
++#else
++static inline void crashlog_init_bootmem(struct bootmem_data *bdata)
++{
++}
++
++static inline void crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
++{
++}
++#endif
++
++#endif
+--- a/init/Kconfig
++++ b/init/Kconfig
+@@ -1186,6 +1186,10 @@ config RELAY
+ 
+ 	  If unsure, say N.
+ 
++config CRASHLOG
++	bool "Crash logging"
++	depends on (!NO_BOOTMEM || HAVE_MEMBLOCK) && !(ARM || SPARC || PPC)
++
+ config BLK_DEV_INITRD
+ 	bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
+ 	depends on BROKEN || !FRV
+--- a/kernel/Makefile
++++ b/kernel/Makefile
+@@ -110,6 +110,7 @@ obj-$(CONFIG_PADATA) += padata.o
+ obj-$(CONFIG_CRASH_DUMP) += crash_dump.o
+ obj-$(CONFIG_JUMP_LABEL) += jump_label.o
+ obj-$(CONFIG_CONTEXT_TRACKING) += context_tracking.o
++obj-$(CONFIG_CRASHLOG) += crashlog.o
+ 
+ $(obj)/configs.o: $(obj)/config_data.h
+ 
+--- /dev/null
++++ b/kernel/crashlog.c
+@@ -0,0 +1,181 @@
++/*
++ * Crash information logger
++ * Copyright (C) 2010 Felix Fietkau <nbd@openwrt.org>
++ *
++ * Based on ramoops.c
++ *   Copyright (C) 2010 Marco Stornelli <marco.stornelli@gmail.com>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * version 2 as published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ *
++ */
++
++#include <linux/module.h>
++#include <linux/bootmem.h>
++#include <linux/memblock.h>
++#include <linux/debugfs.h>
++#include <linux/crashlog.h>
++#include <linux/kmsg_dump.h>
++#include <linux/module.h>
++#include <linux/pfn.h>
++#include <asm/io.h>
++
++#define CRASHLOG_PAGES	4
++#define CRASHLOG_SIZE	(CRASHLOG_PAGES * PAGE_SIZE)
++#define CRASHLOG_MAGIC	0xa1eedead
++
++/*
++ * Start the log at 1M before the end of RAM, as some boot loaders like
++ * to use the end of the RAM for stack usage and other things
++ * If this fails, fall back to using the last part.
++ */
++#define CRASHLOG_OFFSET	(1024 * 1024)
++
++struct crashlog_data {
++	u32 magic;
++	u32 len;
++	u8 data[];
++};
++
++static struct debugfs_blob_wrapper crashlog_blob;
++static unsigned long crashlog_addr = 0;
++static struct crashlog_data *crashlog_buf;
++static struct kmsg_dumper dump;
++static bool first = true;
++
++extern struct list_head *crashlog_modules;
++
++#ifndef CONFIG_NO_BOOTMEM
++void __init crashlog_init_bootmem(bootmem_data_t *bdata)
++{
++	unsigned long addr;
++
++	if (crashlog_addr)
++		return;
++
++	addr = PFN_PHYS(bdata->node_low_pfn) - CRASHLOG_OFFSET;
++	if (reserve_bootmem(addr, CRASHLOG_SIZE, BOOTMEM_EXCLUSIVE) < 0) {
++		printk("Crashlog failed to allocate RAM at address 0x%lx\n", addr);
++		bdata->node_low_pfn -= CRASHLOG_PAGES;
++		addr = PFN_PHYS(bdata->node_low_pfn);
++	}
++	crashlog_addr = addr;
++}
++#endif
++
++#ifdef CONFIG_HAVE_MEMBLOCK
++void __meminit crashlog_init_memblock(phys_addr_t addr, phys_addr_t size)
++{
++	if (crashlog_addr)
++		return;
++
++	addr += size - CRASHLOG_OFFSET;
++	if (memblock_reserve(addr, CRASHLOG_SIZE)) {
++		printk("Crashlog failed to allocate RAM at address 0x%lx\n", (unsigned long) addr);
++		return;
++	}
++
++	crashlog_addr = addr;
++}
++#endif
++
++static void __init crashlog_copy(void)
++{
++	if (crashlog_buf->magic != CRASHLOG_MAGIC)
++		return;
++
++	if (!crashlog_buf->len || crashlog_buf->len >
++	    CRASHLOG_SIZE - sizeof(*crashlog_buf))
++		return;
++
++	crashlog_blob.size = crashlog_buf->len;
++	crashlog_blob.data = kmemdup(crashlog_buf->data,
++		crashlog_buf->len, GFP_KERNEL);
++
++	debugfs_create_blob("crashlog", 0700, NULL, &crashlog_blob);
++}
++
++static int get_maxlen(void)
++{
++	return CRASHLOG_SIZE - sizeof(*crashlog_buf) - crashlog_buf->len;
++}
++
++static void crashlog_printf(const char *fmt, ...)
++{
++	va_list args;
++	int len = get_maxlen();
++
++	if (!len)
++		return;
++
++	va_start(args, fmt);
++	crashlog_buf->len += vscnprintf(
++		&crashlog_buf->data[crashlog_buf->len],
++		len, fmt, args);
++	va_end(args);
++}
++
++static void crashlog_do_dump(struct kmsg_dumper *dumper,
++		enum kmsg_dump_reason reason)
++{
++	struct timeval tv;
++	struct module *m;
++	char *buf;
++	size_t len;
++
++	if (!first)
++		crashlog_printf("\n===================================\n");
++
++	do_gettimeofday(&tv);
++	crashlog_printf("Time: %lu.%lu\n",
++		(long)tv.tv_sec, (long)tv.tv_usec);
++
++	if (first) {
++		crashlog_printf("Modules:");
++		list_for_each_entry(m, crashlog_modules, list) {
++			crashlog_printf("\t%s@%p+%x", m->name,
++			m->module_core, m->core_size,
++			m->module_init, m->init_size);
++		}
++		crashlog_printf("\n");
++		first = false;
++	}
++
++	buf = (char *)&crashlog_buf->data[crashlog_buf->len];
++
++	kmsg_dump_get_buffer(dumper, true, buf, get_maxlen(), &len);
++
++	crashlog_buf->len += len;
++}
++
++
++int __init crashlog_init_fs(void)
++{
++	if (!crashlog_addr)
++		return -ENOMEM;
++
++	crashlog_buf = ioremap(crashlog_addr, CRASHLOG_SIZE);
++
++	crashlog_copy();
++
++	crashlog_buf->magic = CRASHLOG_MAGIC;
++	crashlog_buf->len = 0;
++
++	dump.max_reason = KMSG_DUMP_OOPS;
++	dump.dump = crashlog_do_dump;
++	kmsg_dump_register(&dump);
++
++	return 0;
++}
++module_init(crashlog_init_fs);
+--- a/mm/bootmem.c
++++ b/mm/bootmem.c
+@@ -15,6 +15,7 @@
+ #include <linux/export.h>
+ #include <linux/kmemleak.h>
+ #include <linux/range.h>
++#include <linux/crashlog.h>
+ #include <linux/memblock.h>
+ 
+ #include <asm/bug.h>
+@@ -177,6 +178,7 @@ static unsigned long __init free_all_boo
+ 	if (!bdata->node_bootmem_map)
+ 		return 0;
+ 
++	crashlog_init_bootmem(bdata);
+ 	start = bdata->node_min_pfn;
+ 	end = bdata->node_low_pfn;
+ 
+--- a/kernel/module.c
++++ b/kernel/module.c
+@@ -106,6 +106,9 @@ static LIST_HEAD(modules);
+ #ifdef CONFIG_KGDB_KDB
+ struct list_head *kdb_modules = &modules; /* kdb needs the list of modules */
+ #endif /* CONFIG_KGDB_KDB */
++#ifdef CONFIG_CRASHLOG
++struct list_head *crashlog_modules = &modules;
++#endif
+ 
+ #ifdef CONFIG_MODULE_SIG
+ #ifdef CONFIG_MODULE_SIG_FORCE
+--- a/mm/memblock.c
++++ b/mm/memblock.c
+@@ -19,6 +19,7 @@
+ #include <linux/debugfs.h>
+ #include <linux/seq_file.h>
+ #include <linux/memblock.h>
++#include <linux/crashlog.h>
+ 
+ static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
+ static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
+@@ -344,6 +345,8 @@ static void __init_memblock memblock_ins
+ 	memblock_set_region_node(rgn, nid);
+ 	type->cnt++;
+ 	type->total_size += size;
++	if (type == &memblock.memory && idx == 0)
++		crashlog_init_memblock(base, size);
+ }
+ 
+ /**
diff --git a/target/linux/generic/patches-3.10/940-ocf_kbuild_integration.patch b/target/linux/generic/patches-3.10/940-ocf_kbuild_integration.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/940-ocf_kbuild_integration.patch
@@ -0,0 +1,20 @@
+--- a/crypto/Kconfig
++++ b/crypto/Kconfig
+@@ -1406,3 +1406,6 @@ source "drivers/crypto/Kconfig"
+ source crypto/asymmetric_keys/Kconfig
+ 
+ endif	# if CRYPTO
++
++source "crypto/ocf/Kconfig"
++
+--- a/crypto/Makefile
++++ b/crypto/Makefile
+@@ -96,6 +96,8 @@ obj-$(CONFIG_CRYPTO_USER_API) += af_alg.
+ obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
+ obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
+ 
++obj-$(CONFIG_OCF_OCF) += ocf/
++
+ #
+ # generic algorithms and the async_tx api
+ #
diff --git a/target/linux/generic/patches-3.10/941-ocf_20120127.patch b/target/linux/generic/patches-3.10/941-ocf_20120127.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/941-ocf_20120127.patch
@@ -0,0 +1,178 @@
+Index: kernel_tree/drivers/char/random.c
+===================================================================
+--- kernel_tree.orig/drivers/char/random.c
++++ kernel_tree/drivers/char/random.c
+@@ -139,6 +139,9 @@
+  * that might otherwise be identical and have very little entropy
+  * available to them (particularly common in the embedded world).
+  *
++ *      void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
++ *      int random_input_wait(void);
++ *
+  * add_input_randomness() uses the input layer interrupt timing, as well as
+  * the event type information from the hardware.
+  *
+@@ -152,6 +155,13 @@
+  * seek times do not make for good sources of entropy, as their seek
+  * times are usually fairly consistent.
+  *
++ * random_input_words() just provides a raw block of entropy to the input
++ * pool, such as from a hardware entropy generator.
++ *
++ * random_input_wait() suspends the caller until such time as the
++ * entropy pool falls below the write threshold, and returns a count of how
++ * much entropy (in bits) is needed to sustain the pool.
++ *
+  * All of these routines try to estimate how many bits of randomness a
+  * particular randomness source.  They do this by keeping track of the
+  * first and second order deltas of the event timings.
+@@ -796,6 +806,63 @@ void add_disk_randomness(struct gendisk
+ }
+ #endif
+ 
++/*
++ * random_input_words - add bulk entropy to pool
++ *
++ * @buf: buffer to add
++ * @wordcount: number of __u32 words to add
++ * @ent_count: total amount of entropy (in bits) to credit
++ *
++ * this provides bulk input of entropy to the input pool
++ *
++ */
++void random_input_words(__u32 *buf, size_t wordcount, int ent_count)
++{
++	mix_pool_bytes(&input_pool, buf, wordcount*4, NULL);
++
++	credit_entropy_bits(&input_pool, ent_count);
++
++	DEBUG_ENT("crediting %d bits => %d\n",
++		  ent_count, input_pool.entropy_count);
++	/*
++	 * Wake up waiting processes if we have enough
++	 * entropy.
++	 */
++	if (input_pool.entropy_count >= random_read_wakeup_thresh)
++		wake_up_interruptible(&random_read_wait);
++}
++EXPORT_SYMBOL(random_input_words);
++
++/*
++ * random_input_wait - wait until random needs entropy
++ *
++ * this function sleeps until the /dev/random subsystem actually
++ * needs more entropy, and then return the amount of entropy
++ * that it would be nice to have added to the system.
++ */
++int random_input_wait(void)
++{
++	int count;
++
++	wait_event_interruptible(random_write_wait, 
++			 input_pool.entropy_count < random_write_wakeup_thresh);
++
++	count = random_write_wakeup_thresh - input_pool.entropy_count;
++
++        /* likely we got woken up due to a signal */
++	if (count <= 0) count = random_read_wakeup_thresh; 
++
++	DEBUG_ENT("requesting %d bits from input_wait()er %d<%d\n",
++		  count,
++		  input_pool.entropy_count, random_write_wakeup_thresh);
++
++	return count;
++}
++EXPORT_SYMBOL(random_input_wait);
++
++
++#define EXTRACT_SIZE 10
++
+ /*********************************************************************
+  *
+  * Entropy extraction routines
+Index: kernel_tree/fs/fcntl.c
+===================================================================
+--- kernel_tree.orig/fs/fcntl.c
++++ kernel_tree/fs/fcntl.c
+@@ -148,6 +148,7 @@ pid_t f_getown(struct file *filp)
+ 	read_unlock(&filp->f_owner.lock);
+ 	return pid;
+ }
++EXPORT_SYMBOL(sys_dup);
+ 
+ static int f_setown_ex(struct file *filp, unsigned long arg)
+ {
+Index: kernel_tree/include/linux/miscdevice.h
+===================================================================
+--- kernel_tree.orig/include/linux/miscdevice.h
++++ kernel_tree/include/linux/miscdevice.h
+@@ -19,6 +19,7 @@
+ #define APOLLO_MOUSE_MINOR	7
+ #define PC110PAD_MINOR		9
+ /*#define ADB_MOUSE_MINOR	10	FIXME OBSOLETE */
++#define CRYPTODEV_MINOR		70	/* /dev/crypto */
+ #define WATCHDOG_MINOR		130	/* Watchdog timer     */
+ #define TEMP_MINOR		131	/* Temperature Sensor */
+ #define RTC_MINOR		135
+Index: kernel_tree/include/uapi/linux/random.h
+===================================================================
+--- kernel_tree.orig/include/uapi/linux/random.h
++++ kernel_tree/include/uapi/linux/random.h
+@@ -34,6 +34,30 @@
+ /* Clear the entropy pool and associated counters.  (Superuser only.) */
+ #define RNDCLEARPOOL	_IO( 'R', 0x06 )
+ 
++#ifdef CONFIG_FIPS_RNG
++
++/* Size of seed value - equal to AES blocksize */
++#define AES_BLOCK_SIZE_BYTES	16
++#define SEED_SIZE_BYTES			AES_BLOCK_SIZE_BYTES
++/* Size of AES key */
++#define KEY_SIZE_BYTES		16
++
++/* ioctl() structure used by FIPS 140-2 Tests */
++struct rand_fips_test {
++	unsigned char key[KEY_SIZE_BYTES];			/* Input */
++	unsigned char datetime[SEED_SIZE_BYTES];	/* Input */
++	unsigned char seed[SEED_SIZE_BYTES];		/* Input */
++	unsigned char result[SEED_SIZE_BYTES];		/* Output */
++};
++
++/* FIPS 140-2 RNG Variable Seed Test. (Superuser only.) */
++#define RNDFIPSVST	_IOWR('R', 0x10, struct rand_fips_test)
++
++/* FIPS 140-2 RNG Monte Carlo Test. (Superuser only.) */
++#define RNDFIPSMCT	_IOWR('R', 0x11, struct rand_fips_test)
++
++#endif /* #ifdef CONFIG_FIPS_RNG */
++
+ struct rand_pool_info {
+ 	int	entropy_count;
+ 	int	buf_size;
+Index: kernel_tree/include/linux/random.h
+===================================================================
+--- kernel_tree.orig/include/linux/random.h
++++ kernel_tree/include/linux/random.h
+@@ -14,6 +14,10 @@ extern void add_input_randomness(unsigne
+ 				 unsigned int value);
+ extern void add_interrupt_randomness(int irq, int irq_flags);
+ 
++extern void random_input_words(__u32 *buf, size_t wordcount, int ent_count);
++extern int random_input_wait(void);
++#define HAS_RANDOM_INPUT_WAIT 1
++
+ extern void get_random_bytes(void *buf, int nbytes);
+ extern void get_random_bytes_arch(void *buf, int nbytes);
+ void generate_random_uuid(unsigned char uuid_out[16]);
+Index: kernel_tree/kernel/pid.c
+===================================================================
+--- kernel_tree.orig/kernel/pid.c
++++ kernel_tree/kernel/pid.c
+@@ -425,6 +425,7 @@ void transfer_pid(struct task_struct *ol
+ 	new->pids[type].pid = old->pids[type].pid;
+ 	hlist_replace_rcu(&old->pids[type].node, &new->pids[type].node);
+ }
++EXPORT_SYMBOL(find_task_by_vpid);
+ 
+ struct task_struct *pid_task(struct pid *pid, enum pid_type type)
+ {
diff --git a/target/linux/generic/patches-3.10/950-vm_exports.patch b/target/linux/generic/patches-3.10/950-vm_exports.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/950-vm_exports.patch
@@ -0,0 +1,115 @@
+Index: kernel_tree/mm/shmem.c
+===================================================================
+--- kernel_tree.orig/mm/shmem.c
++++ kernel_tree/mm/shmem.c
+@@ -2965,6 +2965,15 @@ static struct dentry_operations anon_ops
+ 	.d_dname = simple_dname
+ };
+ 
++void shmem_set_file(struct vm_area_struct *vma, struct file *file)
++{
++	if (vma->vm_file)
++		fput(vma->vm_file);
++	vma->vm_file = file;
++	vma->vm_ops = &shmem_vm_ops;
++}
++EXPORT_SYMBOL_GPL(shmem_set_file);
++
+ /**
+  * shmem_file_setup - get an unlinked file living in tmpfs
+  * @name: name for dentry (to be seen in /proc/<pid>/maps
+@@ -3038,11 +3047,8 @@ int shmem_zero_setup(struct vm_area_stru
+ 	file = shmem_file_setup("dev/zero", size, vma->vm_flags);
+ 	if (IS_ERR(file))
+ 		return PTR_ERR(file);
++	shmem_set_file(vma, file);
+ 
+-	if (vma->vm_file)
+-		fput(vma->vm_file);
+-	vma->vm_file = file;
+-	vma->vm_ops = &shmem_vm_ops;
+ 	return 0;
+ }
+ 
+Index: kernel_tree/fs/file.c
+===================================================================
+--- kernel_tree.orig/fs/file.c
++++ kernel_tree/fs/file.c
+@@ -218,6 +218,7 @@ static inline void __set_open_fd(int fd,
+ {
+ 	__set_bit(fd, fdt->open_fds);
+ }
++EXPORT_SYMBOL_GPL(expand_files);
+ 
+ static inline void __clear_open_fd(int fd, struct fdtable *fdt)
+ {
+Index: kernel_tree/kernel/exit.c
+===================================================================
+--- kernel_tree.orig/kernel/exit.c
++++ kernel_tree/kernel/exit.c
+@@ -502,6 +502,8 @@ static void exit_mm(struct task_struct *
+ 	mm_update_next_owner(mm);
+ 	mmput(mm);
+ }
++EXPORT_SYMBOL_GPL(get_files_struct);
++EXPORT_SYMBOL_GPL(put_files_struct);
+ 
+ /*
+  * When we die, we re-parent all our children, and try to:
+Index: kernel_tree/kernel/sched/core.c
+===================================================================
+--- kernel_tree.orig/kernel/sched/core.c
++++ kernel_tree/kernel/sched/core.c
+@@ -3718,6 +3718,7 @@ int can_nice(const struct task_struct *p
+ 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||
+ 		capable(CAP_SYS_NICE));
+ }
++EXPORT_SYMBOL_GPL(can_nice);
+ 
+ #ifdef __ARCH_WANT_SYS_NICE
+ 
+Index: kernel_tree/mm/memory.c
+===================================================================
+--- kernel_tree.orig/mm/memory.c
++++ kernel_tree/mm/memory.c
+@@ -1413,6 +1413,7 @@ void zap_page_range(struct vm_area_struc
+ 	mmu_notifier_invalidate_range_end(mm, start, end);
+ 	tlb_finish_mmu(&tlb, start, end);
+ }
++EXPORT_SYMBOL_GPL(zap_page_range);
+ 
+ /**
+  * zap_page_range_single - remove user pages in a given range
+Index: kernel_tree/mm/vmalloc.c
+===================================================================
+--- kernel_tree.orig/mm/vmalloc.c
++++ kernel_tree/mm/vmalloc.c
+@@ -1281,6 +1281,7 @@ void unmap_kernel_range(unsigned long ad
+ 	vunmap_page_range(addr, end);
+ 	flush_tlb_kernel_range(addr, end);
+ }
++EXPORT_SYMBOL_GPL(unmap_kernel_range);
+ 
+ int map_vm_area(struct vm_struct *area, pgprot_t prot, struct page ***pages)
+ {
+@@ -1412,6 +1413,7 @@ struct vm_struct *get_vm_area(unsigned l
+ 				  NUMA_NO_NODE, GFP_KERNEL,
+ 				  __builtin_return_address(0));
+ }
++EXPORT_SYMBOL_GPL(get_vm_area);
+ 
+ struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,
+ 				const void *caller)
+Index: kernel_tree/include/linux/shmem_fs.h
+===================================================================
+--- kernel_tree.orig/include/linux/shmem_fs.h
++++ kernel_tree/include/linux/shmem_fs.h
+@@ -47,6 +47,8 @@ extern int shmem_init(void);
+ extern int shmem_fill_super(struct super_block *sb, void *data, int silent);
+ extern struct file *shmem_file_setup(const char *name,
+ 					loff_t size, unsigned long flags);
++
++extern void shmem_set_file(struct vm_area_struct *vma, struct file *file);
+ extern int shmem_zero_setup(struct vm_area_struct *);
+ extern int shmem_lock(struct file *file, int lock, struct user_struct *user);
+ extern void shmem_unlock_mapping(struct address_space *mapping);
diff --git a/target/linux/generic/patches-3.10/960-decompress_unlzo_fix.patch b/target/linux/generic/patches-3.10/960-decompress_unlzo_fix.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/960-decompress_unlzo_fix.patch
@@ -0,0 +1,23 @@
+--- /dev/null
++++ b/include/linux/decompress/unlzo_mm.h
+@@ -0,0 +1,10 @@
++#ifndef UNLZO_MM_H
++#define UNLZO_MM_H
++
++#ifdef STATIC
++#define INIT
++#else
++#define INIT __init
++#endif
++
++#endif
+--- a/lib/decompress_unlzo.c
++++ b/lib/decompress_unlzo.c
+@@ -38,6 +38,7 @@
+ 
+ #include <linux/types.h>
+ #include <linux/lzo.h>
++#include <linux/decompress/unlzo_mm.h>
+ #include <linux/decompress/mm.h>
+ 
+ #include <linux/compiler.h>
diff --git a/target/linux/generic/patches-3.10/970-remove-unsane-filenames-from-deps_initramfs-list.patch b/target/linux/generic/patches-3.10/970-remove-unsane-filenames-from-deps_initramfs-list.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/970-remove-unsane-filenames-from-deps_initramfs-list.patch
@@ -0,0 +1,28 @@
+--- a/usr/Makefile
++++ b/usr/Makefile
+@@ -50,20 +50,22 @@ ifneq ($(wildcard $(obj)/.initramfs_data
+ 	include $(obj)/.initramfs_data.cpio.d
+ endif
+ 
++deps_initramfs_sane := $(foreach v,$(deps_initramfs),$(if $(findstring :,$(v)),,$(v)))
++
+ quiet_cmd_initfs = GEN     $@
+       cmd_initfs = $(initramfs) -o $@ $(ramfs-args) $(ramfs-input)
+ 
+ targets := initramfs_data.cpio.gz initramfs_data.cpio.bz2 initramfs_data.cpio.lzma initramfs_data.cpio.xz initramfs_data.cpio.lzo initramfs_data.cpio
+ # do not try to update files included in initramfs
+-$(deps_initramfs): ;
++$(deps_initramfs_sane): ;
+ 
+-$(deps_initramfs): klibcdirs
++$(deps_initramfs_sane): klibcdirs
+ # We rebuild initramfs_data.cpio if:
+ # 1) Any included file is newer then initramfs_data.cpio
+ # 2) There are changes in which files are included (added or deleted)
+ # 3) If gen_init_cpio are newer than initramfs_data.cpio
+ # 4) arguments to gen_initramfs.sh changes
+-$(obj)/initramfs_data.cpio$(suffix_y): $(obj)/gen_init_cpio $(deps_initramfs) klibcdirs
++$(obj)/initramfs_data.cpio$(suffix_y): $(obj)/gen_init_cpio $(deps_initramfs_sane) klibcdirs
+ 	$(Q)$(initramfs) -l $(ramfs-input) > $(obj)/.initramfs_data.cpio.d
+ 	$(call if_changed,initfs)
+ 
diff --git a/target/linux/generic/patches-3.10/980-arm_openwrt_machtypes.patch b/target/linux/generic/patches-3.10/980-arm_openwrt_machtypes.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/980-arm_openwrt_machtypes.patch
@@ -0,0 +1,32 @@
+--- a/arch/arm/tools/mach-types
++++ b/arch/arm/tools/mach-types
+@@ -1007,3 +1007,29 @@ eco5_bx2		MACH_ECO5_BX2		ECO5_BX2		4572
+ eukrea_cpuimx28sd	MACH_EUKREA_CPUIMX28SD	EUKREA_CPUIMX28SD	4573
+ domotab			MACH_DOMOTAB		DOMOTAB			4574
+ pfla03			MACH_PFLA03		PFLA03			4575
++#
++# Additional mach-types supported by OpenWrt
++#
++wg302v1			MACH_WG302V1		WG302V1			889
++pronghorn		MACH_PRONGHORN		PRONGHORN		928
++pronghorn_metro		MACH_PRONGHORNMETRO	PRONGHORNMETRO		1040
++sidewinder		MACH_SIDEWINDER		SIDEWINDER		1041
++wrt300nv2		MACH_WRT300NV2		WRT300NV2		1077
++compex42x		MACH_COMPEXWP18		COMPEXWP18		1273
++goldfish		MACH_GOLDFISH		GOLDFISH		1441
++cambria			MACH_CAMBRIA		CAMBRIA			1468
++dt2			MACH_DT2		DT2			1514
++ap1000			MACH_AP1000		AP1000			1543
++tw2662			MACH_TW2662		TW2662			1658
++tw5334			MACH_TW5334		TW5334			1664
++usr8200			MACH_USR8200		USR8200			1762
++mi424wr			MACH_MI424WR		MI424WR			1778
++gw2388			MACH_GW2388		GW2388			2635
++iconnect		MACH_ICONNECT		ICONNECT		2870
++nsb3ast			MACH_NSB3AST		NSB3AST			2917
++goflexnet		MACH_GOFLEXNET		GOFLEXNET		3089
++nas6210			MACH_NAS6210		NAS6210			3104
++ns_k330			MACH_NS_K330		NS_K330			3108
++bcm2708			MACH_BCM2708		BCM2708			3138
++wn802t			MACH_WN802T		WN802T			3306
++nsa310			MACH_NSA310		NSA310			4022
diff --git a/target/linux/generic/patches-3.10/990-gpio_wdt.patch b/target/linux/generic/patches-3.10/990-gpio_wdt.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/990-gpio_wdt.patch
@@ -0,0 +1,360 @@
+This generic GPIO watchdog is used on Huawei E970 (brcm47xx)
+
+Signed-off-by: Mathias Adam <m.adam--openwrt@adamis.de>
+
+--- a/drivers/watchdog/Kconfig
++++ b/drivers/watchdog/Kconfig
+@@ -1035,6 +1035,15 @@ config WDT_MTX1
+ 	  Hardware driver for the MTX-1 boards. This is a watchdog timer that
+ 	  will reboot the machine after a 100 seconds timer expired.
+ 
++config GPIO_WDT
++	tristate "GPIO Hardware Watchdog"
++ 	help
++	  Hardware driver for GPIO-controlled watchdogs. GPIO pin and
++	  toggle interval settings are platform-specific. The driver
++	  will stop toggling the GPIO (i.e. machine reboots) after a
++	  100 second timer expired and no process has written to
++	  /dev/watchdog during that time.
++
+ config PNX833X_WDT
+ 	tristate "PNX833x Hardware Watchdog"
+ 	depends on SOC_PNX8335
+--- a/drivers/watchdog/Makefile
++++ b/drivers/watchdog/Makefile
+@@ -127,6 +127,7 @@ obj-$(CONFIG_RC32434_WDT) += rc32434_wdt
+ obj-$(CONFIG_INDYDOG) += indydog.o
+ obj-$(CONFIG_JZ4740_WDT) += jz4740_wdt.o
+ obj-$(CONFIG_WDT_MTX1) += mtx-1_wdt.o
++obj-$(CONFIG_GPIO_WDT) += gpio_wdt.o
+ obj-$(CONFIG_PNX833X_WDT) += pnx833x_wdt.o
+ obj-$(CONFIG_SIBYTE_WDOG) += sb_wdog.o
+ obj-$(CONFIG_AR7_WDT) += ar7_wdt.o
+--- /dev/null
++++ b/drivers/watchdog/gpio_wdt.c
+@@ -0,0 +1,301 @@
++/*
++ *      Driver for GPIO-controlled Hardware Watchdogs.
++ *
++ *      Copyright (C) 2013 Mathias Adam <m.adam--linux@adamis.de>
++ *
++ *      Replaces mtx1_wdt (driver for the MTX-1 Watchdog):
++ *
++ *      (C) Copyright 2005 4G Systems <info@4g-systems.biz>,
++ *                              All Rights Reserved.
++ *                              http://www.4g-systems.biz
++ *
++ *      (C) Copyright 2007 OpenWrt.org, Florian Fainelli <florian@openwrt.org>
++ *
++ *      This program is free software; you can redistribute it and/or
++ *      modify it under the terms of the GNU General Public License
++ *      as published by the Free Software Foundation; either version
++ *      2 of the License, or (at your option) any later version.
++ *
++ *      Neither Michael Stickel nor 4G Systems admit liability nor provide
++ *      warranty for any of this software. This material is provided
++ *      "AS-IS" and at no charge.
++ *
++ *      (c) Copyright 2005    4G Systems <info@4g-systems.biz>
++ *
++ *      Release 0.01.
++ *      Author: Michael Stickel  michael.stickel@4g-systems.biz
++ *
++ *      Release 0.02.
++ *      Author: Florian Fainelli florian@openwrt.org
++ *              use the Linux watchdog/timer APIs
++ *
++ *      Release 0.03.
++ *      Author: Mathias Adam <m.adam--linux@adamis.de>
++ *              make it a generic gpio watchdog driver
++ *
++ *      The Watchdog is configured to reset the MTX-1
++ *      if it is not triggered for 100 seconds.
++ *      It should not be triggered more often than 1.6 seconds.
++ *
++ *      A timer triggers the watchdog every 5 seconds, until
++ *      it is opened for the first time. After the first open
++ *      it MUST be triggered every 2..95 seconds.
++ */
++
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/types.h>
++#include <linux/errno.h>
++#include <linux/miscdevice.h>
++#include <linux/fs.h>
++#include <linux/init.h>
++#include <linux/ioport.h>
++#include <linux/timer.h>
++#include <linux/completion.h>
++#include <linux/jiffies.h>
++#include <linux/watchdog.h>
++#include <linux/platform_device.h>
++#include <linux/io.h>
++#include <linux/uaccess.h>
++#include <linux/gpio.h>
++#include <linux/gpio_wdt.h>
++
++static int ticks = 100 * HZ;
++
++static struct {
++	struct completion stop;
++	spinlock_t lock;
++	int running;
++	struct timer_list timer;
++	int queue;
++	int default_ticks;
++	unsigned long inuse;
++	unsigned gpio;
++	unsigned int gstate;
++	int interval;
++	int first_interval;
++} gpio_wdt_device;
++
++static void gpio_wdt_trigger(unsigned long unused)
++{
++	spin_lock(&gpio_wdt_device.lock);
++	if (gpio_wdt_device.running && ticks > 0)
++		ticks -= gpio_wdt_device.interval;
++
++	/* toggle wdt gpio */
++	gpio_wdt_device.gstate = !gpio_wdt_device.gstate;
++	gpio_set_value(gpio_wdt_device.gpio, gpio_wdt_device.gstate);
++
++	if (gpio_wdt_device.queue && ticks > 0)
++		mod_timer(&gpio_wdt_device.timer, jiffies + gpio_wdt_device.interval);
++	else
++		complete(&gpio_wdt_device.stop);
++	spin_unlock(&gpio_wdt_device.lock);
++}
++
++static void gpio_wdt_reset(void)
++{
++	ticks = gpio_wdt_device.default_ticks;
++}
++
++
++static void gpio_wdt_start(void)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&gpio_wdt_device.lock, flags);
++	if (!gpio_wdt_device.queue) {
++		gpio_wdt_device.queue = 1;
++		gpio_wdt_device.gstate = 1;
++		gpio_set_value(gpio_wdt_device.gpio, 1);
++		mod_timer(&gpio_wdt_device.timer, jiffies + gpio_wdt_device.first_interval);
++	}
++	gpio_wdt_device.running++;
++	spin_unlock_irqrestore(&gpio_wdt_device.lock, flags);
++}
++
++static int gpio_wdt_stop(void)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&gpio_wdt_device.lock, flags);
++	if (gpio_wdt_device.queue) {
++		gpio_wdt_device.queue = 0;
++		gpio_wdt_device.gstate = 0;
++		gpio_set_value(gpio_wdt_device.gpio, 0);
++	}
++	ticks = gpio_wdt_device.default_ticks;
++	spin_unlock_irqrestore(&gpio_wdt_device.lock, flags);
++	return 0;
++}
++
++/* Filesystem functions */
++
++static int gpio_wdt_open(struct inode *inode, struct file *file)
++{
++	if (test_and_set_bit(0, &gpio_wdt_device.inuse))
++		return -EBUSY;
++	return nonseekable_open(inode, file);
++}
++
++
++static int gpio_wdt_release(struct inode *inode, struct file *file)
++{
++	clear_bit(0, &gpio_wdt_device.inuse);
++	return 0;
++}
++
++static long gpio_wdt_ioctl(struct file *file, unsigned int cmd,
++							unsigned long arg)
++{
++	void __user *argp = (void __user *)arg;
++	int __user *p = (int __user *)argp;
++	unsigned int value;
++	static const struct watchdog_info ident = {
++		.options = WDIOF_CARDRESET,
++		.identity = "GPIO WDT",
++	};
++
++	switch (cmd) {
++	case WDIOC_GETSUPPORT:
++		if (copy_to_user(argp, &ident, sizeof(ident)))
++			return -EFAULT;
++		break;
++	case WDIOC_GETSTATUS:
++	case WDIOC_GETBOOTSTATUS:
++		put_user(0, p);
++		break;
++	case WDIOC_SETOPTIONS:
++		if (get_user(value, p))
++			return -EFAULT;
++		if (value & WDIOS_ENABLECARD)
++			gpio_wdt_start();
++		else if (value & WDIOS_DISABLECARD)
++			gpio_wdt_stop();
++		else
++			return -EINVAL;
++		return 0;
++	case WDIOC_KEEPALIVE:
++		gpio_wdt_reset();
++		break;
++	default:
++		return -ENOTTY;
++	}
++	return 0;
++}
++
++
++static ssize_t gpio_wdt_write(struct file *file, const char *buf,
++						size_t count, loff_t *ppos)
++{
++	if (!count)
++		return -EIO;
++	gpio_wdt_reset();
++	return count;
++}
++
++static const struct file_operations gpio_wdt_fops = {
++	.owner		= THIS_MODULE,
++	.llseek		= no_llseek,
++	.unlocked_ioctl	= gpio_wdt_ioctl,
++	.open		= gpio_wdt_open,
++	.write		= gpio_wdt_write,
++	.release	= gpio_wdt_release,
++};
++
++
++static struct miscdevice gpio_wdt_misc = {
++	.minor	= WATCHDOG_MINOR,
++	.name	= "watchdog",
++	.fops	= &gpio_wdt_fops,
++};
++
++
++static int gpio_wdt_probe(struct platform_device *pdev)
++{
++	int ret;
++	struct gpio_wdt_platform_data *gpio_wdt_data = pdev->dev.platform_data;
++
++	gpio_wdt_device.gpio = gpio_wdt_data->gpio;
++	gpio_wdt_device.interval = gpio_wdt_data->interval;
++	gpio_wdt_device.first_interval = gpio_wdt_data->first_interval;
++	if (gpio_wdt_device.first_interval <= 0) {
++		gpio_wdt_device.first_interval = gpio_wdt_device.interval;
++	}
++
++	ret = gpio_request(gpio_wdt_device.gpio, "gpio-wdt");
++	if (ret < 0) {
++		dev_err(&pdev->dev, "failed to request gpio");
++		return ret;
++	}
++
++	spin_lock_init(&gpio_wdt_device.lock);
++	init_completion(&gpio_wdt_device.stop);
++	gpio_wdt_device.queue = 0;
++	clear_bit(0, &gpio_wdt_device.inuse);
++	setup_timer(&gpio_wdt_device.timer, gpio_wdt_trigger, 0L);
++	gpio_wdt_device.default_ticks = ticks;
++
++	gpio_wdt_start();
++	dev_info(&pdev->dev, "GPIO Hardware Watchdog driver (gpio=%i interval=%i/%i)\n",
++		gpio_wdt_data->gpio, gpio_wdt_data->first_interval, gpio_wdt_data->interval);
++	return 0;
++}
++
++static int gpio_wdt_remove(struct platform_device *pdev)
++{
++	/* FIXME: do we need to lock this test ? */
++	if (gpio_wdt_device.queue) {
++		gpio_wdt_device.queue = 0;
++		wait_for_completion(&gpio_wdt_device.stop);
++	}
++
++	gpio_free(gpio_wdt_device.gpio);
++	misc_deregister(&gpio_wdt_misc);
++	return 0;
++}
++
++static struct platform_driver gpio_wdt_driver = {
++	.probe = gpio_wdt_probe,
++	.remove = gpio_wdt_remove,
++	.driver.name = "gpio-wdt",
++	.driver.owner = THIS_MODULE,
++};
++
++static int __init gpio_wdt_init(void)
++{
++	return platform_driver_register(&gpio_wdt_driver);
++}
++arch_initcall(gpio_wdt_init);
++
++/*
++ * We do wdt initialization in two steps: arch_initcall probes the wdt
++ * very early to start pinging the watchdog (misc devices are not yet
++ * available), and later module_init() just registers the misc device.
++ */
++static int gpio_wdt_init_late(void)
++{
++	int ret;
++
++	ret = misc_register(&gpio_wdt_misc);
++	if (ret < 0) {
++		pr_err("GPIO_WDT: failed to register misc device\n");
++		return ret;
++	}
++	return 0;
++}
++#ifndef MODULE
++module_init(gpio_wdt_init_late);
++#endif
++
++static void __exit gpio_wdt_exit(void)
++{
++	platform_driver_unregister(&gpio_wdt_driver);
++}
++module_exit(gpio_wdt_exit);
++
++MODULE_AUTHOR("Michael Stickel, Florian Fainelli, Mathias Adam");
++MODULE_DESCRIPTION("Driver for GPIO hardware watchdogs");
++MODULE_LICENSE("GPL");
++MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
++MODULE_ALIAS("platform:gpio-wdt");
+--- /dev/null
++++ b/include/linux/gpio_wdt.h
+@@ -0,0 +1,21 @@
++/*
++ *  Definitions for the GPIO watchdog driver
++ *
++ *  Copyright (C) 2013 Mathias Adam <m.adam--linux@adamis.de>
++ *
++ *  This program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License version 2 as
++ *  published by the Free Software Foundation.
++ *
++ */
++
++#ifndef _GPIO_WDT_H_
++#define _GPIO_WDT_H_
++
++struct gpio_wdt_platform_data {
++	int	gpio;		/* GPIO line number */
++	int	interval;	/* watchdog reset interval in system ticks */
++	int	first_interval;	/* first wd reset interval in system ticks */
++};
++
++#endif /* _GPIO_WDT_H_ */
diff --git a/target/linux/generic/patches-3.10/992-mpcore_wdt_fix_watchdog_counter_loading.patch b/target/linux/generic/patches-3.10/992-mpcore_wdt_fix_watchdog_counter_loading.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/992-mpcore_wdt_fix_watchdog_counter_loading.patch
@@ -0,0 +1,75 @@
+Although the commit "98af057092f8f0dabe63c5df08adc2bbfbddb1d2
+ ARM: 6126/1: ARM mpcore_wdt: fix build failure and other fixes"
+resolved long standing mpcore_wdt driver build problems, it
+introduced an error in the relationship between the MPcore watchdog
+timer clock rate and mpcore_margin, "MPcore timer margin in seconds",
+such that watchdog timeouts are now arbitrary rather than the number
+of seconds specified by mpcore_margin.
+
+This change restores mpcore_wdt_keepalive() to its equivalent
+implementation prior to commit 98af057 such that watchdog timeouts now
+occur as specified by mpcore_margin.
+
+The variable 'mpcore_timer_rate' which caused that build failure was
+replaced by 'twd_timer_rate'. Adding exported function to obtain
+'twd_timer_rate' value in mpcore_wdt driver.
+
+MPCORE_WATCHDOG needed to build 'mpcore_wdt' already depends on
+HAVE_ARM_TWD needed to build 'smp_twd', so from the point of view of
+'mpcore_wdt' driver the exported function will always exist.
+
+Signed-off-by: Valentine Barshak <vbarshak@mvista.com>
+Signed-off-by: Vitaly Kuzmichev <vkuzmichev@mvista.com>
+---
+
+ arch/arm/include/asm/smp_twd.h |    1 +
+ arch/arm/kernel/smp_twd.c      |    7 +++++++
+ drivers/watchdog/mpcore_wdt.c  |    4 +---
+ 3 files changed, 9 insertions(+), 3 deletions(-)
+
+--- a/arch/arm/include/asm/smp_twd.h
++++ b/arch/arm/include/asm/smp_twd.h
+@@ -33,5 +33,6 @@ struct twd_local_timer name __initdata =
+ };
+ 
+ int twd_local_timer_register(struct twd_local_timer *);
++unsigned long twd_timer_get_rate(void);
+ 
+ #endif
+--- a/arch/arm/kernel/smp_twd.c
++++ b/arch/arm/kernel/smp_twd.c
+@@ -10,6 +10,7 @@
+  */
+ #include <linux/init.h>
+ #include <linux/kernel.h>
++#include <linux/export.h>
+ #include <linux/clk.h>
+ #include <linux/delay.h>
+ #include <linux/device.h>
+@@ -361,6 +362,13 @@ int __init twd_local_timer_register(stru
+ 	return twd_local_timer_common_register(NULL);
+ }
+ 
++/* Needed by mpcore_wdt */
++unsigned long twd_timer_get_rate(void)
++{
++	return twd_timer_rate;
++}
++EXPORT_SYMBOL_GPL(twd_timer_get_rate);
++
+ #ifdef CONFIG_OF
+ static void __init twd_local_timer_of_register(struct device_node *np)
+ {
+--- a/drivers/watchdog/mpcore_wdt.c
++++ b/drivers/watchdog/mpcore_wdt.c
+@@ -101,9 +101,7 @@ static void mpcore_wdt_keepalive(struct
+ 
+ 	spin_lock(&wdt_lock);
+ 	/* Assume prescale is set to 256 */
+-	count =  __raw_readl(wdt->base + TWD_WDOG_COUNTER);
+-	count = (0xFFFFFFFFU - count) * (HZ / 5);
+-	count = (count / 256) * mpcore_margin;
++	count = (twd_timer_get_rate() / 256) * mpcore_margin;
+ 
+ 	/* Reload the counter */
+ 	writel(count + wdt->perturb, wdt->base + TWD_WDOG_LOAD);
diff --git a/target/linux/generic/patches-3.10/993-mpcore_wdt_fix_wdioc_setoptions_handling.patch b/target/linux/generic/patches-3.10/993-mpcore_wdt_fix_wdioc_setoptions_handling.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/993-mpcore_wdt_fix_wdioc_setoptions_handling.patch
@@ -0,0 +1,29 @@
+According to the include/linux/watchdog.h WDIOC_SETOPTIONS is
+classified as 'read from device' ioctl call:
+  #define WDIOC_SETOPTIONS        _IOR(WATCHDOG_IOCTL_BASE, 4, int)
+
+However, the driver 'mpcore_wdt' performs 'copy_from_user' only if
+_IOC_WRITE is set, thus the local variable 'uarg' which is used in
+WDIOC_SETOPTIONS handling remains uninitialized.
+
+The proper way to fix this is to bind WDIOC_SETOPTIONS to _IOW,
+but this will break compatibility.
+So adding additional condition for performing 'copy_from_user'.
+
+Signed-off-by: Vitaly Kuzmichev <vkuzmichev@mvista.com>
+---
+ drivers/watchdog/mpcore_wdt.c |    3 ++-
+ 1 files changed, 2 insertions(+), 1 deletions(-)
+
+--- a/drivers/watchdog/mpcore_wdt.c
++++ b/drivers/watchdog/mpcore_wdt.c
+@@ -235,7 +235,8 @@ static long mpcore_wdt_ioctl(struct file
+ 	if (_IOC_DIR(cmd) && _IOC_SIZE(cmd) > sizeof(uarg))
+ 		return -ENOTTY;
+ 
+-	if (_IOC_DIR(cmd) & _IOC_WRITE) {
++	if ((_IOC_DIR(cmd) & _IOC_WRITE)
++			|| cmd == WDIOC_SETOPTIONS) {
+ 		ret = copy_from_user(&uarg, (void __user *)arg, _IOC_SIZE(cmd));
+ 		if (ret)
+ 			return -EFAULT;
diff --git a/target/linux/generic/patches-3.10/994-mpcore_wdt_fix_timer_mode_setup.patch b/target/linux/generic/patches-3.10/994-mpcore_wdt_fix_timer_mode_setup.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/994-mpcore_wdt_fix_timer_mode_setup.patch
@@ -0,0 +1,57 @@
+Allow watchdog to set its iterrupt as pending when it is configured
+for timer mode (in other words, allow emitting interrupt).
+Also add macros for all Watchdog Control Register flags.
+
+Signed-off-by: Vitaly Kuzmichev <vkuzmichev@mvista.com>
+---
+ arch/arm/include/asm/smp_twd.h |    6 ++++++
+ drivers/watchdog/mpcore_wdt.c  |   15 +++++++++++----
+ 2 files changed, 17 insertions(+), 4 deletions(-)
+
+--- a/arch/arm/include/asm/smp_twd.h
++++ b/arch/arm/include/asm/smp_twd.h
+@@ -18,6 +18,12 @@
+ #define TWD_TIMER_CONTROL_PERIODIC	(1 << 1)
+ #define TWD_TIMER_CONTROL_IT_ENABLE	(1 << 2)
+ 
++#define TWD_WDOG_CONTROL_ENABLE		(1 << 0)
++#define TWD_WDOG_CONTROL_PERIODIC	(1 << 1)
++#define TWD_WDOG_CONTROL_IT_ENABLE	(1 << 2)
++#define TWD_WDOG_CONTROL_TIMER_MODE	(0 << 3)
++#define TWD_WDOG_CONTROL_WATCHDOG_MODE	(1 << 3)
++
+ #include <linux/ioport.h>
+ 
+ struct twd_local_timer {
+--- a/drivers/watchdog/mpcore_wdt.c
++++ b/drivers/watchdog/mpcore_wdt.c
+@@ -120,18 +120,25 @@ static void mpcore_wdt_stop(struct mpcor
+ 
+ static void mpcore_wdt_start(struct mpcore_wdt *wdt)
+ {
++	u32 mode;
++
+ 	dev_info(wdt->dev, "enabling watchdog\n");
+ 
+ 	/* This loads the count register but does NOT start the count yet */
+ 	mpcore_wdt_keepalive(wdt);
+ 
++	/* Setup watchdog - prescale=256, enable=1 */
++	mode = (255 << 8) | TWD_WDOG_CONTROL_ENABLE;
++
+ 	if (mpcore_noboot) {
+-		/* Enable watchdog - prescale=256, watchdog mode=0, enable=1 */
+-		writel(0x0000FF01, wdt->base + TWD_WDOG_CONTROL);
++		/* timer mode, send interrupt */
++		mode |=	TWD_WDOG_CONTROL_TIMER_MODE |
++				TWD_WDOG_CONTROL_IT_ENABLE;
+ 	} else {
+-		/* Enable watchdog - prescale=256, watchdog mode=1, enable=1 */
+-		writel(0x0000FF09, wdt->base + TWD_WDOG_CONTROL);
++		/* watchdog mode */
++		mode |=	TWD_WDOG_CONTROL_WATCHDOG_MODE;
+ 	}
++	writel(mode, wdt->base + TWD_WDOG_CONTROL);
+ }
+ 
+ static int mpcore_wdt_set_heartbeat(int t)
diff --git a/target/linux/generic/patches-3.10/995-mpcore_twd_calibrate_single_core.patch b/target/linux/generic/patches-3.10/995-mpcore_twd_calibrate_single_core.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/995-mpcore_twd_calibrate_single_core.patch
@@ -0,0 +1,23 @@
+--- a/arch/arm/kernel/smp_twd.c
++++ b/arch/arm/kernel/smp_twd.c
+@@ -188,7 +188,7 @@ core_initcall(twd_cpufreq_init);
+ 
+ #endif
+ 
+-static void __cpuinit twd_calibrate_rate(void)
++static int twd_calibrate_rate(void)
+ {
+ 	unsigned long count;
+ 	u64 waitjiffies;
+@@ -225,8 +225,11 @@ static void __cpuinit twd_calibrate_rate
+ 		printk("%lu.%02luMHz.\n", twd_timer_rate / 1000000,
+ 			(twd_timer_rate / 10000) % 100);
+ 	}
++	return 0;
+ }
+ 
++device_initcall(twd_calibrate_rate);
++
+ static irqreturn_t twd_handler(int irq, void *dev_id)
+ {
+ 	struct clock_event_device *evt = *(struct clock_event_device **)dev_id;
diff --git a/target/linux/generic/patches-3.10/996-zsmalloc_allow_module_build.patch b/target/linux/generic/patches-3.10/996-zsmalloc_allow_module_build.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/996-zsmalloc_allow_module_build.patch
@@ -0,0 +1,9 @@
+--- a/drivers/staging/zsmalloc/Kconfig
++++ b/drivers/staging/zsmalloc/Kconfig
+@@ -1,5 +1,5 @@
+ config ZSMALLOC
+-	bool "Memory allocator for compressed pages"
++	tristate "Memory allocator for compressed pages"
+ 	default n
+ 	help
+ 	  zsmalloc is a slab-based memory allocator designed to store
diff --git a/target/linux/generic/patches-3.10/997-device_tree_cmdline.patch b/target/linux/generic/patches-3.10/997-device_tree_cmdline.patch
new file mode 100644
--- /dev/null
+++ b/target/linux/generic/patches-3.10/997-device_tree_cmdline.patch
@@ -0,0 +1,12 @@
+--- a/drivers/of/fdt.c
++++ b/drivers/of/fdt.c
+@@ -679,6 +679,9 @@ int __init early_init_dt_scan_chosen(uns
+ 	p = of_get_flat_dt_prop(node, "bootargs", &l);
+ 	if (p != NULL && l > 0)
+ 		strlcpy(data, p, min((int)l, COMMAND_LINE_SIZE));
++	p = of_get_flat_dt_prop(node, "bootargs-append", &l);
++	if (p != NULL && l > 0)
++		strlcat(data, p, min(strlen(data) + (int)l, COMMAND_LINE_SIZE));
+ 
+ 	/*
+ 	 * CONFIG_CMDLINE is meant to be a default in case nothing else
